{"example_id": 904, "sql_complexity": "basic SQL", "prompt": "What is the minimum Shariah-compliant loan amount issued in the last quarter of 2021?", "context": "CREATE TABLE loans (id INT, amount DECIMAL, date DATE, loan_type VARCHAR); INSERT INTO loans (id, amount, date, loan_type) VALUES (1, 5000, '2021-09-05', 'Shariah-compliant'), (2, 7000, '2021-10-07', 'socially responsible'), (3, 9000, '2021-11-03', 'Shariah-compliant'), (4, 11000, '2021-12-31', 'Shariah-compliant');", "reference_sql": "SELECT MIN(amount) FROM loans WHERE EXTRACT(YEAR FROM date) = 2021 AND EXTRACT(QUARTER FROM date) = 4 AND loan_type = 'Shariah-compliant';", "generated_sql": "SELECT MIN(amount) \nFROM loans \nWHERE date >= '2021-10-01' AND date < '2022-01-01' AND loan_type = 'Shariah-compliant';", "raw_model_output": "```sql\nSELECT MIN(amount) \nFROM loans \nWHERE date >= '2021-10-01' AND date < '2022-01-01' AND loan_type = 'Shariah-compliant';\n```\n\nThis SQL statement selects the minimum amount from the `loans` table where the `date` falls within the last quarter of 2021 (October to December) and the `loan_type` is 'Shariah-compliant'.", "latency_sec": 1.9205119609832764, "total_duration_sec": 1.632239922, "load_duration_sec": 0.890215549, "tokens_prompt": 220, "prompt_eval_sec": 0.130626654, "tokens_completion": 94, "completion_eval_sec": 0.610089968, "tokens_total": 314, "tokens_per_sec": 163.4980705036777, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter loans with 'Shariah-compliant' type and dates in the fourth quarter of 2021. The reference query uses EXTRACT(YEAR=2021 AND QUARTER=4) while the generated query uses date range '2021-10-01' to '2022-01-01', which covers the same period (October-December 2021). The MIN(amount) calculation will yield identical results as the filtered rows are the same.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify the minimum Shariah-compliant loan amount in Q4 2021. The reference query uses EXTRACT(QUARTER) to filter Q4, while the generated query uses a date range ('2021-10-01' to '2022-01-01') which explicitly captures October-December 2021. Both approaches are logically equivalent for this dataset. However, the generated query is more efficient as date ranges can leverage indexes on the 'date' column, whereas EXTRACT() may not. The generated query also avoids potential ambiguity in quarter calculations across different SQL dialects. Both fulfill the business intent, but the generated version is more elegant and performant.", "overall_assessment": "correct"}}
{"example_id": 1373, "sql_complexity": "subqueries", "prompt": "What is the total value of military equipment sales to Africa in the last 12 months?", "context": "CREATE TABLE Military_Equipment_Sales(sale_id INT, sale_date DATE, equipment_type VARCHAR(50), country VARCHAR(50), sale_value DECIMAL(10,2));", "reference_sql": "SELECT SUM(sale_value) FROM Military_Equipment_Sales WHERE country IN (SELECT country FROM World_Countries WHERE continent = 'Africa') AND sale_date >= DATE_SUB(CURRENT_DATE, INTERVAL 12 MONTH);", "generated_sql": "SELECT SUM(T1.sale_value) \nFROM Military_Equipment_Sales AS T1 \nINNER JOIN Military_Equipment_Sales AS T2 ON T1.sale_id = T2.sale_id \nWHERE T1.country = 'Africa' AND T2.sale_date BETWEEN CURRENT_DATE - INTERVAL '12 month' AND CURRENT_DATE;", "raw_model_output": "```sql\nSELECT SUM(T1.sale_value) \nFROM Military_Equipment_Sales AS T1 \nINNER JOIN Military_Equipment_Sales AS T2 ON T1.sale_id = T2.sale_id \nWHERE T1.country = 'Africa' AND T2.sale_date BETWEEN CURRENT_DATE - INTERVAL '12 month' AND CURRENT_DATE;\n```\n\nHowever, the above query is not efficient as it joins the table with itself. A more efficient approach would be to use a subquery or window function.\n\n```sql\nSELECT SUM(T1.sale_value) \nFROM Military_Equipment_Sales AS T1 \nWHERE T1.country = 'Africa' AND T1.sale_date BETWEEN CURRENT_DATE - INTERVAL '12 month' AND CURRENT_DATE;\n```\n\nOr, using window functions:\n\n```sql\nSELECT SUM(sale_value) OVER (PARTITION BY country ORDER BY sale_date DESC) as total_value \nFROM Military_Equipment_Sales \nWHERE country = 'Africa' AND sale_date BETWEEN CURRENT_DATE - INTERVAL '12 month' AND CURRENT_DATE;\n```", "latency_sec": 1.563701868057251, "total_duration_sec": 1.404508449, "load_duration_sec": 0.014653396, "tokens_prompt": 136, "prompt_eval_sec": 0.005595704, "tokens_completion": 212, "completion_eval_sec": 1.383606882, "tokens_total": 348, "tokens_per_sec": 222.5488164392593, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their country filtering logic. The Reference SQL uses a subquery to select countries in Africa from World_Countries, while the Generated SQL incorrectly checks for T1.country = 'Africa' (a continent name, not a country). Additionally, the Generated SQL performs a redundant self-join on sale_id, which doesn't affect the result but indicates a logical discrepancy. The date conditions are similar but not identical in implementation.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly identifies African countries via a subquery on World_Countries and filters sales within the last 12 months using DATE_SUB. The Generated SQL has critical flaws: 1) It self-joins Military_Equipment_Sales on sale_id (redundant and incorrect), 2) It incorrectly filters T1.country = 'Africa' (assuming country column stores continent names instead of country names), 3) The JOIN would cause duplicate rows and inflate the SUM. The Generated SQL's logic would produce incorrect totals and misinterpret the data schema.", "overall_assessment": "incorrect"}}
{"example_id": 5039, "sql_complexity": "subqueries", "prompt": "What is the total number of community policing events in 'City Park' in 2021?", "context": "CREATE TABLE locations (id INT, name VARCHAR(255)); CREATE TABLE community_policing (id INT, location_id INT, year INT, events INT); INSERT INTO locations (id, name) VALUES (1, 'City Park'); INSERT INTO community_policing (id, location_id, year, events) VALUES (1, 1, 2021, 5);", "reference_sql": "SELECT SUM(events) FROM community_policing WHERE location_id = (SELECT id FROM locations WHERE name = 'City Park') AND year = 2021;", "generated_sql": "SELECT SUM(events)\nFROM community_policing\nWHERE location_id = 1 AND year = 2021;", "raw_model_output": "```sql\nSELECT SUM(events)\nFROM community_policing\nWHERE location_id = 1 AND year = 2021;\n```\n\nThis SQL statement will return the total number of community policing events that occurred in 'City Park' in 2021. It filters the results to only include rows where `location_id` is 1 (corresponding to 'City Park') and `year` is 2021, then sums up the `events` column for those rows.", "latency_sec": 0.8044989109039307, "total_duration_sec": 0.669426605, "load_duration_sec": 0.017240105, "tokens_prompt": 179, "prompt_eval_sec": 0.002825877, "tokens_completion": 99, "completion_eval_sec": 0.648812451, "tokens_total": 278, "tokens_per_sec": 345.5567139148028, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of 'events' for the community_policing record where location_id corresponds to 'City Park' (id=1) and year=2021. The Reference SQL uses a subquery to get the location_id dynamically, while the Generated SQL hardcodes it as 1. Since the subquery would return 1 (from the given data), both queries target the same row and produce identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries produce identical results by filtering community_policing records for 'City Park' (via location_id=1) in 2021. The reference query explicitly links the location name to its ID through a subquery, directly addressing the business intent of using the park's name as specified in the question. The generated query assumes prior knowledge of the location_id (1), which is technically correct but less intuitive for end-users. While both are valid, the reference better aligns with the original question's phrasing and is more maintainable if location names/IDs change.", "overall_assessment": "correct"}}
{"example_id": 4932, "sql_complexity": "basic SQL", "prompt": "Delete the workout row with the id of 2.", "context": "CREATE TABLE Workouts (id INT, user_id INT, workout_name TEXT, calories INT); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (1, 1, 'Running', 300); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (2, 1, 'Cycling', 400); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (3, 2, 'Yoga', 200);", "reference_sql": "DELETE FROM Workouts WHERE id = 2;", "generated_sql": "DELETE FROM Workouts WHERE id = 2;", "raw_model_output": "```sql\nDELETE FROM Workouts WHERE id = 2;\n```\n\nThis SQL statement directly deletes the row from the `Workouts` table where the `id` is equal to 2. It adheres to standard ANSI SQL syntax and only references columns present in the provided schema.", "latency_sec": 0.6501438617706299, "total_duration_sec": 0.411946501, "load_duration_sec": 0.014590169, "tokens_prompt": 198, "prompt_eval_sec": 0.003552942, "tokens_completion": 59, "completion_eval_sec": 0.393265485, "tokens_total": 257, "tokens_per_sec": 395.2971259315978, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They both delete the record from the Workouts table where the id is 2. The SQL syntax, table name, and WHERE condition are exactly the same in both statements.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical: DELETE FROM Workouts WHERE id = 2;. They correctly delete the specific row with id=2 as required. The query is technically correct, semantically equivalent, and fulfills the business intent of removing the targeted workout record. The simplicity and precision of the query make it both efficient and elegant.", "overall_assessment": "correct"}}
{"example_id": 4637, "sql_complexity": "single join", "prompt": "What is the total value of transactions for each customer in the last 30 days?", "context": "CREATE TABLE transactions (id INT, customer_id INT, value DECIMAL(10, 2), transaction_date DATE); INSERT INTO transactions (id, customer_id, value, transaction_date) VALUES (1, 1, 100, '2022-01-01'), (2, 1, 200, '2022-01-15'), (3, 2, 50, '2022-01-05'), (4, 2, 150, '2022-01-30'), (5, 3, 300, '2022-01-20');", "reference_sql": "SELECT c.id, SUM(t.value) FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE t.transaction_date >= CURDATE() - INTERVAL 30 DAY GROUP BY c.id;", "generated_sql": "SELECT \n    t.customer_id,\n    SUM(t.value) AS total_value\nFROM \n    transactions t\nWHERE \n    t.transaction_date >= DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY)\nGROUP BY \n    t.customer_id;", "raw_model_output": "```sql\nSELECT \n    t.customer_id,\n    SUM(t.value) AS total_value\nFROM \n    transactions t\nWHERE \n    t.transaction_date >= DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY)\nGROUP BY \n    t.customer_id;\n```\n\nThis SQL statement:\n\n1. Selects the `customer_id` and calculates the sum of `value` for each customer.\n2. Filters transactions that occurred in the last 30 days by comparing the `transaction_date` with a date 30 days ago from the current date.\n3. Groups the results by `customer_id`.", "latency_sec": 1.0204930305480957, "total_duration_sec": 0.818946108, "load_duration_sec": 0.015077634, "tokens_prompt": 223, "prompt_eval_sec": 0.003736999, "tokens_completion": 120, "completion_eval_sec": 0.799613013, "tokens_total": 343, "tokens_per_sec": 336.112045582299, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the total transaction value per customer for the last 30 days. The Reference SQL uses an INNER JOIN between customers and transactions, while the Generated SQL directly groups transactions by customer_id. Since the WHERE clause filters transactions to the last 30 days, both approaches yield the same customer_id and SUM(value) results. The GROUP BY and aggregate logic are equivalent, and the JOIN in the Reference SQL doesn't affect the outcome because it's implicitly restricted by the date filter.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the total transaction value per customer for the last 30 days. The Reference query uses an unnecessary INNER JOIN with the customers table, which adds computational overhead without providing additional value since customer_id is already present in the transactions table. The Generated query directly groups by customer_id from the transactions table, achieving the same result with simpler, more efficient logic. Both handle date filtering equivalently (CURDATE() - INTERVAL 30 DAY vs. DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY)), and both group by customer identifiers (c.id vs. t.customer_id) which are functionally equivalent in this context. The Generated query is more efficient due to the absence of a redundant join.", "overall_assessment": "correct"}}
{"example_id": 3704, "sql_complexity": "aggregation", "prompt": "What is the total sales revenue for each category of garments in the South America region in Q1 2022?", "context": "CREATE TABLE sales_category (sale_id INT, garment_category VARCHAR(50), sale_date DATE, total_sales DECIMAL(10, 2), region VARCHAR(50));", "reference_sql": "SELECT garment_category, SUM(total_sales) FROM sales_category WHERE sale_date BETWEEN '2022-01-01' AND '2022-03-31' AND region = 'South America' GROUP BY garment_category;", "generated_sql": "SELECT \n    garment_category,\n    SUM(total_sales) AS total_revenue\nFROM \n    sales_category\nWHERE \n    region = 'South America' AND EXTRACT(MONTH FROM sale_date) BETWEEN 1 AND 3 AND YEAR(sale_date) = 2022\nGROUP BY \n    garment_category;", "raw_model_output": "```sql\nSELECT \n    garment_category,\n    SUM(total_sales) AS total_revenue\nFROM \n    sales_category\nWHERE \n    region = 'South America' AND EXTRACT(MONTH FROM sale_date) BETWEEN 1 AND 3 AND YEAR(sale_date) = 2022\nGROUP BY \n    garment_category;\n```\n\nThis SQL statement:\n\n- Selects the `garment_category` and calculates the sum of `total_sales` for each category.\n- Filters rows where the `region` is 'South America', the month of `sale_date` is between 1 and 3 (i.e., Q1), and the year of `sale_date` is 2022.\n- Groups the results by `garment_category`.", "latency_sec": 1.2023589611053467, "total_duration_sec": 1.034481632, "load_duration_sec": 0.030891039, "tokens_prompt": 139, "prompt_eval_sec": 0.004445384, "tokens_completion": 154, "completion_eval_sec": 0.998453053, "tokens_total": 293, "tokens_per_sec": 243.68762530836938, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries aggregate total_sales by garment_category for South America during Q1 2022. The reference uses a date range (BETWEEN '2022-01-01' AND '2022-03-31') while the generated query uses EXTRACT(MONTH) BETWEEN 1-3 and YEAR(sale_date)=2022. These conditions are logically equivalent for filtering dates in January-March 2022. The SUM alias difference (total_revenue vs. implicit name) doesn't affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate total sales revenue per garment category in South America for Q1 2022. The Reference SQL uses a simple date range filter (BETWEEN '2022-01-01' AND '2022-03-31') which is semantically equivalent to the Generated SQL's combination of EXTRACT(MONTH) BETWEEN 1-3 AND YEAR(sale_date) = 2022. Both achieve the same grouping and aggregation. The Reference is more concise and likely more efficient due to direct date comparison, while the Generated version explicitly separates month/year logic. However, both produce identical results and meet the business requirements.", "overall_assessment": "correct"}}
{"example_id": 382, "sql_complexity": "window functions", "prompt": "What is the average annual precipitation in the past 10 years for each weather station?", "context": "CREATE TABLE WeatherStation (ID INT, Name VARCHAR(100), Location VARCHAR(100), Elevation FLOAT, AnnualPrecipitation FLOAT); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (1, 'Station A', 'Arctic Circle', 100, 450); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (2, 'Station B', 'North Pole', 200, 300);", "reference_sql": "SELECT Name, AVG(AnnualPrecipitation) OVER (PARTITION BY Name ORDER BY Name ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS AvgAnnualPrecipitation FROM WeatherStation WHERE YEAR(CurrentDate) - YEAR(DateInstalled) BETWEEN 1 AND 10;", "generated_sql": "SELECT \n    W.Name,\n    AVG(WP.AnnualPrecipitation) AS AverageAnnualPrecipitation\nFROM \n    WeatherStation W\nJOIN \n    (SELECT \n         StationID, \n         YEAR(RecordDate) AS RecordYear, \n         AnnualPrecipitation\n     FROM \n         PrecipitationRecords \n     WHERE \n         RecordYear >= DATE_TRUNC('year', CURRENT_DATE) - INTERVAL '10 year') WP ON W.ID = WP.StationID\nGROUP BY \n    W.Name;", "raw_model_output": "```sql\nSELECT \n    W.Name,\n    AVG(WP.AnnualPrecipitation) AS AverageAnnualPrecipitation\nFROM \n    WeatherStation W\nJOIN \n    (SELECT \n         StationID, \n         YEAR(RecordDate) AS RecordYear, \n         AnnualPrecipitation\n     FROM \n         PrecipitationRecords \n     WHERE \n         RecordYear >= DATE_TRUNC('year', CURRENT_DATE) - INTERVAL '10 year') WP ON W.ID = WP.StationID\nGROUP BY \n    W.Name;\n```\n\nHowever, the above SQL query assumes that there is a `PrecipitationRecords` table with columns `StationID`, `RecordDate`, and `AnnualPrecipitation`. \n\nIf this table does not exist in your schema, you would need to create it first. Here's an example of how you could do that:\n\n```sql\nCREATE TABLE PrecipitationRecords (\n    StationID INT,\n    RecordDate DATE,\n    AnnualPrecipitation FLOAT\n);\n```\n\nAlso note that the above SQL query assumes that `RecordDate` is a date column and not a timestamp or datetime column. If it's a timestamp or datetime column, you would need to adjust the query accordingly.\n\n### Alternative Solution\n\nIf you don't have a separate table for precipitation records, you could also calculate the average annual precipitation directly from the `WeatherStation` table:\n\n```sql\nSELECT \n    W.Name,\n    AVG(WP.AnnualPrecipitation) AS AverageAnnualPrecipitation\nFROM \n    WeatherStation W\nJOIN \n    (SELECT \n         StationID, \n         YEAR(RecordDate) AS RecordYear, \n         AnnualPrecipitation\n     FROM \n         PrecipitationRecords \n     WHERE \n         RecordYear >= DATE_TRUNC('year', CURRENT_DATE) - INTERVAL '10 year') WP ON W.ID = WP.StationID\nGROUP BY \n    W.Name;\n```\n\nHowever, this would require you to have a `RecordDate` column in the `WeatherStation` table. \n\n### Final Solution\n\nIf none of the above solutions work for your schema, here's an alternative solution that calculates the average annual precipitation directly from the `WeatherStation` table:\n\n```sql\nSELECT \n    W.Name,\n    AVG(WP.AnnualPrecipitation) AS AverageAnnualPrecipitation\nFROM \n    WeatherStation W\nJOIN \n    (SELECT \n         StationID, \n         YEAR(RecordDate) AS RecordYear, \n         AnnualPrecipitation\n     FROM \n         PrecipitationRecords \n     WHERE \n         RecordYear >= DATE_TRUNC('year', CURRENT_DATE) - INTERVAL '10 year') WP ON W.ID = WP.StationID\nGROUP BY \n    W.Name;\n```\n\nThis solution assumes that you have a `RecordDate` column in the `WeatherStation` table. \n\n### SQL with subquery\n\n```sql\nSELECT Name, AverageAnnualPrecipitation\nFROM (\n  SELECT W.Name, AVG(P.AnnualPrecipitation) AS AverageAnnualPrecipitation\n  FROM WeatherStation W\n  JOIN PrecipitationRecords P ON W.ID = P.StationID\n  WHERE P.RecordYear >= DATE_TRUNC('year', CURRENT_DATE) - INTERVAL '10 year'\n  GROUP BY W.Name\n) AS Subquery;\n```", "latency_sec": 4.753841876983643, "total_duration_sec": 4.532326923, "load_duration_sec": 0.025731632, "tokens_prompt": 202, "prompt_eval_sec": 0.003354869, "tokens_completion": 679, "completion_eval_sec": 4.50259722, "tokens_total": 881, "tokens_per_sec": 185.32379132454503, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL references non-existent columns (DateInstalled, CurrentDate) and uses a window function on WeatherStation, while the Generated SQL joins with a non-existent PrecipitationRecords table and calculates an aggregate. The conditions and data sources differ fundamentally.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "equal", "explanation": "Both queries have critical issues. The Reference SQL references a non-existent 'DateInstalled' column and incorrectly uses a window function on a single value (AnnualPrecipitation) which would just return the same value for each row. The Generated SQL assumes a 'PrecipitationRecords' table that doesn't exist in the provided schema. Neither query correctly addresses the business intent because the WeatherStation table only contains a single AnnualPrecipitation value per station, making 'average over 10 years' impossible with the given schema. The Reference SQL's WHERE clause also contains a logical error (YEAR(CurrentDate) - YEAR(DateInstalled) between 1-10) that doesn't align with the 'past 10 years' requirement.", "overall_assessment": "incorrect"}}
{"example_id": 5168, "sql_complexity": "aggregation", "prompt": "Get the number of renewable energy projects in Australia for each project type.", "context": "CREATE TABLE renewable_projects (id INT PRIMARY KEY, project_name VARCHAR(255), project_location VARCHAR(255), project_type VARCHAR(255), capacity_mw FLOAT);", "reference_sql": "SELECT project_type, COUNT(*) FROM renewable_projects WHERE project_location = 'Australia' GROUP BY project_type;", "generated_sql": "SELECT \n    project_type,\n    COUNT(*) AS num_projects\nFROM \n    renewable_projects\nWHERE \n    project_location = 'Australia'\nGROUP BY \n    project_type;", "raw_model_output": "```sql\nSELECT \n    project_type,\n    COUNT(*) AS num_projects\nFROM \n    renewable_projects\nWHERE \n    project_location = 'Australia'\nGROUP BY \n    project_type;\n```\n\nThis SQL statement:\n\n1. Selects the `project_type` column.\n2. Counts the number of rows for each group using the `COUNT(*)` aggregation function.\n3. Filters the results to only include projects located in Australia.\n4. Groups the remaining results by `project_type`.", "latency_sec": 0.6684169769287109, "total_duration_sec": 0.658375803, "load_duration_sec": 0.01428834, "tokens_prompt": 129, "prompt_eval_sec": 0.003027354, "tokens_completion": 99, "completion_eval_sec": 0.640538797, "tokens_total": 228, "tokens_per_sec": 341.1044420918666, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. The generated query adds an explicit column alias ('num_projects') for COUNT(*), but this does not affect the actual data returned. Both queries filter by 'Australia', group by project_type, and count the number of projects per type. The result set structure (grouping and aggregation) remains identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically correct and produce identical results. The reference query is functionally equivalent to the generated query, as both count projects by type in Australia. The generated query improves on readability by explicitly aliasing the count column as 'num_projects', making the output more self-documenting. While the reference query is concise, the generated version better addresses the business intent by providing clearer column naming without altering the core logic. Both are efficient, but the generated query's explicit alias enhances usability for end-users.", "overall_assessment": "correct"}}
{"example_id": 4669, "sql_complexity": "set operations", "prompt": "Identify the number of IoT devices in each country and the total number of devices.", "context": "CREATE TABLE device_country (device_id INT, country TEXT); INSERT INTO device_country (device_id, country) VALUES (1, 'USA'), (2, 'Canada'), (3, 'Mexico'), (4, 'Brazil'); CREATE TABLE device_info (device_id INT, device_type TEXT); INSERT INTO device_info (device_id, device_type) VALUES (1, 'Soil Sensor'), (2, 'Temperature Sensor'), (3, 'Humidity Sensor'), (4, 'Precision Sprayer');", "reference_sql": "SELECT country, COUNT(*) AS device_count FROM device_country GROUP BY country UNION SELECT 'Total' AS country, COUNT(*) FROM device_country;", "generated_sql": "SELECT \n  d.country,\n  COUNT(d.device_id) AS num_devices,\n  COALESCE(SUM(di.num_devices), 0) AS total_num_devices\nFROM \n  device_country d\nLEFT JOIN \n  (\n    SELECT \n      country, \n      COUNT(device_id) AS num_devices\n    FROM \n      device_info\n    GROUP BY \n      country\n  ) di ON d.country = di.country\nGROUP BY \n  d.country;", "raw_model_output": "```sql\nSELECT \n  d.country,\n  COUNT(d.device_id) AS num_devices,\n  COALESCE(SUM(di.num_devices), 0) AS total_num_devices\nFROM \n  device_country d\nLEFT JOIN \n  (\n    SELECT \n      country, \n      COUNT(device_id) AS num_devices\n    FROM \n      device_info\n    GROUP BY \n      country\n  ) di ON d.country = di.country\nGROUP BY \n  d.country;\n```\n\nThis SQL statement first joins the `device_country` table with a subquery that counts the number of devices in each country. The `LEFT JOIN` ensures that all countries are included, even if there are no devices in them.\n\nThe `COALESCE` function is used to replace `NULL` values (which would occur if a country has no devices) with 0, so that we can calculate the total number of devices for each country. The `SUM(di.num_devices)` expression calculates the total number of devices across all countries.", "latency_sec": 1.5424919128417969, "total_duration_sec": 1.382662632, "load_duration_sec": 0.014952247, "tokens_prompt": 202, "prompt_eval_sec": 0.00326576, "tokens_completion": 207, "completion_eval_sec": 1.363897958, "tokens_total": 409, "tokens_per_sec": 265.1553610070359, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL counts devices in device_country and adds a total row. The Generated SQL attempts to join device_country with a subquery that incorrectly references a 'country' column in device_info (which doesn't exist), leading to invalid syntax. Additionally, the Generated SQL returns different columns (num_devices and total_num_devices) compared to the Reference SQL's single device_count column. The structure and logic differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The Reference SQL correctly addresses the question by first grouping device_country by country to get device counts, then using UNION to add a 'Total' row. The Generated SQL contains critical errors: 1) The subquery in the LEFT JOIN references 'country' from device_info, which doesn't exist in that table. 2) The logic for calculating totals is flawed as it attempts to sum device counts from a non-existent column. The Reference SQL is technically correct, semantically equivalent, and efficiently solves the problem. The Generated SQL fails both technically and semantically.", "overall_assessment": "incorrect"}}
{"example_id": 4573, "sql_complexity": "subqueries", "prompt": "Find the names of all the indigenous communities in the 'Arctic_Communities' table that have a population size greater than the average population size in the 'Antarctic_Communities' table.", "context": "CREATE TABLE Arctic_Communities (name TEXT, population INTEGER); CREATE TABLE Antarctic_Communities (name TEXT, population INTEGER);", "reference_sql": "SELECT name FROM Arctic_Communities WHERE Arctic_Communities.population > (SELECT AVG(population) FROM Antarctic_Communities)", "generated_sql": "SELECT name \nFROM Arctic_Communities \nWHERE population > (SELECT AVG(population) FROM Antarctic_Communities);", "raw_model_output": "```sql\nSELECT name \nFROM Arctic_Communities \nWHERE population > (SELECT AVG(population) FROM Antarctic_Communities);\n```\n\nThis SQL statement first calculates the average population size in the `Antarctic_Communities` table using a subquery. It then selects the names of all communities from the `Arctic_Communities` table where the population is greater than this average value.", "latency_sec": 0.5653190612792969, "total_duration_sec": 0.536350789, "load_duration_sec": 0.018626729, "tokens_prompt": 145, "prompt_eval_sec": 0.002535927, "tokens_completion": 79, "completion_eval_sec": 0.514717286, "tokens_total": 224, "tokens_per_sec": 396.2364182327339, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select names from Arctic_Communities where population exceeds the average population of Antarctic_Communities. The generated SQL omits the table alias in the WHERE clause, but since the column exists only in the queried table (Arctic_Communities), the result remains identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically correct and semantically equivalent. The reference query explicitly qualifies the 'population' column with the table name, while the generated query relies on implicit column resolution since the outer query's FROM clause defines the context. Both correctly calculate the average population from Antarctic_Communities and compare it to Arctic_Communities' population. The business intent of identifying Arctic communities exceeding the Antarctic average is fully satisfied by both. The generated query is slightly more concise but neither version demonstrates superior efficiency or elegance. The difference is purely stylistic.", "overall_assessment": "correct"}}
{"example_id": 3008, "sql_complexity": "multiple_joins", "prompt": "Who are the users who used electric vehicles and their trip details?", "context": "CREATE TABLE users (id INT, name VARCHAR(50), age INT, gender VARCHAR(10), city VARCHAR(50));CREATE TABLE vehicles (id INT, vehicle_type VARCHAR(20), is_electric BOOLEAN);CREATE TABLE trips (id INT, user_id INT, vehicle_id INT, trip_distance FLOAT, trip_duration INT, departure_time TIMESTAMP, arrival_time TIMESTAMP);INSERT INTO users (id, name, age, gender, city) VALUES (3, 'Alex', 30, 'Female', 'New York');INSERT INTO vehicles (id, vehicle_type, is_electric) VALUES (1, 'Tesla', true), (2, 'Bike', false);INSERT INTO trips (id, user_id, vehicle_id, trip_distance, trip_duration, departure_time, arrival_time) VALUES (3, 3, 1, 15.3, 25, '2022-01-03 12:00:00', '2022-01-03 12:25:00');", "reference_sql": "SELECT u.name, v.vehicle_type, t.trip_distance, t.trip_duration FROM users u JOIN trips t ON u.id = t.user_id JOIN vehicles v ON t.vehicle_id = v.id WHERE v.is_electric = true;", "generated_sql": "SELECT u.name, t.trip_distance, t.trip_duration, t.departure_time, t.arrival_time \nFROM trips t \nJOIN vehicles v ON t.vehicle_id = v.id \nJOIN users u ON t.user_id = u.id \nWHERE v.is_electric = TRUE;", "raw_model_output": "```sql\nSELECT u.name, t.trip_distance, t.trip_duration, t.departure_time, t.arrival_time \nFROM trips t \nJOIN vehicles v ON t.vehicle_id = v.id \nJOIN users u ON t.user_id = u.id \nWHERE v.is_electric = TRUE;\n```\n\nThis SQL statement joins the `trips`, `vehicles`, and `users` tables based on their respective IDs. It then filters the results to only include rows where the vehicle is electric (`v.is_electric = TRUE`). The final result set includes the user's name, trip details (distance and duration), and departure and arrival times for users who used electric vehicles.", "latency_sec": 1.231081247329712, "total_duration_sec": 0.959036888, "load_duration_sec": 0.022795717, "tokens_prompt": 301, "prompt_eval_sec": 0.006653875, "tokens_completion": 136, "completion_eval_sec": 0.928817209, "tokens_total": 437, "tokens_per_sec": 354.97250969249905, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL selects 'vehicle_type' while the Generated SQL includes 'departure_time' and 'arrival_time' instead. The selected columns differ, resulting in different output structures.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because they select different columns. The Reference SQL includes 'vehicle_type' while the Generated SQL includes 'departure_time' and 'arrival_time'. Both fulfill the business intent of identifying users who used electric vehicles with trip details, but the Generated query provides more comprehensive trip information (times) that directly aligns with the phrase 'trip details' in the question. The Generated query also maintains the same table joins and filter conditions, making it equally correct but more detailed.", "overall_assessment": "differently_correct"}}
{"example_id": 1506, "sql_complexity": "basic SQL", "prompt": "How many habitats are in the 'animal_habitats' table?", "context": "CREATE TABLE animal_habitats (id INT PRIMARY KEY, habitat_name VARCHAR, num_animals INT);", "reference_sql": "SELECT COUNT(*) FROM animal_habitats;", "generated_sql": "SELECT COUNT(*) \nFROM animal_habitats;", "raw_model_output": "```sql\nSELECT COUNT(*) \nFROM animal_habitats;\n```\n\nThis SQL statement uses the `COUNT` function to count the number of rows in the `animal_habitats` table, effectively answering the question \"How many habitats are in the 'animal_habitats' table?\"", "latency_sec": 0.7303171157836914, "total_duration_sec": 0.41035674, "load_duration_sec": 0.014941861, "tokens_prompt": 117, "prompt_eval_sec": 0.002805088, "tokens_completion": 60, "completion_eval_sec": 0.392043889, "tokens_total": 177, "tokens_per_sec": 242.36047077996272, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They both select the count of all rows from the 'animal_habitats' table using the same syntax. There are no differences in keywords, table names, or query structure that would affect the result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are syntactically identical except for whitespace formatting. They both execute a COUNT(*) operation on the animal_habitats table, which directly answers the question about the number of habitats. The line break in the generated query doesn't affect functionality, logic, or performance. Neither query is more efficient or elegant than the other, and both fully address the business intent of counting table entries.", "overall_assessment": "correct"}}
{"example_id": 4138, "sql_complexity": "window functions", "prompt": "How many lifelong learning courses has a student with ID '2' completed, in chronological order?", "context": "CREATE TABLE lifelong_learning (student_id INT, course_id INT, completion_date DATE); INSERT INTO lifelong_learning VALUES (2, 1001, '2015-01-01'), (2, 1002, '2016-01-01');", "reference_sql": "SELECT student_id, course_id, COUNT(course_id) OVER (PARTITION BY student_id ORDER BY completion_date) as completed_courses FROM lifelong_learning WHERE student_id = 2;", "generated_sql": "SELECT COUNT(*) \nFROM lifelong_learning \nWHERE student_id = 2 \nORDER BY completion_date;", "raw_model_output": "```sql\nSELECT COUNT(*) \nFROM lifelong_learning \nWHERE student_id = 2 \nORDER BY completion_date;\n```\n\nThis SQL statement counts the number of rows where `student_id` is 2 and orders the results by `completion_date` in ascending order (chronological). \n\nHowever, if you want to get all courses completed by a specific student in chronological order, including the course ID, you can modify it as follows:\n\n```sql\nSELECT COUNT(*) AS num_courses, \n       course_id \nFROM lifelong_learning \nWHERE student_id = 2 \nGROUP BY course_id \nORDER BY completion_date;\n```\n\nThis will return the number of courses completed by a student with ID 2 and the corresponding course IDs in chronological order.", "latency_sec": 1.3164620399475098, "total_duration_sec": 0.997622924, "load_duration_sec": 0.015086145, "tokens_prompt": 153, "prompt_eval_sec": 0.002623835, "tokens_completion": 151, "completion_eval_sec": 0.979475423, "tokens_total": 304, "tokens_per_sec": 230.92196415486552, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns multiple rows with student_id, course_id, and a running count of completed courses per student, while the Generated SQL returns a single scalar value (total count of courses) and lacks the course_id and student_id columns. The window function in the Reference SQL produces per-row counts, whereas the Generated SQL aggregates all rows into one value.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL calculates a running count of courses per student using a window function, returning multiple rows with incremental counts (e.g., 1, 2 for two courses). The Generated SQL correctly counts total courses (returns 2) but includes an unnecessary ORDER BY clause. The original question asks for the total number of completed courses, not a running tally. While the Generated SQL is technically correct for counting, the Reference SQL fails to answer the question as phrased. However, the Generated SQL's ORDER BY is redundant and doesn't affect the result. The Reference SQL does not fulfill the intent of counting total courses, making the Generated SQL superior for this specific question.", "overall_assessment": "incorrect"}}
{"example_id": 5499, "sql_complexity": "set operations", "prompt": "How many legal aid clinics and community mediation centers are there in total, and what is the sum of cases handled by each type of center, for centers located in the state of California?", "context": "CREATE TABLE LegalAidClinics (ClinicName text, State text, NumCases int); INSERT INTO LegalAidClinics VALUES ('Clinic1', 'CA', 30, '2022-01-01'), ('Clinic2', 'CA', 25, '2022-01-01'); CREATE TABLE CommunityMediationCenters (CenterName text, State text, NumCases int); INSERT INTO CommunityMediationCenters VALUES ('CM1', 'CA', 22, '2022-01-01'), ('CM2', 'CA', 28, '2022-01-01');", "reference_sql": "SELECT State, 'Legal Aid Clinics' AS CenterType, COUNT(*) AS NumCenters, SUM(NumCases) AS TotalCases FROM LegalAidClinics WHERE State = 'CA' UNION ALL SELECT State, 'Community Mediation Centers', COUNT(*), SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA';", "generated_sql": "SELECT \n    COUNT(*) AS TotalCenters,\n    SUM(CASE WHEN T1.State = 'CA' THEN T1.NumCases ELSE 0 END) AS CA_Cases,\n    SUM(CASE WHEN T2.State = 'CA' THEN T2.NumCases ELSE 0 END) AS CM_Cases\nFROM \n    LegalAidClinics T1\nFULL OUTER JOIN \n    CommunityMediationCenters T2 ON T1.ClinicName = T2.CenterName;", "raw_model_output": "```sql\nSELECT \n    COUNT(*) AS TotalCenters,\n    SUM(CASE WHEN T1.State = 'CA' THEN T1.NumCases ELSE 0 END) AS CA_Cases,\n    SUM(CASE WHEN T2.State = 'CA' THEN T2.NumCases ELSE 0 END) AS CM_Cases\nFROM \n    LegalAidClinics T1\nFULL OUTER JOIN \n    CommunityMediationCenters T2 ON T1.ClinicName = T2.CenterName;\n```\n\nThis SQL statement uses a `FULL OUTER JOIN` to combine rows from both tables where the join condition (`ClinicName = CenterName`) is met. The `CASE` statements within the `SUM` aggregation functions count the number of cases for each type of center in California by checking if the state matches 'CA'. If it does, the case value is included; otherwise, 0 is used as a placeholder to avoid counting non-California centers.", "latency_sec": 1.6492509841918945, "total_duration_sec": 1.337286641, "load_duration_sec": 0.015154008, "tokens_prompt": 248, "prompt_eval_sec": 0.004547961, "tokens_completion": 197, "completion_eval_sec": 1.31696743, "tokens_total": 445, "tokens_per_sec": 269.81945396142515, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL returns two rows (one for each center type) with counts and sums per type, while the Generated SQL returns a single row with total centers and combined case sums. The Generated SQL's FULL OUTER JOIN logic and aggregation structure differ fundamentally from the Reference SQL's UNION ALL approach. Additionally, the JOIN condition (ClinicName = CenterName) is unrelated to the State filter in the Reference SQL, leading to different data combinations.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly addresses the question by separately aggregating data from both tables with explicit filters for California. It returns two rows (one per center type) with accurate counts and case sums. The Generated SQL is fundamentally flawed: 1) The FULL OUTER JOIN creates incorrect row combinations (ClinicName vs CenterName mismatch), 2) COUNT(*) counts joined rows rather than distinct centers, 3) The CASE statements incorrectly aggregate across both tables in a single row rather than separating by center type. The Generated SQL fails to meet both technical and semantic requirements while the Reference SQL directly answers the question with proper structure.", "overall_assessment": "incorrect"}}
{"example_id": 2265, "sql_complexity": "aggregation", "prompt": "Hourly revenue for a specific movie?", "context": "CREATE TABLE Movie_Revenue (id INT, movie_title VARCHAR(100), revenue_time TIME, revenue DECIMAL(10,2));", "reference_sql": "SELECT revenue_time, SUM(revenue) FROM Movie_Revenue WHERE movie_title = 'Spider-Man: No Way Home' GROUP BY revenue_time;", "generated_sql": "SELECT revenue / 3600 AS hourly_revenue \nFROM Movie_Revenue \nWHERE movie_title = 'specific_movie_title';", "raw_model_output": "```sql\nSELECT revenue / 3600 AS hourly_revenue \nFROM Movie_Revenue \nWHERE movie_title = 'specific_movie_title';\n```\n\nReplace `'specific_movie_title'` with the actual title of the movie you're interested in. This query calculates the hourly revenue by dividing the total revenue by 3600 (since there are 3600 seconds in an hour).", "latency_sec": 0.5800588130950928, "total_duration_sec": 0.530449788, "load_duration_sec": 0.029779034, "tokens_prompt": 117, "prompt_eval_sec": 0.002403567, "tokens_completion": 77, "completion_eval_sec": 0.497897522, "tokens_total": 194, "tokens_per_sec": 334.44884487634937, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query aggregates revenue by revenue_time for a specific movie, while the generated query calculates hourly revenue by dividing revenue by 3600 without grouping or aggregation. Additionally, the movie titles in the WHERE clauses differ ('Spider-Man: No Way Home' vs 'specific_movie_title').", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly groups revenue by time and sums it, which aligns with the 'hourly revenue' requirement. The Generated SQL lacks aggregation, divides revenue by 3600 (assuming per-second revenue), and uses a placeholder title. While both queries filter by movie title, the Reference properly aggregates revenue per time interval, whereas the Generated query misinterprets the calculation and fails to group data. The Reference better addresses the business intent of measuring revenue per hour.", "overall_assessment": "incorrect"}}
{"example_id": 5792, "sql_complexity": "multiple_joins", "prompt": "How many cases were handled by attorneys in the 'Los Angeles' office?", "context": "CREATE TABLE offices (office_id INT, office_name VARCHAR(20), city VARCHAR(20), state VARCHAR(20)); INSERT INTO offices (office_id, office_name, city, state) VALUES (1, 'Boston', 'Boston', 'MA'), (2, 'New York', 'New York', 'NY'), (3, 'Los Angeles', 'Los Angeles', 'CA'); CREATE TABLE attorneys (attorney_id INT, office_id INT); INSERT INTO attorneys (attorney_id, office_id) VALUES (1, 1), (2, 2), (3, 3); CREATE TABLE cases (case_id INT, attorney_id INT); INSERT INTO cases (case_id, attorney_id) VALUES (1, 1), (2, 2), (3, 3);", "reference_sql": "SELECT COUNT(*) FROM cases JOIN attorneys ON cases.attorney_id = attorneys.attorney_id JOIN offices ON attorneys.office_id = offices.office_id WHERE offices.city = 'Los Angeles';", "generated_sql": "SELECT COUNT(c.case_id)\nFROM offices o\nJOIN attorneys a ON o.office_id = a.office_id\nJOIN cases c ON a.attorney_id = c.attorney_id\nWHERE o.city = 'Los Angeles';", "raw_model_output": "```sql\nSELECT COUNT(c.case_id)\nFROM offices o\nJOIN attorneys a ON o.office_id = a.office_id\nJOIN cases c ON a.attorney_id = c.attorney_id\nWHERE o.city = 'Los Angeles';\n```\n\nThis SQL statement joins the `offices`, `attorneys`, and `cases` tables based on their respective relationships. It then filters the results to only include rows where the office city is 'Los Angeles' and counts the number of cases handled by attorneys in that office.", "latency_sec": 0.9075078964233398, "total_duration_sec": 0.725720647, "load_duration_sec": 0.014772593, "tokens_prompt": 260, "prompt_eval_sec": 0.004878079, "tokens_completion": 105, "completion_eval_sec": 0.705367167, "tokens_total": 365, "tokens_per_sec": 402.20035708618514, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of cases associated with offices in 'Los Angeles'. The Reference SQL uses COUNT(*) while the Generated SQL uses COUNT(c.case_id), which are equivalent since case_id is a non-nullable primary key. The join conditions and filtering criteria are identical, and table aliases in the Generated SQL do not affect the semantic outcome.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly count cases handled by attorneys in the 'Los Angeles' office by joining the three tables (cases \u2192 attorneys \u2192 offices) and filtering on the city. The reference query uses explicit table names, while the generated query uses aliases (o, a, c) for brevity. The logic, join conditions, and WHERE clause are identical in effect. Neither query has syntax errors or logical flaws. The generated query is slightly more concise but offers no functional advantage over the reference. Both fully address the business question.", "overall_assessment": "correct"}}
{"example_id": 2513, "sql_complexity": "single join", "prompt": "What is the total number of concert ticket sales for artists who released their first album between 2015 and 2017?", "context": "CREATE TABLE ConcertTicketSales (id INT, year INT, artist_id INT); CREATE TABLE ArtistAlbums (id INT, artist_id INT, year INT);", "reference_sql": "SELECT COUNT(DISTINCT cts.artist_id) FROM ConcertTicketSales cts JOIN ArtistAlbums a ON cts.artist_id = a.artist_id WHERE a.year BETWEEN 2015 AND 2017;", "generated_sql": "SELECT COUNT(*) \nFROM ConcertTicketSales cts\nJOIN ArtistAlbums al ON cts.artist_id = al.artist_id\nWHERE al.year BETWEEN 2015 AND 2017;", "raw_model_output": "```sql\nSELECT COUNT(*) \nFROM ConcertTicketSales cts\nJOIN ArtistAlbums al ON cts.artist_id = al.artist_id\nWHERE al.year BETWEEN 2015 AND 2017;\n```\n\nThis SQL statement joins the `ConcertTicketSales` and `ArtistAlbums` tables on the `artist_id` column. It then filters the results to only include rows where the album's release year is between 2015 and 2017, effectively identifying artists who released their first album during this period. The final `COUNT(*)` aggregation function returns the total number of matching concert ticket sales.", "latency_sec": 0.9000468254089355, "total_duration_sec": 0.830549922, "load_duration_sec": 0.015929773, "tokens_prompt": 139, "prompt_eval_sec": 0.003208056, "tokens_completion": 125, "completion_eval_sec": 0.810936614, "tokens_total": 264, "tokens_per_sec": 293.3180725125627, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query uses COUNT(DISTINCT cts.artist_id) to count unique artist IDs, while the generated query uses COUNT(*) which counts all rows. If there are multiple entries for the same artist_id in the joined result, the generated query would return a higher count. The semantic difference lies in deduplication of artist IDs.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly uses COUNT(DISTINCT cts.artist_id) to count unique artists who meet the criteria, while the generated query uses COUNT(*) which would overcount artists with multiple albums in the 2015-2017 range. The original question asks for the 'total number of concert ticket sales' but the actual business intent appears to be counting distinct artists (not sales volume). The reference query aligns with this intent by ensuring each artist is counted once, whereas the generated query would produce an inflated count. Both queries fail to address the ambiguity in the original question about whether it seeks sales volume or artist count, but the reference better addresses the likely business intent.", "overall_assessment": "differently_correct"}}
{"example_id": 3546, "sql_complexity": "window functions", "prompt": "What are the cryptocurrency exchanges with their corresponding blockchain companies, ranked by exchange ID in ascending order, for the Bitcoin platform?", "context": "CREATE TABLE cryptocurrency_exchanges (exchange_id INT, exchange_name VARCHAR(50), company_id INT); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (1, 'Binance', 1); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (2, 'Coinbase', 2); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (3, 'Kraken', 3); CREATE TABLE blockchain_companies (company_id INT, company_name VARCHAR(50), platform VARCHAR(50)); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (1, 'Binance', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (2, 'Blockstream', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (3, 'Blockchair', 'Bitcoin');", "reference_sql": "SELECT ce.exchange_name, bc.company_name, ce.exchange_id, ROW_NUMBER() OVER (PARTITION BY bc.platform ORDER BY ce.exchange_id ASC) as rank FROM cryptocurrency_exchanges ce JOIN blockchain_companies bc ON ce.company_id = bc.company_id WHERE bc.platform = 'Bitcoin';", "generated_sql": "SELECT \n    cex.exchange_name AS exchange_name,\n    bc.company_name AS company_name,\n    bc.platform AS platform\nFROM \n    cryptocurrency_exchanges cex\nINNER JOIN \n    blockchain_companies bc ON cex.company_id = bc.company_id\nWHERE \n    bc.platform = 'Bitcoin'\nORDER BY \n    cex.exchange_id ASC;", "raw_model_output": "```sql\nSELECT \n    cex.exchange_name AS exchange_name,\n    bc.company_name AS company_name,\n    bc.platform AS platform\nFROM \n    cryptocurrency_exchanges cex\nINNER JOIN \n    blockchain_companies bc ON cex.company_id = bc.company_id\nWHERE \n    bc.platform = 'Bitcoin'\nORDER BY \n    cex.exchange_id ASC;\n```\n\nThis SQL statement joins the `cryptocurrency_exchanges` table with the `blockchain_companies` table on the `company_id` column, filters for Bitcoin platforms, and orders the results by exchange ID in ascending order.", "latency_sec": 1.1110930442810059, "total_duration_sec": 0.850268544, "load_duration_sec": 0.015710881, "tokens_prompt": 300, "prompt_eval_sec": 0.005117998, "tokens_completion": 122, "completion_eval_sec": 0.828304849, "tokens_total": 422, "tokens_per_sec": 379.80617570428444, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL includes a ROW_NUMBER() column and selects ce.exchange_id, while the Generated SQL omits the row number, includes bc.platform instead of exchange_id, and adds an ORDER BY clause. The selected columns and additional computed field make the result sets different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL includes a ROW_NUMBER() ranking column that wasn't explicitly requested in the original question, while the Generated SQL directly addresses the requirements. Both queries correctly join the tables and filter for 'Bitcoin', but the Generated query avoids unnecessary complexity by using simple ORDER BY instead of a window function. The original question asked for 'ranked by exchange ID' which is best interpreted as ordering results (not adding a rank column), making the Generated query more precise. The Reference query's partitioning by platform is redundant due to the WHERE clause. The Generated query is more efficient and directly answers the business question without extra elements.", "overall_assessment": "differently_correct"}}
{"example_id": 1515, "sql_complexity": "multiple_joins", "prompt": "What is the average age of clients who lost cases in the 'personal injury' category?", "context": "CREATE TABLE Cases (CaseID int, ClientID int, Category varchar(50)); INSERT INTO Cases (CaseID, ClientID, Category) VALUES (701, 7, 'Personal Injury'); CREATE TABLE Clients (ClientID int, Age int, Gender varchar(10)); INSERT INTO Clients (ClientID, Age, Gender) VALUES (7, 45, 'Male'); CREATE TABLE CaseOutcomes (CaseID int, Outcome varchar(50)); INSERT INTO CaseOutcomes (CaseID, Outcome) VALUES (701, 'Lost');", "reference_sql": "SELECT AVG(C.Age) as AvgAge FROM Clients C INNER JOIN Cases CA ON C.ClientID = CA.ClientID INNER JOIN CaseOutcomes CO ON CA.CaseID = CO.CaseID WHERE CA.Category = 'Personal Injury' AND CO.Outcome = 'Lost';", "generated_sql": "SELECT AVG(C.age)\nFROM Clients C\nJOIN Cases c ON C.ClientID = c.ClientID\nJOIN CaseOutcomes co ON c.CaseID = co.CaseID\nWHERE c.Category = 'Personal Injury' AND co.Outcome = 'Lost';", "raw_model_output": "```sql\nSELECT AVG(C.age)\nFROM Clients C\nJOIN Cases c ON C.ClientID = c.ClientID\nJOIN CaseOutcomes co ON c.CaseID = co.CaseID\nWHERE c.Category = 'Personal Injury' AND co.Outcome = 'Lost';\n```\n\nThis SQL statement joins the `Clients`, `Cases`, and `CaseOutcomes` tables based on their respective IDs. It then filters the results to only include clients who lost cases in the 'Personal Injury' category, and finally calculates the average age of these clients using the `AVG()` function.", "latency_sec": 0.9655401706695557, "total_duration_sec": 0.812203134, "load_duration_sec": 0.014521581, "tokens_prompt": 210, "prompt_eval_sec": 0.003703968, "tokens_completion": 120, "completion_eval_sec": 0.793297377, "tokens_total": 330, "tokens_per_sec": 341.77759768520133, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform the same three-table join (Clients, Cases, CaseOutcomes) with identical join conditions and WHERE clause filters. The only differences are table alias names (CA/CO vs c/co) and column case formatting (Age vs age), which are syntactic variations without semantic impact. The aggregate calculation (AVG(C.Age)) is identical in logic.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent as they use identical logic: joining Clients, Cases, and CaseOutcomes tables with the same conditions (Category = 'Personal Injury' and Outcome = 'Lost') to calculate the average client age. The only differences are stylistic (table aliases 'CA/CO' vs 'c/co' and case sensitivity of column names 'Age' vs 'age'), which do not affect query execution or results. Both queries correctly address the business intent by focusing on lost cases in the specified category. Neither query demonstrates superior efficiency or elegance over the other, as they share the same execution plan and structure.", "overall_assessment": "correct"}}
{"example_id": 3925, "sql_complexity": "set operations", "prompt": "What is the total number of students and staff with accommodations in the \"disability_services\" schema, excluding the \"accessibility_parking\" type?", "context": "CREATE SCHEMA disability_services; CREATE TABLE staff (id INT, name VARCHAR(50), accommodation VARCHAR(50)); CREATE TABLE students (id INT, name VARCHAR(50), accommodation VARCHAR(50));", "reference_sql": "SELECT COUNT(*) FROM disability_services.staff WHERE accommodation != 'accessibility_parking' UNION SELECT COUNT(*) FROM disability_services.students WHERE accommodation != 'accessibility_parking';", "generated_sql": "SELECT \n    COUNT(*) AS total_count\nFROM \n    disability_services.staff s\n    JOIN disability_services.students st ON s.id = st.id\nWHERE \n    s.accommodation != 'accessibility_parking' AND st.accommodation != 'accessibility_parking';", "raw_model_output": "```sql\nSELECT \n    COUNT(*) AS total_count\nFROM \n    disability_services.staff s\n    JOIN disability_services.students st ON s.id = st.id\nWHERE \n    s.accommodation != 'accessibility_parking' AND st.accommodation != 'accessibility_parking';\n```\n\nThis SQL statement joins the `staff` and `students` tables based on their common `id` column. It then filters out rows where either `staff` or `students` have an accommodation type of \"accessibility_parking\". The `COUNT(*)` function is used to count the total number of remaining rows, which represents the total number of students and staff with accommodations excluding \"accessibility_parking\" in the specified schema.", "latency_sec": 1.055556297302246, "total_duration_sec": 0.99022701, "load_duration_sec": 0.014740002, "tokens_prompt": 152, "prompt_eval_sec": 0.004954254, "tokens_completion": 149, "completion_eval_sec": 0.969744062, "tokens_total": 301, "tokens_per_sec": 285.1576943544227, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate counts (staff and students) where accommodation is not 'accessibility_parking', while the Generated SQL performs a JOIN between staff and students on id and counts rows where both have accommodation != 'accessibility_parking'. The semantics differ: the first combines two independent counts, the second measures overlapping records between tables. The result structures and logic are fundamentally different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly isolates staff and student counts with proper filtering, but fails to sum them (returns two rows). The generated query incorrectly joins staff and students on ID (which likely has no meaningful relationship) and filters both tables in a single row context, producing a drastically different result. Neither query fully meets the 'total number' requirement, but the reference better aligns with the schema structure and exclusion logic, even though it doesn't aggregate the counts. The generated query's join introduces a fundamental logical error.", "overall_assessment": "differently_correct"}}
{"example_id": 335, "sql_complexity": "single join", "prompt": "List the policy numbers, claim amounts, and claim dates for policies that have more than two claims and the total claim amount exceeds $5000", "context": "CREATE TABLE policies (policy_number INT);CREATE TABLE claims (claim_id INT, policy_number INT, claim_amount DECIMAL(10,2), claim_date DATE);", "reference_sql": "SELECT p.policy_number, c.claim_amount, c.claim_date FROM policies p INNER JOIN claims c ON p.policy_number = c.policy_number GROUP BY p.policy_number, c.claim_amount, c.claim_date HAVING COUNT(c.claim_id) > 2 AND SUM(c.claim_amount) > 5000;", "generated_sql": "SELECT \n    p.policy_number,\n    SUM(c.claim_amount) AS total_claim_amount,\n    MAX(c.claim_date) AS latest_claim_date\nFROM \n    claims c\nJOIN \n    policies p ON c.policy_number = p.policy_number\nGROUP BY \n    p.policy_number\nHAVING \n    COUNT(c.claim_id) > 2 AND SUM(c.claim_amount) > 5000;", "raw_model_output": "```sql\nSELECT \n    p.policy_number,\n    SUM(c.claim_amount) AS total_claim_amount,\n    MAX(c.claim_date) AS latest_claim_date\nFROM \n    claims c\nJOIN \n    policies p ON c.policy_number = p.policy_number\nGROUP BY \n    p.policy_number\nHAVING \n    COUNT(c.claim_id) > 2 AND SUM(c.claim_amount) > 5000;\n```\n\nThis SQL statement joins the `claims` and `policies` tables based on the `policy_number`, groups the results by policy number, calculates the total claim amount for each policy, and filters out policies with two or fewer claims and a total claim amount less than $5000. The result is a list of policy numbers, their corresponding total claim amounts, and the date of the latest claim.", "latency_sec": 1.4509601593017578, "total_duration_sec": 1.129352313, "load_duration_sec": 0.015791024, "tokens_prompt": 144, "prompt_eval_sec": 0.002454716, "tokens_completion": 170, "completion_eval_sec": 1.110518772, "tokens_total": 314, "tokens_per_sec": 216.40842306180585, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL groups by policy_number, claim_amount, and claim_date, returning individual claim details for policies meeting the HAVING conditions. The Generated SQL groups by policy_number only, aggregating total claim amounts and latest claim dates. The SELECT clauses differ in both column selection and aggregation, leading to different result structures and content.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is technically incorrect because it groups by claim_amount and claim_date, which would prevent any group from having COUNT > 2 (each group would contain only identical claim amounts/dates). The Generated SQL correctly groups by policy_number but changes the output to aggregate values (SUM and MAX) instead of listing individual claims. While the Generated SQL is more efficient and structurally sound, it fails to fulfill the business intent of listing individual claim details. The Reference SQL's grouping logic is fundamentally flawed, making it incorrect. Neither query fully meets the requirements, but the Generated SQL is technically superior despite not addressing the original question's output format.", "overall_assessment": "incorrect"}}
