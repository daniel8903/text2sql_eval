{"example_id": 1, "sql_complexity": "basic SQL", "prompt": "What is the average explainability score of creative AI applications in 'Europe' and 'North America' in the 'creative_ai' table?", "context": "CREATE TABLE creative_ai (application_id INT, name TEXT, region TEXT, explainability_score FLOAT); INSERT INTO creative_ai (application_id, name, region, explainability_score) VALUES (1, 'ApplicationX', 'Europe', 0.87), (2, 'ApplicationY', 'North America', 0.91), (3, 'ApplicationZ', 'Europe', 0.84), (4, 'ApplicationAA', 'North America', 0.93), (5, 'ApplicationAB', 'Europe', 0.89);", "reference_sql": "SELECT AVG(explainability_score) FROM creative_ai WHERE region IN ('Europe', 'North America');", "generated_sql": "SELECT \n    region,\n    AVG(explainability_score) AS avg_explainability_score\nFROM \n    creative_ai\nWHERE \n    region IN ('Europe', 'North America')\nGROUP BY \n    region;", "raw_model_output": "To find the average explainability score for creative AI applications in both 'Europe' and 'North America', you can use the following SQL query:\n\n```sql\nSELECT \n    region,\n    AVG(explainability_score) AS avg_explainability_score\nFROM \n    creative_ai\nWHERE \n    region IN ('Europe', 'North America')\nGROUP BY \n    region;\n```\n\nThis query will return the average explainability score for each specified region. If you want to get a single value representing the overall average across both regions, you can modify the query as follows:\n\n```sql\nSELECT \n    AVG(explainability_score) AS avg_explainability_score\nFROM \n    creative_ai\nWHERE \n    region IN ('Europe', 'North America');\n```\n\nThis will give you the combined average explainability score for all applications in Europe and North America.", "latency_sec": 2.379505157470703, "total_duration": 2133783894, "load_duration": 19547599, "tokens_prompt": 177, "prompt_eval_duration": 19394116, "tokens_completion": 174, "eval_duration": 2092292460, "tokens_total": 351, "tokens_per_sec": 147.5096613671961, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query calculates the overall average explainability_score for all rows where region is either 'Europe' or 'North America', returning a single scalar value. The generated query calculates the average explainability_score separately for each region ('Europe' and 'North America'), returning multiple rows with region and its corresponding average. Therefore, the result sets differ in structure and content."}
{"example_id": 2, "sql_complexity": "basic SQL", "prompt": "Delete all records of rural infrastructure projects in Indonesia that have a completion date before 2010.", "context": "CREATE TABLE rural_infrastructure (id INT, project_name TEXT, sector TEXT, country TEXT, completion_date DATE); INSERT INTO rural_infrastructure (id, project_name, sector, country, completion_date) VALUES (1, 'Water Supply Expansion', 'Infrastructure', 'Indonesia', '2008-05-15'), (2, 'Rural Electrification', 'Infrastructure', 'Indonesia', '2012-08-28'), (3, 'Transportation Improvement', 'Infrastructure', 'Indonesia', '2009-12-31');", "reference_sql": "DELETE FROM rural_infrastructure WHERE country = 'Indonesia' AND completion_date < '2010-01-01';", "generated_sql": "DELETE FROM rural_infrastructure\nWHERE country = 'Indonesia' AND completion_date < '2010-01-01';", "raw_model_output": "To delete all records from the `rural_infrastructure` table where the country is \"Indonesia\" and the completion date is before January 1, 2010, you can use the following SQL query:\n\n```sql\nDELETE FROM rural_infrastructure\nWHERE country = 'Indonesia' AND completion_date < '2010-01-01';\n```\n\nThis query will remove any rows that match both conditions: being from Indonesia and having a completion date before 2010.", "latency_sec": 1.35197114944458, "total_duration": 1331461480, "load_duration": 18062268, "tokens_prompt": 176, "prompt_eval_duration": 12323548, "tokens_completion": 106, "eval_duration": 1298384044, "tokens_total": 282, "tokens_per_sec": 208.58433267296562, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries delete rows from the rural_infrastructure table where the country is 'Indonesia' and the completion_date is before '2010-01-01'. The only difference is formatting and line breaks, which do not affect the semantics."}
{"example_id": 3, "sql_complexity": "aggregation", "prompt": "How many accidents have been recorded for SpaceX and Blue Origin rocket launches?", "context": "CREATE TABLE Accidents (id INT, launch_provider VARCHAR(255), year INT, description TEXT); INSERT INTO Accidents (id, launch_provider, year, description) VALUES (1, 'SpaceX', 2015, 'Falcon 9 explosion'), (2, 'Blue Origin', 2011, 'Propulsion system failure'), (3, 'SpaceX', 2016, 'Falcon 9 explosion');", "reference_sql": "SELECT launch_provider, COUNT(*) FROM Accidents GROUP BY launch_provider;", "generated_sql": "SELECT launch_provider, COUNT(*) AS accident_count\nFROM Accidents\nWHERE launch_provider IN ('SpaceX', 'Blue Origin')\nGROUP BY launch_provider;", "raw_model_output": "To find out how many accidents have been recorded for SpaceX and Blue Origin rocket launches, you can use the following SQL query:\n\n```sql\nSELECT launch_provider, COUNT(*) AS accident_count\nFROM Accidents\nWHERE launch_provider IN ('SpaceX', 'Blue Origin')\nGROUP BY launch_provider;\n```\n\nThis query will return a count of accidents for each specified launch provider. Let's break down what this query does:\n\n- `SELECT launch_provider, COUNT(*) AS accident_count`: This selects the `launch_provider` and counts the number of rows (accidents) for each provider.\n- `FROM Accidents`: Specifies the table from which to retrieve the data.\n- `WHERE launch_provider IN ('SpaceX', 'Blue Origin')`: Filters the results to include only records where the `launch_provider` is either 'SpaceX' or 'Blue Origin'.\n- `GROUP BY launch_provider`: Groups the results by `launch_provider`, so you get a count for each provider.\n\nRunning this query on your data will give you:\n\n```\n+----------------+---------------+\n| launch_provider | accident_count |\n+----------------+---------------+\n| SpaceX          | 2             |\n| Blue Origin     | 1             |\n+----------------+---------------+\n```\n\nThis means there were 2 accidents recorded for SpaceX and 1 accident recorded for Blue Origin.", "latency_sec": 3.3599259853363037, "total_duration": 3260657395, "load_duration": 19220572, "tokens_prompt": 140, "prompt_eval_duration": 13747665, "tokens_completion": 269, "eval_duration": 3222163365, "tokens_total": 409, "tokens_per_sec": 121.72887194092823, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query counts accidents for all launch providers, while the generated query filters to only 'SpaceX' and 'Blue Origin'. Therefore, the generated query may exclude some launch providers present in the data, making the results potentially different."}
{"example_id": 4, "sql_complexity": "basic SQL", "prompt": "What is the maximum quantity of seafood sold in a single transaction?", "context": "CREATE TABLE sales (id INT, location VARCHAR(20), quantity INT, price DECIMAL(5,2)); INSERT INTO sales (id, location, quantity, price) VALUES (1, 'Northeast', 50, 12.99), (2, 'Midwest', 75, 19.99), (3, 'West', 120, 14.49);", "reference_sql": "SELECT MAX(quantity) FROM sales;", "generated_sql": "SELECT MAX(quantity) AS max_quantity_sold\nFROM sales;", "raw_model_output": "The SQL query to find the maximum quantity of seafood sold in a single transaction from the `sales` table would be:\n\n```sql\nSELECT MAX(quantity) AS max_quantity_sold\nFROM sales;\n```\n\nGiven the data you provided, this query will return the maximum value among the quantities listed. In your example data:\n\n- ID 1: Northeast, Quantity = 50\n- ID 2: Midwest, Quantity = 75\n- ID 3: West, Quantity = 120\n\nThe result of the query would be:\n\n```sql\nmax_quantity_sold\n-----------------\n120\n```\n\nThis indicates that the maximum quantity sold in a single transaction is 120.", "latency_sec": 2.009589910507202, "total_duration": 1751694789, "load_duration": 16335122, "tokens_prompt": 134, "prompt_eval_duration": 8793238, "tokens_completion": 145, "eval_duration": 1724207789, "tokens_total": 279, "tokens_per_sec": 138.8342957641457, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries compute the maximum value of the 'quantity' column from the 'sales' table. The only difference is that the second query assigns an alias to the result, which does not affect the result set values."}
{"example_id": 5, "sql_complexity": "basic SQL", "prompt": "What is the total budget for movies released before 2010?", "context": "CREATE TABLE Movies_Release_Year (id INT, title VARCHAR(100), release_year INT, budget DECIMAL(10,2)); INSERT INTO Movies_Release_Year (id, title, release_year, budget) VALUES (1, 'The Matrix', 1999, 63000000.00), (2, 'Titanic', 1997, 200000000.00), (3, 'The Lord of the Rings: The Fellowship of the Ring', 2001, 93000000.00);", "reference_sql": "SELECT SUM(budget) FROM Movies_Release_Year WHERE release_year < 2010;", "generated_sql": "SELECT SUM(budget) AS total_budget\nFROM Movies_Release_Year\nWHERE release_year < 2010;", "raw_model_output": "To find the total budget for movies released before 2010, you can use the following SQL query:\n\n```sql\nSELECT SUM(budget) AS total_budget\nFROM Movies_Release_Year\nWHERE release_year < 2010;\n```\n\nThis query sums up the `budget` column for all rows where the `release_year` is less than 2010. The result will give you the total budget for movies released before 2010.\n\nGiven the data provided:\n\n- \"The Matrix\" (1999, $63,000,000)\n- \"Titanic\" (1997, $200,000,000)\n- \"The Lord of the Rings: The Fellowship of the Ring\" (2001, $93,000,000)\n\nSince only \"The Matrix\" and \"Titanic\" are released before 2010, the total budget would be:\n\n\\[ 63,000,000 + 200,000,000 = 263,000,000 \\]\n\nSo, the query will return a `total_budget` of $263,000,000.", "latency_sec": 3.6126549243927, "total_duration": 3373047582, "load_duration": 15368217, "tokens_prompt": 180, "prompt_eval_duration": 11654474, "tokens_completion": 274, "eval_duration": 3343604954, "tokens_total": 454, "tokens_per_sec": 125.66935107324677, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries compute the sum of the budget for movies released before 2010. The only difference is that the generated query assigns an alias 'total_budget' to the result, which does not affect the result set's content or semantics."}
{"example_id": 6, "sql_complexity": "basic SQL", "prompt": "Add a new attorney named 'Oliver Martinez' with email 'oliver.martinez@lawfirm.com' and phone '555-555-5678' to the 'attorneys' table", "context": "CREATE TABLE attorneys (attorney_id INT, attorney_name VARCHAR(50), attorney_email VARCHAR(50), attorney_phone VARCHAR(15));", "reference_sql": "INSERT INTO attorneys (attorney_name, attorney_email, attorney_phone) VALUES ('Oliver Martinez', 'oliver.martinez@lawfirm.com', '555-555-5678');", "generated_sql": "INSERT INTO attorneys (attorney_id, attorney_name, attorney_email, attorney_phone)\nVALUES (1004, 'Oliver Martinez', 'oliver.martinez@lawfirm.com', '555-555-5678');", "raw_model_output": "To add a new attorney named 'Oliver Martinez' with the specified email and phone number to the `attorneys` table, you can use the following SQL statement:\n\n```sql\nINSERT INTO attorneys (attorney_id, attorney_name, attorney_email, attorney_phone)\nVALUES (1004, 'Oliver Martinez', 'oliver.martinez@lawfirm.com', '555-555-5678');\n```\n\nIn this example:\n- `1004` is the ID assigned to Oliver Martinez. You can choose any unique integer value for the `attorney_id`.\n- `'Oliver Martinez'` is the attorney's name.\n- `'oliver.martinez@lawfirm.com'` is the email address.\n- `'555-555-5678'` is the phone number.\n\nMake sure that the `attorney_id` you choose does not already exist in the table to avoid duplicates.", "latency_sec": 2.70054292678833, "total_duration": 2453863775, "load_duration": 18900308, "tokens_prompt": 106, "prompt_eval_duration": 7365631, "tokens_completion": 201, "eval_duration": 2424007576, "tokens_total": 307, "tokens_per_sec": 113.68084430529876, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query inserts a row without specifying attorney_id, likely relying on default or auto-increment behavior, whereas the generated query explicitly inserts attorney_id with value 1004. This difference can lead to different data being inserted, especially if attorney_id is a primary key or has constraints."}
{"example_id": 7, "sql_complexity": "aggregation", "prompt": "Identify the top 2 plants with the highest CO2 emissions per ton produced.", "context": "CREATE TABLE co2_emissions (id INT PRIMARY KEY, plant_name VARCHAR(255), chemical_name VARCHAR(255), co2_emission_per_ton_produced DECIMAL(5,2)); INSERT INTO co2_emissions (id, plant_name, chemical_name, co2_emission_per_ton_produced) VALUES (1, 'Plant A', 'Nitric Acid', 2.3); INSERT INTO co2_emissions (id, plant_name, chemical_name, co2_emission_per_ton_produced) VALUES (2, 'Plant B', 'Acetic Acid', 1.8);", "reference_sql": "SELECT plant_name, SUM(co2_emission_per_ton_produced) AS total_co2_emission FROM co2_emissions GROUP BY plant_name ORDER BY total_co2_emission DESC LIMIT 2;", "generated_sql": "SELECT plant_name, chemical_name, co2_emission_per_ton_produced\nFROM co2_emissions\nORDER BY co2_emission_per_ton_produced DESC\nLIMIT 2;", "raw_model_output": "To identify the top 2 plants with the highest CO2 emissions per ton produced, you can use a SQL query to order the records by `co2_emission_per_ton_produced` in descending order and then limit the result to the top 2.\n\nHere is the SQL query:\n\n```sql\nSELECT plant_name, chemical_name, co2_emission_per_ton_produced\nFROM co2_emissions\nORDER BY co2_emission_per_ton_produced DESC\nLIMIT 2;\n```\n\nThis query will return the names of the plants along with their respective chemicals and CO2 emissions per ton produced, sorted in descending order by CO2 emission. The `LIMIT 2` clause ensures that only the top 2 records are returned.\n\nGiven the data you provided:\n\n- Plant A (Nitric Acid) has a CO2 emission of 2.3 tons per ton produced.\n- Plant B (Acetic Acid) has a CO2 emission of 1.8 tons per ton produced.\n\nThe query will return:\n\n```\nplant_name | chemical_name   | co2_emission_per_ton_produced\n-----------|----------------|-------------------------------\nPlant A    | Nitric Acid     | 2.30\nPlant B    | Acetic Acid     | 1.80\n```", "latency_sec": 3.295996904373169, "total_duration": 3288085586, "load_duration": 14227359, "tokens_prompt": 177, "prompt_eval_duration": 11029352, "tokens_completion": 267, "eval_duration": 3260387345, "tokens_total": 444, "tokens_per_sec": 134.7088643836089, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query aggregates CO2 emissions by plant_name, summing emissions per plant and returning the top 2 plants with the highest total emissions. The generated query returns individual rows with plant_name, chemical_name, and emission values, ordered by single emission values, not aggregated totals. Therefore, they produce different results and are not semantically equivalent."}
{"example_id": 8, "sql_complexity": "basic SQL", "prompt": "What is the total cost of all climate communication projects that ended after 2010 in 'Antarctica'?", "context": "CREATE TABLE climate_communication (project_id INT, project_name VARCHAR(255), location VARCHAR(255), start_date DATE, end_date DATE, total_cost DECIMAL(10,2));", "reference_sql": "SELECT SUM(total_cost) FROM climate_communication WHERE location = 'Antarctica' AND end_date >= '2010-12-31';", "generated_sql": "SELECT SUM(total_cost) AS total_cost_of_projects\nFROM climate_communication\nWHERE location = 'Antarctica' AND end_date > '2010-12-31';", "raw_model_output": "To find the total cost of all climate communication projects that ended after 2010 in Antarctica, you can use the following SQL query:\n\n```sql\nSELECT SUM(total_cost) AS total_cost_of_projects\nFROM climate_communication\nWHERE location = 'Antarctica' AND end_date > '2010-12-31';\n```\n\nThis query does the following:\n- `SUM(total_cost)` calculates the total cost of all projects that meet the criteria.\n- The `WHERE` clause filters the records to include only those where the project location is 'Antarctica' and the end date is after December 31, 2010.", "latency_sec": 1.9035530090332031, "total_duration": 1701365664, "load_duration": 14750159, "tokens_prompt": 97, "prompt_eval_duration": 8592839, "tokens_completion": 139, "eval_duration": 1675529523, "tokens_total": 236, "tokens_per_sec": 123.97868558431279, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query includes projects with end_date equal to '2010-12-31' (using >=), while the generated query excludes projects that end exactly on '2010-12-31' (using >). Therefore, they may produce different sums if any projects end on '2010-12-31'. Additionally, the generated query uses an alias for the sum, but this does not affect the result set equivalence."}
{"example_id": 9, "sql_complexity": "basic SQL", "prompt": "List all marine species with their conservation status.", "context": "CREATE TABLE marine_species (name TEXT, conservation_status TEXT);", "reference_sql": "SELECT name, conservation_status FROM marine_species;", "generated_sql": "SELECT name, conservation_status FROM marine_species;", "raw_model_output": "Certainly! To list all marine species along with their conservation status from the `marine_species` table, you can use the following SQL query:\n\n```sql\nSELECT name, conservation_status FROM marine_species;\n```\n\nThis query will return a list of all entries in the `marine_species` table, showing each species' name and its corresponding conservation status.", "latency_sec": 0.9484050273895264, "total_duration": 869225717, "load_duration": 15955838, "tokens_prompt": 51, "prompt_eval_duration": 7803289, "tokens_completion": 71, "eval_duration": 843307372, "tokens_total": 122, "tokens_per_sec": 128.63702371528288, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (name, conservation_status) from the same table (marine_species) without any filtering, ordering, or aggregation. Therefore, they produce the same result set."}
{"example_id": 10, "sql_complexity": "basic SQL", "prompt": "What is the average number of publications per researcher for researchers working at the 'National Geographic' organization?", "context": "CREATE TABLE researchers (id INT, name VARCHAR(255), organization VARCHAR(255), publications INT); INSERT INTO researchers (id, name, organization, publications) VALUES (1, 'Alice Johnson', 'NOAA', 25); INSERT INTO researchers (id, name, organization, publications) VALUES (2, 'Bob Smith', 'University of Miami', 30); INSERT INTO researchers (id, name, organization, publications) VALUES (3, 'Charlie Brown', 'National Geographic', 50);", "reference_sql": "SELECT organization, AVG(publications) as avg_publications FROM researchers WHERE organization = 'National Geographic';", "generated_sql": "SELECT AVG(publications) AS average_publications\nFROM researchers\nWHERE organization = 'National Geographic';", "raw_model_output": "To find the average number of publications per researcher for those working at the 'National Geographic' organization, you can use the following SQL query:\n\n```sql\nSELECT AVG(publications) AS average_publications\nFROM researchers\nWHERE organization = 'National Geographic';\n```\n\nThis query calculates the average (`AVG`) number of publications from the `publications` column where the `organization` is 'National Geographic'. \n\nGiven the data you provided, there's only one researcher at National Geographic (Charlie Brown with 50 publications), so the result will be:\n\n```sql\nSELECT AVG(publications) AS average_publications\nFROM researchers\nWHERE organization = 'National Geographic';\n```\n\nThe output would be:\n\n```\naverage_publications\n--------------------\n50.0\n```\n\nThis means that, on average, there are 50 publications per researcher at the National Geographic organization.", "latency_sec": 2.2379989624023438, "total_duration": 2216080569, "load_duration": 14259248, "tokens_prompt": 159, "prompt_eval_duration": 10061644, "tokens_completion": 179, "eval_duration": 2189823471, "tokens_total": 338, "tokens_per_sec": 151.0277733271062, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query selects both the organization and the average publications, while the generated query only selects the average publications. Additionally, the reference query includes the organization column in the SELECT clause, which affects the result set structure. Therefore, the two queries are not semantically equivalent."}
{"example_id": 11, "sql_complexity": "basic SQL", "prompt": "How many decentralized applications have been downloaded from the 'Asia-Pacific' region?", "context": "CREATE TABLE dapp_ranking (dapp_id INT, dapp_name VARCHAR(50), dapp_category VARCHAR(30), dapp_rating DECIMAL(3,2), dapp_downloads INT, dapp_region VARCHAR(30)); INSERT INTO dapp_ranking (dapp_id, dapp_name, dapp_category, dapp_rating, dapp_downloads, dapp_region) VALUES (1, 'AsiaPacificDapp', 'Social', 4.3, 2000000, 'Asia-Pacific');", "reference_sql": "SELECT SUM(dapp_downloads) FROM dapp_ranking WHERE dapp_region = 'Asia-Pacific';", "generated_sql": "SELECT SUM(dapp_downloads) AS total_downloads FROM dapp_ranking WHERE dapp_region = 'Asia-Pacific';", "raw_model_output": "To find out how many decentralized applications (dapps) have been downloaded from the 'Asia-Pacific' region, you can use a SQL query to sum up the `dapp_downloads` where `dapp_region` is 'Asia-Pacific'. Here's the SQL query for that:\n\n```sql\nSELECT SUM(dapp_downloads) AS total_downloads FROM dapp_ranking WHERE dapp_region = 'Asia-Pacific';\n```\n\nGiven the data you provided, this query would return:\n\n```sql\nSELECT SUM(dapp_downloads) AS total_downloads FROM dapp_ranking WHERE dapp_region = 'Asia-Pacific';\n\n-- Result:\ntotal_downloads\n2000000\n```\n\nSo, 2,000,000 decentralized applications have been downloaded from the 'Asia-Pacific' region.", "latency_sec": 2.146254062652588, "total_duration": 2087502518, "load_duration": 15754883, "tokens_prompt": 160, "prompt_eval_duration": 11324711, "tokens_completion": 169, "eval_duration": 2057958933, "tokens_total": 329, "tokens_per_sec": 153.29033301555359, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of dapp_downloads for rows where dapp_region is 'Asia-Pacific'. The only difference is that the second query assigns an alias 'total_downloads' to the result, which does not affect the result set's values or filtering criteria."}
{"example_id": 12, "sql_complexity": "basic SQL", "prompt": "Identify forests in Canada or the United States with an area larger than 1 million hectares?", "context": "CREATE TABLE forests (id INT, name VARCHAR(255), hectares FLOAT, country VARCHAR(255)); INSERT INTO forests (id, name, hectares, country) VALUES (1, 'Amazon Rainforest', 5500000.0, 'Brazil'), (2, 'Daintree Rainforest', 120000.0, 'Australia'), (3, 'Yellowstone', 894000.0, 'USA'), (4, 'Banff National Park', 664000.0, 'Canada');", "reference_sql": "SELECT forests.name FROM forests WHERE (forests.country = 'Canada' OR forests.country = 'USA') AND forests.hectares > 1000000;", "generated_sql": "SELECT id, name, hectares, country\nFROM forests\nWHERE (country = 'Canada' OR country = 'United States') AND hectares > 1000000;", "raw_model_output": "To identify forests in Canada or the United States with an area larger than 1 million hectares, you can use the following SQL query:\n\n```sql\nSELECT id, name, hectares, country\nFROM forests\nWHERE (country = 'Canada' OR country = 'United States') AND hectares > 1000000;\n```\n\nThis query filters the `forests` table to include only those records where the `country` is either 'Canada' or 'United States', and the `hectares` are greater than 1,000,000. \n\nGiven the data you provided:\n\n- The Amazon Rainforest (Brazil) does not meet the criteria.\n- Daintree Rainforest (Australia) does not meet the criteria.\n- Yellowstone (USA) meets the criteria with an area of 894,000 hectares.\n- Banff National Park (Canada) does not meet the criteria.\n\nTherefore, no forests in Canada or the United States have an area larger than 1 million hectares based on the provided data.", "latency_sec": 2.843331813812256, "total_duration": 2699173643, "load_duration": 20971717, "tokens_prompt": 173, "prompt_eval_duration": 12290792, "tokens_completion": 218, "eval_duration": 2659606093, "tokens_total": 391, "tokens_per_sec": 137.51472765176803, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query filters for countries 'Canada' or 'USA', while the generated query filters for 'Canada' or 'United States'. Since 'USA' and 'United States' are not the same string, the generated query will not match rows where country = 'USA'. Additionally, the reference query selects only the 'name' column, whereas the generated query selects all columns (id, name, hectares, country). Therefore, the queries are not semantically equivalent."}
{"example_id": 13, "sql_complexity": "basic SQL", "prompt": "What is the maximum response time for emergency calls in the city of Los Angeles?", "context": "CREATE TABLE emergency_calls (id INT, city VARCHAR(20), response_time INT);", "reference_sql": "SELECT MAX(response_time) FROM emergency_calls WHERE city = 'Los Angeles';", "generated_sql": "SELECT MAX(response_time) AS max_response_time\nFROM emergency_calls\nWHERE city = 'Los Angeles';", "raw_model_output": "To find the maximum response time for emergency calls in the city of Los Angeles, you can use the following SQL query:\n\n```sql\nSELECT MAX(response_time) AS max_response_time\nFROM emergency_calls\nWHERE city = 'Los Angeles';\n```\n\nThis query selects the maximum value from the `response_time` column where the `city` is 'Los Angeles'. The result will give you the highest response time for emergency calls in Los Angeles.", "latency_sec": 1.3593721389770508, "total_duration": 1080710875, "load_duration": 15128289, "tokens_prompt": 64, "prompt_eval_duration": 6600362, "tokens_completion": 90, "eval_duration": 1056776111, "tokens_total": 154, "tokens_per_sec": 113.28759475377173, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the maximum response_time from the emergency_calls table filtered by city = 'Los Angeles'. The only difference is that the second query assigns an alias 'max_response_time' to the result, which does not affect the result set values."}
{"example_id": 14, "sql_complexity": "single join", "prompt": "What is the total number of police patrols and community engagement events in each district in January 2021?", "context": "CREATE TABLE patrols (id INT, district_id INT, date DATE, type TEXT); INSERT INTO patrols (id, district_id, date, type) VALUES (1, 1, '2021-01-01', 'Patrol'), (2, 1, '2021-01-02', 'Community'), (3, 2, '2021-01-01', 'Patrol'), (4, 2, '2021-01-03', 'Community'), (5, 3, '2021-01-04', 'Patrol'), (6, 3, '2021-01-05', 'Community');", "reference_sql": "SELECT d.name, SUM(IF(p.type = 'Patrol', 1, 0)) as num_patrols, SUM(IF(p.type = 'Community', 1, 0)) as num_community FROM districts d JOIN patrols p ON d.id = p.district_id WHERE p.date >= '2021-01-01' AND p.date < '2021-02-01' GROUP BY d.id;", "generated_sql": "SELECT \n    district_id,\n    COUNT(CASE WHEN type = 'Patrol' THEN id END) AS patrol_count,\n    COUNT(CASE WHEN type = 'Community' THEN id END) AS community_count\nFROM \n    patrols\nWHERE \n    date >= '2021-01-01' AND date < '2021-02-01'\nGROUP BY \n    district_id;", "raw_model_output": "To find the total number of police patrols and community engagement events in each district for January 2021, you can use the following SQL query:\n\n```sql\nSELECT \n    district_id,\n    COUNT(CASE WHEN type = 'Patrol' THEN id END) AS patrol_count,\n    COUNT(CASE WHEN type = 'Community' THEN id END) AS community_count\nFROM \n    patrols\nWHERE \n    date >= '2021-01-01' AND date < '2021-02-01'\nGROUP BY \n    district_id;\n```\n\nThis query does the following:\n1. Filters the records to include only those from January 2021.\n2. Uses `COUNT(CASE WHEN type = 'Patrol' THEN id END)` to count the number of patrols for each district.\n3. Uses `COUNT(CASE WHEN type = 'Community' THEN id END)` to count the number of community engagement events for each district.\n4. Groups the results by `district_id` so that you get a summary for each district.\n\nThe result will show the total number of patrols and community engagements for each district in January 2021.", "latency_sec": 3.320167064666748, "total_duration": 3068896516, "load_duration": 15532881, "tokens_prompt": 213, "prompt_eval_duration": 12432488, "tokens_completion": 247, "eval_duration": 3038238131, "tokens_total": 460, "tokens_per_sec": 138.5472450755038, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query joins the 'patrols' table with the 'districts' table to include the district name in the output and groups by district id, returning district names along with counts of patrol types. The generated query only queries the 'patrols' table, grouping by district_id and counting patrol types, but does not include district names. Therefore, the outputs differ in columns and potentially in semantics if district names are required, so they are not semantically equivalent."}
{"example_id": 15, "sql_complexity": "basic SQL", "prompt": "What is the average cybersecurity contract value?", "context": "CREATE TABLE contracts (id INT, category VARCHAR(255), value DECIMAL(10,2));INSERT INTO contracts (id, category, value) VALUES (1, 'Aircraft', 5000000.00), (2, 'Missiles', 2000000.00), (3, 'Shipbuilding', 8000000.00), (4, 'Cybersecurity', 3000000.00), (5, 'Aircraft', 6000000.00), (6, 'Shipbuilding', 9000000.00);", "reference_sql": "SELECT AVG(value) as avg_value FROM contracts WHERE category = 'Cybersecurity';", "generated_sql": "SELECT AVG(value) AS average_value\nFROM contracts\nWHERE category = 'Cybersecurity';", "raw_model_output": "To find the average cybersecurity contract value, you can use the following SQL query:\n\n```sql\nSELECT AVG(value) AS average_value\nFROM contracts\nWHERE category = 'Cybersecurity';\n```\n\nThis query filters the `contracts` table for rows where the `category` is 'Cybersecurity' and then calculates the average (`AVG`) of the `value` column. \n\nGiven your data, the result should be:\n\n```sql\nSELECT AVG(value) AS average_value\nFROM contracts\nWHERE category = 'Cybersecurity';\n```\n\nExecuting this query will return:\n\n```plaintext\naverage_value\n--------------\n3000000.00\n```\n\nSo, the average cybersecurity contract value is 3,000,000.00.", "latency_sec": 2.1416890621185303, "total_duration": 1970375664, "load_duration": 17017123, "tokens_prompt": 187, "prompt_eval_duration": 16847439, "tokens_completion": 160, "eval_duration": 1930046737, "tokens_total": 347, "tokens_per_sec": 162.0216520397934, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average of the 'value' column for rows where the category is 'Cybersecurity'. The only difference is the alias name for the resulting column ('avg_value' vs 'average_value'), which does not affect the result set values."}
{"example_id": 16, "sql_complexity": "basic SQL", "prompt": "Delete arms_imports table records where year is before 2000", "context": "CREATE TABLE arms_imports (id INT PRIMARY KEY, country VARCHAR(100), year INT, quantity INT); INSERT INTO arms_imports (id, country, year, quantity) VALUES (1, 'China', 1999, 5000);", "reference_sql": "DELETE FROM arms_imports WHERE year < 2000;", "generated_sql": "DELETE FROM arms_imports WHERE year < 2000;", "raw_model_output": "To delete records from the `arms_imports` table where the `year` is before 2000, you can use the following SQL query:\n\n```sql\nDELETE FROM arms_imports WHERE year < 2000;\n```\n\nGiven that your initial insert statement only includes a record for the year 1999, this command will effectively delete that single record.\n\nHere's the full process in context:\n\n1. First, ensure you have the `arms_imports` table created and populated with data (as shown in your example):\n\n```sql\nCREATE TABLE arms_imports (id INT PRIMARY KEY, country VARCHAR(100), year INT, quantity INT);\nINSERT INTO arms_imports (id, country, year, quantity) VALUES (1, 'China', 1999, 5000);\n```\n\n2. Then, execute the delete statement:\n\n```sql\nDELETE FROM arms_imports WHERE year < 2000;\n```\n\nSince there is only one record and its `year` value is 1999 (which is less than 2000), this command will remove that single row from the table.", "latency_sec": 3.1289987564086914, "total_duration": 2922125328, "load_duration": 15065215, "tokens_prompt": 102, "prompt_eval_duration": 7579153, "tokens_completion": 244, "eval_duration": 2896883063, "tokens_total": 346, "tokens_per_sec": 110.57850352012333, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries delete rows from the arms_imports table where the year is less than 2000. They have identical conditions and will produce the same result."}
{"example_id": 17, "sql_complexity": "basic SQL", "prompt": "What is the average number of military personnel per country involved in peacekeeping operations?", "context": "CREATE TABLE Peacekeeping_Operations (id INT, country VARCHAR(50), military_personnel INT); INSERT INTO Peacekeeping_Operations (id, country, military_personnel) VALUES (1, 'United States', 500), (2, 'United Kingdom', 300), (3, 'Canada', 250);", "reference_sql": "SELECT AVG(military_personnel) FROM Peacekeeping_Operations;", "generated_sql": "SELECT AVG(military_personnel) AS average_military_personnel\nFROM Peacekeeping_Operations;", "raw_model_output": "To find the average number of military personnel per country involved in peacekeeping operations, you can use the following SQL query:\n\n```sql\nSELECT AVG(military_personnel) AS average_military_personnel\nFROM Peacekeeping_Operations;\n```\n\nThis query calculates the average (mean) value of `military_personnel` across all entries in the `Peacekeeping_Operations` table.\n\nGiven the data you provided, let's calculate it step by step:\n\n1. The total number of military personnel is:\n   500 (United States) + 300 (United Kingdom) + 250 (Canada) = 1050\n\n2. There are 3 countries in the table.\n\n3. Therefore, the average number of military personnel per country is:\n   \\( \\frac{1050}{3} = 350 \\)\n\nSo, the average number of military personnel per country involved in peacekeeping operations is **350**.", "latency_sec": 2.7248239517211914, "total_duration": 2486334498, "load_duration": 15758230, "tokens_prompt": 120, "prompt_eval_duration": 8709867, "tokens_completion": 204, "eval_duration": 2459809501, "tokens_total": 324, "tokens_per_sec": 118.90676452522325, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average of the military_personnel column from the Peacekeeping_Operations table. The only difference is that the second query assigns an alias to the result, but this does not affect the result set values."}
{"example_id": 18, "sql_complexity": "window functions", "prompt": "What is the maximum daily investment for each client?", "context": "CREATE TABLE daily_investments (client_id INT, date DATE, investment FLOAT); INSERT INTO daily_investments (client_id, date, investment) VALUES (1, '2022-01-01', 1000.00), (1, '2022-01-02', 2000.00), (2, '2022-01-01', 3000.00), (2, '2022-01-02', 4000.00);", "reference_sql": "SELECT client_id, MAX(investment) OVER (PARTITION BY client_id ORDER BY client_id) as max_daily_investment FROM daily_investments;", "generated_sql": "SELECT client_id, MAX(investment) AS max_daily_investment\nFROM daily_investments\nGROUP BY client_id;", "raw_model_output": "To find the maximum daily investment for each client, you can use a SQL query with the `GROUP BY` clause to group the results by `client_id`, and then use the `MAX()` function to get the highest investment amount per client. Here's how you can write the query:\n\n```sql\nSELECT client_id, MAX(investment) AS max_daily_investment\nFROM daily_investments\nGROUP BY client_id;\n```\n\nThis query will return a result set with two columns: `client_id` and `max_daily_investment`, showing the maximum investment amount for each client.\n\nFor your provided data:\n\n- Client 1's maximum daily investment is $2000.00.\n- Client 2's maximum daily investment is $4000.00.\n\nThe result would look like this:\n\n```\nclient_id | max_daily_investment\n----------|----------------------\n1         | 2000.00\n2         | 4000.00\n```", "latency_sec": 2.6221041679382324, "total_duration": 2565443822, "load_duration": 18622262, "tokens_prompt": 168, "prompt_eval_duration": 13859204, "tokens_completion": 207, "eval_duration": 2527054776, "tokens_total": 375, "tokens_per_sec": 143.01491320799184, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query uses a window function MAX() OVER (PARTITION BY client_id ORDER BY client_id), which computes a running maximum of investment per client_id ordered by client_id. However, since the ORDER BY client_id is constant within each partition (all rows have the same client_id), the window function effectively returns the maximum investment per client_id for all rows of that client. The generated query uses GROUP BY client_id and aggregates MAX(investment), returning one row per client_id with the maximum investment. The key difference is that the reference query returns one row per original row (with max_daily_investment repeated), while the generated query returns one row per client_id. Therefore, their result sets differ in row count and structure, so they are not semantically equivalent."}
{"example_id": 19, "sql_complexity": "single join", "prompt": "List the ports with their total cargo weight for 'Fruit' type from the 'CARGO_HANDLING' table.", "context": "CREATE TABLE PORTS (ID INT, PortName VARCHAR(30)); CREATE TABLE CARGO_HANDLING (ID INT, PortID INT, CargoType VARCHAR(10), Weight INT); INSERT INTO PORTS (ID, PortName) VALUES (1, 'PortA'), (2, 'PortB'), (3, 'PortC'); INSERT INTO CARGO_HANDLING (ID, PortID, CargoType, Weight) VALUES (1, 1, 'Fruit', 100), (2, 1, 'Fruit', 200), (3, 2, 'Fruit', 300);", "reference_sql": "SELECT P.PortName, SUM(CH.Weight) FROM PORTS P JOIN CARGO_HANDLING CH ON P.ID = CH.PortID WHERE CH.CargoType = 'Fruit' GROUP BY P.PortName;", "generated_sql": "SELECT \n    P.PortName,\n    SUM(CH.Weight) AS TotalWeight\nFROM \n    PORTS P\nJOIN \n    CARGO_HANDLING CH ON P.ID = CH.PortID\nWHERE \n    CH.CargoType = 'Fruit'\nGROUP BY \n    P.PortName;", "raw_model_output": "To list the ports along with their total cargo weight for the 'Fruit' type from the `CARGO_HANDLING` table, you can use a SQL query that joins the `PORTS` and `CARGO_HANDLING` tables on the `PortID` and then groups by `PortName`, summing up the weights where `CargoType` is 'Fruit'. Here's how you can write this query:\n\n```sql\nSELECT \n    P.PortName,\n    SUM(CH.Weight) AS TotalWeight\nFROM \n    PORTS P\nJOIN \n    CARGO_HANDLING CH ON P.ID = CH.PortID\nWHERE \n    CH.CargoType = 'Fruit'\nGROUP BY \n    P.PortName;\n```\n\nThis query does the following:\n1. Joins the `PORTS` and `CARGO_HANDLING` tables on the `PortID`.\n2. Filters the rows to include only those where `CargoType` is 'Fruit'.\n3. Groups the results by `PortName`.\n4. Sums up the weights for each port.\n\nGiven your sample data, this query will return:\n\n```\nPortName | TotalWeight\n---------|------------\nPortA    | 300\n```\n\nThis result indicates that PortA has a total cargo weight of 300 units for 'Fruit'.", "latency_sec": 3.6548659801483154, "total_duration": 3390386031, "load_duration": 14623994, "tokens_prompt": 191, "prompt_eval_duration": 12786570, "tokens_completion": 278, "eval_duration": 3360270838, "tokens_total": 469, "tokens_per_sec": 128.3220787157202, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries perform the same operations: they join the PORTS and CARGO_HANDLING tables on PortID, filter rows where CargoType is 'Fruit', group by PortName, and sum the Weight. The only difference is the alias 'TotalWeight' in the second query, which does not affect the result set's data. Therefore, they are semantically equivalent."}
{"example_id": 20, "sql_complexity": "aggregation", "prompt": "What is the minimum fuel consumption of container ships built in 2016, grouped by container type?", "context": "CREATE TABLE container_ships (ship_id INT, ship_name VARCHAR(255), ship_builder VARCHAR(255), year INT, container_type VARCHAR(255), fuel_consumption INT);INSERT INTO container_ships (ship_id, ship_name, ship_builder, year, container_type, fuel_consumption) VALUES (1, 'Ever Golden', 'Imabari Shipbuilding', 2016, 'dry', 230), (2, 'HMM Oslo', 'Hyundai Heavy Industries', 2016, 'refrigerated', 250);", "reference_sql": "SELECT container_type, MIN(fuel_consumption) FROM container_ships WHERE year = 2016 GROUP BY container_type;", "generated_sql": "SELECT \n    container_type,\n    MIN(fuel_consumption) AS min_fuel_consumption\nFROM \n    container_ships\nWHERE \n    year = 2016\nGROUP BY \n    container_type;", "raw_model_output": "To find the minimum fuel consumption of container ships built in 2016, grouped by container type, you can use a SQL query with `GROUP BY` and `MIN()` functions. Here is the query:\n\n```sql\nSELECT \n    container_type,\n    MIN(fuel_consumption) AS min_fuel_consumption\nFROM \n    container_ships\nWHERE \n    year = 2016\nGROUP BY \n    container_type;\n```\n\nThis query will return the minimum fuel consumption for each container type of ships built in 2016.\n\nGiven the data you provided, let's run this query:\n\n```sql\nSELECT \n    container_type,\n    MIN(fuel_consumption) AS min_fuel_consumption\nFROM \n    container_ships\nWHERE \n    year = 2016\nGROUP BY \n    container_type;\n```\n\nThe result will be:\n\n| container_type | min_fuel_consumption |\n|----------------|---------------------|\n| dry            | 230                 |\n| refrigerated   | 250                 |\n\nThis shows that the minimum fuel consumption for a dry container ship built in 2016 is 230, and for a refrigerated container ship built in 2016, it is 250.", "latency_sec": 3.5657827854156494, "total_duration": 3253470243, "load_duration": 15379392, "tokens_prompt": 177, "prompt_eval_duration": 10936990, "tokens_completion": 268, "eval_duration": 3224804449, "tokens_total": 445, "tokens_per_sec": 124.79728204984535, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the container_type and the minimum fuel_consumption for ships from the year 2016, grouping by container_type. The only difference is the alias 'min_fuel_consumption' in the generated query, which does not affect the result set's data or grouping."}
