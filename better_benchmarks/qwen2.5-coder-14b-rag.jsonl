{"example_id": 2656, "sql_complexity": "multiple_joins", "prompt": "Find the drugs and their respective total sales for rare diseases indication with sales greater than the average sales for infectious diseases.", "context": "CREATE TABLE sales (id INT, drug_id INT, quarter INT, year INT, revenue FLOAT); INSERT INTO sales (id, drug_id, quarter, year, revenue) VALUES (1, 1, 1, 2022, 1500000); CREATE TABLE drugs (id INT, name VARCHAR(50), company VARCHAR(50), indication VARCHAR(50)); INSERT INTO drugs (id, name, company, indication) VALUES (1, 'DrugA', 'ABC Corp', 'Rare_Diseases');", "reference_sql": "SELECT s.drug_id, d.name, SUM(s.revenue) as total_sales FROM sales s JOIN drugs d ON s.drug_id = d.id WHERE d.indication = 'Rare_Diseases' GROUP BY s.drug_id HAVING total_sales > (SELECT AVG(s2.revenue) FROM sales s2 JOIN drugs d2 ON s2.drug_id = d2.id WHERE d2.indication = 'Infectious_Diseases')", "generated_sql": "SELECT d.name, SUM(s.revenue) AS total_sales\nFROM drugs d\nJOIN sales s ON d.id = s.drug_id\nWHERE d.indication = 'Rare_Diseases'\nGROUP BY d.name\nHAVING SUM(s.revenue) > (SELECT AVG(revenue) FROM sales JOIN drugs ON sales.drug_id = drugs.id WHERE drugs.indication = 'Infectious Diseases');", "raw_model_output": "```sql\nSELECT d.name, SUM(s.revenue) AS total_sales\nFROM drugs d\nJOIN sales s ON d.id = s.drug_id\nWHERE d.indication = 'Rare_Diseases'\nGROUP BY d.name\nHAVING SUM(s.revenue) > (SELECT AVG(revenue) FROM sales JOIN drugs ON sales.drug_id = drugs.id WHERE drugs.indication = 'Infectious Diseases');\n```", "latency_sec": 7.821384906768799, "total_duration_sec": 7.815255085, "load_duration_sec": 5.395555507, "tokens_prompt": 782, "prompt_eval_sec": 0.448172312, "tokens_completion": 87, "completion_eval_sec": 1.961523419, "tokens_total": 869, "tokens_per_sec": 111.10564310010471, "retrieval_latency_sec": 0.8168859481811523, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in several key aspects. 1) The Reference SQL groups by drug_id while the Generated SQL groups by name, which could lead to different results if multiple drugs share the same name. 2) The subquery in the HAVING clause uses different indication values ('Infectious_Diseases' vs 'Infectious Diseases'). 3) The Reference SQL includes drug_id in the output, while the Generated SQL does not. These differences mean the queries are not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in two critical aspects. 1) The Reference SQL correctly uses 'Rare_Diseases' (matching the database schema) in the WHERE clause, while the Generated SQL uses 'Rare_Diseases' (which is correct) but the subquery uses 'Infectious Diseases' (with a space) instead of 'Infectious_Diseases' (with an underscore) - this would lead to incorrect average calculation. 2) The Reference SQL groups by drug_id (ensuring unique drug identification) while the Generated SQL groups by name (which could be problematic if multiple drugs have the same name). The Generated SQL's subquery also lacks the JOIN condition in the subquery, which is present in the Reference SQL. These differences mean the queries would not produce identical results and the Generated SQL would fail to fulfill the business intent due to the incorrect indication filter in the subquery.", "overall_assessment": "incorrect"}}
{"example_id": 3008, "sql_complexity": "multiple_joins", "prompt": "Who are the users who used electric vehicles and their trip details?", "context": "CREATE TABLE users (id INT, name VARCHAR(50), age INT, gender VARCHAR(10), city VARCHAR(50));CREATE TABLE vehicles (id INT, vehicle_type VARCHAR(20), is_electric BOOLEAN);CREATE TABLE trips (id INT, user_id INT, vehicle_id INT, trip_distance FLOAT, trip_duration INT, departure_time TIMESTAMP, arrival_time TIMESTAMP);INSERT INTO users (id, name, age, gender, city) VALUES (3, 'Alex', 30, 'Female', 'New York');INSERT INTO vehicles (id, vehicle_type, is_electric) VALUES (1, 'Tesla', true), (2, 'Bike', false);INSERT INTO trips (id, user_id, vehicle_id, trip_distance, trip_duration, departure_time, arrival_time) VALUES (3, 3, 1, 15.3, 25, '2022-01-03 12:00:00', '2022-01-03 12:25:00');", "reference_sql": "SELECT u.name, v.vehicle_type, t.trip_distance, t.trip_duration FROM users u JOIN trips t ON u.id = t.user_id JOIN vehicles v ON t.vehicle_id = v.id WHERE v.is_electric = true;", "generated_sql": "SELECT u.name AS user_name, t.trip_distance, t.trip_duration, t.departure_time, t.arrival_time\nFROM users u\nJOIN trips t ON u.id = t.user_id\nJOIN vehicles v ON t.vehicle_id = v.id\nWHERE v.is_electric = true;", "raw_model_output": "```sql\nSELECT u.name AS user_name, t.trip_distance, t.trip_duration, t.departure_time, t.arrival_time\nFROM users u\nJOIN trips t ON u.id = t.user_id\nJOIN vehicles v ON t.vehicle_id = v.id\nWHERE v.is_electric = true;\n```", "latency_sec": 1.9803509712219238, "total_duration_sec": 1.833374428, "load_duration_sec": 0.013361151, "tokens_prompt": 803, "prompt_eval_sec": 0.325283516, "tokens_completion": 64, "completion_eval_sec": 1.490516051, "tokens_total": 867, "tokens_per_sec": 437.8011840320609, "retrieval_latency_sec": 0.11266565322875977, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query selects 4 columns (name, vehicle_type, trip_distance, trip_duration), while the generated query selects 5 columns (name, trip_distance, trip_duration, departure_time, arrival_time). The additional columns in the generated query result in different output structures, even though both filter for electric vehicles and join the same tables.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because the generated query includes additional columns (departure_time, arrival_time) not present in the reference. Both fulfill the business intent of identifying electric vehicle users and their trip details, but the generated query provides more comprehensive trip information. The generated query is more elegant as it explicitly aliases the user name and includes temporal details that enhance the trip context. The reference query is correct but less detailed.", "overall_assessment": "differently_correct"}}
{"example_id": 2531, "sql_complexity": "basic SQL", "prompt": "Who is the top customer by sales in 2022?", "context": "CREATE TABLE customers (customer_id INT, total_sales_2022 FLOAT); INSERT INTO customers (customer_id, total_sales_2022) VALUES (1, 25000.0), (2, 30000.0), (3, 22000.0), (4, 35000.0);", "reference_sql": "SELECT customer_id, total_sales_2022 FROM customers ORDER BY total_sales_2022 DESC LIMIT 1;", "generated_sql": "SELECT customer_id \nFROM customers \nORDER BY total_sales_2022 DESC \nLIMIT 1;", "raw_model_output": "```sql\nSELECT customer_id \nFROM customers \nORDER BY total_sales_2022 DESC \nLIMIT 1;\n```", "latency_sec": 1.445910930633545, "total_duration_sec": 1.365537514, "load_duration_sec": 0.014272051, "tokens_prompt": 1433, "prompt_eval_sec": 0.635755594, "tokens_completion": 27, "completion_eval_sec": 0.711198044, "tokens_total": 1460, "tokens_per_sec": 1009.7440783301097, "retrieval_latency_sec": 0.11216402053833008, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent because the first query returns both 'customer_id' and 'total_sales_2022' columns, while the second query only returns 'customer_id'. Although both order by 'total_sales_2022' descending and limit to 1 result, the result sets differ in column structure.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "While both queries correctly identify the top customer by sales, they differ in output. The reference query returns both customer_id and total_sales_2022, while the generated query only returns customer_id. The original question asks 'who is the top customer,' which primarily requires the customer identifier. The generated query is more efficient as it retrieves only the necessary column, and both would return the same single customer_id result. The reference query's additional column isn't required to answer the question.", "overall_assessment": "differently_correct"}}
{"example_id": 3792, "sql_complexity": "single join", "prompt": "What is the maximum distance traveled by an electric vehicle in a single trip, grouped by vehicle model?", "context": "CREATE TABLE Trips (trip_id INT, vehicle_id INT, distance FLOAT); CREATE TABLE ElectricVehicleModels (vehicle_id INT, vehicle_model TEXT);", "reference_sql": "SELECT evm.vehicle_model, MAX(trips.distance) AS max_distance_traveled FROM Trips trips INNER JOIN ElectricVehicleModels evm ON trips.vehicle_id = evm.vehicle_id GROUP BY 1;", "generated_sql": "SELECT vehicle_model, MAX(distance) as max_distance \nFROM Trips \nJOIN ElectricVehicleModels ON Trips.vehicle_id = ElectricVehicleModels.vehicle_id \nGROUP BY vehicle_model;", "raw_model_output": "```sql\nSELECT vehicle_model, MAX(distance) as max_distance \nFROM Trips \nJOIN ElectricVehicleModels ON Trips.vehicle_id = ElectricVehicleModels.vehicle_id \nGROUP BY vehicle_model;\n```", "latency_sec": 1.5329718589782715, "total_duration_sec": 1.395316525, "load_duration_sec": 0.019888066, "tokens_prompt": 924, "prompt_eval_sec": 0.35853901, "tokens_completion": 41, "completion_eval_sec": 1.008940503, "tokens_total": 965, "tokens_per_sec": 629.4962261363195, "retrieval_latency_sec": 0.11486315727233887, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between Trips and ElectricVehicleModels on vehicle_id, group by vehicle_model, and calculate the maximum distance. The reference uses an alias (evm) and groups by column position (1), while the generated query uses the column name directly. These are syntactic differences with no impact on semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the maximum distance per vehicle model by joining the Trips and ElectricVehicleModels tables. The Reference SQL uses a positional GROUP BY (GROUP BY 1) which is functionally equivalent to grouping by the first column (vehicle_model). The Generated SQL explicitly groups by the column name, making it more readable. While both are technically correct, the Generated SQL is more elegant due to its clarity and directness without unnecessary aliases. Both fulfill the business intent of identifying the maximum trip distance per model.", "overall_assessment": "correct"}}
{"example_id": 2311, "sql_complexity": "subqueries", "prompt": "Determine the percentage of sales from each ingredient category", "context": "CREATE TABLE Sales_Details (sale_id INT, ingredient_id INT, quantity INT); INSERT INTO Sales_Details (sale_id, ingredient_id, quantity) VALUES (1, 1, 2), (1, 2, 8), (2, 1, 3), (2, 2, 7); CREATE TABLE Ingredient_Categories (ingredient_id INT, ingredient_category VARCHAR(255)); INSERT INTO Ingredient_Categories (ingredient_id, ingredient_category) VALUES (1, 'Legumes'), (2, 'Poultry');", "reference_sql": "SELECT ingredient_category, SUM(quantity) AS total_quantity, SUM(quantity) * 100.0 / (SELECT SUM(quantity) FROM Sales_Details) AS percentage_of_sales FROM Sales_Details, Ingredient_Categories WHERE Sales_Details.ingredient_id = Ingredient_Categories.ingredient_id GROUP BY ingredient_category;", "generated_sql": "SELECT \n    ic.ingredient_category,\n    100.0 * SUM(sd.quantity) / (SELECT SUM(quantity) FROM Sales_Details) AS percentage\nFROM \n    Sales_Details sd\nJOIN \n    Ingredient_Categories ic ON sd.ingredient_id = ic.ingredient_id\nGROUP BY \n    ic.ingredient_category;", "raw_model_output": "```sql\nSELECT \n    ic.ingredient_category,\n    100.0 * SUM(sd.quantity) / (SELECT SUM(quantity) FROM Sales_Details) AS percentage\nFROM \n    Sales_Details sd\nJOIN \n    Ingredient_Categories ic ON sd.ingredient_id = ic.ingredient_id\nGROUP BY \n    ic.ingredient_category;\n```", "latency_sec": 2.1282167434692383, "total_duration_sec": 2.006412724, "load_duration_sec": 0.013977866, "tokens_prompt": 789, "prompt_eval_sec": 0.315144151, "tokens_completion": 72, "completion_eval_sec": 1.674461056, "tokens_total": 861, "tokens_per_sec": 404.56405704076496, "retrieval_latency_sec": 0.11666369438171387, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the selected columns. The Reference SQL includes 'total_quantity' as an explicit column, while the Generated SQL omits it and only returns 'percentage'. Although the percentage calculation and grouping logic are equivalent, the result sets have different structures due to the missing column in the Generated SQL.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the percentage of sales per ingredient category by joining the tables, aggregating quantities, and dividing by total sales. The generated query uses explicit JOIN syntax which is more modern and readable compared to the reference query's implicit join (comma-separated tables). The generated version also has clearer formatting and avoids potential ambiguity in complex joins. While both produce identical results, the generated query is more efficient, elegant, and adheres to best practices.", "overall_assessment": "correct"}}
{"example_id": 3329, "sql_complexity": "set operations", "prompt": "Which causes received funding from donors in both the United States and Canada?", "context": "CREATE TABLE donor_location (donor_id INT, country VARCHAR(50), cause VARCHAR(50), donation DECIMAL(10,2)); INSERT INTO donor_location (donor_id, country, cause, donation) VALUES (1, 'United States', 'Global Health', 1000.00), (2, 'Canada', 'Education', 2000.00), (3, 'United States', 'Environment', 1500.00), (4, 'Canada', 'Animal Welfare', 2500.00);", "reference_sql": "SELECT cause FROM donor_location WHERE country = 'United States' INTERSECT SELECT cause FROM donor_location WHERE country = 'Canada';", "generated_sql": "SELECT cause \nFROM donor_location \nWHERE country IN ('United States', 'Canada') \nGROUP BY cause \nHAVING COUNT(DISTINCT country) = 2;", "raw_model_output": "```sql\nSELECT cause \nFROM donor_location \nWHERE country IN ('United States', 'Canada') \nGROUP BY cause \nHAVING COUNT(DISTINCT country) = 2;\n```", "latency_sec": 1.4185068607330322, "total_duration_sec": 1.342599877, "load_duration_sec": 0.01426425, "tokens_prompt": 949, "prompt_eval_sec": 0.362884122, "tokens_completion": 39, "completion_eval_sec": 0.961849672, "tokens_total": 988, "tokens_per_sec": 696.5070295743496, "retrieval_latency_sec": 0.1138162612915039, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve causes that appear in both 'United States' and 'Canada'. The reference uses INTERSECT to find common causes between the two countries, while the generated query groups by cause and ensures presence in both countries via COUNT(DISTINCT country) = 2. The sample data shows no overlapping causes, but semantically they are equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify causes that received funding from both the United States and Canada. The Reference SQL uses INTERSECT to find common causes between two country-specific subqueries, while the Generated SQL uses GROUP BY and HAVING to ensure each cause appears in both countries. Technically, they produce identical results. However, the Generated SQL is more efficient as it requires a single table scan and avoids the overhead of INTERSECT, making it more elegant and performant.", "overall_assessment": "correct"}}
{"example_id": 2912, "sql_complexity": "single join", "prompt": "Which company has manufactured the most satellites?", "context": "CREATE TABLE manufacturers (id INT, name TEXT); CREATE TABLE satellites (id INT, manufacturer_id INT, name TEXT, launch_date DATE); INSERT INTO manufacturers (id, name) VALUES (1, 'SpaceX'), (2, 'Blue Origin'), (3, 'ISRO'), (4, 'CAST'); INSERT INTO satellites (id, manufacturer_id, name, launch_date) VALUES (1, 1, 'StarDragon', '2012-05-25'), (2, 1, 'Falcon', '2015-12-21'), (3, 2, 'New Glenn', '2022-01-11'), (4, 3, 'ChinaSat 1E', '2000-12-05'), (5, 3, 'ChinaSat 2A', '2003-08-13'), (6, 4, 'Shijian 9', '2017-11-19'), (7, 1, 'StarLink', '2020-05-24'), (8, 1, 'StarLink', '2020-06-13');", "reference_sql": "SELECT m.name, COUNT(s.id) FROM manufacturers m JOIN satellites s ON m.id = s.manufacturer_id GROUP BY m.name ORDER BY COUNT(s.id) DESC;", "generated_sql": "SELECT m.name \nFROM manufacturers m \nJOIN satellites s ON m.id = s.manufacturer_id \nGROUP BY m.name \nORDER BY COUNT(s.id) DESC \nLIMIT 1;", "raw_model_output": "```sql\nSELECT m.name \nFROM manufacturers m \nJOIN satellites s ON m.id = s.manufacturer_id \nGROUP BY m.name \nORDER BY COUNT(s.id) DESC \nLIMIT 1;\n```", "latency_sec": 1.7754192352294922, "total_duration_sec": 1.463623862, "load_duration_sec": 0.018538635, "tokens_prompt": 1025, "prompt_eval_sec": 0.386770206, "tokens_completion": 42, "completion_eval_sec": 1.055296035, "tokens_total": 1067, "tokens_per_sec": 600.9848146441191, "retrieval_latency_sec": 0.11605191230773926, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns all manufacturers with their satellite counts sorted descending, while the Generated SQL only returns the top result due to LIMIT 1. They differ in output quantity and purpose (all vs. top 1).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in their output structure. The reference query returns all manufacturers sorted by satellite count, while the generated query explicitly retrieves only the top result using LIMIT 1. Both correctly join tables and count satellites, but the generated query directly addresses the business intent of identifying 'the company' with the most satellites. The generated query is more efficient as it avoids unnecessary sorting and filtering, and its result aligns precisely with the question's requirement for a single answer.", "overall_assessment": "differently_correct"}}
{"example_id": 3170, "sql_complexity": "aggregation", "prompt": "Determine the total production quantity of silver for mining sites in Mexico, between the dates '2017-05-01' and '2017-09-30', having less than 40 employees.", "context": "CREATE TABLE silver_mine_2 (site_id INT, country VARCHAR(50), num_employees INT, extraction_date DATE, quantity INT); INSERT INTO silver_mine_2 (site_id, country, num_employees, extraction_date, quantity) VALUES (1, 'Mexico', 35, '2017-05-02', 1200), (2, 'Mexico', 30, '2017-08-31', 1800), (3, 'Mexico', 37, '2017-07-04', 2200);", "reference_sql": "SELECT country, SUM(quantity) as total_silver_prod FROM silver_mine_2 WHERE num_employees < 40 AND country = 'Mexico' AND extraction_date >= '2017-05-01' AND extraction_date <= '2017-09-30' GROUP BY country;", "generated_sql": "SELECT SUM(quantity) AS total_production_quantity\nFROM silver_mine_2\nWHERE country = 'Mexico'\n  AND extraction_date BETWEEN '2017-05-01' AND '2017-09-30'\n  AND num_employees < 40;", "raw_model_output": "```sql\nSELECT SUM(quantity) AS total_production_quantity\nFROM silver_mine_2\nWHERE country = 'Mexico'\n  AND extraction_date BETWEEN '2017-05-01' AND '2017-09-30'\n  AND num_employees < 40;\n```", "latency_sec": 2.3302860260009766, "total_duration_sec": 2.035641979, "load_duration_sec": 0.014506912, "tokens_prompt": 1027, "prompt_eval_sec": 0.387321402, "tokens_completion": 67, "completion_eval_sec": 1.630071338, "tokens_total": 1094, "tokens_per_sec": 469.4702657928317, "retrieval_latency_sec": 0.12388896942138672, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a GROUP BY country, which returns two columns (country and total_silver_prod), while the Generated SQL omits the GROUP BY and returns only the sum. Although both queries calculate the same total quantity, their result structures differ. The Reference SQL's output would have a 'country' column with 'Mexico' for all rows, whereas the Generated SQL returns a single column. This structural difference makes them non-equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically correct and would produce identical results. The reference query includes an unnecessary GROUP BY country clause, which is redundant since the WHERE clause already filters to Mexico. The generated query uses BETWEEN for date range filtering, which is more concise and achieves the same outcome. While both fulfill the business intent of calculating total silver production for Mexican sites with <40 employees between the specified dates, the generated query is more efficient and elegant by avoiding redundant grouping and using a cleaner date range syntax.", "overall_assessment": "correct"}}
{"example_id": 3518, "sql_complexity": "basic SQL", "prompt": "Insert new records of ticket sales for a new event, including event and salesperson information.", "context": "CREATE TABLE salesperson (salesperson_id INT, name VARCHAR(50), position VARCHAR(50)); CREATE TABLE tickets (ticket_id INT, salesperson_id INT, event_id INT, price DECIMAL(5,2), quantity INT); CREATE TABLE events (event_id INT, name VARCHAR(50), date DATE); INSERT INTO salesperson VALUES (1, 'John Doe', 'Senior Salesperson'); INSERT INTO events VALUES (2, 'New Event', '2023-04-15');", "reference_sql": "INSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity) VALUES (2, 1, 2, 75, 50), (3, 2, 2, 65, 75); INSERT INTO events (event_id, name, date) VALUES (2, 'New Event', '2023-04-15');", "generated_sql": "INSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity) \nVALUES (3, 1, 2, 50, 75);", "raw_model_output": "```sql\nINSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity) \nVALUES (3, 1, 2, 50, 75);\n```", "latency_sec": 1.5817639827728271, "total_duration_sec": 1.413124796, "load_duration_sec": 0.014256536, "tokens_prompt": 956, "prompt_eval_sec": 0.359748071, "tokens_completion": 42, "completion_eval_sec": 1.034355221, "tokens_total": 998, "tokens_per_sec": 630.9411586490352, "retrieval_latency_sec": 0.11366391181945801, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL inserts two rows into the tickets table and one row into the events table, while the Generated SQL only inserts a single row into the tickets table. The events table insertion in the Reference SQL is redundant due to existing data, but the tickets table data differs in both quantity of rows and values. The generated query does not replicate the full dataset of the reference query.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is not technically equivalent because it contains two INSERT operations, including a redundant insertion into the events table for an existing event (event_id=2). The Generated SQL is a single, focused INSERT into the tickets table. While neither fully fulfills the business intent (neither inserts a *new* event), the Generated SQL avoids violating data integrity by not reinserting an existing event. The Reference SQL's second INSERT into events would fail if event_id is a primary key (implied by the context's INSERT statement). The Generated SQL better addresses the core requirement of inserting ticket sales records without unnecessary operations.", "overall_assessment": "differently_correct"}}
{"example_id": 3925, "sql_complexity": "set operations", "prompt": "What is the total number of students and staff with accommodations in the \"disability_services\" schema, excluding the \"accessibility_parking\" type?", "context": "CREATE SCHEMA disability_services; CREATE TABLE staff (id INT, name VARCHAR(50), accommodation VARCHAR(50)); CREATE TABLE students (id INT, name VARCHAR(50), accommodation VARCHAR(50));", "reference_sql": "SELECT COUNT(*) FROM disability_services.staff WHERE accommodation != 'accessibility_parking' UNION SELECT COUNT(*) FROM disability_services.students WHERE accommodation != 'accessibility_parking';", "generated_sql": "SELECT COUNT(*) \nFROM (\n    SELECT * FROM disability_services.staff WHERE accommodation != 'accessibility_parking'\n    UNION ALL\n    SELECT * FROM disability_services.students WHERE accommodation != 'accessibility_parking'\n) AS combined;", "raw_model_output": "```sql\nSELECT COUNT(*) \nFROM (\n    SELECT * FROM disability_services.staff WHERE accommodation != 'accessibility_parking'\n    UNION ALL\n    SELECT * FROM disability_services.students WHERE accommodation != 'accessibility_parking'\n) AS combined;\n```", "latency_sec": 1.502838134765625, "total_duration_sec": 1.449732835, "load_duration_sec": 0.014476325, "tokens_prompt": 625, "prompt_eval_sec": 0.281718572, "tokens_completion": 51, "completion_eval_sec": 1.15048741, "tokens_total": 676, "tokens_per_sec": 449.815575185298, "retrieval_latency_sec": 0.11567926406860352, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate counts (staff and students) as two rows, while the Generated SQL combines all matching rows (staff and students) into a single count. The structure and result format differ: the first produces two rows with individual counts, the second produces one row with a combined total.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL uses UNION between two separate COUNT(*) queries, which would return two rows (one for staff, one for students) rather than a single total. The Generated SQL correctly combines all relevant records using UNION ALL (preserving duplicates where necessary) and then applies a single COUNT(*), producing the correct aggregated total. While both queries exclude 'accessibility_parking', only the Generated SQL satisfies the requirement for a single numeric result. The Reference SQL fails to fulfill the business intent of providing a total count.", "overall_assessment": "differently_correct"}}
{"example_id": 3340, "sql_complexity": "subqueries", "prompt": "Calculate the total revenue for garments manufactured in the US and sold in California.", "context": "CREATE TABLE garment_manufacturing(id INT PRIMARY KEY, garment_id INT, country VARCHAR(50), material VARCHAR(50), manufacturing_date DATE, quantity INT); CREATE TABLE garment_sales(id INT PRIMARY KEY, garment_id INT, store_id INT, sale_date DATE, units INT, revenue DECIMAL(10,2));", "reference_sql": "SELECT SUM(gs.revenue) FROM garment_manufacturing gm JOIN garment_sales gs ON gm.garment_id = gs.garment_id WHERE gm.country = 'United States' AND gs.store_id IN (SELECT id FROM stores WHERE region = 'California');", "generated_sql": "SELECT SUM(garment_sales.revenue) \nFROM garment_sales \nJOIN garment_manufacturing ON garment_sales.garment_id = garment_manufacturing.garment_id \nWHERE garment_manufacturing.country = 'US' AND garment_sales.store_id IN (\n    SELECT store_id FROM stores WHERE state = 'California'\n);", "raw_model_output": "```sql\nSELECT SUM(garment_sales.revenue) \nFROM garment_sales \nJOIN garment_manufacturing ON garment_sales.garment_id = garment_manufacturing.garment_id \nWHERE garment_manufacturing.country = 'US' AND garment_sales.store_id IN (\n    SELECT store_id FROM stores WHERE state = 'California'\n);\n```", "latency_sec": 2.106168031692505, "total_duration_sec": 2.075660413, "load_duration_sec": 0.017160622, "tokens_prompt": 933, "prompt_eval_sec": 0.352146813, "tokens_completion": 71, "completion_eval_sec": 1.701970125, "tokens_total": 1004, "tokens_per_sec": 476.69510926589805, "retrieval_latency_sec": 0.11816215515136719, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects: 1) The country filter uses 'United States' vs 'US' (different string values), and 2) The subquery references 'region' vs 'state' columns in the stores table (different column names). These differences would produce different results unless the data explicitly maps 'US' to 'United States' and 'region' to 'state', which is not guaranteed by the schema.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent due to two key differences: 1) The reference uses 'United States' while the generated uses 'US' for country comparison, which may yield different results if the database stores full country names. 2) The reference references 'region' in the stores table while the generated uses 'state' - this matters if the stores table has a 'state' column (more semantically accurate for California). Both queries correctly join garment_manufacturing and garment_sales, and filter for California sales. The generated query is more precise in using 'state' (aligning with the business term 'California') and may better handle US country codes. However, neither query is fully complete without knowing the stores table structure, but the generated version shows better alignment with typical schema design.", "overall_assessment": "differently_correct"}}
{"example_id": 596, "sql_complexity": "basic SQL", "prompt": "What is the minimum energy production cost of wind farms in Spain?", "context": "CREATE TABLE wind_farm_costs (id INT, name TEXT, country TEXT, energy_production_cost FLOAT); INSERT INTO wind_farm_costs (id, name, country, energy_production_cost) VALUES (1, 'Las Tiesas', 'Spain', 0.045), (2, 'Eolo', 'Spain', 0.050);", "reference_sql": "SELECT MIN(energy_production_cost) FROM wind_farm_costs WHERE country = 'Spain';", "generated_sql": "SELECT MIN(energy_production_cost) AS min_cost \nFROM wind_farm_costs \nWHERE country = 'Spain';", "raw_model_output": "```sql\nSELECT MIN(energy_production_cost) AS min_cost \nFROM wind_farm_costs \nWHERE country = 'Spain';\n```", "latency_sec": 1.2728888988494873, "total_duration_sec": 0.976339366, "load_duration_sec": 0.014449645, "tokens_prompt": 705, "prompt_eval_sec": 0.307109564, "tokens_completion": 28, "completion_eval_sec": 0.651589414, "tokens_total": 733, "tokens_per_sec": 575.8554424211956, "retrieval_latency_sec": 0.11947894096374512, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the minimum energy_production_cost for wind farms in Spain. The generated query adds an alias (min_cost) to the result column, but this does not affect the semantic meaning or the actual computed value. The WHERE clause and aggregate function (MIN) are identical in both queries.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly retrieve the minimum energy production cost for Spanish wind farms using the MIN() aggregate function and filtering by country. The generated query adds an explicit alias (AS min_cost) which improves readability without altering the result. While the reference query is technically correct, the generated version is more elegant as it clarifies the output column name, making it slightly more suitable for business reporting contexts. Both queries fulfill the business intent of identifying the minimum cost.", "overall_assessment": "correct"}}
{"example_id": 2604, "sql_complexity": "subqueries", "prompt": "What is the maximum number of virtual tours taken by a single user in the UK?", "context": "CREATE TABLE virtual_tour_data (user_id INT, hotel_id INT, tour_date DATE); INSERT INTO virtual_tour_data (user_id, hotel_id, tour_date) VALUES (1, 10, '2022-01-01'), (2, 11, '2022-01-03'), (3, 12, '2022-01-05'), (4, 10, '2022-01-07'), (5, 10, '2022-01-09'); CREATE TABLE hotels (hotel_id INT, hotel_name TEXT, country TEXT); INSERT INTO hotels (hotel_id, hotel_name, country) VALUES (10, 'Royal Park Hotel', 'UK'), (11, 'The Ritz London', 'UK'), (12, 'Hotel de Crillon', 'France');", "reference_sql": "SELECT MAX(vt.user_tours) FROM (SELECT user_id, COUNT(DISTINCT hotel_id) as user_tours FROM virtual_tour_data WHERE country = 'UK' GROUP BY user_id) as vt;", "generated_sql": "SELECT MAX(tour_count) AS max_tours\nFROM (\n    SELECT user_id, COUNT(*) AS tour_count\n    FROM virtual_tour_data vtd\n    JOIN hotels h ON vtd.hotel_id = h.hotel_id\n    WHERE h.country = 'UK'\n    GROUP BY user_id\n) AS user_tour_counts;", "raw_model_output": "To find the maximum number of virtual tours taken by a single user in the UK, we need to:\n\n1. Join the `virtual_tour_data` table with the `hotels` table on the `hotel_id` column.\n2. Filter the results to only include rows where the country is 'UK'.\n3. Group the results by `user_id`.\n4. Count the number of tours for each user.\n5. Find the maximum count from these grouped results.\n\nHere's the SQL query that accomplishes this:\n\n```sql\nSELECT MAX(tour_count) AS max_tours\nFROM (\n    SELECT user_id, COUNT(*) AS tour_count\n    FROM virtual_tour_data vtd\n    JOIN hotels h ON vtd.hotel_id = h.hotel_id\n    WHERE h.country = 'UK'\n    GROUP BY user_id\n) AS user_tour_counts;\n```", "latency_sec": 4.649798154830933, "total_duration_sec": 4.536892084, "load_duration_sec": 0.013711299, "tokens_prompt": 874, "prompt_eval_sec": 0.347351747, "tokens_completion": 180, "completion_eval_sec": 4.172356692, "tokens_total": 1054, "tokens_per_sec": 226.6765061414421, "retrieval_latency_sec": 0.11037611961364746, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references a 'country' column not present in the virtual_tour_data table, making it invalid. Even if corrected, the Reference SQL uses COUNT(DISTINCT hotel_id) to count unique hotels per user, while the Generated SQL uses COUNT(*) to count total tours per user. These approaches yield different results (distinct hotels vs. total visits) and the Reference SQL's structure is fundamentally flawed without a JOIN.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL contains a critical error: it references a 'country' column in the virtual_tour_data table, which does not exist. The country information is in the hotels table, requiring a JOIN to filter UK hotels. The Generated SQL correctly joins virtual_tour_data with hotels on hotel_id, filters by h.country = 'UK', and counts all tours (COUNT(*)) per user. The original question asks for the maximum number of tours (records) per user, not unique hotels. The Reference SQL's COUNT(DISTINCT hotel_id) would incorrectly count unique hotel visits instead of total tours. While both queries aim to find a maximum, only the Generated SQL addresses the business intent accurately and executes without syntax errors.", "overall_assessment": "differently_correct"}}
{"example_id": 5812, "sql_complexity": "single join", "prompt": "Calculate the percentage of Shariah-compliant investments held by each investor in the top 5 countries with the highest percentage?", "context": "CREATE TABLE investors (investor_id INT, investor_name TEXT, country TEXT); INSERT INTO investors (investor_id, investor_name, country) VALUES (1, 'Al Thani', 'Qatar'), (2, 'Saudi Investment Group', 'Saudi Arabia'), (3, 'Temasek Holdings', 'Singapore'); CREATE TABLE investments (investment_id INT, investor_id INT, investment_type TEXT, investment_value DECIMAL, is_shariah_compliant BOOLEAN); INSERT INTO investments (investment_id, investor_id, investment_type, investment_value, is_shariah_compliant) VALUES (1, 1, 'Real Estate', 15000000, true), (2, 2, 'Stocks', 20000000, false);", "reference_sql": "SELECT investor_name, ROUND((SUM(CASE WHEN is_shariah_compliant THEN investment_value ELSE 0 END) / SUM(investment_value)) * 100, 2) AS percentage FROM investments JOIN investors ON investments.investor_id = investors.investor_id GROUP BY investor_name ORDER BY percentage DESC LIMIT 5;", "generated_sql": "WITH CountryInvestmentStats AS (\n    SELECT \n        i.country,\n        COUNT(*) AS total_investments,\n        COUNT(CASE WHEN inv.is_shariah_compliant THEN 1 END) AS shariah_compliant_investments\n    FROM \n        investors i\n    JOIN \n        investments inv ON i.investor_id = inv.investor_id\n    GROUP BY \n        i.country\n),\nCountryShariahPercentage AS (\n    SELECT \n        country,\n        (shariah_compliant_investments * 100.0 / total_investments) AS shariah_percentage\n    FROM \n        CountryInvestmentStats\n)\nSELECT \n    country,\n    shariah_percentage\nFROM \n    CountryShariahPercentage\nORDER BY \n    shariah_percentage DESC\nLIMIT 5;", "raw_model_output": "```sql\nWITH CountryInvestmentStats AS (\n    SELECT \n        i.country,\n        COUNT(*) AS total_investments,\n        COUNT(CASE WHEN inv.is_shariah_compliant THEN 1 END) AS shariah_compliant_investments\n    FROM \n        investors i\n    JOIN \n        investments inv ON i.investor_id = inv.investor_id\n    GROUP BY \n        i.country\n),\nCountryShariahPercentage AS (\n    SELECT \n        country,\n        (shariah_compliant_investments * 100.0 / total_investments) AS shariah_percentage\n    FROM \n        CountryInvestmentStats\n)\nSELECT \n    country,\n    shariah_percentage\nFROM \n    CountryShariahPercentage\nORDER BY \n    shariah_percentage DESC\nLIMIT 5;\n```", "latency_sec": 4.884663105010986, "total_duration_sec": 4.649440575, "load_duration_sec": 0.018761014, "tokens_prompt": 1168, "prompt_eval_sec": 0.55038992, "tokens_completion": 176, "completion_eval_sec": 4.074665355, "tokens_total": 1344, "tokens_per_sec": 275.14691824319317, "retrieval_latency_sec": 0.11545777320861816, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL calculates the percentage of shariah-compliant investment value per investor, while the Generated SQL calculates the percentage of shariah-compliant investments (count-based) per country. Key differences: 1) Grouping by investor_name vs country, 2) Value-based calculation vs count-based calculation, 3) Different output columns (investor names vs country names).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL calculates the percentage of Shariah-compliant investments per investor and orders them, but it does not address the 'top 5 countries' requirement. The Generated SQL correctly calculates country-level Shariah compliance percentages and identifies the top 5 countries, aligning with the business intent of analyzing countries first. However, neither query fully addresses the 'each investor in the top 5 countries' aspect. The Generated SQL better fulfills the intent by focusing on country-level metrics, while the Reference SQL misinterprets the question by prioritizing individual investors over countries.", "overall_assessment": "differently_correct"}}
{"example_id": 4706, "sql_complexity": "multiple_joins", "prompt": "Who are the top 3 customers by total spend on makeup products from Italy and Spain?", "context": "CREATE TABLE customers (customer_id INT, customer_name TEXT, country TEXT); INSERT INTO customers (customer_id, customer_name, country) VALUES (1, 'Alessandro Martini', 'IT'), (2, 'Laura Rossi', 'ES'), (3, 'Daniela Gonzalez', 'MX'), (4, 'Jose Hernandez', 'ES'), (5, 'Sophia Rodriguez', 'IT'); CREATE TABLE sales (sale_id INT, customer_id INT, product_id INT, sale_quantity INT, sale_country TEXT); INSERT INTO sales (sale_id, customer_id, product_id, sale_quantity, sale_country) VALUES (1, 1, 1, 100, 'IT'), (2, 2, 2, 150, 'ES'), (3, 3, 3, 200, 'MX'), (4, 4, 4, 250, 'ES'), (5, 5, 5, 300, 'IT'); CREATE TABLE products (product_id INT, product_name TEXT, category TEXT); INSERT INTO products (product_id, product_name, category) VALUES (1, 'Eyeshadow Palette', 'makeup'), (2, 'Liquid Lipstick', 'makeup'), (3, 'BB Cream', 'makeup'), (4, 'Volumizing Mascara', 'makeup'), (5, 'Nourishing Lip Balm', 'makeup');", "reference_sql": "SELECT c.customer_name, SUM(s.sale_quantity) as total_spent_on_makeup FROM sales s JOIN customers c ON s.customer_id = c.customer_id JOIN products p ON s.product_id = p.product_id WHERE c.country IN ('IT', 'ES') AND p.category = 'makeup' GROUP BY c.customer_name ORDER BY total_spent_on_makeup DESC LIMIT 3;", "generated_sql": "SELECT c.customer_name, SUM(s.sale_quantity * p.product_price) AS total_spend\nFROM customers c\nJOIN sales s ON c.customer_id = s.customer_id\nJOIN products p ON s.product_id = p.product_id\nWHERE p.category = 'makeup' AND (c.country = 'IT' OR c.country = 'ES')\nGROUP BY c.customer_name\nORDER BY total_spend DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT c.customer_name, SUM(s.sale_quantity * p.product_price) AS total_spend\nFROM customers c\nJOIN sales s ON c.customer_id = s.customer_id\nJOIN products p ON s.product_id = p.product_id\nWHERE p.category = 'makeup' AND (c.country = 'IT' OR c.country = 'ES')\nGROUP BY c.customer_name\nORDER BY total_spend DESC\nLIMIT 3;\n```", "latency_sec": 2.986781120300293, "total_duration_sec": 2.849910182, "load_duration_sec": 0.01546508, "tokens_prompt": 1405, "prompt_eval_sec": 0.621558384, "tokens_completion": 92, "completion_eval_sec": 2.207231567, "tokens_total": 1497, "tokens_per_sec": 501.20847149639496, "retrieval_latency_sec": 0.11336994171142578, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the calculation of the total. The Reference SQL sums 'sale_quantity' directly, while the Generated SQL attempts to multiply 'sale_quantity' by 'product_price' (a column not present in the schema). Additionally, the Generated SQL references a non-existent 'product_price' column, making it invalid. Even if the column existed, the calculations would differ, leading to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent. The generated query references a 'product_price' column that does not exist in the provided schema (products table only has product_id, product_name, and category). This makes the generated query syntactically invalid. The reference query correctly uses available columns (sale_quantity) and properly joins tables. While both aim to calculate customer spend, the reference query uses quantity as a proxy for spend (which may not align with true business intent), whereas the generated query attempts to calculate actual spend but is invalid due to missing data. The reference query is the only technically valid solution.", "overall_assessment": "incorrect"}}
{"example_id": 1515, "sql_complexity": "multiple_joins", "prompt": "What is the average age of clients who lost cases in the 'personal injury' category?", "context": "CREATE TABLE Cases (CaseID int, ClientID int, Category varchar(50)); INSERT INTO Cases (CaseID, ClientID, Category) VALUES (701, 7, 'Personal Injury'); CREATE TABLE Clients (ClientID int, Age int, Gender varchar(10)); INSERT INTO Clients (ClientID, Age, Gender) VALUES (7, 45, 'Male'); CREATE TABLE CaseOutcomes (CaseID int, Outcome varchar(50)); INSERT INTO CaseOutcomes (CaseID, Outcome) VALUES (701, 'Lost');", "reference_sql": "SELECT AVG(C.Age) as AvgAge FROM Clients C INNER JOIN Cases CA ON C.ClientID = CA.ClientID INNER JOIN CaseOutcomes CO ON CA.CaseID = CO.CaseID WHERE CA.Category = 'Personal Injury' AND CO.Outcome = 'Lost';", "generated_sql": "SELECT AVG(Clients.Age) \nFROM Clients \nJOIN Cases ON Clients.ClientID = Cases.ClientID \nJOIN CaseOutcomes ON Cases.CaseID = CaseOutcomes.CaseID \nWHERE Cases.Category = 'Personal Injury' AND CaseOutcomes.Outcome = 'Lost';", "raw_model_output": "```sql\nSELECT AVG(Clients.Age) \nFROM Clients \nJOIN Cases ON Clients.ClientID = Cases.ClientID \nJOIN CaseOutcomes ON Cases.CaseID = CaseOutcomes.CaseID \nWHERE Cases.Category = 'Personal Injury' AND CaseOutcomes.Outcome = 'Lost';\n```", "latency_sec": 1.8184268474578857, "total_duration_sec": 1.728889962, "load_duration_sec": 0.01475041, "tokens_prompt": 747, "prompt_eval_sec": 0.303844033, "tokens_completion": 61, "completion_eval_sec": 1.407395898, "tokens_total": 808, "tokens_per_sec": 444.34011801440533, "retrieval_latency_sec": 0.11586594581604004, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average age of clients with 'Personal Injury' cases that resulted in 'Lost'. The differences are purely syntactic: the Reference uses table aliases (C, CA, CO) while the Generated uses full table names. The join conditions, filter criteria, and aggregate function are identical. Both use INNER JOIN (explicit in Reference, implicit in Generated) and reference the same columns (Clients.Age, Cases.Category, CaseOutcomes.Outcome).", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent, producing identical results by correctly joining the three tables (Clients, Cases, CaseOutcomes) with the same filtering conditions (Category = 'Personal Injury' and Outcome = 'Lost'). The reference query uses table aliases (C, CA, CO) while the generated query uses full table names, but this does not affect functionality. Both accurately calculate the average age of clients who lost personal injury cases. The generated query is slightly more concise, but neither demonstrates superior efficiency or elegance. Both fully address the business intent of identifying the average age of affected clients.", "overall_assessment": "correct"}}
{"example_id": 4388, "sql_complexity": "subqueries", "prompt": "Insert a new drug with a price 10% higher than the average price", "context": "CREATE TABLE drugs (drug_id INT, drug_name VARCHAR(50), price DECIMAL(10, 2)); INSERT INTO drugs (drug_id, drug_name, price) VALUES (1, 'DrugA', 50), (2, 'DrugB', 75), (3, 'DrugC', 100)", "reference_sql": "INSERT INTO drugs (drug_id, drug_name, price) VALUES ((SELECT MAX(drug_id) FROM drugs) + 1, 'DrugD', (SELECT AVG(price) * 1.1 FROM drugs))", "generated_sql": "INSERT INTO drugs (drug_name, price)\nVALUES ('NewDrug', (SELECT AVG(price) * 1.10 FROM drugs));", "raw_model_output": "```sql\nINSERT INTO drugs (drug_name, price)\nVALUES ('NewDrug', (SELECT AVG(price) * 1.10 FROM drugs));\n```", "latency_sec": 1.2940080165863037, "total_duration_sec": 1.107516868, "load_duration_sec": 0.014366523, "tokens_prompt": 773, "prompt_eval_sec": 0.308399908, "tokens_completion": 33, "completion_eval_sec": 0.781551261, "tokens_total": 806, "tokens_per_sec": 622.8709479917228, "retrieval_latency_sec": 0.11786198616027832, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL explicitly sets drug_id to (MAX(drug_id) + 1) and uses 'DrugD' as the drug_name, while the Generated SQL omits drug_id (relying on auto-increment) and uses 'NewDrug' as the drug_name. Although both calculate the price as AVG(price)*1.1, the drug_name and drug_id values differ, leading to different inserted rows.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query is technically correct as it properly calculates the next drug_id using (SELECT MAX(drug_id) FROM drugs) + 1 and includes all required columns in the INSERT. The generated query omits the drug_id column, which is required based on the schema (as seen in the context's INSERT statements). While both calculate the price correctly as AVG(price) * 1.1, the generated query would fail due to missing required values. Both fulfill the business intent of inserting a drug with a 10% higher price than average, but the reference query is more robust.", "overall_assessment": "differently_correct"}}
{"example_id": 5431, "sql_complexity": "basic SQL", "prompt": "What is the average CO2 emission of ride-hailing vehicles in San Francisco?", "context": "CREATE TABLE SFRideHailing (id INT, company VARCHAR(20), co2_emission DECIMAL(5,2));", "reference_sql": "SELECT AVG(co2_emission) FROM SFRideHailing WHERE company = 'Uber';", "generated_sql": "SELECT AVG(co2_emission) FROM SFRideHailing;", "raw_model_output": "```sql\nSELECT AVG(co2_emission) FROM SFRideHailing;\n```", "latency_sec": 0.9693970680236816, "total_duration_sec": 0.721878052, "load_duration_sec": 0.020629146, "tokens_prompt": 580, "prompt_eval_sec": 0.274214004, "tokens_completion": 19, "completion_eval_sec": 0.424524912, "tokens_total": 599, "tokens_per_sec": 617.9098532051336, "retrieval_latency_sec": 0.11992216110229492, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query calculates the average co2_emission specifically for 'Uber' entries, while the generated query calculates the average for all entries in the table without any company filter. The absence of the WHERE company = 'Uber' condition in the generated query means it would include data from all companies, leading to a different result.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query is technically incorrect for the stated question because it explicitly filters for 'Uber' which is not mentioned in the original question. The generated query correctly calculates the average CO2 emission for all ride-hailing vehicles in San Francisco without arbitrary company restrictions. While neither query specifies a location filter (though the table name implies SF), the generated query better aligns with the business intent of analyzing all ride-hailing vehicles rather than a subset. The reference query's company filter introduces a bias not supported by the original question.", "overall_assessment": "differently_correct"}}
{"example_id": 3531, "sql_complexity": "single join", "prompt": "What is the total number of workouts and total workout time per user for users with a membership type of 'Basic'?", "context": "CREATE TABLE Members (id INT, user_name VARCHAR, membership_type VARCHAR, signup_date DATE); CREATE TABLE Workouts (id INT, user_id INT, workout_date DATE, workout_duration INT); INSERT INTO Members (id, user_name, membership_type, signup_date) VALUES (1, 'John Doe', 'Premium', '2020-01-01'), (2, 'Jane Smith', 'Basic', '2019-06-15'), (3, 'Alice Johnson', 'Premium', '2020-03-20'); INSERT INTO Workouts (id, user_id, workout_date, workout_duration) VALUES (1, 1, '2020-01-01', 60), (2, 1, '2020-01-02', 70), (3, 2, '2019-06-15', 90), (4, 3, '2020-03-20', 65), (5, 3, '2020-03-21', 70);", "reference_sql": "SELECT Members.user_name, SUM(Workouts.workout_duration) AS total_workout_time, COUNT(Workouts.id) AS total_workouts FROM Members JOIN Workouts ON Members.id = Workouts.user_id WHERE Members.membership_type = 'Basic' GROUP BY Members.user_name;", "generated_sql": "SELECT \n    Members.user_name, \n    COUNT(Workouts.id) AS total_workouts, \n    SUM(Workouts.workout_duration) AS total_workout_time\nFROM \n    Members\nJOIN \n    Workouts ON Members.id = Workouts.user_id\nWHERE \n    Members.membership_type = 'Basic'\nGROUP BY \n    Members.user_name;", "raw_model_output": "```sql\nSELECT \n    Members.user_name, \n    COUNT(Workouts.id) AS total_workouts, \n    SUM(Workouts.workout_duration) AS total_workout_time\nFROM \n    Members\nJOIN \n    Workouts ON Members.id = Workouts.user_id\nWHERE \n    Members.membership_type = 'Basic'\nGROUP BY \n    Members.user_name;\n```", "latency_sec": 2.6250998973846436, "total_duration_sec": 2.372587489, "load_duration_sec": 0.014094573, "tokens_prompt": 1121, "prompt_eval_sec": 0.540732022, "tokens_completion": 79, "completion_eval_sec": 1.814127781, "tokens_total": 1200, "tokens_per_sec": 457.1254607093414, "retrieval_latency_sec": 0.11931014060974121, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same data by joining Members and Workouts tables on user_id, filtering for 'Basic' membership type. The GROUP BY clause and aggregation functions (SUM and COUNT) are identical, with only the column order in the SELECT clause differing. Semantic equivalence is maintained as the result set structure and values remain the same.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are structurally identical except for the order of columns in the SELECT clause. The reference query lists 'total_workout_time' first while the generated query lists 'total_workouts' first, but this does not affect the results. Both correctly join Members and Workouts tables on user_id, filter for 'Basic' membership, group by user_name, and calculate the required aggregates (COUNT and SUM). The business intent is fully satisfied as both return the total workouts and total workout time per eligible user.", "overall_assessment": "correct"}}
{"example_id": 5678, "sql_complexity": "set operations", "prompt": "How many public works projects are there in 'Sydney' and 'Melbourne' combined?", "context": "CREATE TABLE PublicWorksC(id INT, city VARCHAR(20), project VARCHAR(30)); INSERT INTO PublicWorksC(id, city, project) VALUES (1, 'Sydney', 'Park Renovation'), (2, 'Melbourne', 'Sidewalk Repair');", "reference_sql": "SELECT COUNT(*) FROM (SELECT city FROM PublicWorksC WHERE city = 'Sydney' UNION ALL SELECT city FROM PublicWorksC WHERE city = 'Melbourne') AS Total;", "generated_sql": "SELECT COUNT(*) AS TotalProjects \nFROM PublicWorksC \nWHERE city IN ('Sydney', 'Melbourne');", "raw_model_output": "```sql\nSELECT COUNT(*) AS TotalProjects \nFROM PublicWorksC \nWHERE city IN ('Sydney', 'Melbourne');\n```", "latency_sec": 1.0532400608062744, "total_duration_sec": 0.988957476, "load_duration_sec": 0.013707469, "tokens_prompt": 744, "prompt_eval_sec": 0.311523401, "tokens_completion": 28, "completion_eval_sec": 0.65932424, "tokens_total": 772, "tokens_per_sec": 732.9762973590465, "retrieval_latency_sec": 0.11932182312011719, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the total number of rows where the city is either 'Sydney' or 'Melbourne'. The Reference SQL uses a UNION ALL to combine results from two separate selects, while the Generated SQL uses a single WHERE clause with IN. Since UNION ALL preserves duplicates and the WHERE IN clause includes all matching rows, the final COUNT(*) will be identical in both cases.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count projects in Sydney and Melbourne. The Reference SQL uses a subquery with UNION ALL to combine city values before counting, which is logically equivalent but unnecessarily complex. The Generated SQL directly filters with WHERE city IN (...) and counts rows, achieving the same result with simpler, more efficient syntax. Both handle duplicates correctly (since each row represents a unique project), and both return the combined count of projects in the specified cities.", "overall_assessment": "correct"}}
{"example_id": 5792, "sql_complexity": "multiple_joins", "prompt": "How many cases were handled by attorneys in the 'Los Angeles' office?", "context": "CREATE TABLE offices (office_id INT, office_name VARCHAR(20), city VARCHAR(20), state VARCHAR(20)); INSERT INTO offices (office_id, office_name, city, state) VALUES (1, 'Boston', 'Boston', 'MA'), (2, 'New York', 'New York', 'NY'), (3, 'Los Angeles', 'Los Angeles', 'CA'); CREATE TABLE attorneys (attorney_id INT, office_id INT); INSERT INTO attorneys (attorney_id, office_id) VALUES (1, 1), (2, 2), (3, 3); CREATE TABLE cases (case_id INT, attorney_id INT); INSERT INTO cases (case_id, attorney_id) VALUES (1, 1), (2, 2), (3, 3);", "reference_sql": "SELECT COUNT(*) FROM cases JOIN attorneys ON cases.attorney_id = attorneys.attorney_id JOIN offices ON attorneys.office_id = offices.office_id WHERE offices.city = 'Los Angeles';", "generated_sql": "SELECT COUNT(*) \nFROM cases \nINNER JOIN attorneys ON cases.attorney_id = attorneys.attorney_id \nINNER JOIN offices ON attorneys.office_id = offices.office_id \nWHERE offices.city = 'Los Angeles';", "raw_model_output": "```sql\nSELECT COUNT(*) \nFROM cases \nINNER JOIN attorneys ON cases.attorney_id = attorneys.attorney_id \nINNER JOIN offices ON attorneys.office_id = offices.office_id \nWHERE offices.city = 'Los Angeles';\n```", "latency_sec": 1.491654872894287, "total_duration_sec": 1.482381634, "load_duration_sec": 0.018541568, "tokens_prompt": 895, "prompt_eval_sec": 0.348659047, "tokens_completion": 46, "completion_eval_sec": 1.109455734, "tokens_total": 941, "tokens_per_sec": 630.8429765486967, "retrieval_latency_sec": 0.11645078659057617, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform identical JOIN operations (implicit INNER JOIN vs explicit INNER JOIN) and apply the same WHERE condition filtering on offices.city = 'Los Angeles'. The semantic meaning and result set remain unchanged.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are structurally identical in terms of table relationships, join conditions, and filtering logic. The reference query uses implicit JOIN syntax while the generated query uses explicit INNER JOIN, but SQL standards treat these as functionally equivalent. Both correctly count cases linked to attorneys in the 'Los Angeles' office via the three-table join. The business intent is fully satisfied as both queries address the exact requirement of counting cases handled by attorneys in the specified office. Neither query demonstrates superior efficiency or elegance over the other.", "overall_assessment": "correct"}}
{"example_id": 5148, "sql_complexity": "window functions", "prompt": "List the unique types of smart city technologies that have been implemented in the top 3 most populous countries in the world.", "context": "CREATE TABLE smart_city_tech (tech_type VARCHAR(255), country VARCHAR(255)); CREATE TABLE country_populations (country VARCHAR(255), population INT);", "reference_sql": "SELECT DISTINCT tech_type FROM smart_city_tech SCT WHERE country IN (SELECT country FROM (SELECT country, ROW_NUMBER() OVER (ORDER BY population DESC) as rank FROM country_populations) CP WHERE rank <= 3);", "generated_sql": "SELECT DISTINCT tech_type \nFROM smart_city_tech \nWHERE country IN (\n    SELECT country \n    FROM country_populations \n    ORDER BY population DESC \n    LIMIT 3\n);", "raw_model_output": "```sql\nSELECT DISTINCT tech_type \nFROM smart_city_tech \nWHERE country IN (\n    SELECT country \n    FROM country_populations \n    ORDER BY population DESC \n    LIMIT 3\n);\n```", "latency_sec": 1.3725602626800537, "total_duration_sec": 1.302592523, "load_duration_sec": 0.016319583, "tokens_prompt": 741, "prompt_eval_sec": 0.308263519, "tokens_completion": 42, "completion_eval_sec": 0.974828467, "tokens_total": 783, "tokens_per_sec": 570.4667556607812, "retrieval_latency_sec": 0.11467409133911133, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the top 3 countries by population. The reference query uses a window function with ROW_NUMBER() to assign ranks and filter the top 3, while the generated query uses ORDER BY and LIMIT 3. Both approaches yield the same set of countries, ensuring the same DISTINCT tech_type results from the smart_city_tech table.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify unique smart city technologies in the top 3 most populous countries. The reference query uses a window function with ROW_NUMBER() to rank countries by population, while the generated query uses ORDER BY and LIMIT 3. Both approaches reliably retrieve the top 3 countries. However, the generated query is more efficient and elegant, as LIMIT 3 directly achieves the goal without the overhead of a window function. The reference query's approach could potentially include more than 3 countries if there are population ties (though the WHERE rank <= 3 condition would still limit it to 3). Both fulfill the business intent, but the generated query is simpler and more performant.", "overall_assessment": "correct"}}
{"example_id": 5547, "sql_complexity": "multiple_joins", "prompt": "Which species have a population growth rate higher than the average for protected areas?", "context": "CREATE TABLE species (id INT, name VARCHAR(50), population DECIMAL(5,2), protected_area_id INT, growth_rate DECIMAL(5,2)); INSERT INTO species (id, name, population, protected_area_id, growth_rate) VALUES (1, 'Species 1', 500.00, 1, 0.05), (2, 'Species 2', 800.00, 1, 0.03), (3, 'Species 3', 1200.00, 2, 0.07), (4, 'Species 4', 700.00, 2, 0.02); CREATE TABLE protected_areas (id INT, name VARCHAR(50)); INSERT INTO protected_areas (id, name) VALUES (1, 'Area 1'), (2, 'Area 2');", "reference_sql": "SELECT s.name, s.growth_rate FROM species s INNER JOIN protected_areas pa ON s.protected_area_id = pa.id GROUP BY s.name, s.growth_rate HAVING s.growth_rate > (SELECT AVG(s.growth_rate) FROM species s INNER JOIN protected_areas pa ON s.protected_area_id = pa.id);", "generated_sql": "SELECT s.name \nFROM species s\nJOIN (\n    SELECT protected_area_id, AVG(growth_rate) AS avg_growth_rate\n    FROM species\n    GROUP BY protected_area_id\n) pa_avg ON s.protected_area_id = pa_avg.protected_area_id\nWHERE s.growth_rate > pa_avg.avg_growth_rate;", "raw_model_output": "To determine which species have a population growth rate higher than the average for their respective protected areas, we need to follow these steps:\n\n1. Calculate the average growth rate for each protected area.\n2. Compare each species's growth rate with the average growth rate of its protected area.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT s.name \nFROM species s\nJOIN (\n    SELECT protected_area_id, AVG(growth_rate) AS avg_growth_rate\n    FROM species\n    GROUP BY protected_area_id\n) pa_avg ON s.protected_area_id = pa_avg.protected_area_id\nWHERE s.growth_rate > pa_avg.avg_growth_rate;\n```\n\nExplanation:\n- The subquery calculates the average growth rate for each protected area.\n- The main query joins this subquery with the `species` table on `protected_area_id`.\n- It then filters the species whose growth rate is higher than the average growth rate of their respective protected area.", "latency_sec": 5.449016094207764, "total_duration_sec": 5.117565626, "load_duration_sec": 0.014130464, "tokens_prompt": 1179, "prompt_eval_sec": 0.556450185, "tokens_completion": 196, "completion_eval_sec": 4.541971436, "tokens_total": 1375, "tokens_per_sec": 252.33913356607772, "retrieval_latency_sec": 0.12314510345458984, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL compares species growth rates to the overall average growth rate across all protected areas, while the Generated SQL compares them to the average growth rate within their specific protected area. The HAVING clause in the Reference uses a scalar subquery for the global average, whereas the Generated SQL uses a per-area average from a subquery. This fundamental difference in aggregation scope makes the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query correctly calculates the overall average growth rate across all protected areas (using a subquery that aggregates all species' growth rates) and filters species with rates above this global average. The generated query computes area-specific averages (per protected_area_id) and compares species to their own area's average, which addresses a different business question (local vs. global benchmarking). While both queries are technically valid, they answer distinct questions. The reference directly aligns with the original intent of comparing to the overall protected areas' average.", "overall_assessment": "differently_correct"}}
{"example_id": 5498, "sql_complexity": "aggregation", "prompt": "Identify the destinations with the highest number of repeat visitors from the US.", "context": "CREATE TABLE RepeatTravelers (Visitor VARCHAR(20), Destination VARCHAR(20), VisitCount INT); INSERT INTO RepeatTravelers (Visitor, Destination, VisitCount) VALUES ('David', 'Paris', 3), ('Ella', 'London', 4), ('Fiona', 'Paris', 2);", "reference_sql": "SELECT Destination, AVG(VisitCount) AS AvgVisitCount FROM RepeatTravelers WHERE Visitor LIKE '%USA%' GROUP BY Destination ORDER BY AvgVisitCount DESC;", "generated_sql": "SELECT Destination, MAX(VisitCount) AS MaxRepeatVisitors \nFROM RepeatTravelers \nWHERE Visitor IN (\n    SELECT Visitor \n    FROM RepeatTravelers \n    WHERE VisitCount > 1\n) \nGROUP BY Destination \nORDER BY MaxRepeatVisitors DESC;", "raw_model_output": "```sql\nSELECT Destination, MAX(VisitCount) AS MaxRepeatVisitors \nFROM RepeatTravelers \nWHERE Visitor IN (\n    SELECT Visitor \n    FROM RepeatTravelers \n    WHERE VisitCount > 1\n) \nGROUP BY Destination \nORDER BY MaxRepeatVisitors DESC;\n```", "latency_sec": 1.879429817199707, "total_duration_sec": 1.773710301, "load_duration_sec": 0.014346839, "tokens_prompt": 856, "prompt_eval_sec": 0.336002769, "tokens_completion": 60, "completion_eval_sec": 1.420468575, "tokens_total": 916, "tokens_per_sec": 487.3818599753898, "retrieval_latency_sec": 0.11492204666137695, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates the average VisitCount for travelers with 'USA' in their name, while the Generated SQL finds the maximum VisitCount for travelers with VisitCount > 1. The filtering conditions (LIKE '%USA%' vs VisitCount > 1) and aggregate functions (AVG vs MAX) produce different results. Additionally, the sample data contains no visitors with 'USA' in their name, making the Reference SQL return no rows, whereas the Generated SQL returns valid data.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries are not technically equivalent. The Reference SQL calculates the average VisitCount for US visitors (which is irrelevant as no US visitors exist in the sample data), while the Generated SQL identifies the maximum VisitCount for visitors with multiple visits. Neither correctly addresses the business intent of counting repeat visitors per destination. However, the Generated SQL better aligns with the 'repeat visitors' concept by filtering VisitCount > 1, even though it incorrectly uses MAX instead of COUNT. The Reference SQL fails to address the core requirement of counting repeat visitors altogether.", "overall_assessment": "differently_correct"}}
{"example_id": 3546, "sql_complexity": "window functions", "prompt": "What are the cryptocurrency exchanges with their corresponding blockchain companies, ranked by exchange ID in ascending order, for the Bitcoin platform?", "context": "CREATE TABLE cryptocurrency_exchanges (exchange_id INT, exchange_name VARCHAR(50), company_id INT); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (1, 'Binance', 1); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (2, 'Coinbase', 2); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (3, 'Kraken', 3); CREATE TABLE blockchain_companies (company_id INT, company_name VARCHAR(50), platform VARCHAR(50)); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (1, 'Binance', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (2, 'Blockstream', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (3, 'Blockchair', 'Bitcoin');", "reference_sql": "SELECT ce.exchange_name, bc.company_name, ce.exchange_id, ROW_NUMBER() OVER (PARTITION BY bc.platform ORDER BY ce.exchange_id ASC) as rank FROM cryptocurrency_exchanges ce JOIN blockchain_companies bc ON ce.company_id = bc.company_id WHERE bc.platform = 'Bitcoin';", "generated_sql": "SELECT ce.exchange_name, bc.company_name, ce.exchange_id \nFROM cryptocurrency_exchanges ce \nJOIN blockchain_companies bc ON ce.company_id = bc.company_id \nWHERE bc.platform = 'Bitcoin' \nORDER BY ce.exchange_id ASC;", "raw_model_output": "```sql\nSELECT ce.exchange_name, bc.company_name, ce.exchange_id \nFROM cryptocurrency_exchanges ce \nJOIN blockchain_companies bc ON ce.company_id = bc.company_id \nWHERE bc.platform = 'Bitcoin' \nORDER BY ce.exchange_id ASC;\n```", "latency_sec": 1.9134349822998047, "total_duration_sec": 1.728585297, "load_duration_sec": 0.017180531, "tokens_prompt": 1034, "prompt_eval_sec": 0.399086308, "tokens_completion": 53, "completion_eval_sec": 1.309103006, "tokens_total": 1087, "tokens_per_sec": 568.0882862784854, "retrieval_latency_sec": 0.11647391319274902, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes an additional 'rank' column generated by the ROW_NUMBER() function, which is absent in the Generated SQL. While both queries join the same tables and filter on 'Bitcoin', the Generated SQL also includes an ORDER BY clause not present in the Reference SQL. The presence of the extra column and differing output structure make them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query includes a ROW_NUMBER() ranking column that isn't explicitly requested in the original question, while the generated query directly addresses the requirements. Both queries correctly join the tables and filter for 'Bitcoin', but the generated query's ORDER BY ce.exchange_id ASC achieves the 'ranked by exchange ID' requirement as interpreted through simple ordering. The reference's ranking is technically valid but adds unnecessary complexity. The generated query is more efficient and directly answers the business question without extraneous elements.", "overall_assessment": "differently_correct"}}
{"example_id": 486, "sql_complexity": "single join", "prompt": "What is the average price of paintings from African artists in our collection?", "context": "CREATE TABLE Artworks (id INT, title VARCHAR(50), price DECIMAL(10,2), medium VARCHAR(50), artist_nationality VARCHAR(50)); CREATE TABLE Collections (id INT, name VARCHAR(50), continent VARCHAR(50));", "reference_sql": "SELECT AVG(Artworks.price) FROM Artworks INNER JOIN Collections ON Artworks.artist_nationality = Collections.continent WHERE Artworks.medium = 'Painting' AND Collections.continent = 'Africa';", "generated_sql": "SELECT AVG(price) AS AveragePrice \nFROM Artworks \nWHERE artist_nationality = 'African';", "raw_model_output": "```sql\nSELECT AVG(price) AS AveragePrice \nFROM Artworks \nWHERE artist_nationality = 'African';\n```", "latency_sec": 1.2601878643035889, "total_duration_sec": 1.043791318, "load_duration_sec": 0.015026559, "tokens_prompt": 877, "prompt_eval_sec": 0.34850947, "tokens_completion": 27, "completion_eval_sec": 0.676823033, "tokens_total": 904, "tokens_per_sec": 717.3533610400009, "retrieval_latency_sec": 0.11455988883972168, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates the average price of 'Painting' artworks where the artist's nationality matches the 'Africa' continent (via a join), while the Generated SQL averages all artworks with 'African' artist_nationality without considering medium or the join condition. The Generated SQL lacks the medium filter and the join logic, leading to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent. The Reference SQL incorrectly joins Artworks.artist_nationality with Collections.continent (which are different data types: nationality vs. continent) and redundantly filters Collections.continent = 'Africa' after the join. It does correctly filter for 'Painting' medium. The Generated SQL omits the medium filter entirely and incorrectly assumes artist_nationality is stored as 'African' (a specific nationality) rather than a continent. Neither query fully addresses the business intent, but the Reference SQL at least includes the medium filter. The Generated SQL fails to account for the 'painting' requirement and uses an inaccurate nationality condition.", "overall_assessment": "incorrect"}}
{"example_id": 794, "sql_complexity": "multiple_joins", "prompt": "Which suppliers have provided raw materials for the production of chemicals with high environmental impact?", "context": "CREATE TABLE suppliers (id INT, name TEXT); INSERT INTO suppliers (id, name) VALUES (1, 'Supplier1'), (2, 'Supplier2'), (3, 'Supplier3'); CREATE TABLE chemicals (id INT, name TEXT, environmental_impact INT); INSERT INTO chemicals (id, name, environmental_impact) VALUES (1, 'ChemA', 10), (2, 'ChemB', 20), (3, 'ChemC', 15); CREATE TABLE raw_materials (chemical_id INT, supplier_id INT); INSERT INTO raw_materials (chemical_id, supplier_id) VALUES (1, 1), (1, 2), (2, 3), (3, 1);", "reference_sql": "SELECT s.name FROM suppliers s INNER JOIN raw_materials rm ON s.id = rm.supplier_id INNER JOIN chemicals c ON rm.chemical_id = c.id WHERE c.environmental_impact > 10;", "generated_sql": "SELECT DISTINCT s.name \nFROM suppliers s \nJOIN raw_materials rm ON s.id = rm.supplier_id \nJOIN chemicals c ON rm.chemical_id = c.id \nWHERE c.environmental_impact > (SELECT AVG(environmental_impact) FROM chemicals);", "raw_model_output": "```sql\nSELECT DISTINCT s.name \nFROM suppliers s \nJOIN raw_materials rm ON s.id = rm.supplier_id \nJOIN chemicals c ON rm.chemical_id = c.id \nWHERE c.environmental_impact > (SELECT AVG(environmental_impact) FROM chemicals);\n```", "latency_sec": 2.3083341121673584, "total_duration_sec": 1.764189106, "load_duration_sec": 0.014308816, "tokens_prompt": 920, "prompt_eval_sec": 0.351989335, "tokens_completion": 58, "completion_eval_sec": 1.39436527, "tokens_total": 978, "tokens_per_sec": 423.6821675185179, "retrieval_latency_sec": 0.11536431312561035, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters chemicals with environmental_impact > 10, while the Generated SQL filters chemicals with environmental_impact > (average environmental_impact). The average of the environmental_impact values (10, 20, 15) is 15, so the Generated SQL effectively filters for environmental_impact > 15. This changes the result set: the Reference includes chemicals with impact 15 and 20, while the Generated only includes 20. Additionally, the Generated SQL uses DISTINCT, which could further alter results if duplicates exist.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in their environmental impact criteria. The reference uses a fixed threshold (environmental_impact > 10), while the generated query uses a dynamic threshold (above average environmental impact). This leads to different results: the reference includes chemicals with impact >10 (ChemB [20], ChemC [15]) while the generated query only includes chemicals above the average (15) which is only ChemB [20]. The original question's intent to identify suppliers for 'high environmental impact' chemicals is not fully met by the generated query since 'high' is ambiguously defined. The reference's explicit threshold better aligns with the question's phrasing, even though both approaches are technically valid. The generated query's use of DISTINCT is unnecessary in this specific schema but doesn't affect correctness.", "overall_assessment": "differently_correct"}}
{"example_id": 3164, "sql_complexity": "set operations", "prompt": "What is the average age of patients who received therapy in 'clinic_a' and 'clinic_b'?", "context": "CREATE TABLE clinic_a (patient_id INT, age INT, therapy_received BOOLEAN); INSERT INTO clinic_a (patient_id, age, therapy_received) VALUES (1, 35, true), (2, 42, true), (3, 28, false); CREATE TABLE clinic_b (patient_id INT, age INT, therapy_received BOOLEAN); INSERT INTO clinic_b (patient_id, age, therapy_received) VALUES (4, 50, true), (5, 32, false), (6, 45, true);", "reference_sql": "SELECT AVG(age) FROM (SELECT age FROM clinic_a WHERE therapy_received = true UNION ALL SELECT age FROM clinic_b WHERE therapy_received = true) AS combined_clinics;", "generated_sql": "SELECT \n    (SELECT AVG(age) FROM clinic_a WHERE therapy_received = true) AS avg_age_clinic_a,\n    (SELECT AVG(age) FROM clinic_b WHERE therapy_received = true) AS avg_age_clinic_b;", "raw_model_output": "To find the average age of patients who received therapy in both 'clinic_a' and 'clinic_b', you need to calculate the average age separately for each clinic and then combine these averages. Here's how you can do it:\n\n1. Calculate the average age of patients who received therapy in 'clinic_a'.\n2. Calculate the average age of patients who received therapy in 'clinic_b'.\n3. Combine these two averages.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT \n    (SELECT AVG(age) FROM clinic_a WHERE therapy_received = true) AS avg_age_clinic_a,\n    (SELECT AVG(age) FROM clinic_b WHERE therapy_received = true) AS avg_age_clinic_b;\n```\n\nThis query will return two columns: `avg_age_clinic_a` and `avg_age_clinic_b`, representing the average ages of patients who received therapy in 'clinic_a' and 'clinic_b', respectively.", "latency_sec": 4.922003984451294, "total_duration_sec": 4.651763316, "load_duration_sec": 0.017412859, "tokens_prompt": 756, "prompt_eval_sec": 0.302146013, "tokens_completion": 189, "completion_eval_sec": 4.329596297, "tokens_total": 945, "tokens_per_sec": 191.99496850983326, "retrieval_latency_sec": 0.10680890083312988, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates a single average age for all patients across both clinics where therapy_received is true. The Generated SQL returns two separate average ages for each clinic. While the numerical average of the two clinic averages (38.5 and 47.5) would equal the combined average (43), the Generated SQL does not explicitly compute the combined average. The output structure and calculation method differ, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly combines patients from both clinics into a single dataset before calculating the average age, which aligns with the business question asking for an overall average across 'clinic_a' and 'clinic_b'. The generated query instead calculates separate averages for each clinic, which does not fulfill the requirement to report a single average age for patients receiving therapy in both clinics. While both queries are technically correct in their own right, they produce different results and address different analytical needs. The reference query is more efficient as it performs a single aggregation over combined data, whereas the generated query requires two separate subqueries.", "overall_assessment": "incorrect"}}
{"example_id": 3704, "sql_complexity": "aggregation", "prompt": "What is the total sales revenue for each category of garments in the South America region in Q1 2022?", "context": "CREATE TABLE sales_category (sale_id INT, garment_category VARCHAR(50), sale_date DATE, total_sales DECIMAL(10, 2), region VARCHAR(50));", "reference_sql": "SELECT garment_category, SUM(total_sales) FROM sales_category WHERE sale_date BETWEEN '2022-01-01' AND '2022-03-31' AND region = 'South America' GROUP BY garment_category;", "generated_sql": "SELECT garment_category, SUM(total_sales) \nFROM sales_category \nWHERE sale_date BETWEEN '2022-01-01' AND '2022-03-31' \n  AND region = 'South America' \nGROUP BY garment_category;", "raw_model_output": "```sql\nSELECT garment_category, SUM(total_sales) \nFROM sales_category \nWHERE sale_date BETWEEN '2022-01-01' AND '2022-03-31' \n  AND region = 'South America' \nGROUP BY garment_category;\n```", "latency_sec": 2.129662036895752, "total_duration_sec": 1.825294913, "load_duration_sec": 0.019270596, "tokens_prompt": 837, "prompt_eval_sec": 0.34029819, "tokens_completion": 62, "completion_eval_sec": 1.462918317, "tokens_total": 899, "tokens_per_sec": 422.1327067042077, "retrieval_latency_sec": 0.11870884895324707, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select garment_category and sum of total_sales from sales_category, apply the same date range filter (BETWEEN '2022-01-01' AND '2022-03-31'), filter for 'South America' region, and group by garment_category. The only difference is formatting/whitepace, which does not affect semantic meaning.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "The queries are technically identical except for minor formatting differences (whitespace after AND). Both correctly filter sales records for Q1 2022 (January 1 to March 31) in the 'South America' region, group by garment_category, and calculate total sales revenue using SUM(total_sales). The business intent is fully addressed by both queries as they produce the same results.", "overall_assessment": "correct"}}
{"example_id": 2851, "sql_complexity": "single join", "prompt": "How many cases were handled by attorneys who joined the firm in 2015 or later?", "context": "CREATE TABLE attorneys (attorney_id INT, join_year INT); CREATE TABLE cases (case_id INT, attorney_id INT, billing_amount INT);", "reference_sql": "SELECT COUNT(DISTINCT cases.case_id) FROM cases INNER JOIN attorneys ON cases.attorney_id = attorneys.attorney_id WHERE attorneys.join_year >= 2015;", "generated_sql": "SELECT COUNT(cases.case_id) \nFROM cases \nINNER JOIN attorneys ON cases.attorney_id = attorneys.attorney_id \nWHERE attorneys.join_year >= 2015;", "raw_model_output": "```sql\nSELECT COUNT(cases.case_id) \nFROM cases \nINNER JOIN attorneys ON cases.attorney_id = attorneys.attorney_id \nWHERE attorneys.join_year >= 2015;\n```", "latency_sec": 1.4597859382629395, "total_duration_sec": 1.367521646, "load_duration_sec": 0.014686041, "tokens_prompt": 909, "prompt_eval_sec": 0.346462192, "tokens_completion": 41, "completion_eval_sec": 1.002784035, "tokens_total": 950, "tokens_per_sec": 650.7803473778114, "retrieval_latency_sec": 0.11553001403808594, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses COUNT(DISTINCT cases.case_id) while the Generated SQL uses COUNT(cases.case_id). If the join between cases and attorneys produces duplicate case_id values (which is possible since case_id is not explicitly constrained as unique in the schema), the two queries would return different results. COUNT(DISTINCT) ensures each case_id is counted once, whereas COUNT would count all occurrences, including duplicates.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries differ in their use of COUNT(DISTINCT) vs COUNT. The reference query correctly counts unique cases (cases.case_id) to avoid overcounting duplicate case entries, while the generated query counts all matching rows, which could overcount cases handled by multiple attorneys or with multiple records. Both queries correctly join tables and filter by join_year >= 2015, but the reference better addresses the business intent of counting distinct cases.", "overall_assessment": "differently_correct"}}
{"example_id": 3246, "sql_complexity": "single join", "prompt": "What is the average eco-friendliness score of accommodations in Oceania by year?", "context": "CREATE TABLE Accommodations (Accommodation_ID INT, Accommodation_Name VARCHAR(50), City VARCHAR(30), Country VARCHAR(50), Eco_Friendliness_Score INT, Visit_Year INT); INSERT INTO Accommodations (Accommodation_ID, Accommodation_Name, City, Country, Eco_Friendliness_Score, Visit_Year) VALUES (1, 'EcoLodge', 'Sydney', 'Australia', 85, 2019), (2, 'GreenHotel', 'Melbourne', 'Australia', 90, 2019), (3, 'SustainableResort', 'Auckland', 'New Zealand', 80, 2019), (4, 'EcoVilla', 'Wellington', 'New Zealand', 88, 2019); CREATE TABLE Countries (Country VARCHAR(50), Continent VARCHAR(30)); INSERT INTO Countries (Country, Continent) VALUES ('Australia', 'Oceania'), ('New Zealand', 'Oceania');", "reference_sql": "SELECT C.Continent, V.Visit_Year, AVG(A.Eco_Friendliness_Score) AS Avg_Eco_Score  FROM Accommodations A  JOIN Countries C  ON A.Country = C.Country  WHERE C.Continent = 'Oceania'  GROUP BY C.Continent, V.Visit_Year  ORDER BY V.Visit_Year;", "generated_sql": "SELECT Visit_Year, AVG(Eco_Friendliness_Score) AS Average_Eco_Friendliness_Score\nFROM Accommodations\nJOIN Countries ON Accommodations.Country = Countries.Country\nWHERE Countries.Continent = 'Oceania'\nGROUP BY Visit_Year;", "raw_model_output": "```sql\nSELECT Visit_Year, AVG(Eco_Friendliness_Score) AS Average_Eco_Friendliness_Score\nFROM Accommodations\nJOIN Countries ON Accommodations.Country = Countries.Country\nWHERE Countries.Continent = 'Oceania'\nGROUP BY Visit_Year;\n```", "latency_sec": 2.2088141441345215, "total_duration_sec": 1.884076957, "load_duration_sec": 0.025468315, "tokens_prompt": 985, "prompt_eval_sec": 0.373434648, "tokens_completion": 61, "completion_eval_sec": 1.481415252, "tokens_total": 1046, "tokens_per_sec": 473.5572717956556, "retrieval_latency_sec": 0.11376094818115234, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes 'Continent' in both the SELECT and GROUP BY clauses, while the Generated SQL omits it. Although the Continent filter ('Oceania') makes the 'Continent' column constant in the result, the presence of this column in the Reference SQL changes the structure of the output. The Generated SQL produces a different set of columns (Visit_Year and Average_Eco_Friendliness_Score) compared to the Reference SQL (Continent, Visit_Year, and Avg_Eco_Score), making them semantically distinct.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because the reference query includes 'Continent' in both SELECT and GROUP BY clauses, while the generated query omits it. However, since the WHERE clause explicitly filters for 'Oceania', the Continent column is redundant in the results. The generated query is more efficient by avoiding unnecessary columns and grouping, while still fulfilling the business intent of calculating average eco-friendliness scores by year for Oceania. The reference query's inclusion of 'Continent' adds no value given the filter condition.", "overall_assessment": "differently_correct"}}
{"example_id": 3056, "sql_complexity": "multiple_joins", "prompt": "Identify all suppliers who provide non-GMO ingredients to restaurants with Michelin stars.", "context": "CREATE TABLE Suppliers (id INT, name VARCHAR(50), isNonGMO BOOLEAN); CREATE TABLE Restaurants (id INT, name VARCHAR(50), numStars INT); CREATE TABLE Ingredients (supplierId INT, restaurantId INT, isNonGMO BOOLEAN);", "reference_sql": "SELECT Suppliers.name FROM Suppliers INNER JOIN Ingredients ON Suppliers.id = Ingredients.supplierId INNER JOIN Restaurants ON Ingredients.restaurantId = Restaurants.id WHERE Restaurants.numStars > 2 AND Ingredients.isNonGMO = TRUE;", "generated_sql": "SELECT DISTINCT s.id, s.name \nFROM Suppliers s \nJOIN Ingredients i ON s.id = i.supplierId \nJOIN Restaurants r ON i.restaurantId = r.id \nWHERE s.isNonGMO = true AND r.numStars > 0;", "raw_model_output": "```sql\nSELECT DISTINCT s.id, s.name \nFROM Suppliers s \nJOIN Ingredients i ON s.id = i.supplierId \nJOIN Restaurants r ON i.restaurantId = r.id \nWHERE s.isNonGMO = true AND r.numStars > 0;\n```", "latency_sec": 1.8652398586273193, "total_duration_sec": 1.640563586, "load_duration_sec": 0.016109429, "tokens_prompt": 793, "prompt_eval_sec": 0.315703172, "tokens_completion": 56, "completion_eval_sec": 1.305760069, "tokens_total": 849, "tokens_per_sec": 455.16934246987523, "retrieval_latency_sec": 0.11393570899963379, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in selected columns (name vs. id+name), filter conditions (Restaurants.numStars > 2 vs. r.numStars > 0, and Ingredients.isNonGMO = TRUE vs. Suppliers.isNonGMO = TRUE), and use of DISTINCT. These differences in semantics ensure they would produce different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly identifies suppliers providing non-GMO ingredients to Michelin-starred restaurants by checking Ingredients.isNonGMO = TRUE and Restaurants.numStars > 2. The Generated SQL incorrectly uses Suppliers.isNonGMO = TRUE (checking supplier status instead of ingredient status) and allows any restaurant with numStars > 0 (including 1-star restaurants). While the Generated query includes DISTINCT for uniqueness, its core logic misaligns with the business intent. The Reference query better addresses the requirement for non-GMO ingredients in Michelin-starred establishments.", "overall_assessment": "incorrect"}}
{"example_id": 264, "sql_complexity": "set operations", "prompt": "List the number of community health centers and infectious disease tracking facilities in 'southwest' regions.", "context": "CREATE TABLE centers (id INT, name TEXT, region TEXT); INSERT INTO centers (id, name, region) VALUES (1, 'Center A', 'southwest'); INSERT INTO centers (id, name, region) VALUES (2, 'Center B', 'northeast'); INSERT INTO centers (id, name, region) VALUES (3, 'Center C', 'northwest'); CREATE TABLE diseases (id INT, name TEXT, region TEXT); INSERT INTO diseases (id, name, region) VALUES (1, 'Disease A', 'southwest'); INSERT INTO diseases (id, name, region) VALUES (2, 'Disease B', 'southeast');", "reference_sql": "SELECT COUNT(*) FROM ( (SELECT * FROM centers WHERE region = 'southwest') UNION (SELECT * FROM diseases WHERE region = 'southwest') );", "generated_sql": "SELECT 'Community Health Centers', COUNT(*) AS count \nFROM centers \nWHERE region = 'southwest' \nUNION ALL \nSELECT 'Infectious Disease Tracking Facilities', COUNT(*) AS count \nFROM diseases \nWHERE region = 'southwest';", "raw_model_output": "```sql\nSELECT 'Community Health Centers', COUNT(*) AS count \nFROM centers \nWHERE region = 'southwest' \nUNION ALL \nSELECT 'Infectious Disease Tracking Facilities', COUNT(*) AS count \nFROM diseases \nWHERE region = 'southwest';\n```", "latency_sec": 1.9312357902526855, "total_duration_sec": 1.706342641, "load_duration_sec": 0.017981139, "tokens_prompt": 917, "prompt_eval_sec": 0.352674768, "tokens_completion": 55, "completion_eval_sec": 1.327572246, "tokens_total": 972, "tokens_per_sec": 503.3046740878918, "retrieval_latency_sec": 0.12011504173278809, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns a single count of all combined rows from centers and diseases in the 'southwest' region (using UNION which merges results). The Generated SQL returns two separate counts (with labels) for centers and diseases in the 'southwest' region (using UNION ALL which preserves separate counts). The output structure and results differ: Reference produces 1 row with total count, while Generated produces 2 rows with individual counts.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL combines rows from both tables using UNION, which would return a single count of all records (centers + diseases) in the 'southwest' region. This incorrectly aggregates the two facility types into a single number rather than separating them. The Generated SQL correctly uses two separate COUNT() operations with UNION ALL to produce two distinct rows: one for community health centers and one for infectious disease tracking facilities, each with their respective counts. While both queries are technically valid SQL, only the Generated query fulfills the business intent of distinguishing between the two facility types. The Generated query is also more explicit in representing the dual metrics required by the question.", "overall_assessment": "differently_correct"}}
{"example_id": 2838, "sql_complexity": "basic SQL", "prompt": "What is the minimum safety rating of electric vehicles in the 'green_cars' table?", "context": "CREATE TABLE green_cars (id INT, make VARCHAR(50), model VARCHAR(50), type VARCHAR(50), safety_rating INT);", "reference_sql": "SELECT MIN(safety_rating) FROM green_cars WHERE type = 'Electric';", "generated_sql": "SELECT MIN(safety_rating) FROM green_cars WHERE type = 'electric';", "raw_model_output": "```sql\nSELECT MIN(safety_rating) FROM green_cars WHERE type = 'electric';\n```", "latency_sec": 0.9456980228424072, "total_duration_sec": 0.751562823, "load_duration_sec": 0.014129604, "tokens_prompt": 604, "prompt_eval_sec": 0.267956079, "tokens_completion": 21, "completion_eval_sec": 0.466788089, "tokens_total": 625, "tokens_per_sec": 660.8874978098067, "retrieval_latency_sec": 0.12291884422302246, "match_exact": true, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The two queries are semantically equivalent. The difference in case ('Electric' vs 'electric') does not affect the result because SQL string comparisons are case-insensitive by default in most database systems unless explicitly configured otherwise. Both queries select the minimum safety_rating from the green_cars table where the type matches the specified value.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are technically equivalent in most SQL environments because string comparisons are typically case-insensitive by default. However, the reference query uses 'Electric' (capitalized) which aligns with standard data entry practices for categorical values like vehicle types. While both queries would return the same results in case-insensitive systems, the reference query better fulfills the business intent by matching potential data formatting conventions. The generated query's lowercase 'electric' might fail to retrieve results if the database stores vehicle types with proper capitalization. Both queries are equally efficient, but the reference version is more semantically precise for the given context.", "overall_assessment": "correct"}}
{"example_id": 1187, "sql_complexity": "multiple_joins", "prompt": "Who are the top 3 authors with the highest number of articles published in The Guardian?", "context": "CREATE TABLE authors (id INT, name VARCHAR(100), publisher VARCHAR(50)); CREATE TABLE articles_authors (article_id INT, author_id INT); INSERT INTO authors (id, name, publisher) VALUES (1, 'Author1', 'The Guardian'), (2, 'Author2', 'The Guardian'), (3, 'Author3', 'The Guardian'); INSERT INTO articles_authors (article_id, author_id) VALUES (1, 1), (2, 2), (3, 1), (3, 2), (3, 3); INSERT INTO articles (id, title, publication_date, publisher) VALUES (1, 'Article1', '2021-01-01', 'The Guardian'), (2, 'Article2', '2021-01-02', 'The Guardian'), (3, 'Article3', '2021-01-03', 'The Guardian');", "reference_sql": "SELECT a.name, COUNT(aa.article_id) AS articles_count FROM authors a JOIN articles_authors aa ON a.id = aa.author_id JOIN articles ar ON aa.article_id = ar.id WHERE ar.publisher = 'The Guardian' GROUP BY a.name ORDER BY articles_count DESC LIMIT 3;", "generated_sql": "SELECT a.name, COUNT(aa.article_id) AS Articles_Count \nFROM authors a \nJOIN articles_authors aa ON a.id = aa.author_id \nWHERE a.publisher = 'The Guardian' \nGROUP BY a.id, a.name \nORDER BY Articles_Count DESC \nLIMIT 3;", "raw_model_output": "```sql\nSELECT a.name, COUNT(aa.article_id) AS Articles_Count \nFROM authors a \nJOIN articles_authors aa ON a.id = aa.author_id \nWHERE a.publisher = 'The Guardian' \nGROUP BY a.id, a.name \nORDER BY Articles_Count DESC \nLIMIT 3;\n```", "latency_sec": 1.9703431129455566, "total_duration_sec": 1.934596048, "load_duration_sec": 0.014857303, "tokens_prompt": 1081, "prompt_eval_sec": 0.393390278, "tokens_completion": 62, "completion_eval_sec": 1.523397231, "tokens_total": 1143, "tokens_per_sec": 580.1020098937371, "retrieval_latency_sec": 0.11360979080200195, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their filtering conditions. The Reference SQL filters articles by 'ar.publisher = 'The Guardian'', while the Generated SQL filters authors by 'a.publisher = 'The Guardian''. Additionally, the Generated SQL groups by both a.id and a.name, whereas the Reference SQL groups only by a.name. Although the data may produce similar results in this specific case, the logical conditions and grouping criteria are not equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in critical aspects. The reference query correctly filters articles by 'The Guardian' publisher using the articles table (ar.publisher = 'The Guardian'), ensuring only articles from The Guardian are counted. The generated query incorrectly filters authors by their publisher (a.publisher = 'The Guardian'), which may not align with the article's actual publisher. While the generated query groups by both a.id and a.name (which is technically safer), the core business intent of counting articles published in The Guardian is not properly addressed. The reference query directly links to the article's publisher, making it the correct approach.", "overall_assessment": "incorrect"}}
{"example_id": 360, "sql_complexity": "window functions", "prompt": "What is the change in crime rate for each category, between this year and last year, for the same time period?", "context": "CREATE TABLE CrimeStatistics (ID INT, CrimeType VARCHAR(50), Date TIMESTAMP, Count INT); INSERT INTO CrimeStatistics (ID, CrimeType, Date, Count) VALUES (1, 'Theft', '2022-01-01 00:00:00', 100), (2, 'Vandalism', '2022-01-01 00:00:00', 50), (3, 'Theft', '2022-01-02 00:00:00', 120), (4, 'Vandalism', '2022-01-02 00:00:00', 60), (5, 'Theft', '2021-01-01 00:00:00', 80), (6, 'Vandalism', '2021-01-01 00:00:00', 40), (7, 'Theft', '2021-01-02 00:00:00', 90), (8, 'Vandalism', '2021-01-02 00:00:00', 45);", "reference_sql": "SELECT CrimeType, (SUM(Count) OVER (PARTITION BY CrimeType ORDER BY EXTRACT(YEAR FROM Date) ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)) - SUM(Count) OVER (PARTITION BY CrimeType ORDER BY EXTRACT(YEAR FROM Date)) AS CrimeRateChange FROM CrimeStatistics WHERE Date BETWEEN DATE_TRUNC('year', CURRENT_DATE - INTERVAL '1 year') AND CURRENT_DATE;", "generated_sql": "WITH ThisYear AS (\n    SELECT CrimeType, SUM(Count) AS TotalThisYear\n    FROM CrimeStatistics\n    WHERE YEAR(Date) = YEAR(CURRENT_DATE)\n    GROUP BY CrimeType\n),\nLastYear AS (\n    SELECT CrimeType, SUM(Count) AS TotalLastYear\n    FROM CrimeStatistics\n    WHERE YEAR(Date) = YEAR(CURRENT_DATE) - 1\n    GROUP BY CrimeType\n)\nSELECT \n    t.CrimeType,\n    t.TotalThisYear,\n    l.TotalLastYear,\n    (t.TotalThisYear - l.TotalLastYear) AS ChangeInCrimeRate\nFROM ThisYear t\nJOIN LastYear l ON t.CrimeType = l.CrimeType;", "raw_model_output": "To calculate the change in crime rate for each category between this year and last year for the same time period, you can use the following SQL query:\n\n```sql\nWITH ThisYear AS (\n    SELECT CrimeType, SUM(Count) AS TotalThisYear\n    FROM CrimeStatistics\n    WHERE YEAR(Date) = YEAR(CURRENT_DATE)\n    GROUP BY CrimeType\n),\nLastYear AS (\n    SELECT CrimeType, SUM(Count) AS TotalLastYear\n    FROM CrimeStatistics\n    WHERE YEAR(Date) = YEAR(CURRENT_DATE) - 1\n    GROUP BY CrimeType\n)\nSELECT \n    t.CrimeType,\n    t.TotalThisYear,\n    l.TotalLastYear,\n    (t.TotalThisYear - l.TotalLastYear) AS ChangeInCrimeRate\nFROM ThisYear t\nJOIN LastYear l ON t.CrimeType = l.CrimeType;\n```\n\n### Explanation:\n1. **ThisYear CTE**: Calculates the total crime count for each category in the current year.\n2. **LastYear CTE**: Calculates the total crime count for each category in the previous year.\n3. **Final SELECT**: Joins the results of `ThisYear` and `LastYear` on `CrimeType`, calculates the change in crime rate by subtracting `TotalLastYear` from `TotalThisYear`, and selects the necessary columns to display the results.", "latency_sec": 7.0402538776397705, "total_duration_sec": 6.928501424, "load_duration_sec": 0.017425274, "tokens_prompt": 984, "prompt_eval_sec": 0.380054029, "tokens_completion": 281, "completion_eval_sec": 6.527492325, "tokens_total": 1265, "tokens_per_sec": 179.68102031344478, "retrieval_latency_sec": 0.12156295776367188, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL uses window functions to calculate a difference between previous year's sum and cumulative current year sum, but it returns multiple rows per CrimeType and may include partial year data. The Generated SQL aggregates totals for entire years and returns one row per CrimeType with explicit this/last year totals. The calculation logic differs (window function vs. direct year-based aggregation) and the result structures are different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL has several issues: 1) It uses window functions with EXTRACT(YEAR) but doesn't properly isolate 'same time period' comparisons (e.g., it might compare full years instead of matching date ranges). 2) The WHERE clause uses DATE_TRUNC which could include partial years. 3) The window frame (ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING) is misapplied for year-over-year comparisons. The Generated SQL correctly isolates this year and last year's totals via explicit CTEs, ensures proper year filtering, and calculates the difference directly. While both queries aim to compare year-over-year crime rates, the Generated SQL's approach is more precise for the business intent of comparing 'same time period' (assuming full year comparisons).", "overall_assessment": "correct"}}
{"example_id": 335, "sql_complexity": "single join", "prompt": "List the policy numbers, claim amounts, and claim dates for policies that have more than two claims and the total claim amount exceeds $5000", "context": "CREATE TABLE policies (policy_number INT);CREATE TABLE claims (claim_id INT, policy_number INT, claim_amount DECIMAL(10,2), claim_date DATE);", "reference_sql": "SELECT p.policy_number, c.claim_amount, c.claim_date FROM policies p INNER JOIN claims c ON p.policy_number = c.policy_number GROUP BY p.policy_number, c.claim_amount, c.claim_date HAVING COUNT(c.claim_id) > 2 AND SUM(c.claim_amount) > 5000;", "generated_sql": "SELECT c.policy_number, c.claim_amount, c.claim_date\nFROM claims c\nJOIN (\n    SELECT policy_number\n    FROM claims\n    GROUP BY policy_number\n    HAVING COUNT(*) > 2 AND SUM(claim_amount) > 5000\n) subq ON c.policy_number = subq.policy_number;", "raw_model_output": "```sql\nSELECT c.policy_number, c.claim_amount, c.claim_date\nFROM claims c\nJOIN (\n    SELECT policy_number\n    FROM claims\n    GROUP BY policy_number\n    HAVING COUNT(*) > 2 AND SUM(claim_amount) > 5000\n) subq ON c.policy_number = subq.policy_number;\n```", "latency_sec": 3.676137924194336, "total_duration_sec": 2.284620782, "load_duration_sec": 0.01391497, "tokens_prompt": 1093, "prompt_eval_sec": 0.547456826, "tokens_completion": 75, "completion_eval_sec": 1.719643759, "tokens_total": 1168, "tokens_per_sec": 317.7247492029232, "retrieval_latency_sec": 0.1181328296661377, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their grouping and filtering logic. The reference query groups by policy_number, claim_amount, and claim_date, requiring each (policy, amount, date) combination to have >2 claims and sum >5000. The generated query first filters policies with >2 total claims and sum >5000, then returns all their claims. This means the generated query includes all claims for qualifying policies, while the reference query only includes claims that meet the per-group criteria. The grouping columns and HAVING conditions are not equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL is technically incorrect due to improper grouping. It groups by policy_number, claim_amount, and claim_date, which would cause each claim to form its own group (since claim_amount and claim_date are unique per claim). This makes COUNT(c.claim_id) = 1 for all groups, rendering the HAVING clause ineffective. The Generated SQL correctly identifies policies meeting the criteria first (via subquery grouping by policy_number) and then retrieves all claims for those policies. While both queries aim to fulfill the business intent, the Generated SQL achieves it correctly. The Reference SQL would return no results due to its logical error.", "overall_assessment": "differently_correct"}}
{"example_id": 2866, "sql_complexity": "basic SQL", "prompt": "What is the number of hospitals in 'rural_healthcare' table?", "context": "CREATE TABLE rural_healthcare (name VARCHAR(255), type VARCHAR(255), location VARCHAR(255)); INSERT INTO rural_healthcare (name, type, location) VALUES ('Rural General Hospital', 'Hospital', 'Bushland'), ('Rural Community Hospital', 'Hospital', 'Forest Region');", "reference_sql": "SELECT COUNT(*) FROM rural_healthcare WHERE type = 'Hospital';", "generated_sql": "SELECT COUNT(*) FROM rural_healthcare WHERE type = 'Hospital';", "raw_model_output": "```sql\nSELECT COUNT(*) FROM rural_healthcare WHERE type = 'Hospital';\n```", "latency_sec": 0.8813433647155762, "total_duration_sec": 0.692106832, "load_duration_sec": 0.014129527, "tokens_prompt": 588, "prompt_eval_sec": 0.276583878, "tokens_completion": 18, "completion_eval_sec": 0.398830797, "tokens_total": 606, "tokens_per_sec": 687.5867275582951, "retrieval_latency_sec": 0.11231303215026855, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They both count all rows in the 'rural_healthcare' table where the 'type' column equals 'Hospital'. The SQL syntax, table name, column references, and filter condition are exactly the same in both queries.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure, logic, and implementation. They both count rows in the 'rural_healthcare' table where the 'type' column equals 'Hospital', which directly answers the question about the number of hospitals. The queries are syntactically correct, semantically equivalent, and equally efficient. Since they are identical, neither is superior to the other.", "overall_assessment": "correct"}}
{"example_id": 4440, "sql_complexity": "multiple_joins", "prompt": "What is the average session length for each game genre in the last month, sorted by average session length.", "context": "CREATE TABLE game_sessions(id INT, user_id INT, game_name VARCHAR(50), start_time DATETIME, end_time DATETIME); CREATE TABLE games(id INT, name VARCHAR(50), genre VARCHAR(50));", "reference_sql": "SELECT genres.genre, AVG(TIMESTAMPDIFF(SECOND, start_time, end_time)) as avg_session_length FROM game_sessions JOIN games ON game_sessions.game_name = games.name JOIN (SELECT DISTINCT game_name, genre FROM game_sessions JOIN games ON game_sessions.game_name = games.name) genres ON games.name = genres.game_name WHERE start_time >= DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH) GROUP BY genres.genre ORDER BY avg_session_length DESC;", "generated_sql": "SELECT genres.genre, AVG(TIMESTAMPDIFF(SECOND, start_time, end_time)) AS avg_session_length \nFROM game_sessions \nJOIN games ON game_sessions.game_name = games.name \nJOIN (SELECT DISTINCT game_name, genre FROM games) genres ON games.name = genres.game_name \nWHERE game_sessions.start_time >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH) \nGROUP BY genres.genre \nORDER BY avg_session_length DESC;", "raw_model_output": "```sql\nSELECT genres.genre, AVG(TIMESTAMPDIFF(SECOND, start_time, end_time)) AS avg_session_length \nFROM game_sessions \nJOIN games ON game_sessions.game_name = games.name \nJOIN (SELECT DISTINCT game_name, genre FROM games) genres ON games.name = genres.game_name \nWHERE game_sessions.start_time >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH) \nGROUP BY genres.genre \nORDER BY avg_session_length DESC;\n```", "latency_sec": 2.869192123413086, "total_duration_sec": 2.460760663, "load_duration_sec": 0.017137285, "tokens_prompt": 779, "prompt_eval_sec": 0.314529246, "tokens_completion": 92, "completion_eval_sec": 2.124539882, "tokens_total": 871, "tokens_per_sec": 303.56977244308416, "retrieval_latency_sec": 0.11450982093811035, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Generated SQL contains a subquery that selects 'game_name' from the 'games' table, which does not have a 'game_name' column (the correct column is 'name'). The Reference SQL correctly joins game_sessions and games to get 'game_name' and 'genre'. This structural discrepancy makes the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries produce the same results by calculating average session lengths per genre for the last month. However, the Generated SQL is more efficient and elegant. The Reference SQL includes a redundant subquery that joins game_sessions and games twice, while the Generated SQL's subquery (SELECT DISTINCT game_name, genre FROM games) is unnecessary but still correct. The Generated SQL avoids redundant joins and uses CURDATE() which is functionally equivalent to CURRENT_DATE. Both correctly address the business intent, but the Generated SQL is simpler and more efficient.", "overall_assessment": "correct"}}
{"example_id": 451, "sql_complexity": "single join", "prompt": "Which customers have made a transaction over 500 in the \"risk_management\" category?", "context": "CREATE TABLE customers (id INT, name VARCHAR(50), category VARCHAR(50)); INSERT INTO customers (id, name, category) VALUES (1, 'John Doe', 'risk_management'); INSERT INTO customers (id, name, category) VALUES (2, 'Jane Smith', 'compliance'); INSERT INTO customers (id, name, category) VALUES (3, 'Jim Brown', 'risk_management'); CREATE TABLE transactions (id INT, customer_id INT, amount DECIMAL(10, 2)); INSERT INTO transactions (id, customer_id, amount) VALUES (1, 1, 500.00); INSERT INTO transactions (id, customer_id, amount) VALUES (2, 1, 200.00); INSERT INTO transactions (id, customer_id, amount) VALUES (3, 2, 100.00); INSERT INTO transactions (id, customer_id, amount) VALUES (4, 3, 750.00);", "reference_sql": "SELECT c.name FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE c.category = 'risk_management' AND t.amount > 500;", "generated_sql": "SELECT DISTINCT c.name \nFROM customers c \nJOIN transactions t ON c.id = t.customer_id \nWHERE c.category = 'risk_management' AND t.amount > 500;", "raw_model_output": "```sql\nSELECT DISTINCT c.name \nFROM customers c \nJOIN transactions t ON c.id = t.customer_id \nWHERE c.category = 'risk_management' AND t.amount > 500;\n```", "latency_sec": 2.2565832138061523, "total_duration_sec": 1.612034223, "load_duration_sec": 0.014465967, "tokens_prompt": 1294, "prompt_eval_sec": 0.583487142, "tokens_completion": 42, "completion_eval_sec": 1.009296777, "tokens_total": 1336, "tokens_per_sec": 592.045527869803, "retrieval_latency_sec": 0.11830472946166992, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Generated SQL includes DISTINCT which ensures unique names, while the Reference SQL may return duplicate names if a customer has multiple qualifying transactions. Although the sample data produces the same result, the queries are not semantically equivalent in all cases.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because the generated query uses DISTINCT to eliminate duplicate customer names, while the reference query may return duplicates if a customer has multiple transactions over 500. Both correctly identify customers in the 'risk_management' category with transactions >500, but the generated query better fulfills the business intent of listing unique customers. The generated version is more elegant and efficient as it avoids redundant results without additional complexity.", "overall_assessment": "differently_correct"}}
{"example_id": 2879, "sql_complexity": "basic SQL", "prompt": "Update the FoodSafetyRecords.OrganicFarms table to include a new record for a certified organic farm in Kenya.", "context": "CREATE TABLE FoodSafetyRecords.OrganicFarms (farmName TEXT, country TEXT, certified BOOLEAN);", "reference_sql": "INSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('Ngong Organic Farm', 'Kenya', TRUE);", "generated_sql": "INSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('Kenya Green Farm', 'Kenya', TRUE);", "raw_model_output": "```sql\nINSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('Kenya Green Farm', 'Kenya', TRUE);\n```", "latency_sec": 1.280113935470581, "total_duration_sec": 1.094035573, "load_duration_sec": 0.014693822, "tokens_prompt": 578, "prompt_eval_sec": 0.271574421, "tokens_completion": 36, "completion_eval_sec": 0.803979287, "tokens_total": 614, "tokens_per_sec": 479.6448058151076, "retrieval_latency_sec": 0.11561393737792969, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The two queries insert different farm names ('Ngong Organic Farm' vs. 'Kenya Green Farm') into the OrganicFarms table. While the country and certified values are identical, the farmName field differs, resulting in semantically different records.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly insert a certified organic farm record into the FoodSafetyRecords.OrganicFarms table. The reference query uses 'Ngong Organic Farm' while the generated query uses 'Kenya Green Farm'. Since the original question did not specify a particular farm name, both satisfy the business intent of adding a certified organic farm in Kenya. The technical structure of both queries is identical, but the inserted data differs. Neither query is more efficient or elegant than the other, as both are simple, direct inserts with proper syntax and semantics.", "overall_assessment": "differently_correct"}}
{"example_id": 5688, "sql_complexity": "single join", "prompt": "What is the total amount donated to a specific cause?", "context": "CREATE TABLE causes (id INT, name TEXT); CREATE TABLE donations (id INT, donor_id INT, cause_id INT, donation_amount DECIMAL(10,2)); INSERT INTO causes (id, name) VALUES (1, 'Cause A'), (2, 'Cause B'); INSERT INTO donations (id, donor_id, cause_id, donation_amount) VALUES (1, 1, 1, 50.00), (2, 2, 1, 100.00);", "reference_sql": "SELECT SUM(donation_amount) FROM donations JOIN causes ON donations.cause_id = causes.id WHERE causes.name = 'Cause A';", "generated_sql": "SELECT c.name AS CauseName, SUM(d.donation_amount) AS TotalDonationAmount \nFROM donations d \nJOIN causes c ON d.cause_id = c.id \nGROUP BY c.name;", "raw_model_output": "```sql\nSELECT c.name AS CauseName, SUM(d.donation_amount) AS TotalDonationAmount \nFROM donations d \nJOIN causes c ON d.cause_id = c.id \nGROUP BY c.name;\n```", "latency_sec": 1.859527826309204, "total_duration_sec": 1.495333007, "load_duration_sec": 0.019740882, "tokens_prompt": 951, "prompt_eval_sec": 0.364164725, "tokens_completion": 45, "completion_eval_sec": 1.105549487, "tokens_total": 996, "tokens_per_sec": 535.619841719101, "retrieval_latency_sec": 0.11524724960327148, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns a single aggregated sum for 'Cause A', while the Generated SQL groups results by cause name, returning multiple rows (one per cause). Although in the provided sample data both might yield the same numeric value for 'Cause A', the Generated SQL's structure inherently produces a table with potentially multiple rows, making them semantically different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL directly answers the question by calculating the total donations for a specific cause ('Cause A') using a WHERE clause. The Generated SQL returns totals for all causes (due to GROUP BY) and lacks filtering, making it semantically incorrect for the specific cause requirement. While both are syntactically valid, the Generated SQL's output structure (multiple rows) differs from the Reference's single-value result. The Reference is more efficient as it filters early and avoids unnecessary aggregation.", "overall_assessment": "correct"}}
{"example_id": 3273, "sql_complexity": "multiple_joins", "prompt": "List all departments, the number of chemicals they handle, and the number of machines used in their manufacturing processes.", "context": "CREATE TABLE Departments (DepartmentID INT, DepartmentName VARCHAR(20)); INSERT INTO Departments (DepartmentID, DepartmentName) VALUES (1, 'Manufacturing'), (2, 'Engineering'), (3, 'Chemical Safety'), (4, 'Product Development'); CREATE TABLE Chemicals (ChemicalID INT, ChemicalName VARCHAR(20), DepartmentID INT); INSERT INTO Chemicals (ChemicalID, ChemicalName, DepartmentID) VALUES (1, 'Hydrochloric Acid', 1), (2, 'Nitric Acid', 2), (3, 'Sodium Hydroxide', 3), (4, 'New Chemical', 4); CREATE TABLE Machinery (MachineID INT, MachineName VARCHAR(20), DepartmentID INT); INSERT INTO Machinery (MachineID, MachineName, DepartmentID) VALUES (1, 'Mixer 1', 1), (2, 'Cutter 2', 2), (3, 'Dispenser 3', 3), (4, 'Innovator 4', 4);", "reference_sql": "SELECT D.DepartmentName, COUNT(C.ChemicalID) AS ChemicalCount, COUNT(M.MachineID) AS MachineCount FROM Departments D LEFT JOIN Chemicals C ON D.DepartmentID = C.DepartmentID LEFT JOIN Machinery M ON D.DepartmentID = M.DepartmentID GROUP BY D.DepartmentName;", "generated_sql": "SELECT \n    d.DepartmentName,\n    COUNT(c.ChemicalID) AS NumberOfChemicals,\n    COUNT(m.MachineID) AS NumberOfMachines\nFROM \n    Departments d\nLEFT JOIN \n    Chemicals c ON d.DepartmentID = c.DepartmentID\nLEFT JOIN \n    Machinery m ON d.DepartmentID = m.DepartmentID\nGROUP BY \n    d.DepartmentName;", "raw_model_output": "```sql\nSELECT \n    d.DepartmentName,\n    COUNT(c.ChemicalID) AS NumberOfChemicals,\n    COUNT(m.MachineID) AS NumberOfMachines\nFROM \n    Departments d\nLEFT JOIN \n    Chemicals c ON d.DepartmentID = c.DepartmentID\nLEFT JOIN \n    Machinery m ON d.DepartmentID = m.DepartmentID\nGROUP BY \n    d.DepartmentName;\n```", "latency_sec": 2.6065659523010254, "total_duration_sec": 2.528530852, "load_duration_sec": 0.022209424, "tokens_prompt": 1256, "prompt_eval_sec": 0.577258426, "tokens_completion": 82, "completion_eval_sec": 1.925456059, "tokens_total": 1338, "tokens_per_sec": 513.3190659606521, "retrieval_latency_sec": 0.11544132232666016, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform the same operations: left joining Departments with Chemicals and Machinery on DepartmentID, then grouping by DepartmentName. The only differences are alias names (D/d, C/c, M/m) and column aliases (ChemicalCount/NumberOfChemicals, MachineCount/NumberOfMachines), which do not affect the semantic result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically equivalent as they produce identical results through equivalent LEFT JOINs, GROUP BY clauses, and COUNT aggregations. The reference query uses 'ChemicalCount' and 'MachineCount' while the generated query uses 'NumberOfChemicals' and 'NumberOfMachines' - the column names differ but the semantic meaning is identical. The generated query demonstrates superior readability through more descriptive column aliases ('NumberOfChemicals' vs 'ChemicalCount') without altering the core logic. Both correctly address the business intent of listing departments with their chemical/machine counts.", "overall_assessment": "correct"}}
{"example_id": 1895, "sql_complexity": "window functions", "prompt": "What is the average safety score of chemical production sites in the United States, partitioned by state and ranked in descending order?", "context": "CREATE TABLE production_sites (site_id INT, site_name TEXT, country TEXT, state TEXT, safety_score FLOAT); INSERT INTO production_sites (site_id, site_name, country, state, safety_score) VALUES (1, 'Site A', 'USA', 'NY', 92.5), (2, 'Site B', 'USA', 'CA', 87.4), (3, 'Site C', 'USA', 'TX', 95.3), (4, 'Site D', 'USA', 'FL', 89.2);", "reference_sql": "SELECT state, AVG(safety_score) as avg_safety_score, ROW_NUMBER() OVER (ORDER BY AVG(safety_score) DESC) as rank FROM production_sites WHERE country = 'USA' GROUP BY state ORDER BY rank;", "generated_sql": "SELECT state, AVG(safety_score) AS avg_safety_score \nFROM production_sites \nWHERE country = 'USA' \nGROUP BY state \nORDER BY avg_safety_score DESC;", "raw_model_output": "```sql\nSELECT state, AVG(safety_score) AS avg_safety_score \nFROM production_sites \nWHERE country = 'USA' \nGROUP BY state \nORDER BY avg_safety_score DESC;\n```", "latency_sec": 1.5009729862213135, "total_duration_sec": 1.417482149, "load_duration_sec": 0.014327113, "tokens_prompt": 910, "prompt_eval_sec": 0.353546395, "tokens_completion": 42, "completion_eval_sec": 1.046454345, "tokens_total": 952, "tokens_per_sec": 634.2552522525084, "retrieval_latency_sec": 0.10488104820251465, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a 'rank' column generated by ROW_NUMBER() and orders by this rank, while the Generated SQL only orders by avg_safety_score DESC without the rank column. The presence of the additional column and different ordering mechanism make the result sets structurally and semantically different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL includes an unnecessary ROW_NUMBER() ranking column that wasn't requested in the original question. While both queries calculate average safety scores by state and sort them descending, the Generated SQL directly addresses the requirement without extra complexity. The Reference SQL's ORDER BY rank would produce the same ordering as Generated SQL's ORDER BY avg_safety_score DESC, but the Generated version is more efficient and aligns better with the explicit request for 'partitioned by state and ranked' (interpreted as sorted, not requiring an explicit rank column).", "overall_assessment": "differently_correct"}}
{"example_id": 4669, "sql_complexity": "set operations", "prompt": "Identify the number of IoT devices in each country and the total number of devices.", "context": "CREATE TABLE device_country (device_id INT, country TEXT); INSERT INTO device_country (device_id, country) VALUES (1, 'USA'), (2, 'Canada'), (3, 'Mexico'), (4, 'Brazil'); CREATE TABLE device_info (device_id INT, device_type TEXT); INSERT INTO device_info (device_id, device_type) VALUES (1, 'Soil Sensor'), (2, 'Temperature Sensor'), (3, 'Humidity Sensor'), (4, 'Precision Sprayer');", "reference_sql": "SELECT country, COUNT(*) AS device_count FROM device_country GROUP BY country UNION SELECT 'Total' AS country, COUNT(*) FROM device_country;", "generated_sql": "SELECT country, COUNT(*) AS device_count \nFROM device_country \nGROUP BY country;", "raw_model_output": "```sql\nSELECT country, COUNT(*) AS device_count \nFROM device_country \nGROUP BY country;\n```", "latency_sec": 1.2877790927886963, "total_duration_sec": 0.927891798, "load_duration_sec": 0.026534013, "tokens_prompt": 852, "prompt_eval_sec": 0.341064327, "tokens_completion": 22, "completion_eval_sec": 0.557343451, "tokens_total": 874, "tokens_per_sec": 678.6878315498551, "retrieval_latency_sec": 0.11056685447692871, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a UNION ALL with a 'Total' row, while the Generated SQL only performs the grouped count. The Reference query adds a summary row with the total device count, which the Generated query lacks.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly addresses both parts of the business question by first grouping devices by country and then adding a 'Total' row via UNION. The generated query only provides country-level counts without the total device count. While both queries are technically correct in their own right, they are not semantically equivalent as the generated query fails to fulfill the complete business intent of reporting both per-country counts and the overall total. The reference query is more comprehensive but slightly less efficient due to the UNION operation. The generated query is more elegant but incomplete.", "overall_assessment": "differently_correct"}}
{"example_id": 5302, "sql_complexity": "multiple_joins", "prompt": "Find the supplier with the lowest average delivery time for orders in the last month.", "context": "CREATE TABLE Suppliers (SupplierID int, SupplierName varchar(50)); CREATE TABLE Products (ProductID int, ProductName varchar(50), SupplierID int); CREATE TABLE Orders (OrderID int, ProductID int, OrderDate date, DeliveryTime int); INSERT INTO Suppliers VALUES (1, 'SupplierA'), (2, 'SupplierB'); INSERT INTO Products VALUES (1, 'Organic Apples', 1), (2, 'Bananas', 2); INSERT INTO Orders VALUES (1, 1, '2022-01-01', 2), (2, 2, '2022-01-03', 3);", "reference_sql": "SELECT SupplierName, AVG(DeliveryTime) as AvgDeliveryTime FROM Orders o JOIN Products p ON o.ProductID = p.ProductID JOIN Suppliers sp ON p.SupplierID = sp.SupplierID WHERE OrderDate >= DATEADD(month, -1, GETDATE()) GROUP BY SupplierName ORDER BY AvgDeliveryTime ASC;", "generated_sql": "SELECT s.SupplierName, AVG(o.DeliveryTime) AS avg_delivery_time\nFROM Suppliers s\nJOIN Products p ON s.SupplierID = p.SupplierID\nJOIN Orders o ON p.ProductID = o.ProductID\nWHERE o.OrderDate >= DATEADD(MONTH, -1, GETDATE())\nGROUP BY s.SupplierName\nORDER BY avg_delivery_time ASC\nLIMIT 1;", "raw_model_output": "```sql\nSELECT s.SupplierName, AVG(o.DeliveryTime) AS avg_delivery_time\nFROM Suppliers s\nJOIN Products p ON s.SupplierID = p.SupplierID\nJOIN Orders o ON p.ProductID = o.ProductID\nWHERE o.OrderDate >= DATEADD(MONTH, -1, GETDATE())\nGROUP BY s.SupplierName\nORDER BY avg_delivery_time ASC\nLIMIT 1;\n```", "latency_sec": 2.647369146347046, "total_duration_sec": 2.436023731, "load_duration_sec": 0.019304762, "tokens_prompt": 903, "prompt_eval_sec": 0.34627716, "tokens_completion": 87, "completion_eval_sec": 2.063736147, "tokens_total": 990, "tokens_per_sec": 373.95615997340025, "retrieval_latency_sec": 0.11867022514343262, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the LIMIT 1 clause in the Generated SQL, which restricts the result to only one row. The Reference SQL returns all suppliers ordered by average delivery time. This makes them non-equivalent as the Generated SQL's output is truncated.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent due to the LIMIT 1 clause in the generated query. Both correctly calculate average delivery times for suppliers within the last month, but the generated query explicitly retrieves only the top result, directly answering the 'lowest' requirement. The reference query returns all suppliers ordered by average delivery time, requiring additional processing to identify the minimum. Both fulfill the business intent, but the generated query is more precise and efficient for the specific question.", "overall_assessment": "differently_correct"}}
{"example_id": 267, "sql_complexity": "subqueries", "prompt": "What is the total number of disability support programs offered in urban and rural areas, and the percentage of total programs for each area type?", "context": "CREATE TABLE programs (program_id INT, program_name VARCHAR(255), area_type VARCHAR(255));", "reference_sql": "SELECT area_type, COUNT(*) as total_programs, ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM programs) , 2) as percentage_of_total FROM programs WHERE area_type IN ('urban', 'rural') GROUP BY area_type;", "generated_sql": "SELECT \n    area_type,\n    COUNT(program_id) AS total_programs,\n    (COUNT(program_id) * 100.0 / (SELECT COUNT(*) FROM programs)) AS percentage_of_total\nFROM \n    programs\nGROUP BY \n    area_type;", "raw_model_output": "```sql\nSELECT \n    area_type,\n    COUNT(program_id) AS total_programs,\n    (COUNT(program_id) * 100.0 / (SELECT COUNT(*) FROM programs)) AS percentage_of_total\nFROM \n    programs\nGROUP BY \n    area_type;\n```", "latency_sec": 1.3772451877593994, "total_duration_sec": 1.868858374, "load_duration_sec": 0.01569449, "tokens_prompt": 1031, "prompt_eval_sec": 0.403513681, "tokens_completion": 59, "completion_eval_sec": 1.44521552, "tokens_total": 1090, "tokens_per_sec": 791.4349671994786, "retrieval_latency_sec": 0.11223506927490234, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the WHERE clause. The Reference SQL filters area_type to ('urban', 'rural') before grouping, while the Generated SQL groups all area_types without filtering. This means the Generated SQL may include additional area_type categories not present in the Reference SQL's output, making their results non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent. The Reference SQL explicitly filters for 'urban' and 'rural' using WHERE, ensuring only relevant area types are included. The Generated SQL omits this filter, which could include other area types if present. Both calculate percentages correctly using a subquery, but the Reference includes ROUND() for precise decimal formatting. While both fulfill the business intent of counting programs by area type, the Reference is more precise in addressing the question's scope. The Generated SQL might inadvertently include additional area types, making it less accurate for this specific request.", "overall_assessment": "differently_correct"}}
{"example_id": 3028, "sql_complexity": "basic SQL", "prompt": "What is the number of startups founded by non-binary individuals in the technology industry?", "context": "CREATE TABLE company (id INT, name TEXT, founder_gender TEXT, industry TEXT); INSERT INTO company (id, name, founder_gender, industry) VALUES (1, 'CodeForAll', 'Non-binary', 'Technology'); INSERT INTO company (id, name, founder_gender, industry) VALUES (2, 'TechVillage', 'Male', 'Technology');", "reference_sql": "SELECT COUNT(*) FROM company WHERE founder_gender = 'Non-binary' AND industry = 'Technology';", "generated_sql": "SELECT COUNT(*) \nFROM company \nWHERE founder_gender = 'Non-binary' AND industry = 'Technology';", "raw_model_output": "```sql\nSELECT COUNT(*) \nFROM company \nWHERE founder_gender = 'Non-binary' AND industry = 'Technology';\n```", "latency_sec": 1.1011462211608887, "total_duration_sec": 0.97485558, "load_duration_sec": 0.024497285, "tokens_prompt": 767, "prompt_eval_sec": 0.319138567, "tokens_completion": 26, "completion_eval_sec": 0.6272522, "tokens_total": 793, "tokens_per_sec": 720.1586717193435, "retrieval_latency_sec": 0.11222004890441895, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and content. Both select the count of rows from the 'company' table where founder_gender is 'Non-binary' and industry is 'Technology'. The formatting differences (line breaks, indentation) do not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure, logic, and syntax. They both correctly count companies where founder_gender is 'Non-binary' and industry is 'Technology', which directly addresses the business question. The whitespace differences (line breaks) do not affect execution. Both queries are equally efficient, semantically equivalent, and fulfill the business intent.", "overall_assessment": "correct"}}
{"example_id": 3282, "sql_complexity": "aggregation", "prompt": "Which marine species have been observed in both the Arctic and Antarctic oceans?", "context": "CREATE TABLE marine_species (id INT, species_name VARCHAR(50), common_name VARCHAR(50), region VARCHAR(20));INSERT INTO marine_species (id, species_name, common_name, region) VALUES (1, 'Orcinus_orca', 'Killer Whale', 'Arctic');INSERT INTO marine_species (id, species_name, common_name, region) VALUES (2, 'Balaenoptera_bonaerensis', 'Antarctic Minke Whale', 'Antarctic');", "reference_sql": "SELECT species_name FROM marine_species WHERE region IN ('Arctic', 'Antarctic') GROUP BY species_name HAVING COUNT(DISTINCT region) = 2;", "generated_sql": "SELECT species_name \nFROM marine_species \nWHERE region IN ('Arctic', 'Antarctic') \nGROUP BY species_name \nHAVING COUNT(DISTINCT region) = 2;", "raw_model_output": "```sql\nSELECT species_name \nFROM marine_species \nWHERE region IN ('Arctic', 'Antarctic') \nGROUP BY species_name \nHAVING COUNT(DISTINCT region) = 2;\n```", "latency_sec": 1.4987859725952148, "total_duration_sec": 1.475477171, "load_duration_sec": 0.01979249, "tokens_prompt": 979, "prompt_eval_sec": 0.380883904, "tokens_completion": 43, "completion_eval_sec": 1.067427455, "tokens_total": 1022, "tokens_per_sec": 681.8852182278977, "retrieval_latency_sec": 0.11325788497924805, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure, logic, and conditions. Both select species_name from marine_species where region is 'Arctic' or 'Antarctic', group by species_name, and filter with HAVING COUNT(DISTINCT region) = 2. Since they are exactly the same, they will produce identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "The reference and generated SQL queries are identical in structure, syntax, and logic. Both correctly filter marine species observed in either the Arctic or Antarctic, group by species_name, and use HAVING COUNT(DISTINCT region) = 2 to ensure presence in both regions. The queries are semantically equivalent, technically correct, and fully address the business intent of identifying species observed in both oceans. Neither query demonstrates superior efficiency or elegance over the other as they are identical.", "overall_assessment": "correct"}}
{"example_id": 3474, "sql_complexity": "subqueries", "prompt": "What is the total transaction volume for the top 3 digital assets by market capitalization in the 'developed_markets' schema?", "context": "CREATE SCHEMA developed_markets; CREATE TABLE developed_markets.digital_assets (asset_name VARCHAR(10), market_cap BIGINT, daily_transaction_volume BIGINT); INSERT INTO developed_markets.digital_assets (asset_name, market_cap, daily_transaction_volume) VALUES ('AssetG', 30000000, 15000000), ('AssetH', 25000000, 12000000), ('AssetI', 20000000, 10000000), ('AssetJ', 15000000, 8000000), ('AssetK', 10000000, 6000000);", "reference_sql": "SELECT SUM(daily_transaction_volume) FROM (SELECT daily_transaction_volume FROM developed_markets.digital_assets ORDER BY market_cap DESC FETCH NEXT 3 ROWS ONLY) t;", "generated_sql": "SELECT SUM(daily_transaction_volume) \nFROM (\n    SELECT daily_transaction_volume \n    FROM developed_markets.digital_assets \n    ORDER BY market_cap DESC \n    FETCH NEXT 3 ROWS ONLY\n) t;", "raw_model_output": "```sql\nSELECT SUM(daily_transaction_volume) \nFROM (\n    SELECT daily_transaction_volume \n    FROM developed_markets.digital_assets \n    ORDER BY market_cap DESC \n    FETCH NEXT 3 ROWS ONLY\n) t;\n```", "latency_sec": 1.9107041358947754, "total_duration_sec": 1.670103359, "load_duration_sec": 0.015425083, "tokens_prompt": 1134, "prompt_eval_sec": 0.552140823, "tokens_completion": 48, "completion_eval_sec": 1.098018653, "tokens_total": 1182, "tokens_per_sec": 618.6201085739912, "retrieval_latency_sec": 0.11441993713378906, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of daily_transaction_volume for the top 3 digital assets by market_cap. They use identical subquery structures, ordering logic (ORDER BY market_cap DESC), row limiting (FETCH NEXT 3 ROWS ONLY), and column/table references. The semantic meaning and result will be the same.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic. They correctly retrieve the top 3 digital assets by market capitalization using ORDER BY market_cap DESC FETCH NEXT 3 ROWS ONLY, then sum their daily_transaction_volume. The subquery ensures only the top 3 rows are aggregated. Both queries technically and semantically fulfill the business intent of calculating the total transaction volume for the top 3 assets. Since the queries are identical, neither is superior to the other.", "overall_assessment": "correct"}}
{"example_id": 1626, "sql_complexity": "aggregation", "prompt": "Find the total value of social impact bonds issued by each organization.", "context": "CREATE TABLE social_impact_bonds (id INT, organization_name VARCHAR(255), issue_year INT, value FLOAT); INSERT INTO social_impact_bonds (id, organization_name, issue_year, value) VALUES (1, 'Acme Corp', 2018, 2000000), (2, 'XYZ Foundation', 2019, 3000000), (3, 'Global Giving', 2018, 1500000), (4, 'Acme Corp', 2019, 2500000), (5, 'XYZ Foundation', 2018, 1000000);", "reference_sql": "SELECT organization_name, SUM(value) as total_value FROM social_impact_bonds GROUP BY organization_name;", "generated_sql": "SELECT organization_name, SUM(value) AS total_value \nFROM social_impact_bonds \nGROUP BY organization_name;", "raw_model_output": "```sql\nSELECT organization_name, SUM(value) AS total_value \nFROM social_impact_bonds \nGROUP BY organization_name;\n```", "latency_sec": 1.5426840782165527, "total_duration_sec": 1.219061596, "load_duration_sec": 0.015571938, "tokens_prompt": 1144, "prompt_eval_sec": 0.556348712, "tokens_completion": 28, "completion_eval_sec": 0.642796328, "tokens_total": 1172, "tokens_per_sec": 759.7148480036893, "retrieval_latency_sec": 0.12070989608764648, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. The only differences are formatting (line breaks and capitalization of 'AS') which do not affect semantic meaning. Both group by organization_name and calculate the same SUM(value) alias.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic. They correctly aggregate the total value of social impact bonds by organization using SUM() and GROUP BY. The queries are syntactically identical, produce the same results, and directly address the business requirement to calculate organization-specific totals. Neither query has any technical deficiencies or semantic differences.", "overall_assessment": "correct"}}
{"example_id": 1315, "sql_complexity": "single join", "prompt": "List all the transactions made by clients living in New York with a transaction amount greater than $1000.", "context": "CREATE TABLE transactions (id INT, client_id INT, transaction_amount DECIMAL(10,2), transaction_date DATE); INSERT INTO transactions (id, client_id, transaction_amount, transaction_date) VALUES (1, 3, 1500.00, '2022-01-01'), (2, 4, 800.00, '2022-01-02'), (3, 3, 1200.00, '2022-01-03'); CREATE TABLE clients (id INT, name VARCHAR(255), state VARCHAR(255)); INSERT INTO clients (id, name, state) VALUES (3, 'Mike Johnson', 'New York'), (4, 'Sara Lee', 'California');", "reference_sql": "SELECT transactions.id, transactions.client_id, transactions.transaction_amount, transactions.transaction_date FROM transactions INNER JOIN clients ON transactions.client_id = clients.id WHERE clients.state = 'New York' AND transactions.transaction_amount > 1000.00;", "generated_sql": "SELECT t.* \nFROM transactions t \nJOIN clients c ON t.client_id = c.id \nWHERE c.state = 'New York' AND t.transaction_amount > 1000.00;", "raw_model_output": "```sql\nSELECT t.* \nFROM transactions t \nJOIN clients c ON t.client_id = c.id \nWHERE c.state = 'New York' AND t.transaction_amount > 1000.00;\n```", "latency_sec": 1.694289207458496, "total_duration_sec": 1.542313584, "load_duration_sec": 0.020539731, "tokens_prompt": 963, "prompt_eval_sec": 0.378311137, "tokens_completion": 46, "completion_eval_sec": 1.136033473, "tokens_total": 1009, "tokens_per_sec": 595.5299694752479, "retrieval_latency_sec": 0.1191098690032959, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an INNER JOIN between transactions and clients on client_id = clients.id, apply the same WHERE filters (clients.state = 'New York' and transactions.transaction_amount > 1000.00), and return identical columns. The Generated SQL uses table aliases and t.* to explicitly select all columns from transactions, which matches the explicit column list in the Reference SQL. The semantic result is the same.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically equivalent as they produce identical results by joining transactions with clients, filtering for New York residents and transactions over $1000. The reference query explicitly lists columns while the generated query uses a table alias (t.*) which is functionally identical. The generated query better fulfills the business intent through its concise syntax and use of aliases, which improves readability without sacrificing clarity. Both are efficient, but the generated version demonstrates more elegant query writing by using aliases and avoiding repetitive table names.", "overall_assessment": "correct"}}
{"example_id": 520, "sql_complexity": "multiple_joins", "prompt": "What is the total number of electric vehicles sold in 'California' in the 'sales' schema?", "context": "CREATE TABLE sales_regions (id INT, name VARCHAR(50));   CREATE TABLE sales (id INT, region_id INT, vehicle_count INT);   CREATE TABLE vehicles (id INT, type VARCHAR(50));   INSERT INTO sales_regions VALUES (1, 'California');   INSERT INTO sales VALUES (1, 1, 5000);   INSERT INTO vehicles VALUES (1, 'electric');", "reference_sql": "SELECT SUM(sales.vehicle_count) FROM sales INNER JOIN sales_regions ON sales.region_id = sales_regions.id INNER JOIN vehicles ON sales.id = vehicles.id WHERE vehicles.type = 'electric' AND sales_regions.name = 'California';", "generated_sql": "SELECT SUM(sales.vehicle_count) \nFROM sales \nINNER JOIN sales_regions ON sales.region_id = sales_regions.id \nINNER JOIN vehicles ON sales.id = vehicles.id \nWHERE vehicles.type = 'electric' AND sales_regions.name = 'California';", "raw_model_output": "To find the total number of electric vehicles sold in 'California', we need to join the `sales`, `sales_regions`, and `vehicles` tables based on their respective IDs. Then, we filter the results to only include rows where the vehicle type is 'electric' and the sales region is 'California'. Finally, we sum up the `vehicle_count` from the `sales` table.\n\nHere is the SQL query:\n\n```sql\nSELECT SUM(sales.vehicle_count) \nFROM sales \nINNER JOIN sales_regions ON sales.region_id = sales_regions.id \nINNER JOIN vehicles ON sales.id = vehicles.id \nWHERE vehicles.type = 'electric' AND sales_regions.name = 'California';\n```\n\nThis query will return the total number of electric vehicles sold in 'California'.", "latency_sec": 4.0474138259887695, "total_duration_sec": 3.954538529, "load_duration_sec": 0.015940179, "tokens_prompt": 760, "prompt_eval_sec": 0.315429159, "tokens_completion": 155, "completion_eval_sec": 3.618838731, "tokens_total": 915, "tokens_per_sec": 226.07028570311033, "retrieval_latency_sec": 0.1119072437286377, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure, join conditions, and WHERE clauses. Both perform the same three-table join (sales, sales_regions, vehicles) with the same filters (vehicles.type = 'electric' and sales_regions.name = 'California'), and both calculate the same aggregate SUM(sales.vehicle_count).", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure, logic, and syntax. They perform the same three-table join (sales \u2194 sales_regions \u2194 vehicles), apply the same filters (vehicles.type = 'electric' and sales_regions.name = 'California'), and calculate the same aggregate (SUM(sales.vehicle_count)). The business intent to count electric vehicles sold in California is fully addressed by both. Since the queries are identical, neither is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 3999, "sql_complexity": "single join", "prompt": "What is the total number of tickets sold for performances with a rating of 5?", "context": "CREATE TABLE performance (id INT PRIMARY KEY, name VARCHAR(255), date DATE, artist_id INT, rating INT); INSERT INTO performance (id, name, date, artist_id, rating) VALUES (1, 'Dance Recital', '2022-03-01', 1, 5);", "reference_sql": "SELECT SUM(t.quantity) as total_tickets_sold FROM performance p INNER JOIN ticket t ON p.id = t.performance_id WHERE p.rating = 5;", "generated_sql": "SELECT SUM(tickets_sold) FROM performance WHERE rating = 5;", "raw_model_output": "```sql\nSELECT SUM(tickets_sold) FROM performance WHERE rating = 5;\n```", "latency_sec": 0.8349161148071289, "total_duration_sec": 0.78721281, "load_duration_sec": 0.016579785, "tokens_prompt": 737, "prompt_eval_sec": 0.312119261, "tokens_completion": 19, "completion_eval_sec": 0.454979003, "tokens_total": 756, "tokens_per_sec": 905.4801872816181, "retrieval_latency_sec": 0.1127018928527832, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL correctly joins the 'performance' table with the 'ticket' table to sum ticket quantities, while the Generated SQL references a non-existent 'tickets_sold' column in the 'performance' table. The Generated SQL would result in an error due to invalid column reference.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly joins the performance and ticket tables to sum ticket quantities for 5-star performances. The generated query attempts to sum a non-existent 'tickets_sold' column in the performance table, which violates the schema provided. While both target the same business question, the generated query is technically invalid due to referencing an undefined column. The reference query properly addresses the data model and business logic.", "overall_assessment": "incorrect"}}
{"example_id": 2261, "sql_complexity": "multiple_joins", "prompt": "What is the total number of animals that have been released into 'protected' habitats, and the average weight of those animals?", "context": "CREATE TABLE habitats (habitat_id INT, habitat_name VARCHAR(50), habitat_status VARCHAR(50)); INSERT INTO habitats (habitat_id, habitat_name, habitat_status) VALUES (1, 'Habitat A', 'protected'), (2, 'Habitat B', 'unprotected'); CREATE TABLE animal_habitats (animal_id INT, habitat_id INT, animal_weight FLOAT); INSERT INTO animal_habitats (animal_id, habitat_id, animal_weight) VALUES (101, 1, 25.5), (102, 2, 15.2); CREATE TABLE animals (animal_id INT, animal_name VARCHAR(50)); INSERT INTO animals (animal_id, animal_name) VALUES (101, 'Dog'), (102, 'Cat');", "reference_sql": "SELECT COUNT(*), AVG(animal_habitats.animal_weight) FROM animal_habitats INNER JOIN animals ON animal_habitats.animal_id = animals.animal_id INNER JOIN habitats ON animal_habitats.habitat_id = habitats.habitat_id WHERE habitats.habitat_status = 'protected';", "generated_sql": "SELECT COUNT(*) AS total_animals, AVG(animal_weight) AS average_weight \nFROM animal_habitats ah \nJOIN habitats h ON ah.habitat_id = h.habitat_id \nWHERE h.habitat_status = 'protected';", "raw_model_output": "```sql\nSELECT COUNT(*) AS total_animals, AVG(animal_weight) AS average_weight \nFROM animal_habitats ah \nJOIN habitats h ON ah.habitat_id = h.habitat_id \nWHERE h.habitat_status = 'protected';\n```", "latency_sec": 1.9057071208953857, "total_duration_sec": 1.77389126, "load_duration_sec": 0.015906488, "tokens_prompt": 1028, "prompt_eval_sec": 0.400550323, "tokens_completion": 55, "completion_eval_sec": 1.353287086, "tokens_total": 1083, "tokens_per_sec": 568.2929911555132, "retrieval_latency_sec": 0.1064603328704834, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the count and average animal weight for protected habitats. The Reference SQL includes an unnecessary join with the animals table, but since no columns from animals are used, it doesn't affect the result. The Generated SQL simplifies the query by omitting this redundant join while maintaining the same filtering and aggregation logic.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the total number of animals in 'protected' habitats and their average weight. The reference query includes an unnecessary join with the 'animals' table, which doesn't affect the result but adds computational overhead. The generated query is more efficient by directly joining only the required tables ('animal_habitats' and 'habitats'). Both produce identical results, but the generated version is more elegant and optimized.", "overall_assessment": "correct"}}
{"example_id": 3439, "sql_complexity": "multiple_joins", "prompt": "How many menu items contain ingredients sourced from local suppliers for each restaurant?", "context": "CREATE TABLE restaurants (id INT, name VARCHAR(50), location VARCHAR(50)); INSERT INTO restaurants VALUES (1, 'Restaurant A', 'City A'); INSERT INTO restaurants VALUES (2, 'Restaurant B', 'City B'); CREATE TABLE menu_items (id INT, name VARCHAR(50), restaurant_id INT, price DECIMAL(5,2)); INSERT INTO menu_items VALUES (1, 'Item A', 1, 10.99); INSERT INTO menu_items VALUES (2, 'Item B', 1, 12.99); INSERT INTO menu_items VALUES (3, 'Item C', 2, 11.99); CREATE TABLE ingredients (id INT, name VARCHAR(50), local_source BOOLEAN, menu_item_id INT); INSERT INTO ingredients VALUES (1, 'Ingredient A', TRUE, 1); INSERT INTO ingredients VALUES (2, 'Ingredient B', FALSE, 1); INSERT INTO ingredients VALUES (3, 'Ingredient C', TRUE, 2); INSERT INTO ingredients VALUES (4, 'Ingredient D', FALSE, 2); INSERT INTO ingredients VALUES (5, 'Ingredient E', TRUE, 3);", "reference_sql": "SELECT r.name, COUNT(DISTINCT mi.id) as num_local_items FROM restaurants r JOIN menu_items mi ON r.id = mi.restaurant_id JOIN ingredients i ON mi.id = i.menu_item_id WHERE i.local_source = TRUE GROUP BY r.name;", "generated_sql": "SELECT r.name AS restaurant_name, COUNT(mi.id) AS local_ingredient_count\nFROM restaurants r\nJOIN menu_items mi ON r.id = mi.restaurant_id\nJOIN ingredients i ON mi.id = i.menu_item_id\nWHERE i.local_source = TRUE\nGROUP BY r.name;", "raw_model_output": "```sql\nSELECT r.name AS restaurant_name, COUNT(mi.id) AS local_ingredient_count\nFROM restaurants r\nJOIN menu_items mi ON r.id = mi.restaurant_id\nJOIN ingredients i ON mi.id = i.menu_item_id\nWHERE i.local_source = TRUE\nGROUP BY r.name;\n```", "latency_sec": 2.012836217880249, "total_duration_sec": 1.910102221, "load_duration_sec": 0.020687458, "tokens_prompt": 924, "prompt_eval_sec": 0.368016122, "tokens_completion": 62, "completion_eval_sec": 1.512902481, "tokens_total": 986, "tokens_per_sec": 489.8560505028933, "retrieval_latency_sec": 0.10903716087341309, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their aggregation logic. The Reference SQL uses COUNT(DISTINCT mi.id) to count unique menu items with at least one local ingredient, while the Generated SQL uses COUNT(mi.id) to count all local ingredients. This leads to different results when a menu item has multiple local ingredients (e.g., 2 local ingredients for a single menu item would count as 1 in Reference and 2 in Generated).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in their aggregation approach. The Reference query uses COUNT(DISTINCT mi.id) which ensures each menu item is counted once even if it has multiple local ingredients. The Generated query uses COUNT(mi.id) which would overcount menu items with multiple local ingredients. The original question asks for 'how many menu items' (unique items) not 'how many local ingredients', making COUNT(DISTINCT) technically correct. Both queries correctly join tables and filter by local_source, but the Generated query fails to address the business intent of counting unique menu items.", "overall_assessment": "differently_correct"}}
{"example_id": 2265, "sql_complexity": "aggregation", "prompt": "Hourly revenue for a specific movie?", "context": "CREATE TABLE Movie_Revenue (id INT, movie_title VARCHAR(100), revenue_time TIME, revenue DECIMAL(10,2));", "reference_sql": "SELECT revenue_time, SUM(revenue) FROM Movie_Revenue WHERE movie_title = 'Spider-Man: No Way Home' GROUP BY revenue_time;", "generated_sql": "SELECT DATEPART(hh, revenue_time) AS Hour_of_Day, SUM(revenue) AS Total_Revenue \nFROM Movie_Revenue \nWHERE movie_title = 'Specific Movie' \nGROUP BY DATEPART(hh, revenue_time);", "raw_model_output": "```sql\nSELECT DATEPART(hh, revenue_time) AS Hour_of_Day, SUM(revenue) AS Total_Revenue \nFROM Movie_Revenue \nWHERE movie_title = 'Specific Movie' \nGROUP BY DATEPART(hh, revenue_time);\n```", "latency_sec": 1.6577200889587402, "total_duration_sec": 1.527774675, "load_duration_sec": 0.025068391, "tokens_prompt": 659, "prompt_eval_sec": 0.289792598, "tokens_completion": 53, "completion_eval_sec": 1.208721098, "tokens_total": 712, "tokens_per_sec": 429.5055629368809, "retrieval_latency_sec": 0.11223196983337402, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent.  The reference query groups by the entire 'revenue_time' field, while the generated query groups by the hour part of 'revenue_time' using DATEPART. Additionally, the WHERE clauses reference different movie titles ('Spider-Man: No Way Home' vs 'Specific Movie').  These differences in grouping and filtering will result in different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent. The reference groups by the exact 'revenue_time' (e.g., 10:00:00, 10:30:00), while the generated query groups by the hour part of the time (e.g., 10 for all times between 10:00:00-10:59:59). The generated query also contains a critical error: it filters for 'Specific Movie' instead of the actual movie title ('Spider-Man: No Way Home'). While the generated query better aligns with the 'hourly' requirement, its incorrect WHERE clause prevents it from fulfilling the business intent. The reference query correctly filters the specific movie but may not fully address the 'hourly' requirement if the data contains multiple entries per hour. The reference is technically correct but less aligned with the business intent, while the generated query is closer to the intent but contains a critical error.", "overall_assessment": "differently_correct"}}
{"example_id": 1763, "sql_complexity": "multiple_joins", "prompt": "What is the total food and beverage revenue last month for hotels in 'Bangkok'?", "context": "CREATE TABLE revenue (hotel_id INT, revenue_source VARCHAR(50), revenue INT, revenue_date DATE); INSERT INTO revenue (hotel_id, revenue_source, revenue, revenue_date) VALUES (5, 'Room revenue', 12000, '2022-03-01'), (5, 'Food and beverage', 4000, '2022-03-02'), (5, 'Other revenue', 1000, '2022-03-03'); CREATE TABLE hotels (hotel_id INT, city VARCHAR(50)); INSERT INTO hotels (hotel_id, city) VALUES (5, 'Bangkok'); CREATE TABLE dates (date DATE); INSERT INTO dates (date) VALUES ('2022-03-01'), ('2022-03-02'), ('2022-03-03');", "reference_sql": "SELECT SUM(revenue) FROM revenue JOIN hotels ON revenue.hotel_id = hotels.hotel_id JOIN dates ON revenue.revenue_date = dates.date WHERE hotels.city = 'Bangkok' AND revenue_source = 'Food and beverage' AND dates.date >= DATEADD(month, -1, GETDATE());", "generated_sql": "SELECT SUM(revenue) AS total_food_and_beverage_revenue\nFROM revenue\nJOIN hotels ON revenue.hotel_id = hotels.hotel_id\nWHERE revenue.revenue_source = 'Food and beverage'\nAND hotels.city = 'Bangkok'\nAND revenue_date >= DATEADD(month, -1, GETDATE());", "raw_model_output": "```sql\nSELECT SUM(revenue) AS total_food_and_beverage_revenue\nFROM revenue\nJOIN hotels ON revenue.hotel_id = hotels.hotel_id\nWHERE revenue.revenue_source = 'Food and beverage'\nAND hotels.city = 'Bangkok'\nAND revenue_date >= DATEADD(month, -1, GETDATE());\n```", "latency_sec": 2.349320888519287, "total_duration_sec": 2.152334122, "load_duration_sec": 0.01541045, "tokens_prompt": 1125, "prompt_eval_sec": 0.549953112, "tokens_completion": 69, "completion_eval_sec": 1.582953947, "tokens_total": 1194, "tokens_per_sec": 508.23197709383396, "retrieval_latency_sec": 0.11998105049133301, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of 'Food and beverage' revenue for hotels in Bangkok with revenue dates within the last month. The Reference SQL includes an unnecessary join with the dates table, but the date condition (dates.date >= ...) is equivalent to revenue_date >= ... because the join ensures dates.date matches revenue.revenue_date. The Generated SQL simplifies this by directly using revenue.revenue_date, producing the same result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": false, "superiority": "generated", "explanation": "Both queries produce identical results technically, as the 'dates' table join in the Reference SQL is redundant and doesn't affect the outcome. The Generated SQL is more efficient by avoiding an unnecessary join. However, neither query correctly captures 'last month' due to flawed date logic (using DATEADD(month, -1, GETDATE()) instead of proper month boundaries). The business intent is partially fulfilled but requires correction in date filtering.", "overall_assessment": "differently_correct"}}
{"example_id": 5499, "sql_complexity": "set operations", "prompt": "How many legal aid clinics and community mediation centers are there in total, and what is the sum of cases handled by each type of center, for centers located in the state of California?", "context": "CREATE TABLE LegalAidClinics (ClinicName text, State text, NumCases int); INSERT INTO LegalAidClinics VALUES ('Clinic1', 'CA', 30, '2022-01-01'), ('Clinic2', 'CA', 25, '2022-01-01'); CREATE TABLE CommunityMediationCenters (CenterName text, State text, NumCases int); INSERT INTO CommunityMediationCenters VALUES ('CM1', 'CA', 22, '2022-01-01'), ('CM2', 'CA', 28, '2022-01-01');", "reference_sql": "SELECT State, 'Legal Aid Clinics' AS CenterType, COUNT(*) AS NumCenters, SUM(NumCases) AS TotalCases FROM LegalAidClinics WHERE State = 'CA' UNION ALL SELECT State, 'Community Mediation Centers', COUNT(*), SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA';", "generated_sql": "SELECT \n    'Legal Aid Clinics' AS CenterType,\n    COUNT(*) AS TotalCenters,\n    SUM(NumCases) AS TotalCases\nFROM \n    LegalAidClinics\nWHERE \n    State = 'CA'\nUNION ALL\nSELECT \n    'Community Mediation Centers' AS CenterType,\n    COUNT(*) AS TotalCenters,\n    SUM(NumCases) AS TotalCases\nFROM \n    CommunityMediationCenters\nWHERE \n    State = 'CA';", "raw_model_output": "```sql\nSELECT \n    'Legal Aid Clinics' AS CenterType,\n    COUNT(*) AS TotalCenters,\n    SUM(NumCases) AS TotalCases\nFROM \n    LegalAidClinics\nWHERE \n    State = 'CA'\nUNION ALL\nSELECT \n    'Community Mediation Centers' AS CenterType,\n    COUNT(*) AS TotalCenters,\n    SUM(NumCases) AS TotalCases\nFROM \n    CommunityMediationCenters\nWHERE \n    State = 'CA';\n```", "latency_sec": 5.169934988021851, "total_duration_sec": 3.026235517, "load_duration_sec": 0.019309495, "tokens_prompt": 1181, "prompt_eval_sec": 0.566570352, "tokens_completion": 105, "completion_eval_sec": 2.432038166, "tokens_total": 1286, "tokens_per_sec": 248.7458745573233, "retrieval_latency_sec": 0.11808300018310547, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their selected columns. The Reference SQL includes the 'State' column in both SELECT statements, while the Generated SQL omits it. Although both filter for 'CA', the result sets have different structures (4 columns vs 3 columns), making them semantically distinct.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because the Reference SQL includes a 'State' column in the output while the Generated SQL does not. Both correctly filter for California (State = 'CA') and calculate counts/sums for each center type. The Generated SQL is more concise and directly addresses the question by focusing on CenterType, TotalCenters, and TotalCases without redundant state information. The Reference SQL's inclusion of 'State' is technically correct but unnecessary since the filter already enforces California. Both fulfill the business intent, but the Generated SQL is more elegant and avoids unnecessary columns.", "overall_assessment": "differently_correct"}}
{"example_id": 2408, "sql_complexity": "aggregation", "prompt": "What is the average number of victories for players from Japan and South Korea, partitioned by game mode?", "context": "CREATE TABLE PlayerVictories (PlayerID INT, GameMode VARCHAR(255), Victories INT, Country VARCHAR(255)); INSERT INTO PlayerVictories (PlayerID, GameMode, Victories, Country) VALUES (1, 'Battle Royale', 25, 'Japan'), (2, 'Team Deathmatch', 18, 'South Korea');", "reference_sql": "SELECT GameMode, AVG(Victories) as AvgVictories FROM PlayerVictories WHERE Country IN ('Japan', 'South Korea') GROUP BY GameMode, Country WITH ROLLUP;", "generated_sql": "SELECT GameMode, AVG(Victories) \nFROM PlayerVictories \nWHERE Country IN ('Japan', 'South Korea') \nGROUP BY GameMode;", "raw_model_output": "```sql\nSELECT GameMode, AVG(Victories) \nFROM PlayerVictories \nWHERE Country IN ('Japan', 'South Korea') \nGROUP BY GameMode;\n```", "latency_sec": 1.3209288120269775, "total_duration_sec": 1.262528943, "load_duration_sec": 0.023844959, "tokens_prompt": 874, "prompt_eval_sec": 0.352755106, "tokens_completion": 36, "completion_eval_sec": 0.882256325, "tokens_total": 910, "tokens_per_sec": 688.909191558625, "retrieval_latency_sec": 0.1147000789642334, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses GROUP BY GameMode, Country WITH ROLLUP, which groups by both columns and adds summary rows, while the Generated SQL only groups by GameMode. This results in different aggregation levels and the Reference includes additional rollup rows. The SELECT clause also implicitly includes Country in the Reference due to GROUP BY, but the Generated SQL omits it.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query groups by both GameMode and Country (with ROLLUP), which would produce separate averages for Japan and South Korea within each game mode, plus a summary row. This deviates from the original question's requirement to partition by game mode only. The generated query correctly groups by GameMode alone, calculating the average victories across both countries per game mode. While the reference query technically addresses a related but different question, the generated query directly answers the original business intent. The generated query is also more efficient as it avoids unnecessary ROLLUP aggregation.", "overall_assessment": "differently_correct"}}
{"example_id": 2729, "sql_complexity": "subqueries", "prompt": "Find the total number of trips made by shared autonomous vehicles in Seattle", "context": "CREATE TABLE shared_vehicles (id INT, vehicle_type VARCHAR(20), is_autonomous BOOLEAN, trip_count INT); INSERT INTO shared_vehicles (id, vehicle_type, is_autonomous, trip_count) VALUES (1, 'ebike', false, 1200), (2, 'escooter', false, 800), (3, 'car', true, 1500); CREATE TABLE city_data (city VARCHAR(20), has_autonomous_vehicles BOOLEAN); INSERT INTO city_data (city, has_autonomous_vehicles) VALUES ('Seattle', true), ('Denver', false), ('Portland', true);", "reference_sql": "SELECT SUM(trip_count) FROM shared_vehicles WHERE is_autonomous = true AND vehicle_type != 'ebike' AND vehicle_type != 'escooter' AND city IN (SELECT city FROM city_data WHERE has_autonomous_vehicles = true AND city = 'Seattle');", "generated_sql": "SELECT SUM(trip_count) AS TotalTrips \nFROM shared_vehicles \nWHERE is_autonomous = true;", "raw_model_output": "```sql\nSELECT SUM(trip_count) AS TotalTrips \nFROM shared_vehicles \nWHERE is_autonomous = true;\n```", "latency_sec": 1.5567359924316406, "total_duration_sec": 1.013848467, "load_duration_sec": 0.015925448, "tokens_prompt": 785, "prompt_eval_sec": 0.321819541, "tokens_completion": 28, "completion_eval_sec": 0.672380455, "tokens_total": 813, "tokens_per_sec": 522.2465491596196, "retrieval_latency_sec": 0.11597895622253418, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references a 'city' column in the shared_vehicles table, which does not exist according to the provided schema. The Generated SQL lacks this invalid condition and simply sums trip_count for autonomous vehicles. Since the Reference SQL is syntactically invalid and the Generated SQL is valid, they cannot be equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL contains a critical technical error: it references a 'city' column in shared_vehicles that does not exist in the schema. This makes it invalid. The Generated SQL is syntactically correct but fails to filter for Seattle, which is required by the original question. However, since the schema lacks a city column in shared_vehicles, neither query can fully address the business intent. The Generated SQL is technically superior as it avoids invalid column references, while the Reference SQL is fundamentally flawed. The business intent cannot be fully fulfilled due to schema limitations.", "overall_assessment": "differently_correct"}}
{"example_id": 2952, "sql_complexity": "aggregation", "prompt": "Show the total budget allocated for each program category in 2023.", "context": "CREATE TABLE Budget (id INT, category TEXT, year INT, allocated_amount INT); INSERT INTO Budget (id, category, year, allocated_amount) VALUES (1, 'Education', 2023, 30000); INSERT INTO Budget (id, category, year, allocated_amount) VALUES (2, 'Healthcare', 2023, 50000);", "reference_sql": "SELECT category, SUM(allocated_amount) FROM Budget WHERE year = 2023 GROUP BY category;", "generated_sql": "SELECT category, SUM(allocated_amount) AS total_budget \nFROM Budget \nWHERE year = 2023 \nGROUP BY category;", "raw_model_output": "```sql\nSELECT category, SUM(allocated_amount) AS total_budget \nFROM Budget \nWHERE year = 2023 \nGROUP BY category;\n```", "latency_sec": 1.24275803565979, "total_duration_sec": 1.139249629, "load_duration_sec": 0.018509946, "tokens_prompt": 819, "prompt_eval_sec": 0.327580949, "tokens_completion": 33, "completion_eval_sec": 0.789953714, "tokens_total": 852, "tokens_per_sec": 685.5719098590793, "retrieval_latency_sec": 0.10881209373474121, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (category and summed allocated_amount) from the Budget table where year is 2023, and group by category. The only difference is the alias 'total_budget' in the generated query, which doesn't affect the semantic meaning of the result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the total allocated budget per category for 2023 using SUM and GROUP BY. The generated query adds an explicit alias (total_budget) to the aggregated column, which improves readability and aligns more closely with common reporting practices. While the reference query is technically correct, the generated version provides clearer column naming without altering the semantic meaning or computational logic. Both fulfill the business intent of showing total budgets per category, but the generated query's enhanced clarity makes it slightly superior.", "overall_assessment": "correct"}}
{"example_id": 4328, "sql_complexity": "aggregation", "prompt": "What is the average cargo handling time in hours for each port?", "context": "CREATE TABLE cargo_handling (id INT, port_id INT, time_in_hours DECIMAL(5,2)); INSERT INTO cargo_handling (id, port_id, time_in_hours) VALUES (1, 1, 20.5), (2, 1, 22.3), (3, 2, 18.7);", "reference_sql": "SELECT port_id, AVG(time_in_hours) FROM cargo_handling GROUP BY port_id;", "generated_sql": "SELECT port_id, AVG(time_in_hours) AS average_handling_time \nFROM cargo_handling \nGROUP BY port_id;", "raw_model_output": "```sql\nSELECT port_id, AVG(time_in_hours) AS average_handling_time \nFROM cargo_handling \nGROUP BY port_id;\n```", "latency_sec": 1.3834609985351562, "total_duration_sec": 1.003561562, "load_duration_sec": 0.019734591, "tokens_prompt": 762, "prompt_eval_sec": 0.315167213, "tokens_completion": 28, "completion_eval_sec": 0.665411311, "tokens_total": 790, "tokens_per_sec": 571.0316379258051, "retrieval_latency_sec": 0.11176085472106934, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average time_in_hours per port_id. The generated query adds an alias (average_handling_time) for the calculated column, but this does not affect the semantic result. The GROUP BY logic and aggregate function remain identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the average cargo handling time per port using GROUP BY port_id. The reference query omits the column alias, while the generated query explicitly names the calculated column 'average_handling_time'. This makes the generated query more readable and semantically descriptive without altering the computational logic. Both produce identical results, but the generated version better addresses the business intent by providing clearer column labeling.", "overall_assessment": "correct"}}
{"example_id": 4915, "sql_complexity": "window functions", "prompt": "Calculate the percentage of total Europium production for each country.", "context": "CREATE TABLE europium_production (country VARCHAR(50), quantity INT);", "reference_sql": "SELECT country, quantity * 100.0 / SUM(quantity) OVER (PARTITION BY NULL) AS percentage FROM europium_production;", "generated_sql": "SELECT country, (quantity / SUM(quantity) OVER ()) * 100 AS europium_percentage \nFROM europium_production;", "raw_model_output": "```sql\nSELECT country, (quantity / SUM(quantity) OVER ()) * 100 AS europium_percentage \nFROM europium_production;\n```", "latency_sec": 1.232715129852295, "total_duration_sec": 1.08251989, "load_duration_sec": 0.015602872, "tokens_prompt": 791, "prompt_eval_sec": 0.321981331, "tokens_completion": 31, "completion_eval_sec": 0.740649736, "tokens_total": 822, "tokens_per_sec": 666.8207277528044, "retrieval_latency_sec": 0.10675501823425293, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in how they handle division precision. The Reference SQL uses 100.0 (float) which ensures floating-point division, while the Generated SQL uses 100 (integer) which may cause integer division. For example, if quantity=1 and total=3, Reference returns 33.333... but Generated returns 0. The window function syntax (PARTITION BY NULL vs. empty OVER()) is functionally equivalent, but the calculation order and data types make the results non-equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries calculate the percentage of total Europium production per country using window functions. The reference query uses `SUM(quantity) OVER (PARTITION BY NULL)` which is functionally equivalent to `SUM(quantity) OVER ()` in the generated query. The percentage calculation (`quantity * 100.0 / SUM(...)`) in the reference query explicitly avoids integer division by using `100.0`, ensuring floating-point precision. The generated query uses `100` (integer) which may lead to integer division in some SQL dialects, potentially truncating results. While both queries fulfill the business intent, the reference query is more robust for precision. The column alias difference (`percentage` vs `europium_percentage`) does not affect result correctness.", "overall_assessment": "correct"}}
{"example_id": 5030, "sql_complexity": "subqueries", "prompt": "What is the success rate of diverse-led startups (at least 1 female or underrepresented racial or ethnic group executive) in the past 3 years?", "context": "CREATE TABLE DiverseStartups(id INT, name TEXT, country TEXT, year INT, success BOOLEAN);   INSERT INTO DiverseStartups VALUES (1, 'FemTech', 'USA', 2020, true), (2, 'GreenCity', 'Canada', 2019, false), (3, 'AI-Health', 'UK', 2021, true), (4, 'SolarEnergy', 'USA', 2020, false), (5, 'DataAnalytics', 'Germany', 2019, true), (6, 'SmartGrid', 'USA', 2021, true), (7, 'CloudServices', 'India', 2020, false), (8, 'RenewableEnergy', 'USA', 2019, true);", "reference_sql": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3) AS success_rate FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3 AND success = true;", "generated_sql": "SELECT \n    (COUNT(CASE WHEN success = true THEN id END) * 100.0 / COUNT(id)) AS success_rate\nFROM \n    DiverseStartups\nWHERE \n    year >= YEAR(CURRENT_DATE) - 3;", "raw_model_output": "```sql\nSELECT \n    (COUNT(CASE WHEN success = true THEN id END) * 100.0 / COUNT(id)) AS success_rate\nFROM \n    DiverseStartups\nWHERE \n    year >= YEAR(CURRENT_DATE) - 3;\n```", "latency_sec": 2.326754093170166, "total_duration_sec": 2.046142933, "load_duration_sec": 0.016239415, "tokens_prompt": 1398, "prompt_eval_sec": 0.635228796, "tokens_completion": 57, "completion_eval_sec": 1.389403043, "tokens_total": 1455, "tokens_per_sec": 625.3346687004579, "retrieval_latency_sec": 0.11230325698852539, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the success rate of startups in the last three years. The Reference SQL uses a subquery to get the total count and explicitly filters for success=true. The Generated SQL achieves the same by using a CASE statement within COUNT to count successes and divides by the total count in the same filtered dataset. Both apply the same WHERE clause and compute (success_count / total_count) * 100, producing identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries calculate the success rate of diverse-led startups in the past 3 years by filtering the relevant timeframe and dividing successful entries by total entries. The reference query uses a subquery to calculate the denominator, while the generated query uses a CASE statement within a single scan. Both produce identical results, but the generated query is more efficient (avoids redundant table scan) and elegant (explicitly handles nulls via CASE). The business intent is fully addressed by both, but the generated query better handles edge cases (e.g., zero startups in the timeframe) by leveraging COUNT(CASE...) which avoids division by zero issues.", "overall_assessment": "correct"}}
{"example_id": 4626, "sql_complexity": "aggregation", "prompt": "What was the maximum number of training hours for farmers in each country in 2020?", "context": "CREATE TABLE training (id INT, country_id INT, farmer_id INT, hours INT, date DATE);", "reference_sql": "SELECT country_id, MAX(hours) FROM training WHERE YEAR(date) = 2020 GROUP BY country_id;", "generated_sql": "SELECT country_id, MAX(hours) as max_training_hours \nFROM training \nWHERE YEAR(date) = 2020 \nGROUP BY country_id;", "raw_model_output": "```sql\nSELECT country_id, MAX(hours) as max_training_hours \nFROM training \nWHERE YEAR(date) = 2020 \nGROUP BY country_id;\n```", "latency_sec": 1.2945067882537842, "total_duration_sec": 1.145521857, "load_duration_sec": 0.022656884, "tokens_prompt": 661, "prompt_eval_sec": 0.292128885, "tokens_completion": 36, "completion_eval_sec": 0.824096057, "tokens_total": 697, "tokens_per_sec": 538.4290034818691, "retrieval_latency_sec": 0.11336779594421387, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (country_id and MAX(hours)) from the training table filtered by YEAR(date) = 2020, grouped by country_id. The generated query adds an explicit alias (max_training_hours) for the MAX(hours) column, but this does not affect the semantic result set content. The core logic and output data remain identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically correct and produce identical results. The reference query returns the same data as the generated query but lacks a column alias. The generated query improves readability by explicitly naming the aggregated column 'max_training_hours', which better aligns with the business question's requirement to report 'maximum number of training hours'. While both fulfill the intent, the generated version is more elegant and semantically descriptive without altering the core logic.", "overall_assessment": "correct"}}
{"example_id": 2703, "sql_complexity": "set operations", "prompt": "Identify the species unique to 'MarineResearchAreaA' and 'MarineResearchAreaB'", "context": "CREATE TABLE ResearchAreaSpecies (area VARCHAR(255), species VARCHAR(255)); INSERT INTO ResearchAreaSpecies (area, species) VALUES ('MarineResearchAreaA', 'Coral'), ('MarineResearchAreaA', 'Starfish'), ('MarineResearchAreaB', 'Jellyfish');", "reference_sql": "(SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB') UNION (SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA');", "generated_sql": "(SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB') \nUNION \n(SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA');", "raw_model_output": "```sql\n(SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB') \nUNION \n(SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA');\n```", "latency_sec": 2.395479917526245, "total_duration_sec": 2.072596399, "load_duration_sec": 0.01594949, "tokens_prompt": 696, "prompt_eval_sec": 0.296482731, "tokens_completion": 77, "completion_eval_sec": 1.756228294, "tokens_total": 773, "tokens_per_sec": 322.6910792883034, "retrieval_latency_sec": 0.11515021324157715, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure and logic. Both queries compute the symmetric difference between species in 'MarineResearchAreaA' and 'MarineResearchAreaB' using EXCEPT and UNION operations. The line breaks in the Generated SQL do not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "The reference and generated SQL queries are identical in structure and logic. Both use EXCEPT to find species present in one area but not the other, then combine results with UNION to show all unique species across both areas. The queries correctly implement set operations to identify species exclusive to each research area, matching the business intent. The approach is efficient, using native SQL set operations without unnecessary complexity.", "overall_assessment": "correct"}}
{"example_id": 200, "sql_complexity": "window functions", "prompt": "List the top three categories of workforce development programs with the highest budget increases.", "context": "CREATE TABLE programs (program_id INT, program_name VARCHAR(50), budget DECIMAL(10, 2), category VARCHAR(50), budget_date DATE);", "reference_sql": "SELECT category, SUM(budget - LAG(budget) OVER (PARTITION BY category ORDER BY budget_date)) as total_budget_increase FROM programs GROUP BY category ORDER BY total_budget_increase DESC LIMIT 3;", "generated_sql": "SELECT category, SUM(budget) AS total_budget\nFROM programs\nGROUP BY category\nORDER BY total_budget DESC\nLIMIT 3;", "raw_model_output": "To list the top three categories of workforce development programs with the highest budget increases, we need to calculate the budget increase for each category and then rank them. Here's how you can achieve this:\n\n1. Calculate the budget increase for each category.\n2. Rank the categories based on their budget increase in descending order.\n3. Select the top three categories.\n\nHere is the SQL query to accomplish this:\n\n```sql\nSELECT category, SUM(budget) AS total_budget\nFROM programs\nGROUP BY category\nORDER BY total_budget DESC\nLIMIT 3;\n```\n\nExplanation:\n- We use `SUM(budget)` to calculate the total budget for each category.\n- We group the results by `category` using `GROUP BY`.\n- We order the results by `total_budget` in descending order using `ORDER BY total_budget DESC`.\n- Finally, we limit the results to the top three categories using `LIMIT 3`.", "latency_sec": 4.543076038360596, "total_duration_sec": 4.454881155, "load_duration_sec": 0.015776082, "tokens_prompt": 535, "prompt_eval_sec": 0.138312745, "tokens_completion": 186, "completion_eval_sec": 4.296849994, "tokens_total": 721, "tokens_per_sec": 158.70304478993015, "retrieval_latency_sec": 0.11286234855651855, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates the total budget increase per category by subtracting the previous budget (using LAG) from each budget value before summing, while the generated query simply sums all budgets per category. The semantic logic and resulting metrics differ fundamentally.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly calculates budget increases by using the LAG function to compare consecutive budgets within each category and sums the differences. The Generated SQL incorrectly sums total budgets instead of measuring increases. While both queries are technically valid, they address different metrics: the Reference focuses on *changes* in budget over time, while the Generated focuses on *absolute budget amounts*. The original question explicitly asks for 'budget increases,' making the Reference the only query that fulfills the business intent. The Generated query would return categories with the largest total budgets, not the greatest increases.", "overall_assessment": "differently_correct"}}
{"example_id": 5131, "sql_complexity": "basic SQL", "prompt": "How many wells were drilled in the Eagle Ford Shale and Bakken Formation?", "context": "CREATE TABLE wells (id INT, region VARCHAR(255), well_type VARCHAR(255), num_drilled INT); INSERT INTO wells (id, region, well_type, num_drilled) VALUES (1, 'Eagle Ford Shale', 'Oil', 2000), (2, 'Eagle Ford Shale', 'Gas', 1500), (3, 'Bakken Formation', 'Oil', 1000), (4, 'Bakken Formation', 'Gas', 1200);", "reference_sql": "SELECT SUM(num_drilled) as total_wells FROM wells WHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "generated_sql": "SELECT SUM(num_drilled) AS total_wells \nFROM wells \nWHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "raw_model_output": "```sql\nSELECT SUM(num_drilled) AS total_wells \nFROM wells \nWHERE region IN ('Eagle Ford Shale', 'Bakken Formation');\n```", "latency_sec": 1.4113729000091553, "total_duration_sec": 1.195729382, "load_duration_sec": 0.022097931, "tokens_prompt": 822, "prompt_eval_sec": 0.329097059, "tokens_completion": 35, "completion_eval_sec": 0.837722068, "tokens_total": 857, "tokens_per_sec": 607.2101851994188, "retrieval_latency_sec": 0.11241292953491211, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both calculate the sum of num_drilled for wells in the 'Eagle Ford Shale' and 'Bakken Formation' regions using the same WHERE clause with IN operator. The only difference is formatting (line breaks and spacing), which does not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "The reference and generated queries are identical in structure, logic, and syntax. Both correctly sum the 'num_drilled' column for wells in 'Eagle Ford Shale' and 'Bakken Formation' regions. The queries are semantically equivalent, produce identical results, and directly address the business question by aggregating total wells drilled in the specified formations. Both are equally efficient and elegant, with no differences in performance or clarity.", "overall_assessment": "correct"}}
{"example_id": 1160, "sql_complexity": "subqueries", "prompt": "What is the total revenue generated from ads on Instagram in March 2021, for users in the 'brand' category who have posted more than 10 times?", "context": "CREATE TABLE ads (ad_id INT, user_id INT, platform VARCHAR(255), ad_revenue DECIMAL(10,2), post_count INT); INSERT INTO ads (ad_id, user_id, platform, ad_revenue, post_count) VALUES (1, 1, 'Instagram', 150.50, 12), (2, 2, 'Twitter', 80.00, 15), (3, 3, 'Instagram', 120.75, 8);", "reference_sql": "SELECT SUM(ad_revenue) FROM ads WHERE platform = 'Instagram' AND MONTH(ad_date) = 3 AND YEAR(ad_date) = 2021 AND user_id IN (SELECT user_id FROM users WHERE category = 'brand' AND post_count > 10);", "generated_sql": "SELECT SUM(ad_revenue) \nFROM ads \nWHERE platform = 'Instagram' \n  AND MONTH(ad_date) = 3 \n  AND YEAR(ad_date) = 2021 \n  AND user_id IN (SELECT user_id FROM users WHERE category = 'brand' AND post_count > 10);", "raw_model_output": "```sql\nSELECT SUM(ad_revenue) \nFROM ads \nWHERE platform = 'Instagram' \n  AND MONTH(ad_date) = 3 \n  AND YEAR(ad_date) = 2021 \n  AND user_id IN (SELECT user_id FROM users WHERE category = 'brand' AND post_count > 10);\n```", "latency_sec": 2.179960012435913, "total_duration_sec": 2.158046358, "load_duration_sec": 0.016523556, "tokens_prompt": 1082, "prompt_eval_sec": 0.405521421, "tokens_completion": 70, "completion_eval_sec": 1.731307019, "tokens_total": 1152, "tokens_per_sec": 528.4500602892901, "retrieval_latency_sec": 0.12268996238708496, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and conditions. Both select the sum of ad_revenue from the ads table with the same filters on platform, ad_date month/year, and user_id subquery. Since they are exactly the same, they will produce identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": false, "superiority": "equal", "explanation": "The Reference and Generated SQL queries are identical in structure and logic, making them technically equivalent. However, they fail to fulfill the business intent because the context provided does not include a 'users' table, which is required by the subquery in the WHERE clause. The original question references 'users in the 'brand' category', but the schema only defines an 'ads' table with a 'post_count' field. This creates a logical inconsistency: the queries assume a 'users' table exists (with 'category' and 'post_count' columns) that is not present in the given context. Without the 'users' table, the queries would fail to execute and cannot accurately answer the question as posed.", "overall_assessment": "incorrect"}}
{"example_id": 4708, "sql_complexity": "subqueries", "prompt": "What is the maximum number of high-level threats reported by a single agency in a month?", "context": "CREATE TABLE Threat_Intelligence (Threat_ID INT, Threat_Type VARCHAR(50), Threat_Level VARCHAR(50), Reported_Date DATE, Reporting_Agency VARCHAR(50)); CREATE VIEW High_Level_Threats AS SELECT Threat_Type, Threat_Level, Reported_Date FROM Threat_Intelligence WHERE Threat_Level = 'High';", "reference_sql": "SELECT Reporting_Agency, MAX(Number_of_High_Level_Threats) as Max_High_Level_Threats_in_a_Month FROM (SELECT Reporting_Agency, TO_CHAR(Reported_Date, 'YYYY-MM') as Month, COUNT(*) as Number_of_High_Level_Threats FROM High_Level_Threats GROUP BY Reporting_Agency, Month) GROUP BY Reporting_Agency;", "generated_sql": "SELECT MAX(threat_count) \nFROM (\n    SELECT Reporting_Agency, COUNT(*) AS threat_count \n    FROM Threat_Intelligence \n    WHERE Threat_Level = 'High' \n      AND Reported_Date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH)\n    GROUP BY Reporting_Agency\n) AS subquery;", "raw_model_output": "```sql\nSELECT MAX(threat_count) \nFROM (\n    SELECT Reporting_Agency, COUNT(*) AS threat_count \n    FROM Threat_Intelligence \n    WHERE Threat_Level = 'High' \n      AND Reported_Date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH)\n    GROUP BY Reporting_Agency\n) AS subquery;\n```", "latency_sec": 2.158947706222534, "total_duration_sec": 1.886542271, "load_duration_sec": 0.021921274, "tokens_prompt": 671, "prompt_eval_sec": 0.289021016, "tokens_completion": 69, "completion_eval_sec": 1.572575793, "tokens_total": 740, "tokens_per_sec": 342.75957581888935, "retrieval_latency_sec": 0.11410784721374512, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in scope and logic. The Reference SQL calculates the maximum number of high-level threats per month across all time for each agency, while the Generated SQL only considers threats from the last month and returns the maximum count across all agencies in that period. The date filter in the Generated SQL ('last month') and the absence of monthly grouping make them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL attempts to address the question by grouping high-level threats by agency and month, but its outer GROUP BY Reporting_Agency and MAX() operation only returns per-agency maxima rather than the global maximum across all agencies and months. The Generated SQL incorrectly restricts to the last month via DATE_SUB and groups by agency without considering monthly granularity, failing to capture threats reported in other months. While the Reference query's subquery correctly identifies high-level threats by month, its final aggregation structure is flawed. The Generated SQL's date filter and lack of monthly grouping make it fundamentally misaligned with the question's requirements. The Reference query is technically closer to the correct approach but still fails to return a single maximum value.", "overall_assessment": "incorrect"}}
{"example_id": 5608, "sql_complexity": "set operations", "prompt": "List the suppliers that provide materials for both product A and product C.", "context": "CREATE TABLE products (product_id INT, product_name TEXT); CREATE TABLE materials (material_id INT, material_name TEXT, product_id INT, supplier_id INT); INSERT INTO products (product_id, product_name) VALUES (1, 'Product A'), (2, 'Product B'), (3, 'Product C'); INSERT INTO materials (material_id, material_name, product_id, supplier_id) VALUES (1, 'Material 1', 1, 101), (2, 'Material 2', 1, 102), (3, 'Material 3', 2, 103), (4, 'Material 4', 3, 101), (5, 'Material 5', 3, 102);", "reference_sql": "SELECT supplier_id FROM materials WHERE product_id = 1 INTERSECT SELECT supplier_id FROM materials WHERE product_id = 3;", "generated_sql": "SELECT supplier_id \nFROM materials \nWHERE product_id IN (SELECT product_id FROM products WHERE product_name = 'Product A')\nINTERSECT\nSELECT supplier_id \nFROM materials \nWHERE product_id IN (SELECT product_id FROM products WHERE product_name = 'Product C');", "raw_model_output": "```sql\nSELECT supplier_id \nFROM materials \nWHERE product_id IN (SELECT product_id FROM products WHERE product_name = 'Product A')\nINTERSECT\nSELECT supplier_id \nFROM materials \nWHERE product_id IN (SELECT product_id FROM products WHERE product_name = 'Product C');\n```", "latency_sec": 2.0817601680755615, "total_duration_sec": 2.051068335, "load_duration_sec": 0.02209799, "tokens_prompt": 1315, "prompt_eval_sec": 0.597379077, "tokens_completion": 59, "completion_eval_sec": 1.426911654, "tokens_total": 1374, "tokens_per_sec": 660.0183926423017, "retrieval_latency_sec": 0.11485791206359863, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries find supplier_ids associated with product_id 1 (Product A) and product_id 3 (Product C). The Reference SQL directly uses product_id = 1 and product_id = 3, while the Generated SQL uses subqueries to translate product names ('Product A' \u2192 1, 'Product C' \u2192 3). Since the product_id mappings are fixed and unique, the result sets are identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify suppliers providing materials for both Product A and Product C using INTERSECT. The Reference query hardcodes product_id values (1 and 3), while the Generated query dynamically retrieves product_ids via subqueries based on product_name. Technically, they produce identical results in this specific dataset. However, the Generated query better fulfills business intent by using product names (as specified in the question) rather than arbitrary IDs, making it more maintainable and semantically aligned with the original question. While the Reference is simpler, the Generated version demonstrates better design for real-world scenarios where product_id values might change or be less intuitive.", "overall_assessment": "differently_correct"}}
{"example_id": 1506, "sql_complexity": "basic SQL", "prompt": "How many habitats are in the 'animal_habitats' table?", "context": "CREATE TABLE animal_habitats (id INT PRIMARY KEY, habitat_name VARCHAR, num_animals INT);", "reference_sql": "SELECT COUNT(*) FROM animal_habitats;", "generated_sql": "SELECT COUNT(*) FROM animal_habitats;", "raw_model_output": "```sql\nSELECT COUNT(*) FROM animal_habitats;\n```", "latency_sec": 1.666877269744873, "total_duration_sec": 0.630712599, "load_duration_sec": 0.020605452, "tokens_prompt": 634, "prompt_eval_sec": 0.286732211, "tokens_completion": 14, "completion_eval_sec": 0.317666633, "tokens_total": 648, "tokens_per_sec": 388.75087672122424, "retrieval_latency_sec": 0.1141669750213623, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical: they select the count of all rows from the 'animal_habitats' table using the same syntax. The result will always be the same since they execute the same operation on the same table.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical: SELECT COUNT(*) FROM animal_habitats;. They will produce the same result by counting all rows in the table. The business intent is fully satisfied as the question asks for the number of habitats, which corresponds to the total row count. The query is efficient and elegant, using the standard COUNT(*) approach for row counting. No differences exist between the two queries in any evaluation aspect.", "overall_assessment": "correct"}}
{"example_id": 3117, "sql_complexity": "aggregation", "prompt": "What is the percentage of the population that has access to clean water in each continent?", "context": "CREATE TABLE water_data (id INT, country VARCHAR(50), continent CHAR(2), access_to_clean_water BOOLEAN); INSERT INTO water_data VALUES (1, 'Canada', 'NA', true), (2, 'Mexico', 'NA', false), (3, 'Brazil', 'SA', true), (4, 'Russia', 'EU', true);", "reference_sql": "SELECT continent, COUNT(*) FILTER (WHERE access_to_clean_water) * 100.0 / COUNT(*) AS percentage FROM water_data GROUP BY continent;", "generated_sql": "SELECT continent, \n       (SUM(CASE WHEN access_to_clean_water = true THEN 1 ELSE 0 END) / COUNT(*)) * 100 AS clean_water_percentage\nFROM water_data\nGROUP BY continent;", "raw_model_output": "```sql\nSELECT continent, \n       (SUM(CASE WHEN access_to_clean_water = true THEN 1 ELSE 0 END) / COUNT(*)) * 100 AS clean_water_percentage\nFROM water_data\nGROUP BY continent;\n```", "latency_sec": 1.6601741313934326, "total_duration_sec": 1.550113646, "load_duration_sec": 0.019420107, "tokens_prompt": 798, "prompt_eval_sec": 0.323488222, "tokens_completion": 51, "completion_eval_sec": 1.20378295, "tokens_total": 849, "tokens_per_sec": 511.39213890015833, "retrieval_latency_sec": 0.1152961254119873, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses COUNT(*) FILTER (WHERE access_to_clean_water) * 100.0 / COUNT(*) which ensures floating-point division by multiplying by 100.0. The Generated SQL uses (SUM(CASE...) / COUNT(*)) * 100, which performs integer division in PostgreSQL (since both SUM and COUNT are integers), leading to incorrect results for fractional percentages. For example, 1/2 would yield 0 instead of 50.0.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries calculate the percentage of countries with access to clean water per continent. The reference query uses PostgreSQL's COUNT(*) FILTER syntax, which is more concise. The generated query uses a CASE statement with SUM/COUNT, which is more portable across SQL dialects. Semantically, they produce identical results when division is handled as floating-point (e.g., 3/4 * 100 = 75.0). However, the reference query explicitly uses 100.0 to ensure floating-point division, while the generated query relies on implicit conversion. Both fulfill the business intent, but the reference is more elegant and efficient.", "overall_assessment": "correct"}}
{"example_id": 3542, "sql_complexity": "window functions", "prompt": "What is the average yield of crops for each country, ranked by average yield?", "context": "CREATE TABLE farming (id INT, name TEXT, country TEXT, crop TEXT, yield INT); INSERT INTO farming VALUES (1, 'Smith Farm', 'USA', 'Corn', 120), (2, 'Brown Farm', 'Canada', 'Soybeans', 45), (3, 'Jones Farm', 'Mexico', 'Wheat', 80);", "reference_sql": "SELECT country, AVG(yield) as avg_yield, ROW_NUMBER() OVER (ORDER BY AVG(yield) DESC) as rank FROM farming GROUP BY country;", "generated_sql": "SELECT country, AVG(yield) AS avg_yield \nFROM farming \nGROUP BY country \nORDER BY avg_yield DESC;", "raw_model_output": "```sql\nSELECT country, AVG(yield) AS avg_yield \nFROM farming \nGROUP BY country \nORDER BY avg_yield DESC;\n```", "latency_sec": 1.107193946838379, "total_duration_sec": 0.972684196, "load_duration_sec": 0.016709248, "tokens_prompt": 673, "prompt_eval_sec": 0.290216943, "tokens_completion": 29, "completion_eval_sec": 0.662767875, "tokens_total": 702, "tokens_per_sec": 634.0352582350899, "retrieval_latency_sec": 0.11139512062072754, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a ROW_NUMBER() column that assigns a rank based on average yield, while the Generated SQL only returns country and average yield without the rank. The presence of the additional column makes them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The Reference SQL includes a ROW_NUMBER() window function to explicitly assign ranks based on average yield, directly addressing the 'ranked by average yield' requirement. The Generated SQL only orders results by average yield without adding a rank column. While both calculate average yields correctly, the Reference query fully satisfies the business intent of providing explicit rankings. The Generated query is technically correct but incomplete for the specific request. The Reference query is slightly less efficient due to the window function but better aligns with the user's explicit need for ranking.", "overall_assessment": "differently_correct"}}
{"example_id": 2274, "sql_complexity": "subqueries", "prompt": "Add a new crop 'amaranth' to farm 'Nourishing Harvest' with yield 50 in 2023", "context": "CREATE TABLE farms (id INT, name TEXT, location TEXT, size FLOAT); INSERT INTO farms (id, name, location, size) VALUES (1, 'Nourishing Harvest', 'Mexico', 120.0); CREATE TABLE crops (id INT, farm_id INT, crop TEXT, yield INT, year INT);", "reference_sql": "INSERT INTO crops (id, farm_id, crop, yield, year) VALUES (5, (SELECT id FROM farms WHERE name = 'Nourishing Harvest'), 'amaranth', 50, 2023);", "generated_sql": "INSERT INTO crops (farm_id, crop, yield, year) \nVALUES ((SELECT id FROM farms WHERE name = 'Nourishing Harvest'), 'amaranth', 50, 2023);", "raw_model_output": "```sql\nINSERT INTO crops (farm_id, crop, yield, year) \nVALUES ((SELECT id FROM farms WHERE name = 'Nourishing Harvest'), 'amaranth', 50, 2023);\n```", "latency_sec": 1.6275010108947754, "total_duration_sec": 1.62277935, "load_duration_sec": 0.017196056, "tokens_prompt": 1084, "prompt_eval_sec": 0.402500629, "tokens_completion": 48, "completion_eval_sec": 1.19952427, "tokens_total": 1132, "tokens_per_sec": 695.5448828739243, "retrieval_latency_sec": 0.10981893539428711, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL explicitly specifies the 'id' column and assigns it a value of 5, while the Generated SQL omits the 'id' column entirely. This difference in column selection leads to different behaviors: the Reference SQL sets an explicit ID, whereas the Generated SQL relies on the database to handle the 'id' (e.g., auto-increment). The presence of the 'id' column in the first query but not the second makes them semantically distinct.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because the reference query explicitly specifies an 'id' column while the generated query omits it. However, the generated query better fulfills the business intent by focusing on the required fields (farm_id, crop, yield, year) without unnecessary complexity. The reference query's inclusion of a hard-coded 'id' (5) is less flexible and potentially error-prone if the actual ID differs. The generated query uses a subquery to dynamically fetch the farm_id, making it more robust and aligned with the original question's requirements. Both queries would produce semantically equivalent results if the 'id' column is auto-generated or irrelevant, but the generated query is more efficient and elegant.", "overall_assessment": "differently_correct"}}
{"example_id": 3705, "sql_complexity": "subqueries", "prompt": "What is the percentage of unions with collective bargaining agreements in the Midwest region?", "context": "CREATE TABLE collective_bargaining (bargaining_id INT, union_name VARCHAR(50), contract_start_date DATE, contract_end_date DATE, region VARCHAR(50));CREATE VIEW union_region AS SELECT DISTINCT union_name, region FROM collective_bargaining;", "reference_sql": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM union_region) as percentage FROM union_region ur WHERE ur.region = 'Midwest' AND EXISTS (SELECT 1 FROM collective_bargaining cb WHERE cb.union_name = ur.union_name);", "generated_sql": "SELECT \n    (COUNT(CASE WHEN region = 'Midwest' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_midwest_unions\nFROM \n    union_region;", "raw_model_output": "```sql\nSELECT \n    (COUNT(CASE WHEN region = 'Midwest' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_midwest_unions\nFROM \n    union_region;\n```", "latency_sec": 1.9413390159606934, "total_duration_sec": 1.701104063, "load_duration_sec": 0.022053414, "tokens_prompt": 1156, "prompt_eval_sec": 0.562251133, "tokens_completion": 48, "completion_eval_sec": 1.109343461, "tokens_total": 1204, "tokens_per_sec": 620.1904922846189, "retrieval_latency_sec": 0.11832308769226074, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the percentage of unions in the 'Midwest' region relative to the total number of unique union-region combinations. The reference query uses a subquery with EXISTS (which is redundant since union_region is derived from collective_bargaining) and counts Midwest entries, while the generated query directly computes the same ratio using conditional aggregation. The mathematical result is identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries calculate the percentage of unions with collective bargaining agreements in the Midwest region. The reference query uses a subquery and EXISTS clause, which is redundant since union_region already contains only unions with agreements. The generated query simplifies this with a single COUNT(CASE...) expression, achieving the same result more efficiently. Both correctly interpret the question as (Midwest unions with agreements / total unions with agreements), but the generated query is more elegant and avoids unnecessary complexity.", "overall_assessment": "correct"}}
{"example_id": 240, "sql_complexity": "aggregation", "prompt": "What is the average capacity of renewable energy projects for each country?", "context": "CREATE TABLE projects (name TEXT, type TEXT, capacity INTEGER, country TEXT); INSERT INTO projects (name, type, capacity, country) VALUES ('Project 1', 'Wind', 100, 'USA'), ('Project 2', 'Solar', 200, 'Germany'), ('Project 3', 'Wind', 300, 'France');", "reference_sql": "SELECT country, AVG(capacity) FROM projects GROUP BY country", "generated_sql": "SELECT country, AVG(capacity) AS avg_capacity \nFROM projects \nWHERE type IN ('Wind', 'Solar') \nGROUP BY country;", "raw_model_output": "```sql\nSELECT country, AVG(capacity) AS avg_capacity \nFROM projects \nWHERE type IN ('Wind', 'Solar') \nGROUP BY country;\n```", "latency_sec": 1.2520372867584229, "total_duration_sec": 1.091760296, "load_duration_sec": 0.016532748, "tokens_prompt": 724, "prompt_eval_sec": 0.305059822, "tokens_completion": 33, "completion_eval_sec": 0.766252869, "tokens_total": 757, "tokens_per_sec": 604.6145813755314, "retrieval_latency_sec": 0.11097216606140137, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average capacity per country. The generated query includes a WHERE clause filtering for 'Wind' and 'Solar' types, but the sample data contains only projects of these types. Thus, the filtering has no effect on the result, making the queries semantically equivalent in this context.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because the generated query adds a WHERE clause filtering for 'Wind' and 'Solar' projects, while the reference query includes all project types. The original question asks for 'renewable energy projects,' which aligns with the generated query's explicit filtering (assuming Wind/Solar are the only renewable types in the dataset). The reference query might include non-renewable projects if they exist in the table, making it less precise. However, since the context's sample data only contains Wind/Solar projects, both queries would produce the same results in this specific case. The generated query better fulfills the business intent by explicitly restricting to renewable energy types, ensuring accuracy even if the table contains non-renewable projects.", "overall_assessment": "differently_correct"}}
{"example_id": 2132, "sql_complexity": "set operations", "prompt": "What is the average caseload per attorney in community legal clinics in California, and how does it compare to the state average?", "context": "CREATE TABLE cali_community_legal_clinics(id INT, attorney_count INT, cases_handled INT, state VARCHAR(255));", "reference_sql": "SELECT state, AVG(cases_handled/attorney_count) AS avg_caseload FROM cali_community_legal_clinics WHERE state = 'California' GROUP BY state UNION ALL SELECT 'California', AVG(cases_handled/attorney_count) FROM cali_community_legal_clinics WHERE state = 'California';", "generated_sql": "SELECT \n    (SUM(cases_handled) / SUM(attorney_count)) AS avg_caseload_per_attorney_california,\n    (SUM(cases_handled) / COUNT(*)) AS state_average_cases_handled\nFROM \n    cali_community_legal_clinics;", "raw_model_output": "To answer the question, we need to calculate two things:\n1. The average caseload per attorney in community legal clinics in California.\n2. The state average of cases handled.\n\nWe can achieve this by using the `AVG` function on the `cases_handled` and `attorney_count` columns for California, and then comparing it with the overall state average.\n\nHere is the SQL query to get the required information:\n\n```sql\nSELECT \n    (SUM(cases_handled) / SUM(attorney_count)) AS avg_caseload_per_attorney_california,\n    (SUM(cases_handled) / COUNT(*)) AS state_average_cases_handled\nFROM \n    cali_community_legal_clinics;\n```\n\nExplanation:\n- `SUM(cases_handled) / SUM(attorney_count)` calculates the average caseload per attorney in California.\n- `SUM(cases_handled) / COUNT(*)` calculates the overall state average of cases handled.", "latency_sec": 5.1909401416778564, "total_duration_sec": 4.910307397, "load_duration_sec": 0.016095799, "tokens_prompt": 760, "prompt_eval_sec": 0.310705294, "tokens_completion": 196, "completion_eval_sec": 4.580102709, "tokens_total": 956, "tokens_per_sec": 184.1670244517584, "retrieval_latency_sec": 0.1099100112915039, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates the average caseload per attorney specifically for California clinics, using AVG(cases_handled/attorney_count) and includes a redundant union. The Generated SQL computes aggregate values for all states (not just California) and uses SUM(cases_handled)/SUM(attorney_count) (total cases per total attorneys) instead of averaging ratios. Additionally, the Generated SQL includes an extra column (state_average_cases_handled) not present in the Reference SQL.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL calculates the average caseload per attorney for California clinics (first SELECT) but redundantly repeats the same value in the UNION ALL. It fails to compute the 'state average' as requested. The Generated SQL lacks a WHERE clause to filter for California, leading to incorrect aggregation of all clinics (not just California's). It also calculates 'state_average_cases_handled' as total cases per clinic (not per attorney), which misrepresents the intended comparison. While the Reference SQL correctly isolates California data, its second part is semantically flawed. The Generated SQL is fundamentally incorrect due to missing filters and misaligned metrics.", "overall_assessment": "incorrect"}}
{"example_id": 3276, "sql_complexity": "basic SQL", "prompt": "What is the total energy consumption of the Chemical Plant B in the last quarter?", "context": "CREATE TABLE EnergyConsumption (EnergyID INT, Plant VARCHAR(255), EnergyQuantity DECIMAL(5,2), Timestamp DATETIME);", "reference_sql": "SELECT SUM(EnergyQuantity) FROM EnergyConsumption WHERE Plant = 'Chemical Plant B' AND Timestamp BETWEEN DATE_SUB(CURRENT_DATE(), INTERVAL 3 MONTH) AND CURRENT_DATE();", "generated_sql": "SELECT SUM(EnergyQuantity) AS TotalEnergyConsumption\nFROM EnergyConsumption\nWHERE Plant = 'Chemical Plant B'\n  AND Timestamp >= DATEADD(quarter, -1, CURRENT_DATE);", "raw_model_output": "```sql\nSELECT SUM(EnergyQuantity) AS TotalEnergyConsumption\nFROM EnergyConsumption\nWHERE Plant = 'Chemical Plant B'\n  AND Timestamp >= DATEADD(quarter, -1, CURRENT_DATE);\n```", "latency_sec": 1.6117799282073975, "total_duration_sec": 1.424915796, "load_duration_sec": 0.015783972, "tokens_prompt": 795, "prompt_eval_sec": 0.321020558, "tokens_completion": 46, "completion_eval_sec": 1.083948836, "tokens_total": 841, "tokens_per_sec": 521.7833931803272, "retrieval_latency_sec": 0.11288905143737793, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of EnergyQuantity for 'Chemical Plant B' over the last 3 months. The reference uses BETWEEN with DATE_SUB(CURRENT_DATE(), INTERVAL 3 MONTH) to define the range, while the generated query uses TIMESTAMP >= DATEADD(quarter, -1, CURRENT_DATE). Since DATE_SUB with 3 months and DATEADD with -1 quarter produce the same date, and both conditions include the current date as the upper bound, the semantic logic is equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in their date range logic. The reference query uses BETWEEN with DATE_SUB(CURRENT_DATE(), INTERVAL 3 MONTH) to explicitly capture the full 3-month period ending today. The generated query uses DATEADD(quarter, -1, CURRENT_DATE) but lacks an upper bound, potentially including timestamps beyond the current date (if any exist). While both target the 'last quarter,' the generated query's missing upper bound makes it technically incomplete. The reference query more accurately captures the intended 3-month window.", "overall_assessment": "incorrect"}}
{"example_id": 3074, "sql_complexity": "multiple_joins", "prompt": "Find the top 5 players with the highest scores in the 'historical_tournaments' view, including their scores and the names of the tournaments they participated in.", "context": "CREATE VIEW historical_tournaments AS SELECT tournaments.tournament_name, players.player_name, players.score FROM tournaments JOIN players_scores ON tournaments.tournament_id = players_scores.tournament_id JOIN players ON players_scores.player_id = players.player_id;  CREATE TABLE tournaments (tournament_id INT, tournament_name TEXT);  CREATE TABLE players_scores (player_id INT, tournament_id INT, score INT);  CREATE TABLE players (player_id INT, player_name TEXT);", "reference_sql": "SELECT players.player_name, MAX(players_scores.score) as high_score, tournaments.tournament_name FROM historical_tournaments JOIN players ON historical_tournaments.player_id = players.player_id JOIN players_scores ON historical_tournaments.player_id = players_scores.player_id JOIN tournaments ON players_scores.tournament_id = tournaments.tournament_id GROUP BY players.player_id, tournaments.tournament_name ORDER BY high_score DESC LIMIT 5;", "generated_sql": "SELECT player_name, score, tournament_name \nFROM historical_tournaments \nORDER BY score DESC \nLIMIT 5;", "raw_model_output": "```sql\nSELECT player_name, score, tournament_name \nFROM historical_tournaments \nORDER BY score DESC \nLIMIT 5;\n```", "latency_sec": 1.2273027896881104, "total_duration_sec": 1.131833725, "load_duration_sec": 0.015693475, "tokens_prompt": 995, "prompt_eval_sec": 0.383354252, "tokens_completion": 28, "completion_eval_sec": 0.728441915, "tokens_total": 1023, "tokens_per_sec": 833.5351378611068, "retrieval_latency_sec": 0.11918091773986816, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL groups by player and tournament to find the maximum score per group, while the Generated SQL simply selects top 5 scores from the view without aggregation. The Generated SQL lacks grouping and would return individual rows, potentially including multiple entries per player/tournament, whereas the Reference SQL aggregates scores. Additionally, the Reference SQL references columns (player_id) not present in the historical_tournaments view, indicating a potential error.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL contains critical technical errors: it references 'player_id' in joins, but the 'historical_tournaments' view does not include this column (it only contains tournament_name, player_name, and score). This makes the Reference SQL invalid. The Generated SQL correctly uses the view's existing columns (player_name, score, tournament_name) and directly retrieves the top 5 scores. However, neither query fully addresses the business intent of identifying top players (not just top scores). The Generated SQL is technically valid but may return multiple entries for the same player, while the Reference SQL is invalid due to schema mismatches.", "overall_assessment": "incorrect"}}
{"example_id": 2219, "sql_complexity": "window functions", "prompt": "What is the average population of cities with a UNESCO World Heritage designation, ordered by designation date?", "context": "CREATE TABLE cities (name VARCHAR(255), population INT, designation_date DATE); INSERT INTO cities (name, population, designation_date) VALUES ('Paris', 2141000, '1991-09-16'); INSERT INTO cities (name, population, designation_date) VALUES ('Rio de Janeiro', 6727000, '2012-07-01');", "reference_sql": "SELECT AVG(population) FROM (SELECT population, ROW_NUMBER() OVER (ORDER BY designation_date) rn FROM cities WHERE name IN (SELECT name FROM heritagesites)) t WHERE rn % 2 = 1;", "generated_sql": "SELECT AVG(population) AS average_population \nFROM cities \nWHERE name IN (\n    SELECT site_name \n    FROM unesco_world_heritage_sites\n)\nORDER BY designation_date;", "raw_model_output": "```sql\nSELECT AVG(population) AS average_population \nFROM cities \nWHERE name IN (\n    SELECT site_name \n    FROM unesco_world_heritage_sites\n)\nORDER BY designation_date;\n```", "latency_sec": 1.7476160526275635, "total_duration_sec": 1.452709029, "load_duration_sec": 0.015601226, "tokens_prompt": 981, "prompt_eval_sec": 0.385325372, "tokens_completion": 42, "completion_eval_sec": 1.047370742, "tokens_total": 1023, "tokens_per_sec": 585.3688505904407, "retrieval_latency_sec": 0.11294293403625488, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. 1) The reference query uses a subquery with ROW_NUMBER() to select only odd-numbered rows (based on designation_date ordering) from a filtered subset of cities, then averages those populations. The generated query simply averages all populations of cities meeting the name condition, without any row filtering. 2) The subquery conditions differ: the reference uses 'heritagesites' while the generated uses 'unesco_world_heritage_sites' (assuming these are different tables). These differences in logic and data sources ensure the queries produce different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is fundamentally flawed: it uses ROW_NUMBER() to select every other row (rn % 2 = 1) and averages those, which does not compute the true average population of all UNESCO-designated cities. The Generated SQL correctly calculates the average population but references a non-existent 'unesco_world_heritage_sites' table. However, it properly orders by designation_date (though ordering is unnecessary for an average). The Reference SQL's approach is mathematically incorrect for the question, while the Generated SQL better aligns with the business intent despite schema issues.", "overall_assessment": "differently_correct"}}
{"example_id": 3786, "sql_complexity": "aggregation", "prompt": "Display the names and average co-owner percentages for all properties in the 'property_coownership' table where the co-owner percentage is greater than 60.", "context": "CREATE TABLE property_coownership (property_id INT, owner VARCHAR(255), percentage INT); INSERT INTO property_coownership (property_id, owner, percentage) VALUES (1, 'Mohammed', 70), (1, 'Fatima', 30), (2, 'Jamal', 65), (2, 'Aisha', 35), (3, 'Ali', 75), (3, 'Khadija', 25);", "reference_sql": "SELECT owner, AVG(percentage) FROM property_coownership WHERE percentage > 60 GROUP BY owner;", "generated_sql": "SELECT owner, AVG(percentage) \nFROM property_coownership \nWHERE percentage > 60 \nGROUP BY owner;", "raw_model_output": "```sql\nSELECT owner, AVG(percentage) \nFROM property_coownership \nWHERE percentage > 60 \nGROUP BY owner;\n```", "latency_sec": 1.1566181182861328, "total_duration_sec": 1.121930108, "load_duration_sec": 0.019326793, "tokens_prompt": 905, "prompt_eval_sec": 0.358949589, "tokens_completion": 29, "completion_eval_sec": 0.736037172, "tokens_total": 934, "tokens_per_sec": 807.5266894348789, "retrieval_latency_sec": 0.11344695091247559, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure, logic, and syntax. Both select the 'owner' and average 'percentage' from the property_coownership table where percentage exceeds 60, grouping by owner. No differences exist in conditions, columns, or operations.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": false, "superiority": "equal", "explanation": "The Reference and Generated SQL queries are identical in syntax and logic, making them technically equivalent. However, they do not fully fulfill the business intent. The original question asks for 'average co-owner percentages for all properties' where co-owner percentages exceed 60. The queries group by 'owner' instead of 'property_id', which would calculate averages per owner rather than per property. For example, property 1 (Mohammed 70%, Fatima 30%) would show Mohammed's 70% average (correctly filtered) but omit the property-level context. The queries also fail to address whether the average should be calculated across all co-owners per property or individual co-owners. This misalignment with the business intent (properties vs. owners) makes the queries technically correct but semantically incomplete.", "overall_assessment": "differently_correct"}}
{"example_id": 2357, "sql_complexity": "basic SQL", "prompt": "What is the total amount of climate finance invested in renewable energy projects by public and private sectors in Africa?", "context": "CREATE TABLE renewable_energy_projects (project_id INT, sector TEXT, investor_type TEXT, region TEXT, amount FLOAT); INSERT INTO renewable_energy_projects (project_id, sector, investor_type, region, amount) VALUES (1, 'Renewable Energy', 'Public', 'Africa', 5000000); INSERT INTO renewable_energy_projects (project_id, sector, investor_type, region, amount) VALUES (2, 'Renewable Energy', 'Private', 'Africa', 7000000);", "reference_sql": "SELECT SUM(amount) FROM renewable_energy_projects WHERE sector = 'Renewable Energy' AND region = 'Africa';", "generated_sql": "SELECT SUM(amount) \nFROM renewable_energy_projects \nWHERE region = 'Africa';", "raw_model_output": "```sql\nSELECT SUM(amount) \nFROM renewable_energy_projects \nWHERE region = 'Africa';\n```", "latency_sec": 0.898780345916748, "total_duration_sec": 0.864597517, "load_duration_sec": 0.015781472, "tokens_prompt": 813, "prompt_eval_sec": 0.322943487, "tokens_completion": 21, "completion_eval_sec": 0.52237537, "tokens_total": 834, "tokens_per_sec": 927.9241627711912, "retrieval_latency_sec": 0.11134076118469238, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The generated query omits the 'sector = 'Renewable Energy'' condition. While both queries filter by 'region = 'Africa'', the reference query explicitly restricts to 'Renewable Energy' sector projects. If there were other sector projects in Africa, the generated query would include them, resulting in a different sum.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly filters both sector ('Renewable Energy') and region ('Africa'), ensuring only relevant renewable energy projects in Africa are summed. The generated query omits the sector filter, potentially including non-renewable energy projects in Africa. While both queries sum amounts for African projects, the generated query violates the business requirement to specifically target renewable energy projects. The reference query is more precise and aligns with the original question's constraints.", "overall_assessment": "incorrect"}}
{"example_id": 1009, "sql_complexity": "multiple_joins", "prompt": "Find the number of IoT sensors installed in each farm that use Sprinkler irrigation.", "context": "CREATE TABLE IoT_Sensors (id INT, sensor_type VARCHAR(50), Farm_id INT); INSERT INTO IoT_Sensors (id, sensor_type, Farm_id) VALUES (1, 'Soil Moisture', 1), (2, 'Temperature', 1), (3, 'Humidity', 2); CREATE TABLE Irrigation (id INT, Farm_id INT, irrigation_type VARCHAR(50), duration INT); INSERT INTO Irrigation (id, Farm_id, irrigation_type, duration) VALUES (1, 1, 'Sprinkler', 30), (2, 2, 'Drip', 45);", "reference_sql": "SELECT f.id, COUNT(s.id) FROM Farmers f JOIN Irrigation i ON f.id = i.Farm_id JOIN IoT_Sensors s ON f.id = s.Farm_id WHERE i.irrigation_type = 'Sprinkler' GROUP BY f.id;", "generated_sql": "SELECT Farm_id, COUNT(*) as number_of_sensors \nFROM IoT_Sensors \nWHERE Farm_id IN (\n    SELECT Farm_id \n    FROM Irrigation \n    WHERE irrigation_type = 'Sprinkler'\n)\nGROUP BY Farm_id;", "raw_model_output": "```sql\nSELECT Farm_id, COUNT(*) as number_of_sensors \nFROM IoT_Sensors \nWHERE Farm_id IN (\n    SELECT Farm_id \n    FROM Irrigation \n    WHERE irrigation_type = 'Sprinkler'\n)\nGROUP BY Farm_id;\n```", "latency_sec": 1.7097599506378174, "total_duration_sec": 1.637870226, "load_duration_sec": 0.016138065, "tokens_prompt": 864, "prompt_eval_sec": 0.350033362, "tokens_completion": 53, "completion_eval_sec": 1.267769934, "tokens_total": 917, "tokens_per_sec": 536.3326001746138, "retrieval_latency_sec": 0.11375999450683594, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of IoT sensors per farm that has at least one 'Sprinkler' irrigation entry. The Reference SQL uses explicit joins between Farmers, Irrigation, and IoT_Sensors tables, while the Generated SQL uses a subquery to filter Farm_ids with 'Sprinkler' irrigation and directly counts sensors in IoT_Sensors. Since the Farm_id in IoT_Sensors corresponds to Farmers.id, both approaches produce the same result.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query is technically incorrect because it references a 'Farmers' table that does not exist in the provided schema. The generated query correctly uses the existing 'IoT_Sensors' and 'Irrigation' tables. Both queries aim to count sensors on farms with Sprinkler irrigation, but the reference query's invalid table reference makes it non-functional. The generated query is semantically correct, uses valid joins/subqueries, and would produce accurate results. While both address the business intent, the generated query is the only valid implementation.", "overall_assessment": "incorrect"}}
{"example_id": 4217, "sql_complexity": "subqueries", "prompt": "Show consumer preference data for foundations, excluding products from the USA.", "context": "CREATE TABLE cosmetics (product_id INT, product_name VARCHAR(100), product_type VARCHAR(50), is_cruelty_free BOOLEAN, consumer_preference_score INT); INSERT INTO cosmetics (product_id, product_name, product_type, is_cruelty_free, consumer_preference_score) VALUES (1, 'Lipstick A', 'Lipstick', TRUE, 80), (2, 'Foundation B', 'Foundation', FALSE, 90), (3, 'Mascara C', 'Mascara', TRUE, 85), (4, 'Eyeshadow D', 'Eyeshadow', TRUE, 70), (5, 'Blush E', 'Blush', FALSE, 95); CREATE TABLE ingredient_sourcing (ingredient_id INT, ingredient_name VARCHAR(100), sourcing_country VARCHAR(50), is_organic BOOLEAN); INSERT INTO ingredient_sourcing (ingredient_id, ingredient_name, sourcing_country, is_organic) VALUES (1, 'Rosehip Oil', 'Chile', TRUE), (2, 'Shea Butter', 'Ghana', TRUE), (3, 'Jojoba Oil', 'India', TRUE), (4, 'Coconut Oil', 'Philippines', FALSE), (5, 'Aloe Vera', 'USA', TRUE);", "reference_sql": "SELECT * FROM cosmetics WHERE product_type = 'Foundation' AND product_id NOT IN (SELECT cosmetics.product_id FROM cosmetics INNER JOIN ingredient_sourcing ON cosmetics.product_id = ingredient_sourcing.ingredient_id WHERE ingredient_sourcing.sourcing_country = 'USA');", "generated_sql": "SELECT product_name, consumer_preference_score \nFROM cosmetics \nWHERE product_type = 'Foundation' AND sourcing_country != 'USA';", "raw_model_output": "```sql\nSELECT product_name, consumer_preference_score \nFROM cosmetics \nWHERE product_type = 'Foundation' AND sourcing_country != 'USA';\n```", "latency_sec": 1.8006668090820312, "total_duration_sec": 1.194246363, "load_duration_sec": 0.023824466, "tokens_prompt": 972, "prompt_eval_sec": 0.382297325, "tokens_completion": 30, "completion_eval_sec": 0.780164496, "tokens_total": 1002, "tokens_per_sec": 556.4605261485401, "retrieval_latency_sec": 0.11124086380004883, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL uses a subquery to exclude 'Foundation' products linked to ingredients sourced from 'USA' via a join between cosmetics and ingredient_sourcing. The Generated SQL incorrectly references 'sourcing_country' directly from the cosmetics table (which doesn't contain this column) and lacks the necessary join logic. Additionally, the Generated SQL selects different columns (product_name, consumer_preference_score) compared to the Reference SQL's SELECT *.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query is technically correct and aligns with the business intent. It properly joins the cosmetics and ingredient_sourcing tables to exclude foundations with ingredients sourced from the USA. The generated query contains a critical error: it references a non-existent 'sourcing_country' column in the cosmetics table. The business intent to exclude USA-sourced products is fulfilled by the reference query through its logical exclusion of products linked to USA-sourced ingredients, while the generated query fails syntactically and semantically.", "overall_assessment": "correct"}}
{"example_id": 5620, "sql_complexity": "basic SQL", "prompt": "What is the recycling rate of plastic in the residential sector in the state of New York?", "context": "CREATE TABLE recycling_rates_city (sector VARCHAR(20), city VARCHAR(20), material VARCHAR(20), recycling_rate DECIMAL(5,2)); INSERT INTO recycling_rates_city (sector, city, material, recycling_rate) VALUES ('residential', 'New York City', 'plastic', 0.25), ('commercial', 'New York City', 'plastic', 0.30), ('residential', 'New York City', 'paper', 0.45), ('commercial', 'New York City', 'paper', 0.50), ('residential', 'Los Angeles', 'plastic', 0.20), ('commercial', 'Los Angeles', 'plastic', 0.35), ('residential', 'Los Angeles', 'paper', 0.40), ('commercial', 'Los Angeles', 'paper', 0.50);", "reference_sql": "SELECT recycling_rate FROM recycling_rates_city WHERE sector = 'residential' AND material = 'plastic' AND city = 'New York City';", "generated_sql": "SELECT recycling_rate \nFROM recycling_rates_city \nWHERE sector = 'residential' \nAND city = 'New York City' \nAND material = 'plastic';", "raw_model_output": "```sql\nSELECT recycling_rate \nFROM recycling_rates_city \nWHERE sector = 'residential' \nAND city = 'New York City' \nAND material = 'plastic';\n```", "latency_sec": 1.6123569011688232, "total_duration_sec": 1.389936864, "load_duration_sec": 0.015348492, "tokens_prompt": 1045, "prompt_eval_sec": 0.401919257, "tokens_completion": 38, "completion_eval_sec": 0.96866344, "tokens_total": 1083, "tokens_per_sec": 671.6875148516535, "retrieval_latency_sec": 0.10789299011230469, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select the same column ('recycling_rate') from the same table ('recycling_rates_city') and apply identical WHERE conditions (sector = 'residential', city = 'New York City', material = 'plastic'). The order of conditions in the WHERE clause does not affect the result set.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are structurally identical in terms of logic and conditions. The order of conditions in the WHERE clause does not affect SQL execution or results. Both correctly filter for 'residential' sector, 'plastic' material, and 'New York City' to retrieve the recycling rate. The generated query's slightly different condition ordering does not impact correctness or efficiency. Both queries directly address the business question by isolating the specific metric requested.", "overall_assessment": "correct"}}
{"example_id": 3151, "sql_complexity": "basic SQL", "prompt": "List all biotech startups that received funding in 2022 and their respective funding amounts.", "context": "CREATE TABLE biotech_startups (name TEXT, funding FLOAT, date DATE); INSERT INTO biotech_startups (name, funding, date) VALUES ('StartupA', 3500000, '2022-02-28'); INSERT INTO biotech_startups (name, funding, date) VALUES ('StartupB', 4500000, '2022-07-12');", "reference_sql": "SELECT name, funding FROM biotech_startups WHERE date BETWEEN '2022-01-01' AND '2022-12-31';", "generated_sql": "SELECT name, funding \nFROM biotech_startups \nWHERE date BETWEEN '2022-01-01' AND '2022-12-31';", "raw_model_output": "```sql\nSELECT name, funding \nFROM biotech_startups \nWHERE date BETWEEN '2022-01-01' AND '2022-12-31';\n```", "latency_sec": 1.513796091079712, "total_duration_sec": 1.453298823, "load_duration_sec": 0.01579934, "tokens_prompt": 907, "prompt_eval_sec": 0.352011432, "tokens_completion": 44, "completion_eval_sec": 1.081190969, "tokens_total": 951, "tokens_per_sec": 628.2219947613296, "retrieval_latency_sec": 0.11402702331542969, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. The only differences are whitespace and formatting (line breaks), which do not affect SQL execution. Both select the same columns from the same table with the same WHERE condition using BETWEEN, so they will produce identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure, logic, and output. They select the same columns (name, funding) from the same table, apply the same date filter using BETWEEN '2022-01-01' AND '2022-12-31', and would produce identical results. The slight formatting difference (line breaks) does not affect functionality. Both correctly address the business intent of listing 2022 biotech startup fundings. Neither query is more efficient or elegant than the other as they are functionally identical.", "overall_assessment": "correct"}}
{"example_id": 2136, "sql_complexity": "window functions", "prompt": "What is the total military equipment sales revenue for each sales representative by fiscal year?", "context": "CREATE TABLE SalesReps (SalesRepID INT, SalesRepName VARCHAR(50), FiscalYear INT, Revenue DECIMAL(10,2)); INSERT INTO SalesReps (SalesRepID, SalesRepName, FiscalYear, Revenue) VALUES (1, 'John Doe', 2020, 150000.00), (2, 'Jane Smith', 2020, 200000.00), (1, 'John Doe', 2021, 180000.00), (2, 'Jane Smith', 2021, 250000.00);", "reference_sql": "SELECT SalesRepName, FiscalYear, SUM(Revenue) OVER (PARTITION BY SalesRepName ORDER BY FiscalYear) AS TotalRevenue FROM SalesReps;", "generated_sql": "SELECT SalesRepName, FiscalYear, SUM(Revenue) AS TotalRevenue \nFROM SalesReps \nGROUP BY SalesRepName, FiscalYear;", "raw_model_output": "```sql\nSELECT SalesRepName, FiscalYear, SUM(Revenue) AS TotalRevenue \nFROM SalesReps \nGROUP BY SalesRepName, FiscalYear;\n```", "latency_sec": 1.3728358745574951, "total_duration_sec": 1.193768846, "load_duration_sec": 0.015897811, "tokens_prompt": 810, "prompt_eval_sec": 0.326743689, "tokens_completion": 35, "completion_eval_sec": 0.848069086, "tokens_total": 845, "tokens_per_sec": 615.5142181670974, "retrieval_latency_sec": 0.11276912689208984, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses a window function to calculate a running total of Revenue per SalesRepName ordered by FiscalYear, while the Generated SQL aggregates Revenue by grouping on SalesRepName and FiscalYear. The Reference query produces cumulative sums (e.g., 150000 for 2020, 330000 for 2021 for John Doe), whereas the Generated query returns individual year totals (e.g., 150000 for 2020, 180000 for 2021 for John Doe). The results differ in their calculation logic and output values.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL calculates a running total (cumulative sum) of revenue per sales representative over fiscal years using a window function, while the Generated SQL correctly aggregates revenue by SalesRepName and FiscalYear using GROUP BY. The original question requires total revenue per sales rep per fiscal year, not a cumulative sum. The Reference query would produce incorrect results if there are multiple entries per sales rep in the same fiscal year, whereas the Generated query properly groups and sums revenues for each distinct sales rep-year combination.", "overall_assessment": "incorrect"}}
{"example_id": 5452, "sql_complexity": "basic SQL", "prompt": "What is the name of the farms with a size greater than 150 acres located in 'Texas'?", "context": "CREATE TABLE farms (id INT PRIMARY KEY, name VARCHAR(50), size INT, location VARCHAR(50)); INSERT INTO farms (id, name, size, location) VALUES (1, 'Smith Farms', 200, 'Texas'), (2, 'Johnson Farms', 100, 'California');", "reference_sql": "SELECT name FROM farms WHERE size > 150 AND location = 'Texas'", "generated_sql": "SELECT name FROM farms WHERE size > 150 AND location = 'Texas';", "raw_model_output": "```sql\nSELECT name FROM farms WHERE size > 150 AND location = 'Texas';\n```", "latency_sec": 1.3467729091644287, "total_duration_sec": 1.02584285, "load_duration_sec": 0.019969456, "tokens_prompt": 1029, "prompt_eval_sec": 0.400876484, "tokens_completion": 22, "completion_eval_sec": 0.601366042, "tokens_total": 1051, "tokens_per_sec": 780.3839777650907, "retrieval_latency_sec": 0.11231207847595215, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the 'name' column from the 'farms' table with identical WHERE conditions (size > 150 AND location = 'Texas'). The only difference is the presence of a semicolon at the end of the generated SQL, which does not affect query semantics.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "The reference and generated queries are identical in structure, syntax, and logic. Both correctly filter farms with size > 150 acres located in 'Texas' by using the same WHERE clause conditions. The sample data contains one matching record ('Smith Farms'), which both queries would return. The queries are equally efficient, elegant, and semantically equivalent. No differences exist in how they address the business question.", "overall_assessment": "correct"}}
{"example_id": 5152, "sql_complexity": "aggregation", "prompt": "How many international tourists visited Portugal in 2020, broken down by continent?", "context": "CREATE TABLE international_tourists(tourist_id INT, country TEXT, arrival_year INT, continent TEXT);INSERT INTO international_tourists (tourist_id, country, arrival_year, continent) VALUES (1, 'Spain', 2020, 'Europe'), (2, 'France', 2020, 'Europe'), (3, 'Brazil', 2020, 'South America'), (4, 'United States', 2020, 'North America'), (5, 'China', 2020, 'Asia');", "reference_sql": "SELECT continent, COUNT(*) FROM international_tourists WHERE arrival_year = 2020 GROUP BY continent;", "generated_sql": "SELECT continent, COUNT(*) AS tourist_count \nFROM international_tourists \nWHERE country = 'Portugal' AND arrival_year = 2020 \nGROUP BY continent;", "raw_model_output": "```sql\nSELECT continent, COUNT(*) AS tourist_count \nFROM international_tourists \nWHERE country = 'Portugal' AND arrival_year = 2020 \nGROUP BY continent;\n```", "latency_sec": 1.5533387660980225, "total_duration_sec": 1.39596086, "load_duration_sec": 0.016229943, "tokens_prompt": 926, "prompt_eval_sec": 0.363753127, "tokens_completion": 41, "completion_eval_sec": 1.011823354, "tokens_total": 967, "tokens_per_sec": 622.5300115499583, "retrieval_latency_sec": 0.11150622367858887, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query counts all tourists from 2020 grouped by continent, while the generated query adds a filter for 'country = 'Portugal'', which doesn't exist in the data. This makes the generated query return no rows, whereas the reference query returns counts for all continents. The additional condition changes the result set entirely.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly counts all international tourists who arrived in 2020, grouped by continent. The Generated SQL incorrectly filters for tourists whose 'country' is 'Portugal' (which would be locals, not international visitors), and the schema implies 'country' refers to the tourist's origin, not destination. Neither query explicitly references Portugal as the destination, but the Reference SQL aligns with the implicit assumption that the table contains data about tourists visiting Portugal. The Generated SQL fails to address the actual question by filtering on the wrong column.", "overall_assessment": "incorrect"}}
{"example_id": 2477, "sql_complexity": "set operations", "prompt": "What is the carbon price in Europe and Australia for the last quarter of 2020?", "context": "CREATE TABLE CarbonPrices (Country TEXT, Year INT, Quarter INT, CarbonPrice NUMBER); INSERT INTO CarbonPrices (Country, Year, Quarter, CarbonPrice) VALUES ('Europe', 2020, 4, 25), ('Australia', 2020, 4, 15); CREATE TABLE CarbonTaxes (Country TEXT, Year INT, Quarter INT, CarbonPrice NUMBER); INSERT INTO CarbonTaxes (Country, Year, Quarter, CarbonPrice) VALUES ('Europe', 2019, 4, 20), ('Australia', 2019, 4, 10);", "reference_sql": "SELECT Context.Country, Context.CarbonPrice FROM ( SELECT * FROM CarbonPrices WHERE CarbonPrices.Country IN ('Europe', 'Australia') AND CarbonPrices.Year = 2020 AND CarbonPrices.Quarter = 4 UNION SELECT * FROM CarbonTaxes WHERE CarbonTaxes.Country IN ('Europe', 'Australia') AND CarbonTaxes.Year = 2020 AND CarbonTaxes.Quarter = 4 ) AS Context;", "generated_sql": "SELECT Country, CarbonPrice \nFROM CarbonPrices \nWHERE Year = 2020 AND Quarter = 4;", "raw_model_output": "```sql\nSELECT Country, CarbonPrice \nFROM CarbonPrices \nWHERE Year = 2020 AND Quarter = 4;\n```", "latency_sec": 1.111449956893921, "total_duration_sec": 1.049999688, "load_duration_sec": 0.014185035, "tokens_prompt": 823, "prompt_eval_sec": 0.330199103, "tokens_completion": 29, "completion_eval_sec": 0.701596986, "tokens_total": 852, "tokens_per_sec": 766.5662270400508, "retrieval_latency_sec": 0.11462593078613281, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL combines data from both CarbonPrices and CarbonTaxes tables with specific filters on Country, Year, and Quarter, while the Generated SQL only queries the CarbonPrices table without the Country filter. The Generated SQL misses the UNION with CarbonTaxes and the Country IN clause, leading to different result sets.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries return the correct carbon prices for Europe and Australia in Q4 2020. The reference query uses an unnecessary UNION with CarbonTaxes table, which contains no data for 2020 Q4 (only 2019 Q4 exists). The generated query directly accesses the CarbonPrices table, which contains the relevant data. While technically equivalent due to the empty CarbonTaxes result, the generated query is more efficient, simpler, and directly addresses the business intent of retrieving carbon prices (not carbon taxes).", "overall_assessment": "correct"}}
{"example_id": 4573, "sql_complexity": "subqueries", "prompt": "Find the names of all the indigenous communities in the 'Arctic_Communities' table that have a population size greater than the average population size in the 'Antarctic_Communities' table.", "context": "CREATE TABLE Arctic_Communities (name TEXT, population INTEGER); CREATE TABLE Antarctic_Communities (name TEXT, population INTEGER);", "reference_sql": "SELECT name FROM Arctic_Communities WHERE Arctic_Communities.population > (SELECT AVG(population) FROM Antarctic_Communities)", "generated_sql": "SELECT name \nFROM Arctic_Communities \nWHERE population > (SELECT AVG(population) FROM Antarctic_Communities);", "raw_model_output": "```sql\nSELECT name \nFROM Arctic_Communities \nWHERE population > (SELECT AVG(population) FROM Antarctic_Communities);\n```", "latency_sec": 0.9856739044189453, "total_duration_sec": 0.919268887, "load_duration_sec": 0.013887919, "tokens_prompt": 644, "prompt_eval_sec": 0.288952064, "tokens_completion": 27, "completion_eval_sec": 0.612437122, "tokens_total": 671, "tokens_per_sec": 680.7525257509525, "retrieval_latency_sec": 0.11557626724243164, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select names from Arctic_Communities where population exceeds the average population of Antarctic_Communities. The generated query omits the table name in the WHERE clause, but since 'population' is unambiguous (only exists in Arctic_Communities), the semantic meaning remains identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent as they produce identical results by correctly comparing Arctic_Communities' population to the average population from Antarctic_Communities. The reference query explicitly qualifies the population column with the table name, while the generated query relies on context from the FROM clause. Both correctly address the business intent by identifying Arctic communities exceeding the Antarctic average. The generated query is slightly more concise but neither demonstrates superior efficiency or elegance. The semantic equivalence is confirmed by identical logical structure and output.", "overall_assessment": "correct"}}
{"example_id": 3596, "sql_complexity": "window functions", "prompt": "What is the total revenue for each game in the \"Gaming\" category?", "context": "CREATE TABLE Games (GameID int, GameName varchar(50), Category varchar(50), Revenue decimal(10,2));", "reference_sql": "SELECT Category, SUM(Revenue) OVER(PARTITION BY Category) as TotalRevenue FROM Games;", "generated_sql": "SELECT GameName, SUM(Revenue) AS TotalRevenue \nFROM Games \nWHERE Category = 'Gaming' \nGROUP BY GameName;", "raw_model_output": "```sql\nSELECT GameName, SUM(Revenue) AS TotalRevenue \nFROM Games \nWHERE Category = 'Gaming' \nGROUP BY GameName;\n```", "latency_sec": 1.346642017364502, "total_duration_sec": 1.151273889, "load_duration_sec": 0.020018447, "tokens_prompt": 815, "prompt_eval_sec": 0.329449453, "tokens_completion": 33, "completion_eval_sec": 0.793897851, "tokens_total": 848, "tokens_per_sec": 629.7144965516607, "retrieval_latency_sec": 0.11040711402893066, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates the total revenue per category for each row using a window function, while the generated query filters to only 'Gaming' category, groups by GameName, and sums revenue per game. Differences include: 1) Column selection (Category vs GameName), 2) Filtering to a specific category, 3) Aggregation scope (category-wide vs per-game), and 4) Output structure.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL calculates total revenue per category (not per game) using a window function, which would return the same category total for every row. The Generated SQL correctly filters for 'Gaming' and groups by GameName to calculate per-game revenue. However, neither query perfectly matches the ambiguous question: if 'total revenue for each game' means individual game revenue (not aggregated), both are incorrect. But the Generated SQL better aligns with the intent to break down revenue by game within the Gaming category.", "overall_assessment": "differently_correct"}}
{"example_id": 5039, "sql_complexity": "subqueries", "prompt": "What is the total number of community policing events in 'City Park' in 2021?", "context": "CREATE TABLE locations (id INT, name VARCHAR(255)); CREATE TABLE community_policing (id INT, location_id INT, year INT, events INT); INSERT INTO locations (id, name) VALUES (1, 'City Park'); INSERT INTO community_policing (id, location_id, year, events) VALUES (1, 1, 2021, 5);", "reference_sql": "SELECT SUM(events) FROM community_policing WHERE location_id = (SELECT id FROM locations WHERE name = 'City Park') AND year = 2021;", "generated_sql": "SELECT l.name, SUM(cp.events) \nFROM locations l \nJOIN community_policing cp ON l.id = cp.location_id \nWHERE l.name = 'City Park' AND cp.year = 2021;", "raw_model_output": "```sql\nSELECT l.name, SUM(cp.events) \nFROM locations l \nJOIN community_policing cp ON l.id = cp.location_id \nWHERE l.name = 'City Park' AND cp.year = 2021;\n```", "latency_sec": 1.6089520454406738, "total_duration_sec": 1.51392202, "load_duration_sec": 0.017187046, "tokens_prompt": 797, "prompt_eval_sec": 0.319145181, "tokens_completion": 50, "completion_eval_sec": 1.172938325, "tokens_total": 847, "tokens_per_sec": 526.4296113735423, "retrieval_latency_sec": 0.10802102088928223, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL returns only the sum of events (one column), while the Generated SQL returns two columns (location name and sum of events). Additionally, the Generated SQL's JOIN structure could return multiple rows if there are multiple matching entries, though in this specific dataset they would produce the same sum value. However, the result set structure differs, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries correctly calculate the total community policing events in 'City Park' for 2021. The reference query uses a subquery to directly obtain the location_id and sums events, while the generated query uses a JOIN and filters on the location name. Technically, they produce identical results. However, the reference query is more efficient as it avoids unnecessary JOIN operations and directly targets the required value. The generated query includes an extra column (l.name) in the output, which is not required by the question. Both fulfill the business intent, but the reference query is more elegant and optimized.", "overall_assessment": "correct"}}
{"example_id": 2724, "sql_complexity": "basic SQL", "prompt": "What is the earliest installation date for solar panels in Italy?", "context": "CREATE TABLE solar_panels_italy (id INT, installation_date DATE); INSERT INTO solar_panels_italy (id, installation_date) VALUES (1, '2018-01-01'), (2, '2019-01-01'), (3, '2020-01-01');", "reference_sql": "SELECT MIN(installation_date) as earliest_date FROM solar_panels_italy;", "generated_sql": "SELECT MIN(installation_date) FROM solar_panels_italy;", "raw_model_output": "```sql\nSELECT MIN(installation_date) FROM solar_panels_italy;\n```", "latency_sec": 0.8287558555603027, "total_duration_sec": 0.815998822, "load_duration_sec": 0.016969821, "tokens_prompt": 754, "prompt_eval_sec": 0.313622781, "tokens_completion": 20, "completion_eval_sec": 0.481664923, "tokens_total": 774, "tokens_per_sec": 933.9300528702948, "retrieval_latency_sec": 0.12300896644592285, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the minimum installation_date from the solar_panels_italy table. The only difference is the alias 'earliest_date' in the reference query, which does not affect the semantic result. The generated query omits the alias but returns the same value.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly retrieve the earliest installation date using MIN(installation_date). The reference query adds an alias ('earliest_date') which improves readability but doesn't affect functionality. The generated query is technically equivalent but more concise. Both fulfill the business intent of finding the earliest date. The generated query is slightly more elegant due to its brevity without sacrificing clarity.", "overall_assessment": "correct"}}
{"example_id": 2200, "sql_complexity": "single join", "prompt": "Which diversity programs are currently being participated in by employees in the HR department?", "context": "CREATE TABLE Employees (Employee_ID INT, First_Name VARCHAR(20), Last_Name VARCHAR(20), Department VARCHAR(20), Salary DECIMAL(10,2), Date_Hired DATE); CREATE TABLE Diversity_Programs (Program_ID INT, Program_Name VARCHAR(50), Participant_ID INT, Date_Started DATE, Date_Ended DATE);", "reference_sql": "SELECT dp.Program_Name FROM Diversity_Programs dp JOIN Employees e ON dp.Participant_ID = e.Employee_ID WHERE e.Department = 'HR' AND dp.Date_Ended IS NULL;", "generated_sql": "SELECT Program_Name \nFROM Diversity_Programs \nWHERE Participant_ID IN (\n    SELECT Employee_ID \n    FROM Employees \n    WHERE Department = 'HR'\n) \nAND Date_Ended IS NULL;", "raw_model_output": "```sql\nSELECT Program_Name \nFROM Diversity_Programs \nWHERE Participant_ID IN (\n    SELECT Employee_ID \n    FROM Employees \n    WHERE Department = 'HR'\n) \nAND Date_Ended IS NULL;\n```", "latency_sec": 1.7057769298553467, "total_duration_sec": 1.466700667, "load_duration_sec": 0.020671542, "tokens_prompt": 906, "prompt_eval_sec": 0.358269058, "tokens_completion": 44, "completion_eval_sec": 1.081273841, "tokens_total": 950, "tokens_per_sec": 556.9309699132593, "retrieval_latency_sec": 0.11097121238708496, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve Program_Name from Diversity_Programs where the Participant_ID corresponds to an HR department employee and Date_Ended is NULL. The reference uses an INNER JOIN between Employees and Diversity_Programs, while the generated query uses a subquery with IN. Both ensure only HR employees (via Employee_ID) are considered, and the Date_Ended condition is applied in both. The logical outcome is identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly identify active diversity programs involving HR employees by filtering for Department = 'HR' and Date_Ended IS NULL. The reference uses an explicit JOIN between Employees and Diversity_Programs, while the generated query uses a subquery with IN. Both achieve the same result, though the JOIN may be more efficient in some databases due to optimization opportunities. The semantic intent of identifying current HR participation is fully met by both.", "overall_assessment": "correct"}}
{"example_id": 4359, "sql_complexity": "window functions", "prompt": "Which destinations have the least hotel awards?", "context": "CREATE TABLE Destinations (destination_id INT, destination_name TEXT, country TEXT, awards INT); INSERT INTO Destinations (destination_id, destination_name, country, awards) VALUES (1, 'City A', 'Germany', 3), (2, 'City B', 'Switzerland', 5), (3, 'City C', 'Norway', 2);", "reference_sql": "SELECT destination_name, country, awards, RANK() OVER (PARTITION BY country ORDER BY awards ASC) AS rank FROM Destinations;", "generated_sql": "SELECT destination_name, country, awards \nFROM Destinations \nWHERE awards = (SELECT MIN(awards) FROM Destinations);", "raw_model_output": "```sql\nSELECT destination_name, country, awards \nFROM Destinations \nWHERE awards = (SELECT MIN(awards) FROM Destinations);\n```", "latency_sec": 1.3815898895263672, "total_duration_sec": 1.093744775, "load_duration_sec": 0.014030343, "tokens_prompt": 816, "prompt_eval_sec": 0.329098799, "tokens_completion": 31, "completion_eval_sec": 0.745733058, "tokens_total": 847, "tokens_per_sec": 613.0618111937445, "retrieval_latency_sec": 0.10752582550048828, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates ranks within each country partition, while the Generated SQL filters for destinations with the absolute minimum awards in the entire table. The first returns all rows with rank values, the second only returns rows matching the global minimum award count.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query calculates ranks within each country but does not filter for destinations with the least awards, while the generated query explicitly identifies destinations with the minimum awards. The original question asks for destinations with 'the least hotel awards' without specifying country-based grouping, making the generated query more directly aligned with the business intent. The reference query's use of RANK() over partitions introduces unnecessary complexity and may not answer the question as intended. The generated query is more efficient and semantically precise for the given question.", "overall_assessment": "differently_correct"}}
{"example_id": 1373, "sql_complexity": "subqueries", "prompt": "What is the total value of military equipment sales to Africa in the last 12 months?", "context": "CREATE TABLE Military_Equipment_Sales(sale_id INT, sale_date DATE, equipment_type VARCHAR(50), country VARCHAR(50), sale_value DECIMAL(10,2));", "reference_sql": "SELECT SUM(sale_value) FROM Military_Equipment_Sales WHERE country IN (SELECT country FROM World_Countries WHERE continent = 'Africa') AND sale_date >= DATE_SUB(CURRENT_DATE, INTERVAL 12 MONTH);", "generated_sql": "SELECT SUM(sale_value) \nFROM Military_Equipment_Sales \nWHERE country = 'Africa' \nAND sale_date >= DATEADD(year, -1, GETDATE());", "raw_model_output": "```sql\nSELECT SUM(sale_value) \nFROM Military_Equipment_Sales \nWHERE country = 'Africa' \nAND sale_date >= DATEADD(year, -1, GETDATE());\n```", "latency_sec": 1.447328805923462, "total_duration_sec": 1.205533152, "load_duration_sec": 0.015811024, "tokens_prompt": 613, "prompt_eval_sec": 0.280334101, "tokens_completion": 40, "completion_eval_sec": 0.905020405, "tokens_total": 653, "tokens_per_sec": 451.17598525468173, "retrieval_latency_sec": 0.11292409896850586, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. 1) The Reference SQL uses a subquery to select countries from the World_Countries table where continent = 'Africa', while the Generated SQL directly compares the country column to 'Africa'. This would only return sales where the country is explicitly named 'Africa', not all African countries. 2) The date filtering uses different functions (DATE_SUB vs DATEADD) and different date functions (CURRENT_DATE vs GETDATE()). While both aim to get the last 12 months, the exact date calculation might differ depending on the SQL dialect, but the primary issue is the different country filtering logic.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly identifies African countries via a subquery on World_Countries, ensuring accurate continent-based filtering. The generated query incorrectly filters WHERE country = 'Africa' (assuming country names are stored as continent names, which is unlikely). Both handle date ranges similarly, but the generated query uses GETDATE() (SQL Server syntax) vs. CURRENT_DATE (standard SQL). The reference better addresses the business intent of aggregating sales to the entire continent.", "overall_assessment": "incorrect"}}
{"example_id": 904, "sql_complexity": "basic SQL", "prompt": "What is the minimum Shariah-compliant loan amount issued in the last quarter of 2021?", "context": "CREATE TABLE loans (id INT, amount DECIMAL, date DATE, loan_type VARCHAR); INSERT INTO loans (id, amount, date, loan_type) VALUES (1, 5000, '2021-09-05', 'Shariah-compliant'), (2, 7000, '2021-10-07', 'socially responsible'), (3, 9000, '2021-11-03', 'Shariah-compliant'), (4, 11000, '2021-12-31', 'Shariah-compliant');", "reference_sql": "SELECT MIN(amount) FROM loans WHERE EXTRACT(YEAR FROM date) = 2021 AND EXTRACT(QUARTER FROM date) = 4 AND loan_type = 'Shariah-compliant';", "generated_sql": "SELECT MIN(amount) \nFROM loans \nWHERE loan_type = 'Shariah-compliant' \n  AND date BETWEEN '2021-10-01' AND '2021-12-31';", "raw_model_output": "```sql\nSELECT MIN(amount) \nFROM loans \nWHERE loan_type = 'Shariah-compliant' \n  AND date BETWEEN '2021-10-01' AND '2021-12-31';\n```", "latency_sec": 1.9926340579986572, "total_duration_sec": 1.67748291, "load_duration_sec": 0.015878654, "tokens_prompt": 897, "prompt_eval_sec": 0.357108349, "tokens_completion": 54, "completion_eval_sec": 1.300766223, "tokens_total": 951, "tokens_per_sec": 477.2577263660525, "retrieval_latency_sec": 0.11176204681396484, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter 'Shariah-compliant' loans in the fourth quarter of 2021. The reference query uses EXTRACT(QUARTER) = 4, which corresponds to October-December, while the generated query uses a date range from '2021-10-01' to '2021-12-31', covering the same period. Both ensure the same subset of loans is considered, so they produce identical MIN(amount) results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly identify the minimum Shariah-compliant loan amount in Q4 2021. The Reference SQL uses EXTRACT() to explicitly target the 4th quarter, while the Generated SQL uses a date range (2021-10-01 to 2021-12-31) which aligns with Q4. Both approaches filter the same subset of data (Shariah-compliant loans in Q4 2021) and would return the same result (9000). The Generated SQL's date range is more explicit and may be more efficient with indexed date columns, but both are technically valid. Neither query has logical errors, and both fulfill the business intent of finding the minimum loan amount in the specified timeframe.", "overall_assessment": "correct"}}
{"example_id": 3299, "sql_complexity": "set operations", "prompt": "How many schools and hospitals are there in Colombia and which ones need repairs?", "context": "CREATE TABLE schools (id INT, country VARCHAR(20), name VARCHAR(50), needs_repair BOOLEAN); CREATE TABLE hospitals (id INT, country VARCHAR(20), name VARCHAR(50), needs_repair BOOLEAN);", "reference_sql": "SELECT 'Schools' as facility_type, COUNT(*) as total, SUM(needs_repair) as repairs_needed FROM schools WHERE country = 'Colombia' UNION ALL SELECT 'Hospitals' as facility_type, COUNT(*) as total, SUM(needs_repair) as repairs_needed FROM hospitals WHERE country = 'Colombia';", "generated_sql": "SELECT \n    country,\n    COUNT(*) AS total_facilities,\n    STRING_AGG(CASE WHEN needs_repair THEN name ELSE NULL END, ', ') AS facilities_needing_repairs\nFROM \n    (SELECT id, country, name, needs_repair FROM schools WHERE country = 'Colombia'\n     UNION ALL\n     SELECT id, country, name, needs_repair FROM hospitals WHERE country = 'Colombia') AS facilities\nGROUP BY \n    country;", "raw_model_output": "```sql\nSELECT \n    country,\n    COUNT(*) AS total_facilities,\n    STRING_AGG(CASE WHEN needs_repair THEN name ELSE NULL END, ', ') AS facilities_needing_repairs\nFROM \n    (SELECT id, country, name, needs_repair FROM schools WHERE country = 'Colombia'\n     UNION ALL\n     SELECT id, country, name, needs_repair FROM hospitals WHERE country = 'Colombia') AS facilities\nGROUP BY \n    country;\n```", "latency_sec": 2.955228090286255, "total_duration_sec": 2.89754374, "load_duration_sec": 0.025486592, "tokens_prompt": 1126, "prompt_eval_sec": 0.547024624, "tokens_completion": 101, "completion_eval_sec": 2.320490466, "tokens_total": 1227, "tokens_per_sec": 415.19637825354727, "retrieval_latency_sec": 0.12232398986816406, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL returns two rows (Schools and Hospitals) with counts and sum of repairs, while the Generated SQL returns a single row per country with a comma-separated list of facilities needing repairs. The structure, columns, and data types differ significantly between the two queries.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent. The reference query returns separate counts for schools and hospitals with repairs needed (numeric values), while the generated query combines all facilities into a single row, reporting total facilities and a comma-separated list of names needing repairs. The original question requires both (1) separate counts of schools/hospitals and (2) identification of specific facilities needing repairs. The reference query addresses (1) fully but not (2), while the generated query addresses (2) but not (1) correctly (it combines schools and hospitals into a single total). Neither fully fulfills the intent, but the reference is closer to answering the quantitative aspect of the question.", "overall_assessment": "differently_correct"}}
{"example_id": 907, "sql_complexity": "set operations", "prompt": "What is the total quantity of items with type 'E' or type 'F' in warehouse O and warehouse P?", "context": "CREATE TABLE warehouse_o(item_id INT, item_type VARCHAR(10), quantity INT);CREATE TABLE warehouse_p(item_id INT, item_type VARCHAR(10), quantity INT);INSERT INTO warehouse_o(item_id, item_type, quantity) VALUES (1, 'E', 200), (2, 'F', 300), (3, 'E', 50), (4, 'F', 400);INSERT INTO warehouse_p(item_id, item_type, quantity) VALUES (1, 'E', 150), (2, 'F', 250), (3, 'E', 40), (4, 'F', 350);", "reference_sql": "SELECT quantity FROM warehouse_o WHERE item_type IN ('E', 'F') UNION ALL SELECT quantity FROM warehouse_p WHERE item_type IN ('E', 'F');", "generated_sql": "SELECT quantity FROM warehouse_o WHERE item_type IN ('E', 'F') \nUNION ALL \nSELECT quantity FROM warehouse_p WHERE item_type IN ('E', 'F');", "raw_model_output": "```sql\nSELECT quantity FROM warehouse_o WHERE item_type IN ('E', 'F') \nUNION ALL \nSELECT quantity FROM warehouse_p WHERE item_type IN ('E', 'F');\n```", "latency_sec": 1.7036771774291992, "total_duration_sec": 1.436603182, "load_duration_sec": 0.016050187, "tokens_prompt": 1071, "prompt_eval_sec": 0.403970461, "tokens_completion": 40, "completion_eval_sec": 1.012663653, "tokens_total": 1111, "tokens_per_sec": 652.1188489925466, "retrieval_latency_sec": 0.11013007164001465, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. The only difference is formatting (line breaks and whitespace), which does not affect semantic equivalence. Both select quantities from both tables where item_type is 'E' or 'F', using UNION ALL to combine results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": false, "superiority": "equal", "explanation": "The queries are technically identical (same syntax, logic, and output structure). However, they do not fulfill the business intent because they return individual quantities instead of aggregating them. The original question asks for a 'total quantity,' but the queries simply list quantities from both warehouses. Neither query uses SUM() or combines results into a single total value, making them incorrect for the stated purpose.", "overall_assessment": "incorrect"}}
{"example_id": 1400, "sql_complexity": "single join", "prompt": "What is the maximum co-ownership duration for properties in the neighborhood of 'Chinatown' in San Francisco?'", "context": "CREATE TABLE sf_neighborhoods (neighborhood_id INT, name VARCHAR(255), city VARCHAR(255)); INSERT INTO sf_neighborhoods (neighborhood_id, name, city) VALUES (1, 'Chinatown', 'San Francisco'); CREATE TABLE co_ownership (co_ownership_id INT, property_id INT, co_owner_id INT, start_date DATE, end_date DATE); INSERT INTO co_ownership (co_ownership_id, property_id, co_owner_id, start_date, end_date) VALUES (1, 1, 2, '2010-01-01', '2020-01-01'), (2, 2, 3, '2015-01-01', '2022-01-01'); CREATE TABLE properties (property_id INT, city VARCHAR(255)); INSERT INTO properties (property_id, city) VALUES (1, 'San Francisco'), (2, 'San Francisco');", "reference_sql": "SELECT MAX(DATEDIFF(end_date, start_date)) as max_duration FROM co_ownership JOIN properties ON co_ownership.property_id = properties.property_id WHERE properties.city = 'San Francisco' AND name = 'Chinatown';", "generated_sql": "SELECT MAX(DATEDIFF(end_date, start_date)) AS max_co_ownership_duration\nFROM co_ownership\nJOIN properties ON co_ownership.property_id = properties.property_id\nJOIN sf_neighborhoods ON properties.city = sf_neighborhoods.city\nWHERE sf_neighborhoods.name = 'Chinatown' AND sf_neighborhoods.city = 'San Francisco';", "raw_model_output": "```sql\nSELECT MAX(DATEDIFF(end_date, start_date)) AS max_co_ownership_duration\nFROM co_ownership\nJOIN properties ON co_ownership.property_id = properties.property_id\nJOIN sf_neighborhoods ON properties.city = sf_neighborhoods.city\nWHERE sf_neighborhoods.name = 'Chinatown' AND sf_neighborhoods.city = 'San Francisco';\n```", "latency_sec": 2.371774911880493, "total_duration_sec": 2.307660066, "load_duration_sec": 0.015971149, "tokens_prompt": 1005, "prompt_eval_sec": 0.386799665, "tokens_completion": 79, "completion_eval_sec": 1.900788567, "tokens_total": 1084, "tokens_per_sec": 457.04168408651236, "retrieval_latency_sec": 0.11059713363647461, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references a 'name' column in the WHERE clause that doesn't exist in the joined tables (properties table lacks 'name', and sf_neighborhoods isn't joined). The Generated SQL correctly joins sf_neighborhoods and filters on its 'name' column. The Reference query would fail due to invalid column reference, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query is technically incorrect because it references 'name' in the WHERE clause without joining with the sf_neighborhoods table, which contains the neighborhood name column. This would result in a syntax error. The generated query correctly joins with sf_neighborhoods on city, properly filters for 'Chinatown' in San Francisco, and calculates the maximum duration. While both queries calculate DATEDIFF correctly, only the generated query addresses the business intent by correctly linking properties to their neighborhoods.", "overall_assessment": "incorrect"}}
{"example_id": 5248, "sql_complexity": "window functions", "prompt": "Find the top 5 games by rating", "context": "CREATE TABLE games (game_id INT PRIMARY KEY, name VARCHAR(50), genre VARCHAR(50), rating DECIMAL(3,2));", "reference_sql": "SELECT * FROM (SELECT name, rating, ROW_NUMBER() OVER (ORDER BY rating DESC) as rn FROM games) t WHERE rn <= 5;", "generated_sql": "SELECT name, rating \nFROM games \nORDER BY rating DESC \nLIMIT 5;", "raw_model_output": "```sql\nSELECT name, rating \nFROM games \nORDER BY rating DESC \nLIMIT 5;\n```", "latency_sec": 1.2504189014434814, "total_duration_sec": 0.928216785, "load_duration_sec": 0.016115053, "tokens_prompt": 862, "prompt_eval_sec": 0.347140475, "tokens_completion": 22, "completion_eval_sec": 0.560968221, "tokens_total": 884, "tokens_per_sec": 706.963081715665, "retrieval_latency_sec": 0.11294007301330566, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes an additional 'rn' column from the ROW_NUMBER() function, while the Generated SQL only selects 'name' and 'rating', resulting in different output structures.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly retrieve the top 5 games by rating. The reference query uses ROW_NUMBER() with a subquery to assign ranks, while the generated query uses ORDER BY and LIMIT. Semantically, they produce the same results when there are no ties in the rating column. However, the generated query is more efficient and elegant as it avoids unnecessary complexity. Both fulfill the business intent of identifying top-rated games, but the generated query achieves this with simpler syntax and better performance.", "overall_assessment": "correct"}}
{"example_id": 778, "sql_complexity": "single join", "prompt": "What is the maximum property price in wheelchair-accessible neighborhoods in Singapore?", "context": "CREATE TABLE Singapore_Neighborhoods (Neighborhood_Name TEXT, Wheelchair_Accessibility BOOLEAN); INSERT INTO Singapore_Neighborhoods (Neighborhood_Name, Wheelchair_Accessibility) VALUES ('Orchard', true), ('Marina Bay', true), ('Chinatown', false), ('Little India', false), ('Bugis', true); CREATE TABLE Singapore_Properties (Neighborhood_Name TEXT, Property_Price INTEGER); INSERT INTO Singapore_Properties (Neighborhood_Name, Property_Price) VALUES ('Orchard', 2000000), ('Marina Bay', 3000000), ('Chinatown', 1500000), ('Little India', 1200000), ('Bugis', 1800000);", "reference_sql": "SELECT MAX(Singapore_Properties.Property_Price) FROM Singapore_Properties INNER JOIN Singapore_Neighborhoods ON Singapore_Properties.Neighborhood_Name = Singapore_Neighborhoods.Neighborhood_Name WHERE Singapore_Neighborhoods.Wheelchair_Accessibility = true;", "generated_sql": "SELECT MAX(Property_Price) \nFROM Singapore_Properties \nWHERE Neighborhood_Name IN (\n    SELECT Neighborhood_Name \n    FROM Singapore_Neighborhoods \n    WHERE Wheelchair_Accessibility = true\n);", "raw_model_output": "```sql\nSELECT MAX(Property_Price) \nFROM Singapore_Properties \nWHERE Neighborhood_Name IN (\n    SELECT Neighborhood_Name \n    FROM Singapore_Neighborhoods \n    WHERE Wheelchair_Accessibility = true\n);\n```", "latency_sec": 1.6060571670532227, "total_duration_sec": 1.501020811, "load_duration_sec": 0.023287602, "tokens_prompt": 909, "prompt_eval_sec": 0.361314156, "tokens_completion": 45, "completion_eval_sec": 1.109513194, "tokens_total": 954, "tokens_per_sec": 594.0012719163599, "retrieval_latency_sec": 0.11244606971740723, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the maximum property price from neighborhoods with wheelchair accessibility. The Reference SQL uses an INNER JOIN to combine tables and filter accessible neighborhoods, while the Generated SQL uses a subquery with IN to achieve the same filtering. Both approaches ensure only properties in accessible neighborhoods are considered, resulting in the same maximum value.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly identify the maximum property price in wheelchair-accessible neighborhoods. The reference query uses an explicit INNER JOIN to combine tables and filter accessible neighborhoods, while the generated query uses a subquery with IN to achieve the same result. Semantically, both approaches ensure only properties in neighborhoods with Wheelchair_Accessibility = true are considered. The data shows the correct maximum price (3,000,000) from Marina Bay. Both queries are logically equivalent, efficient, and fulfill the business intent. The choice between them depends on style preferences (JOIN vs. subquery) as neither has a clear technical advantage in this context.", "overall_assessment": "correct"}}
{"example_id": 3859, "sql_complexity": "aggregation", "prompt": "What is the total number of mental health parity violations by month and year?", "context": "CREATE TABLE mental_health_parity_reports (report_id INT, violation_date DATE); INSERT INTO mental_health_parity_reports (report_id, violation_date) VALUES (1, '2022-01-01'), (2, '2022-02-15'), (3, '2022-03-05'), (4, '2022-04-20'), (5, '2021-06-12'), (6, '2021-07-28');", "reference_sql": "SELECT EXTRACT(MONTH FROM violation_date) AS month, EXTRACT(YEAR FROM violation_date) AS year, COUNT(*) FROM mental_health_parity_reports GROUP BY month, year;", "generated_sql": "SELECT \n    EXTRACT(YEAR FROM violation_date) AS year,\n    EXTRACT(MONTH FROM violation_date) AS month,\n    COUNT(*) AS total_violations\nFROM \n    mental_health_parity_reports\nGROUP BY \n    year, month\nORDER BY \n    year, month;", "raw_model_output": "```sql\nSELECT \n    EXTRACT(YEAR FROM violation_date) AS year,\n    EXTRACT(MONTH FROM violation_date) AS month,\n    COUNT(*) AS total_violations\nFROM \n    mental_health_parity_reports\nGROUP BY \n    year, month\nORDER BY \n    year, month;\n```", "latency_sec": 2.058357000350952, "total_duration_sec": 1.824197216, "load_duration_sec": 0.021805271, "tokens_prompt": 698, "prompt_eval_sec": 0.293709021, "tokens_completion": 66, "completion_eval_sec": 1.504345575, "tokens_total": 764, "tokens_per_sec": 371.1698213039512, "retrieval_latency_sec": 0.11518692970275879, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries group by year and month (order of columns in GROUP BY doesn't affect grouping), count violations, and return the same data. The SELECT clause column order differs but doesn't change the result's semantic meaning. The Generated SQL adds an ORDER BY which isn't present in the Reference, but SQL result equivalence typically ignores row order unless explicitly required. The COUNT(*) alias difference (total_violations vs. implicit name) doesn't affect the actual data returned.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly group violations by month and year, count the violations, and return the same results. The reference query uses a simpler structure with implicit column ordering in GROUP BY, while the generated query explicitly aliases columns and adds an ORDER BY clause. The generated query's additional ORDER BY doesn't affect correctness but improves readability. Both satisfy the business intent of aggregating violations by temporal granularity. The difference in column ordering (month/year vs year/month) doesn't impact the grouping logic since the same fields are used.", "overall_assessment": "correct"}}
{"example_id": 3551, "sql_complexity": "multiple_joins", "prompt": "List all artists who have performed in New York and Chicago, along with their highest-earning performance.", "context": "CREATE TABLE artist_events (artist_id INT, event_id INT, earnings DECIMAL(5,2)); CREATE TABLE artists (id INT, name VARCHAR(50)); CREATE TABLE events (id INT, city VARCHAR(20));", "reference_sql": "SELECT artists.name, MAX(artist_events.earnings) FROM artists INNER JOIN artist_events ON artists.id = artist_events.artist_id INNER JOIN events ON artist_events.event_id = events.id WHERE city IN ('New York', 'Chicago') GROUP BY artists.name;", "generated_sql": "SELECT \n    artists.name AS artist_name, \n    MAX(artist_events.earnings) AS highest_earning_performance\nFROM \n    artists\nJOIN \n    artist_events ON artists.id = artist_events.artist_id\nJOIN \n    events ON artist_events.event_id = events.id\nWHERE \n    events.city IN ('New York', 'Chicago')\nGROUP BY \n    artists.name\nHAVING \n    COUNT(DISTINCT events.city) = 2;", "raw_model_output": "```sql\nSELECT \n    artists.name AS artist_name, \n    MAX(artist_events.earnings) AS highest_earning_performance\nFROM \n    artists\nJOIN \n    artist_events ON artists.id = artist_events.artist_id\nJOIN \n    events ON artist_events.event_id = events.id\nWHERE \n    events.city IN ('New York', 'Chicago')\nGROUP BY \n    artists.name\nHAVING \n    COUNT(DISTINCT events.city) = 2;\n```", "latency_sec": 2.82572078704834, "total_duration_sec": 2.568661466, "load_duration_sec": 0.026978057, "tokens_prompt": 776, "prompt_eval_sec": 0.316375126, "tokens_completion": 96, "completion_eval_sec": 2.221591041, "tokens_total": 872, "tokens_per_sec": 308.5938299342251, "retrieval_latency_sec": 0.1098318099975586, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The generated query adds a HAVING clause that requires artists to have events in both 'New York' and 'Chicago' (COUNT(DISTINCT events.city) = 2), while the reference query only filters events to those cities without requiring multiple cities. This makes the generated query more restrictive.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL fails to ensure artists have performed in *both* cities. It simply filters events in either city and groups by artist, potentially including artists with only New York or only Chicago performances. The Generated SQL correctly adds a HAVING clause (COUNT(DISTINCT events.city) = 2) to enforce that artists must have events in *both* cities. While both queries are syntactically correct, only the Generated SQL fulfills the business intent of identifying artists with performances in *both* locations. The HAVING clause ensures semantic accuracy even though it slightly reduces efficiency.", "overall_assessment": "differently_correct"}}
{"example_id": 5168, "sql_complexity": "aggregation", "prompt": "Get the number of renewable energy projects in Australia for each project type.", "context": "CREATE TABLE renewable_projects (id INT PRIMARY KEY, project_name VARCHAR(255), project_location VARCHAR(255), project_type VARCHAR(255), capacity_mw FLOAT);", "reference_sql": "SELECT project_type, COUNT(*) FROM renewable_projects WHERE project_location = 'Australia' GROUP BY project_type;", "generated_sql": "SELECT project_type, COUNT(*) \nFROM renewable_projects \nWHERE project_location = 'Australia' \nGROUP BY project_type;", "raw_model_output": "```sql\nSELECT project_type, COUNT(*) \nFROM renewable_projects \nWHERE project_location = 'Australia' \nGROUP BY project_type;\n```", "latency_sec": 1.2649381160736084, "total_duration_sec": 0.956046579, "load_duration_sec": 0.017036962, "tokens_prompt": 581, "prompt_eval_sec": 0.27905116, "tokens_completion": 29, "completion_eval_sec": 0.656123413, "tokens_total": 610, "tokens_per_sec": 482.23702981885896, "retrieval_latency_sec": 0.1083226203918457, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. The only differences are formatting (line breaks and whitespace) which do not affect SQL execution. Both select project_type and count rows from renewable_projects where project_location is 'Australia', grouped by project_type.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure, logic, and syntax. They both correctly filter for 'Australia' in the project_location column, group by project_type, and count the number of projects per type. The queries are semantically equivalent and would produce identical results. Neither query has any technical issues, and both fully address the business requirement of counting renewable energy projects by type in Australia. The lack of differences means neither is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 4916, "sql_complexity": "aggregation", "prompt": "What is the maximum revenue generated from selling Yttrium in India in the past 3 years?", "context": "CREATE TABLE Yttrium_Sales (id INT PRIMARY KEY, year INT, country VARCHAR(20), quantity INT, price PER_KG); INSERT INTO Yttrium_Sales (id, year, country, quantity, price) VALUES (1, 2019, 'India', 120, 40), (2, 2020, 'India', 130, 45), (3, 2021, 'India', 140, 50), (4, 2019, 'China', 150, 35), (5, 2020, 'China', 160, 40), (6, 2021, 'China', 170, 45);", "reference_sql": "SELECT MAX(quantity * price) FROM Yttrium_Sales WHERE country = 'India' GROUP BY year ORDER BY year DESC LIMIT 3;", "generated_sql": "SELECT MAX(quantity * price) AS max_revenue \nFROM Yttrium_Sales \nWHERE country = 'India' AND year BETWEEN 2019 AND 2021;", "raw_model_output": "```sql\nSELECT MAX(quantity * price) AS max_revenue \nFROM Yttrium_Sales \nWHERE country = 'India' AND year BETWEEN 2019 AND 2021;\n```", "latency_sec": 1.6098289489746094, "total_duration_sec": 1.489408, "load_duration_sec": 0.02217921, "tokens_prompt": 886, "prompt_eval_sec": 0.353204456, "tokens_completion": 45, "completion_eval_sec": 1.109533408, "tokens_total": 931, "tokens_per_sec": 578.3223121891343, "retrieval_latency_sec": 0.1135411262512207, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL groups by year and returns the maximum quantity*price per year (3 rows), while the Generated SQL calculates a single maximum value across all years. The Reference SQL also orders results and limits to 3 rows, which the Generated SQL lacks. The aggregation logic and output structure differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query groups by year and returns the maximum revenue per year, then orders and limits to 3 rows. This approach would return multiple values (one per year) rather than a single maximum revenue value. The generated query correctly calculates the absolute maximum revenue across all sales in India within the specified 3-year window (2019-2021). The reference query's use of GROUP BY and LIMIT 3 misaligns with the business intent of finding the single highest revenue value. The generated query directly addresses the question by computing the maximum of quantity * price in the relevant timeframe.", "overall_assessment": "differently_correct"}}
{"example_id": 812, "sql_complexity": "multiple_joins", "prompt": "What is the average salary of 'engineer' workers in each factory?", "context": "CREATE TABLE factories (factory_id INT, factory_name VARCHAR(20)); INSERT INTO factories VALUES (1, 'Factory X'), (2, 'Factory Y'), (3, 'Factory Z'); CREATE TABLE roles (role_id INT, role_name VARCHAR(20)); INSERT INTO roles VALUES (1, 'engineer'), (2, 'manager'), (3, 'assistant'); CREATE TABLE workers (worker_id INT, factory_id INT, role_id INT, salary DECIMAL(5,2)); INSERT INTO workers VALUES (1, 1, 1, 50000.00), (2, 1, 2, 70000.00), (3, 2, 1, 55000.00), (4, 2, 3, 40000.00), (5, 3, 1, 60000.00);", "reference_sql": "SELECT f.factory_name, AVG(salary) FROM workers w INNER JOIN factories f ON w.factory_id = f.factory_id INNER JOIN roles r ON w.role_id = r.role_id WHERE r.role_name = 'engineer' GROUP BY f.factory_name;", "generated_sql": "SELECT f.factory_name, AVG(w.salary) AS avg_salary \nFROM factories f \nJOIN workers w ON f.factory_id = w.factory_id \nJOIN roles r ON w.role_id = r.role_id \nWHERE r.role_name = 'engineer' \nGROUP BY f.factory_name;", "raw_model_output": "```sql\nSELECT f.factory_name, AVG(w.salary) AS avg_salary \nFROM factories f \nJOIN workers w ON f.factory_id = w.factory_id \nJOIN roles r ON w.role_id = r.role_id \nWHERE r.role_name = 'engineer' \nGROUP BY f.factory_name;\n```", "latency_sec": 2.0621588230133057, "total_duration_sec": 1.844963191, "load_duration_sec": 0.021363806, "tokens_prompt": 853, "prompt_eval_sec": 0.346395614, "tokens_completion": 62, "completion_eval_sec": 1.470015566, "tokens_total": 915, "tokens_per_sec": 443.7097617258048, "retrieval_latency_sec": 0.11142706871032715, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the average salary per factory for workers with the 'engineer' role. They use identical table joins (factories, workers, roles) with the same conditions, filter on 'engineer' role, and group by factory name. The differences are syntactic (e.g., explicit INNER JOIN vs JOIN, table aliases) and do not affect the result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically correct and produce identical results. They join the same tables (factories, workers, roles), filter for 'engineer' roles, and calculate average salaries per factory. The key difference is that the generated query explicitly aliases the computed average as 'avg_salary', improving readability and clarity. While the reference query omits the alias, this does not affect the result. Both fulfill the business intent of calculating average engineer salaries per factory. The generated query is slightly more elegant due to the explicit alias.", "overall_assessment": "correct"}}
{"example_id": 5784, "sql_complexity": "set operations", "prompt": "List the number of users who have completed a workout of a specific type (e.g. Running) and have a membership status of 'Active'.", "context": "CREATE TABLE workouts (id INT, user_id INT, workout_type VARCHAR(20)); CREATE TABLE members (id INT, name VARCHAR(50), membership_status VARCHAR(20), state VARCHAR(20)); INSERT INTO workouts (id, user_id, workout_type) VALUES (1, 1, 'Running'), (2, 1, 'Cycling'), (3, 2, 'Running'), (4, 3, 'Cycling'), (5, 3, 'Swimming'), (6, 4, 'Running'), (7, 4, 'Swimming'); INSERT INTO members (id, name, membership_status, state) VALUES (1, 'John Doe', 'Active', 'Texas'), (2, 'Jane Doe', 'Inactive', 'California'), (3, 'Bob Smith', 'Active', 'Texas'), (4, 'Alice Johnson', 'Active', 'California');", "reference_sql": "SELECT COUNT(*) FROM (SELECT user_id FROM workouts WHERE workout_type = 'Running' INTERSECT SELECT id FROM members WHERE membership_status = 'Active') AS user_set;", "generated_sql": "SELECT COUNT(*) \nFROM (\n    SELECT DISTINCT w.user_id \n    FROM workouts w \n    JOIN members m ON w.user_id = m.id \n    WHERE w.workout_type = 'Running' AND m.membership_status = 'Active'\n) AS active_running_users;", "raw_model_output": "```sql\nSELECT COUNT(*) \nFROM (\n    SELECT DISTINCT w.user_id \n    FROM workouts w \n    JOIN members m ON w.user_id = m.id \n    WHERE w.workout_type = 'Running' AND m.membership_status = 'Active'\n) AS active_running_users;\n```", "latency_sec": 2.0617711544036865, "total_duration_sec": 2.017150722, "load_duration_sec": 0.01607494, "tokens_prompt": 1220, "prompt_eval_sec": 0.575049156, "tokens_completion": 60, "completion_eval_sec": 1.42162338, "tokens_total": 1280, "tokens_per_sec": 620.8254477060073, "retrieval_latency_sec": 0.11822223663330078, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count users who have at least one 'Running' workout and are active members. The Reference SQL uses INTERSECT to find common user_ids between workouts and active members, while the Generated SQL uses a JOIN with DISTINCT to achieve the same result. Both approaches ensure uniqueness and filter the same conditions, producing identical counts.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count users with 'Running' workouts and 'Active' membership. The reference query uses INTERSECT to find overlapping user_ids between two subqueries, while the generated query uses an explicit JOIN with DISTINCT to achieve the same result. The generated query is more efficient and readable, as it avoids the INTERSECT operation and directly joins relevant tables. Both handle duplicates (INTERSECT inherently de-duplicates, while the generated query uses DISTINCT). The generated query better aligns with standard SQL practices for this type of relationship.", "overall_assessment": "correct"}}
{"example_id": 3038, "sql_complexity": "subqueries", "prompt": "What is the total assets of clients who have invested in mutual funds but not in stocks?", "context": "CREATE TABLE clients (client_id INT, name TEXT, age INT, gender TEXT, total_assets DECIMAL(10,2)); INSERT INTO clients VALUES (1, 'John Doe', 35, 'Male', 250000.00), (2, 'Jane Smith', 45, 'Female', 500000.00); CREATE TABLE investments (client_id INT, investment_type TEXT); INSERT INTO investments VALUES (1, 'Stocks'), (1, 'Bonds'), (2, 'Stocks'), (3, 'Mutual Funds');", "reference_sql": "SELECT c.total_assets FROM clients c INNER JOIN investments i ON c.client_id = i.client_id WHERE i.investment_type = 'Mutual Funds' AND c.client_id NOT IN (SELECT client_id FROM investments WHERE investment_type = 'Stocks');", "generated_sql": "SELECT SUM(c.total_assets) \nFROM clients c \nWHERE c.client_id IN (\n    SELECT i.client_id \n    FROM investments i \n    WHERE i.investment_type = 'Mutual Funds'\n) \nAND c.client_id NOT IN (\n    SELECT i.client_id \n    FROM investments i \n    WHERE i.investment_type = 'Stocks'\n);", "raw_model_output": "```sql\nSELECT SUM(c.total_assets) \nFROM clients c \nWHERE c.client_id IN (\n    SELECT i.client_id \n    FROM investments i \n    WHERE i.investment_type = 'Mutual Funds'\n) \nAND c.client_id NOT IN (\n    SELECT i.client_id \n    FROM investments i \n    WHERE i.investment_type = 'Stocks'\n);\n```", "latency_sec": 2.4962570667266846, "total_duration_sec": 2.34382797, "load_duration_sec": 0.02116073, "tokens_prompt": 1117, "prompt_eval_sec": 0.554168768, "tokens_completion": 77, "completion_eval_sec": 1.76340528, "tokens_total": 1194, "tokens_per_sec": 478.31612213147565, "retrieval_latency_sec": 0.11043500900268555, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns individual client assets (multiple rows if applicable), while the Generated SQL aggregates the total_assets using SUM, producing a single numeric result. The semantic difference lies in the aggregation: the first query retrieves raw values, while the second computes a total. Additionally, the Generated SQL's structure with IN/NOT IN clauses may yield different row sets compared to the JOIN-based logic in the Reference SQL.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query returns individual client assets instead of a total, while the generated query correctly uses SUM() to aggregate the total assets. Both queries correctly identify clients with mutual funds and no stocks, but the generated query addresses the explicit request for 'total assets' through aggregation. The reference query would return multiple rows of individual asset values rather than a single total. The generated query is more efficient as it avoids unnecessary joins and directly filters via subqueries.", "overall_assessment": "differently_correct"}}
{"example_id": 1078, "sql_complexity": "basic SQL", "prompt": "What is the maximum and minimum temperature difference between any two Arctic research stations?", "context": "CREATE TABLE arctic_stations (id INT, name TEXT, location TEXT, temperature DECIMAL(5,2)); INSERT INTO arctic_stations (id, name, location, temperature) VALUES (1, 'Station A', 'Greenland', 2.3), (2, 'Station B', 'Canada', -5.2);", "reference_sql": "SELECT a.name as station1, b.name as station2, MAX(ABS(a.temperature - b.temperature)) as temp_diff FROM arctic_stations a, arctic_stations b ORDER BY temp_diff DESC LIMIT 1", "generated_sql": "SELECT \n    MAX(ABS(a.temperature - b.temperature)) AS max_temperature_difference,\n    MIN(ABS(a.temperature - b.temperature)) AS min_temperature_difference\nFROM \n    arctic_stations a, arctic_stations b\nWHERE \n    a.id <> b.id;", "raw_model_output": "To find the maximum and minimum temperature difference between any two Arctic research stations, we need to calculate the absolute differences between each pair of station temperatures and then determine the maximum and minimum of these differences.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT \n    MAX(ABS(a.temperature - b.temperature)) AS max_temperature_difference,\n    MIN(ABS(a.temperature - b.temperature)) AS min_temperature_difference\nFROM \n    arctic_stations a, arctic_stations b\nWHERE \n    a.id <> b.id;\n```\n\nExplanation:\n- We use a self-join on the `arctic_stations` table to compare each station with every other station.\n- The condition `a.id <> b.id` ensures that we do not compare a station with itself.\n- We calculate the absolute difference in temperatures between each pair of stations using `ABS(a.temperature - b.temperature)`.\n- Finally, we use `MAX()` and `MIN()` to find the maximum and minimum temperature differences.", "latency_sec": 5.396650075912476, "total_duration_sec": 5.076079328, "load_duration_sec": 0.022695897, "tokens_prompt": 810, "prompt_eval_sec": 0.329406577, "tokens_completion": 202, "completion_eval_sec": 4.718707694, "tokens_total": 1012, "tokens_per_sec": 187.5237389426049, "retrieval_latency_sec": 0.11269307136535645, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL returns the single pair of stations with the maximum temperature difference, including station names and the max difference. The Generated SQL calculates both the maximum and minimum temperature differences across all station pairs (excluding same-station comparisons) but does not return station names. Additionally, the Reference SQL implicitly includes same-station pairs (which have 0 difference) in its Cartesian product, while the Generated SQL explicitly excludes them. The result structures and outputs differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query only returns the maximum temperature difference (via ORDER BY + LIMIT 1) but not the minimum, while the generated query explicitly calculates both MAX and MIN. The generated query also includes a WHERE a.id <> b.id condition to avoid comparing stations with themselves, which the reference query lacks. Although both use self-joins, the generated query directly addresses the dual requirement of the question, while the reference query only partially fulfills it. The generated query is more efficient as it computes both values in a single pass.", "overall_assessment": "differently_correct"}}
{"example_id": 5015, "sql_complexity": "basic SQL", "prompt": "Calculate the average recycling rate", "context": "CREATE TABLE recycling_rates (id INT PRIMARY KEY, location VARCHAR(50), rate FLOAT);", "reference_sql": "SELECT AVG(rate) FROM recycling_rates;", "generated_sql": "SELECT AVG(rate) AS average_recycling_rate FROM recycling_rates;", "raw_model_output": "```sql\nSELECT AVG(rate) AS average_recycling_rate FROM recycling_rates;\n```", "latency_sec": 0.803429126739502, "total_duration_sec": 0.769515968, "load_duration_sec": 0.023585422, "tokens_prompt": 732, "prompt_eval_sec": 0.309557306, "tokens_completion": 18, "completion_eval_sec": 0.429927608, "tokens_total": 750, "tokens_per_sec": 933.4986435501418, "retrieval_latency_sec": 0.11394190788269043, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average of the 'rate' column from the 'recycling_rates' table. The generated query adds an alias ('average_recycling_rate') to the result column, but this does not affect the computed value. The semantic result (the average value) remains identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries calculate the average recycling rate correctly. The reference query returns the average directly, while the generated query adds an alias ('average_recycling_rate') for the result column. Since the original question only asks to 'calculate the average' without specifying output formatting, both approaches are valid. The alias in the generated query improves readability but does not alter the mathematical result. Neither query introduces errors or changes the semantic meaning. Efficiency is identical as both perform the same aggregation operation.", "overall_assessment": "correct"}}
{"example_id": 1533, "sql_complexity": "subqueries", "prompt": "Which programs had the highest volunteer participation rate in the last quarter?", "context": "CREATE TABLE Programs (ProgramID INT, ProgramName TEXT, Budget DECIMAL(10,2), NumVolunteers INT); CREATE TABLE VolunteerEvents (EventID INT, ProgramID INT, EventDate DATE, NumVolunteers INT);", "reference_sql": "SELECT p.ProgramName, COUNT(v.EventID) / (SELECT COUNT(*) FROM VolunteerEvents WHERE EventDate >= DATEADD(quarter, -1, GETDATE())) * 100.0 AS VolunteerParticipationRate FROM Programs p INNER JOIN VolunteerEvents v ON p.ProgramID = v.ProgramID WHERE v.EventDate >= DATEADD(quarter, -1, GETDATE()) GROUP BY p.ProgramName ORDER BY VolunteerParticipationRate DESC;", "generated_sql": "SELECT P.ProgramName, (SUM(VE.NumVolunteers) / P.NumVolunteers) * 100 AS ParticipationRate\nFROM Programs P\nJOIN VolunteerEvents VE ON P.ProgramID = VE.ProgramID\nWHERE VE.EventDate >= DATEADD(QUARTER, DATEDIFF(QUARTER, 0, GETDATE()) - 3, 0)\nAND VE.EventDate < DATEADD(QUARTER, DATEDIFF(QUARTER, 0, GETDATE()), 0)\nGROUP BY P.ProgramID, P.ProgramName, P.NumVolunteers\nORDER BY ParticipationRate DESC;", "raw_model_output": "```sql\nSELECT P.ProgramName, (SUM(VE.NumVolunteers) / P.NumVolunteers) * 100 AS ParticipationRate\nFROM Programs P\nJOIN VolunteerEvents VE ON P.ProgramID = VE.ProgramID\nWHERE VE.EventDate >= DATEADD(QUARTER, DATEDIFF(QUARTER, 0, GETDATE()) - 3, 0)\nAND VE.EventDate < DATEADD(QUARTER, DATEDIFF(QUARTER, 0, GETDATE()), 0)\nGROUP BY P.ProgramID, P.ProgramName, P.NumVolunteers\nORDER BY ParticipationRate DESC;\n```", "latency_sec": 3.46244478225708, "total_duration_sec": 3.41421091, "load_duration_sec": 0.015692867, "tokens_prompt": 794, "prompt_eval_sec": 0.315714932, "tokens_completion": 133, "completion_eval_sec": 3.079431659, "tokens_total": 927, "tokens_per_sec": 267.72990135476243, "retrieval_latency_sec": 0.11259818077087402, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in multiple aspects.  The reference query calculates a participation rate based on the count of events, while the generated query uses a sum of volunteers.  The date ranges used for filtering events are different.  Additionally, the denominator in the reference query is the total number of events in the last quarter, while the generated query uses the program's total volunteers.  These differences in calculation and filtering criteria mean the queries will not produce the same results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent. The reference query calculates participation rate as (events per program / total events in last quarter) * 100, while the generated query uses (sum of volunteers in events / program's total volunteers) * 100. The reference query correctly identifies the last quarter using DATEADD(quarter, -1, GETDATE()), whereas the generated query's date logic incorrectly captures the last three quarters. The reference query's calculation aligns with event-based participation rate, while the generated query's approach (if date were correct) would measure volunteer utilization. However, the generated query's date range is flawed, making it technically incorrect. The reference query fulfills the intent of identifying programs with the highest event participation rate, but not volunteer participation rate. Neither query perfectly matches the ambiguous business intent, but the reference is technically correct.", "overall_assessment": "correct"}}
{"example_id": 4021, "sql_complexity": "subqueries", "prompt": "What is the percentage of energy efficiency improvement, per sector, compared to 2015 levels?", "context": "CREATE TABLE energy_efficiency (id INT, sector VARCHAR(50), year INT, efficiency FLOAT); INSERT INTO energy_efficiency (id, sector, year, efficiency) VALUES (1, 'Industry', 2015, 100.0), (2, 'Industry', 2020, 105.0), (3, 'Residential', 2015, 100.0), (4, 'Residential', 2020, 103.0);", "reference_sql": "SELECT sector, (SUM(efficiency) / (SELECT SUM(efficiency) FROM energy_efficiency WHERE year = 2015 AND sector = e.sector) * 100.0) - 100.0 AS improvement FROM energy_efficiency e WHERE year = 2020 GROUP BY sector;", "generated_sql": "SELECT \n    sector,\n    ((MAX(CASE WHEN year = 2020 THEN efficiency END) - MAX(CASE WHEN year = 2015 THEN efficiency END)) / MAX(CASE WHEN year = 2015 THEN efficiency END)) * 100 AS percentage_improvement\nFROM \n    energy_efficiency\nGROUP BY \n    sector;", "raw_model_output": "```sql\nSELECT \n    sector,\n    ((MAX(CASE WHEN year = 2020 THEN efficiency END) - MAX(CASE WHEN year = 2015 THEN efficiency END)) / MAX(CASE WHEN year = 2015 THEN efficiency END)) * 100 AS percentage_improvement\nFROM \n    energy_efficiency\nGROUP BY \n    sector;\n```", "latency_sec": 2.472524881362915, "total_duration_sec": 2.322750129, "load_duration_sec": 0.018513448, "tokens_prompt": 864, "prompt_eval_sec": 0.35192513, "tokens_completion": 83, "completion_eval_sec": 1.948493558, "tokens_total": 947, "tokens_per_sec": 383.009290275773, "retrieval_latency_sec": 0.11238598823547363, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in how they calculate efficiency values. The Reference SQL uses SUM(efficiency) for 2020 and a subquery SUM for 2015, while the Generated SQL uses MAX(CASE WHEN year = 2020 THEN efficiency END) and MAX(CASE WHEN year = 2015 THEN efficiency END). If there are multiple entries per sector/year, SUM vs MAX would produce different results. Even in the sample data, the formulas compute different metrics (ratio of sums vs ratio of maxima).", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries calculate the percentage improvement per sector compared to 2015 levels. The Reference SQL uses SUM with a correlated subquery to compare total efficiency, while the Generated SQL uses conditional aggregation with MAX to directly compare 2020 and 2015 values. In the given dataset (single entry per sector/year), both produce identical results. However, the Generated SQL is more efficient and elegant, avoiding a subquery and explicitly handling year-specific values. The Reference SQL's SUM approach could be problematic if multiple entries exist per sector/year, but the context suggests single entries. Both fulfill the business intent, but the Generated SQL is technically superior.", "overall_assessment": "correct"}}
{"example_id": 1551, "sql_complexity": "single join", "prompt": "How many unique donors made donations in the healthcare industry in Q3 2022?", "context": "CREATE TABLE donations (id INT, donor_id INT, amount FLOAT, donation_date DATE); INSERT INTO donations (id, donor_id, amount, donation_date) VALUES (1, 7, 100, '2022-07-01'); INSERT INTO donations (id, donor_id, amount, donation_date) VALUES (2, 8, 200, '2022-09-15'); INSERT INTO donors (id, name, industry, first_donation_date DATE) VALUES (7, 'Charlie Davis', 'Healthcare', '2022-07-01'); INSERT INTO donors (id, name, industry, first_donation_date DATE) VALUES (8, 'Dana Wilson', 'Healthcare', '2022-09-15');", "reference_sql": "SELECT COUNT(DISTINCT donor_id) FROM donations d JOIN donors don ON d.donor_id = don.id WHERE industry = 'Healthcare' AND donation_date BETWEEN '2022-07-01' AND '2022-09-30';", "generated_sql": "SELECT COUNT(DISTINCT d.donor_id) \nFROM donations d \nJOIN donors dr ON d.donor_id = dr.id \nWHERE dr.industry = 'Healthcare' \nAND d.donation_date BETWEEN '2022-07-01' AND '2022-09-30';", "raw_model_output": "```sql\nSELECT COUNT(DISTINCT d.donor_id) \nFROM donations d \nJOIN donors dr ON d.donor_id = dr.id \nWHERE dr.industry = 'Healthcare' \nAND d.donation_date BETWEEN '2022-07-01' AND '2022-09-30';\n```", "latency_sec": 2.3410329818725586, "total_duration_sec": 2.221361613, "load_duration_sec": 0.023911949, "tokens_prompt": 1031, "prompt_eval_sec": 0.40164003, "tokens_completion": 73, "completion_eval_sec": 1.788003412, "tokens_total": 1104, "tokens_per_sec": 471.5866920921918, "retrieval_latency_sec": 0.10723400115966797, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count distinct donor_ids from donations joined with donors where industry is 'Healthcare' and donation_date is between '2022-07-01' and '2022-09-30'. The only differences are table aliases ('don' vs 'dr') and column qualification (don.industry vs dr.industry), which do not affect the semantic result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly count unique donor_ids from donations joined with donors, filtering for Healthcare industry and Q3 2022 dates. The reference uses 'don' alias while generated uses 'dr', but this doesn't affect results. Both use COUNT(DISTINCT) properly and filter on the correct date range (July-September 2022). The business intent to count unique healthcare donors in Q3 is fully addressed by both queries. The queries are equally efficient and well-structured.", "overall_assessment": "correct"}}
{"example_id": 2592, "sql_complexity": "window functions", "prompt": "What is the third highest account balance for Shariah-compliant finance customers?", "context": "CREATE TABLE shariah_compliant_finance(customer_id INT, account_balance DECIMAL(10, 2)); INSERT INTO shariah_compliant_finance VALUES (1, 5000), (2, 7000), (3, 6000), (4, 8000), (5, 9000);", "reference_sql": "SELECT account_balance FROM (SELECT account_balance, RANK() OVER (ORDER BY account_balance DESC) as rn FROM shariah_compliant_finance) t WHERE rn = 3;", "generated_sql": "SELECT account_balance \nFROM (\n    SELECT account_balance, ROW_NUMBER() OVER (ORDER BY account_balance DESC) AS rn \n    FROM shariah_compliant_finance\n) t \nWHERE rn = 3;", "raw_model_output": "```sql\nSELECT account_balance \nFROM (\n    SELECT account_balance, ROW_NUMBER() OVER (ORDER BY account_balance DESC) AS rn \n    FROM shariah_compliant_finance\n) t \nWHERE rn = 3;\n```", "latency_sec": 1.6519527435302734, "total_duration_sec": 1.553147026, "load_duration_sec": 0.013846557, "tokens_prompt": 892, "prompt_eval_sec": 0.353108431, "tokens_completion": 49, "completion_eval_sec": 1.181516417, "tokens_total": 941, "tokens_per_sec": 569.6288853814633, "retrieval_latency_sec": 0.11774897575378418, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries use different window functions: RANK() vs. ROW_NUMBER(). While they produce the same result here (due to unique account_balance values), RANK() handles ties by assigning identical ranks and skipping subsequent numbers, whereas ROW_NUMBER() always assigns unique consecutive numbers. This difference makes them non-equivalent in general cases.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries technically produce the same result in this specific case (returns 7000) because the sample data has unique account balances. However, the generated query using ROW_NUMBER() is more appropriate for the business intent. RANK() would produce different results if there were duplicate account balances (e.g., two customers with 8000), as it would assign the same rank to ties and create gaps. ROW_NUMBER() ensures a strict ordering without gaps, correctly identifying the third distinct row in the sorted list. While both queries fulfill the intent for the given data, the generated query is more robust for general cases.", "overall_assessment": "differently_correct"}}
{"example_id": 3795, "sql_complexity": "single join", "prompt": "What is the total quantity of unsold garments for each manufacturer based in 'Italy' or 'Spain'?", "context": "CREATE TABLE manufacturers (id INT PRIMARY KEY, name VARCHAR(255), country VARCHAR(255)); CREATE TABLE garments (id INT PRIMARY KEY, manufacturer_id INT, quantity_manufactured INT, quantity_sold INT);", "reference_sql": "SELECT m.name, SUM(g.quantity_manufactured - g.quantity_sold) as total_unsold_quantity FROM manufacturers m JOIN garments g ON m.id = g.manufacturer_id WHERE m.country IN ('Italy', 'Spain') GROUP BY m.name;", "generated_sql": "SELECT m.name AS manufacturer_name, SUM(g.quantity_manufactured - g.quantity_sold) AS total_unsold_quantity\nFROM garments g\nJOIN manufacturers m ON g.manufacturer_id = m.id\nWHERE m.country IN ('Italy', 'Spain')\nGROUP BY m.name;", "raw_model_output": "```sql\nSELECT m.name AS manufacturer_name, SUM(g.quantity_manufactured - g.quantity_sold) AS total_unsold_quantity\nFROM garments g\nJOIN manufacturers m ON g.manufacturer_id = m.id\nWHERE m.country IN ('Italy', 'Spain')\nGROUP BY m.name;\n```", "latency_sec": 1.848863124847412, "total_duration_sec": 1.844500172, "load_duration_sec": 0.017854797, "tokens_prompt": 937, "prompt_eval_sec": 0.365750217, "tokens_completion": 60, "completion_eval_sec": 1.456506876, "tokens_total": 997, "tokens_per_sec": 539.2503028488294, "retrieval_latency_sec": 0.11385703086853027, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform the same operation: joining manufacturers and garments tables on manufacturer_id, filtering by country ('Italy' or 'Spain'), and calculating total unsold quantity (quantity_manufactured - quantity_sold) per manufacturer. The differences are purely syntactic (table order in JOIN, column aliases) and do not affect the result set.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the total unsold garments (quantity_manufactured - quantity_sold) for manufacturers in Italy/Spain. The reference query uses implicit join syntax (comma-separated tables) while the generated query uses explicit JOIN syntax, which is more readable. The generated query also uses consistent aliasing (manufacturer_name vs. m.name) but this doesn't affect functionality. Both group by manufacturer name and apply the country filter correctly. The generated query's explicit JOIN syntax is considered more modern and maintainable.", "overall_assessment": "correct"}}
{"example_id": 4138, "sql_complexity": "window functions", "prompt": "How many lifelong learning courses has a student with ID '2' completed, in chronological order?", "context": "CREATE TABLE lifelong_learning (student_id INT, course_id INT, completion_date DATE); INSERT INTO lifelong_learning VALUES (2, 1001, '2015-01-01'), (2, 1002, '2016-01-01');", "reference_sql": "SELECT student_id, course_id, COUNT(course_id) OVER (PARTITION BY student_id ORDER BY completion_date) as completed_courses FROM lifelong_learning WHERE student_id = 2;", "generated_sql": "SELECT student_id, course_id, \n       COUNT(course_id) OVER (PARTITION BY student_id ORDER BY completion_date) AS completed_courses \nFROM lifelong_learning \nWHERE student_id = 2;", "raw_model_output": "```sql\nSELECT student_id, course_id, \n       COUNT(course_id) OVER (PARTITION BY student_id ORDER BY completion_date) AS completed_courses \nFROM lifelong_learning \nWHERE student_id = 2;\n```", "latency_sec": 1.6575658321380615, "total_duration_sec": 1.517420207, "load_duration_sec": 0.016068458, "tokens_prompt": 978, "prompt_eval_sec": 0.382506982, "tokens_completion": 45, "completion_eval_sec": 1.114266915, "tokens_total": 1023, "tokens_per_sec": 617.1700575418187, "retrieval_latency_sec": 0.11394476890563965, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select student_id, course_id, and a window function COUNT(course_id) partitioned by student_id and ordered by completion_date, with the same WHERE condition (student_id = 2). The formatting differences (line breaks, spacing) do not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": false, "superiority": "equal", "explanation": "The queries are technically identical, with the same syntax, logic, and output structure. However, they do not fully fulfill the business intent. The original question asks for the *total number* of courses completed by student 2, but the queries return a running count per course (e.g., 1, 2 for two courses) rather than a single aggregate count. The window function creates a cumulative count per row, which is not the same as the total number of courses. To fulfill the intent, an aggregate function like COUNT(*) with GROUP BY or a subquery would be required.", "overall_assessment": "incorrect"}}
{"example_id": 312, "sql_complexity": "aggregation", "prompt": "List the top 3 most represented ethnicities in movies produced in the USA.", "context": "CREATE TABLE movies (title VARCHAR(255), production_country VARCHAR(64), lead_actor_ethnicity VARCHAR(64));", "reference_sql": "SELECT lead_actor_ethnicity, COUNT(*) AS count FROM movies WHERE production_country = 'USA' GROUP BY lead_actor_ethnicity ORDER BY count DESC LIMIT 3;", "generated_sql": "SELECT lead_actor_ethnicity, COUNT(*) as count \nFROM movies \nWHERE production_country = 'USA' \nGROUP BY lead_actor_ethnicity \nORDER BY count DESC \nLIMIT 3;", "raw_model_output": "```sql\nSELECT lead_actor_ethnicity, COUNT(*) as count \nFROM movies \nWHERE production_country = 'USA' \nGROUP BY lead_actor_ethnicity \nORDER BY count DESC \nLIMIT 3;\n```", "latency_sec": 1.5534169673919678, "total_duration_sec": 1.449037735, "load_duration_sec": 0.020411851, "tokens_prompt": 833, "prompt_eval_sec": 0.342941027, "tokens_completion": 45, "completion_eval_sec": 1.078141686, "tokens_total": 878, "tokens_per_sec": 565.2056198884414, "retrieval_latency_sec": 0.1131587028503418, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure, logic, and syntax. Both select the lead_actor_ethnicity and count of movies from the USA, group by ethnicity, order by count descending, and limit to 3 results. No semantic differences exist between them.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "The queries are identical in structure, logic, and syntax. Both correctly filter movies produced in the USA, group by lead actor ethnicity, count occurrences, order by count descending, and limit to top 3 results. They both accurately address the business intent of identifying the most represented ethnicities in US-produced movies. The queries are equally efficient and elegant, with no differences in performance or readability.", "overall_assessment": "correct"}}
{"example_id": 4298, "sql_complexity": "single join", "prompt": "How many users joined the gym in Q1 2023?", "context": "CREATE TABLE memberships (id INT, user_id INT, join_date DATE); INSERT INTO memberships (id, user_id, join_date) VALUES (1, 5, '2023-01-15'), (2, 6, '2023-02-03'), (3, 7, '2023-03-20'), (4, 8, '2022-12-31');", "reference_sql": "SELECT COUNT(*) FROM memberships WHERE join_date BETWEEN '2023-01-01' AND '2023-03-31';", "generated_sql": "SELECT COUNT(*) FROM memberships WHERE join_date >= '2023-01-01' AND join_date <= '2023-03-31';", "raw_model_output": "```sql\nSELECT COUNT(*) FROM memberships WHERE join_date >= '2023-01-01' AND join_date <= '2023-03-31';\n```", "latency_sec": 1.7372548580169678, "total_duration_sec": 1.619376914, "load_duration_sec": 0.015612484, "tokens_prompt": 1263, "prompt_eval_sec": 0.589814772, "tokens_completion": 42, "completion_eval_sec": 1.008454102, "tokens_total": 1305, "tokens_per_sec": 751.1851205813431, "retrieval_latency_sec": 0.11707282066345215, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter memberships with join_date between '2023-01-01' and '2023-03-31' inclusive. The BETWEEN operator and the combination of >=/<= conditions are logically equivalent for date ranges, and the sample data confirms they would produce the same count.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly count users who joined in Q1 2023 (January 1 - March 31). The reference uses BETWEEN which includes both endpoints, while the generated query uses explicit >= and <= operators. Since the date ranges are identical and the sample data shows 3 users in Q1 (1,2,3), both would return the same result. The logic is sound, and both address the business intent of counting Q1 2023 signups. Neither query is more efficient or elegant than the other in this case.", "overall_assessment": "correct"}}
{"example_id": 5211, "sql_complexity": "multiple_joins", "prompt": "What is the average transaction value in the last week, split by product category and customer demographics?", "context": "CREATE TABLE transactions (transaction_id INT, customer_id INT, product_id INT, category_id INT, transaction_date DATE, amount DECIMAL(10,2)); CREATE TABLE customers (customer_id INT, age INT, gender VARCHAR(10), location VARCHAR(255)); CREATE TABLE products (product_id INT, name VARCHAR(255), category_id INT);", "reference_sql": "SELECT c.age, c.gender, p.category_id, AVG(t.amount) as avg_transaction_value FROM transactions t INNER JOIN customers c ON t.customer_id = c.customer_id INNER JOIN products p ON t.product_id = p.product_id WHERE t.transaction_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 WEEK) GROUP BY c.age, c.gender, p.category_id;", "generated_sql": "SELECT p.category_id, c.age, c.gender, AVG(t.amount) as avg_transaction_value \nFROM transactions t \nINNER JOIN customers c ON t.customer_id = c.customer_id \nINNER JOIN products p ON t.product_id = p.product_id \nWHERE t.transaction_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 WEEK) \nGROUP BY p.category_id, c.age, c.gender;", "raw_model_output": "```sql\nSELECT p.category_id, c.age, c.gender, AVG(t.amount) as avg_transaction_value \nFROM transactions t \nINNER JOIN customers c ON t.customer_id = c.customer_id \nINNER JOIN products p ON t.product_id = p.product_id \nWHERE t.transaction_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 WEEK) \nGROUP BY p.category_id, c.age, c.gender;\n```", "latency_sec": 2.5250589847564697, "total_duration_sec": 2.360470099, "load_duration_sec": 0.015714975, "tokens_prompt": 875, "prompt_eval_sec": 0.354001372, "tokens_completion": 84, "completion_eval_sec": 1.986394949, "tokens_total": 959, "tokens_per_sec": 379.7931081172312, "retrieval_latency_sec": 0.1162409782409668, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (age, gender, category_id, avg_transaction_value) and apply identical JOIN conditions, WHERE filters, and GROUP BY logic. The order of columns in SELECT and GROUP BY clauses does not affect semantic equivalence in SQL.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent as they produce identical results. The only difference is the order of columns in the GROUP BY clause, which does not affect SQL semantics. Both correctly split by product category (category_id) and customer demographics (age, gender) while calculating the average transaction value for the last week. The reference query's GROUP BY order matches the SELECT order, while the generated query uses a different order but remains logically equivalent. Both fulfill the business intent perfectly.", "overall_assessment": "correct"}}
{"example_id": 382, "sql_complexity": "window functions", "prompt": "What is the average annual precipitation in the past 10 years for each weather station?", "context": "CREATE TABLE WeatherStation (ID INT, Name VARCHAR(100), Location VARCHAR(100), Elevation FLOAT, AnnualPrecipitation FLOAT); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (1, 'Station A', 'Arctic Circle', 100, 450); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (2, 'Station B', 'North Pole', 200, 300);", "reference_sql": "SELECT Name, AVG(AnnualPrecipitation) OVER (PARTITION BY Name ORDER BY Name ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS AvgAnnualPrecipitation FROM WeatherStation WHERE YEAR(CurrentDate) - YEAR(DateInstalled) BETWEEN 1 AND 10;", "generated_sql": "SELECT WeatherStation.Name, AVG(climate_data.precipitation) AS AverageAnnualPrecipitation\nFROM WeatherStation\nJOIN climate_data ON WeatherStation.Name = climate_data.location\nWHERE climate_data.measurement_date >= DATE_SUB(CURDATE(), INTERVAL 10 YEAR)\nGROUP BY WeatherStation.Name;", "raw_model_output": "```sql\nSELECT WeatherStation.Name, AVG(climate_data.precipitation) AS AverageAnnualPrecipitation\nFROM WeatherStation\nJOIN climate_data ON WeatherStation.Name = climate_data.location\nWHERE climate_data.measurement_date >= DATE_SUB(CURDATE(), INTERVAL 10 YEAR)\nGROUP BY WeatherStation.Name;\n```", "latency_sec": 2.2840399742126465, "total_duration_sec": 2.121124532, "load_duration_sec": 0.016232713, "tokens_prompt": 1118, "prompt_eval_sec": 0.553247873, "tokens_completion": 67, "completion_eval_sec": 1.546872589, "tokens_total": 1185, "tokens_per_sec": 518.8175397011136, "retrieval_latency_sec": 0.11624908447265625, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL references a non-existent 'DateInstalled' column and uses a window function with 'Name' partitioning, while the Generated SQL joins with a non-existent 'climate_data' table and filters based on 'measurement_date'. Additionally, the Reference SQL's WHERE clause contains invalid syntax (YEAR(CurrentDate) - YEAR(DateInstalled)) that doesn't align with the provided schema. The two queries operate on different data structures and have distinct logical conditions.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries are not technically equivalent. The Reference SQL references non-existent columns (DateInstalled, CurrentDate) and uses a window function incorrectly for this task. The Generated SQL correctly filters by the last 10 years but references a non-existent climate_data table. Neither query matches the schema, but the Generated SQL better addresses the 'past 10 years' requirement. The original question assumes AnnualPrecipitation is already stored, so both queries are flawed, but the Generated SQL's temporal filtering aligns more with the intent.", "overall_assessment": "differently_correct"}}
{"example_id": 2190, "sql_complexity": "single join", "prompt": "What is the total number of humanitarian assistance events by each country in the last 3 years?", "context": "CREATE TABLE Humanitarian_Assistance (id INT, country VARCHAR(50), year INT, events INT); CREATE TABLE Countries (id INT, name VARCHAR(50), region VARCHAR(50));", "reference_sql": "SELECT co.name, SUM(ha.events) FROM Humanitarian_Assistance ha INNER JOIN Countries co ON ha.country = co.name WHERE ha.year BETWEEN (YEAR(CURRENT_DATE) - 3) AND YEAR(CURRENT_DATE) GROUP BY co.name;", "generated_sql": "SELECT H.country, SUM(H.events) AS TotalEvents \nFROM Humanitarian_Assistance H \nWHERE H.year >= YEAR(CURRENT_DATE) - 3 \nGROUP BY H.country;", "raw_model_output": "```sql\nSELECT H.country, SUM(H.events) AS TotalEvents \nFROM Humanitarian_Assistance H \nWHERE H.year >= YEAR(CURRENT_DATE) - 3 \nGROUP BY H.country;\n```", "latency_sec": 1.6349139213562012, "total_duration_sec": 1.507009867, "load_duration_sec": 0.0213236, "tokens_prompt": 1042, "prompt_eval_sec": 0.404406815, "tokens_completion": 42, "completion_eval_sec": 1.073395263, "tokens_total": 1084, "tokens_per_sec": 663.0318488577034, "retrieval_latency_sec": 0.1120290756225586, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in three key aspects: 1) The Reference SQL joins with the Countries table, while the Generated SQL does not. 2) The Reference uses a BETWEEN clause with explicit upper/lower bounds (YEAR(CURRENT_DATE) - 3 to YEAR(CURRENT_DATE)), whereas the Generated uses a >= condition without an upper bound. 3) The Reference groups by co.name (country names from Countries table), while the Generated groups by H.country (directly from Humanitarian_Assistance). These differences could lead to different results due to potential mismatches in country names, inclusion of future years, and filtering via the join.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent. The Reference query correctly joins with the Countries table to ensure country names align with the reference data, while the Generated query uses raw country names from Humanitarian_Assistance which may lack standardization. Both filter for the last 3 years correctly (YEAR(CURRENT_DATE) - 3 is equivalent to BETWEEN ...), but the Reference provides more accurate country identifiers by leveraging the Countries table. The Generated query is more efficient but risks inconsistent country naming. Both fulfill the business intent of aggregating events by country, but the Reference better ensures data consistency with the schema.", "overall_assessment": "differently_correct"}}
{"example_id": 1852, "sql_complexity": "set operations", "prompt": "Compare coal production and employment rates in China and India between 2018 and 2020.", "context": "CREATE TABLE china_coal_production (year INT, production FLOAT); INSERT INTO china_coal_production (year, production) VALUES (2018, 3500.0), (2019, 3600.0), (2020, 3700.0); CREATE TABLE china_employment (year INT, employment FLOAT); INSERT INTO china_employment (year, employment) VALUES (2018, 8000000.0), (2019, 8100000.0), (2020, 8200000.0); CREATE TABLE india_coal_production (year INT, production FLOAT); INSERT INTO india_coal_production (year, production) VALUES (2018, 700.0), (2019, 750.0), (2020, 800.0); CREATE TABLE india_employment (year INT, employment FLOAT); INSERT INTO india_employment (year, employment) VALUES (2018, 1000000.0), (2019, 1050000.0), (2020, 1100000.0);", "reference_sql": "SELECT 'China' AS country, china_coal_production.production, china_employment.employment FROM china_coal_production INNER JOIN china_employment ON china_coal_production.year = china_employment.year WHERE china_coal_production.year BETWEEN 2018 AND 2020 UNION ALL SELECT 'India', india_coal_production.production, india_employment.employment FROM india_coal_production INNER JOIN india_employment ON india_coal_production.year = india_employment.year WHERE india_coal_production.year BETWEEN 2018 AND 2020;", "generated_sql": "SELECT \n    ccp.year,\n    ccp.production AS china_production,\n    ce.employment AS china_employment,\n    icp.production AS india_production,\n    ie.employment AS india_employment\nFROM \n    china_coal_production ccp\nJOIN \n    china_employment ce ON ccp.year = ce.year\nJOIN \n    india_coal_production icp ON ccp.year = icp.year\nJOIN \n    india_employment ie ON ccp.year = ie.year\nWHERE \n    ccp.year BETWEEN 2018 AND 2020;", "raw_model_output": "```sql\nSELECT \n    ccp.year,\n    ccp.production AS china_production,\n    ce.employment AS china_employment,\n    icp.production AS india_production,\n    ie.employment AS india_employment\nFROM \n    china_coal_production ccp\nJOIN \n    china_employment ce ON ccp.year = ce.year\nJOIN \n    india_coal_production icp ON ccp.year = icp.year\nJOIN \n    india_employment ie ON ccp.year = ie.year\nWHERE \n    ccp.year BETWEEN 2018 AND 2020;\n```", "latency_sec": 3.4016659259796143, "total_duration_sec": 3.323043335, "load_duration_sec": 0.014280903, "tokens_prompt": 1282, "prompt_eval_sec": 0.591904968, "tokens_completion": 116, "completion_eval_sec": 2.713317809, "tokens_total": 1398, "tokens_per_sec": 410.9751017356012, "retrieval_latency_sec": 0.11083817481994629, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two rows per year (China and India) with columns 'country', 'production', and 'employment', while the Generated SQL returns one row per year with separate columns for China and India's production/employment. The structure and number of rows differ, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL returns separate rows for China and India with vertical alignment, while the Generated SQL provides a horizontal comparison in a single row per year. Both are technically correct but produce different result structures. The Generated SQL better fulfills the business intent by directly enabling side-by-side comparison of all metrics. The Reference SQL requires additional post-processing to compare values across countries. The Generated SQL's joins are valid given the data structure, though it assumes all years exist in all tables (which is true in this case).", "overall_assessment": "differently_correct"}}
{"example_id": 2535, "sql_complexity": "subqueries", "prompt": "What is the maximum safety rating for vehicles in the vehiclesafety schema?", "context": "CREATE TABLE VehicleSafety (id INT, vehicle_id INT, safetyrating INT, PRIMARY KEY (id)); CREATE TABLE Vehicles (id INT, make VARCHAR(50), model VARCHAR(50), PRIMARY KEY (id)); CREATE TABLE LuxuryVehicles (id INT, vehicle_id INT, PRIMARY KEY (id), FOREIGN KEY (vehicle_id) REFERENCES Vehicles(id));", "reference_sql": "SELECT MAX(safetyrating) FROM vehicleSafety JOIN Vehicles ON vehicleSafety.vehicle_id = Vehicles.id WHERE EXISTS (SELECT * FROM LuxuryVehicles WHERE Vehicles.id = LuxuryVehicles.vehicle_id);", "generated_sql": "SELECT MAX(safetyrating) FROM VehicleSafety;", "raw_model_output": "```sql\nSELECT MAX(safetyrating) FROM VehicleSafety;\n```", "latency_sec": 0.8408088684082031, "total_duration_sec": 0.705702928, "load_duration_sec": 0.015310152, "tokens_prompt": 754, "prompt_eval_sec": 0.315413023, "tokens_completion": 15, "completion_eval_sec": 0.371569787, "tokens_total": 769, "tokens_per_sec": 914.5954911915359, "retrieval_latency_sec": 0.11421990394592285, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters vehicles using an EXISTS clause to only include luxury vehicles (via LuxuryVehicles table), while the Generated SQL selects from VehicleSafety without any filters. This means the Reference SQL's MAX(safetyrating) is restricted to luxury vehicles, whereas the Generated SQL considers all vehicles. The presence of the LuxuryVehicles table and the WHERE EXISTS condition in the Reference SQL makes it semantically different from the Generated SQL.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query incorrectly filters results to only include luxury vehicles via the EXISTS clause, while the original question makes no mention of luxury vehicles. The generated query directly retrieves the maximum safety rating from the VehicleSafety table, which aligns with the explicit request for 'vehicles in the vehiclesafety schema' (implying the VehicleSafety table itself). The reference query introduces an unnecessary join and filter that alter the result set. The generated query is technically correct, more efficient, and directly addresses the business intent without additional constraints.", "overall_assessment": "incorrect"}}
{"example_id": 2140, "sql_complexity": "aggregation", "prompt": "What was the total amount of minerals extracted in the 'north' region for each month in 2020?", "context": "CREATE TABLE extraction(id INT, location TEXT, month INT, year INT, minerals_extracted FLOAT);INSERT INTO extraction(id, location, month, year, minerals_extracted) VALUES (1, 'north', 1, 2020, 1500), (2, 'north', 2, 2020, 1800), (3, 'south', 1, 2020, 1200);", "reference_sql": "SELECT month, SUM(minerals_extracted) FROM extraction WHERE location = 'north' AND year = 2020 GROUP BY month;", "generated_sql": "SELECT month, SUM(minerals_extracted) AS total_minerals_extracted \nFROM extraction \nWHERE location = 'north' AND year = 2020 \nGROUP BY month;", "raw_model_output": "```sql\nSELECT month, SUM(minerals_extracted) AS total_minerals_extracted \nFROM extraction \nWHERE location = 'north' AND year = 2020 \nGROUP BY month;\n```", "latency_sec": 1.7150037288665771, "total_duration_sec": 1.480506502, "load_duration_sec": 0.015545158, "tokens_prompt": 958, "prompt_eval_sec": 0.382430452, "tokens_completion": 43, "completion_eval_sec": 1.078502543, "tokens_total": 1001, "tokens_per_sec": 583.672200329003, "retrieval_latency_sec": 0.11234784126281738, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. The generated query adds an alias 'total_minerals_extracted' for the SUM column, but the selection of columns, filtering conditions, and grouping logic remain identical. The result set structure (column names) may differ in the alias, but the data returned for the 'month' and aggregated 'minerals_extracted' values is the same.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically equivalent as they produce identical results through the same aggregation logic. The generated query improves upon the reference by adding an explicit column alias ('total_minerals_extracted'), which enhances readability and aligns better with standard reporting practices. Both correctly filter for 'north' location and 2020 year, grouping by month to calculate monthly totals. The generated query's alias makes the output more semantically meaningful without altering functionality.", "overall_assessment": "correct"}}
{"example_id": 4779, "sql_complexity": "window functions", "prompt": "What is the average CO2 emission for the top 3 highest emitting countries since 2015?", "context": "CREATE TABLE emissions (country VARCHAR(50), year INT, co2_emission INT); INSERT INTO emissions (country, year, co2_emission) VALUES ('USA', 2015, 5373978000); INSERT INTO emissions (country, year, co2_emission) VALUES ('China', 2015, 10498600000); INSERT INTO emissions (country, year, co2_emission) VALUES ('India', 2015, 2633830000); INSERT INTO emissions (country, year, co2_emission) VALUES ('USA', 2016, 5518004000); INSERT INTO emissions (country, year, co2_emission) VALUES ('China', 2016, 10813000000); INSERT INTO emissions (country, year, co2_emission) VALUES ('India', 2016, 2799280000);", "reference_sql": "SELECT AVG(co2_emission) as avg_emission FROM (SELECT country, year, co2_emission, ROW_NUMBER() OVER (ORDER BY co2_emission DESC) as rn FROM emissions WHERE year >= 2015) t WHERE rn <= 3 GROUP BY country;", "generated_sql": "SELECT AVG(co2_emission) AS avg_co2_emission\nFROM (\n    SELECT country, SUM(co2_emission) AS total_co2_emission\n    FROM emissions\n    WHERE year >= 2015\n    GROUP BY country\n    ORDER BY total_co2_emission DESC\n    LIMIT 3\n) AS top_countries;", "raw_model_output": "```sql\nSELECT AVG(co2_emission) AS avg_co2_emission\nFROM (\n    SELECT country, SUM(co2_emission) AS total_co2_emission\n    FROM emissions\n    WHERE year >= 2015\n    GROUP BY country\n    ORDER BY total_co2_emission DESC\n    LIMIT 3\n) AS top_countries;\n```", "latency_sec": 2.385497808456421, "total_duration_sec": 2.300173947, "load_duration_sec": 0.020792566, "tokens_prompt": 1080, "prompt_eval_sec": 0.403831874, "tokens_completion": 77, "completion_eval_sec": 1.868901919, "tokens_total": 1157, "tokens_per_sec": 485.0140695575225, "retrieval_latency_sec": 0.11258602142333984, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates the average of the top 3 highest co2_emission values (per row) grouped by country, while the Generated SQL sums emissions per country first, then averages the top 3 country totals. The Reference SQL's row_number() operates globally, whereas the Generated SQL's aggregation and ordering are country-based. The result structures and calculation logic differ fundamentally.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL is technically flawed because it applies ROW_NUMBER() without grouping by country, leading to per-row ranking rather than per-country aggregation. This could select multiple entries from the same country (e.g., multiple years) and incorrectly calculate averages per country. The Generated SQL correctly groups by country, sums emissions since 2015, selects the top 3 countries by total emissions, and calculates their average. This aligns with the business intent of finding the average CO2 emission of the top 3 countries' total emissions over the period. The Generated SQL is more efficient and semantically accurate.", "overall_assessment": "differently_correct"}}
{"example_id": 1015, "sql_complexity": "subqueries", "prompt": "List the top 3 most expensive eco-friendly products in Europe and their suppliers.", "context": "CREATE TABLE Suppliers (supplierID INT, supplierName VARCHAR(50), country VARCHAR(50)); CREATE TABLE Products (productID INT, productName VARCHAR(50), price DECIMAL(10,2), ecoFriendly BOOLEAN, supplierID INT);", "reference_sql": "SELECT P.productName, P.price, S.supplierName FROM (SELECT * FROM Products WHERE ecoFriendly = TRUE ORDER BY price DESC LIMIT 3) P JOIN Suppliers S ON P.supplierID = S.supplierID;", "generated_sql": "SELECT p.productName, p.price, s.supplierName \nFROM Products p \nJOIN Suppliers s ON p.supplierID = s.supplierID \nWHERE p.ecoFriendly = TRUE AND s.country = 'Europe' \nORDER BY p.price DESC \nLIMIT 3;", "raw_model_output": "```sql\nSELECT p.productName, p.price, s.supplierName \nFROM Products p \nJOIN Suppliers s ON p.supplierID = s.supplierID \nWHERE p.ecoFriendly = TRUE AND s.country = 'Europe' \nORDER BY p.price DESC \nLIMIT 3;\n```", "latency_sec": 1.9083318710327148, "total_duration_sec": 1.828341254, "load_duration_sec": 0.016758031, "tokens_prompt": 868, "prompt_eval_sec": 0.350928914, "tokens_completion": 61, "completion_eval_sec": 1.45675548, "tokens_total": 929, "tokens_per_sec": 486.81260010464604, "retrieval_latency_sec": 0.11091899871826172, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in filtering conditions. The Reference SQL only filters by ecoFriendly = TRUE, while the Generated SQL adds an additional condition WHERE s.country = 'Europe'. This means the Generated SQL restricts results to products from European suppliers, whereas the Reference SQL includes suppliers from all countries. The ordering and limiting logic is similar, but the extra country filter makes them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in critical aspects. The Reference query selects top 3 eco-friendly products first (without considering supplier location) and then joins with suppliers, which may include non-European suppliers. The Generated query correctly filters for European suppliers (s.country = 'Europe') before ordering and limiting results. While both identify eco-friendly products, only the Generated query ensures the supplier is located in Europe as required by the business question. The Reference query fails to fulfill the 'in Europe' constraint, making it technically incomplete for the stated intent.", "overall_assessment": "differently_correct"}}
{"example_id": 3715, "sql_complexity": "aggregation", "prompt": "What is the average age of engines still in service for each engine type?", "context": "CREATE TABLE Engine (id INT, aircraft_id INT, engine_type VARCHAR(255), hours_since_last_service INT, manufacture_year INT); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (1, 1, 'GE90-115B', 500, 2000); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (2, 2, 'CFM56-5B', 1000, 1995); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (3, 1, 'GE90-115B', 700, 2002);", "reference_sql": "SELECT engine_type, AVG(YEAR(CURRENT_DATE) - manufacture_year) as avg_age FROM Engine GROUP BY engine_type;", "generated_sql": "SELECT engine_type, AVG(CURRENT_YEAR - manufacture_year) AS avg_age \nFROM Engine \nJOIN (SELECT YEAR(CURDATE()) AS CURRENT_YEAR) AS current_year_subquery \nGROUP BY engine_type;", "raw_model_output": "```sql\nSELECT engine_type, AVG(CURRENT_YEAR - manufacture_year) AS avg_age \nFROM Engine \nJOIN (SELECT YEAR(CURDATE()) AS CURRENT_YEAR) AS current_year_subquery \nGROUP BY engine_type;\n```", "latency_sec": 1.5525591373443604, "total_duration_sec": 1.403207261, "load_duration_sec": 0.014020812, "tokens_prompt": 698, "prompt_eval_sec": 0.295360742, "tokens_completion": 47, "completion_eval_sec": 1.090000524, "tokens_total": 745, "tokens_per_sec": 479.8528971168959, "retrieval_latency_sec": 0.11748981475830078, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average age of engines by subtracting the manufacture year from the current year. The Reference SQL uses YEAR(CURRENT_DATE) directly, while the Generated SQL uses a subquery to obtain the current year (YEAR(CURDATE())). Since CURRENT_DATE and CURDATE() return the same date in MySQL, and the subquery's JOIN does not alter the per-row calculation, the final result remains identical.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query is technically correct and semantically equivalent, while the generated query has issues. The reference uses YEAR(CURRENT_DATE) - manufacture_year, which correctly calculates age using standard SQL functions. The generated query incorrectly uses CURRENT_YEAR (non-standard function) and adds unnecessary complexity with a redundant subquery join. Both queries fulfill the business intent by calculating average engine age per type, but the reference is more efficient and elegant. The generated query would fail in databases that don't recognize CURRENT_YEAR.", "overall_assessment": "differently_correct"}}
{"example_id": 1957, "sql_complexity": "set operations", "prompt": "What is the average temperature recorded for the 'polar_bear' species in the 'Arctic_Animals' table compared to the 'penguin' species in the 'Antarctic_Animals' table?", "context": "CREATE TABLE Arctic_Animals (species TEXT, avg_temp FLOAT); CREATE TABLE Antarctic_Animals (species TEXT, avg_temp FLOAT);", "reference_sql": "SELECT AVG(Arctic_Animals.avg_temp) FROM Arctic_Animals WHERE Arctic_Animals.species = 'polar_bear' INTERSECT SELECT AVG(Antarctic_Animals.avg_temp) FROM Antarctic_Animals WHERE Antarctic_Animals.species = 'penguin'", "generated_sql": "SELECT \n    (SELECT avg_temp FROM Arctic_Animals WHERE species = 'polar_bear') AS polar_bear_avg_temp,\n    (SELECT avg_temp FROM Antarctic_Animals WHERE species = 'penguin') AS penguin_avg_temp;", "raw_model_output": "```sql\nSELECT \n    (SELECT avg_temp FROM Arctic_Animals WHERE species = 'polar_bear') AS polar_bear_avg_temp,\n    (SELECT avg_temp FROM Antarctic_Animals WHERE species = 'penguin') AS penguin_avg_temp;\n```", "latency_sec": 1.8382940292358398, "total_duration_sec": 1.551524535, "load_duration_sec": 0.019917912, "tokens_prompt": 670, "prompt_eval_sec": 0.292764168, "tokens_completion": 54, "completion_eval_sec": 1.235683921, "tokens_total": 724, "tokens_per_sec": 393.84341595286554, "retrieval_latency_sec": 0.11494207382202148, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the average temperature for polar bears and penguins separately, then returns the intersection of these two values (only matching values). The Generated SQL retrieves the raw avg_temp values for each species directly. The first returns a single column with potential single-value results (via INTERSECT), while the second returns two columns with individual values. Their structure and logic differ fundamentally.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL is technically incorrect because it uses INTERSECT, which returns common values between the two averages rather than comparing them. This would only return a result if the averages are identical, which is not the intended comparison. The Generated SQL correctly retrieves both averages separately in a single query, directly answering the question. While the Generated SQL assumes each species has exactly one record (which may not hold if multiple rows exist), the Reference SQL's use of AVG is redundant if the table already stores precomputed averages. The Generated SQL better fulfills the business intent of comparing the two averages.", "overall_assessment": "differently_correct"}}
{"example_id": 1311, "sql_complexity": "basic SQL", "prompt": "What is the total number of veteran job applications in Texas in the last year?", "context": "CREATE TABLE veteran_jobs (id INT, state VARCHAR(50), application_date DATE); INSERT INTO veteran_jobs (id, state, application_date) VALUES (1, 'Texas', '2021-02-15'), (2, 'California', '2021-04-10'), (3, 'Texas', '2022-01-05');", "reference_sql": "SELECT COUNT(*) FROM veteran_jobs WHERE state = 'Texas' AND application_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR);", "generated_sql": "SELECT COUNT(*) \nFROM veteran_jobs \nWHERE state = 'Texas' \n  AND application_date >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR);", "raw_model_output": "```sql\nSELECT COUNT(*) \nFROM veteran_jobs \nWHERE state = 'Texas' \n  AND application_date >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR);\n```", "latency_sec": 1.5307960510253906, "total_duration_sec": 1.209564778, "load_duration_sec": 0.014030932, "tokens_prompt": 809, "prompt_eval_sec": 0.329498261, "tokens_completion": 36, "completion_eval_sec": 0.861562047, "tokens_total": 845, "tokens_per_sec": 552.0003787793835, "retrieval_latency_sec": 0.11488890647888184, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries use equivalent date functions (CURRENT_DATE and CURDATE() are synonyms in MySQL) and identical logic to count Texas applications from the last year. The semantic meaning of the date calculations and filters is identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly count veteran job applications in Texas within the last year. The only difference is the use of CURRENT_DATE (reference) vs. CURDATE() (generated), which are functionally identical in MySQL. Both properly filter by state and date range, ensuring semantic equivalence. Neither query is more efficient or elegant than the other, as they execute the same logic with equivalent performance characteristics.", "overall_assessment": "correct"}}
{"example_id": 2997, "sql_complexity": "window functions", "prompt": "What is the earliest capture time for each satellite image in the 'satellite_images' table?", "context": "CREATE TABLE satellite_images (image_id INT, image_url TEXT, capture_time TIMESTAMP); INSERT INTO satellite_images (image_id, image_url, capture_time) VALUES (1, 'image1.jpg', '2022-01-01 10:00:00'), (2, 'image2.jpg', '2021-05-01 10:00:00');", "reference_sql": "SELECT image_id, MIN(capture_time) OVER (PARTITION BY image_id) FROM satellite_images;", "generated_sql": "SELECT image_id, MIN(capture_time) AS earliest_capture_time \nFROM satellite_images \nGROUP BY image_id;", "raw_model_output": "```sql\nSELECT image_id, MIN(capture_time) AS earliest_capture_time \nFROM satellite_images \nGROUP BY image_id;\n```", "latency_sec": 1.1872010231018066, "total_duration_sec": 0.994101744, "load_duration_sec": 0.015775098, "tokens_prompt": 732, "prompt_eval_sec": 0.308378919, "tokens_completion": 28, "completion_eval_sec": 0.666032779, "tokens_total": 760, "tokens_per_sec": 640.1611733911278, "retrieval_latency_sec": 0.11243200302124023, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries return the same result because the window function in the Reference SQL effectively computes the same value as the GROUP BY aggregation in the Generated SQL. Since each image_id is unique in the table, the MIN(capture_time) over a partition of one row (Reference SQL) equals the MIN(capture_time) after grouping by image_id (Generated SQL). The output structure differs slightly (column name), but the data content is identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries return the same results in this specific case. The Reference SQL uses a window function (MIN() OVER) which, when partitioned by unique image_id, produces the same value as the original capture_time. The Generated SQL uses GROUP BY with MIN(), which is the standard approach for this type of aggregation. While both are technically equivalent here, the Generated SQL is more efficient and semantically appropriate for the task. The original question's phrasing ('earliest capture time for each satellite image') implies per-image aggregation, which the Generated SQL explicitly handles with GROUP BY.", "overall_assessment": "correct"}}
{"example_id": 3743, "sql_complexity": "aggregation", "prompt": "What is the maximum budget spent on peacekeeping operations by each department?", "context": "CREATE TABLE DepartmentPeacekeeping (id INT, department VARCHAR(50), budget INT);", "reference_sql": "SELECT department, MAX(budget) FROM DepartmentPeacekeeping GROUP BY department;", "generated_sql": "SELECT department, MAX(budget) \nFROM DepartmentPeacekeeping \nGROUP BY department;", "raw_model_output": "```sql\nSELECT department, MAX(budget) \nFROM DepartmentPeacekeeping \nGROUP BY department;\n```", "latency_sec": 0.9549739360809326, "total_duration_sec": 0.761476145, "load_duration_sec": 0.018242692, "tokens_prompt": 567, "prompt_eval_sec": 0.141101092, "tokens_completion": 22, "completion_eval_sec": 0.594586521, "tokens_total": 589, "tokens_per_sec": 616.7707596472907, "retrieval_latency_sec": 0.1116642951965332, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. The generated SQL only differs in formatting (line breaks) and does not change the semantic meaning of the query. Both select the department and maximum budget per department from the DepartmentPeacekeeping table.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are syntactically identical except for formatting. They correctly group by department and calculate the maximum budget per department, directly addressing the business question. The line breaks in the generated query improve readability without altering functionality. Neither query is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 4664, "sql_complexity": "multiple_joins", "prompt": "Calculate the total number of volunteer hours contributed by volunteers from 'California' in 'Health' projects in 2021.", "context": "CREATE TABLE volunteers (volunteer_id INT, name VARCHAR(255), state VARCHAR(255));", "reference_sql": "SELECT SUM(vh.hours) as total_hours FROM volunteer_projects vp JOIN volunteer_hours vh ON vp.project_id = vh.project_id JOIN volunteers vol ON vh.volunteer_id = vol.volunteer_id WHERE vp.cause = 'Health' AND vol.state = 'California' AND vh.volunteer_date BETWEEN '2021-01-01' AND '2021-12-31';", "generated_sql": "SELECT SUM(hours) AS total_volunteer_hours\nFROM Volunteer_Hours\nINNER JOIN volunteers ON Volunteer_Hours.volunteer = volunteers.name\nWHERE volunteers.state = 'California' AND Volunteer_Hours.program = 'Health' AND YEAR(Volunteer_Hours.hours_date) = 2021;", "raw_model_output": "```sql\nSELECT SUM(hours) AS total_volunteer_hours\nFROM Volunteer_Hours\nINNER JOIN volunteers ON Volunteer_Hours.volunteer = volunteers.name\nWHERE volunteers.state = 'California' AND Volunteer_Hours.program = 'Health' AND YEAR(Volunteer_Hours.hours_date) = 2021;\n```", "latency_sec": 2.2895078659057617, "total_duration_sec": 1.982179461, "load_duration_sec": 0.014241986, "tokens_prompt": 946, "prompt_eval_sec": 0.362747632, "tokens_completion": 66, "completion_eval_sec": 1.600914803, "tokens_total": 1012, "tokens_per_sec": 442.0163892294113, "retrieval_latency_sec": 0.11208701133728027, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in table/column relationships and filtering logic. The reference query joins three tables (volunteer_projects, volunteer_hours, volunteers) with specific ID-based joins and filters by 'cause' in volunteer_projects. The generated query joins Volunteer_Hours with volunteers on name (not ID) and filters by 'program' in Volunteer_Hours. Additionally, the date filter uses YEAR() function vs BETWEEN, which could yield different results if hours_date has time components. The schema mappings (e.g., 'cause' vs 'program') and join logic differences make them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in table/column usage and logic. The reference query correctly joins volunteer_projects (to access 'cause' column) and volunteer_hours (to access 'hours' and 'volunteer_date'), while the generated query uses non-existent tables/columns (Volunteer_Hours.program, hours_date) and lacks necessary joins. The reference explicitly filters on 'Health' projects via project cause, whereas the generated query uses an ambiguous 'program' field. The date filter in the generated query (YEAR(hours_date) = 2021) is less efficient than the reference's range comparison. The reference better aligns with the business intent of counting hours for 'Health' projects.", "overall_assessment": "incorrect"}}
{"example_id": 251, "sql_complexity": "set operations", "prompt": "Compare the number of economic diversification projects in two regions, one in Europe and one in Oceania, by showing the project type and the number of projects in each region.", "context": "CREATE TABLE economic_diversification (region VARCHAR(50), project_type VARCHAR(50), project_start_date DATE);", "reference_sql": "SELECT 'Europe' as region, project_type, COUNT(*) as project_count FROM economic_diversification WHERE region = 'Europe' UNION ALL SELECT 'Oceania' as region, project_type, COUNT(*) as project_count FROM economic_diversification WHERE region = 'Oceania';", "generated_sql": "SELECT 'Europe' AS region, project_type, COUNT(*) AS project_count \nFROM economic_diversification \nWHERE region = 'Europe' \nGROUP BY project_type \nUNION ALL \nSELECT 'Oceania' AS region, project_type, COUNT(*) AS project_count \nFROM economic_diversification \nWHERE region = 'Oceania' \nGROUP BY project_type;", "raw_model_output": "```sql\nSELECT 'Europe' AS region, project_type, COUNT(*) AS project_count \nFROM economic_diversification \nWHERE region = 'Europe' \nGROUP BY project_type \nUNION ALL \nSELECT 'Oceania' AS region, project_type, COUNT(*) AS project_count \nFROM economic_diversification \nWHERE region = 'Oceania' \nGROUP BY project_type;\n```", "latency_sec": 2.4452362060546875, "total_duration_sec": 2.203960704, "load_duration_sec": 0.015048761, "tokens_prompt": 745, "prompt_eval_sec": 0.314467357, "tokens_completion": 81, "completion_eval_sec": 1.869737148, "tokens_total": 826, "tokens_per_sec": 337.7996767570873, "retrieval_latency_sec": 0.11614775657653809, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL lacks GROUP BY clauses, which would cause it to return a single row per region with an arbitrary project_type value (not grouped). The Generated SQL explicitly groups by project_type, producing separate counts for each project type in Europe and Oceania. This makes the queries semantically different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is technically incorrect because it lacks GROUP BY clauses, which are required when using aggregate functions like COUNT(*) with non-aggregated columns (project_type). This would result in a syntax error. The Generated SQL correctly groups by project_type in both subqueries, ensuring valid execution. While both queries aim to compare project counts by type between regions, only the Generated SQL fulfills the business intent properly. The Reference SQL fails to execute, making it unable to answer the question. The Generated SQL is more efficient and elegant due to proper grouping.", "overall_assessment": "incorrect"}}
{"example_id": 610, "sql_complexity": "subqueries", "prompt": "What is the percentage of community development projects completed in 'Caribbean' in 2020?", "context": "CREATE TABLE community_projects (project_id INT, project_name TEXT, location TEXT, completion_year INT); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (1, 'Community Center', 'Southern Region, Caribbean', 2020); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (2, 'Park Renovation', 'Northern Region, Caribbean', 2019); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (3, 'Library Construction', 'Caribbean', 2020);", "reference_sql": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM community_projects WHERE location = 'Caribbean')) FROM community_projects WHERE completion_year = 2020 AND location = 'Caribbean';", "generated_sql": "SELECT \n    (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM community_projects WHERE location LIKE '%Caribbean%')) AS percentage\nFROM \n    community_projects\nWHERE \n    completion_year = 2020 AND location LIKE '%Caribbean%';", "raw_model_output": "```sql\nSELECT \n    (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM community_projects WHERE location LIKE '%Caribbean%')) AS percentage\nFROM \n    community_projects\nWHERE \n    completion_year = 2020 AND location LIKE '%Caribbean%';\n```", "latency_sec": 2.0426530838012695, "total_duration_sec": 1.904837868, "load_duration_sec": 0.017820679, "tokens_prompt": 1006, "prompt_eval_sec": 0.385157292, "tokens_completion": 62, "completion_eval_sec": 1.493292928, "tokens_total": 1068, "tokens_per_sec": 522.8494297291581, "retrieval_latency_sec": 0.11095595359802246, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses exact matches for 'Caribbean' in both the numerator and denominator, while the Generated SQL uses LIKE '%Caribbean%' which includes partial matches. For the given data, the Reference calculates 100% (1/1) while the Generated calculates ~66.67% (2/3). The different location filtering criteria lead to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in how they filter locations. The Reference SQL uses exact matches ('Caribbean'), while the Generated SQL uses pattern matching ('%Caribbean%'). The original question's context includes locations like 'Southern Region, Caribbean' which would be excluded by the Reference query but included by the Generated query. The Generated query better captures projects 'in the Caribbean' as intended, even if locations have additional descriptors. Both queries correctly calculate percentages, but the Generated version aligns more closely with the business intent of identifying all Caribbean-related projects.", "overall_assessment": "differently_correct"}}
{"example_id": 421, "sql_complexity": "set operations", "prompt": "What is the combined landfill capacity for 'City A' and 'City B'?", "context": "CREATE TABLE landfill_capacity (city VARCHAR(255), capacity INT); INSERT INTO landfill_capacity (city, capacity) VALUES ('City A', 500000), ('City B', 600000);", "reference_sql": "SELECT SUM(capacity) FROM (SELECT capacity FROM landfill_capacity WHERE city = 'City A' UNION ALL SELECT capacity FROM landfill_capacity WHERE city = 'City B') AS combined_capacity;", "generated_sql": "SELECT SUM(capacity) AS combined_capacity \nFROM landfill_capacity \nWHERE city IN ('City A', 'City B');", "raw_model_output": "```sql\nSELECT SUM(capacity) AS combined_capacity \nFROM landfill_capacity \nWHERE city IN ('City A', 'City B');\n```", "latency_sec": 1.114790916442871, "total_duration_sec": 1.048857212, "load_duration_sec": 0.015677538, "tokens_prompt": 817, "prompt_eval_sec": 0.328153154, "tokens_completion": 29, "completion_eval_sec": 0.701177008, "tokens_total": 846, "tokens_per_sec": 758.886700206939, "retrieval_latency_sec": 0.11269497871398926, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of capacities for 'City A' and 'City B'. The reference query uses a subquery with UNION ALL to combine the two cities' capacities before summing, while the generated query uses WHERE city IN to directly filter and sum the same values. Since UNION ALL preserves all rows and the WHERE IN clause achieves the same filtering, the final SUM is identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the combined landfill capacity for 'City A' and 'City B'. The Reference query uses a subquery with UNION ALL to isolate the two cities' capacities before summing, while the Generated query directly filters and sums the capacities in a single step. Technically, they produce identical results. However, the Generated query is more efficient as it avoids unnecessary subquery overhead and directly leverages the WHERE clause with IN. The business intent of summing capacities for the specified cities is fulfilled equally by both, but the Generated version is more elegant and performant.", "overall_assessment": "correct"}}
{"example_id": 880, "sql_complexity": "aggregation", "prompt": "Show veteran employment statistics for each state in the 'veteran_employment' table", "context": "CREATE TABLE veteran_employment (employee_id INT, state VARCHAR(2), job_title VARCHAR(50), employment_date DATE);", "reference_sql": "SELECT state, COUNT(*) as veteran_employees FROM veteran_employment WHERE state IN ('CA', 'NY', 'TX', 'FL', 'PA') GROUP BY state;", "generated_sql": "SELECT state, COUNT(*) as veteran_employees \nFROM veteran_employment \nGROUP BY state;", "raw_model_output": "```sql\nSELECT state, COUNT(*) as veteran_employees \nFROM veteran_employment \nGROUP BY state;\n```", "latency_sec": 0.9159491062164307, "total_duration_sec": 0.843119878, "load_duration_sec": 0.015775217, "tokens_prompt": 624, "prompt_eval_sec": 0.283388917, "tokens_completion": 24, "completion_eval_sec": 0.540352403, "tokens_total": 648, "tokens_per_sec": 707.4628880601618, "retrieval_latency_sec": 0.1092216968536377, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a WHERE clause filtering records to only 'CA', 'NY', 'TX', 'FL', 'PA' states, while the Generated SQL groups all states without filtering. If the table contains records from other states, the Generated SQL would include those in the count, making the results different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because the reference query explicitly filters for specific states ('CA', 'NY', 'TX', 'FL', 'PA') while the generated query includes all states. The original question asks for statistics 'for each state' without restricting to specific states, making the generated query more aligned with the business intent. The reference query's state filter introduces an implicit constraint not mentioned in the question, potentially excluding relevant data. The generated query is more elegant as it directly addresses the general requirement to show statistics per state without unnecessary restrictions.", "overall_assessment": "differently_correct"}}
{"example_id": 454, "sql_complexity": "single join", "prompt": "Which excavation sites have more than 10 artifacts?", "context": "CREATE TABLE ExcavationSite (SiteID INT, SiteName VARCHAR(50)); INSERT INTO ExcavationSite (SiteID, SiteName) VALUES (1, 'Site A'), (2, 'Site B'), (3, 'Site C'); CREATE TABLE Artifact (ArtifactID INT, SiteID INT, ObjectType VARCHAR(50)); INSERT INTO Artifact (ArtifactID, SiteID, ObjectType) VALUES (1, 1, 'Pottery'), (2, 1, 'Tool'), (3, 2, 'Statue'), (4, 2, 'Bead'), (5, 3, 'Bead'), (6, 3, 'Bead'), (7, 3, 'Bead'), (8, 3, 'Bead'), (9, 3, 'Bead'), (10, 3, 'Bead'), (11, 3, 'Bead');", "reference_sql": "SELECT e.SiteName FROM ExcavationSite e JOIN Artifact a ON e.SiteID = a.SiteID GROUP BY e.SiteName HAVING COUNT(a.ArtifactID) > 10;", "generated_sql": "SELECT e.SiteName \nFROM ExcavationSite e \nJOIN Artifact a ON e.SiteID = a.SiteID \nGROUP BY e.SiteName \nHAVING COUNT(a.ArtifactID) > 10;", "raw_model_output": "```sql\nSELECT e.SiteName \nFROM ExcavationSite e \nJOIN Artifact a ON e.SiteID = a.SiteID \nGROUP BY e.SiteName \nHAVING COUNT(a.ArtifactID) > 10;\n```", "latency_sec": 1.9765119552612305, "total_duration_sec": 1.679548013, "load_duration_sec": 0.020142167, "tokens_prompt": 1131, "prompt_eval_sec": 0.552456559, "tokens_completion": 48, "completion_eval_sec": 1.099438992, "tokens_total": 1179, "tokens_per_sec": 596.5053724373626, "retrieval_latency_sec": 0.10675716400146484, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure, syntax, and logic. Both queries perform the same operations: joining the ExcavationSite and Artifact tables on SiteID, grouping by SiteName, and filtering groups with more than 10 artifacts. Since the queries are exactly the same, they will produce identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure, logic, and output. They correctly join the ExcavationSite and Artifact tables, group by site name, and filter sites with more than 10 artifacts using COUNT(a.ArtifactID) > 10. The schema shows no sites meet this condition (Site C has 7 artifacts), but the queries are technically sound and fulfill the business intent of identifying sites with over 10 artifacts. The formatting differences (line breaks/indentation) do not affect functionality.", "overall_assessment": "correct"}}
{"example_id": 1086, "sql_complexity": "aggregation", "prompt": "What is the total CO2 emission for each equipment type, excluding equipment that is older than 8 years?", "context": "CREATE TABLE EmissionData (EquipmentID INT, EquipmentType VARCHAR(50), CO2Emission INT, Age INT); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (1, 'Excavator', 50, 8); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (2, 'Haul Truck', 70, 7); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (3, 'Shovel', 30, 6); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (4, 'Drilling Rig', 40, 3);", "reference_sql": "SELECT EquipmentType, SUM(CO2Emission) as TotalCO2Emission FROM EmissionData WHERE Age <= 8 GROUP BY EquipmentType;", "generated_sql": "SELECT EquipmentType, SUM(CO2Emission) AS TotalCO2Emission \nFROM EmissionData \nWHERE Age <= 8 \nGROUP BY EquipmentType;", "raw_model_output": "```sql\nSELECT EquipmentType, SUM(CO2Emission) AS TotalCO2Emission \nFROM EmissionData \nWHERE Age <= 8 \nGROUP BY EquipmentType;\n```", "latency_sec": 1.354255199432373, "total_duration_sec": 1.327272834, "load_duration_sec": 0.015329659, "tokens_prompt": 868, "prompt_eval_sec": 0.350349635, "tokens_completion": 39, "completion_eval_sec": 0.957397735, "tokens_total": 907, "tokens_per_sec": 669.740829040319, "retrieval_latency_sec": 0.11551785469055176, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select EquipmentType and sum CO2Emission where Age <= 8, grouping by EquipmentType. The only difference is formatting (line breaks/spaces), which does not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure, logic, and output. They correctly filter equipment with Age <= 8, group by EquipmentType, and calculate total CO2 emissions. The WHERE clause explicitly excludes equipment older than 8 years as required. The GROUP BY and SUM operations properly aggregate emissions per equipment type. No differences exist in syntax, semantics, or efficiency between the two queries.", "overall_assessment": "correct"}}
{"example_id": 3455, "sql_complexity": "basic SQL", "prompt": "What are the names of all innovation projects in the 'rural_infrastructure' table, excluding those with a budget over 50000?", "context": "CREATE TABLE rural_infrastructure (name VARCHAR(255), budget INT); INSERT INTO rural_infrastructure (name, budget) VALUES ('Dam Construction', 40000), ('Well Digging', 30000), ('Irrigation System', 70000);", "reference_sql": "SELECT name FROM rural_infrastructure WHERE budget <= 50000;", "generated_sql": "SELECT name FROM rural_infrastructure WHERE budget <= 50000;", "raw_model_output": "```sql\nSELECT name FROM rural_infrastructure WHERE budget <= 50000;\n```", "latency_sec": 1.1982920169830322, "total_duration_sec": 0.941231786, "load_duration_sec": 0.013921009, "tokens_prompt": 957, "prompt_eval_sec": 0.366064163, "tokens_completion": 21, "completion_eval_sec": 0.558173353, "tokens_total": 978, "tokens_per_sec": 816.1616585432434, "retrieval_latency_sec": 0.10733175277709961, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They select the 'name' column from the 'rural_infrastructure' table where the 'budget' is less than or equal to 50000. The schema and data confirm the condition will filter the same rows (Dam Construction and Well Digging).", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic. They correctly select project names from the rural_infrastructure table where budget is less than or equal to 50000, which directly addresses the requirement to exclude projects with budgets over 50000. The queries are semantically equivalent, technically correct, and efficiently achieve the business goal. Since the reference and generated queries are exactly the same, neither is superior to the other.", "overall_assessment": "correct"}}
{"example_id": 3936, "sql_complexity": "window functions", "prompt": "What is the total investment per client for each investment type?", "context": "CREATE TABLE clients (client_id INT, name TEXT, investment_type TEXT, investment FLOAT); INSERT INTO clients (client_id, name, investment_type, investment) VALUES (1, 'John Doe', 'Stocks', 3000.00), (1, 'John Doe', 'Bonds', 2000.00), (2, 'Jane Smith', 'Stocks', 5000.00);", "reference_sql": "SELECT client_id, name, investment_type, SUM(investment) OVER (PARTITION BY client_id, investment_type ORDER BY client_id) as total_investment FROM clients;", "generated_sql": "SELECT client_id, investment_type, SUM(investment) AS total_investment \nFROM clients \nGROUP BY client_id, investment_type;", "raw_model_output": "```sql\nSELECT client_id, investment_type, SUM(investment) AS total_investment \nFROM clients \nGROUP BY client_id, investment_type;\n```", "latency_sec": 1.4095687866210938, "total_duration_sec": 1.112344622, "load_duration_sec": 0.016208192, "tokens_prompt": 806, "prompt_eval_sec": 0.326083361, "tokens_completion": 32, "completion_eval_sec": 0.765874855, "tokens_total": 838, "tokens_per_sec": 594.5080566155178, "retrieval_latency_sec": 0.10913896560668945, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL uses a window function to retain individual rows with aggregated sums, including the 'name' column. The Generated SQL aggregates rows via GROUP BY, omitting the 'name' column and reducing the result set to one row per (client_id, investment_type) group. The output structures and row counts differ.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query uses a window function to calculate a running total per client/investment type but retains all rows with duplicated totals, which is inefficient and unnecessary. The generated query correctly aggregates investment amounts using GROUP BY, producing one row per client-investment type combination with the accurate total. While both queries involve SUM, their output structures differ: the reference retains row-level details with redundant totals, whereas the generated query directly answers the business question by summarizing data. The generated query is more efficient and semantically aligned with the requirement for 'total investment per client for each investment type'.", "overall_assessment": "correct"}}
{"example_id": 1838, "sql_complexity": "window functions", "prompt": "What are the top 3 species with the most sightings across all arctic research stations?", "context": "CREATE TABLE research_station (id INT, name TEXT); INSERT INTO research_station (id, name) VALUES (1, 'Station A'); INSERT INTO research_station (id, name) VALUES (2, 'Station B'); CREATE TABLE species_observations (station_id INT, species_name TEXT, sightings INT); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (1, 'Species 1', 10); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (1, 'Species 2', 5); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (2, 'Species 1', 8); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (2, 'Species 3', 15);", "reference_sql": "SELECT species_name, SUM(sightings) as total_sightings, RANK() OVER (ORDER BY SUM(sightings) DESC) as rank FROM species_observations GROUP BY species_name HAVING rank <= 3;", "generated_sql": "SELECT species_name, SUM(sightings) AS total_sightings \nFROM species_observations \nGROUP BY species_name \nORDER BY total_sightings DESC \nLIMIT 3;", "raw_model_output": "```sql\nSELECT species_name, SUM(sightings) AS total_sightings \nFROM species_observations \nGROUP BY species_name \nORDER BY total_sightings DESC \nLIMIT 3;\n```", "latency_sec": 1.6217231750488281, "total_duration_sec": 1.532683225, "load_duration_sec": 0.022267687, "tokens_prompt": 1116, "prompt_eval_sec": 0.549221209, "tokens_completion": 42, "completion_eval_sec": 0.954362759, "tokens_total": 1158, "tokens_per_sec": 714.0552825639518, "retrieval_latency_sec": 0.11024999618530273, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL attempts to use a window function (RANK()) in the HAVING clause, which is invalid syntax in standard SQL. Additionally, even if the Reference SQL were valid, it would return an extra 'rank' column not present in the Generated SQL. The Generated SQL correctly retrieves the top 3 species by total sightings using ORDER BY and LIMIT, while the Reference SQL's structure would either fail or produce a different result set.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL contains a critical technical error: the HAVING clause attempts to filter using 'rank', which is an alias from the SELECT clause. In SQL, aliases cannot be used in HAVING clauses. Additionally, RANK() over (ORDER BY SUM(sightings) DESC) would require a window frame specification and would not behave as intended in this context. The Generated SQL correctly groups by species, sums sightings, orders by total sightings in descending order, and limits to 3 results, which directly answers the business question. While both queries aim to fulfill the intent, the Generated SQL is technically correct and more efficient.", "overall_assessment": "incorrect"}}
{"example_id": 3091, "sql_complexity": "single join", "prompt": "Find the number of hybrid vehicles sold in the US, Germany, and Japan.", "context": "CREATE TABLE vehicle_sales (sale_id INT, vehicle_id INT, country VARCHAR(20), quantity INT); CREATE TABLE vehicles (vehicle_id INT, model VARCHAR(20), manufacture VARCHAR(20), vehicle_type VARCHAR(20));", "reference_sql": "SELECT SUM(vs.quantity) FROM vehicle_sales vs JOIN vehicles v ON vs.vehicle_id = v.vehicle_id WHERE v.vehicle_type = 'hybrid' AND vs.country IN ('US', 'Germany', 'Japan');", "generated_sql": "SELECT SUM(quantity) \nFROM vehicle_sales \nWHERE country IN ('US', 'Germany', 'Japan') \nAND vehicle_id IN (SELECT vehicle_id FROM vehicles WHERE vehicle_type = 'Hybrid');", "raw_model_output": "```sql\nSELECT SUM(quantity) \nFROM vehicle_sales \nWHERE country IN ('US', 'Germany', 'Japan') \nAND vehicle_id IN (SELECT vehicle_id FROM vehicles WHERE vehicle_type = 'Hybrid');\n```", "latency_sec": 1.577345848083496, "total_duration_sec": 1.418107848, "load_duration_sec": 0.017937242, "tokens_prompt": 824, "prompt_eval_sec": 0.328370359, "tokens_completion": 45, "completion_eval_sec": 1.06891457, "tokens_total": 869, "tokens_per_sec": 550.9254682832245, "retrieval_latency_sec": 0.11545515060424805, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the vehicle_type filter case ('hybrid' vs 'Hybrid'). While the logical structure is equivalent (both filter hybrid vehicles in specified countries), the case sensitivity of the database could cause a discrepancy. If the database is case-sensitive, the generated query would not match 'hybrid' entries, making them non-equivalent. Assuming case-insensitive comparison, they would be equivalent, but the explicit case difference introduces ambiguity.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent due to a case sensitivity discrepancy in the vehicle_type filter ('hybrid' vs 'Hybrid'). The reference query uses lowercase 'hybrid' which may not match data stored as 'Hybrid' in some case-sensitive databases. Both queries correctly aggregate quantities for the specified countries and hybrid vehicles, fulfilling the business intent. The reference query is more efficient and elegant with an explicit JOIN, while the generated query uses a subquery that could be less performant. The reference better aligns with standard SQL practices for readability and maintainability.", "overall_assessment": "differently_correct"}}
{"example_id": 2399, "sql_complexity": "set operations", "prompt": "What is the average duration of criminal trials for Indigenous defendants compared to non-Indigenous defendants in Canada and New Zealand?", "context": "CREATE TABLE canada_criminal_trials (id INT, defendant_type VARCHAR(255), days_to_completion INT); INSERT INTO canada_criminal_trials (id, defendant_type, days_to_completion) VALUES (1, 'Indigenous', 60), (2, 'Non-Indigenous', 45);CREATE TABLE nz_criminal_trials (id INT, defendant_type VARCHAR(255), days_to_completion INT); INSERT INTO nz_criminal_trials (id, defendant_type, days_to_completion) VALUES (1, 'Indigenous', 70), (2, 'Non-Indigenous', 50);", "reference_sql": "SELECT AVG(days_to_completion) AS avg_duration FROM canada_criminal_trials WHERE defendant_type = 'Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM canada_criminal_trials WHERE defendant_type = 'Non-Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM nz_criminal_trials WHERE defendant_type = 'Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM nz_criminal_trials WHERE defendant_type = 'Non-Indigenous';", "generated_sql": "SELECT \n    defendant_type, \n    AVG(days_to_completion) AS average_days_to_completion\nFROM (\n    SELECT defendant_type, days_to_completion FROM canada_criminal_trials\n    UNION ALL\n    SELECT defendant_type, days_to_completion FROM nz_criminal_trials\n) AS combined_trials\nGROUP BY defendant_type;", "raw_model_output": "To find the average duration of criminal trials for Indigenous defendants compared to non-Indigenous defendants in Canada and New Zealand, we need to calculate the average `days_to_completion` for each category (Indigenous and Non-Indigenous) from both tables (`canada_criminal_trials` and `nz_criminal_trials`). We will then combine these results into a single dataset.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT \n    defendant_type, \n    AVG(days_to_completion) AS average_days_to_completion\nFROM (\n    SELECT defendant_type, days_to_completion FROM canada_criminal_trials\n    UNION ALL\n    SELECT defendant_type, days_to_completion FROM nz_criminal_trials\n) AS combined_trials\nGROUP BY defendant_type;\n```\n\nExplanation:\n1. We use a subquery to combine the data from both `canada_criminal_trials` and `nz_criminal_trials` using `UNION ALL`.\n2. The outer query then groups the combined results by `defendant_type` and calculates the average `days_to_completion` for each group.\n3. The result will show the average duration of criminal trials for Indigenous and Non-Indigenous defendants in both Canada and New Zealand.", "latency_sec": 6.280303716659546, "total_duration_sec": 6.080294091, "load_duration_sec": 0.015921962, "tokens_prompt": 940, "prompt_eval_sec": 0.366840674, "tokens_completion": 244, "completion_eval_sec": 5.693386578, "tokens_total": 1184, "tokens_per_sec": 188.52591425781588, "retrieval_latency_sec": 0.11400175094604492, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates separate averages for each defendant_type within each country (4 total rows), while the Generated SQL combines data from both countries and averages across all entries per defendant_type (2 total rows). The Generated SQL's averages are arithmetic means of combined datasets, whereas the Reference SQL's averages are per-country metrics. For example, the Generated SQL's 'Indigenous' average would be (60+70)/2=65, but the Reference SQL shows 60 (Canada) and 70 (NZ) as separate rows.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly separates Canada and New Zealand data, producing four rows: Canada Indigenous, Canada Non-Indigenous, NZ Indigenous, NZ Non-Indigenous. The generated query combines data from both countries into a single aggregate, losing the country distinction. While the generated query is more efficient, it fails to address the business intent of comparing Indigenous vs. non-Indigenous defendants within each country separately. The reference query explicitly fulfills the requirement to compare both jurisdictions.", "overall_assessment": "differently_correct"}}
{"example_id": 2972, "sql_complexity": "set operations", "prompt": "How many indigenous communities are in the Arctic Research Station 13 and 14?", "context": "CREATE TABLE Arctic_Research_Station_13 (id INT, community TEXT); CREATE TABLE Arctic_Research_Station_14 (id INT, community TEXT);", "reference_sql": "SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_13; SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_14; SELECT COUNT(DISTINCT community) FROM (SELECT * FROM Arctic_Research_Station_13 UNION ALL SELECT * FROM Arctic_Research_Station_14) AS Arctic_Communities;", "generated_sql": "SELECT COUNT(DISTINCT community) \nFROM (\n    SELECT community FROM Arctic_Research_Station_13\n    UNION ALL\n    SELECT community FROM Arctic_Research_Station_14\n) AS Arctic_Communities;", "raw_model_output": "```sql\nSELECT COUNT(DISTINCT community) \nFROM (\n    SELECT community FROM Arctic_Research_Station_13\n    UNION ALL\n    SELECT community FROM Arctic_Research_Station_14\n) AS Arctic_Communities;\n```", "latency_sec": 1.8951070308685303, "total_duration_sec": 1.49008975, "load_duration_sec": 0.015361932, "tokens_prompt": 693, "prompt_eval_sec": 0.297261043, "tokens_completion": 51, "completion_eval_sec": 1.173723731, "tokens_total": 744, "tokens_per_sec": 392.58996345922674, "retrieval_latency_sec": 0.10820698738098145, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The Generated SQL is semantically equivalent to the third query in the Reference SQL. Both combine communities from both tables using UNION ALL and count distinct values. The first two queries in the Reference (counting individual tables) are not part of the comparison, and the Generated SQL matches the third query's logic.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count distinct communities across both stations. The reference's third query and generated query produce identical results by combining data from both tables and counting unique communities. However, the generated query is more efficient as it explicitly selects only the 'community' column (avoiding unnecessary 'id' columns) and uses a simpler subquery structure. The reference's third query includes all columns (id and community) in the UNION ALL, which is technically correct but less optimized. Both fulfill the business intent of counting unique indigenous communities across stations 13 and 14.", "overall_assessment": "correct"}}
{"example_id": 5576, "sql_complexity": "window functions", "prompt": "Who are the top 5 users with the most followers, and what is their location?", "context": "CREATE TABLE user_data (user_id INT, name VARCHAR(50), followers INT, location VARCHAR(50)); INSERT INTO user_data (user_id, name, followers, location) VALUES (1, 'Alice', 10000, 'New York'), (2, 'Bob', 15000, 'California'), (3, 'Charlie', 12000, 'Texas'), (4, 'David', 8000, 'Florida'), (5, 'Eve', 9000, 'Illinois');", "reference_sql": "SELECT name, location FROM (SELECT name, location, ROW_NUMBER() OVER (ORDER BY followers DESC) AS rank FROM user_data) AS user_ranks WHERE rank <= 5;", "generated_sql": "SELECT name, location \nFROM user_data \nORDER BY followers DESC \nLIMIT 5;", "raw_model_output": "```sql\nSELECT name, location \nFROM user_data \nORDER BY followers DESC \nLIMIT 5;\n```", "latency_sec": 1.104767084121704, "total_duration_sec": 1.000064825, "load_duration_sec": 0.021462474, "tokens_prompt": 936, "prompt_eval_sec": 0.373312844, "tokens_completion": 23, "completion_eval_sec": 0.597260127, "tokens_total": 959, "tokens_per_sec": 868.0562751943413, "retrieval_latency_sec": 0.11319494247436523, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the top 5 users by followers. The Reference SQL uses ROW_NUMBER() to assign ranks and filters for rank <=5, while the Generated SQL uses ORDER BY followers DESC with LIMIT 5. Since the ordering is identical and both methods select the top 5 rows, the results will be the same.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly retrieve the top 5 users by followers and their locations. The Reference SQL uses a subquery with ROW_NUMBER() to assign ranks and filter results, while the Generated SQL directly orders by followers and applies LIMIT 5. Technically, they produce identical results in this specific case because the data has unique follower counts. However, the Generated SQL is more efficient and elegant, as it avoids unnecessary subquery complexity. Both fulfill the business intent, but the Generated version is superior for its simplicity and performance.", "overall_assessment": "correct"}}
{"example_id": 1560, "sql_complexity": "basic SQL", "prompt": "What is the average media literacy score for users in the 'Young Adult' age group who have completed at least one disinformation detection course?", "context": "CREATE TABLE users (id INT, age VARCHAR(20), media_literacy_score INT, courses_completed INT);", "reference_sql": "SELECT AVG(media_literacy_score) FROM users WHERE age = 'Young Adult' AND courses_completed > 0;", "generated_sql": "SELECT AVG(media_literacy_score) \nFROM users \nWHERE age = 'Young Adult' AND courses_completed > 0;", "raw_model_output": "```sql\nSELECT AVG(media_literacy_score) \nFROM users \nWHERE age = 'Young Adult' AND courses_completed > 0;\n```", "latency_sec": 1.0889337062835693, "total_duration_sec": 0.972713353, "load_duration_sec": 0.015266934, "tokens_prompt": 564, "prompt_eval_sec": 0.144186162, "tokens_completion": 31, "completion_eval_sec": 0.808832559, "tokens_total": 595, "tokens_per_sec": 546.4060819925212, "retrieval_latency_sec": 0.11334085464477539, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the average media_literacy_score from the users table with identical WHERE conditions (age = 'Young Adult' AND courses_completed > 0). The generated SQL has identical logic but different formatting (line breaks/whitespace), which does not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic. They correctly calculate the average media literacy score for users aged 'Young Adult' with courses_completed > 0. The WHERE clause accurately filters for the specified age group and course completion requirement. The query is technically correct, semantically equivalent, and efficiently addresses the business question. Since the queries are identical, neither is superior to the other.", "overall_assessment": "correct"}}
{"example_id": 1201, "sql_complexity": "basic SQL", "prompt": "What is the maximum energy efficiency rating of hydroelectric dams in Canada?", "context": "CREATE TABLE hydro_dams (id INT, name TEXT, country TEXT, energy_efficiency_rating FLOAT); INSERT INTO hydro_dams (id, name, country, energy_efficiency_rating) VALUES (1, 'Robert-Bourassa', 'Canada', 0.94), (2, 'Churchill Falls', 'Canada', 0.92);", "reference_sql": "SELECT MAX(energy_efficiency_rating) FROM hydro_dams WHERE country = 'Canada';", "generated_sql": "SELECT MAX(energy_efficiency_rating) FROM hydro_dams WHERE country = 'Canada';", "raw_model_output": "```sql\nSELECT MAX(energy_efficiency_rating) FROM hydro_dams WHERE country = 'Canada';\n```", "latency_sec": 1.1037647724151611, "total_duration_sec": 0.825806109, "load_duration_sec": 0.014818904, "tokens_prompt": 647, "prompt_eval_sec": 0.285511117, "tokens_completion": 23, "completion_eval_sec": 0.521454347, "tokens_total": 670, "tokens_per_sec": 607.0133933826904, "retrieval_latency_sec": 0.11295890808105469, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They select the maximum energy_efficiency_rating from the hydro_dams table where the country is 'Canada'. The SQL syntax, table name, column names, and conditions are exactly the same in both queries.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure, syntax, and logic. They correctly filter hydroelectric dams in Canada and calculate the maximum energy efficiency rating. The queries are semantically equivalent, produce identical results, and fully address the business intent of identifying the highest efficiency rating for Canadian hydro dams. Neither query demonstrates superior efficiency or elegance as they are mathematically and operationally identical.", "overall_assessment": "correct"}}
{"example_id": 4243, "sql_complexity": "single join", "prompt": "How many orders were placed by new and returning customers in each month of the year 2021?'", "context": "CREATE TABLE customer (id INT, first_order_date DATE, last_order_date DATE);", "reference_sql": "INSERT INTO customer (id, first_order_date, last_order_date) SELECT customer_id, MIN(order_date) AS first_order_date, MAX(order_date) AS last_order_date FROM orders GROUP BY customer_id; SELECT YEAR(order_date) AS year, MONTH(order_date) AS month, CASE WHEN DATEDIFF(last_order_date, first_order_date) > 30 THEN 'returning' ELSE 'new' END AS customer_type, COUNT(DISTINCT id) AS num_orders FROM orders JOIN customer ON orders.customer_id = customer.id WHERE YEAR(order_date) = 2021 GROUP BY year, month, customer_type;", "generated_sql": "SELECT \n    DATE_FORMAT(first_order_date, '%Y-%m') AS month,\n    COUNT(*) FILTER (WHERE first_order_date = last_order_date) AS new_customers,\n    COUNT(*) FILTER (WHERE first_order_date < last_order_date) AS returning_customers\nFROM \n    customer\nWHERE \n    YEAR(first_order_date) = 2021\nGROUP BY \n    month;", "raw_model_output": "To determine the number of orders placed by new and returning customers in each month of the year 2021, we need to analyze the `first_order_date` and `last_order_date` columns in the `customer` table. New customers are those who made their first order in a given month, while returning customers are those who had previous orders before that month.\n\nHere's the SQL query to achieve this:\n\n```sql\nSELECT \n    DATE_FORMAT(first_order_date, '%Y-%m') AS month,\n    COUNT(*) FILTER (WHERE first_order_date = last_order_date) AS new_customers,\n    COUNT(*) FILTER (WHERE first_order_date < last_order_date) AS returning_customers\nFROM \n    customer\nWHERE \n    YEAR(first_order_date) = 2021\nGROUP BY \n    month;\n```\n\n### Explanation:\n- **DATE_FORMAT(first_order_date, '%Y-%m')**: Extracts the year and month from the `first_order_date`.\n- **COUNT(*) FILTER (WHERE first_order_date = last_order_date)**: Counts customers who made their first order in that month and no subsequent orders.\n- **COUNT(*) FILTER (WHERE first_order_date < last_order_date)**: Counts customers who had previous orders before that month, indicating they are returning customers.\n- **WHERE YEAR(first_order_date) = 2021**: Filters the records to include only those from the year 2021.\n- **GROUP BY month**: Groups the results by month.", "latency_sec": 7.603924036026001, "total_duration_sec": 7.42670611, "load_duration_sec": 0.022708263, "tokens_prompt": 786, "prompt_eval_sec": 0.319999976, "tokens_completion": 307, "completion_eval_sec": 7.081228622, "tokens_total": 1093, "tokens_per_sec": 143.74157274869737, "retrieval_latency_sec": 0.11375689506530762, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query analyzes orders (counting distinct customer IDs per month/customer_type) based on order dates and customer first/last order date differences. The generated query counts customers directly from the customer table, using a different definition of 'new' (first_order_date = last_order_date) and grouping by month. Key differences include: 1) Data source (orders vs customer table), 2) Aggregation logic (orders vs customers), 3) Customer type definition (DATEDIFF vs equality), and 4) Output metrics (num_orders vs customer counts).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "equal", "explanation": "The queries are not technically equivalent because they fundamentally differ in their approach. The reference SQL attempts to count orders (though incorrectly using COUNT(DISTINCT id) instead of COUNT(*) on the orders table) while the generated SQL counts customers. Neither query correctly addresses the original question, which requires counting orders, not customers. The reference SQL's logic for determining 'new' vs 'returning' customers (based on DATEDIFF between first and last order dates) is flawed, as it doesn't account for monthly context. The generated SQL incorrectly assumes that first_order_date = last_order_date implies a 'new' customer, which is not a valid definition for the question's requirements. Both queries fail to accurately count orders and misinterpret the business intent.", "overall_assessment": "incorrect"}}
{"example_id": 2321, "sql_complexity": "subqueries", "prompt": "What are the names and types of vessels used in research expeditions in the regions with the lowest ocean acidification levels?", "context": "CREATE TABLE ocean_acidification (id INT PRIMARY KEY, region VARCHAR(255), year INT, acidification_level INT); INSERT INTO ocean_acidification (id, region, year, acidification_level) VALUES (1, 'Arctic Ocean', 2018, 20), (2, 'Southern Ocean', 2019, 22); CREATE TABLE expedition_vessels (id INT PRIMARY KEY, name VARCHAR(255), type VARCHAR(255), region VARCHAR(255)); INSERT INTO expedition_vessels (id, name, type, region) VALUES (1, 'Sea Researcher', 'Research Vessel', 'Arctic Ocean');", "reference_sql": "SELECT v.name, v.type FROM expedition_vessels v INNER JOIN ocean_acidification oa ON v.region = oa.region WHERE oa.acidification_level = (SELECT MIN(acidification_level) FROM ocean_acidification);", "generated_sql": "SELECT name, type \nFROM expedition_vessels \nWHERE region IN (\n    SELECT region \n    FROM ocean_acidification \n    ORDER BY acidification_level ASC \n    LIMIT 1\n);", "raw_model_output": "To find the names and types of vessels used in research expeditions in the regions with the lowest ocean acidification levels, we need to follow these steps:\n\n1. Identify the region(s) with the lowest ocean acidification level.\n2. Select the names and types of vessels from the `expedition_vessels` table that operate in those regions.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT name, type \nFROM expedition_vessels \nWHERE region IN (\n    SELECT region \n    FROM ocean_acidification \n    ORDER BY acidification_level ASC \n    LIMIT 1\n);\n```\n\nExplanation:\n- The subquery `SELECT region FROM ocean_acidification ORDER BY acidification_level ASC LIMIT 1` finds the region with the lowest ocean acidification level.\n- The main query selects the `name` and `type` of vessels from the `expedition_vessels` table where the `region` matches the result of the subquery.", "latency_sec": 5.277878999710083, "total_duration_sec": 5.025583117, "load_duration_sec": 0.021616299, "tokens_prompt": 902, "prompt_eval_sec": 0.35623451, "tokens_completion": 199, "completion_eval_sec": 4.643446953, "tokens_total": 1101, "tokens_per_sec": 208.60652547367582, "retrieval_latency_sec": 0.11719894409179688, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL finds all regions with the minimum acidification_level (which could be multiple regions) and joins with vessels in those regions. The Generated SQL only selects a single region (due to LIMIT 1) from the ocean_acidification table, potentially missing other regions with the same minimum acidification_level. This makes them non-equivalent in cases where multiple regions share the minimum acidification_level.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The Reference SQL correctly identifies all regions with the absolute minimum acidification level using a subquery with MIN(), ensuring all relevant regions are considered. It then joins with expedition_vessels to get vessels in those regions. The Generated SQL only selects the single region with the lowest acidification level (due to LIMIT 1), potentially missing other regions with the same minimum value. While both queries address the core intent, the Reference is more accurate for the business question as it accounts for all regions with the lowest levels. The Generated SQL is technically correct but less comprehensive.", "overall_assessment": "correct"}}
{"example_id": 4349, "sql_complexity": "multiple_joins", "prompt": "Show the research grants awarded to professors in the Computer Science department.", "context": "CREATE TABLE departments (id INT, name VARCHAR(50)); INSERT INTO departments (id, name) VALUES (1, 'Computer Science'), (2, 'Mathematics'); CREATE TABLE professors (id INT, name VARCHAR(50), department_id INT); INSERT INTO professors (id, name, department_id) VALUES (1, 'John Smith', 1), (2, 'Jane Doe', 2); CREATE TABLE grants (id INT, professor_id INT, year INT, amount FLOAT); INSERT INTO grants (id, professor_id, year, amount) VALUES (1, 1, 2021, 5000.0), (2, 2, 2020, 7000.0);", "reference_sql": "SELECT professors.name, grants.amount FROM professors INNER JOIN grants ON professors.id = grants.professor_id INNER JOIN departments ON professors.department_id = departments.id WHERE departments.name = 'Computer Science';", "generated_sql": "SELECT g.id, g.year, g.amount \nFROM grants g \nJOIN professors p ON g.professor_id = p.id \nJOIN departments d ON p.department_id = d.id \nWHERE d.name = 'Computer Science';", "raw_model_output": "```sql\nSELECT g.id, g.year, g.amount \nFROM grants g \nJOIN professors p ON g.professor_id = p.id \nJOIN departments d ON p.department_id = d.id \nWHERE d.name = 'Computer Science';\n```", "latency_sec": 1.608595848083496, "total_duration_sec": 1.585703819, "load_duration_sec": 0.020697909, "tokens_prompt": 879, "prompt_eval_sec": 0.348059042, "tokens_completion": 50, "completion_eval_sec": 1.209441103, "tokens_total": 929, "tokens_per_sec": 577.5223161907472, "retrieval_latency_sec": 0.11243391036987305, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects professors' names and grant amounts, while the Generated SQL selects grant IDs, years, and amounts. The selected columns differ, leading to different result sets even though both filter for 'Computer Science' department professors.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent as they select different columns (reference includes professor names, generated focuses on grant details). Both correctly fulfill the business intent by identifying grants awarded to Computer Science professors through equivalent joins and filters. The generated query is more elegant with table aliases and focuses specifically on grant attributes (ID, year, amount) which directly answers 'research grants' without additional professor metadata. The reference query includes unnecessary professor names for this specific question.", "overall_assessment": "differently_correct"}}
{"example_id": 476, "sql_complexity": "basic SQL", "prompt": "Insert new food safety records for locations \"A123\", \"B456\", and \"C789\"", "context": "CREATE TABLE food_safety_records (id INT, location VARCHAR(255), inspection_date DATE, violation_count INT);", "reference_sql": "INSERT INTO food_safety_records (location, inspection_date, violation_count) VALUES ('A123', '2022-03-01', 0), ('B456', '2022-03-05', 2), ('C789', '2022-03-10', 1);", "generated_sql": "INSERT INTO food_safety_records (location, inspection_date, violation_count) \nVALUES ('A123', CURRENT_DATE, 0), \n       ('B456', CURRENT_DATE, 0), \n       ('C789', CURRENT_DATE, 0);", "raw_model_output": "```sql\nINSERT INTO food_safety_records (location, inspection_date, violation_count) \nVALUES ('A123', CURRENT_DATE, 0), \n       ('B456', CURRENT_DATE, 0), \n       ('C789', CURRENT_DATE, 0);\n```", "latency_sec": 1.9076542854309082, "total_duration_sec": 1.710869928, "load_duration_sec": 0.016339197, "tokens_prompt": 641, "prompt_eval_sec": 0.286080857, "tokens_completion": 62, "completion_eval_sec": 1.403711729, "tokens_total": 703, "tokens_per_sec": 368.51540940564274, "retrieval_latency_sec": 0.11105608940124512, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The two queries are not equivalent. The Reference SQL inserts specific dates (2022-03-01, 2022-03-05, 2022-03-10) and varying violation counts (0, 2, 1), while the Generated SQL uses CURRENT_DATE (which inserts the current date at execution time) and sets all violation_counts to 0. This results in different data being inserted.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because the reference SQL uses specific dates and violation counts while the generated SQL uses CURRENT_DATE and zeros. Both fulfill the business intent of inserting records for the specified locations, but the generated SQL is more dynamic and practical for real-world scenarios where current dates and default violation counts are appropriate. The generated query is more efficient and elegant as it avoids hardcoding values and uses database functions for accuracy.", "overall_assessment": "differently_correct"}}
{"example_id": 2908, "sql_complexity": "single join", "prompt": "List all co-owners and the properties they own in New York, NY.", "context": "CREATE TABLE properties (id INT, city VARCHAR(50), price INT); CREATE TABLE co_owners (property_id INT, owner_name VARCHAR(50)); INSERT INTO properties (id, city, price) VALUES (1, 'New York', 800000), (2, 'Los Angeles', 600000); INSERT INTO co_owners (property_id, owner_name) VALUES (1, 'David'), (1, 'Ella'), (2, 'Frank');", "reference_sql": "SELECT properties.city, co_owners.owner_name FROM properties INNER JOIN co_owners ON properties.id = co_owners.property_id WHERE properties.city = 'New York';", "generated_sql": "SELECT co_owners.owner_name, properties.id AS property_id \nFROM co_owners \nJOIN properties ON co_owners.property_id = properties.id \nWHERE properties.city = 'New York';", "raw_model_output": "```sql\nSELECT co_owners.owner_name, properties.id AS property_id \nFROM co_owners \nJOIN properties ON co_owners.property_id = properties.id \nWHERE properties.city = 'New York';\n```", "latency_sec": 1.4227750301361084, "total_duration_sec": 1.338475053, "load_duration_sec": 0.016636132, "tokens_prompt": 758, "prompt_eval_sec": 0.312776257, "tokens_completion": 43, "completion_eval_sec": 1.005245961, "tokens_total": 801, "tokens_per_sec": 562.9842969083968, "retrieval_latency_sec": 0.10993504524230957, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries select different columns. The Reference SQL returns (city, owner_name) while the Generated SQL returns (owner_name, property_id). Although both queries join the same tables and filter by 'New York', the output columns differ, making their result sets non-equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify co-owners of properties in New York via INNER JOIN and WHERE filtering. The Reference query includes the 'city' column which is redundant since the filter already enforces New York. The Generated query focuses on relevant columns (owner_name and property_id) directly addressing the business question. While both produce equivalent data, the Generated query is more elegant by omitting unnecessary columns and using explicit JOIN syntax. The output differences (column order and selection) don't affect semantic equivalence but the Generated version better aligns with the requested information.", "overall_assessment": "correct"}}
{"example_id": 636, "sql_complexity": "set operations", "prompt": "Insert new data into the 'cosmetic_ingredients' table for a vegan eyeshadow product by brand 'Ara' with ingredients 'Mica', 'Iron Oxide', 'Titanium Dioxide' and 'Zinc Oxide'.", "context": "CREATE TABLE cosmetic_ingredients (ingredient_id INT, product_name TEXT, brand_name TEXT, ingredient_type TEXT);", "reference_sql": "INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type) VALUES (NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient'); INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type, ingredient_name) SELECT ingredient_id, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Mica' FROM cosmetic_ingredients WHERE ingredient_name = 'Mica' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Iron Oxide' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Titanium Dioxide' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Zinc Oxide';", "generated_sql": "INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type) \nVALUES ((SELECT MAX(ingredient_id) FROM cosmetic_ingredients)+1, 'Vegan Eyeshadow', 'Ara', 'Mica');\nINSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type) \nVALUES ((SELECT MAX(ingredient_id) FROM cosmetic_ingredients)+1, 'Vegan Eyeshadow', 'Ara', 'Iron Oxide');\nINSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type) \nVALUES ((SELECT MAX(ingredient_id) FROM cosmetic_ingredients)+1, 'Vegan Eyeshadow', 'Ara', 'Titanium Dioxide');\nINSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type) \nVALUES ((SELECT MAX(ingredient_id) FROM cosmetic_ingredients)+1, 'Vegan Eyeshadow', 'Ara', 'Zinc Oxide');", "raw_model_output": "```sql\nINSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type) \nVALUES ((SELECT MAX(ingredient_id) FROM cosmetic_ingredients)+1, 'Vegan Eyeshadow', 'Ara', 'Mica');\nINSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type) \nVALUES ((SELECT MAX(ingredient_id) FROM cosmetic_ingredients)+1, 'Vegan Eyeshadow', 'Ara', 'Iron Oxide');\nINSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type) \nVALUES ((SELECT MAX(ingredient_id) FROM cosmetic_ingredients)+1, 'Vegan Eyeshadow', 'Ara', 'Titanium Dioxide');\nINSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type) \nVALUES ((SELECT MAX(ingredient_id) FROM cosmetic_ingredients)+1, 'Vegan Eyeshadow', 'Ara', 'Zinc Oxide');\n```", "latency_sec": 5.30518913269043, "total_duration_sec": 5.127777363, "load_duration_sec": 0.014475461, "tokens_prompt": 756, "prompt_eval_sec": 0.314512418, "tokens_completion": 206, "completion_eval_sec": 4.794750384, "tokens_total": 962, "tokens_per_sec": 181.33189523294888, "retrieval_latency_sec": 0.11584305763244629, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL attempts to insert rows with a mix of static values and a SELECT that references a non-existent 'ingredient_name' column, leading to schema inconsistency. The Generated SQL inserts four rows with distinct 'ingredient_type' values (e.g., 'Mica', 'Iron Oxide') using sequentially generated IDs, while the Reference SQL's first INSERT sets 'ingredient_type' to 'Ingredient' and relies on a flawed SELECT clause. The data structure and logic differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference SQL contains critical errors: it references a non-existent 'ingredient_name' column in the schema and attempts to insert a generic 'Ingredient' type before adding specific ingredients. The generated SQL correctly uses the existing columns (ingredient_id, product_name, brand_name, ingredient_type) without referencing undefined fields. While both insert the required ingredients, the generated SQL avoids schema inconsistencies and executes without errors. The reference SQL's second INSERT clause is invalid due to the missing column, making it technically incorrect. The generated SQL's approach of using MAX(ingredient_id)+1 for sequential IDs is less ideal than auto-increment but still valid for this context.", "overall_assessment": "correct"}}
{"example_id": 3404, "sql_complexity": "multiple_joins", "prompt": "What are the names of startups that have received funding from investors with over 3 million funds, and are involved in Genetic Research or Bioprocess Engineering?", "context": "CREATE TABLE public.investors ( id SERIAL PRIMARY KEY, name VARCHAR(100), type VARCHAR(50), funds INTEGER ); CREATE TABLE public.investments ( id SERIAL PRIMARY KEY, investor_id INTEGER, startup_id INTEGER ); CREATE TABLE public.startups ( id SERIAL PRIMARY KEY, name VARCHAR(100), industry VARCHAR(50), funding INTEGER );", "reference_sql": "SELECT startups.name FROM public.startups JOIN public.investments ON startups.id = investments.startup_id JOIN public.investors ON investments.investor_id = investors.id WHERE (startups.industry = 'Genetic Research' OR startups.industry = 'Bioprocess Engineering') AND investors.funds > 3000000;", "generated_sql": "SELECT DISTINCT s.name \nFROM startups s \nJOIN investments i ON s.id = i.startup_id \nJOIN investors inv ON i.investor_id = inv.id \nWHERE inv.funds > 3000000 AND s.industry IN ('Genetic Research', 'Bioprocess Engineering');", "raw_model_output": "```sql\nSELECT DISTINCT s.name \nFROM startups s \nJOIN investments i ON s.id = i.startup_id \nJOIN investors inv ON i.investor_id = inv.id \nWHERE inv.funds > 3000000 AND s.industry IN ('Genetic Research', 'Bioprocess Engineering');\n```", "latency_sec": 2.0420939922332764, "total_duration_sec": 2.012964618, "load_duration_sec": 0.015994194, "tokens_prompt": 931, "prompt_eval_sec": 0.36503166, "tokens_completion": 68, "completion_eval_sec": 1.627800164, "tokens_total": 999, "tokens_per_sec": 489.20373097394645, "retrieval_latency_sec": 0.11334228515625, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their handling of duplicate results. The Generated SQL uses DISTINCT to eliminate duplicates, while the Reference SQL does not. If a startup meets the criteria through multiple investments or investors, the Reference SQL could return duplicate entries whereas the Generated SQL would not. This makes them semantically different in scenarios where duplicates are possible.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent due to the use of DISTINCT in the generated query, which prevents duplicate startup names when multiple investors meet the criteria. The reference query would return duplicates in such cases. Both correctly filter investors with >3M funds and startups in the specified industries, but the generated query's use of IN ('Genetic Research', 'Bioprocess Engineering') is more efficient and readable than the reference's OR condition. The generated query better fulfills the business intent by ensuring unique results, which aligns with the natural language question's implicit requirement for distinct startup names.", "overall_assessment": "differently_correct"}}
{"example_id": 134, "sql_complexity": "subqueries", "prompt": "Who are the top 3 authors with the most citations in the Mathematics department in the past 5 years?", "context": "CREATE TABLE authors (id INT, name VARCHAR(50), department VARCHAR(50)); INSERT INTO authors (id, name, department) VALUES (1, 'Author Name', 'Mathematics'); CREATE TABLE publications (id INT, title VARCHAR(100), author VARCHAR(50), journal VARCHAR(50), year INT, cites INT); INSERT INTO publications (id, title, author, journal, year, cites) VALUES (1, 'Publication Title', 'Author Name', 'Journal Name', 2021, 10);", "reference_sql": "SELECT author, SUM(cites) as total_cites FROM publications WHERE author IN (SELECT name FROM authors WHERE department = 'Mathematics') AND year BETWEEN YEAR(CURRENT_DATE) - 5 AND YEAR(CURRENT_DATE) GROUP BY author ORDER BY total_cites DESC LIMIT 3;", "generated_sql": "SELECT a.name \nFROM authors a \nJOIN publications p ON a.id = p.author \nWHERE a.department = 'Mathematics' AND p.year >= YEAR(CURRENT_DATE) - 5 \nGROUP BY a.name \nORDER BY SUM(p.cites) DESC \nLIMIT 3;", "raw_model_output": "```sql\nSELECT a.name \nFROM authors a \nJOIN publications p ON a.id = p.author \nWHERE a.department = 'Mathematics' AND p.year >= YEAR(CURRENT_DATE) - 5 \nGROUP BY a.name \nORDER BY SUM(p.cites) DESC \nLIMIT 3;\n```", "latency_sec": 1.9924333095550537, "total_duration_sec": 1.945695991, "load_duration_sec": 0.021475399, "tokens_prompt": 1059, "prompt_eval_sec": 0.400520509, "tokens_completion": 62, "completion_eval_sec": 1.515445708, "tokens_total": 1121, "tokens_per_sec": 562.6286182950532, "retrieval_latency_sec": 0.11140990257263184, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Generated SQL incorrectly joins authors.id (INT) with publications.author (VARCHAR), which would never match due to type mismatch. Additionally, the Reference SQL uses a subquery to filter authors by department, while the Generated SQL attempts a JOIN but with an invalid condition. The year condition is equivalent, but the join error makes the results fundamentally different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in critical technical aspects. The reference query correctly uses a subquery to filter Mathematics department authors and properly sums citations. The generated query incorrectly joins authors.id (INT) with publications.author (VARCHAR), which would cause a type mismatch error. Additionally, the generated query's JOIN condition is invalid, making it non-functional. While both aim to answer the business question, only the reference query is technically correct and would produce valid results.", "overall_assessment": "incorrect"}}
{"example_id": 592, "sql_complexity": "set operations", "prompt": "How many public healthcare facilities and public parks are there in total, in the 'StateData' schema's 'StateHealthcare' and 'StateParks' tables?", "context": "CREATE SCHEMA StateData; CREATE TABLE StateHealthcare (Name varchar(255), Type varchar(255)); INSERT INTO StateHealthcare (Name, Type) VALUES ('FacilityA', 'Public'), ('FacilityB', 'Public'), ('FacilityC', 'Private'); CREATE TABLE StateParks (Name varchar(255), Type varchar(255)); INSERT INTO StateParks (Name, Type) VALUES ('ParkA', 'Public'), ('ParkB', 'Public'), ('ParkC', 'Private');", "reference_sql": "SELECT COUNT(*) FROM StateData.StateHealthcare WHERE Type = 'Public' UNION ALL SELECT COUNT(*) FROM StateData.StateParks WHERE Type = 'Public';", "generated_sql": "SELECT \n    (SELECT COUNT(*) FROM StateData.StateHealthcare WHERE Type = 'Public') + \n    (SELECT COUNT(*) FROM StateData.StateParks WHERE Type = 'Public') AS Total_Public_Facilities_and_Parks;", "raw_model_output": "To find the total number of public healthcare facilities and public parks in the 'StateData' schema's 'StateHealthcare' and 'StateParks' tables, you can use the following SQL query:\n\n```sql\nSELECT \n    (SELECT COUNT(*) FROM StateData.StateHealthcare WHERE Type = 'Public') + \n    (SELECT COUNT(*) FROM StateData.StateParks WHERE Type = 'Public') AS Total_Public_Facilities_and_Parks;\n```\n\nThis query uses two subqueries to count the number of public facilities in each table and then adds these counts together to get the total.", "latency_sec": 3.416666030883789, "total_duration_sec": 3.179775502, "load_duration_sec": 0.01453464, "tokens_prompt": 759, "prompt_eval_sec": 0.310260366, "tokens_completion": 122, "completion_eval_sec": 2.851818731, "tokens_total": 881, "tokens_per_sec": 257.85370651872336, "retrieval_latency_sec": 0.1112210750579834, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate counts (one for StateHealthcare and one for StateParks) as two rows, while the Generated SQL returns a single row with the summed total of both counts. The output structure and results differ.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query returns two separate rows with counts from each table, while the generated query returns a single row with the summed total. The original question explicitly asks for a 'total' count, making the generated query's approach more appropriate. Both queries correctly filter for 'Public' types, but the generated query better fulfills the business intent of providing a combined total. The generated query is also more efficient as it requires a single execution with subqueries rather than two separate queries with UNION ALL.", "overall_assessment": "correct"}}
{"example_id": 1989, "sql_complexity": "single join", "prompt": "What are the names and production dates of garments made from fabrics with a sustainability score over 70, produced after 2021-01-01?", "context": "CREATE TABLE fabrics (id INT, name VARCHAR(50), type VARCHAR(50), sustainability_score INT); INSERT INTO fabrics (id, name, type, sustainability_score) VALUES (1, 'Organic Linen', 'Natural', 80); INSERT INTO fabrics (id, name, type, sustainability_score) VALUES (2, 'Recycled Nylon', 'Synthetic', 72);", "reference_sql": "SELECT garments.name, garments.production_date FROM garments JOIN fabrics ON garments.fabric_id = fabrics.id WHERE fabrics.sustainability_score > 70 AND garments.production_date > '2021-01-01';", "generated_sql": "SELECT garments.name, garments.production_date \nFROM garments \nJOIN fabrics ON garments.fabric_id = fabrics.id \nWHERE fabrics.sustainability_score > 70 AND garments.production_date > '2021-01-01';", "raw_model_output": "```sql\nSELECT garments.name, garments.production_date \nFROM garments \nJOIN fabrics ON garments.fabric_id = fabrics.id \nWHERE fabrics.sustainability_score > 70 AND garments.production_date > '2021-01-01';\n```", "latency_sec": 1.651817798614502, "total_duration_sec": 1.544577202, "load_duration_sec": 0.016634634, "tokens_prompt": 710, "prompt_eval_sec": 0.305092723, "tokens_completion": 53, "completion_eval_sec": 1.219429674, "tokens_total": 763, "tokens_per_sec": 461.91535206848044, "retrieval_latency_sec": 0.11545300483703613, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure, column selections, join conditions, and WHERE clause filters. Both retrieve the same data by joining 'garments' and 'fabrics' tables with the same sustainability score and production date constraints.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "The queries are technically equivalent as they share identical syntax, logic, and structure. The only difference is whitespace formatting (extra space after 'AND' in Generated SQL), which has no impact on execution. Both correctly join garments and fabrics tables, filter for sustainability_score > 70, and production_date > '2021-01-01', fully addressing the business question. Neither query demonstrates superior efficiency or elegance as they are functionally identical.", "overall_assessment": "correct"}}
{"example_id": 1388, "sql_complexity": "aggregation", "prompt": "What was the total donation amount by each organization in the last 30 days?", "context": "CREATE TABLE organization_donations (id INT, organization TEXT, donation_date DATE, donation_amount DECIMAL(10,2)); INSERT INTO organization_donations (id, organization, donation_date, donation_amount) VALUES (1, 'Organization A', '2021-03-15', 100.00), (2, 'Organization B', '2021-03-25', 200.00);", "reference_sql": "SELECT organization, SUM(donation_amount) FROM organization_donations WHERE donation_date >= DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY) GROUP BY organization;", "generated_sql": "SELECT organization, SUM(donation_amount) AS total_donation \nFROM organization_donations \nWHERE donation_date >= DATEADD(day, -30, GETDATE()) \nGROUP BY organization;", "raw_model_output": "```sql\nSELECT organization, SUM(donation_amount) AS total_donation \nFROM organization_donations \nWHERE donation_date >= DATEADD(day, -30, GETDATE()) \nGROUP BY organization;\n```", "latency_sec": 1.7099332809448242, "total_duration_sec": 1.487227757, "load_duration_sec": 0.019236472, "tokens_prompt": 981, "prompt_eval_sec": 0.382744024, "tokens_completion": 43, "completion_eval_sec": 1.080509722, "tokens_total": 1024, "tokens_per_sec": 598.8537748292662, "retrieval_latency_sec": 0.11275315284729004, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in date functions and handling of time components. The reference uses MySQL's DATE_SUB and CURRENT_DATE (date-only), while the generated query uses SQL Server's DATEADD and GETDATE() (datetime). The generated query's condition (donation_date >= DATEADD(day, -30, GETDATE())) may exclude donations exactly on the 30-day boundary if the current time is after midnight, whereas the reference includes them. This makes the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries differ in date calculation functions. The reference uses MySQL-specific DATE_SUB/CURRENT_DATE, while the generated uses SQL Server-specific DATEADD/GETDATE. These functions are not universally interchangeable across DBMS. Both correctly group by organization and sum donations, but the reference is technically correct for MySQL (implied by schema syntax), whereas the generated query would fail in MySQL environments. Both fulfill the business intent of aggregating donations by organization, but the reference is more appropriate for the given context.", "overall_assessment": "differently_correct"}}
{"example_id": 1628, "sql_complexity": "window functions", "prompt": "What is the ranking of national security measures for Russia based on the publication date?", "context": "CREATE TABLE national_security (id INT, title VARCHAR(255), description TEXT, agency VARCHAR(255), date DATE); INSERT INTO national_security (id, title, description, agency, date) VALUES (1, 'National Cyber Strategy', 'Outlines the approach to protecting the American people and the American way of life in the digital age', 'White House', '2018-09-20'); INSERT INTO national_security (id, title, description, agency, date) VALUES (2, 'Cybersecurity and Infrastructure Security Agency Act of 2018', 'Establishes the Cybersecurity and Infrastructure Security Agency within the Department of Homeland Security', 'Congress', '2018-11-16'); INSERT INTO national_security (id, title, description, agency, date) VALUES (3, 'Russian Military Doctrine', 'Outlines the country\u2019s stance on military security', 'Russian Government', '2014-12-26');", "reference_sql": "SELECT title, description, agency, date, ROW_NUMBER() OVER (PARTITION BY agency ORDER BY date DESC) as ranking FROM national_security WHERE agency = 'Russian Government';", "generated_sql": "SELECT title, description, agency, date, \n       RANK() OVER (ORDER BY date DESC) AS ranking\nFROM national_security\nWHERE agency = 'Russian Government';", "raw_model_output": "```sql\nSELECT title, description, agency, date, \n       RANK() OVER (ORDER BY date DESC) AS ranking\nFROM national_security\nWHERE agency = 'Russian Government';\n```", "latency_sec": 1.8441920280456543, "total_duration_sec": 1.583006548, "load_duration_sec": 0.017186653, "tokens_prompt": 1304, "prompt_eval_sec": 0.599152483, "tokens_completion": 40, "completion_eval_sec": 0.961160977, "tokens_total": 1344, "tokens_per_sec": 728.7744332266077, "retrieval_latency_sec": 0.11374783515930176, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter for 'Russian Government' and assign a ranking based on date descending. Since the WHERE clause restricts to a single agency, the PARTITION BY agency in the Reference query is redundant. The single row will have ranking 1 in both cases, as ROW_NUMBER() and RANK() produce the same result when there's only one record.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly filter for 'Russian Government' and rank entries by date. The Reference SQL uses ROW_NUMBER() with a redundant PARTITION BY agency (since the WHERE clause already restricts to one agency), while the Generated SQL uses RANK() without a partition. For the given data, both produce identical results (single row with ranking 1). However, the Generated SQL is more efficient and elegant by avoiding unnecessary partitioning. The business intent of ranking Russia's measures by date is fulfilled equally by both, but the Generated query is technically superior.", "overall_assessment": "correct"}}
{"example_id": 2300, "sql_complexity": "aggregation", "prompt": "What is the minimum capacity for schools in each location ('community_development')?", "context": "CREATE TABLE community_development.schools (id INT, name VARCHAR(50), capacity INT, location VARCHAR(50));", "reference_sql": "SELECT location, MIN(capacity) FROM community_development.schools GROUP BY location;", "generated_sql": "SELECT location, MIN(capacity) \nFROM community_development.schools \nGROUP BY location;", "raw_model_output": "```sql\nSELECT location, MIN(capacity) \nFROM community_development.schools \nGROUP BY location;\n```", "latency_sec": 0.8598771095275879, "total_duration_sec": 0.751963817, "load_duration_sec": 0.015737386, "tokens_prompt": 484, "prompt_eval_sec": 0.114825322, "tokens_completion": 24, "completion_eval_sec": 0.618044245, "tokens_total": 508, "tokens_per_sec": 590.782094756648, "retrieval_latency_sec": 0.1123809814453125, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. The only difference is formatting (line breaks) which does not affect SQL execution. Both select location and minimum capacity from the schools table grouped by location.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are syntactically identical except for whitespace formatting. They both select location and minimum capacity from the schools table, grouping by location to calculate the minimum capacity per location. The semantic meaning is exactly the same, and both correctly address the business intent of finding the minimum school capacity by community development location. Neither query is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 4976, "sql_complexity": "set operations", "prompt": "What is the most common hashtag used in posts made by users from Brazil?", "context": "CREATE TABLE posts (id INT, user_id INT, content TEXT, hashtags TEXT, post_date DATE); INSERT INTO posts (id, user_id, content, hashtags, post_date) VALUES (1, 1, 'Hello World', '#datascience', '2022-06-01'), (2, 1, 'I love data', '#ai', '2022-06-02'), (3, 2, 'Ol\u00e1 Mundo', '#brasil', '2022-06-03'); CREATE TABLE users (id INT, name VARCHAR(100), country VARCHAR(50)); INSERT INTO users (id, name, country) VALUES (1, 'Jo\u00e3o Silva', 'Brazil'), (2, 'Maria Souza', 'Brazil');", "reference_sql": "SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(hashtags, ' ', n.n), ' ', -1) hashtag, COUNT(*) count FROM posts JOIN users ON posts.user_id = users.id CROSS JOIN (SELECT 1 n UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5) n WHERE users.country = 'Brazil' GROUP BY hashtag ORDER BY count DESC LIMIT 1;", "generated_sql": "SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(hashtags, ' ', n.n), ' ', -1) hashtag, COUNT(*) count \nFROM posts \nJOIN users ON posts.user_id = users.id \nCROSS JOIN (SELECT 1 n UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5) n \nWHERE users.country = 'Brazil' \nGROUP BY hashtag \nORDER BY count DESC \nLIMIT 1;", "raw_model_output": "```sql\nSELECT SUBSTRING_INDEX(SUBSTRING_INDEX(hashtags, ' ', n.n), ' ', -1) hashtag, COUNT(*) count \nFROM posts \nJOIN users ON posts.user_id = users.id \nCROSS JOIN (SELECT 1 n UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5) n \nWHERE users.country = 'Brazil' \nGROUP BY hashtag \nORDER BY count DESC \nLIMIT 1;\n```", "latency_sec": 2.988758087158203, "total_duration_sec": 2.921316245, "load_duration_sec": 0.018017772, "tokens_prompt": 1398, "prompt_eval_sec": 0.631818692, "tokens_completion": 93, "completion_eval_sec": 2.265455475, "tokens_total": 1491, "tokens_per_sec": 498.86941549614863, "retrieval_latency_sec": 0.11008095741271973, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure, logic, and syntax. Both queries perform the same operations: extracting hashtags from the posts table, joining with users to filter by Brazil, counting occurrences, and returning the most frequent hashtag. Since the queries are exactly the same, they will produce identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "The reference and generated SQL queries are identical in structure, logic, and syntax. Both correctly join the posts and users tables, split space-separated hashtags using SUBSTRING_INDEX, filter for Brazilian users, count hashtag occurrences, and return the most frequent one. The queries handle the schema's design (storing multiple hashtags in a single TEXT field) using a numbers table cross-join. Since they are identical, they produce the same results, fulfill the business intent of finding the most common Brazilian hashtag, and have equal efficiency/elegance.", "overall_assessment": "correct"}}
{"example_id": 4637, "sql_complexity": "single join", "prompt": "What is the total value of transactions for each customer in the last 30 days?", "context": "CREATE TABLE transactions (id INT, customer_id INT, value DECIMAL(10, 2), transaction_date DATE); INSERT INTO transactions (id, customer_id, value, transaction_date) VALUES (1, 1, 100, '2022-01-01'), (2, 1, 200, '2022-01-15'), (3, 2, 50, '2022-01-05'), (4, 2, 150, '2022-01-30'), (5, 3, 300, '2022-01-20');", "reference_sql": "SELECT c.id, SUM(t.value) FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE t.transaction_date >= CURDATE() - INTERVAL 30 DAY GROUP BY c.id;", "generated_sql": "SELECT customer_id, SUM(value) AS total_value \nFROM transactions \nWHERE transaction_date >= CURRENT_DATE - INTERVAL '30 days' \nGROUP BY customer_id;", "raw_model_output": "```sql\nSELECT customer_id, SUM(value) AS total_value \nFROM transactions \nWHERE transaction_date >= CURRENT_DATE - INTERVAL '30 days' \nGROUP BY customer_id;\n```", "latency_sec": 1.5988972187042236, "total_duration_sec": 1.403620774, "load_duration_sec": 0.015839332, "tokens_prompt": 1066, "prompt_eval_sec": 0.408879893, "tokens_completion": 38, "completion_eval_sec": 0.974282916, "tokens_total": 1104, "tokens_per_sec": 690.4759024439998, "retrieval_latency_sec": 0.11390805244445801, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of transaction values for each customer_id within the last 30 days. The Reference SQL uses an INNER JOIN with customers (which is redundant since transactions already contain customer_id) and groups by c.id, while the Generated SQL directly groups by customer_id from transactions. The date conditions (CURDATE() - INTERVAL 30 DAY vs CURRENT_DATE - INTERVAL '30 days') are functionally equivalent. Since the customer_id in transactions corresponds to c.id in customers, both queries produce the same result set.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent due to differences in date syntax and join logic. The Reference SQL uses `CURDATE() - INTERVAL 30 DAY` (MySQL syntax) and joins with the `customers` table, while the Generated SQL uses `CURRENT_DATE - INTERVAL '30 days'` (which may not be valid in all SQL dialects like MySQL, where string literals in INTERVAL are disallowed). The Reference SQL's INNER JOIN ensures only customers with transactions are included, while the Generated SQL directly groups transactions by customer_id. Both fulfill the business intent of calculating 30-day transaction totals per customer, but the Reference SQL is more robust in handling date calculations and explicitly references the customer table. However, the Generated SQL is more efficient by avoiding an unnecessary join.", "overall_assessment": "differently_correct"}}
{"example_id": 4947, "sql_complexity": "aggregation", "prompt": "What is the total revenue for drugs approved between 2017 and 2019?", "context": "CREATE TABLE drug_sales_3 (drug_name TEXT, revenue FLOAT, year INT); INSERT INTO drug_sales_3 (drug_name, revenue, year) VALUES ('DrugG', 20000000, 2019), ('DrugG', 19000000, 2018), ('DrugH', 15000000, 2017), ('DrugH', 16000000, 2018);", "reference_sql": "SELECT drug_name, SUM(revenue) FROM drug_sales_3 WHERE year BETWEEN 2017 AND 2019 GROUP BY drug_name;", "generated_sql": "SELECT SUM(revenue) \nFROM drug_sales_3 \nWHERE year BETWEEN 2017 AND 2019;", "raw_model_output": "```sql\nSELECT SUM(revenue) \nFROM drug_sales_3 \nWHERE year BETWEEN 2017 AND 2019;\n```", "latency_sec": 1.4238147735595703, "total_duration_sec": 1.227747532, "load_duration_sec": 0.01653888, "tokens_prompt": 989, "prompt_eval_sec": 0.385331178, "tokens_completion": 32, "completion_eval_sec": 0.821473281, "tokens_total": 1021, "tokens_per_sec": 717.0876570183888, "retrieval_latency_sec": 0.11285829544067383, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query groups results by drug_name, producing separate SUM(revenue) values for each drug. The generated query lacks a GROUP BY clause, resulting in a single total revenue value for all drugs combined. The presence/absence of grouping changes the output structure and meaning.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query groups results by drug_name, returning per-drug totals, while the generated query returns a single aggregate total. The original question asks for 'total revenue for drugs' (singular), which implies a single value rather than per-drug breakdowns. The generated query correctly calculates the overall revenue across all drugs approved between 2017-2019. The reference query's grouping by drug_name introduces unnecessary complexity and does not align with the business intent of obtaining a single total revenue figure. However, the question's ambiguity about 'total revenue for drugs' (per-drug vs. overall) creates some uncertainty.", "overall_assessment": "differently_correct"}}
{"example_id": 4767, "sql_complexity": "window functions", "prompt": "List the top 2 AI algorithms with the highest explainability scores, by algorithm subtype, ordered by scores in descending order for the European region.", "context": "CREATE TABLE ai_algorithms (algorithm_id INT, algorithm_name VARCHAR(50), algorithm_subtype VARCHAR(50), region VARCHAR(50), explainability_score FLOAT); INSERT INTO ai_algorithms (algorithm_id, algorithm_name, algorithm_subtype, region, explainability_score) VALUES (1, 'AlgoA', 'Tree-based', 'Europe', 0.85), (2, 'AlgoB', 'Computer Vision', 'Europe', 0.92), (3, 'AlgoC', 'Tree-based', 'Europe', 0.78), (4, 'AlgoD', 'Transformer', 'Europe', 0.90), (5, 'AlgoE', 'Tree-based', 'Europe', 0.80);", "reference_sql": "SELECT algorithm_subtype, region, * FROM (SELECT algorithm_subtype, region, algorithm_id, algorithm_name, explainability_score, RANK() OVER (PARTITION BY algorithm_subtype ORDER BY explainability_score DESC) AS rank FROM ai_algorithms WHERE region = 'Europe') ranked WHERE rank <= 2 ORDER BY algorithm_subtype, region, explainability_score DESC;", "generated_sql": "SELECT algorithm_name, algorithm_subtype, explainability_score \nFROM ai_algorithms \nWHERE region = 'Europe' \nORDER BY explainability_score DESC \nLIMIT 2;", "raw_model_output": "```sql\nSELECT algorithm_name, algorithm_subtype, explainability_score \nFROM ai_algorithms \nWHERE region = 'Europe' \nORDER BY explainability_score DESC \nLIMIT 2;\n```", "latency_sec": 1.6726799011230469, "total_duration_sec": 1.385362441, "load_duration_sec": 0.022398668, "tokens_prompt": 992, "prompt_eval_sec": 0.383367852, "tokens_completion": 39, "completion_eval_sec": 0.976542062, "tokens_total": 1031, "tokens_per_sec": 616.3761514129396, "retrieval_latency_sec": 0.10439085960388184, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL selects top 2 algorithms per subtype in Europe using window ranking, while the Generated SQL simply returns top 2 overall algorithms in Europe. The Reference query returns multiple rows (2 per subtype) whereas the Generated query returns exactly 2 rows. Additionally, the selected columns differ between the queries.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference query correctly groups results by algorithm_subtype using RANK() with PARTITION BY, ensuring top 2 entries per subtype in Europe. It also includes necessary columns and proper ordering. The Generated query fails to account for algorithm_subtype grouping, instead returning only the absolute top 2 entries globally (AlgoB and AlgoD) without considering subtypes. This violates the requirement to 'list top 2... by algorithm subtype'. The Reference query technically handles the partitioning and ranking logic required for the business question.", "overall_assessment": "incorrect"}}
{"example_id": 4495, "sql_complexity": "basic SQL", "prompt": "Which countries are the top 3 sources of sustainable textiles?", "context": "CREATE TABLE Textile_Sources (Source_ID INT, Source_Country TEXT, Sustainable BOOLEAN, Quantity INT); INSERT INTO Textile_Sources (Source_ID, Source_Country, Sustainable, Quantity) VALUES (1, 'India', true, 1000), (2, 'Bangladesh', false, 800), (3, 'China', true, 1200), (4, 'Vietnam', false, 900), (5, 'Italy', true, 1100), (6, 'USA', false, 700);", "reference_sql": "SELECT Source_Country FROM Textile_Sources WHERE Sustainable = true ORDER BY Quantity DESC LIMIT 3;", "generated_sql": "SELECT Source_Country \nFROM Textile_Sources \nWHERE Sustainable = true \nGROUP BY Source_Country \nORDER BY SUM(Quantity) DESC \nLIMIT 3;", "raw_model_output": "```sql\nSELECT Source_Country \nFROM Textile_Sources \nWHERE Sustainable = true \nGROUP BY Source_Country \nORDER BY SUM(Quantity) DESC \nLIMIT 3;\n```", "latency_sec": 1.6179311275482178, "total_duration_sec": 1.293016354, "load_duration_sec": 0.019687699, "tokens_prompt": 810, "prompt_eval_sec": 0.328809691, "tokens_completion": 39, "completion_eval_sec": 0.938579828, "tokens_total": 849, "tokens_per_sec": 524.7442153403393, "retrieval_latency_sec": 0.11088895797729492, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL returns individual rows for sustainable sources ordered by Quantity, while the Generated SQL groups by Source_Country (aggregating quantities) and orders by summed quantities. If multiple entries exist per country, the Generated SQL would return fewer rows with aggregated values, whereas the Reference SQL would list all individual entries. In the provided sample data, they produce the same result due to unique countries, but this is not guaranteed in general.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query selects individual rows where Sustainable=true and orders by Quantity, while the generated query groups by Source_Country, sums Quantity, and orders by the total. The generated query better addresses the business intent of identifying top sources by total sustainable textile quantity. If multiple entries exist for a country, the reference query would return duplicate countries or incorrect rankings. The generated query ensures accurate aggregation, making it more robust for real-world data. Both fulfill the intent of identifying top countries, but the generated query does so more reliably.", "overall_assessment": "differently_correct"}}
{"example_id": 2513, "sql_complexity": "single join", "prompt": "What is the total number of concert ticket sales for artists who released their first album between 2015 and 2017?", "context": "CREATE TABLE ConcertTicketSales (id INT, year INT, artist_id INT); CREATE TABLE ArtistAlbums (id INT, artist_id INT, year INT);", "reference_sql": "SELECT COUNT(DISTINCT cts.artist_id) FROM ConcertTicketSales cts JOIN ArtistAlbums a ON cts.artist_id = a.artist_id WHERE a.year BETWEEN 2015 AND 2017;", "generated_sql": "SELECT COUNT(*) AS total_concert_ticket_sales\nFROM ConcertTicketSales cts\nJOIN (\n    SELECT artist_id, MIN(year) AS first_album_year\n    FROM ArtistAlbums\n    GROUP BY artist_id\n    HAVING MIN(year) BETWEEN 2015 AND 2017\n) aa ON cts.artist_id = aa.artist_id;", "raw_model_output": "To answer the question \"What is the total number of concert ticket sales for artists who released their first album between 2015 and 2017?\", we need to follow these steps:\n\n1. Identify artists who released their first album between 2015 and 2017.\n2. Count the total number of concert ticket sales for these artists.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT COUNT(*) AS total_concert_ticket_sales\nFROM ConcertTicketSales cts\nJOIN (\n    SELECT artist_id, MIN(year) AS first_album_year\n    FROM ArtistAlbums\n    GROUP BY artist_id\n    HAVING MIN(year) BETWEEN 2015 AND 2017\n) aa ON cts.artist_id = aa.artist_id;\n```\n\nExplanation:\n- The subquery in the `JOIN` clause identifies artists who released their first album between 2015 and 2017 by selecting the minimum year for each artist from the `ArtistAlbums` table and filtering those years to be between 2015 and 2017.\n- The main query then joins this result with the `ConcertTicketSales` table on `artist_id` to count the total number of concert ticket sales for these artists.", "latency_sec": 6.699717998504639, "total_duration_sec": 6.63131483, "load_duration_sec": 0.020868929, "tokens_prompt": 797, "prompt_eval_sec": 0.323240471, "tokens_completion": 269, "completion_eval_sec": 6.279555149, "tokens_total": 1066, "tokens_per_sec": 159.1111745655457, "retrieval_latency_sec": 0.11106109619140625, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query counts distinct artist_ids from ConcertTicketSales joined with ArtistAlbums where the album year is between 2015-2017. The generated query counts all concert ticket sales entries for artists whose earliest album year is in 2015-2017. The key difference is that the reference uses COUNT(DISTINCT) while the generated uses COUNT(*), leading to different results when an artist has multiple entries in ConcertTicketSales.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query is incorrect because it counts artists who have any album between 2015-2017, not their first album. The generated query correctly identifies artists whose first album was between 2015-2017 using a subquery with MIN(year) and HAVING clause. While both queries join on artist_id, the generated query's filtering is semantically correct for the business intent. However, the generated query counts all concert ticket sales (COUNT(*)) rather than distinct artists, which might misalign with the ambiguous phrasing of 'total number of concert ticket sales' (could mean sales count vs artist count). Despite this, the generated query better addresses the first album requirement.", "overall_assessment": "differently_correct"}}
{"example_id": 873, "sql_complexity": "subqueries", "prompt": "Identify attorneys who have never handled cases in the 'West' region but have in the 'North' or 'South'.", "context": "CREATE TABLE attorney_regions(attorney_id INT, region VARCHAR(20)); INSERT INTO attorney_regions(attorney_id, region) VALUES (1, 'North'), (2, 'South'), (3, 'East'), (4, 'West'), (5, 'West'), (6, 'North'); CREATE TABLE handled_cases(attorney_id INT, case_id INT); INSERT INTO handled_cases(attorney_id, case_id) VALUES (1, 101), (2, 102), (3, 103), (4, 104), (5, 105), (6, 106), (1, 107), (1, 108);", "reference_sql": "SELECT h.attorney_id FROM attorney_regions h LEFT JOIN handled_cases i ON h.attorney_id = i.attorney_id WHERE h.region IN ('North', 'South') AND h.region != 'West' AND i.attorney_id IS NOT NULL AND h.attorney_id NOT IN (SELECT attorney_id FROM attorney_regions WHERE region = 'West');", "generated_sql": "SELECT a.attorney_id \nFROM attorney_regions a \nLEFT JOIN handled_cases c ON a.attorney_id = c.attorney_id \nWHERE a.region = 'West' AND c.case_id IS NULL \n\nINTERSECT\n\nSELECT a.attorney_id \nFROM attorney_regions a \nINNER JOIN handled_cases c ON a.attorney_id = c.attorney_id \nWHERE a.region IN ('North', 'South');", "raw_model_output": "```sql\nSELECT a.attorney_id \nFROM attorney_regions a \nLEFT JOIN handled_cases c ON a.attorney_id = c.attorney_id \nWHERE a.region = 'West' AND c.case_id IS NULL \n\nINTERSECT\n\nSELECT a.attorney_id \nFROM attorney_regions a \nINNER JOIN handled_cases c ON a.attorney_id = c.attorney_id \nWHERE a.region IN ('North', 'South');\n```", "latency_sec": 2.628713846206665, "total_duration_sec": 2.546989789, "load_duration_sec": 0.015837669, "tokens_prompt": 1103, "prompt_eval_sec": 0.54415121, "tokens_completion": 87, "completion_eval_sec": 1.982246694, "tokens_total": 1190, "tokens_per_sec": 452.692864123349, "retrieval_latency_sec": 0.1044149398803711, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL selects attorneys in 'North' or 'South' regions with associated cases and excludes those in 'West'. The Generated SQL uses INTERSECT between (West region with no cases) and (North/South with cases), which produces an empty result since no attorney can be in both West and North/South. Thus, the queries return different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query attempts to find attorneys in North/South regions with cases who are not in West regions, but it has logical flaws. The generated query uses INTERSECT between two disjoint sets (West with no cases vs. North/South with cases), which will always return empty results. Neither query correctly addresses the business intent of identifying attorneys who have handled cases in North/South but never in West. The reference query's logic is closer but still flawed due to incorrect region-based filtering instead of case-based analysis.", "overall_assessment": "incorrect"}}
{"example_id": 471, "sql_complexity": "set operations", "prompt": "Find the number of donations made by first-time donors in the last quarter.", "context": "CREATE TABLE Donations (DonationID INT, DonorID INT, DonationDate DATE, DonationType TEXT, DonationAmount FLOAT); INSERT INTO Donations (DonationID, DonorID, DonationDate, DonationType, DonationAmount) VALUES (1, 1, '2021-01-01', 'Individual', 100), (2, 2, '2021-02-01', 'Corporate', 5000);", "reference_sql": "SELECT COUNT(*) FROM (SELECT DonationID FROM Donations WHERE DonationType = 'Individual' AND DonationDate >= DATEADD(quarter, -1, CURRENT_DATE) EXCEPT SELECT DonationID FROM PreviousDonations) AS FirstTimeDonors;", "generated_sql": "SELECT COUNT(*) \nFROM Donations \nWHERE DonorID IN (\n    SELECT DonorID \n    FROM Donations \n    WHERE DonationDate >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH)\n    AND DonorID NOT IN (\n        SELECT DonorID \n        FROM Donations \n        WHERE DonationDate < DATE_SUB(CURDATE(), INTERVAL 6 MONTH)\n    )\n);", "raw_model_output": "```sql\nSELECT COUNT(*) \nFROM Donations \nWHERE DonorID IN (\n    SELECT DonorID \n    FROM Donations \n    WHERE DonationDate >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH)\n    AND DonorID NOT IN (\n        SELECT DonorID \n        FROM Donations \n        WHERE DonationDate < DATE_SUB(CURDATE(), INTERVAL 6 MONTH)\n    )\n);\n```", "latency_sec": 3.040771722793579, "total_duration_sec": 2.455228927, "load_duration_sec": 0.016587738, "tokens_prompt": 1026, "prompt_eval_sec": 0.401638437, "tokens_completion": 84, "completion_eval_sec": 2.032669514, "tokens_total": 1110, "tokens_per_sec": 365.0389115629617, "retrieval_latency_sec": 0.10875391960144043, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in several key aspects. The Reference SQL specifically filters for 'Individual' donations and uses a table 'PreviousDonations' in an EXCEPT clause to identify first-time donors. The Generated SQL lacks a DonationType filter and instead uses date ranges to find donors who donated in the last 3 months but not before 6 months. Additionally, the Reference SQL compares DonationID values between two tables, while the Generated SQL focuses on DonorID patterns. These differences in filtering criteria, table usage, and logic make the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is invalid due to referencing a non-existent 'PreviousDonations' table, making it technically incorrect. The Generated SQL is syntactically valid but contains a logical flaw: it checks for donations in the last 3 months and excludes donors with donations before 6 months, which incorrectly includes donors who may have donated in the 3-6 month window (i.e., before the last quarter). This fails to accurately identify first-time donors who had no donations prior to the last quarter. While the Generated SQL is more aligned with the business intent than the Reference, its time-frame logic is flawed. Neither query perfectly fulfills the intent, but the Generated SQL is technically superior.", "overall_assessment": "differently_correct"}}
{"example_id": 1301, "sql_complexity": "multiple_joins", "prompt": "What is the total quantity of corn sold by farmers in 'Summerfield'?", "context": "CREATE TABLE farmers (id INT, name VARCHAR(50), location VARCHAR(50), crops VARCHAR(50)); CREATE TABLE crops (id INT, name VARCHAR(50), yield INT); CREATE TABLE sales (id INT, farmer_id INT, crop_name VARCHAR(50), quantity INT, price DECIMAL(5,2)); INSERT INTO farmers VALUES (1, 'Jane Doe', 'Summerfield', 'Corn'); INSERT INTO crops VALUES (1, 'Corn', 100); INSERT INTO sales VALUES (1, 1, 'Corn', 50, 2.50);", "reference_sql": "SELECT SUM(quantity) FROM sales INNER JOIN farmers ON sales.farmer_id = farmers.id INNER JOIN crops ON sales.crop_name = crops.name WHERE farmers.location = 'Summerfield' AND crops.name = 'Corn';", "generated_sql": "SELECT SUM(quantity) AS total_quantity_sold \nFROM sales \nJOIN farmers ON sales.farmer_id = farmers.id \nWHERE farmers.location = 'Summerfield' AND sales.crop_name = 'Corn';", "raw_model_output": "```sql\nSELECT SUM(quantity) AS total_quantity_sold \nFROM sales \nJOIN farmers ON sales.farmer_id = farmers.id \nWHERE farmers.location = 'Summerfield' AND sales.crop_name = 'Corn';\n```", "latency_sec": 1.5772511959075928, "total_duration_sec": 1.496338769, "load_duration_sec": 0.016173917, "tokens_prompt": 918, "prompt_eval_sec": 0.363808696, "tokens_completion": 45, "completion_eval_sec": 1.112256276, "tokens_total": 963, "tokens_per_sec": 610.5558851365232, "retrieval_latency_sec": 0.11325597763061523, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes an INNER JOIN with the 'crops' table and filters on crops.name = 'Corn', ensuring only sales with valid crop entries are considered. The Generated SQL skips the crops table join and filters directly on sales.crop_name = 'Corn'. While both filter for 'Corn', the Reference SQL enforces a valid crop relationship via the join, whereas the Generated SQL might include sales with invalid crop names (if any). Thus, they are not semantically equivalent in general.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the total quantity of corn sold by Summerfield farmers. The reference query includes an unnecessary join to the 'crops' table, which doesn't affect the result in this specific case but adds computational overhead. The generated query achieves the same result with a simpler, more efficient structure by directly filtering on sales.crop_name. While both satisfy the business intent, the generated query is more elegant and efficient.", "overall_assessment": "correct"}}
{"example_id": 4667, "sql_complexity": "aggregation", "prompt": "Find the number of unique organizations in each country in the Philanthropy Trends table?", "context": "CREATE TABLE PhilanthropyTrends (OrgID INT, Name TEXT, Country TEXT);", "reference_sql": "SELECT Country, COUNT(DISTINCT OrgID) as UniqueOrganizations FROM PhilanthropyTrends GROUP BY Country;", "generated_sql": "SELECT Country, COUNT(DISTINCT OrgID) AS UniqueOrganizations \nFROM PhilanthropyTrends \nGROUP BY Country;", "raw_model_output": "```sql\nSELECT Country, COUNT(DISTINCT OrgID) AS UniqueOrganizations \nFROM PhilanthropyTrends \nGROUP BY Country;\n```", "latency_sec": 1.159674882888794, "total_duration_sec": 1.116436936, "load_duration_sec": 0.025811649, "tokens_prompt": 806, "prompt_eval_sec": 0.329510626, "tokens_completion": 31, "completion_eval_sec": 0.753035824, "tokens_total": 837, "tokens_per_sec": 721.7540125685928, "retrieval_latency_sec": 0.10980892181396484, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select the 'Country' column, count distinct 'OrgID' values as 'UniqueOrganizations', and group results by 'Country'. The only differences are whitespace and formatting, which do not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure, logic, and output. They correctly group by Country, count distinct OrgIDs to ensure uniqueness, and produce the same results. The formatting differences (e.g., line breaks) do not affect functionality. Both queries perfectly address the business intent of counting unique organizations per country.", "overall_assessment": "correct"}}
{"example_id": 1006, "sql_complexity": "subqueries", "prompt": "What is the average word count of news articles written by investigative journalists?", "context": "CREATE TABLE reporters (id INT, name VARCHAR(50), gender VARCHAR(10), age INT, position VARCHAR(20), country VARCHAR(50)); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (1, 'Anna Smith', 'Female', 35, 'News Reporter', 'USA'); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (2, 'Mike Johnson', 'Male', 40, 'Investigative Journalist', 'Canada'); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (3, 'Sofia Rodriguez', 'Female', 32, 'Investigative Journalist', 'Mexico'); CREATE TABLE news_articles (id INT, title VARCHAR(100), content TEXT, publication_date DATE, reporter_id INT); INSERT INTO news_articles (id, title, content, publication_date, reporter_id) VALUES (1, 'News Article 1', 'Content of News Article 1', '2021-01-01', 2); INSERT INTO news_articles (id, title, content, publication_date, reporter_id) VALUES (2, 'News Article 2', 'Content of News Article 2', '2021-02-01', 3);", "reference_sql": "SELECT AVG(LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1) AS avg_word_count FROM news_articles WHERE reporter_id IN (SELECT id FROM reporters WHERE position = 'Investigative Journalist');", "generated_sql": "SELECT AVG(LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1) AS avg_word_count\nFROM news_articles na\nJOIN reporters r ON na.reporter_id = r.id\nWHERE r.position = 'Investigative Journalist';", "raw_model_output": "To find the average word count of news articles written by investigative journalists, we need to join the `news_articles` table with the `reporters` table on the `reporter_id` and filter for reporters whose position is 'Investigative Journalist'. Then, we calculate the average word count from the content of these articles.\n\nHere's the SQL query:\n\n```sql\nSELECT AVG(LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1) AS avg_word_count\nFROM news_articles na\nJOIN reporters r ON na.reporter_id = r.id\nWHERE r.position = 'Investigative Journalist';\n```\n\nExplanation:\n- We use `JOIN` to combine the `news_articles` and `reporters` tables based on the `reporter_id`.\n- We filter the results to only include articles written by investigative journalists using `WHERE r.position = 'Investigative Journalist'`.\n- We calculate the word count for each article by subtracting the number of spaces from the total length of the content and adding 1 (since words are separated by spaces).\n- Finally, we use `AVG()` to compute the average word count of these articles.", "latency_sec": 6.501399040222168, "total_duration_sec": 6.182968846, "load_duration_sec": 0.014039769, "tokens_prompt": 1030, "prompt_eval_sec": 0.398435921, "tokens_completion": 242, "completion_eval_sec": 5.765498912, "tokens_total": 1272, "tokens_per_sec": 195.6501965393179, "retrieval_latency_sec": 0.11183905601501465, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average word count of news articles written by 'Investigative Journalists'. The Reference SQL uses a subquery to get reporter IDs, while the Generated SQL uses a JOIN. Both filter the same set of articles through equivalent conditions (reporter position), and the word count calculation formula is identical. The final result will be the same.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the average word count of articles by investigative journalists. The reference query uses a subquery to filter reporter IDs, while the generated query uses an explicit JOIN. Both employ the same word-counting logic (length difference between content and space-removed content). The generated query is more efficient due to the JOIN, which avoids a subquery and may leverage indexes better. Both fulfill the business intent, but the generated version is more elegant and readable.", "overall_assessment": "correct"}}
{"example_id": 3635, "sql_complexity": "set operations", "prompt": "Which brands have certifications related to cruelty-free, vegan, or organic products?", "context": "CREATE TABLE brands (brand_name VARCHAR(50), is_cruelty_free BOOLEAN, is_vegan BOOLEAN, is_organic BOOLEAN); INSERT INTO brands (brand_name, is_cruelty_free, is_vegan, is_organic) VALUES ('Lush', TRUE, TRUE, FALSE), ('The Body Shop', TRUE, FALSE, FALSE), ('Est\u00e9e Lauder', FALSE, FALSE, FALSE), ('Urban Decay', TRUE, TRUE, FALSE), ('Maybelline', FALSE, FALSE, FALSE), ('Kat Von D', TRUE, TRUE, FALSE), ('Tarte', TRUE, TRUE, TRUE);", "reference_sql": "SELECT brand_name, 'Cruelty-free' as certification FROM brands WHERE is_cruelty_free = TRUE UNION SELECT brand_name, 'Vegan' as certification FROM brands WHERE is_vegan = TRUE UNION SELECT brand_name, 'Organic' as certification FROM brands WHERE is_organic = TRUE;", "generated_sql": "SELECT brand_name \nFROM brands \nWHERE is_cruelty_free = TRUE OR is_vegan = TRUE OR is_organic = TRUE;", "raw_model_output": "```sql\nSELECT brand_name \nFROM brands \nWHERE is_cruelty_free = TRUE OR is_vegan = TRUE OR is_organic = TRUE;\n```", "latency_sec": 1.3851888179779053, "total_duration_sec": 1.27063045, "load_duration_sec": 0.016412331, "tokens_prompt": 985, "prompt_eval_sec": 0.379210784, "tokens_completion": 34, "completion_eval_sec": 0.870234198, "tokens_total": 1019, "tokens_per_sec": 735.6397819378395, "retrieval_latency_sec": 0.11243391036987305, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns brand names paired with their specific certification type (Cruelty-free/Vegan/Organic) as a second column, while the Generated SQL only returns brand names without any certification information. The output structures differ (two columns vs. one column) and the Generated SQL lacks the categorical distinction present in the Reference SQL.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because the reference query returns two columns (brand_name and certification type) while the generated query only returns brand_name. However, both correctly identify brands with at least one certification. The generated query is more efficient as it uses a single scan with OR conditions instead of three separate queries with UNION. The original question only asks for brands (not certification types), so the generated query directly addresses the business intent without unnecessary complexity. The reference query provides more detailed information but is not required by the question.", "overall_assessment": "differently_correct"}}
{"example_id": 4932, "sql_complexity": "basic SQL", "prompt": "Delete the workout row with the id of 2.", "context": "CREATE TABLE Workouts (id INT, user_id INT, workout_name TEXT, calories INT); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (1, 1, 'Running', 300); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (2, 1, 'Cycling', 400); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (3, 2, 'Yoga', 200);", "reference_sql": "DELETE FROM Workouts WHERE id = 2;", "generated_sql": "DELETE FROM Workouts WHERE id = 2;", "raw_model_output": "```sql\nDELETE FROM Workouts WHERE id = 2;\n```", "latency_sec": 1.0048267841339111, "total_duration_sec": 0.72077249, "load_duration_sec": 0.016048196, "tokens_prompt": 801, "prompt_eval_sec": 0.324285118, "tokens_completion": 15, "completion_eval_sec": 0.377135632, "tokens_total": 816, "tokens_per_sec": 812.0802638669048, "retrieval_latency_sec": 0.11378717422485352, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They both delete the record with id = 2 from the Workouts table, resulting in the same database state after execution.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical: DELETE FROM Workouts WHERE id = 2;. They correctly delete the specific workout row with id=2 as required. The query is technically correct, semantically equivalent, and efficiently fulfills the business intent of removing the specified record. Since the reference and generated queries are exactly the same, neither is superior to the other.", "overall_assessment": "correct"}}
{"example_id": 365, "sql_complexity": "aggregation", "prompt": "Identify the total number of military personnel and their corresponding rank for each branch and country in the 'military_personnel' table, sorted by the total number of personnel in descending order.", "context": "CREATE TABLE military_personnel (id INT, branch VARCHAR(255), rank VARCHAR(255), country VARCHAR(255), personnel INT);", "reference_sql": "SELECT branch, country, SUM(personnel) as total_personnel FROM military_personnel GROUP BY branch, country ORDER BY total_personnel DESC;", "generated_sql": "SELECT branch, country, rank, SUM(personnel) as total_personnel \nFROM military_personnel \nGROUP BY branch, country, rank \nORDER BY total_personnel DESC;", "raw_model_output": "```sql\nSELECT branch, country, rank, SUM(personnel) as total_personnel \nFROM military_personnel \nGROUP BY branch, country, rank \nORDER BY total_personnel DESC;\n```", "latency_sec": 1.303821086883545, "total_duration_sec": 1.299076389, "load_duration_sec": 0.013617693, "tokens_prompt": 747, "prompt_eval_sec": 0.312254393, "tokens_completion": 41, "completion_eval_sec": 0.969172057, "tokens_total": 788, "tokens_per_sec": 604.3774011076282, "retrieval_latency_sec": 0.11008191108703613, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query groups by (branch, country) and sums personnel across all ranks within each group. The generated query groups by (branch, country, rank), summing personnel per rank within each branch-country combination. This results in different aggregation levels: the first produces branch-country totals, while the second produces branch-country-rank totals. The generated query also includes an extra 'rank' column in the output.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly groups by branch and country to calculate total personnel per combination, while the generated query adds 'rank' to the GROUP BY clause, which would split totals by rank within each branch/country. This violates the original requirement to aggregate across all ranks per branch/country. The reference query is technically correct, fulfills the business intent of summarizing total personnel per branch/country, and is more efficient. The generated query addresses a different question (total personnel per rank/branch/country) and would produce structurally different results.", "overall_assessment": "incorrect"}}
{"example_id": 521, "sql_complexity": "subqueries", "prompt": "How many vessels have not had an inspection in the past year?", "context": "CREATE TABLE safety_records(id INT, vessel_name VARCHAR(50), inspection_date DATE); CREATE TABLE vessels(id INT, name VARCHAR(50), country VARCHAR(50)); INSERT INTO vessels(id, name, country) VALUES (1, 'Vessel A', 'Philippines'), (2, 'Vessel B', 'Philippines'); INSERT INTO safety_records(id, vessel_name, inspection_date) VALUES (1, 'Vessel A', '2022-01-01');", "reference_sql": "SELECT COUNT(*) FROM vessels WHERE name NOT IN (SELECT vessel_name FROM safety_records WHERE inspection_date BETWEEN DATE_SUB(NOW(), INTERVAL 1 YEAR) AND NOW());", "generated_sql": "SELECT COUNT(*) \nFROM vessels \nWHERE id NOT IN (\n    SELECT vessel_name \n    FROM safety_records \n    WHERE inspection_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR)\n);", "raw_model_output": "```sql\nSELECT COUNT(*) \nFROM vessels \nWHERE id NOT IN (\n    SELECT vessel_name \n    FROM safety_records \n    WHERE inspection_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR)\n);\n```", "latency_sec": 1.4822261333465576, "total_duration_sec": 1.403168214, "load_duration_sec": 0.016089397, "tokens_prompt": 809, "prompt_eval_sec": 0.325804701, "tokens_completion": 44, "completion_eval_sec": 1.057991898, "tokens_total": 853, "tokens_per_sec": 575.4857378435933, "retrieval_latency_sec": 0.10912823677062988, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL checks for vessels where the name is not in the subquery result (vessel_names with recent inspections), while the Generated SQL incorrectly compares vessel.id (an integer) to vessel_name (a string) from the subquery, causing a type mismatch. Additionally, the subquery conditions differ: the Reference SQL uses BETWEEN with NOW() (datetime) while the Generated SQL uses >= with CURRENT_DATE (date), leading to potential differences in included inspection dates.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in three critical aspects:\n1. Type Mismatch: The generated query compares vessel.id (INT) with vessel_name (VARCHAR) in the NOT IN clause, which is technically invalid. The reference correctly compares vessel.name (VARCHAR) with vessel_name (VARCHAR).\n2. Date Calculation: The reference uses NOW() which includes time components, while the generated query uses CURRENT_DATE (date-only). However, since inspection_date is a DATE type, this difference is less critical.\n3. Subquery Output: The generated query's subquery returns vessel_name (strings) while the main query checks id NOT IN (strings), which would require implicit type conversion that's not reliable.\nThe reference query correctly identifies vessels without recent inspections by comparing names, while the generated query has a critical type mismatch that would cause errors or incorrect results.", "overall_assessment": "incorrect"}}
{"example_id": 5687, "sql_complexity": "multiple_joins", "prompt": "List organizations with more than 200 volunteers, and their average donation amounts, excluding donations less than $10.", "context": "CREATE TABLE organizations (org_id INT, org_name TEXT, social_impact_score INT);CREATE TABLE volunteers (vol_id INT, org_id INT, vol_country TEXT);CREATE TABLE donations (donation_id INT, donor_id INT, donation_amount INT, donation_date DATE);", "reference_sql": "SELECT o.org_name, AVG(donation_amount) AS avg_donation_amount FROM organizations o JOIN volunteers v ON o.org_id = v.org_id JOIN donations don ON o.org_id = don.org_id WHERE donation_amount >= 10 GROUP BY o.org_name HAVING COUNT(v.vol_id) > 200;", "generated_sql": "SELECT o.org_name, AVG(d.donation_amount) AS average_donation_amount\nFROM organizations o\nJOIN volunteers v ON o.org_id = v.org_id\nJOIN donations d ON o.org_id = d.donor_id\nWHERE v.vol_country IS NOT NULL AND d.donation_amount >= 10\nGROUP BY o.org_id, o.org_name\nHAVING COUNT(v.vol_id) > 200;", "raw_model_output": "```sql\nSELECT o.org_name, AVG(d.donation_amount) AS average_donation_amount\nFROM organizations o\nJOIN volunteers v ON o.org_id = v.org_id\nJOIN donations d ON o.org_id = d.donor_id\nWHERE v.vol_country IS NOT NULL AND d.donation_amount >= 10\nGROUP BY o.org_id, o.org_name\nHAVING COUNT(v.vol_id) > 200;\n```", "latency_sec": 2.787822961807251, "total_duration_sec": 2.589952744, "load_duration_sec": 0.022525975, "tokens_prompt": 991, "prompt_eval_sec": 0.393616521, "tokens_completion": 91, "completion_eval_sec": 2.170258335, "tokens_total": 1082, "tokens_per_sec": 388.1164675172114, "retrieval_latency_sec": 0.10547471046447754, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Generated SQL includes an additional WHERE condition (v.vol_country IS NOT NULL) that filters out volunteers with null country values, which is absent in the Reference SQL. Second, the JOIN condition in the Generated SQL uses d.donor_id instead of don.org_id (as in the Reference SQL), which would link donations to organizations via donor_id (a foreign key to donors, not organizations). These differences in filtering and join logic would produce different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries differ in critical aspects. The Reference SQL contains a syntax error: it joins 'donations' on 'don.org_id' which doesn't exist in the schema (donations only has 'donor_id'). The Generated SQL correctly uses 'd.donor_id' but still has logical issues. Both queries incorrectly join organizations directly to donations without accounting for the missing link between donors/volunteers and organizations. However, the Generated SQL groups by both org_id and org_name (ensuring uniqueness) and includes 'v.vol_country IS NOT NULL' which adds explicit filtering not in the Reference version. While neither query fully addresses the schema's limitations, the Generated SQL demonstrates better structure and explicitness.", "overall_assessment": "differently_correct"}}
{"example_id": 1281, "sql_complexity": "subqueries", "prompt": "Find the top 3 contributors with the lowest recycling rate in the 'waste_contributors' table.", "context": "CREATE TABLE waste_contributors (contributor VARCHAR(20), recycling_rate FLOAT); INSERT INTO waste_contributors (contributor, recycling_rate) VALUES ('Manufacturing', 0.4), ('Commercial', 0.38), ('Residential', 0.35), ('Institutional', 0.32), ('Agricultural', 0.2), ('Industrial', 0.15);", "reference_sql": "SELECT contributor FROM waste_contributors WHERE recycling_rate IN (SELECT MIN(recycling_rate) FROM waste_contributors) LIMIT 3;", "generated_sql": "SELECT contributor \nFROM waste_contributors \nORDER BY recycling_rate ASC \nLIMIT 3;", "raw_model_output": "```sql\nSELECT contributor \nFROM waste_contributors \nORDER BY recycling_rate ASC \nLIMIT 3;\n```", "latency_sec": 1.0954208374023438, "total_duration_sec": 0.962838537, "load_duration_sec": 0.028536776, "tokens_prompt": 848, "prompt_eval_sec": 0.345961816, "tokens_completion": 23, "completion_eval_sec": 0.583617231, "tokens_total": 871, "tokens_per_sec": 795.1282011993397, "retrieval_latency_sec": 0.10684585571289062, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL selects contributors with the minimum recycling rate (only 'Industrial' in this case) and limits to 3 results. The Generated SQL orders all contributors by ascending recycling rate and returns the top 3 (Industrial, Agricultural, Institutional). The first query targets the absolute minimum value, while the second returns the three lowest values, leading to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query uses a subquery to find the minimum recycling rate and returns contributors with that exact rate, but this approach would only return contributors with the absolute lowest rate (e.g., Industrial in the sample data) rather than the top 3 lowest rates. The generated query correctly orders all contributors by recycling_rate in ascending order and limits the result to 3, which directly addresses the requirement for the 'top 3 contributors with the lowest recycling rate'. While both queries are technically valid, the generated query better fulfills the business intent by retrieving the three lowest rates regardless of ties.", "overall_assessment": "differently_correct"}}
{"example_id": 5669, "sql_complexity": "window functions", "prompt": "What is the total number of new and returning volunteers in each program in each month?", "context": "CREATE TABLE Volunteers (VolunteerID INT, VolunteerName TEXT, ProgramID INT, VolunteerDate DATE, IsReturning BOOLEAN); INSERT INTO Volunteers (VolunteerID, VolunteerName, ProgramID, VolunteerDate, IsReturning) VALUES (6, 'David Kim', 1, '2022-03-01', FALSE), (7, 'Emily Chen', 2, '2022-03-15', TRUE), (8, 'James Lee', 2, '2022-04-01', FALSE), (9, 'Grace Park', 3, '2022-04-15', TRUE), (10, 'Daniel Kim', 1, '2022-04-01', FALSE);", "reference_sql": "SELECT ProgramID, EXTRACT(MONTH FROM VolunteerDate) AS Month, SUM(CASE WHEN IsReturning THEN 1 ELSE 0 END) OVER (PARTITION BY ProgramID, EXTRACT(MONTH FROM VolunteerDate) ORDER BY ProgramID, EXTRACT(MONTH FROM VolunteerDate)) + COUNT(DISTINCT VolunteerID) OVER (PARTITION BY ProgramID, EXTRACT(MONTH FROM VolunteerDate) ORDER BY ProgramID, EXTRACT(MONTH FROM VolunteerDate)) AS TotalVolunteers FROM Volunteers;", "generated_sql": "SELECT \n    ProgramID,\n    EXTRACT(MONTH FROM VolunteerDate) AS Month,\n    SUM(CASE WHEN IsReturning = FALSE THEN 1 ELSE 0 END) AS NewVolunteers,\n    SUM(CASE WHEN IsReturning = TRUE THEN 1 ELSE 0 END) AS ReturningVolunteers\nFROM \n    Volunteers\nGROUP BY \n    ProgramID, EXTRACT(MONTH FROM VolunteerDate)\nORDER BY \n    ProgramID, Month;", "raw_model_output": "```sql\nSELECT \n    ProgramID,\n    EXTRACT(MONTH FROM VolunteerDate) AS Month,\n    SUM(CASE WHEN IsReturning = FALSE THEN 1 ELSE 0 END) AS NewVolunteers,\n    SUM(CASE WHEN IsReturning = TRUE THEN 1 ELSE 0 END) AS ReturningVolunteers\nFROM \n    Volunteers\nGROUP BY \n    ProgramID, EXTRACT(MONTH FROM VolunteerDate)\nORDER BY \n    ProgramID, Month;\n```", "latency_sec": 2.8727340698242188, "total_duration_sec": 2.840980417, "load_duration_sec": 0.014590176, "tokens_prompt": 1164, "prompt_eval_sec": 0.558146358, "tokens_completion": 98, "completion_eval_sec": 2.263057058, "tokens_total": 1262, "tokens_per_sec": 439.30275804374094, "retrieval_latency_sec": 0.08545708656311035, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL calculates a combined 'TotalVolunteers' by adding returning volunteer counts and distinct volunteer counts using window functions, while the Generated SQL separates new and returning volunteers into distinct columns via aggregation. The Reference's approach combines metrics in a way that doesn't match the Generated SQL's structured grouping and separate counters. Additionally, the Reference's window functions may produce redundant or incorrect totals compared to the Generated SQL's grouped aggregation.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL is technically flawed. It uses window functions without proper aggregation, leading to incorrect totals (e.g., double-counting volunteers). The Generated SQL correctly groups by ProgramID and month, using conditional aggregation to separate new and returning volunteers. While both queries address the business intent, the Generated SQL provides precise, distinct counts for new and returning volunteers, whereas the Reference SQL combines them incorrectly and lacks proper aggregation. The Generated SQL is more efficient and semantically accurate.", "overall_assessment": "differently_correct"}}
{"example_id": 3576, "sql_complexity": "window functions", "prompt": "What is the difference in the number of eco-friendly hotels between the top 2 countries?", "context": "CREATE TABLE eco_hotel_count (country TEXT, num_hotels INT); INSERT INTO eco_hotel_count (country, num_hotels) VALUES ('France', 100), ('Italy', 120), ('Germany', 150), ('Spain', 110), ('UK', 160);", "reference_sql": "SELECT (MAX(num_hotels) OVER (PARTITION BY num_hotels <= 2) - MIN(num_hotels) OVER (PARTITION BY num_hotels <= 2)) AS hotel_difference FROM eco_hotel_count WHERE country IN ('France', 'Italy');", "generated_sql": "SELECT \n    (SELECT num_hotels FROM eco_hotel_count ORDER BY num_hotels DESC LIMIT 1) - \n    (SELECT num_hotels FROM eco_hotel_count ORDER BY num_hotels DESC LIMIT 2 OFFSET 1) AS difference;", "raw_model_output": "To find the difference in the number of eco-friendly hotels between the top 2 countries, we need to:\n\n1. Select the `num_hotels` column from the `eco_hotel_count` table.\n2. Order the results by `num_hotels` in descending order to get the countries with the highest number of eco-friendly hotels first.\n3. Limit the results to the top 2 countries.\n4. Calculate the difference between the number of hotels in these two countries.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT \n    (SELECT num_hotels FROM eco_hotel_count ORDER BY num_hotels DESC LIMIT 1) - \n    (SELECT num_hotels FROM eco_hotel_count ORDER BY num_hotels DESC LIMIT 2 OFFSET 1) AS difference;\n```\n\nExplanation:\n- The first subquery `(SELECT num_hotels FROM eco_hotel_count ORDER BY num_hotels DESC LIMIT 1)` retrieves the number of hotels in the country with the highest count.\n- The second subquery `(SELECT num_hotels FROM eco_hotel_count ORDER BY num_hotels DESC LIMIT 2 OFFSET 1)` retrieves the number of hotels in the country with the second-highest count.\n- The main query calculates the difference between these two values.", "latency_sec": 6.536565065383911, "total_duration_sec": 6.306758493, "load_duration_sec": 0.016638299, "tokens_prompt": 699, "prompt_eval_sec": 0.296422517, "tokens_completion": 260, "completion_eval_sec": 5.990030433, "tokens_total": 959, "tokens_per_sec": 146.71314220960411, "retrieval_latency_sec": 0.11072421073913574, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters to only 'France' and 'Italy' before calculating the difference between max and min values in their partition, resulting in 120-100=20. The Generated SQL operates on the entire table, calculating 160-150=10. The lack of country filtering in the Generated SQL leads to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL is fundamentally flawed: 1) The PARTITION BY num_hotels <= 2 condition is invalid syntax and would return no rows, 2) The WHERE clause restricts to France and Italy (not the top 2 countries), 3) The window functions are misapplied. The Generated SQL correctly identifies the top 2 numbers (160 and 150) through subqueries, calculates their difference (10), and aligns with the business intent of comparing the top 2 countries. While both queries fail technically, the Generated SQL at least addresses the core calculation, whereas the Reference SQL is nonsensical.", "overall_assessment": "differently_correct"}}
{"example_id": 1970, "sql_complexity": "multiple_joins", "prompt": "List all players who have played a specific VR game, 'CyberSphere', and their ages.", "context": "CREATE TABLE Players (PlayerID INT, Age INT, Gender VARCHAR(10), Country VARCHAR(50)); CREATE TABLE VRPlayers (PlayerID INT, VRGameID INT); CREATE TABLE VRGames (VRGameID INT, Title VARCHAR(50)); INSERT INTO Players (PlayerID, Age, Gender, Country) VALUES (1, 25, 'Male', 'USA'); INSERT INTO Players (PlayerID, Age, Gender, Country) VALUES (2, 28, 'Female', 'Canada'); INSERT INTO VRPlayers (PlayerID, VRGameID) VALUES (1, 1); INSERT INTO VRPlayers (PlayerID, VRGameID) VALUES (2, 1); INSERT INTO VRGames (VRGameID, Title) VALUES (1, 'CyberSphere');", "reference_sql": "SELECT Players.Age, Players.PlayerID FROM Players INNER JOIN VRPlayers ON Players.PlayerID = VRPlayers.PlayerID INNER JOIN VRGames ON VRPlayers.VRGameID = VRGames.VRGameID WHERE VRGames.Title = 'CyberSphere';", "generated_sql": "SELECT Players.PlayerID, Players.Age \nFROM Players \nINNER JOIN VRPlayers ON Players.PlayerID = VRPlayers.PlayerID \nINNER JOIN VRGames ON VRPlayers.VRGameID = VRGames.VRGameID \nWHERE VRGames.Title = 'CyberSphere';", "raw_model_output": "```sql\nSELECT Players.PlayerID, Players.Age \nFROM Players \nINNER JOIN VRPlayers ON Players.PlayerID = VRPlayers.PlayerID \nINNER JOIN VRGames ON VRPlayers.VRGameID = VRGames.VRGameID \nWHERE VRGames.Title = 'CyberSphere';\n```", "latency_sec": 2.419584035873413, "total_duration_sec": 1.855979381, "load_duration_sec": 0.020795815, "tokens_prompt": 996, "prompt_eval_sec": 0.382931343, "tokens_completion": 59, "completion_eval_sec": 1.444803159, "tokens_total": 1055, "tokens_per_sec": 436.0253598793355, "retrieval_latency_sec": 0.1083221435546875, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The two queries are semantically equivalent because they select the same columns (PlayerID and Age) from the same tables with identical joins and WHERE conditions. The only difference is the order of columns in the SELECT clause, which does not affect the result set's content, only the column order in the output.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are structurally identical except for the order of columns in the SELECT clause. The reference query lists 'Age' first, while the generated query lists 'PlayerID' first. Since SQL result sets are not inherently ordered, this difference does not affect technical equivalence or semantic correctness. Both queries correctly join the three tables, filter for 'CyberSphere' via the VRGames table, and retrieve the required PlayerID and Age fields. The business intent to list players who played the specific VR game and their ages is fully satisfied by both queries.", "overall_assessment": "correct"}}
{"example_id": 2414, "sql_complexity": "window functions", "prompt": "List the policy areas with the lowest citizen satisfaction scores.", "context": "CREATE TABLE Policy (Area VARCHAR(20), Score INT); INSERT INTO Policy (Area, Score) VALUES ('Transportation', 70), ('Education', 85), ('Healthcare', 75), ('PublicSafety', 80);", "reference_sql": "SELECT Area, Score FROM (SELECT Area, Score, ROW_NUMBER() OVER (ORDER BY Score) AS RN FROM Policy) X WHERE RN IN (1, 2);", "generated_sql": "SELECT Area, Score \nFROM Policy \nORDER BY Score ASC;", "raw_model_output": "```sql\nSELECT Area, Score \nFROM Policy \nORDER BY Score ASC;\n```", "latency_sec": 0.9564411640167236, "total_duration_sec": 0.802714157, "load_duration_sec": 0.022949242, "tokens_prompt": 814, "prompt_eval_sec": 0.327037734, "tokens_completion": 18, "completion_eval_sec": 0.445842804, "tokens_total": 832, "tokens_per_sec": 869.8914594034059, "retrieval_latency_sec": 0.13070893287658691, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns only the top 2 rows based on Score (using ROW_NUMBER()), while the Generated SQL returns all rows ordered by Score. The first query limits results to 2 rows, whereas the second returns all 4 rows. They differ in both result set size and content.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL uses ROW_NUMBER() to return only the top 2 lowest scores (RN=1 and RN=2), which assumes the user wants exactly two results. However, the original question asks for 'lowest citizen satisfaction scores' without specifying a count, which could imply all policies with the minimum score(s). The Generated SQL correctly orders all policies by score ascending, ensuring all lowest scores are included. While the Reference SQL is technically correct for retrieving top 2, the Generated SQL better fulfills the ambiguous business intent by providing a complete list of lowest scores. The Generated SQL is also more elegant and efficient as it avoids unnecessary subqueries.", "overall_assessment": "differently_correct"}}
{"example_id": 1898, "sql_complexity": "single join", "prompt": "What are the total sales for each drug in Q2 2020?", "context": "CREATE TABLE drugs (drug_id INT, drug_name TEXT); INSERT INTO drugs (drug_id, drug_name) VALUES (1001, 'Ibuprofen'), (1002, 'Paracetamol'), (1003, 'Aspirin'); CREATE TABLE sales (sale_id INT, drug_id INT, sale_date DATE, revenue FLOAT); INSERT INTO sales (sale_id, drug_id, sale_date, revenue) VALUES (1, 1001, '2020-04-05', 1800.0), (2, 1002, '2020-04-10', 2300.0), (3, 1003, '2020-04-15', 1400.0), (4, 1001, '2020-05-20', 1900.0), (5, 1002, '2020-06-25', 2400.0);", "reference_sql": "SELECT drug_name, SUM(revenue) as total_sales FROM sales JOIN drugs ON sales.drug_id = drugs.drug_id WHERE sale_date BETWEEN '2020-04-01' AND '2020-06-30' GROUP BY drug_name;", "generated_sql": "SELECT drugs.drug_name, SUM(sales.revenue) AS total_sales \nFROM sales \nJOIN drugs ON sales.drug_id = drugs.drug_id \nWHERE sales.sale_date BETWEEN '2020-04-01' AND '2020-06-30' \nGROUP BY drugs.drug_name;", "raw_model_output": "```sql\nSELECT drugs.drug_name, SUM(sales.revenue) AS total_sales \nFROM sales \nJOIN drugs ON sales.drug_id = drugs.drug_id \nWHERE sales.sale_date BETWEEN '2020-04-01' AND '2020-06-30' \nGROUP BY drugs.drug_name;\n```", "latency_sec": 2.53574800491333, "total_duration_sec": 2.387901202, "load_duration_sec": 0.016045484, "tokens_prompt": 1291, "prompt_eval_sec": 0.598798188, "tokens_completion": 75, "completion_eval_sec": 1.768721958, "tokens_total": 1366, "tokens_per_sec": 538.6970619135669, "retrieval_latency_sec": 0.12094807624816895, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between 'sales' and 'drugs' on drug_id, filter sales between '2020-04-01' and '2020-06-30', and group by drug_name to calculate total sales. The only differences are syntax variations (column aliasing with table name in Generated SQL vs. bare column name in Reference SQL), which do not affect the semantic result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate total sales per drug for Q2 2020 by joining the drugs and sales tables, filtering dates between '2020-04-01' and '2020-06-30', and grouping by drug name. The reference query uses unqualified column names (e.g., 'drug_name'), which could cause ambiguity in complex schemas, while the generated query explicitly qualifies columns with table aliases ('drugs.drug_name'). The generated version is more robust and follows best practices for clarity and maintainability, though both produce identical results. The date range correctly captures Q2 (April-June) as required.", "overall_assessment": "correct"}}
{"example_id": 2403, "sql_complexity": "multiple_joins", "prompt": "Who is the most frequent customer ordering vegetarian items?", "context": "CREATE TABLE customers (customer_id INT, customer_name VARCHAR(50)); INSERT INTO customers VALUES (1, 'John Doe'), (2, 'Jane Smith'), (3, 'Alice Johnson'); CREATE TABLE orders (order_id INT, customer_id INT, menu_id INT, order_date DATE); INSERT INTO orders VALUES (1, 1, 1, '2022-01-01'), (2, 2, 3, '2022-01-02'), (3, 3, 2, '2022-01-03'); CREATE TABLE menu (menu_id INT, item_name VARCHAR(50), is_vegetarian BOOLEAN, price DECIMAL(5,2)); INSERT INTO menu VALUES (1, 'Veggie Burger', true, 8.99), (2, 'Cheeseburger', false, 7.99), (3, 'Tofu Stir Fry', true, 11.99);", "reference_sql": "SELECT customers.customer_name, COUNT(orders.order_id) as order_count FROM customers INNER JOIN orders ON customers.customer_id = orders.customer_id INNER JOIN menu ON orders.menu_id = menu.menu_id WHERE menu.is_vegetarian = true GROUP BY customers.customer_name ORDER BY order_count DESC LIMIT 1;", "generated_sql": "SELECT c.customer_name \nFROM customers c \nJOIN orders o ON c.customer_id = o.customer_id \nJOIN menu m ON o.menu_id = m.menu_id \nWHERE m.is_vegetarian = true \nGROUP BY c.customer_name \nORDER BY COUNT(*) DESC \nLIMIT 1;", "raw_model_output": "```sql\nSELECT c.customer_name \nFROM customers c \nJOIN orders o ON c.customer_id = o.customer_id \nJOIN menu m ON o.menu_id = m.menu_id \nWHERE m.is_vegetarian = true \nGROUP BY c.customer_name \nORDER BY COUNT(*) DESC \nLIMIT 1;\n```", "latency_sec": 2.229159116744995, "total_duration_sec": 1.994558729, "load_duration_sec": 0.01550923, "tokens_prompt": 1088, "prompt_eval_sec": 0.543382692, "tokens_completion": 63, "completion_eval_sec": 1.431178696, "tokens_total": 1151, "tokens_per_sec": 516.3381973740319, "retrieval_latency_sec": 0.12879014015197754, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the customer with the highest count of vegetarian orders. They use equivalent JOINs, filter on menu.is_vegetarian = true, group by customer_name, and order by count descending. The generated query uses COUNT(*) instead of COUNT(orders.order_id), but since the JOINs ensure each row represents an order, the count results are identical. Aliases and formatting differences do not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly identify the most frequent customer ordering vegetarian items by joining customers, orders, and menu tables, filtering vegetarian items, and counting orders per customer. The Reference SQL uses explicit column names (COUNT(orders.order_id)) while the Generated SQL uses COUNT(*), which are functionally equivalent in this context. Both group by customer_name, order by count descending, and limit to 1 result. The structural differences (aliases, column referencing) do not affect correctness or results. The business intent of measuring order frequency for vegetarian items is fully addressed by both queries.", "overall_assessment": "correct"}}
{"example_id": 124, "sql_complexity": "set operations", "prompt": "Find the intersection of AI and accessibility research projects in the EU and those in Africa.", "context": "CREATE SCHEMA if not exists accessibility; CREATE TABLE if not exists accessibility.research (id INT PRIMARY KEY, project_name VARCHAR(255), region VARCHAR(255)); INSERT INTO accessibility.research (id, project_name, region) VALUES (1, 'AI for Accessibility EU', 'EU'), (2, 'Accessibility Africa', 'Africa'), (3, 'AI for Accessibility Africa', 'Africa'), (4, 'Accessibility EU', 'EU');", "reference_sql": "SELECT project_name FROM accessibility.research WHERE region = 'EU' INTERSECT SELECT project_name FROM accessibility.research WHERE region = 'Africa';", "generated_sql": "SELECT project_name \nFROM accessibility.research \nWHERE region = 'EU' AND project_name LIKE '%AI for Accessibility%'\nINTERSECT\nSELECT project_name \nFROM accessibility.research \nWHERE region = 'Africa' AND project_name LIKE '%AI for Accessibility%';", "raw_model_output": "```sql\nSELECT project_name \nFROM accessibility.research \nWHERE region = 'EU' AND project_name LIKE '%AI for Accessibility%'\nINTERSECT\nSELECT project_name \nFROM accessibility.research \nWHERE region = 'Africa' AND project_name LIKE '%AI for Accessibility%';\n```", "latency_sec": 1.7902610301971436, "total_duration_sec": 1.766132897, "load_duration_sec": 0.01572082, "tokens_prompt": 848, "prompt_eval_sec": 0.345992702, "tokens_completion": 58, "completion_eval_sec": 1.399588247, "tokens_total": 906, "tokens_per_sec": 506.07145255249804, "retrieval_latency_sec": 0.1255040168762207, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query finds project names present in both 'EU' and 'Africa' regions without any name restrictions. The generated query adds LIKE '%AI for Accessibility%' conditions to both subqueries, making it more restrictive. This means the generated query only considers project names containing 'AI for Accessibility', potentially excluding valid intersections that exist in the reference query. While both return empty sets in the provided data, they are not equivalent for all possible data scenarios.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL is technically correct but fails to address the 'AI and accessibility' filter mentioned in the question. It returns project_name intersections between EU and Africa regions without considering the research focus. The Generated SQL explicitly filters projects containing 'AI for Accessibility' in their names, directly aligning with the business requirement for AI+accessibility research. While both queries return empty results in the sample data (due to no overlapping project names between regions), the Generated SQL better fulfills the intent by incorporating the critical 'AI and accessibility' criterion. The Reference SQL could include irrelevant projects if they existed in both regions.", "overall_assessment": "differently_correct"}}
{"example_id": 1231, "sql_complexity": "basic SQL", "prompt": "What is the average ticket price for performances at the 'Downtown Theater'?", "context": "CREATE TABLE DowntownTheater (show_name TEXT, date DATE, ticket_price FLOAT); INSERT INTO DowntownTheater (show_name, date, ticket_price) VALUES ('Play 1', '2022-01-01', 30.0), ('Play 2', '2022-01-02', 40.0), ('Concert 1', '2022-01-03', 50.0);", "reference_sql": "SELECT AVG(ticket_price) FROM DowntownTheater WHERE show_name = 'Downtown Theater'", "generated_sql": "SELECT AVG(ticket_price) FROM DowntownTheater;", "raw_model_output": "```sql\nSELECT AVG(ticket_price) FROM DowntownTheater;\n```", "latency_sec": 0.8077688217163086, "total_duration_sec": 0.749165265, "load_duration_sec": 0.022880149, "tokens_prompt": 827, "prompt_eval_sec": 0.333871009, "tokens_completion": 15, "completion_eval_sec": 0.384667347, "tokens_total": 842, "tokens_per_sec": 1042.3774443422546, "retrieval_latency_sec": 0.13619422912597656, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters for show_name = 'Downtown Theater' which doesn't exist in the sample data (the actual shows are 'Play 1', 'Play 2', 'Concert 1'), resulting in an average of NULL. The Generated SQL calculates the average of all ticket prices (30, 40, 50) which is 40.0. The WHERE clause in the Reference SQL changes the result set entirely.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query incorrectly filters for shows named 'Downtown Theater' (a theater name) in the show_name column, which appears to store show titles, not venue names. The generated query correctly averages all ticket prices in the DowntownTheater table. While neither query perfectly aligns with the schema (since show_name likely represents performance titles, not venue names), the generated query at least retrieves data specific to the DowntownTheater table. The reference query would return NULL or 0 if no shows match the invalid filter, while the generated query provides a valid average for all performances in the table.", "overall_assessment": "differently_correct"}}
{"example_id": 1485, "sql_complexity": "set operations", "prompt": "How many public schools and public libraries exist in total, in the 'CityData' schema's 'CityEducation' and 'CityLibrary' tables?", "context": "CREATE SCHEMA CityData; CREATE TABLE CityEducation (Name varchar(255), Type varchar(255)); INSERT INTO CityEducation (Name, Type) VALUES ('SchoolA', 'Public'), ('SchoolB', 'Public'), ('SchoolC', 'Private'); CREATE TABLE CityLibrary (Name varchar(255), Type varchar(255)); INSERT INTO CityLibrary (Name, Type) VALUES ('LibraryA', 'Public'), ('LibraryB', 'Public'), ('LibraryC', 'Private');", "reference_sql": "SELECT COUNT(*) FROM CityData.CityEducation WHERE Type = 'Public' UNION ALL SELECT COUNT(*) FROM CityData.CityLibrary WHERE Type = 'Public';", "generated_sql": "SELECT \n    (SELECT COUNT(*) FROM CityData.CityEducation WHERE Type = 'Public') + \n    (SELECT COUNT(*) FROM CityData.CityLibrary WHERE Type = 'Public') AS TotalPublicSchoolsAndLibraries;", "raw_model_output": "```sql\nSELECT \n    (SELECT COUNT(*) FROM CityData.CityEducation WHERE Type = 'Public') + \n    (SELECT COUNT(*) FROM CityData.CityLibrary WHERE Type = 'Public') AS TotalPublicSchoolsAndLibraries;\n```", "latency_sec": 1.554198980331421, "total_duration_sec": 1.524239011, "load_duration_sec": 0.016386855, "tokens_prompt": 769, "prompt_eval_sec": 0.321036497, "tokens_completion": 50, "completion_eval_sec": 1.182557518, "tokens_total": 819, "tokens_per_sec": 526.9595530331352, "retrieval_latency_sec": 0.14220404624938965, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query returns two separate counts (schools and libraries) as two rows via UNION ALL, while the generated query returns a single summed value. The output structure and results differ: the first produces two rows with individual counts, the second produces one row with the total.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL returns two separate counts (schools and libraries) as individual rows via UNION ALL, while the Generated SQL calculates a single summed total. Although both correctly count public institutions, the original question explicitly asks for a 'total' value, which the Generated SQL provides directly. The Reference requires manual summation of results to answer the question. Both are technically correct, but the Generated query better fulfills the business intent of providing a combined total.", "overall_assessment": "differently_correct"}}
{"example_id": 5806, "sql_complexity": "single join", "prompt": "List the top 3 countries with the most veteran employment in the IT industry", "context": "CREATE TABLE veteran_employment (employee_id INT, industry VARCHAR(255), salary DECIMAL(10,2), state VARCHAR(2), country VARCHAR(255)); CREATE TABLE countries (country_id INT, country VARCHAR(255));", "reference_sql": "SELECT country, COUNT(*) as num_veterans FROM veteran_employment JOIN countries ON veteran_employment.country = countries.country WHERE industry = 'IT' GROUP BY country ORDER BY num_veterans DESC LIMIT 3;", "generated_sql": "SELECT c.country, COUNT(v.employee_id) AS veteran_count \nFROM veteran_employment v \nJOIN countries c ON v.country = c.country \nWHERE v.industry = 'IT' \nGROUP BY c.country \nORDER BY veteran_count DESC \nLIMIT 3;", "raw_model_output": "```sql\nSELECT c.country, COUNT(v.employee_id) AS veteran_count \nFROM veteran_employment v \nJOIN countries c ON v.country = c.country \nWHERE v.industry = 'IT' \nGROUP BY c.country \nORDER BY veteran_count DESC \nLIMIT 3;\n```", "latency_sec": 2.1371548175811768, "total_duration_sec": 1.837649547, "load_duration_sec": 0.015974339, "tokens_prompt": 1011, "prompt_eval_sec": 0.386408561, "tokens_completion": 58, "completion_eval_sec": 1.430943123, "tokens_total": 1069, "tokens_per_sec": 500.19773542184925, "retrieval_latency_sec": 0.1353912353515625, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the top 3 countries with the most veterans in the 'IT' industry. They perform the same inner join between veteran_employment and countries tables on the country column, filter for industry 'IT', group by country, and order by count descending. The only differences are table aliases (v/c vs. original) and COUNT(*) vs COUNT(v.employee_id), which are functionally equivalent in this context since the join ensures non-null employee_id values.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically correct and produce identical results. They both join the veteran_employment and countries tables on the country field, filter for IT industry, group by country, count veterans, and order by descending count. The reference query uses COUNT(*) while the generated query uses COUNT(v.employee_id), but since employee_id is a primary key (non-NULL), both count the same number of rows. The generated query uses table aliases (v and c) which improves readability but does not affect functionality. Neither query has performance advantages over the other. Both fully address the business intent of identifying top 3 countries with IT veteran employment.", "overall_assessment": "correct"}}
{"example_id": 4126, "sql_complexity": "window functions", "prompt": "What is the average crime rate per capita in each neighborhood?", "context": "CREATE TABLE neighborhoods (name VARCHAR(255), population INT, crime_count INT); INSERT INTO neighborhoods (name, population, crime_count) VALUES ('Central Park', 1000, 25), ('Harlem', 2500, 75), ('Brooklyn', 5000, 120);", "reference_sql": "SELECT name, AVG(crime_count/population) OVER (PARTITION BY name) FROM neighborhoods;", "generated_sql": "SELECT name, (crime_count / population) AS avg_crime_rate_per_capita \nFROM neighborhoods;", "raw_model_output": "```sql\nSELECT name, (crime_count / population) AS avg_crime_rate_per_capita \nFROM neighborhoods;\n```", "latency_sec": 1.012786865234375, "total_duration_sec": 0.974435891, "load_duration_sec": 0.019411532, "tokens_prompt": 783, "prompt_eval_sec": 0.322443005, "tokens_completion": 26, "completion_eval_sec": 0.628666382, "tokens_total": 809, "tokens_per_sec": 798.7860306746618, "retrieval_latency_sec": 0.1353321075439453, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses a window function to calculate the average of crime_count/population within each name partition, which for unique names (as in the sample data) would equal the individual ratio. However, if there were multiple rows with the same name, the window function would average the ratios, while the Generated SQL would return individual ratios. Since semantic equivalence requires identical results for all possible data scenarios, the queries are not equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries calculate the crime rate per capita (crime_count/population) for each neighborhood. The Reference SQL uses an unnecessary window function (AVG(...) OVER (PARTITION BY name)) which, for unique names, produces the same result as the raw ratio. However, the Generated SQL directly computes the ratio without redundant aggregation, making it more efficient and semantically clearer. While both technically produce identical results in this specific dataset, the Generated SQL better fulfills the business intent by directly answering 'average crime rate per capita' without overcomplicating the calculation.", "overall_assessment": "correct"}}
{"example_id": 4559, "sql_complexity": "basic SQL", "prompt": "List the top 3 energy efficient appliances in the US by energy star rating?", "context": "CREATE TABLE appliances (id INT, name VARCHAR(255), country VARCHAR(255), energy_star_rating INT); INSERT INTO appliances (id, name, country, energy_star_rating) VALUES (1, 'Fridge A', 'USA', 5), (2, 'TV B', 'USA', 4), (3, 'Laptop C', 'USA', 5), (4, 'Microwave D', 'USA', 3);", "reference_sql": "SELECT name, energy_star_rating FROM appliances WHERE country = 'USA' ORDER BY energy_star_rating DESC LIMIT 3;", "generated_sql": "SELECT name, energy_star_rating \nFROM appliances \nWHERE country = 'USA' \nORDER BY energy_star_rating DESC \nLIMIT 3;", "raw_model_output": "```sql\nSELECT name, energy_star_rating \nFROM appliances \nWHERE country = 'USA' \nORDER BY energy_star_rating DESC \nLIMIT 3;\n```", "latency_sec": 1.2068119049072266, "total_duration_sec": 1.139523173, "load_duration_sec": 0.018783548, "tokens_prompt": 767, "prompt_eval_sec": 0.320613053, "tokens_completion": 33, "completion_eval_sec": 0.792575125, "tokens_total": 800, "tokens_per_sec": 662.9036362228295, "retrieval_latency_sec": 0.12789416313171387, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and content, with only whitespace differences (line breaks) between them. Both select the same columns, apply the same WHERE condition, order by the same column in descending order, and limit to 3 results. Semantic equivalence is maintained.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "The reference and generated SQL queries are identical in structure, syntax, and logic. Both correctly filter US appliances, order by energy_star_rating in descending order, and limit results to 3. They produce the same output (Fridge A, Laptop C, TV B) and address the business intent of identifying top energy-efficient appliances. Neither query has efficiency or elegance advantages over the other since they are functionally identical.", "overall_assessment": "correct"}}
{"example_id": 456, "sql_complexity": "window functions", "prompt": "List the intelligence operations and their corresponding threat levels, and rank them based on their threat level and budget.", "context": "CREATE TABLE intel_ops_threat (id INT, operation VARCHAR, threat VARCHAR, budget INT); INSERT INTO intel_ops_threat (id, operation, threat, budget) VALUES (1, 'Operation Red Folder', 'High', 5000000), (2, 'Operation Black Vault', 'Medium', 7000000), (3, 'Operation Blue Sail', 'Low', 6000000);", "reference_sql": "SELECT operation, threat, budget, ROW_NUMBER() OVER (PARTITION BY threat ORDER BY budget DESC) as rank FROM intel_ops_threat;", "generated_sql": "SELECT operation, threat, \n       ROW_NUMBER() OVER (ORDER BY CASE threat \n                                   WHEN 'High' THEN 1 \n                                   WHEN 'Medium' THEN 2 \n                                   WHEN 'Low' THEN 3 \n                                   END, budget DESC) as rank \nFROM intel_ops_threat;", "raw_model_output": "```sql\nSELECT operation, threat, \n       ROW_NUMBER() OVER (ORDER BY CASE threat \n                                   WHEN 'High' THEN 1 \n                                   WHEN 'Medium' THEN 2 \n                                   WHEN 'Low' THEN 3 \n                                   END, budget DESC) as rank \nFROM intel_ops_threat;\n```", "latency_sec": 1.9712409973144531, "total_duration_sec": 1.85725986, "load_duration_sec": 0.01410059, "tokens_prompt": 797, "prompt_eval_sec": 0.324074737, "tokens_completion": 64, "completion_eval_sec": 1.514612553, "tokens_total": 861, "tokens_per_sec": 436.78068849673633, "retrieval_latency_sec": 0.1318809986114502, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL partitions by 'threat' and ranks within each group by budget, while the Generated SQL orders all rows by a custom threat priority and budget without partitioning. This results in different ranking sequences: the Reference ranks within threat categories, whereas the Generated ranks all rows in a single sequence ordered by threat level (High/Medium/Low) and budget.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The Reference SQL ranks operations within each threat level (e.g., High, Medium, Low) separately, while the Generated SQL ranks all operations in a single sequence ordered by threat priority (High > Medium > Low) and then by budget. The original question asks to 'rank them based on their threat level and budget,' which the Generated SQL addresses by combining both criteria in a unified ranking. The Reference SQL only ranks within threat categories, which partially fulfills the intent but misses the cross-category ranking. The Generated SQL better captures the business requirement by prioritizing threat levels first and budget second in the ranking.", "overall_assessment": "differently_correct"}}
{"example_id": 459, "sql_complexity": "set operations", "prompt": "What is the total installed capacity of hydroelectric power plants in Brazil and Canada?", "context": "CREATE TABLE hydroelectric_power (country TEXT, capacity INTEGER); INSERT INTO hydroelectric_power (country, capacity) VALUES ('Brazil', 104000), ('Canada', 78000), ('China', 350000), ('United States', 100000), ('Russia', 45000);", "reference_sql": "(SELECT capacity FROM hydroelectric_power WHERE country = 'Brazil') UNION (SELECT capacity FROM hydroelectric_power WHERE country = 'Canada');", "generated_sql": "SELECT SUM(capacity) FROM hydroelectric_power WHERE country IN ('Brazil', 'Canada');", "raw_model_output": "```sql\nSELECT SUM(capacity) FROM hydroelectric_power WHERE country IN ('Brazil', 'Canada');\n```", "latency_sec": 1.210468053817749, "total_duration_sec": 0.968072117, "load_duration_sec": 0.015456134, "tokens_prompt": 885, "prompt_eval_sec": 0.353615729, "tokens_completion": 23, "completion_eval_sec": 0.595111504, "tokens_total": 908, "tokens_per_sec": 750.1230595357048, "retrieval_latency_sec": 0.12621712684631348, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate capacity values for Brazil and Canada using UNION, while the Generated SQL returns the sum of capacities for both countries. The first produces two rows of individual values, the second produces a single row with the total sum.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL retrieves individual capacities for Brazil and Canada using UNION, which returns two separate rows instead of a total. The Generated SQL correctly uses SUM() to calculate the combined capacity, directly answering the question. While both queries are technically valid, they produce different result structures (two rows vs. one aggregated value). The Generated SQL better fulfills the business intent of calculating total capacity. The Reference SQL fails to aggregate values, making it semantically incorrect for the question.", "overall_assessment": "correct"}}
{"example_id": 2356, "sql_complexity": "window functions", "prompt": "Find the total billing amount for attorneys in the 'Criminal Law' practice area, for the year 2020, partitioned by attorney's last name and ordered by the total billing amount in descending order.", "context": "CREATE TABLE Attorneys (AttorneyID INT, FirstName VARCHAR(50), LastName VARCHAR(50), PracticeArea VARCHAR(50), TotalBilling FLOAT, BillingYear INT); INSERT INTO Attorneys (AttorneyID, FirstName, LastName, PracticeArea, TotalBilling, BillingYear) VALUES (1, 'Clara', 'Rivera', 'Personal Injury', 8000.00, 2020), (2, 'Jamal', 'Lee', 'Personal Injury', 6000.00, 2019), (3, 'Sophia', 'Gomez', 'Criminal Law', 9000.00, 2020);", "reference_sql": "SELECT LastName, SUM(TotalBilling) OVER (PARTITION BY PracticeArea, LastName, BillingYear) AS TotalBilling FROM Attorneys WHERE PracticeArea = 'Criminal Law' AND BillingYear = 2020 ORDER BY TotalBilling DESC;", "generated_sql": "SELECT LastName, SUM(TotalBilling) OVER (PARTITION BY LastName) AS TotalBilling \nFROM Attorneys \nWHERE PracticeArea = 'Criminal Law' AND BillingYear = 2020 \nORDER BY TotalBilling DESC;", "raw_model_output": "```sql\nSELECT LastName, SUM(TotalBilling) OVER (PARTITION BY LastName) AS TotalBilling \nFROM Attorneys \nWHERE PracticeArea = 'Criminal Law' AND BillingYear = 2020 \nORDER BY TotalBilling DESC;\n```", "latency_sec": 2.011169195175171, "total_duration_sec": 1.697052596, "load_duration_sec": 0.015951901, "tokens_prompt": 979, "prompt_eval_sec": 0.376453081, "tokens_completion": 53, "completion_eval_sec": 1.300781614, "tokens_total": 1032, "tokens_per_sec": 513.1343511405134, "retrieval_latency_sec": 0.1450657844543457, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter to 'Criminal Law' in 2020, and the Generated SQL's window function partitions by LastName. Since the WHERE clause ensures all rows have the same PracticeArea and BillingYear, partitioning by LastName alone in the Generated SQL produces the same grouping as partitioning by PracticeArea, LastName, and BillingYear in the Reference SQL. The SUM calculation remains identical because all rows in the result set share the same PracticeArea and BillingYear values.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries produce the same results because the WHERE clause filters PracticeArea='Criminal Law' and BillingYear=2020, making the additional partitioning by PracticeArea and BillingYear in the Reference SQL redundant. The Generated SQL's simpler partitioning by LastName achieves the same outcome. However, the Generated SQL is more efficient as it avoids unnecessary partitioning fields. Both queries correctly partition by attorney's last name and order by total billing, fulfilling the business intent of aggregating billing amounts per last name.", "overall_assessment": "correct"}}
