{"example_id": 2656, "sql_complexity": "multiple_joins", "prompt": "Find the drugs and their respective total sales for rare diseases indication with sales greater than the average sales for infectious diseases.", "context": "CREATE TABLE sales (id INT, drug_id INT, quarter INT, year INT, revenue FLOAT); INSERT INTO sales (id, drug_id, quarter, year, revenue) VALUES (1, 1, 1, 2022, 1500000); CREATE TABLE drugs (id INT, name VARCHAR(50), company VARCHAR(50), indication VARCHAR(50)); INSERT INTO drugs (id, name, company, indication) VALUES (1, 'DrugA', 'ABC Corp', 'Rare_Diseases');", "reference_sql": "SELECT s.drug_id, d.name, SUM(s.revenue) as total_sales FROM sales s JOIN drugs d ON s.drug_id = d.id WHERE d.indication = 'Rare_Diseases' GROUP BY s.drug_id HAVING total_sales > (SELECT AVG(s2.revenue) FROM sales s2 JOIN drugs d2 ON s2.drug_id = d2.id WHERE d2.indication = 'Infectious_Diseases')", "generated_sql": "SELECT d.name AS drug_name, SUM(s.revenue) AS total_sales\nFROM drugs d\nJOIN sales s ON d.id = s.drug_id\nWHERE d.indication = 'Rare_Diseases'\nGROUP BY d.name\nHAVING SUM(s.revenue) > (\n    SELECT AVG(total_revenue) FROM (\n        SELECT SUM(s2.revenue) AS total_revenue\n        FROM sales s2\n        JOIN drugs d2 ON s2.drug_id = d2.id\n        WHERE d2.indication = 'Infectious_Diseases'\n        GROUP BY s2.drug_id\n    ) AS infectious_sales\n);", "raw_model_output": "SELECT d.name AS drug_name, SUM(s.revenue) AS total_sales\nFROM drugs d\nJOIN sales s ON d.id = s.drug_id\nWHERE d.indication = 'Rare_Diseases'\nGROUP BY d.name\nHAVING SUM(s.revenue) > (\n    SELECT AVG(total_revenue) FROM (\n        SELECT SUM(s2.revenue) AS total_revenue\n        FROM sales s2\n        JOIN drugs d2 ON s2.drug_id = d2.id\n        WHERE d2.indication = 'Infectious_Diseases'\n        GROUP BY s2.drug_id\n    ) AS infectious_sales\n);", "latency_sec": 1.8545520305633545, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 196, "prompt_eval_sec": null, "tokens_completion": 133, "completion_eval_sec": null, "tokens_total": 329, "tokens_per_sec": 177.40133173834985, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in how they calculate the threshold for the HAVING clause. The Reference SQL uses AVG(s2.revenue) (average of individual sales revenues for Infectious_Diseases drugs), while the Generated SQL uses AVG(total_revenue) where total_revenue is the sum of sales per drug (average of per-drug totals). This leads to different threshold values, making the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries differ in how they calculate the average sales for infectious diseases. The Reference SQL computes the average of individual sales records (AVG(s2.revenue)), while the Generated SQL correctly calculates the average of total sales per drug (AVG(total_revenue) from aggregated drug-level sales). This makes the Generated SQL more aligned with the business intent of comparing 'total sales' metrics. Additionally, the Reference SQL groups by drug_id but returns drug_name, which could lead to inaccuracies if multiple drugs share the same name. The Generated SQL's approach of grouping by name is less precise than drug_id, but its core calculation of the infectious diseases average is fundamentally correct.", "overall_assessment": "differently_correct"}}
{"example_id": 3008, "sql_complexity": "multiple_joins", "prompt": "Who are the users who used electric vehicles and their trip details?", "context": "CREATE TABLE users (id INT, name VARCHAR(50), age INT, gender VARCHAR(10), city VARCHAR(50));CREATE TABLE vehicles (id INT, vehicle_type VARCHAR(20), is_electric BOOLEAN);CREATE TABLE trips (id INT, user_id INT, vehicle_id INT, trip_distance FLOAT, trip_duration INT, departure_time TIMESTAMP, arrival_time TIMESTAMP);INSERT INTO users (id, name, age, gender, city) VALUES (3, 'Alex', 30, 'Female', 'New York');INSERT INTO vehicles (id, vehicle_type, is_electric) VALUES (1, 'Tesla', true), (2, 'Bike', false);INSERT INTO trips (id, user_id, vehicle_id, trip_distance, trip_duration, departure_time, arrival_time) VALUES (3, 3, 1, 15.3, 25, '2022-01-03 12:00:00', '2022-01-03 12:25:00');", "reference_sql": "SELECT u.name, v.vehicle_type, t.trip_distance, t.trip_duration FROM users u JOIN trips t ON u.id = t.user_id JOIN vehicles v ON t.vehicle_id = v.id WHERE v.is_electric = true;", "generated_sql": "SELECT u.id, u.name, u.age, u.gender, u.city, t.id AS trip_id, t.trip_distance, t.trip_duration, t.departure_time, t.arrival_time\nFROM users u\nJOIN trips t ON u.id = t.user_id\nJOIN vehicles v ON t.vehicle_id = v.id\nWHERE v.is_electric = TRUE;", "raw_model_output": "SELECT u.id, u.name, u.age, u.gender, u.city, t.id AS trip_id, t.trip_distance, t.trip_duration, t.departure_time, t.arrival_time\nFROM users u\nJOIN trips t ON u.id = t.user_id\nJOIN vehicles v ON t.vehicle_id = v.id\nWHERE v.is_electric = TRUE;", "latency_sec": 0.9687027931213379, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 287, "prompt_eval_sec": null, "tokens_completion": 75, "completion_eval_sec": null, "tokens_total": 362, "tokens_per_sec": 373.6956294237262, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL selects only 4 columns (name, vehicle_type, trip_distance, trip_duration), while the Generated SQL selects 10 columns (including user details, trip IDs, and timestamps). Although both filter for electric vehicles, the result sets have different structures and data content.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent because the generated SQL selects additional user columns (id, age, gender, city) and trip columns (trip_id, departure_time, arrival_time) not present in the reference query. Both queries correctly join users, trips, and vehicles tables with the same WHERE condition (v.is_electric = true), ensuring they retrieve the same core data about electric vehicle users and their trips. However, the reference query is more focused on the exact data requested (user name and trip details), while the generated query includes extra information. Both fulfill the business intent of identifying electric vehicle users and their trip details, but the reference is more concise and directly aligned with the question's requirements.", "overall_assessment": "differently_correct"}}
{"example_id": 2531, "sql_complexity": "basic SQL", "prompt": "Who is the top customer by sales in 2022?", "context": "CREATE TABLE customers (customer_id INT, total_sales_2022 FLOAT); INSERT INTO customers (customer_id, total_sales_2022) VALUES (1, 25000.0), (2, 30000.0), (3, 22000.0), (4, 35000.0);", "reference_sql": "SELECT customer_id, total_sales_2022 FROM customers ORDER BY total_sales_2022 DESC LIMIT 1;", "generated_sql": "SELECT customer_id\nFROM customers\nORDER BY total_sales_2022 DESC\nLIMIT 1;", "raw_model_output": "SELECT customer_id\nFROM customers\nORDER BY total_sales_2022 DESC\nLIMIT 1;", "latency_sec": 0.7367041110992432, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 144, "prompt_eval_sec": null, "tokens_completion": 21, "completion_eval_sec": null, "tokens_total": 165, "tokens_per_sec": 223.97051613272788, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query selects both customer_id and total_sales_2022 columns, while the generated query only selects customer_id. Although both order by total_sales_2022 DESC and limit 1, the result sets differ in column structure (two columns vs one).", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify the top customer by sales in 2022. The reference query includes the total_sales_2022 column, while the generated query only returns customer_id. Since the question asks for 'who' the top customer is (customer_id), both technically fulfill the intent. However, the generated query is more efficient as it retrieves only the necessary column. The reference query's additional column doesn't affect correctness but adds unnecessary data. Both are logically equivalent for this specific question.", "overall_assessment": "correct"}}
{"example_id": 3792, "sql_complexity": "single join", "prompt": "What is the maximum distance traveled by an electric vehicle in a single trip, grouped by vehicle model?", "context": "CREATE TABLE Trips (trip_id INT, vehicle_id INT, distance FLOAT); CREATE TABLE ElectricVehicleModels (vehicle_id INT, vehicle_model TEXT);", "reference_sql": "SELECT evm.vehicle_model, MAX(trips.distance) AS max_distance_traveled FROM Trips trips INNER JOIN ElectricVehicleModels evm ON trips.vehicle_id = evm.vehicle_id GROUP BY 1;", "generated_sql": "SELECT \n    evm.vehicle_model,\n    MAX(t.distance) AS max_distance\nFROM \n    Trips t\nJOIN \n    ElectricVehicleModels evm ON t.vehicle_id = evm.vehicle_id\nGROUP BY \n    evm.vehicle_model;", "raw_model_output": "SELECT \n    evm.vehicle_model,\n    MAX(t.distance) AS max_distance\nFROM \n    Trips t\nJOIN \n    ElectricVehicleModels evm ON t.vehicle_id = evm.vehicle_id\nGROUP BY \n    evm.vehicle_model;", "latency_sec": 0.7630143165588379, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 116, "prompt_eval_sec": null, "tokens_completion": 51, "completion_eval_sec": null, "tokens_total": 167, "tokens_per_sec": 218.86876350258132, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the maximum distance traveled per vehicle model by joining the Trips and ElectricVehicleModels tables. The only differences are table aliases (trips vs. t) and grouping syntax (GROUP BY 1 vs. GROUP BY evm.vehicle_model). These are syntactic variations that do not affect the semantic result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically correct and produce identical results. They both join the Trips and ElectricVehicleModels tables on vehicle_id, calculate the maximum distance per vehicle model, and group by vehicle_model. The reference query uses a positional GROUP BY (GROUP BY 1), which is valid in some SQL dialects but less explicit. The generated query uses the explicit column name in the GROUP BY clause, making it more readable, portable, and less ambiguous. While both fulfill the business intent of finding the maximum distance per vehicle model, the generated query is more elegant and robust.", "overall_assessment": "correct"}}
{"example_id": 2311, "sql_complexity": "subqueries", "prompt": "Determine the percentage of sales from each ingredient category", "context": "CREATE TABLE Sales_Details (sale_id INT, ingredient_id INT, quantity INT); INSERT INTO Sales_Details (sale_id, ingredient_id, quantity) VALUES (1, 1, 2), (1, 2, 8), (2, 1, 3), (2, 2, 7); CREATE TABLE Ingredient_Categories (ingredient_id INT, ingredient_category VARCHAR(255)); INSERT INTO Ingredient_Categories (ingredient_id, ingredient_category) VALUES (1, 'Legumes'), (2, 'Poultry');", "reference_sql": "SELECT ingredient_category, SUM(quantity) AS total_quantity, SUM(quantity) * 100.0 / (SELECT SUM(quantity) FROM Sales_Details) AS percentage_of_sales FROM Sales_Details, Ingredient_Categories WHERE Sales_Details.ingredient_id = Ingredient_Categories.ingredient_id GROUP BY ingredient_category;", "generated_sql": "SELECT \n    ic.ingredient_category,\n    (SUM(sd.quantity) * 100.0) / total_quantity.total AS percentage_of_sales\nFROM \n    Sales_Details sd\nJOIN \n    Ingredient_Categories ic ON sd.ingredient_id = ic.ingredient_id\nCROSS JOIN\n    (SELECT SUM(quantity) AS total FROM Sales_Details) total_quantity\nGROUP BY \n    ic.ingredient_category, total_quantity.total;", "raw_model_output": "SELECT \n    ic.ingredient_category,\n    (SUM(sd.quantity) * 100.0) / total_quantity.total AS percentage_of_sales\nFROM \n    Sales_Details sd\nJOIN \n    Ingredient_Categories ic ON sd.ingredient_id = ic.ingredient_id\nCROSS JOIN\n    (SELECT SUM(quantity) AS total FROM Sales_Details) total_quantity\nGROUP BY \n    ic.ingredient_category, total_quantity.total;", "latency_sec": 0.8068039417266846, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 189, "prompt_eval_sec": null, "tokens_completion": 89, "completion_eval_sec": null, "tokens_total": 278, "tokens_per_sec": 344.5694618261746, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the total quantity per ingredient category and its percentage of total sales. The Reference SQL uses an implicit join and a scalar subquery for the total, while the Generated SQL uses an explicit JOIN and a CROSS JOIN with a derived table for the total. The grouping and aggregation logic are equivalent, and the percentage calculation uses the same total value. The GROUP BY in the Generated SQL includes the total, but since it's a scalar, it doesn't affect the grouping outcome.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the percentage of sales per ingredient category by summing quantities and dividing by total sales. The reference query uses an implicit join and a correlated subquery, while the generated query uses explicit JOIN syntax and a CROSS JOIN with a derived table. The generated version is more modern, avoids potential Cartesian product risks from implicit joins, and explicitly materializes the total in a derived table, which may improve readability and optimization. Both handle grouping correctly, but the generated query's structure is more robust and efficient.", "overall_assessment": "correct"}}
{"example_id": 3329, "sql_complexity": "set operations", "prompt": "Which causes received funding from donors in both the United States and Canada?", "context": "CREATE TABLE donor_location (donor_id INT, country VARCHAR(50), cause VARCHAR(50), donation DECIMAL(10,2)); INSERT INTO donor_location (donor_id, country, cause, donation) VALUES (1, 'United States', 'Global Health', 1000.00), (2, 'Canada', 'Education', 2000.00), (3, 'United States', 'Environment', 1500.00), (4, 'Canada', 'Animal Welfare', 2500.00);", "reference_sql": "SELECT cause FROM donor_location WHERE country = 'United States' INTERSECT SELECT cause FROM donor_location WHERE country = 'Canada';", "generated_sql": "SELECT cause\nFROM donor_location\nWHERE country IN ('United States', 'Canada')\nGROUP BY cause\nHAVING COUNT(DISTINCT country) = 2;", "raw_model_output": "SELECT cause\nFROM donor_location\nWHERE country IN ('United States', 'Canada')\nGROUP BY cause\nHAVING COUNT(DISTINCT country) = 2;", "latency_sec": 0.8903448581695557, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 189, "prompt_eval_sec": null, "tokens_completion": 34, "completion_eval_sec": null, "tokens_total": 223, "tokens_per_sec": 250.46474739963318, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve causes that appear in both 'United States' and 'Canada'. The reference uses INTERSECT to find common causes between the two countries, while the generated query groups by cause and ensures there are entries in both countries via COUNT(DISTINCT country) = 2. Both approaches yield the same result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly identify causes with donations from both the United States and Canada. The Reference SQL uses INTERSECT to find common causes between two country-specific subqueries, while the Generated SQL uses GROUP BY and HAVING to ensure a cause appears in both countries. Both approaches are logically equivalent and produce identical results. The efficiency difference is negligible for small datasets, and both satisfy the business intent of identifying cross-border funding causes.", "overall_assessment": "correct"}}
{"example_id": 2912, "sql_complexity": "single join", "prompt": "Which company has manufactured the most satellites?", "context": "CREATE TABLE manufacturers (id INT, name TEXT); CREATE TABLE satellites (id INT, manufacturer_id INT, name TEXT, launch_date DATE); INSERT INTO manufacturers (id, name) VALUES (1, 'SpaceX'), (2, 'Blue Origin'), (3, 'ISRO'), (4, 'CAST'); INSERT INTO satellites (id, manufacturer_id, name, launch_date) VALUES (1, 1, 'StarDragon', '2012-05-25'), (2, 1, 'Falcon', '2015-12-21'), (3, 2, 'New Glenn', '2022-01-11'), (4, 3, 'ChinaSat 1E', '2000-12-05'), (5, 3, 'ChinaSat 2A', '2003-08-13'), (6, 4, 'Shijian 9', '2017-11-19'), (7, 1, 'StarLink', '2020-05-24'), (8, 1, 'StarLink', '2020-06-13');", "reference_sql": "SELECT m.name, COUNT(s.id) FROM manufacturers m JOIN satellites s ON m.id = s.manufacturer_id GROUP BY m.name ORDER BY COUNT(s.id) DESC;", "generated_sql": "SELECT m.name AS manufacturer_name\nFROM manufacturers m\nJOIN satellites s ON m.id = s.manufacturer_id\nGROUP BY m.id, m.name\nORDER BY COUNT(s.id) DESC\nLIMIT 1;", "raw_model_output": "SELECT m.name AS manufacturer_name\nFROM manufacturers m\nJOIN satellites s ON m.id = s.manufacturer_id\nGROUP BY m.id, m.name\nORDER BY COUNT(s.id) DESC\nLIMIT 1;", "latency_sec": 0.7527239322662354, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 307, "prompt_eval_sec": null, "tokens_completion": 44, "completion_eval_sec": null, "tokens_total": 351, "tokens_per_sec": 466.306417205628, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns all manufacturers with their satellite counts ordered by count descending, while the Generated SQL only returns the top manufacturer (due to LIMIT 1). The Generated query also groups by both m.id and m.name, which is more restrictive than the Reference's group by m.name alone. The output structures differ (multiple rows vs. single row).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query returns all manufacturers sorted by satellite count, while the generated query explicitly retrieves only the top manufacturer using LIMIT 1. Both correctly count satellites per manufacturer, but the generated query better fulfills the business intent of identifying 'the company' with the most satellites. The generated query is more efficient (avoids unnecessary sorting) and explicitly addresses the singular nature of the question. The reference query could return multiple rows, requiring additional processing to extract the top result.", "overall_assessment": "differently_correct"}}
{"example_id": 3170, "sql_complexity": "aggregation", "prompt": "Determine the total production quantity of silver for mining sites in Mexico, between the dates '2017-05-01' and '2017-09-30', having less than 40 employees.", "context": "CREATE TABLE silver_mine_2 (site_id INT, country VARCHAR(50), num_employees INT, extraction_date DATE, quantity INT); INSERT INTO silver_mine_2 (site_id, country, num_employees, extraction_date, quantity) VALUES (1, 'Mexico', 35, '2017-05-02', 1200), (2, 'Mexico', 30, '2017-08-31', 1800), (3, 'Mexico', 37, '2017-07-04', 2200);", "reference_sql": "SELECT country, SUM(quantity) as total_silver_prod FROM silver_mine_2 WHERE num_employees < 40 AND country = 'Mexico' AND extraction_date >= '2017-05-01' AND extraction_date <= '2017-09-30' GROUP BY country;", "generated_sql": "SELECT SUM(quantity) AS total_quantity\nFROM silver_mine_2\nWHERE country = 'Mexico'\n  AND extraction_date BETWEEN '2017-05-01' AND '2017-09-30'\n  AND num_employees < 40;", "raw_model_output": "SELECT SUM(quantity) AS total_quantity\nFROM silver_mine_2\nWHERE country = 'Mexico'\n  AND extraction_date BETWEEN '2017-05-01' AND '2017-09-30'\n  AND num_employees < 40;", "latency_sec": 0.9405510425567627, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 222, "prompt_eval_sec": null, "tokens_completion": 53, "completion_eval_sec": null, "tokens_total": 275, "tokens_per_sec": 292.38179275464853, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the total silver production for Mexican mines with fewer than 40 employees between 2017-05-01 and 2017-09-30. The Reference SQL includes a GROUP BY country (which is redundant here since all results are Mexico) and selects the country column, while the Generated SQL omits the GROUP BY and country column. However, since the WHERE clause filters to a single country, both queries return the same numerical result (sum of quantity). The semantic outcome is equivalent for the given data and conditions.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly filter for Mexico, dates between '2017-05-01' and '2017-09-30', and sites with <40 employees. The reference query includes an unnecessary GROUP BY country (since all results are Mexico) and explicitly lists date conditions with >=/<=, while the generated query uses the more concise BETWEEN operator. The generated query is more efficient and elegant while producing identical results. Both fulfill the business intent of calculating total silver production under the specified constraints.", "overall_assessment": "correct"}}
{"example_id": 3518, "sql_complexity": "basic SQL", "prompt": "Insert new records of ticket sales for a new event, including event and salesperson information.", "context": "CREATE TABLE salesperson (salesperson_id INT, name VARCHAR(50), position VARCHAR(50)); CREATE TABLE tickets (ticket_id INT, salesperson_id INT, event_id INT, price DECIMAL(5,2), quantity INT); CREATE TABLE events (event_id INT, name VARCHAR(50), date DATE); INSERT INTO salesperson VALUES (1, 'John Doe', 'Senior Salesperson'); INSERT INTO events VALUES (2, 'New Event', '2023-04-15');", "reference_sql": "INSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity) VALUES (2, 1, 2, 75, 50), (3, 2, 2, 65, 75); INSERT INTO events (event_id, name, date) VALUES (2, 'New Event', '2023-04-15');", "generated_sql": "Insert a new event\nINSERT INTO events (event_id, name, date) VALUES (3, 'Upcoming Event', '2023-05-20');", "raw_model_output": "-- Insert a new event\nINSERT INTO events (event_id, name, date) VALUES (3, 'Upcoming Event', '2023-05-20');\n\n-- Insert new ticket sales associated with the new event and salesperson\nINSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity)\nVALUES (101, 1, 3, 50.00, 2),\n       (102, 1, 3, 75.00, 1);", "latency_sec": 1.4010138511657715, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 181, "prompt_eval_sec": null, "tokens_completion": 100, "completion_eval_sec": null, "tokens_total": 281, "tokens_per_sec": 200.5690377480439, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL inserts data into both 'tickets' and 'events' tables, including a duplicate event_id (2) in the events table. The Generated SQL only inserts a new event into the 'events' table with a different event_id (3). The operations target different tables and data, so they are not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference SQL inserts records into both the tickets and events tables, addressing the requirement to add ticket sales records (with salesperson/event info) and a new event. However, it redundantly inserts event_id 2 which already exists. The generated SQL only inserts a new event without any ticket sales data, failing to address the core requirement of adding ticket sales records. While the reference has a potential redundancy, it better fulfills the business intent of inserting ticket sales data. The generated SQL is technically correct for inserting an event but misses the critical ticket sales component.", "overall_assessment": "differently_correct"}}
{"example_id": 3925, "sql_complexity": "set operations", "prompt": "What is the total number of students and staff with accommodations in the \"disability_services\" schema, excluding the \"accessibility_parking\" type?", "context": "CREATE SCHEMA disability_services; CREATE TABLE staff (id INT, name VARCHAR(50), accommodation VARCHAR(50)); CREATE TABLE students (id INT, name VARCHAR(50), accommodation VARCHAR(50));", "reference_sql": "SELECT COUNT(*) FROM disability_services.staff WHERE accommodation != 'accessibility_parking' UNION SELECT COUNT(*) FROM disability_services.students WHERE accommodation != 'accessibility_parking';", "generated_sql": "SELECT \n  (SELECT COUNT(*) FROM disability_services.students WHERE accommodation <> 'accessibility_parking') +\n  (SELECT COUNT(*) FROM disability_services.staff WHERE accommodation <> 'accessibility_parking') AS total_with_accommodation;", "raw_model_output": "SELECT \n  (SELECT COUNT(*) FROM disability_services.students WHERE accommodation <> 'accessibility_parking') +\n  (SELECT COUNT(*) FROM disability_services.staff WHERE accommodation <> 'accessibility_parking') AS total_with_accommodation;", "latency_sec": 0.6621420383453369, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 137, "prompt_eval_sec": null, "tokens_completion": 46, "completion_eval_sec": null, "tokens_total": 183, "tokens_per_sec": 276.3757462935124, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate counts (staff and students) as individual rows via UNION, while the Generated SQL calculates the sum of both counts as a single value. The result structures differ (two rows vs. one row) even if the numerical values might match.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query uses UNION to combine two separate counts, resulting in two rows of output rather than a single total. The generated query correctly calculates the sum of both counts in a single numeric result. Both use equivalent NOT EQUAL conditions (!= vs <>), but the generated query's structure directly addresses the request for a 'total number' by summing the values. The reference query fails to fulfill the business intent because it doesn't return a single aggregated total.", "overall_assessment": "differently_correct"}}
{"example_id": 3340, "sql_complexity": "subqueries", "prompt": "Calculate the total revenue for garments manufactured in the US and sold in California.", "context": "CREATE TABLE garment_manufacturing(id INT PRIMARY KEY, garment_id INT, country VARCHAR(50), material VARCHAR(50), manufacturing_date DATE, quantity INT); CREATE TABLE garment_sales(id INT PRIMARY KEY, garment_id INT, store_id INT, sale_date DATE, units INT, revenue DECIMAL(10,2));", "reference_sql": "SELECT SUM(gs.revenue) FROM garment_manufacturing gm JOIN garment_sales gs ON gm.garment_id = gs.garment_id WHERE gm.country = 'United States' AND gs.store_id IN (SELECT id FROM stores WHERE region = 'California');", "generated_sql": "SELECT SUM(gs.revenue) AS total_revenue\nFROM garment_manufacturing gm\nJOIN garment_sales gs ON gm.garment_id = gs.garment_id\nWHERE gm.country = 'US' AND gs.store_id IN (\n    SELECT store_id FROM stores WHERE state = 'California'\n);", "raw_model_output": "SELECT SUM(gs.revenue) AS total_revenue\nFROM garment_manufacturing gm\nJOIN garment_sales gs ON gm.garment_id = gs.garment_id\nWHERE gm.country = 'US' AND gs.store_id IN (\n    SELECT store_id FROM stores WHERE state = 'California'\n);", "latency_sec": 0.7613708972930908, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 146, "prompt_eval_sec": null, "tokens_completion": 62, "completion_eval_sec": null, "tokens_total": 208, "tokens_per_sec": 273.19142449429626, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects: 1) The country condition uses 'United States' vs 'US' which may not match if the data stores country names as full names vs abbreviations. 2) The subquery references 'region' (reference) vs 'state' (generated) in the stores table, which would produce different results if the stores table has distinct columns for region/state. These differences in literal values and column names make the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in two key technical aspects: 1) The reference uses 'United States' while the generated uses 'US' for country comparison, which may yield different results depending on data storage conventions. 2) The reference queries 'region = 'California'' while the generated uses 'state = 'California'' in the subquery, which could return different store IDs if the stores table uses 'state' instead of 'region'. Both queries correctly join garment_manufacturing and garment_sales, but the generated query's use of 'state' aligns better with the business context of California as a state. The generated query is more concise and uses explicit column aliases in the subquery, improving readability without sacrificing functionality. Both fulfill the business intent of calculating revenue for US-manufactured garments sold in California, but the generated query's technical choices are more aligned with typical schema design patterns.", "overall_assessment": "differently_correct"}}
{"example_id": 596, "sql_complexity": "basic SQL", "prompt": "What is the minimum energy production cost of wind farms in Spain?", "context": "CREATE TABLE wind_farm_costs (id INT, name TEXT, country TEXT, energy_production_cost FLOAT); INSERT INTO wind_farm_costs (id, name, country, energy_production_cost) VALUES (1, 'Las Tiesas', 'Spain', 0.045), (2, 'Eolo', 'Spain', 0.050);", "reference_sql": "SELECT MIN(energy_production_cost) FROM wind_farm_costs WHERE country = 'Spain';", "generated_sql": "SELECT MIN(energy_production_cost) AS min_cost\nFROM wind_farm_costs\nWHERE country = 'Spain';", "raw_model_output": "SELECT MIN(energy_production_cost) AS min_cost\nFROM wind_farm_costs\nWHERE country = 'Spain';", "latency_sec": 0.9702987670898438, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 155, "prompt_eval_sec": null, "tokens_completion": 26, "completion_eval_sec": null, "tokens_total": 181, "tokens_per_sec": 186.54048231233145, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the minimum energy_production_cost from the wind_farm_costs table where country is 'Spain'. The generated query adds an alias (AS min_cost) to the result column, but this does not affect the semantic meaning or the actual data returned. The core logic and output remain identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the minimum energy production cost for Spanish wind farms by filtering on 'Spain' and using MIN(). The generated query adds an explicit alias (AS min_cost) which improves readability without altering the result. While the reference query is functionally identical, the generated version is more elegant as it explicitly names the output column, making the result clearer for downstream consumers. Neither query has technical issues, and both fully address the business intent of identifying the minimum cost.", "overall_assessment": "correct"}}
{"example_id": 2604, "sql_complexity": "subqueries", "prompt": "What is the maximum number of virtual tours taken by a single user in the UK?", "context": "CREATE TABLE virtual_tour_data (user_id INT, hotel_id INT, tour_date DATE); INSERT INTO virtual_tour_data (user_id, hotel_id, tour_date) VALUES (1, 10, '2022-01-01'), (2, 11, '2022-01-03'), (3, 12, '2022-01-05'), (4, 10, '2022-01-07'), (5, 10, '2022-01-09'); CREATE TABLE hotels (hotel_id INT, hotel_name TEXT, country TEXT); INSERT INTO hotels (hotel_id, hotel_name, country) VALUES (10, 'Royal Park Hotel', 'UK'), (11, 'The Ritz London', 'UK'), (12, 'Hotel de Crillon', 'France');", "reference_sql": "SELECT MAX(vt.user_tours) FROM (SELECT user_id, COUNT(DISTINCT hotel_id) as user_tours FROM virtual_tour_data WHERE country = 'UK' GROUP BY user_id) as vt;", "generated_sql": "SELECT MAX(tour_count) AS max_tours\nFROM (\n    SELECT user_id, COUNT(*) AS tour_count\n    FROM virtual_tour_data vtd\n    JOIN hotels h ON vtd.hotel_id = h.hotel_id\n    WHERE h.country = 'UK'\n    GROUP BY user_id\n) sub;", "raw_model_output": "SELECT MAX(tour_count) AS max_tours\nFROM (\n    SELECT user_id, COUNT(*) AS tour_count\n    FROM virtual_tour_data vtd\n    JOIN hotels h ON vtd.hotel_id = h.hotel_id\n    WHERE h.country = 'UK'\n    GROUP BY user_id\n) sub;", "latency_sec": 0.7543540000915527, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 252, "prompt_eval_sec": null, "tokens_completion": 65, "completion_eval_sec": null, "tokens_total": 317, "tokens_per_sec": 420.22710817670094, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references a 'country' column in the virtual_tour_data table, which does not exist. The Generated SQL correctly joins with the hotels table to filter by country. Additionally, the Reference SQL uses COUNT(DISTINCT hotel_id) while the Generated SQL uses COUNT(*), leading to different results if users visited the same hotel multiple times. The Reference SQL is also syntactically invalid.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query is technically incorrect because it references a 'country' column that doesn't exist in the virtual_tour_data table. It incorrectly uses COUNT(DISTINCT hotel_id) which counts unique hotels per user rather than actual tour instances. The generated query correctly joins with the hotels table to filter UK-based tours, uses COUNT(*) to count actual tour entries, and properly calculates the maximum value. While both queries aim to find maximum tours, the generated version accurately addresses the business intent by counting tour instances rather than distinct hotels.", "overall_assessment": "differently_correct"}}
{"example_id": 5812, "sql_complexity": "single join", "prompt": "Calculate the percentage of Shariah-compliant investments held by each investor in the top 5 countries with the highest percentage?", "context": "CREATE TABLE investors (investor_id INT, investor_name TEXT, country TEXT); INSERT INTO investors (investor_id, investor_name, country) VALUES (1, 'Al Thani', 'Qatar'), (2, 'Saudi Investment Group', 'Saudi Arabia'), (3, 'Temasek Holdings', 'Singapore'); CREATE TABLE investments (investment_id INT, investor_id INT, investment_type TEXT, investment_value DECIMAL, is_shariah_compliant BOOLEAN); INSERT INTO investments (investment_id, investor_id, investment_type, investment_value, is_shariah_compliant) VALUES (1, 1, 'Real Estate', 15000000, true), (2, 2, 'Stocks', 20000000, false);", "reference_sql": "SELECT investor_name, ROUND((SUM(CASE WHEN is_shariah_compliant THEN investment_value ELSE 0 END) / SUM(investment_value)) * 100, 2) AS percentage FROM investments JOIN investors ON investments.investor_id = investors.investor_id GROUP BY investor_name ORDER BY percentage DESC LIMIT 5;", "generated_sql": "SELECT\n        i.country,\n        inv.investor_id,\n        inv.investor_name,\n        COUNT(*) AS total_investments,\n        SUM(CASE WHEN invs.is_shariah_compliant THEN 1 ELSE 0 END) AS shariah_investments\n    FROM\n        investors i\n        JOIN investments inv ON i.investor_id = inv.investor_id\n        JOIN investments invs ON inv.investor_id = invs.investor_id\n    GROUP BY\n        i.country,\n        inv.investor_id,\n        inv.investor_name\n),\ncountry_shariah_percentage AS (\n    SELECT\n        country,\n        investor_id,\n        investor_name,\n        (shariah_investments * 100.0) / total_investments AS shariah_percentage\n    FROM\n        country_shariah_stats\n),\ncountry_top_investors AS (\n    SELECT\n        country,\n        investor_id,\n        investor_name,\n        shariah_percentage,\n        ROW_NUMBER() OVER (PARTITION BY country ORDER BY shariah_percentage DESC) AS rn\n    FROM\n        country_shariah_percentage\n)\nSELECT\n    country,\n    investor_name,\n    shariah_percentage\nFROM\n    country_top_investors\nWHERE\n    rn = 1\nORDER BY\n    shariah_percentage DESC\nLIMIT 5;", "raw_model_output": "WITH country_shariah_stats AS (\n    SELECT\n        i.country,\n        inv.investor_id,\n        inv.investor_name,\n        COUNT(*) AS total_investments,\n        SUM(CASE WHEN invs.is_shariah_compliant THEN 1 ELSE 0 END) AS shariah_investments\n    FROM\n        investors i\n        JOIN investments inv ON i.investor_id = inv.investor_id\n        JOIN investments invs ON inv.investor_id = invs.investor_id\n    GROUP BY\n        i.country,\n        inv.investor_id,\n        inv.investor_name\n),\ncountry_shariah_percentage AS (\n    SELECT\n        country,\n        investor_id,\n        investor_name,\n        (shariah_investments * 100.0) / total_investments AS shariah_percentage\n    FROM\n        country_shariah_stats\n),\ncountry_top_investors AS (\n    SELECT\n        country,\n        investor_id,\n        investor_name,\n        shariah_percentage,\n        ROW_NUMBER() OVER (PARTITION BY country ORDER BY shariah_percentage DESC) AS rn\n    FROM\n        country_shariah_percentage\n)\nSELECT\n    country,\n    investor_name,\n    shariah_percentage\nFROM\n    country_top_investors\nWHERE\n    rn = 1\nORDER BY\n    shariah_percentage DESC\nLIMIT 5;", "latency_sec": 2.811432123184204, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 244, "prompt_eval_sec": null, "tokens_completion": 296, "completion_eval_sec": null, "tokens_total": 540, "tokens_per_sec": 192.072928080654, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates the percentage of investment value (not count) that is shariah-compliant per investor, while the generated query calculates the percentage of shariah-compliant investments (count-based) per investor within their country. The generated query also introduces unnecessary complexity with multiple joins, CTEs, and country-based grouping, which changes the semantics entirely.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL calculates Shariah compliance percentages per investor but groups by investor_name instead of country, failing to address the country-level analysis required. It also lacks logic to identify top countries. The Generated SQL attempts country-level analysis with CTEs but incorrectly groups by investor within countries and ranks investors rather than countries. While both queries miss the core requirement of identifying top countries first, the Generated SQL's structure better aligns with country-based analysis, even though it doesn't fully solve the problem. Neither query correctly addresses the original question's multi-step requirement (country ranking \u2192 investor analysis).", "overall_assessment": "differently_correct"}}
{"example_id": 4706, "sql_complexity": "multiple_joins", "prompt": "Who are the top 3 customers by total spend on makeup products from Italy and Spain?", "context": "CREATE TABLE customers (customer_id INT, customer_name TEXT, country TEXT); INSERT INTO customers (customer_id, customer_name, country) VALUES (1, 'Alessandro Martini', 'IT'), (2, 'Laura Rossi', 'ES'), (3, 'Daniela Gonzalez', 'MX'), (4, 'Jose Hernandez', 'ES'), (5, 'Sophia Rodriguez', 'IT'); CREATE TABLE sales (sale_id INT, customer_id INT, product_id INT, sale_quantity INT, sale_country TEXT); INSERT INTO sales (sale_id, customer_id, product_id, sale_quantity, sale_country) VALUES (1, 1, 1, 100, 'IT'), (2, 2, 2, 150, 'ES'), (3, 3, 3, 200, 'MX'), (4, 4, 4, 250, 'ES'), (5, 5, 5, 300, 'IT'); CREATE TABLE products (product_id INT, product_name TEXT, category TEXT); INSERT INTO products (product_id, product_name, category) VALUES (1, 'Eyeshadow Palette', 'makeup'), (2, 'Liquid Lipstick', 'makeup'), (3, 'BB Cream', 'makeup'), (4, 'Volumizing Mascara', 'makeup'), (5, 'Nourishing Lip Balm', 'makeup');", "reference_sql": "SELECT c.customer_name, SUM(s.sale_quantity) as total_spent_on_makeup FROM sales s JOIN customers c ON s.customer_id = c.customer_id JOIN products p ON s.product_id = p.product_id WHERE c.country IN ('IT', 'ES') AND p.category = 'makeup' GROUP BY c.customer_name ORDER BY total_spent_on_makeup DESC LIMIT 3;", "generated_sql": "SELECT c.customer_id, c.customer_name, SUM(s.sale_quantity) AS total_spend\nFROM customers c\nJOIN sales s ON c.customer_id = s.customer_id\nJOIN products p ON s.product_id = p.product_id\nWHERE p.category = 'makeup' AND s.sale_country IN ('IT', 'ES')\nGROUP BY c.customer_id, c.customer_name\nORDER BY total_spend DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT c.customer_id, c.customer_name, SUM(s.sale_quantity) AS total_spend\nFROM customers c\nJOIN sales s ON c.customer_id = s.customer_id\nJOIN products p ON s.product_id = p.product_id\nWHERE p.category = 'makeup' AND s.sale_country IN ('IT', 'ES')\nGROUP BY c.customer_id, c.customer_name\nORDER BY total_spend DESC\nLIMIT 3;\n```", "latency_sec": 1.2248649597167969, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 377, "prompt_eval_sec": null, "tokens_completion": 92, "completion_eval_sec": null, "tokens_total": 469, "tokens_per_sec": 382.89935252000214, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in several key aspects. 1) The SELECT clause: the Reference query selects only customer_name, while the Generated query includes customer_id. 2) The WHERE clause: the Reference filters on customers.country, while the Generated filters on sales.sale_country. 3) The GROUP BY clause: the Reference groups by customer_name, while the Generated groups by customer_id and customer_name. These differences will lead to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries differ in critical aspects. The reference query correctly filters customers by their country (c.country IN ('IT', 'ES')) while the generated query incorrectly filters by sale_country (s.sale_country IN ('IT', 'ES')). This means the generated query would include customers whose sales occurred in IT/ES regardless of their actual country, potentially violating the business requirement. Both queries correctly join all necessary tables and calculate total spend, but the reference query's WHERE clause aligns with the original question's requirement to filter customers from Italy and Spain. The generated query's grouping by customer_id and name is more robust than the reference's grouping by name alone, but this doesn't compensate for the fundamental filtering error.", "overall_assessment": "differently_correct"}}
{"example_id": 1515, "sql_complexity": "multiple_joins", "prompt": "What is the average age of clients who lost cases in the 'personal injury' category?", "context": "CREATE TABLE Cases (CaseID int, ClientID int, Category varchar(50)); INSERT INTO Cases (CaseID, ClientID, Category) VALUES (701, 7, 'Personal Injury'); CREATE TABLE Clients (ClientID int, Age int, Gender varchar(10)); INSERT INTO Clients (ClientID, Age, Gender) VALUES (7, 45, 'Male'); CREATE TABLE CaseOutcomes (CaseID int, Outcome varchar(50)); INSERT INTO CaseOutcomes (CaseID, Outcome) VALUES (701, 'Lost');", "reference_sql": "SELECT AVG(C.Age) as AvgAge FROM Clients C INNER JOIN Cases CA ON C.ClientID = CA.ClientID INNER JOIN CaseOutcomes CO ON CA.CaseID = CO.CaseID WHERE CA.Category = 'Personal Injury' AND CO.Outcome = 'Lost';", "generated_sql": "SELECT AVG(c.Age) AS AverageAge\nFROM Clients c\nJOIN Cases ca ON c.ClientID = ca.ClientID\nJOIN CaseOutcomes co ON ca.CaseID = co.CaseID\nWHERE ca.Category = 'Personal Injury' AND co.Outcome = 'Lost';", "raw_model_output": "SELECT AVG(c.Age) AS AverageAge\nFROM Clients c\nJOIN Cases ca ON c.ClientID = ca.ClientID\nJOIN CaseOutcomes co ON ca.CaseID = co.CaseID\nWHERE ca.Category = 'Personal Injury' AND co.Outcome = 'Lost';", "latency_sec": 0.8846511840820312, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 195, "prompt_eval_sec": null, "tokens_completion": 59, "completion_eval_sec": null, "tokens_total": 254, "tokens_per_sec": 287.11881538209445, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. Both perform the same operations: joining Clients, Cases, and CaseOutcomes tables with identical conditions, filtering on 'Personal Injury' category and 'Lost' outcome, and calculating the average age. The only difference is case variation in table aliases (C/CA/CO vs c/ca/co), which does not affect SQL semantics.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are syntactically and semantically identical, with only minor formatting differences (alias naming conventions). They correctly join the three required tables (Clients, Cases, CaseOutcomes) on the appropriate keys, filter for 'Personal Injury' category and 'Lost' outcomes, and calculate the average client age. The business intent is fully addressed by focusing on clients who lost cases in the specified category. Neither query demonstrates superior efficiency or elegance over the other as they are functionally identical.", "overall_assessment": "correct"}}
{"example_id": 4388, "sql_complexity": "subqueries", "prompt": "Insert a new drug with a price 10% higher than the average price", "context": "CREATE TABLE drugs (drug_id INT, drug_name VARCHAR(50), price DECIMAL(10, 2)); INSERT INTO drugs (drug_id, drug_name, price) VALUES (1, 'DrugA', 50), (2, 'DrugB', 75), (3, 'DrugC', 100)", "reference_sql": "INSERT INTO drugs (drug_id, drug_name, price) VALUES ((SELECT MAX(drug_id) FROM drugs) + 1, 'DrugD', (SELECT AVG(price) * 1.1 FROM drugs))", "generated_sql": "INSERT INTO drugs (drug_id, drug_name, price)\nVALUES (\n    (SELECT MAX(drug_id) + 1 FROM drugs),\n    'NewDrug',\n    (SELECT AVG(price) * 1.10 FROM drugs)\n);", "raw_model_output": "INSERT INTO drugs (drug_id, drug_name, price)\nVALUES (\n    (SELECT MAX(drug_id) + 1 FROM drugs),\n    'NewDrug',\n    (SELECT AVG(price) * 1.10 FROM drugs)\n);", "latency_sec": 0.7009658813476562, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 149, "prompt_eval_sec": null, "tokens_completion": 49, "completion_eval_sec": null, "tokens_total": 198, "tokens_per_sec": 282.4673857439838, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the drug_name value ('DrugD' vs 'NewDrug'), which results in different data being inserted. While the drug_id calculation (MAX(drug_id) + 1) and price calculation (AVG(price) * 1.1/1.10) are equivalent, the distinct drug names make the overall results different.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the average price, apply a 10% increase, and generate a new drug_id by incrementing the maximum existing drug_id. The only differences are the drug names ('DrugD' vs 'NewDrug') and the decimal representation (1.1 vs 1.10), which are functionally equivalent. Both queries fulfill the business intent of inserting a drug with a price 10% above the average. The generated SQL uses a more descriptive drug name ('NewDrug'), but the original question did not specify naming requirements. Neither query is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 5431, "sql_complexity": "basic SQL", "prompt": "What is the average CO2 emission of ride-hailing vehicles in San Francisco?", "context": "CREATE TABLE SFRideHailing (id INT, company VARCHAR(20), co2_emission DECIMAL(5,2));", "reference_sql": "SELECT AVG(co2_emission) FROM SFRideHailing WHERE company = 'Uber';", "generated_sql": "SELECT AVG(co2_emission) AS average_co2_emission\nFROM SFRideHailing;", "raw_model_output": "SELECT AVG(co2_emission) AS average_co2_emission\nFROM SFRideHailing;", "latency_sec": 0.4388749599456787, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 110, "prompt_eval_sec": null, "tokens_completion": 22, "completion_eval_sec": null, "tokens_total": 132, "tokens_per_sec": 300.76903912754136, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the average co2_emission specifically for 'Uber' rides, while the Generated SQL calculates the average for all companies in the table. The WHERE clause in the Reference SQL restricts the data, making the results different unless all entries are from Uber.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query is technically incorrect for the original question because it explicitly filters for 'Uber' vehicles, while the original question asks about all ride-hailing vehicles in San Francisco (not limited to Uber). The generated query correctly calculates the average CO2 emission for all entries in the SFRideHailing table, which aligns with the context that the table contains ride-hailing data specific to San Francisco. Although neither query explicitly filters by 'ride-hailing' (as the table name implies this), the generated query better fulfills the business intent by avoiding an unwarranted company-specific restriction. The reference query's WHERE clause introduces a bias not present in the original question, making it less accurate for the stated goal.", "overall_assessment": "differently_correct"}}
{"example_id": 3531, "sql_complexity": "single join", "prompt": "What is the total number of workouts and total workout time per user for users with a membership type of 'Basic'?", "context": "CREATE TABLE Members (id INT, user_name VARCHAR, membership_type VARCHAR, signup_date DATE); CREATE TABLE Workouts (id INT, user_id INT, workout_date DATE, workout_duration INT); INSERT INTO Members (id, user_name, membership_type, signup_date) VALUES (1, 'John Doe', 'Premium', '2020-01-01'), (2, 'Jane Smith', 'Basic', '2019-06-15'), (3, 'Alice Johnson', 'Premium', '2020-03-20'); INSERT INTO Workouts (id, user_id, workout_date, workout_duration) VALUES (1, 1, '2020-01-01', 60), (2, 1, '2020-01-02', 70), (3, 2, '2019-06-15', 90), (4, 3, '2020-03-20', 65), (5, 3, '2020-03-21', 70);", "reference_sql": "SELECT Members.user_name, SUM(Workouts.workout_duration) AS total_workout_time, COUNT(Workouts.id) AS total_workouts FROM Members JOIN Workouts ON Members.id = Workouts.user_id WHERE Members.membership_type = 'Basic' GROUP BY Members.user_name;", "generated_sql": "SELECT \n    m.user_name,\n    COUNT(w.id) AS total_workouts,\n    SUM(w.workout_duration) AS total_workout_time\nFROM \n    Members m\nLEFT JOIN \n    Workouts w ON m.id = w.user_id\nWHERE \n    m.membership_type = 'Basic'\nGROUP BY \n    m.id, m.user_name;", "raw_model_output": "SELECT \n    m.user_name,\n    COUNT(w.id) AS total_workouts,\n    SUM(w.workout_duration) AS total_workout_time\nFROM \n    Members m\nLEFT JOIN \n    Workouts w ON m.id = w.user_id\nWHERE \n    m.membership_type = 'Basic'\nGROUP BY \n    m.id, m.user_name;", "latency_sec": 0.8318901062011719, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 302, "prompt_eval_sec": null, "tokens_completion": 74, "completion_eval_sec": null, "tokens_total": 376, "tokens_per_sec": 451.9827765676946, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Reference SQL uses an INNER JOIN while the Generated SQL uses a LEFT JOIN. This means the Generated SQL includes 'Basic' members with no workouts (resulting in 0 counts), whereas the Reference SQL excludes them. Second, the GROUP BY clause in the Reference SQL uses only user_name (which could aggregate multiple members with the same name) while the Generated SQL groups by both id and user_name (ensuring unique grouping). These differences in join type and grouping logic make the queries non-equivalent in general cases.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The Reference SQL uses an INNER JOIN which excludes Basic members with no workouts, while the Generated SQL uses a LEFT JOIN which includes them (showing 0 workouts and 0 time). The Generated SQL also groups by both id and user_name (ensuring uniqueness via primary key) whereas the Reference only groups by user_name (risking aggregation issues if user_names are not unique). Both calculate correct aggregates, but the Generated query better handles edge cases (e.g., members with no workouts) and uses safer grouping logic. The business intent is fulfilled by both, but the Generated query is more robust.", "overall_assessment": "differently_correct"}}
{"example_id": 5678, "sql_complexity": "set operations", "prompt": "How many public works projects are there in 'Sydney' and 'Melbourne' combined?", "context": "CREATE TABLE PublicWorksC(id INT, city VARCHAR(20), project VARCHAR(30)); INSERT INTO PublicWorksC(id, city, project) VALUES (1, 'Sydney', 'Park Renovation'), (2, 'Melbourne', 'Sidewalk Repair');", "reference_sql": "SELECT COUNT(*) FROM (SELECT city FROM PublicWorksC WHERE city = 'Sydney' UNION ALL SELECT city FROM PublicWorksC WHERE city = 'Melbourne') AS Total;", "generated_sql": "SELECT COUNT(*) AS total_projects\nFROM PublicWorksC\nWHERE city IN ('Sydney', 'Melbourne');", "raw_model_output": "SELECT COUNT(*) AS total_projects\nFROM PublicWorksC\nWHERE city IN ('Sydney', 'Melbourne');", "latency_sec": 0.8428609371185303, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 138, "prompt_eval_sec": null, "tokens_completion": 23, "completion_eval_sec": null, "tokens_total": 161, "tokens_per_sec": 191.0160892618978, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of rows where the city is either 'Sydney' or 'Melbourne'. The Reference SQL uses a UNION ALL to combine results from both cities and then counts them, while the Generated SQL directly filters with WHERE city IN. Since UNION ALL preserves all rows (and there are no duplicates in the sample data), the final count remains the same.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count projects in Sydney and Melbourne. The reference query uses a UNION ALL subquery to combine results from two separate city filters, while the generated query uses a single WHERE clause with IN. Technically, they produce identical results because both count all rows matching either city. However, the generated query is more efficient (single table scan vs two separate scans) and elegant (simpler syntax). Both fulfill the business intent of combining project counts for the two cities.", "overall_assessment": "correct"}}
{"example_id": 5792, "sql_complexity": "multiple_joins", "prompt": "How many cases were handled by attorneys in the 'Los Angeles' office?", "context": "CREATE TABLE offices (office_id INT, office_name VARCHAR(20), city VARCHAR(20), state VARCHAR(20)); INSERT INTO offices (office_id, office_name, city, state) VALUES (1, 'Boston', 'Boston', 'MA'), (2, 'New York', 'New York', 'NY'), (3, 'Los Angeles', 'Los Angeles', 'CA'); CREATE TABLE attorneys (attorney_id INT, office_id INT); INSERT INTO attorneys (attorney_id, office_id) VALUES (1, 1), (2, 2), (3, 3); CREATE TABLE cases (case_id INT, attorney_id INT); INSERT INTO cases (case_id, attorney_id) VALUES (1, 1), (2, 2), (3, 3);", "reference_sql": "SELECT COUNT(*) FROM cases JOIN attorneys ON cases.attorney_id = attorneys.attorney_id JOIN offices ON attorneys.office_id = offices.office_id WHERE offices.city = 'Los Angeles';", "generated_sql": "SELECT COUNT(*) AS case_count\nFROM cases\nJOIN attorneys ON cases.attorney_id = attorneys.attorney_id\nJOIN offices ON attorneys.office_id = offices.office_id\nWHERE offices.city = 'Los Angeles';", "raw_model_output": "SELECT COUNT(*) AS case_count\nFROM cases\nJOIN attorneys ON cases.attorney_id = attorneys.attorney_id\nJOIN offices ON attorneys.office_id = offices.office_id\nWHERE offices.city = 'Los Angeles';", "latency_sec": 1.0229849815368652, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 245, "prompt_eval_sec": null, "tokens_completion": 43, "completion_eval_sec": null, "tokens_total": 288, "tokens_per_sec": 281.52905975934056, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries perform the same three-table join (cases \u2192 attorneys \u2192 offices) with identical join conditions and WHERE clause filtering for 'Los Angeles' city. The only difference is the alias 'case_count' in the Generated SQL, which does not affect the semantic result since COUNT(*) is equivalent to COUNT(*) with an alias. The output value would be identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are structurally identical except for the alias 'case_count' in the generated version. The reference query uses COUNT(*) directly while the generated query adds an alias, but this does not affect the result set. Both correctly join the three tables (cases \u2192 attorneys \u2192 offices) with appropriate keys, filter for 'Los Angeles' office, and count the cases. The business intent is fully addressed by both as they accurately measure cases handled by attorneys located in the specified office.", "overall_assessment": "correct"}}
{"example_id": 5148, "sql_complexity": "window functions", "prompt": "List the unique types of smart city technologies that have been implemented in the top 3 most populous countries in the world.", "context": "CREATE TABLE smart_city_tech (tech_type VARCHAR(255), country VARCHAR(255)); CREATE TABLE country_populations (country VARCHAR(255), population INT);", "reference_sql": "SELECT DISTINCT tech_type FROM smart_city_tech SCT WHERE country IN (SELECT country FROM (SELECT country, ROW_NUMBER() OVER (ORDER BY population DESC) as rank FROM country_populations) CP WHERE rank <= 3);", "generated_sql": "SELECT DISTINCT sct.tech_type\nFROM smart_city_tech sct\nJOIN country_populations cp ON sct.country = cp.country\nORDER BY cp.population DESC\nLIMIT 3;", "raw_model_output": "SELECT DISTINCT sct.tech_type\nFROM smart_city_tech sct\nJOIN country_populations cp ON sct.country = cp.country\nORDER BY cp.population DESC\nLIMIT 3;", "latency_sec": 0.654644250869751, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 123, "prompt_eval_sec": null, "tokens_completion": 39, "completion_eval_sec": null, "tokens_total": 162, "tokens_per_sec": 247.46264827770062, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL selects distinct tech_types from the top 3 countries by population (using ROW_NUMBER()), ensuring all tech_types from those 3 countries are included. The Generated SQL joins the tables, orders by population descending, and limits to 3 rows. However, this may return 3 rows (possibly from the same country) rather than 3 distinct countries, leading to different results. Additionally, the Generated SQL's LIMIT 3 could miss some tech_types from top countries if multiple entries exist per country.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly identifies the top 3 most populous countries using ROW_NUMBER() and then retrieves distinct tech types from those countries. The Generated SQL incorrectly assumes that LIMIT 3 after joining and ordering by population will return exactly 3 distinct countries, which is not guaranteed. A country with multiple entries in smart_city_tech could dominate the LIMIT 3 results, leading to fewer than 3 unique countries. The Reference ensures precise country selection first, then tech types, while the Generated query risks incomplete or incorrect country selection.", "overall_assessment": "differently_correct"}}
{"example_id": 5547, "sql_complexity": "multiple_joins", "prompt": "Which species have a population growth rate higher than the average for protected areas?", "context": "CREATE TABLE species (id INT, name VARCHAR(50), population DECIMAL(5,2), protected_area_id INT, growth_rate DECIMAL(5,2)); INSERT INTO species (id, name, population, protected_area_id, growth_rate) VALUES (1, 'Species 1', 500.00, 1, 0.05), (2, 'Species 2', 800.00, 1, 0.03), (3, 'Species 3', 1200.00, 2, 0.07), (4, 'Species 4', 700.00, 2, 0.02); CREATE TABLE protected_areas (id INT, name VARCHAR(50)); INSERT INTO protected_areas (id, name) VALUES (1, 'Area 1'), (2, 'Area 2');", "reference_sql": "SELECT s.name, s.growth_rate FROM species s INNER JOIN protected_areas pa ON s.protected_area_id = pa.id GROUP BY s.name, s.growth_rate HAVING s.growth_rate > (SELECT AVG(s.growth_rate) FROM species s INNER JOIN protected_areas pa ON s.protected_area_id = pa.id);", "generated_sql": "SELECT s.*\nFROM species s\nWHERE s.growth_rate > (\n    SELECT AVG(s2.growth_rate)\n    FROM species s2\n);", "raw_model_output": "SELECT s.*\nFROM species s\nWHERE s.growth_rate > (\n    SELECT AVG(s2.growth_rate)\n    FROM species s2\n);\n", "latency_sec": 0.7385237216949463, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 260, "prompt_eval_sec": null, "tokens_completion": 31, "completion_eval_sec": null, "tokens_total": 291, "tokens_per_sec": 394.0293201850598, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL selects species.name and species.growth_rate after joining with protected_areas, groups by those columns, and filters using a subquery that calculates the average growth_rate from the joined tables. The Generated SQL selects all columns from species and uses a subquery that calculates the average growth_rate from the species table alone (without joining protected_areas). Additionally, the Reference SQL's HAVING clause filters groups, while the Generated SQL filters individual rows. The output columns and filtering logic differ significantly.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries calculate species with growth rates above the overall average growth rate of all species. The Reference SQL includes unnecessary JOIN and GROUP BY operations that don't affect the result, while the Generated SQL directly compares growth rates to the global average. The business intent is fulfilled since the question's phrasing ('average for protected areas') likely refers to the overall average of species in protected areas (as all species in the dataset are in protected areas). The Generated SQL is more efficient and elegant.", "overall_assessment": "correct"}}
{"example_id": 5498, "sql_complexity": "aggregation", "prompt": "Identify the destinations with the highest number of repeat visitors from the US.", "context": "CREATE TABLE RepeatTravelers (Visitor VARCHAR(20), Destination VARCHAR(20), VisitCount INT); INSERT INTO RepeatTravelers (Visitor, Destination, VisitCount) VALUES ('David', 'Paris', 3), ('Ella', 'London', 4), ('Fiona', 'Paris', 2);", "reference_sql": "SELECT Destination, AVG(VisitCount) AS AvgVisitCount FROM RepeatTravelers WHERE Visitor LIKE '%USA%' GROUP BY Destination ORDER BY AvgVisitCount DESC;", "generated_sql": "SELECT Destination\nFROM RepeatTravelers\nWHERE Visitor IN ('David', 'Ella', 'Fiona') -- assuming these are US visitors based on context\nGROUP BY Destination\nORDER BY COUNT(*) DESC\nLIMIT 1;", "raw_model_output": "SELECT Destination\nFROM RepeatTravelers\nWHERE Visitor IN ('David', 'Ella', 'Fiona') -- assuming these are US visitors based on context\nGROUP BY Destination\nORDER BY COUNT(*) DESC\nLIMIT 1;", "latency_sec": 0.9041540622711182, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 143, "prompt_eval_sec": null, "tokens_completion": 46, "completion_eval_sec": null, "tokens_total": 189, "tokens_per_sec": 209.03517208699634, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates the average VisitCount for destinations where the visitor contains 'USA' (which returns no rows in the sample data). The generated query counts visitor occurrences per destination (returning 'Paris' as the most frequent). They differ in both filtering logic and aggregation metrics.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "equal", "explanation": "The queries are not technically equivalent. The Reference SQL attempts to calculate average VisitCount for visitors with 'USA' in their name (which doesn't match the sample data), while the Generated SQL counts the number of US visitors per destination (assuming hardcoded names). Neither query correctly addresses the business intent: the original question asks for destinations with the highest number of repeat visitors (VisitCount > 1) from the US. The Reference SQL misuses AVG(VisitCount) instead of COUNT(Visitor) or SUM(VisitCount), and the Generated SQL ignores VisitCount entirely while making unsupported assumptions about visitor identities. Both queries fail to properly filter for US visitors or account for repeat visit criteria.", "overall_assessment": "differently_correct"}}
{"example_id": 3546, "sql_complexity": "window functions", "prompt": "What are the cryptocurrency exchanges with their corresponding blockchain companies, ranked by exchange ID in ascending order, for the Bitcoin platform?", "context": "CREATE TABLE cryptocurrency_exchanges (exchange_id INT, exchange_name VARCHAR(50), company_id INT); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (1, 'Binance', 1); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (2, 'Coinbase', 2); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (3, 'Kraken', 3); CREATE TABLE blockchain_companies (company_id INT, company_name VARCHAR(50), platform VARCHAR(50)); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (1, 'Binance', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (2, 'Blockstream', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (3, 'Blockchair', 'Bitcoin');", "reference_sql": "SELECT ce.exchange_name, bc.company_name, ce.exchange_id, ROW_NUMBER() OVER (PARTITION BY bc.platform ORDER BY ce.exchange_id ASC) as rank FROM cryptocurrency_exchanges ce JOIN blockchain_companies bc ON ce.company_id = bc.company_id WHERE bc.platform = 'Bitcoin';", "generated_sql": "SELECT ce.exchange_id, ce.exchange_name, bc.company_name\nFROM cryptocurrency_exchanges ce\nJOIN blockchain_companies bc ON ce.company_id = bc.company_id\nWHERE bc.platform = 'Bitcoin'\nORDER BY ce.exchange_id ASC;", "raw_model_output": "SELECT ce.exchange_id, ce.exchange_name, bc.company_name\nFROM cryptocurrency_exchanges ce\nJOIN blockchain_companies bc ON ce.company_id = bc.company_id\nWHERE bc.platform = 'Bitcoin'\nORDER BY ce.exchange_id ASC;", "latency_sec": 0.6940360069274902, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 285, "prompt_eval_sec": null, "tokens_completion": 48, "completion_eval_sec": null, "tokens_total": 333, "tokens_per_sec": 479.80219567309905, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a ROW_NUMBER() column and does not have an ORDER BY clause, while the Generated SQL omits the row number calculation and adds an ORDER BY. The presence of the additional computed 'rank' column in the Reference query makes the result sets structurally different. Additionally, the Generated query's explicit sorting may alter the order of results compared to the Reference, which relies on default ordering.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL includes a ROW_NUMBER() ranking column that wasn't requested in the original question, while the Generated SQL correctly focuses on the required columns (exchange_id, exchange_name, company_name) and explicitly sorts results by exchange_id ASC. The Reference query's window function is unnecessary since the WHERE clause already filters to a single platform (Bitcoin), making the PARTITION BY clause redundant. The Generated SQL is more efficient, semantically aligned with the question's requirements, and avoids introducing extraneous ranking logic that could mislead users into thinking explicit ranking was required.", "overall_assessment": "differently_correct"}}
{"example_id": 486, "sql_complexity": "single join", "prompt": "What is the average price of paintings from African artists in our collection?", "context": "CREATE TABLE Artworks (id INT, title VARCHAR(50), price DECIMAL(10,2), medium VARCHAR(50), artist_nationality VARCHAR(50)); CREATE TABLE Collections (id INT, name VARCHAR(50), continent VARCHAR(50));", "reference_sql": "SELECT AVG(Artworks.price) FROM Artworks INNER JOIN Collections ON Artworks.artist_nationality = Collections.continent WHERE Artworks.medium = 'Painting' AND Collections.continent = 'Africa';", "generated_sql": "SELECT AVG(price) AS average_price\nFROM Artworks\nWHERE medium = 'painting' AND artist_nationality = 'African';", "raw_model_output": "SELECT AVG(price) AS average_price\nFROM Artworks\nWHERE medium = 'painting' AND artist_nationality = 'African';", "latency_sec": 0.7560780048370361, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 132, "prompt_eval_sec": null, "tokens_completion": 28, "completion_eval_sec": null, "tokens_total": 160, "tokens_per_sec": 211.61837664420108, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL joins Artworks with Collections on artist_nationality = continent and filters Collections.continent = 'Africa', effectively requiring Artworks.artist_nationality to be 'Africa'. The Generated SQL directly filters Artworks.artist_nationality = 'African' (a different value) without using the Collections table. The conditions are not equivalent because 'Africa' (continent) and 'African' (nationality) are distinct values, and the Generated SQL omits the join entirely.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ fundamentally in logic. The Reference SQL incorrectly joins Artworks with Collections on artist_nationality = continent (which is a flawed relationship) and filters Collections.continent = 'Africa'\u2014this would only include artworks where the artist's nationality exactly matches a continent name (e.g., 'Africa') and the Collections table's continent field. The Generated SQL directly filters Artworks where artist_nationality = 'African' (assuming this matches the data's structure) and medium = 'painting', which aligns with the question's intent. The Reference SQL's join is unnecessary and likely incorrect, while the Generated SQL is simpler, more direct, and avoids potential data mismatches.", "overall_assessment": "differently_correct"}}
{"example_id": 794, "sql_complexity": "multiple_joins", "prompt": "Which suppliers have provided raw materials for the production of chemicals with high environmental impact?", "context": "CREATE TABLE suppliers (id INT, name TEXT); INSERT INTO suppliers (id, name) VALUES (1, 'Supplier1'), (2, 'Supplier2'), (3, 'Supplier3'); CREATE TABLE chemicals (id INT, name TEXT, environmental_impact INT); INSERT INTO chemicals (id, name, environmental_impact) VALUES (1, 'ChemA', 10), (2, 'ChemB', 20), (3, 'ChemC', 15); CREATE TABLE raw_materials (chemical_id INT, supplier_id INT); INSERT INTO raw_materials (chemical_id, supplier_id) VALUES (1, 1), (1, 2), (2, 3), (3, 1);", "reference_sql": "SELECT s.name FROM suppliers s INNER JOIN raw_materials rm ON s.id = rm.supplier_id INNER JOIN chemicals c ON rm.chemical_id = c.id WHERE c.environmental_impact > 10;", "generated_sql": "SELECT DISTINCT s.id, s.name\nFROM suppliers s\nJOIN raw_materials rm ON s.id = rm.supplier_id\nJOIN chemicals c ON rm.chemical_id = c.id\nWHERE c.environmental_impact > (SELECT AVG(environmental_impact) FROM chemicals);", "raw_model_output": "SELECT DISTINCT s.id, s.name\nFROM suppliers s\nJOIN raw_materials rm ON s.id = rm.supplier_id\nJOIN chemicals c ON rm.chemical_id = c.id\nWHERE c.environmental_impact > (SELECT AVG(environmental_impact) FROM chemicals);", "latency_sec": 0.9801318645477295, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 232, "prompt_eval_sec": null, "tokens_completion": 57, "completion_eval_sec": null, "tokens_total": 289, "tokens_per_sec": 294.858284332339, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters chemicals with environmental_impact > 10, while the Generated SQL uses a subquery to filter chemicals with environmental_impact > (average of all environmental_impact values). The average of 10, 20, and 15 is 15, so the Generated SQL effectively filters for environmental_impact > 15. This changes the result set: the Reference includes chemicals with values 15 and 20, while the Generated only includes 20. Additionally, the Generated SQL includes DISTINCT, which could affect results if duplicates exist, though the Reference might have duplicates due to multiple chemical links.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The Reference SQL directly addresses the question by filtering chemicals with environmental_impact > 10, which aligns with the explicit phrasing of 'high environmental impact' (assuming 10 is a reasonable threshold). The Generated SQL uses a dynamic threshold (average environmental impact), which changes the criteria for 'high' and would return different results. While both queries are technically correct, they are not semantically equivalent. The Reference SQL better fulfills the business intent by using a fixed threshold that matches the question's wording, whereas the Generated SQL introduces an alternative definition of 'high' that may not align with the user's expectations.", "overall_assessment": "correct"}}
{"example_id": 3164, "sql_complexity": "set operations", "prompt": "What is the average age of patients who received therapy in 'clinic_a' and 'clinic_b'?", "context": "CREATE TABLE clinic_a (patient_id INT, age INT, therapy_received BOOLEAN); INSERT INTO clinic_a (patient_id, age, therapy_received) VALUES (1, 35, true), (2, 42, true), (3, 28, false); CREATE TABLE clinic_b (patient_id INT, age INT, therapy_received BOOLEAN); INSERT INTO clinic_b (patient_id, age, therapy_received) VALUES (4, 50, true), (5, 32, false), (6, 45, true);", "reference_sql": "SELECT AVG(age) FROM (SELECT age FROM clinic_a WHERE therapy_received = true UNION ALL SELECT age FROM clinic_b WHERE therapy_received = true) AS combined_clinics;", "generated_sql": "SELECT AVG(age) AS average_age\nFROM (\n    SELECT age FROM clinic_a WHERE therapy_received = TRUE\n    UNION ALL\n    SELECT age FROM clinic_b WHERE therapy_received = TRUE\n) AS combined_patients;", "raw_model_output": "SELECT AVG(age) AS average_age\nFROM (\n    SELECT age FROM clinic_a WHERE therapy_received = TRUE\n    UNION ALL\n    SELECT age FROM clinic_b WHERE therapy_received = TRUE\n) AS combined_patients;", "latency_sec": 0.6083178520202637, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 196, "prompt_eval_sec": null, "tokens_completion": 45, "completion_eval_sec": null, "tokens_total": 241, "tokens_per_sec": 396.174465700165, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average age of patients who received therapy from both clinics. The only difference is the alias name ('combined_clinics' vs 'combined_patients'), which does not affect the result since the outer query does not reference the alias. The subquery structure, filtering conditions, and aggregation logic are identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the average age of patients who received therapy in clinic_a and clinic_b. They use identical logic: filtering therapy_received=true in both tables, combining results with UNION ALL, and computing AVG(age). The only difference is the alias name ('combined_clinics' vs 'combined_patients') which has no impact on results. Both queries are efficient, semantically equivalent, and fully address the business question.", "overall_assessment": "correct"}}
{"example_id": 3704, "sql_complexity": "aggregation", "prompt": "What is the total sales revenue for each category of garments in the South America region in Q1 2022?", "context": "CREATE TABLE sales_category (sale_id INT, garment_category VARCHAR(50), sale_date DATE, total_sales DECIMAL(10, 2), region VARCHAR(50));", "reference_sql": "SELECT garment_category, SUM(total_sales) FROM sales_category WHERE sale_date BETWEEN '2022-01-01' AND '2022-03-31' AND region = 'South America' GROUP BY garment_category;", "generated_sql": "SELECT \n    garment_category,\n    SUM(total_sales) AS total_revenue\nFROM \n    sales_category\nWHERE \n    region = 'South America'\n    AND sale_date >= '2022-01-01'\n    AND sale_date < '2022-04-01'\nGROUP BY \n    garment_category;", "raw_model_output": "SELECT \n    garment_category,\n    SUM(total_sales) AS total_revenue\nFROM \n    sales_category\nWHERE \n    region = 'South America'\n    AND sale_date >= '2022-01-01'\n    AND sale_date < '2022-04-01'\nGROUP BY \n    garment_category;", "latency_sec": 0.7712101936340332, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 124, "prompt_eval_sec": null, "tokens_completion": 65, "completion_eval_sec": null, "tokens_total": 189, "tokens_per_sec": 245.0693748087143, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries aggregate total_sales by garment_category for 'South America' region. The date filters are equivalent: 'BETWEEN '2022-01-01' AND '2022-03-31'' (inclusive) matches the same dates as 'sale_date >= '2022-01-01' AND sale_date < '2022-04-01'' (exclusive upper bound). The column alias difference (total_revenue vs. implicit name) doesn't affect result content.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate total sales revenue per garment category in South America for Q1 2022. The Reference SQL uses BETWEEN '2022-01-01' AND '2022-03-31' while the Generated SQL uses a range from '2022-01-01' to '2022-04-01' (exclusive). Since sale_date is a DATE type, both effectively capture the same 3-month period. The Generated SQL improves on precision by avoiding potential edge cases with BETWEEN and adds an explicit alias for clarity. Both satisfy the business intent, but the Generated SQL demonstrates better date range handling and readability.", "overall_assessment": "correct"}}
{"example_id": 2851, "sql_complexity": "single join", "prompt": "How many cases were handled by attorneys who joined the firm in 2015 or later?", "context": "CREATE TABLE attorneys (attorney_id INT, join_year INT); CREATE TABLE cases (case_id INT, attorney_id INT, billing_amount INT);", "reference_sql": "SELECT COUNT(DISTINCT cases.case_id) FROM cases INNER JOIN attorneys ON cases.attorney_id = attorneys.attorney_id WHERE attorneys.join_year >= 2015;", "generated_sql": "SELECT COUNT(*) AS case_count\nFROM cases\nJOIN attorneys ON cases.attorney_id = attorneys.attorney_id\nWHERE attorneys.join_year >= 2015;", "raw_model_output": "SELECT COUNT(*) AS case_count\nFROM cases\nJOIN attorneys ON cases.attorney_id = attorneys.attorney_id\nWHERE attorneys.join_year >= 2015;", "latency_sec": 0.5338189601898193, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 114, "prompt_eval_sec": null, "tokens_completion": 33, "completion_eval_sec": null, "tokens_total": 147, "tokens_per_sec": 275.3742578714863, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses COUNT(DISTINCT cases.case_id) to count unique case IDs, while the Generated SQL uses COUNT(*) to count all rows. If there are multiple entries for the same case_id in the cases table, the two queries would produce different results. The DISTINCT keyword ensures uniqueness in the Reference SQL, whereas the Generated SQL counts all joined rows without deduplication.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries differ in their aggregation method: the reference uses COUNT(DISTINCT cases.case_id) while the generated query uses COUNT(*). Technically, they are not equivalent because COUNT(*) would overcount cases if multiple attorney-case relationships exist for the same case (though the schema implies a one-to-many attorney-case relationship). The reference query ensures each case is counted once, aligning with the business intent of counting unique cases handled by qualifying attorneys. The generated query is simpler but less precise in edge cases. Both fulfill the intent, but the reference is more robust.", "overall_assessment": "differently_correct"}}
{"example_id": 3246, "sql_complexity": "single join", "prompt": "What is the average eco-friendliness score of accommodations in Oceania by year?", "context": "CREATE TABLE Accommodations (Accommodation_ID INT, Accommodation_Name VARCHAR(50), City VARCHAR(30), Country VARCHAR(50), Eco_Friendliness_Score INT, Visit_Year INT); INSERT INTO Accommodations (Accommodation_ID, Accommodation_Name, City, Country, Eco_Friendliness_Score, Visit_Year) VALUES (1, 'EcoLodge', 'Sydney', 'Australia', 85, 2019), (2, 'GreenHotel', 'Melbourne', 'Australia', 90, 2019), (3, 'SustainableResort', 'Auckland', 'New Zealand', 80, 2019), (4, 'EcoVilla', 'Wellington', 'New Zealand', 88, 2019); CREATE TABLE Countries (Country VARCHAR(50), Continent VARCHAR(30)); INSERT INTO Countries (Country, Continent) VALUES ('Australia', 'Oceania'), ('New Zealand', 'Oceania');", "reference_sql": "SELECT C.Continent, V.Visit_Year, AVG(A.Eco_Friendliness_Score) AS Avg_Eco_Score  FROM Accommodations A  JOIN Countries C  ON A.Country = C.Country  WHERE C.Continent = 'Oceania'  GROUP BY C.Continent, V.Visit_Year  ORDER BY V.Visit_Year;", "generated_sql": "SELECT Visit_Year, AVG(Eco_Friendliness_Score) AS Average_Eco_Friendliness_Score\nFROM Accommodations\nJOIN Countries ON Accommodations.Country = Countries.Country\nWHERE Countries.Continent = 'Oceania'\nGROUP BY Visit_Year;", "raw_model_output": "SELECT Visit_Year, AVG(Eco_Friendliness_Score) AS Average_Eco_Friendliness_Score\nFROM Accommodations\nJOIN Countries ON Accommodations.Country = Countries.Country\nWHERE Countries.Continent = 'Oceania'\nGROUP BY Visit_Year;", "latency_sec": 0.8910579681396484, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 281, "prompt_eval_sec": null, "tokens_completion": 58, "completion_eval_sec": null, "tokens_total": 339, "tokens_per_sec": 380.44662875050034, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes 'Continent' in the SELECT and GROUP BY clauses, while the Generated SQL omits it. Although the WHERE clause filters to 'Oceania' (making 'Continent' constant), the result sets differ in structure (extra column in Reference). Additionally, the Generated SQL lacks the ORDER BY clause present in the Reference, though ordering isn't required for semantic equivalence. The core data (Visit_Year and Avg_Eco_Score) would match, but column structure differences make them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because the reference query includes 'Continent' in both SELECT and GROUP BY clauses, while the generated query omits it. However, since the WHERE clause explicitly filters for 'Oceania', the Continent column is redundant in the results. Both queries correctly calculate the average eco-friendliness score by year for Oceania. The generated query is more efficient and elegant by avoiding unnecessary columns, directly addressing the business intent of 'average by year' without extraneous data. The reference query's inclusion of Continent doesn't improve the answer to the specific question asked.", "overall_assessment": "differently_correct"}}
{"example_id": 3056, "sql_complexity": "multiple_joins", "prompt": "Identify all suppliers who provide non-GMO ingredients to restaurants with Michelin stars.", "context": "CREATE TABLE Suppliers (id INT, name VARCHAR(50), isNonGMO BOOLEAN); CREATE TABLE Restaurants (id INT, name VARCHAR(50), numStars INT); CREATE TABLE Ingredients (supplierId INT, restaurantId INT, isNonGMO BOOLEAN);", "reference_sql": "SELECT Suppliers.name FROM Suppliers INNER JOIN Ingredients ON Suppliers.id = Ingredients.supplierId INNER JOIN Restaurants ON Ingredients.restaurantId = Restaurants.id WHERE Restaurants.numStars > 2 AND Ingredients.isNonGMO = TRUE;", "generated_sql": "SELECT DISTINCT s.*\nFROM Suppliers s\nJOIN Ingredients i ON s.id = i.supplierId\nJOIN Restaurants r ON i.restaurantId = r.id\nWHERE s.isNonGMO = TRUE AND i.isNonGMO = TRUE AND r.numStars >= 3;", "raw_model_output": "SELECT DISTINCT s.*\nFROM Suppliers s\nJOIN Ingredients i ON s.id = i.supplierId\nJOIN Restaurants r ON i.restaurantId = r.id\nWHERE s.isNonGMO = TRUE AND i.isNonGMO = TRUE AND r.numStars >= 3;", "latency_sec": 0.9547388553619385, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 134, "prompt_eval_sec": null, "tokens_completion": 56, "completion_eval_sec": null, "tokens_total": 190, "tokens_per_sec": 199.007298103492, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Reference SQL filters on `Ingredients.isNonGMO = TRUE` while the Generated SQL adds an additional filter `Suppliers.isNonGMO = TRUE`, which is not present in the Reference. Second, the `Restaurants.numStars` condition in the Reference uses `> 2` (equivalent to `>=3` for integers) but the Generated SQL uses `>=3` (which is functionally equivalent). However, the extra `Suppliers.isNonGMO` condition in the Generated SQL makes it more restrictive, leading to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries differ in three key aspects:\n1. **Column Selection**: Reference selects only Supplier.name, while generated selects all columns (s.*). The original question asks for supplier names, making the reference more precise.\n2. **Non-GMO Logic**: Reference correctly checks Ingredients.isNonGMO = TRUE (as the question focuses on ingredients, not supplier-wide status). Generated adds redundant s.isNonGMO = TRUE condition, which misinterprets the business requirement.\n3. **Star Threshold**: Both use equivalent conditions (numStars > 2 vs. >= 3), but reference's logic is slightly more aligned with Michelin's 3-star scale (though this is minor).\n\nThe generated query's extra condition on Suppliers.isNonGMO incorrectly requires suppliers to be non-GMO overall, not just their ingredients. This makes it technically incorrect for the business intent. The reference query directly addresses the question by focusing on ingredient-level non-GMO status.", "overall_assessment": "differently_correct"}}
{"example_id": 264, "sql_complexity": "set operations", "prompt": "List the number of community health centers and infectious disease tracking facilities in 'southwest' regions.", "context": "CREATE TABLE centers (id INT, name TEXT, region TEXT); INSERT INTO centers (id, name, region) VALUES (1, 'Center A', 'southwest'); INSERT INTO centers (id, name, region) VALUES (2, 'Center B', 'northeast'); INSERT INTO centers (id, name, region) VALUES (3, 'Center C', 'northwest'); CREATE TABLE diseases (id INT, name TEXT, region TEXT); INSERT INTO diseases (id, name, region) VALUES (1, 'Disease A', 'southwest'); INSERT INTO diseases (id, name, region) VALUES (2, 'Disease B', 'southeast');", "reference_sql": "SELECT COUNT(*) FROM ( (SELECT * FROM centers WHERE region = 'southwest') UNION (SELECT * FROM diseases WHERE region = 'southwest') );", "generated_sql": "SELECT \n    (SELECT COUNT(*) FROM centers WHERE region = 'southwest') AS community_health_centers,\n    (SELECT COUNT(*) FROM diseases WHERE region = 'southwest') AS infectious_disease_tracking_facilities;", "raw_model_output": "SELECT \n    (SELECT COUNT(*) FROM centers WHERE region = 'southwest') AS community_health_centers,\n    (SELECT COUNT(*) FROM diseases WHERE region = 'southwest') AS infectious_disease_tracking_facilities;", "latency_sec": 0.8204689025878906, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 224, "prompt_eval_sec": null, "tokens_completion": 45, "completion_eval_sec": null, "tokens_total": 269, "tokens_per_sec": 327.8612987665112, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns a single count of all unique rows from both tables combined via UNION, while the Generated SQL returns two separate counts (1 for centers and 1 for diseases). The result structures differ: the first produces a single value (2), the second produces two columns (1 and 1). Although the sum of the Generated SQL's values equals the Reference SQL's result, their output formats and semantics are distinct.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL combines results from both tables using UNION, which would count all rows from both tables as a single aggregate. This approach is incorrect because the original question requires separate counts for community health centers and infectious disease tracking facilities. The Generated SQL explicitly calculates two distinct counts using subqueries, directly addressing the business requirement. While both queries are syntactically valid, only the Generated SQL produces the correct semantic result. The Reference SQL would return a single number (total entries across both tables), whereas the Generated SQL returns two separate metrics as requested.", "overall_assessment": "differently_correct"}}
{"example_id": 2838, "sql_complexity": "basic SQL", "prompt": "What is the minimum safety rating of electric vehicles in the 'green_cars' table?", "context": "CREATE TABLE green_cars (id INT, make VARCHAR(50), model VARCHAR(50), type VARCHAR(50), safety_rating INT);", "reference_sql": "SELECT MIN(safety_rating) FROM green_cars WHERE type = 'Electric';", "generated_sql": "SELECT MIN(safety_rating) AS min_safety_rating\nFROM green_cars\nWHERE type = 'electric';", "raw_model_output": "SELECT MIN(safety_rating) AS min_safety_rating\nFROM green_cars\nWHERE type = 'electric';", "latency_sec": 0.5198168754577637, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 113, "prompt_eval_sec": null, "tokens_completion": 24, "completion_eval_sec": null, "tokens_total": 137, "tokens_per_sec": 263.5543524425874, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. The difference in string case ('Electric' vs 'electric') is irrelevant under standard SQL's case-insensitive string comparison (assuming default collation). The alias 'min_safety_rating' in the generated query does not affect the result set's content, only the column name.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent due to case sensitivity in the WHERE clause ('Electric' vs 'electric'). While both correctly use MIN(safety_rating) and filter by type, the reference query matches the exact casing expected in the 'type' column (assuming data uses 'Electric' as stored). The generated query's lowercase 'electric' might fail to retrieve results if the database is case-sensitive. Both fulfill the business intent of finding minimum safety ratings for electric vehicles, but the reference is more likely to match actual data casing. The generated query adds an alias (min_safety_rating) which improves readability but doesn't affect functionality.", "overall_assessment": "differently_correct"}}
{"example_id": 1187, "sql_complexity": "multiple_joins", "prompt": "Who are the top 3 authors with the highest number of articles published in The Guardian?", "context": "CREATE TABLE authors (id INT, name VARCHAR(100), publisher VARCHAR(50)); CREATE TABLE articles_authors (article_id INT, author_id INT); INSERT INTO authors (id, name, publisher) VALUES (1, 'Author1', 'The Guardian'), (2, 'Author2', 'The Guardian'), (3, 'Author3', 'The Guardian'); INSERT INTO articles_authors (article_id, author_id) VALUES (1, 1), (2, 2), (3, 1), (3, 2), (3, 3); INSERT INTO articles (id, title, publication_date, publisher) VALUES (1, 'Article1', '2021-01-01', 'The Guardian'), (2, 'Article2', '2021-01-02', 'The Guardian'), (3, 'Article3', '2021-01-03', 'The Guardian');", "reference_sql": "SELECT a.name, COUNT(aa.article_id) AS articles_count FROM authors a JOIN articles_authors aa ON a.id = aa.author_id JOIN articles ar ON aa.article_id = ar.id WHERE ar.publisher = 'The Guardian' GROUP BY a.name ORDER BY articles_count DESC LIMIT 3;", "generated_sql": "SELECT a.name\nFROM authors a\nJOIN articles_authors aa ON a.id = aa.author_id\nJOIN articles ar ON aa.article_id = ar.id\nWHERE ar.publisher = 'The Guardian'\nGROUP BY a.id, a.name\nORDER BY COUNT(ar.id) DESC\nLIMIT 3;", "raw_model_output": "SELECT a.name\nFROM authors a\nJOIN articles_authors aa ON a.id = aa.author_id\nJOIN articles ar ON aa.article_id = ar.id\nWHERE ar.publisher = 'The Guardian'\nGROUP BY a.id, a.name\nORDER BY COUNT(ar.id) DESC\nLIMIT 3;", "latency_sec": 0.8328280448913574, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 274, "prompt_eval_sec": null, "tokens_completion": 61, "completion_eval_sec": null, "tokens_total": 335, "tokens_per_sec": 402.2438990316432, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve authors and count their articles published by 'The Guardian'. The Reference SQL groups by a.name, while the Generated SQL groups by a.id and a.name. Since each author's id uniquely identifies their name in the dataset, the grouping behavior is equivalent. Both use the same joins, filter conditions, and ordering logic, resulting in identical output.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify the top 3 authors by article count in The Guardian. The Reference SQL groups by a.name, which works in this case due to unique names but is technically less precise (could fail if names were non-unique). The Generated SQL groups by a.id and a.name, which is more robust as it explicitly uses the primary key (a.id) for grouping. Both count articles correctly (COUNT(aa.article_id) vs COUNT(ar.id) are equivalent here). The Generated query is more technically sound and avoids potential edge cases, making it superior despite identical results.", "overall_assessment": "correct"}}
{"example_id": 360, "sql_complexity": "window functions", "prompt": "What is the change in crime rate for each category, between this year and last year, for the same time period?", "context": "CREATE TABLE CrimeStatistics (ID INT, CrimeType VARCHAR(50), Date TIMESTAMP, Count INT); INSERT INTO CrimeStatistics (ID, CrimeType, Date, Count) VALUES (1, 'Theft', '2022-01-01 00:00:00', 100), (2, 'Vandalism', '2022-01-01 00:00:00', 50), (3, 'Theft', '2022-01-02 00:00:00', 120), (4, 'Vandalism', '2022-01-02 00:00:00', 60), (5, 'Theft', '2021-01-01 00:00:00', 80), (6, 'Vandalism', '2021-01-01 00:00:00', 40), (7, 'Theft', '2021-01-02 00:00:00', 90), (8, 'Vandalism', '2021-01-02 00:00:00', 45);", "reference_sql": "SELECT CrimeType, (SUM(Count) OVER (PARTITION BY CrimeType ORDER BY EXTRACT(YEAR FROM Date) ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)) - SUM(Count) OVER (PARTITION BY CrimeType ORDER BY EXTRACT(YEAR FROM Date)) AS CrimeRateChange FROM CrimeStatistics WHERE Date BETWEEN DATE_TRUNC('year', CURRENT_DATE - INTERVAL '1 year') AND CURRENT_DATE;", "generated_sql": "SELECT\n    CrimeType,\n    (SUM(CASE WHEN YEAR(Date) = YEAR(CURRENT_DATE) THEN Count ELSE 0 END) -\n     SUM(CASE WHEN YEAR(Date) = YEAR(CURRENT_DATE) - 1 THEN Count ELSE 0 END)) AS ChangeInCrimeRate\nFROM\n    CrimeStatistics\nWHERE\n    (YEAR(Date) = YEAR(CURRENT_DATE) OR YEAR(Date) = YEAR(CURRENT_DATE) - 1)\n    AND MONTH(Date) = MONTH(CURRENT_DATE)\nGROUP BY\n    CrimeType;", "raw_model_output": "SELECT\n    CrimeType,\n    (SUM(CASE WHEN YEAR(Date) = YEAR(CURRENT_DATE) THEN Count ELSE 0 END) -\n     SUM(CASE WHEN YEAR(Date) = YEAR(CURRENT_DATE) - 1 THEN Count ELSE 0 END)) AS ChangeInCrimeRate\nFROM\n    CrimeStatistics\nWHERE\n    (YEAR(Date) = YEAR(CURRENT_DATE) OR YEAR(Date) = YEAR(CURRENT_DATE) - 1)\n    AND MONTH(Date) = MONTH(CURRENT_DATE)\nGROUP BY\n    CrimeType;", "latency_sec": 0.9521808624267578, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 323, "prompt_eval_sec": null, "tokens_completion": 111, "completion_eval_sec": null, "tokens_total": 434, "tokens_per_sec": 455.7957601604112, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in date filtering and calculation logic. The Reference SQL uses window functions to compare year-over-year sums across all dates in the last two years, while the Generated SQL restricts to the same month in current and previous years and calculates the difference via conditional aggregation. The date ranges, aggregation methods, and result structures (row-level vs grouped) make them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL has critical flaws: 1) It uses DATE_TRUNC to capture the last full year but compares it to the current year's partial data, not the same time period. 2) The window function logic is incorrect - ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING only captures the immediately preceding year's data, not the full year's total. 3) It doesn't ensure the same time period (month/day) comparison. The Generated SQL correctly: 1) Filters for the same month in both years using MONTH(Date) = MONTH(CURRENT_DATE). 2) Explicitly separates current year and previous year counts with CASE statements. 3) Uses proper aggregation to calculate the exact same time period comparison. While both have issues with year comparison (current year vs previous year), the Generated SQL better addresses the 'same time period' requirement.", "overall_assessment": "differently_correct"}}
{"example_id": 335, "sql_complexity": "single join", "prompt": "List the policy numbers, claim amounts, and claim dates for policies that have more than two claims and the total claim amount exceeds $5000", "context": "CREATE TABLE policies (policy_number INT);CREATE TABLE claims (claim_id INT, policy_number INT, claim_amount DECIMAL(10,2), claim_date DATE);", "reference_sql": "SELECT p.policy_number, c.claim_amount, c.claim_date FROM policies p INNER JOIN claims c ON p.policy_number = c.policy_number GROUP BY p.policy_number, c.claim_amount, c.claim_date HAVING COUNT(c.claim_id) > 2 AND SUM(c.claim_amount) > 5000;", "generated_sql": "SELECT \n    c.policy_number, \n    c.claim_amount, \n    c.claim_date\nFROM \n    claims c\nWHERE \n    c.policy_number IN (\n        SELECT \n            policy_number\n        FROM \n            claims\n        GROUP BY \n            policy_number\n        HAVING \n            COUNT(*) > 2 AND \n            SUM(claim_amount) > 5000\n    );", "raw_model_output": "SELECT \n    c.policy_number, \n    c.claim_amount, \n    c.claim_date\nFROM \n    claims c\nWHERE \n    c.policy_number IN (\n        SELECT \n            policy_number\n        FROM \n            claims\n        GROUP BY \n            policy_number\n        HAVING \n            COUNT(*) > 2 AND \n            SUM(claim_amount) > 5000\n    );", "latency_sec": 1.1324739456176758, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 129, "prompt_eval_sec": null, "tokens_completion": 80, "completion_eval_sec": null, "tokens_total": 209, "tokens_per_sec": 184.5517071794591, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query groups by policy_number, claim_amount, and claim_date, requiring each group to have >2 claims with the same amount/date combination. The generated query filters policies with >2 total claims (regardless of amount/date) and sum >5000, then returns all claims for those policies. This leads to different result sets: the reference query enforces per-amount-date group constraints, while the generated query applies policy-level constraints and returns all claims for qualifying policies.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL is technically incorrect because it groups by claim_amount and claim_date, which would split claims into individual records rather than aggregating per policy. This would fail to correctly identify policies with >2 claims and total >$5000. The Generated SQL correctly uses a subquery to first identify qualifying policies (with COUNT(*) > 2 and SUM(claim_amount) > 5000) and then retrieves all claims for those policies. While both queries aim to list claims, only the Generated SQL properly addresses the business intent by first filtering policies based on aggregate criteria before returning individual claims.", "overall_assessment": "differently_correct"}}
{"example_id": 2866, "sql_complexity": "basic SQL", "prompt": "What is the number of hospitals in 'rural_healthcare' table?", "context": "CREATE TABLE rural_healthcare (name VARCHAR(255), type VARCHAR(255), location VARCHAR(255)); INSERT INTO rural_healthcare (name, type, location) VALUES ('Rural General Hospital', 'Hospital', 'Bushland'), ('Rural Community Hospital', 'Hospital', 'Forest Region');", "reference_sql": "SELECT COUNT(*) FROM rural_healthcare WHERE type = 'Hospital';", "generated_sql": "SELECT COUNT(*) AS number_of_hospitals\nFROM rural_healthcare\nWHERE type = 'Hospital';", "raw_model_output": "SELECT COUNT(*) AS number_of_hospitals\nFROM rural_healthcare\nWHERE type = 'Hospital';", "latency_sec": 0.7453289031982422, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 142, "prompt_eval_sec": null, "tokens_completion": 22, "completion_eval_sec": null, "tokens_total": 164, "tokens_per_sec": 220.0370860384833, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries count the number of rows where type = 'Hospital'. The generated query adds an alias (number_of_hospitals) for the COUNT(*) result, but this does not affect the actual value returned. The semantic meaning remains the same.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count rows where type = 'Hospital' in the rural_healthcare table. The generated query adds an explicit alias (number_of_hospitals) for the COUNT(*) result, improving readability and making the output column name more descriptive. While the reference query is technically correct, the generated version is more elegant and practical for downstream use cases (e.g., reporting or API responses) where column names matter. The business intent of counting hospitals is equally fulfilled by both.", "overall_assessment": "correct"}}
{"example_id": 4440, "sql_complexity": "multiple_joins", "prompt": "What is the average session length for each game genre in the last month, sorted by average session length.", "context": "CREATE TABLE game_sessions(id INT, user_id INT, game_name VARCHAR(50), start_time DATETIME, end_time DATETIME); CREATE TABLE games(id INT, name VARCHAR(50), genre VARCHAR(50));", "reference_sql": "SELECT genres.genre, AVG(TIMESTAMPDIFF(SECOND, start_time, end_time)) as avg_session_length FROM game_sessions JOIN games ON game_sessions.game_name = games.name JOIN (SELECT DISTINCT game_name, genre FROM game_sessions JOIN games ON game_sessions.game_name = games.name) genres ON games.name = genres.game_name WHERE start_time >= DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH) GROUP BY genres.genre ORDER BY avg_session_length DESC;", "generated_sql": "SELECT \n    g.genre,\n    AVG(TIMESTAMPDIFF(SECOND, gs.start_time, gs.end_time)) AS avg_session_length_seconds\nFROM \n    game_sessions gs\nJOIN \n    games g ON gs.game_name = g.name\nWHERE \n    gs.start_time >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH)\nGROUP BY \n    g.genre\nORDER BY \n    avg_session_length_seconds;", "raw_model_output": "SELECT \n    g.genre,\n    AVG(TIMESTAMPDIFF(SECOND, gs.start_time, gs.end_time)) AS avg_session_length_seconds\nFROM \n    game_sessions gs\nJOIN \n    games g ON gs.game_name = g.name\nWHERE \n    gs.start_time >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH)\nGROUP BY \n    g.genre\nORDER BY \n    avg_session_length_seconds;", "latency_sec": 0.9275588989257812, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 131, "prompt_eval_sec": null, "tokens_completion": 86, "completion_eval_sec": null, "tokens_total": 217, "tokens_per_sec": 233.94740781562302, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average session length per genre by joining game_sessions with games. The Reference SQL includes a redundant subquery and join that doesn't affect the final result, as the Generated SQL directly groups by genre from the games table. Assuming game_names are unique in the games table, both queries produce the same output.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate average session length per genre for the last month. The key differences: 1) The Reference query uses an unnecessary subquery with DISTINCT that doesn't add value (games.genre is already determined by the JOIN) 2) The Generated query is more efficient with simpler structure 3) Both handle time filtering correctly with DATE_SUB/CURDATE. The Generated query achieves the same result with fewer operations and clearer logic.", "overall_assessment": "correct"}}
{"example_id": 451, "sql_complexity": "single join", "prompt": "Which customers have made a transaction over 500 in the \"risk_management\" category?", "context": "CREATE TABLE customers (id INT, name VARCHAR(50), category VARCHAR(50)); INSERT INTO customers (id, name, category) VALUES (1, 'John Doe', 'risk_management'); INSERT INTO customers (id, name, category) VALUES (2, 'Jane Smith', 'compliance'); INSERT INTO customers (id, name, category) VALUES (3, 'Jim Brown', 'risk_management'); CREATE TABLE transactions (id INT, customer_id INT, amount DECIMAL(10, 2)); INSERT INTO transactions (id, customer_id, amount) VALUES (1, 1, 500.00); INSERT INTO transactions (id, customer_id, amount) VALUES (2, 1, 200.00); INSERT INTO transactions (id, customer_id, amount) VALUES (3, 2, 100.00); INSERT INTO transactions (id, customer_id, amount) VALUES (4, 3, 750.00);", "reference_sql": "SELECT c.name FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE c.category = 'risk_management' AND t.amount > 500;", "generated_sql": "SELECT c.*\nFROM customers c\nJOIN transactions t ON c.id = t.customer_id\nWHERE c.category = 'risk_management' AND t.amount > 500;", "raw_model_output": "SELECT c.*\nFROM customers c\nJOIN transactions t ON c.id = t.customer_id\nWHERE c.category = 'risk_management' AND t.amount > 500;", "latency_sec": 0.9077887535095215, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 279, "prompt_eval_sec": null, "tokens_completion": 34, "completion_eval_sec": null, "tokens_total": 313, "tokens_per_sec": 344.79387279247345, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL selects only the 'name' column from customers, while the Generated SQL selects all columns ('c.*'). Although both filter for 'risk_management' category and transactions over 500, the result sets differ in column composition.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent because they return different column sets (name vs. all columns). Both correctly identify customers in the 'risk_management' category with transactions >500, but the Reference SQL explicitly answers the business question by returning only the customer name, while the Generated SQL returns all customer columns. The Reference is more precise and efficient for the stated intent, though both are logically correct.", "overall_assessment": "differently_correct"}}
{"example_id": 2879, "sql_complexity": "basic SQL", "prompt": "Update the FoodSafetyRecords.OrganicFarms table to include a new record for a certified organic farm in Kenya.", "context": "CREATE TABLE FoodSafetyRecords.OrganicFarms (farmName TEXT, country TEXT, certified BOOLEAN);", "reference_sql": "INSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('Ngong Organic Farm', 'Kenya', TRUE);", "generated_sql": "INSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified)\nVALUES ('New Organic Farm', 'Kenya', TRUE);", "raw_model_output": "INSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified)\nVALUES ('New Organic Farm', 'Kenya', TRUE);", "latency_sec": 0.5169768333435059, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 110, "prompt_eval_sec": null, "tokens_completion": 30, "completion_eval_sec": null, "tokens_total": 140, "tokens_per_sec": 270.8051714707627, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The two queries differ in the farmName value being inserted ('Ngong Organic Farm' vs 'New Organic Farm'). While the structure and other values are identical, the distinct farm names result in different data being inserted, making them semantically non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "equal", "explanation": "The queries differ in the farmName value ('Ngong Organic Farm' vs. 'New Organic Farm'), so they are not technically equivalent as they insert distinct records. Both correctly fulfill the business intent by adding a certified organic farm in Kenya with valid syntax. Neither query is more efficient or elegant than the other, as both are simple INSERT statements with identical structure. The difference in farm names does not affect correctness since the original question did not specify a particular farm name.", "overall_assessment": "differently_correct"}}
{"example_id": 5688, "sql_complexity": "single join", "prompt": "What is the total amount donated to a specific cause?", "context": "CREATE TABLE causes (id INT, name TEXT); CREATE TABLE donations (id INT, donor_id INT, cause_id INT, donation_amount DECIMAL(10,2)); INSERT INTO causes (id, name) VALUES (1, 'Cause A'), (2, 'Cause B'); INSERT INTO donations (id, donor_id, cause_id, donation_amount) VALUES (1, 1, 1, 50.00), (2, 2, 1, 100.00);", "reference_sql": "SELECT SUM(donation_amount) FROM donations JOIN causes ON donations.cause_id = causes.id WHERE causes.name = 'Cause A';", "generated_sql": "SELECT SUM(donation_amount) AS total_donated\nFROM donations\nWHERE cause_id = ?;", "raw_model_output": "SELECT SUM(donation_amount) AS total_donated\nFROM donations\nWHERE cause_id = ?;", "latency_sec": 0.5717051029205322, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 179, "prompt_eval_sec": null, "tokens_completion": 22, "completion_eval_sec": null, "tokens_total": 201, "tokens_per_sec": 351.57985991938796, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses a JOIN with the causes table to filter by cause name ('Cause A'), while the Generated SQL directly filters by cause_id. Although the cause_id might correspond to 'Cause A's id, the Generated SQL lacks the join and relies on a parameterized value. Without knowing the parameter's value, they aren't guaranteed to be equivalent. The Reference SQL explicitly links cause names to donations, whereas the Generated SQL assumes the cause_id is already known.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query is technically more complete as it explicitly filters by cause name ('Cause A') using a JOIN, ensuring clarity and correctness. The generated query uses a parameterized placeholder (?) which requires external input to function. While both would produce the same result if the parameter matches the cause_id for 'Cause A', the reference directly addresses the business intent by using the cause name as specified in the question. The generated query assumes prior knowledge of the cause_id, which isn't explicitly provided in the original question. The reference is more self-contained and aligns better with the explicit business requirement.", "overall_assessment": "correct"}}
{"example_id": 3273, "sql_complexity": "multiple_joins", "prompt": "List all departments, the number of chemicals they handle, and the number of machines used in their manufacturing processes.", "context": "CREATE TABLE Departments (DepartmentID INT, DepartmentName VARCHAR(20)); INSERT INTO Departments (DepartmentID, DepartmentName) VALUES (1, 'Manufacturing'), (2, 'Engineering'), (3, 'Chemical Safety'), (4, 'Product Development'); CREATE TABLE Chemicals (ChemicalID INT, ChemicalName VARCHAR(20), DepartmentID INT); INSERT INTO Chemicals (ChemicalID, ChemicalName, DepartmentID) VALUES (1, 'Hydrochloric Acid', 1), (2, 'Nitric Acid', 2), (3, 'Sodium Hydroxide', 3), (4, 'New Chemical', 4); CREATE TABLE Machinery (MachineID INT, MachineName VARCHAR(20), DepartmentID INT); INSERT INTO Machinery (MachineID, MachineName, DepartmentID) VALUES (1, 'Mixer 1', 1), (2, 'Cutter 2', 2), (3, 'Dispenser 3', 3), (4, 'Innovator 4', 4);", "reference_sql": "SELECT D.DepartmentName, COUNT(C.ChemicalID) AS ChemicalCount, COUNT(M.MachineID) AS MachineCount FROM Departments D LEFT JOIN Chemicals C ON D.DepartmentID = C.DepartmentID LEFT JOIN Machinery M ON D.DepartmentID = M.DepartmentID GROUP BY D.DepartmentName;", "generated_sql": "SELECT \n    d.DepartmentID,\n    d.DepartmentName,\n    COUNT(DISTINCT c.ChemicalID) AS ChemicalCount,\n    COUNT(DISTINCT m.MachineID) AS MachineCount\nFROM \n    Departments d\nLEFT JOIN \n    Chemicals c ON d.DepartmentID = c.DepartmentID\nLEFT JOIN \n    Machinery m ON d.DepartmentID = m.DepartmentID\nGROUP BY \n    d.DepartmentID, d.DepartmentName;", "raw_model_output": "SELECT \n    d.DepartmentID,\n    d.DepartmentName,\n    COUNT(DISTINCT c.ChemicalID) AS ChemicalCount,\n    COUNT(DISTINCT m.MachineID) AS MachineCount\nFROM \n    Departments d\nLEFT JOIN \n    Chemicals c ON d.DepartmentID = c.DepartmentID\nLEFT JOIN \n    Machinery m ON d.DepartmentID = m.DepartmentID\nGROUP BY \n    d.DepartmentID, d.DepartmentName;", "latency_sec": 6.781797170639038, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 299, "prompt_eval_sec": null, "tokens_completion": 90, "completion_eval_sec": null, "tokens_total": 389, "tokens_per_sec": 57.359427038621554, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in three key aspects: 1) The Reference query groups by DepartmentName (which could combine departments with identical names), while the Generated query groups by DepartmentID and DepartmentName (ensuring unique grouping). 2) The Reference uses COUNT(C.ChemicalID) and COUNT(M.MachineID) (counting all matches), while the Generated uses COUNT(DISTINCT ...) which would return different results if there were duplicate ChemicalID/MachineID values in the tables. 3) The Generated query includes DepartmentID in the output, whereas the Reference does not.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries produce the same numerical results for chemical and machine counts. The reference query aligns directly with the original question's requirements by returning DepartmentName (as requested) and avoids including DepartmentID, which wasn't specified. The generated query's use of COUNT(DISTINCT) is unnecessary given the schema's primary keys but doesn't affect results. The reference's GROUP BY on DepartmentName is functionally equivalent to the generated query's GROUP BY on both ID and name, though the latter is more robust. However, since the original question didn't request DepartmentID, the reference better fulfills the explicit requirements.", "overall_assessment": "correct"}}
{"example_id": 1895, "sql_complexity": "window functions", "prompt": "What is the average safety score of chemical production sites in the United States, partitioned by state and ranked in descending order?", "context": "CREATE TABLE production_sites (site_id INT, site_name TEXT, country TEXT, state TEXT, safety_score FLOAT); INSERT INTO production_sites (site_id, site_name, country, state, safety_score) VALUES (1, 'Site A', 'USA', 'NY', 92.5), (2, 'Site B', 'USA', 'CA', 87.4), (3, 'Site C', 'USA', 'TX', 95.3), (4, 'Site D', 'USA', 'FL', 89.2);", "reference_sql": "SELECT state, AVG(safety_score) as avg_safety_score, ROW_NUMBER() OVER (ORDER BY AVG(safety_score) DESC) as rank FROM production_sites WHERE country = 'USA' GROUP BY state ORDER BY rank;", "generated_sql": "SELECT \n    state,\n    AVG(safety_score) AS average_safety_score\nFROM \n    production_sites\nWHERE \n    country = 'USA'\nGROUP BY \n    state\nORDER BY \n    average_safety_score DESC;", "raw_model_output": "SELECT \n    state,\n    AVG(safety_score) AS average_safety_score\nFROM \n    production_sites\nWHERE \n    country = 'USA'\nGROUP BY \n    state\nORDER BY \n    average_safety_score DESC;", "latency_sec": 0.8190395832061768, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 206, "prompt_eval_sec": null, "tokens_completion": 48, "completion_eval_sec": null, "tokens_total": 254, "tokens_per_sec": 310.1193217130027, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a ROW_NUMBER() column as 'rank' and orders by this rank, while the Generated SQL only calculates the average safety score and orders by that value directly. The presence of the additional 'rank' column in the Reference SQL makes the result sets structurally different, even though the ordering of states by safety scores might coincide.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL includes a ranking column using ROW_NUMBER() which directly addresses the 'ranked in descending order' requirement. The Generated SQL correctly calculates averages by state but omits the ranking entirely. While both queries technically compute the average safety scores, the Reference SQL's inclusion of ranking makes it semantically equivalent to the original question. The Generated SQL fails to fulfill the business intent as it doesn't provide the requested ranking. The Reference SQL is more elegant in combining aggregation and ranking in a single query, though both are technically correct in their own right.", "overall_assessment": "differently_correct"}}
{"example_id": 4669, "sql_complexity": "set operations", "prompt": "Identify the number of IoT devices in each country and the total number of devices.", "context": "CREATE TABLE device_country (device_id INT, country TEXT); INSERT INTO device_country (device_id, country) VALUES (1, 'USA'), (2, 'Canada'), (3, 'Mexico'), (4, 'Brazil'); CREATE TABLE device_info (device_id INT, device_type TEXT); INSERT INTO device_info (device_id, device_type) VALUES (1, 'Soil Sensor'), (2, 'Temperature Sensor'), (3, 'Humidity Sensor'), (4, 'Precision Sprayer');", "reference_sql": "SELECT country, COUNT(*) AS device_count FROM device_country GROUP BY country UNION SELECT 'Total' AS country, COUNT(*) FROM device_country;", "generated_sql": "SELECT \n    country,\n    COUNT(*) AS device_count\nFROM \n    device_country\nGROUP BY \n    country\nUNION ALL\nSELECT \n    'Total' AS country,\n    COUNT(*) AS device_count\nFROM \n    device_country;", "raw_model_output": "SELECT \n    country,\n    COUNT(*) AS device_count\nFROM \n    device_country\nGROUP BY \n    country\nUNION ALL\nSELECT \n    'Total' AS country,\n    COUNT(*) AS device_count\nFROM \n    device_country;", "latency_sec": 1.2805030345916748, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 186, "prompt_eval_sec": null, "tokens_completion": 51, "completion_eval_sec": null, "tokens_total": 237, "tokens_per_sec": 185.083512961431, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries produce the same result by grouping device counts by country and adding a 'Total' row. The difference between UNION and UNION ALL is irrelevant here because the two result sets (country groups and 'Total') have no overlapping rows. The final output will include all country groups followed by the total count in both cases.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count devices per country and include a total. The reference uses UNION (which removes duplicates) while the generated uses UNION ALL (which preserves all rows). Since the two query blocks cannot produce duplicate rows (one groups by country, the other is a single 'Total' row), both produce identical results. However, the generated query is more efficient due to UNION ALL's lack of deduplication overhead. The reference's use of UNION is technically correct but less optimal.", "overall_assessment": "correct"}}
{"example_id": 5302, "sql_complexity": "multiple_joins", "prompt": "Find the supplier with the lowest average delivery time for orders in the last month.", "context": "CREATE TABLE Suppliers (SupplierID int, SupplierName varchar(50)); CREATE TABLE Products (ProductID int, ProductName varchar(50), SupplierID int); CREATE TABLE Orders (OrderID int, ProductID int, OrderDate date, DeliveryTime int); INSERT INTO Suppliers VALUES (1, 'SupplierA'), (2, 'SupplierB'); INSERT INTO Products VALUES (1, 'Organic Apples', 1), (2, 'Bananas', 2); INSERT INTO Orders VALUES (1, 1, '2022-01-01', 2), (2, 2, '2022-01-03', 3);", "reference_sql": "SELECT SupplierName, AVG(DeliveryTime) as AvgDeliveryTime FROM Orders o JOIN Products p ON o.ProductID = p.ProductID JOIN Suppliers sp ON p.SupplierID = sp.SupplierID WHERE OrderDate >= DATEADD(month, -1, GETDATE()) GROUP BY SupplierName ORDER BY AvgDeliveryTime ASC;", "generated_sql": "SELECT s.SupplierID, s.SupplierName\nFROM Suppliers s\nJOIN Products p ON s.SupplierID = p.SupplierID\nJOIN Orders o ON p.ProductID = o.ProductID\nWHERE o.OrderDate >= DATE('2022-12-01') AND o.OrderDate <= DATE('2022-12-31')\nGROUP BY s.SupplierID, s.SupplierName\nORDER BY AVG(o.DeliveryTime) ASC\nLIMIT 1;", "raw_model_output": "SELECT s.SupplierID, s.SupplierName\nFROM Suppliers s\nJOIN Products p ON s.SupplierID = p.SupplierID\nJOIN Orders o ON p.ProductID = o.ProductID\nWHERE o.OrderDate >= DATE('2022-12-01') AND o.OrderDate <= DATE('2022-12-31')\nGROUP BY s.SupplierID, s.SupplierName\nORDER BY AVG(o.DeliveryTime) ASC\nLIMIT 1;", "latency_sec": 1.0217008590698242, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 215, "prompt_eval_sec": null, "tokens_completion": 90, "completion_eval_sec": null, "tokens_total": 305, "tokens_per_sec": 298.52182005374624, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in several key aspects. 1) The date filtering conditions are different: the Reference query uses a dynamic date range based on the current date, while the Generated query uses a fixed date range for December 2022. 2) The Generated query includes a LIMIT 1 clause, which restricts the result to a single row, while the Reference query returns all suppliers. 3) The columns selected differ: the Reference query selects SupplierName and AvgDeliveryTime, while the Generated query selects SupplierID and SupplierName. 4) The grouping in the Generated query includes SupplierID (in addition to SupplierName) which could lead to different grouping behavior if there were multiple suppliers with the same name (though not the case in the provided data). These differences mean the queries would not produce the same results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in three critical aspects:\n1. Date Filtering: Reference uses dynamic DATEADD(month, -1, GETDATE()) while Generated uses static December 2022 dates, making it incorrect for any other time period.\n2. Grouping: Reference groups by SupplierName (potentially unsafe if names aren't unique) while Generated groups by SupplierID/Name (more reliable).\n3. Result Selection: Generated uses LIMIT 1 which is SQL-specific and might not work across all databases, while Reference relies on ORDER BY ASC which is standard.\nReference better fulfills the intent with dynamic date calculation, though both have room for improvement in handling potential name duplication.", "overall_assessment": "differently_correct"}}
{"example_id": 267, "sql_complexity": "subqueries", "prompt": "What is the total number of disability support programs offered in urban and rural areas, and the percentage of total programs for each area type?", "context": "CREATE TABLE programs (program_id INT, program_name VARCHAR(255), area_type VARCHAR(255));", "reference_sql": "SELECT area_type, COUNT(*) as total_programs, ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM programs) , 2) as percentage_of_total FROM programs WHERE area_type IN ('urban', 'rural') GROUP BY area_type;", "generated_sql": "SELECT COUNT(*) AS total_count\n    FROM programs\n),\narea_counts AS (\n    SELECT \n        area_type,\n        COUNT(*) AS area_count\n    FROM programs\n    GROUP BY area_type\n)\nSELECT\n    ac.area_type,\n    ac.area_count,\n    tc.total_count,\n    ROUND((ac.area_count * 100.0) / tc.total_count, 2) AS percentage\nFROM area_counts ac, total_programs tc;", "raw_model_output": "WITH total_programs AS (\n    SELECT COUNT(*) AS total_count\n    FROM programs\n),\narea_counts AS (\n    SELECT \n        area_type,\n        COUNT(*) AS area_count\n    FROM programs\n    GROUP BY area_type\n)\nSELECT\n    ac.area_type,\n    ac.area_count,\n    tc.total_count,\n    ROUND((ac.area_count * 100.0) / tc.total_count, 2) AS percentage\nFROM area_counts ac, total_programs tc;", "latency_sec": 1.1928770542144775, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 114, "prompt_eval_sec": null, "tokens_completion": 99, "completion_eval_sec": null, "tokens_total": 213, "tokens_per_sec": 178.55989370192287, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL filters area_type to ('urban', 'rural') in the WHERE clause, while the Generated SQL includes all area_types without filtering. Additionally, the Generated SQL's JOIN logic (implicit cross join between area_counts and total_programs) would produce a Cartesian product, leading to incorrect calculations. The column aliases and calculation context also differ, further breaking semantic equivalence.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The Reference SQL is technically correct and semantically equivalent, while the Generated SQL has structural flaws. The Reference SQL properly calculates percentages using a subquery to get the total count once, ensuring accuracy and efficiency. The Generated SQL uses a Cartesian join between two CTEs (total_programs and area_counts) which creates a cross join (no join condition), leading to incorrect intermediate values (e.g., area_count * total_count) even though the final percentage calculation might coincidentally produce correct results. The Generated SQL also includes an unnecessary 'total_count' column. Both queries fulfill the business intent, but the Reference SQL is more efficient and logically sound.", "overall_assessment": "correct"}}
{"example_id": 3028, "sql_complexity": "basic SQL", "prompt": "What is the number of startups founded by non-binary individuals in the technology industry?", "context": "CREATE TABLE company (id INT, name TEXT, founder_gender TEXT, industry TEXT); INSERT INTO company (id, name, founder_gender, industry) VALUES (1, 'CodeForAll', 'Non-binary', 'Technology'); INSERT INTO company (id, name, founder_gender, industry) VALUES (2, 'TechVillage', 'Male', 'Technology');", "reference_sql": "SELECT COUNT(*) FROM company WHERE founder_gender = 'Non-binary' AND industry = 'Technology';", "generated_sql": "SELECT COUNT(*) AS startup_count\nFROM company\nWHERE founder_gender = 'Non-binary' AND industry = 'Technology';", "raw_model_output": "SELECT COUNT(*) AS startup_count\nFROM company\nWHERE founder_gender = 'Non-binary' AND industry = 'Technology';", "latency_sec": 0.5367012023925781, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 158, "prompt_eval_sec": null, "tokens_completion": 26, "completion_eval_sec": null, "tokens_total": 184, "tokens_per_sec": 342.8350806365633, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries count the same rows in the company table with identical WHERE conditions. The generated query adds an alias (startup_count) to the COUNT(*) result, but this does not affect the actual value returned. The semantic result (the count) remains identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically equivalent as they execute the same logic and return identical results. The reference query is functionally correct but lacks an explicit alias for the COUNT(*) result. The generated query adds clarity by naming the output column 'startup_count', which improves readability and aligns better with standard BI practices. While both fulfill the business intent of counting non-binary-founded tech startups, the generated query demonstrates greater elegance and user-friendliness without sacrificing efficiency.", "overall_assessment": "correct"}}
{"example_id": 3282, "sql_complexity": "aggregation", "prompt": "Which marine species have been observed in both the Arctic and Antarctic oceans?", "context": "CREATE TABLE marine_species (id INT, species_name VARCHAR(50), common_name VARCHAR(50), region VARCHAR(20));INSERT INTO marine_species (id, species_name, common_name, region) VALUES (1, 'Orcinus_orca', 'Killer Whale', 'Arctic');INSERT INTO marine_species (id, species_name, common_name, region) VALUES (2, 'Balaenoptera_bonaerensis', 'Antarctic Minke Whale', 'Antarctic');", "reference_sql": "SELECT species_name FROM marine_species WHERE region IN ('Arctic', 'Antarctic') GROUP BY species_name HAVING COUNT(DISTINCT region) = 2;", "generated_sql": "SELECT species_name\nFROM marine_species\nWHERE region IN ('Arctic', 'Antarctic')\nGROUP BY species_name\nHAVING COUNT(DISTINCT region) = 2;", "raw_model_output": "SELECT species_name\nFROM marine_species\nWHERE region IN ('Arctic', 'Antarctic')\nGROUP BY species_name\nHAVING COUNT(DISTINCT region) = 2;", "latency_sec": 0.5822811126708984, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 184, "prompt_eval_sec": null, "tokens_completion": 38, "completion_eval_sec": null, "tokens_total": 222, "tokens_per_sec": 381.25914643134405, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The reference and generated SQL queries are identical in structure and logic. Both select species_name from marine_species where region is 'Arctic' or 'Antarctic', group by species_name, and filter with HAVING COUNT(DISTINCT region) = 2. Since the queries are exactly the same, they will produce identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "The reference and generated SQL queries are identical in structure, logic, and implementation. Both correctly filter for species observed in 'Arctic' or 'Antarctic' regions, group by species_name, and use HAVING COUNT(DISTINCT region) = 2 to ensure presence in both regions. The queries are semantically equivalent and would produce identical results. The business intent of identifying species observed in both oceans is fully satisfied. Both queries are equally efficient and elegant, with no technical flaws.", "overall_assessment": "correct"}}
{"example_id": 3474, "sql_complexity": "subqueries", "prompt": "What is the total transaction volume for the top 3 digital assets by market capitalization in the 'developed_markets' schema?", "context": "CREATE SCHEMA developed_markets; CREATE TABLE developed_markets.digital_assets (asset_name VARCHAR(10), market_cap BIGINT, daily_transaction_volume BIGINT); INSERT INTO developed_markets.digital_assets (asset_name, market_cap, daily_transaction_volume) VALUES ('AssetG', 30000000, 15000000), ('AssetH', 25000000, 12000000), ('AssetI', 20000000, 10000000), ('AssetJ', 15000000, 8000000), ('AssetK', 10000000, 6000000);", "reference_sql": "SELECT SUM(daily_transaction_volume) FROM (SELECT daily_transaction_volume FROM developed_markets.digital_assets ORDER BY market_cap DESC FETCH NEXT 3 ROWS ONLY) t;", "generated_sql": "SELECT SUM(daily_transaction_volume) AS total_transaction_volume\nFROM (\n    SELECT daily_transaction_volume\n    FROM developed_markets.digital_assets\n    ORDER BY market_cap DESC\n    LIMIT 3\n) sub;", "raw_model_output": "SELECT SUM(daily_transaction_volume) AS total_transaction_volume\nFROM (\n    SELECT daily_transaction_volume\n    FROM developed_markets.digital_assets\n    ORDER BY market_cap DESC\n    LIMIT 3\n) sub;", "latency_sec": 0.6878910064697266, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 214, "prompt_eval_sec": null, "tokens_completion": 44, "completion_eval_sec": null, "tokens_total": 258, "tokens_per_sec": 375.05941722375803, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of the top 3 daily_transaction_volume values from the digital_assets table ordered by market_cap descending. The Reference SQL uses FETCH NEXT 3 ROWS ONLY while the Generated SQL uses LIMIT 3, but both achieve the same row limitation effect. The subquery structure, ordering, and aggregation are identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the total transaction volume for the top 3 digital assets by market capitalization. The reference query uses FETCH NEXT 3 ROWS ONLY (SQL Server syntax) while the generated query uses LIMIT 3 (PostgreSQL/MySQL syntax). Both achieve the same result by ordering by market_cap DESC, selecting the top 3 rows, and summing their daily_transaction_volume. The difference lies in syntax dialects rather than logic. The generated query adds an explicit subquery alias 'sub' which improves readability, but this is a stylistic choice rather than a functional improvement. Neither query has logical errors.", "overall_assessment": "correct"}}
{"example_id": 1626, "sql_complexity": "aggregation", "prompt": "Find the total value of social impact bonds issued by each organization.", "context": "CREATE TABLE social_impact_bonds (id INT, organization_name VARCHAR(255), issue_year INT, value FLOAT); INSERT INTO social_impact_bonds (id, organization_name, issue_year, value) VALUES (1, 'Acme Corp', 2018, 2000000), (2, 'XYZ Foundation', 2019, 3000000), (3, 'Global Giving', 2018, 1500000), (4, 'Acme Corp', 2019, 2500000), (5, 'XYZ Foundation', 2018, 1000000);", "reference_sql": "SELECT organization_name, SUM(value) as total_value FROM social_impact_bonds GROUP BY organization_name;", "generated_sql": "SELECT organization_name, SUM(value) AS total_value\nFROM social_impact_bonds\nGROUP BY organization_name;", "raw_model_output": "SELECT organization_name, SUM(value) AS total_value\nFROM social_impact_bonds\nGROUP BY organization_name;", "latency_sec": 0.5575180053710938, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 205, "prompt_eval_sec": null, "tokens_completion": 24, "completion_eval_sec": null, "tokens_total": 229, "tokens_per_sec": 410.7490660280534, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. The only differences are formatting (line breaks) and case sensitivity in the alias declaration (AS vs. as), which do not affect semantic equivalence in SQL.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure, logic, and output. They correctly aggregate the total value of social impact bonds by organization using SUM(value) with GROUP BY organization_name. The queries are technically correct, produce identical results, and fully address the business requirement of calculating organization-specific totals. Neither query has any advantage over the other in terms of efficiency, clarity, or correctness.", "overall_assessment": "correct"}}
{"example_id": 1315, "sql_complexity": "single join", "prompt": "List all the transactions made by clients living in New York with a transaction amount greater than $1000.", "context": "CREATE TABLE transactions (id INT, client_id INT, transaction_amount DECIMAL(10,2), transaction_date DATE); INSERT INTO transactions (id, client_id, transaction_amount, transaction_date) VALUES (1, 3, 1500.00, '2022-01-01'), (2, 4, 800.00, '2022-01-02'), (3, 3, 1200.00, '2022-01-03'); CREATE TABLE clients (id INT, name VARCHAR(255), state VARCHAR(255)); INSERT INTO clients (id, name, state) VALUES (3, 'Mike Johnson', 'New York'), (4, 'Sara Lee', 'California');", "reference_sql": "SELECT transactions.id, transactions.client_id, transactions.transaction_amount, transactions.transaction_date FROM transactions INNER JOIN clients ON transactions.client_id = clients.id WHERE clients.state = 'New York' AND transactions.transaction_amount > 1000.00;", "generated_sql": "SELECT t.*\nFROM transactions t\nJOIN clients c ON t.client_id = c.id\nWHERE c.state = 'New York' AND t.transaction_amount > 1000;", "raw_model_output": "SELECT t.*\nFROM transactions t\nJOIN clients c ON t.client_id = c.id\nWHERE c.state = 'New York' AND t.transaction_amount > 1000;", "latency_sec": 0.7648110389709473, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 236, "prompt_eval_sec": null, "tokens_completion": 36, "completion_eval_sec": null, "tokens_total": 272, "tokens_per_sec": 355.64340227878483, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between transactions and clients on client_id, filter for clients in 'New York' with transaction amounts over 1000, and select all columns from transactions. The generated query uses table aliases and selects all columns (t.*), which in this case includes exactly the same columns as the explicit list in the reference query. The WHERE conditions are logically identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent as they produce identical results by joining transactions with clients, filtering for New York residents with transactions over $1000. The reference query explicitly lists columns while the generated query uses a wildcard (*), but both return the same data given the schema. Both fulfill the business intent by addressing the core requirements. The superiority is equal as the generated query is more concise with aliases, while the reference is more explicit. Neither has a clear efficiency advantage in this context.", "overall_assessment": "correct"}}
{"example_id": 520, "sql_complexity": "multiple_joins", "prompt": "What is the total number of electric vehicles sold in 'California' in the 'sales' schema?", "context": "CREATE TABLE sales_regions (id INT, name VARCHAR(50));   CREATE TABLE sales (id INT, region_id INT, vehicle_count INT);   CREATE TABLE vehicles (id INT, type VARCHAR(50));   INSERT INTO sales_regions VALUES (1, 'California');   INSERT INTO sales VALUES (1, 1, 5000);   INSERT INTO vehicles VALUES (1, 'electric');", "reference_sql": "SELECT SUM(sales.vehicle_count) FROM sales INNER JOIN sales_regions ON sales.region_id = sales_regions.id INNER JOIN vehicles ON sales.id = vehicles.id WHERE vehicles.type = 'electric' AND sales_regions.name = 'California';", "generated_sql": "SELECT SUM(v.vehicle_count) AS total_electric_vehicles_sold\nFROM sales s\nJOIN sales_regions sr ON s.region_id = sr.id\nJOIN vehicles v ON v.id = s.id\nWHERE sr.name = 'California' AND v.type = 'electric';", "raw_model_output": "SELECT SUM(v.vehicle_count) AS total_electric_vehicles_sold\nFROM sales s\nJOIN sales_regions sr ON s.region_id = sr.id\nJOIN vehicles v ON v.id = s.id\nWHERE sr.name = 'California' AND v.type = 'electric';", "latency_sec": 0.6744260787963867, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 167, "prompt_eval_sec": null, "tokens_completion": 56, "completion_eval_sec": null, "tokens_total": 223, "tokens_per_sec": 330.6515080169743, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The generated SQL references 'v.vehicle_count' which does not exist in the schema (vehicles table only has 'id' and 'type'). The reference SQL correctly sums 'sales.vehicle_count'. This syntax error makes the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the total number of electric vehicles sold in California by joining the sales, sales_regions, and vehicles tables. The reference query uses explicit table names while the generated query uses aliases, but this does not affect the result. Both enforce the same logical conditions (vehicle type = 'electric' and region = 'California') and aggregate the vehicle_count column. The schema constraints (e.g., sales.id linking to vehicles.id) are respected in both queries. The generated query is slightly more concise with aliases but offers no performance advantage over the reference.", "overall_assessment": "correct"}}
{"example_id": 3999, "sql_complexity": "single join", "prompt": "What is the total number of tickets sold for performances with a rating of 5?", "context": "CREATE TABLE performance (id INT PRIMARY KEY, name VARCHAR(255), date DATE, artist_id INT, rating INT); INSERT INTO performance (id, name, date, artist_id, rating) VALUES (1, 'Dance Recital', '2022-03-01', 1, 5);", "reference_sql": "SELECT SUM(t.quantity) as total_tickets_sold FROM performance p INNER JOIN ticket t ON p.id = t.performance_id WHERE p.rating = 5;", "generated_sql": "SELECT COUNT(*) AS total_tickets_sold\nFROM performance\nWHERE rating = 5;", "raw_model_output": "SELECT COUNT(*) AS total_tickets_sold\nFROM performance\nWHERE rating = 5;", "latency_sec": 0.733834981918335, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 146, "prompt_eval_sec": null, "tokens_completion": 20, "completion_eval_sec": null, "tokens_total": 166, "tokens_per_sec": 226.20889449294933, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the total tickets sold (summing ticket quantities) for performances with a rating of 5, while the Generated SQL counts the number of performances with a rating of 5. They operate on different data (ticket quantities vs. performance counts) and would produce different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly joins the performance and ticket tables to sum ticket quantities for 5-star performances, while the generated query only counts the number of 5-star performances without accessing ticket data. The generated query fails to address the business intent of measuring 'tickets sold' and would return the count of performances rather than total tickets. The reference query is both technically correct and semantically aligned with the question.", "overall_assessment": "incorrect"}}
{"example_id": 2261, "sql_complexity": "multiple_joins", "prompt": "What is the total number of animals that have been released into 'protected' habitats, and the average weight of those animals?", "context": "CREATE TABLE habitats (habitat_id INT, habitat_name VARCHAR(50), habitat_status VARCHAR(50)); INSERT INTO habitats (habitat_id, habitat_name, habitat_status) VALUES (1, 'Habitat A', 'protected'), (2, 'Habitat B', 'unprotected'); CREATE TABLE animal_habitats (animal_id INT, habitat_id INT, animal_weight FLOAT); INSERT INTO animal_habitats (animal_id, habitat_id, animal_weight) VALUES (101, 1, 25.5), (102, 2, 15.2); CREATE TABLE animals (animal_id INT, animal_name VARCHAR(50)); INSERT INTO animals (animal_id, animal_name) VALUES (101, 'Dog'), (102, 'Cat');", "reference_sql": "SELECT COUNT(*), AVG(animal_habitats.animal_weight) FROM animal_habitats INNER JOIN animals ON animal_habitats.animal_id = animals.animal_id INNER JOIN habitats ON animal_habitats.habitat_id = habitats.habitat_id WHERE habitats.habitat_status = 'protected';", "generated_sql": "SELECT \n    COUNT(DISTINCT a.animal_id) AS total_animals_released,\n    AVG(ah.animal_weight) AS average_weight\nFROM \n    animals a\nJOIN \n    animal_habitats ah ON a.animal_id = ah.animal_id\nJOIN \n    habitats h ON ah.habitat_id = h.habitat_id\nWHERE \n    h.habitat_status = 'protected';", "raw_model_output": "SELECT \n    COUNT(DISTINCT a.animal_id) AS total_animals_released,\n    AVG(ah.animal_weight) AS average_weight\nFROM \n    animals a\nJOIN \n    animal_habitats ah ON a.animal_id = ah.animal_id\nJOIN \n    habitats h ON ah.habitat_id = h.habitat_id\nWHERE \n    h.habitat_status = 'protected';", "latency_sec": 0.8417000770568848, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 246, "prompt_eval_sec": null, "tokens_completion": 87, "completion_eval_sec": null, "tokens_total": 333, "tokens_per_sec": 395.62785970553597, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses COUNT(*) which counts all rows, while the Generated SQL uses COUNT(DISTINCT a.animal_id) which counts unique animal IDs. If there are multiple entries per animal in the joined result, these would produce different counts. The AVG() is equivalent since both use the same column and table alias.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries produce the same numerical results for the given schema and data. However, the generated query better fulfills the business intent by using COUNT(DISTINCT a.animal_id) which accurately counts unique animals released (as opposed to COUNT(*) which could overcount if animals were released multiple times). The generated query also uses explicit table aliases and clearer column qualification, making it more readable and maintainable. While both queries are technically correct, the generated version more precisely addresses the business requirement of counting individual animals rather than release events.", "overall_assessment": "differently_correct"}}
{"example_id": 3439, "sql_complexity": "multiple_joins", "prompt": "How many menu items contain ingredients sourced from local suppliers for each restaurant?", "context": "CREATE TABLE restaurants (id INT, name VARCHAR(50), location VARCHAR(50)); INSERT INTO restaurants VALUES (1, 'Restaurant A', 'City A'); INSERT INTO restaurants VALUES (2, 'Restaurant B', 'City B'); CREATE TABLE menu_items (id INT, name VARCHAR(50), restaurant_id INT, price DECIMAL(5,2)); INSERT INTO menu_items VALUES (1, 'Item A', 1, 10.99); INSERT INTO menu_items VALUES (2, 'Item B', 1, 12.99); INSERT INTO menu_items VALUES (3, 'Item C', 2, 11.99); CREATE TABLE ingredients (id INT, name VARCHAR(50), local_source BOOLEAN, menu_item_id INT); INSERT INTO ingredients VALUES (1, 'Ingredient A', TRUE, 1); INSERT INTO ingredients VALUES (2, 'Ingredient B', FALSE, 1); INSERT INTO ingredients VALUES (3, 'Ingredient C', TRUE, 2); INSERT INTO ingredients VALUES (4, 'Ingredient D', FALSE, 2); INSERT INTO ingredients VALUES (5, 'Ingredient E', TRUE, 3);", "reference_sql": "SELECT r.name, COUNT(DISTINCT mi.id) as num_local_items FROM restaurants r JOIN menu_items mi ON r.id = mi.restaurant_id JOIN ingredients i ON mi.id = i.menu_item_id WHERE i.local_source = TRUE GROUP BY r.name;", "generated_sql": "SELECT \n    r.name AS restaurant_name,\n    COUNT(DISTINCT mi.id) AS local_source_menu_items_count\nFROM \n    restaurants r\nJOIN \n    menu_items mi ON r.id = mi.restaurant_id\nJOIN \n    ingredients ing ON mi.id = ing.menu_item_id\nWHERE \n    ing.local_source = TRUE\nGROUP BY \n    r.id, r.name;", "raw_model_output": "SELECT \n    r.name AS restaurant_name,\n    COUNT(DISTINCT mi.id) AS local_source_menu_items_count\nFROM \n    restaurants r\nJOIN \n    menu_items mi ON r.id = mi.restaurant_id\nJOIN \n    ingredients ing ON mi.id = ing.menu_item_id\nWHERE \n    ing.local_source = TRUE\nGROUP BY \n    r.id, r.name;", "latency_sec": 1.0582149028778076, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 314, "prompt_eval_sec": null, "tokens_completion": 78, "completion_eval_sec": null, "tokens_total": 392, "tokens_per_sec": 370.4351535155656, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count distinct menu items with local ingredients per restaurant. The Reference query groups by r.name, while the Generated query groups by r.id and r.name. Since the restaurants table has unique id values and the sample data has unique names, both grouping strategies produce identical results. The column aliases differ but do not affect the semantic output.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count menu items with local ingredients per restaurant. The reference query groups by 'r.name' while the generated query groups by 'r.id, r.name'. Technically, they are equivalent in this dataset because restaurant names are unique. However, the generated query is more robust as grouping by primary key (id) ensures reliability in databases enforcing strict grouping rules. Both fulfill the business intent, but the generated query's approach is more precise and avoids potential issues with duplicate restaurant names. The generated query also uses explicit column aliases, enhancing readability without affecting functionality.", "overall_assessment": "correct"}}
{"example_id": 2265, "sql_complexity": "aggregation", "prompt": "Hourly revenue for a specific movie?", "context": "CREATE TABLE Movie_Revenue (id INT, movie_title VARCHAR(100), revenue_time TIME, revenue DECIMAL(10,2));", "reference_sql": "SELECT revenue_time, SUM(revenue) FROM Movie_Revenue WHERE movie_title = 'Spider-Man: No Way Home' GROUP BY revenue_time;", "generated_sql": "SELECT \n    movie_title, \n    revenue_time, \n    revenue\nFROM \n    Movie_Revenue\nWHERE \n    movie_title = 'specific movie';", "raw_model_output": "SELECT \n    movie_title, \n    revenue_time, \n    revenue\nFROM \n    Movie_Revenue\nWHERE \n    movie_title = 'specific movie';", "latency_sec": 0.5141980648040771, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 101, "prompt_eval_sec": null, "tokens_completion": 33, "completion_eval_sec": null, "tokens_total": 134, "tokens_per_sec": 260.59996949046763, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL aggregates revenue by revenue_time using SUM() and excludes movie_title from the output, while the Generated SQL selects individual revenue values without aggregation and includes movie_title in the output. The grouping, aggregation, and selected columns differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly groups revenue by time and aggregates it to calculate hourly revenue, which directly addresses the business intent. The generated query lacks aggregation and returns raw rows without summarizing revenue, failing to answer the question. Additionally, the generated query uses a literal 'specific movie' instead of a parameterized value, making it less flexible. The reference query is both technically correct and semantically aligned with the business requirement.", "overall_assessment": "incorrect"}}
{"example_id": 1763, "sql_complexity": "multiple_joins", "prompt": "What is the total food and beverage revenue last month for hotels in 'Bangkok'?", "context": "CREATE TABLE revenue (hotel_id INT, revenue_source VARCHAR(50), revenue INT, revenue_date DATE); INSERT INTO revenue (hotel_id, revenue_source, revenue, revenue_date) VALUES (5, 'Room revenue', 12000, '2022-03-01'), (5, 'Food and beverage', 4000, '2022-03-02'), (5, 'Other revenue', 1000, '2022-03-03'); CREATE TABLE hotels (hotel_id INT, city VARCHAR(50)); INSERT INTO hotels (hotel_id, city) VALUES (5, 'Bangkok'); CREATE TABLE dates (date DATE); INSERT INTO dates (date) VALUES ('2022-03-01'), ('2022-03-02'), ('2022-03-03');", "reference_sql": "SELECT SUM(revenue) FROM revenue JOIN hotels ON revenue.hotel_id = hotels.hotel_id JOIN dates ON revenue.revenue_date = dates.date WHERE hotels.city = 'Bangkok' AND revenue_source = 'Food and beverage' AND dates.date >= DATEADD(month, -1, GETDATE());", "generated_sql": "SELECT SUM(r.revenue) AS total_food_and_beverage_revenue_last_month\nFROM revenue r\nJOIN hotels h ON r.hotel_id = h.hotel_id\nWHERE r.revenue_source = 'Food and beverage'\n  AND h.city = 'Bangkok'\n  AND r.revenue_date >= DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month')\n  AND r.revenue_date < DATE_TRUNC('month', CURRENT_DATE);", "raw_model_output": "SELECT SUM(r.revenue) AS total_food_and_beverage_revenue_last_month\nFROM revenue r\nJOIN hotels h ON r.hotel_id = h.hotel_id\nWHERE r.revenue_source = 'Food and beverage'\n  AND h.city = 'Bangkok'\n  AND r.revenue_date >= DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month')\n  AND r.revenue_date < DATE_TRUNC('month', CURRENT_DATE);", "latency_sec": 0.9007601737976074, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 248, "prompt_eval_sec": null, "tokens_completion": 92, "completion_eval_sec": null, "tokens_total": 340, "tokens_per_sec": 377.45896176399435, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses DATEADD(month, -1, GETDATE()) to filter dates >= one month before the current date, while the Generated SQL uses DATE_TRUNC to capture the entire previous month. This means the Reference SQL includes dates from a specific point in time (e.g., 2023-09-15) onward, whereas the Generated SQL includes all dates in the full previous month (e.g., 2023-09-01 to 2023-09-30). These conditions are not equivalent, as they cover different date ranges.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in their date filtering logic. The Reference SQL uses DATEADD(month, -1, GETDATE()) which calculates the same day of the previous month (e.g., March 5th if today is April 5th), but the sample data's dates are March 1-3, which would be excluded. The Generated SQL correctly uses DATE_TRUNC to capture the entire previous month (March 1st to March 31st). The Reference also unnecessarily joins with the dates table, which is redundant since revenue_date is already in the revenue table. The Generated SQL more accurately captures last month's data and avoids unnecessary joins.", "overall_assessment": "differently_correct"}}
{"example_id": 5499, "sql_complexity": "set operations", "prompt": "How many legal aid clinics and community mediation centers are there in total, and what is the sum of cases handled by each type of center, for centers located in the state of California?", "context": "CREATE TABLE LegalAidClinics (ClinicName text, State text, NumCases int); INSERT INTO LegalAidClinics VALUES ('Clinic1', 'CA', 30, '2022-01-01'), ('Clinic2', 'CA', 25, '2022-01-01'); CREATE TABLE CommunityMediationCenters (CenterName text, State text, NumCases int); INSERT INTO CommunityMediationCenters VALUES ('CM1', 'CA', 22, '2022-01-01'), ('CM2', 'CA', 28, '2022-01-01');", "reference_sql": "SELECT State, 'Legal Aid Clinics' AS CenterType, COUNT(*) AS NumCenters, SUM(NumCases) AS TotalCases FROM LegalAidClinics WHERE State = 'CA' UNION ALL SELECT State, 'Community Mediation Centers', COUNT(*), SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA';", "generated_sql": "SELECT \n  (SELECT COUNT(*) FROM LegalAidClinics WHERE State = 'CA') AS TotalLegalAidClinics,\n  (SELECT COUNT(*) FROM CommunityMediationCenters WHERE State = 'CA') AS TotalMediationCenters,\n  (SELECT SUM(NumCases) FROM LegalAidClinics WHERE State = 'CA') AS SumCasesLegalAid,\n  (SELECT SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA') AS SumCasesMediation;", "raw_model_output": "SELECT \n  (SELECT COUNT(*) FROM LegalAidClinics WHERE State = 'CA') AS TotalLegalAidClinics,\n  (SELECT COUNT(*) FROM CommunityMediationCenters WHERE State = 'CA') AS TotalMediationCenters,\n  (SELECT SUM(NumCases) FROM LegalAidClinics WHERE State = 'CA') AS SumCasesLegalAid,\n  (SELECT SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA') AS SumCasesMediation;", "latency_sec": 1.2528667449951172, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 226, "prompt_eval_sec": null, "tokens_completion": 98, "completion_eval_sec": null, "tokens_total": 324, "tokens_per_sec": 258.6069119435864, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL returns two rows (one for each center type) with columns State, CenterType, NumCenters, TotalCases, while the Generated SQL returns a single row with four separate columns for counts and sums. The structure and number of rows differ, leading to different result formats.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The Reference SQL and Generated SQL differ structurally. The Reference uses UNION ALL to combine two rows (one for each center type) with columns: State, CenterType, NumCenters, TotalCases. The Generated SQL returns a single row with four separate columns for counts and sums. While both correctly filter by 'CA' and calculate the required metrics, the Reference's output format directly matches the question's request for 'total' numbers and 'sum of cases handled by each type' in a structured format. The Generated SQL, though technically correct, presents data in a denormalized format that requires additional processing to interpret. The Reference better preserves semantic clarity for business reporting.", "overall_assessment": "differently_correct"}}
{"example_id": 2408, "sql_complexity": "aggregation", "prompt": "What is the average number of victories for players from Japan and South Korea, partitioned by game mode?", "context": "CREATE TABLE PlayerVictories (PlayerID INT, GameMode VARCHAR(255), Victories INT, Country VARCHAR(255)); INSERT INTO PlayerVictories (PlayerID, GameMode, Victories, Country) VALUES (1, 'Battle Royale', 25, 'Japan'), (2, 'Team Deathmatch', 18, 'South Korea');", "reference_sql": "SELECT GameMode, AVG(Victories) as AvgVictories FROM PlayerVictories WHERE Country IN ('Japan', 'South Korea') GROUP BY GameMode, Country WITH ROLLUP;", "generated_sql": "SELECT \n    GameMode,\n    AVG(Victories) AS AverageVictories,\n    Country\nFROM \n    PlayerVictories\nWHERE \n    Country IN ('Japan', 'South Korea')\nGROUP BY \n    GameMode,\n    Country;", "raw_model_output": "SELECT \n    GameMode,\n    AVG(Victories) AS AverageVictories,\n    Country\nFROM \n    PlayerVictories\nWHERE \n    Country IN ('Japan', 'South Korea')\nGROUP BY \n    GameMode,\n    Country;", "latency_sec": 0.7055292129516602, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 159, "prompt_eval_sec": null, "tokens_completion": 50, "completion_eval_sec": null, "tokens_total": 209, "tokens_per_sec": 296.2315325337489, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes 'WITH ROLLUP' which adds summary rows for aggregations, while the Generated SQL does not. Additionally, the Generated SQL includes 'Country' in the SELECT clause, whereas the Reference SQL does not. These differences in grouping, aggregation, and selected columns make the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query groups by both GameMode and Country, which creates subtotals for each country within each game mode. This does not align with the original question's requirement to 'partition by game mode' (implying a single-level grouping on GameMode). The generated query also groups by GameMode and Country, but without the ROLLUP clause, making it slightly more focused. However, neither query correctly groups by GameMode alone, which would be necessary to calculate the average victories across all players from Japan and South Korea per game mode. The ROLLUP in the reference query adds an unnecessary grand total row not requested in the question. While the generated query is simpler, both fail to fully address the business intent due to incorrect grouping.", "overall_assessment": "differently_correct"}}
{"example_id": 2729, "sql_complexity": "subqueries", "prompt": "Find the total number of trips made by shared autonomous vehicles in Seattle", "context": "CREATE TABLE shared_vehicles (id INT, vehicle_type VARCHAR(20), is_autonomous BOOLEAN, trip_count INT); INSERT INTO shared_vehicles (id, vehicle_type, is_autonomous, trip_count) VALUES (1, 'ebike', false, 1200), (2, 'escooter', false, 800), (3, 'car', true, 1500); CREATE TABLE city_data (city VARCHAR(20), has_autonomous_vehicles BOOLEAN); INSERT INTO city_data (city, has_autonomous_vehicles) VALUES ('Seattle', true), ('Denver', false), ('Portland', true);", "reference_sql": "SELECT SUM(trip_count) FROM shared_vehicles WHERE is_autonomous = true AND vehicle_type != 'ebike' AND vehicle_type != 'escooter' AND city IN (SELECT city FROM city_data WHERE has_autonomous_vehicles = true AND city = 'Seattle');", "generated_sql": "SELECT SUM(trip_count) AS total_trips\nFROM shared_vehicles\nWHERE is_autonomous = TRUE\n  AND id IN (\n    SELECT id FROM shared_vehicles\n    WHERE vehicle_type = 'car'\n  )\n  AND id IN (\n    SELECT id FROM shared_vehicles\n    WHERE id IN (\n      SELECT id FROM shared_vehicles\n    )\n  );", "raw_model_output": "SELECT SUM(trip_count) AS total_trips\nFROM shared_vehicles\nWHERE is_autonomous = TRUE\n  AND id IN (\n    SELECT id FROM shared_vehicles\n    WHERE vehicle_type = 'car'\n  )\n  AND id IN (\n    SELECT id FROM shared_vehicles\n    WHERE id IN (\n      SELECT id FROM shared_vehicles\n    )\n  );", "latency_sec": 0.8465659618377686, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 208, "prompt_eval_sec": null, "tokens_completion": 77, "completion_eval_sec": null, "tokens_total": 285, "tokens_per_sec": 336.6542157935425, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references a 'city' column in shared_vehicles, which does not exist in the provided schema. The Generated SQL uses valid conditions but focuses on vehicle_type='car' and redundant ID checks. The Reference SQL's city filter (invalid due to schema mismatch) and additional vehicle_type exclusions make them non-equivalent. Even if the schema were corrected, the city condition in Reference SQL would add constraints not present in the Generated SQL.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query contains a critical technical error: it references a 'city' column in the shared_vehicles table, which does not exist in the schema. This makes the reference query invalid. The generated query is syntactically correct but fails to address the city filter entirely. While the generated query correctly identifies autonomous 'car' vehicles (which matches the sample data), it ignores the Seattle requirement. The reference query's intent to filter by Seattle is present but unachievable due to schema limitations. The generated query is more technically sound but still incomplete. Neither query fully meets the business intent, but the generated query is structurally superior.", "overall_assessment": "differently_correct"}}
{"example_id": 2952, "sql_complexity": "aggregation", "prompt": "Show the total budget allocated for each program category in 2023.", "context": "CREATE TABLE Budget (id INT, category TEXT, year INT, allocated_amount INT); INSERT INTO Budget (id, category, year, allocated_amount) VALUES (1, 'Education', 2023, 30000); INSERT INTO Budget (id, category, year, allocated_amount) VALUES (2, 'Healthcare', 2023, 50000);", "reference_sql": "SELECT category, SUM(allocated_amount) FROM Budget WHERE year = 2023 GROUP BY category;", "generated_sql": "SELECT category, SUM(allocated_amount) AS total_budget\nFROM Budget\nWHERE year = 2023\nGROUP BY category;", "raw_model_output": "SELECT category, SUM(allocated_amount) AS total_budget\nFROM Budget\nWHERE year = 2023\nGROUP BY category;", "latency_sec": 0.8344321250915527, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 154, "prompt_eval_sec": null, "tokens_completion": 27, "completion_eval_sec": null, "tokens_total": 181, "tokens_per_sec": 216.9139880372426, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (category and summed allocated_amount) from the Budget table where year is 2023, grouped by category. The only difference is the alias 'total_budget' in the generated query, which doesn't affect the semantic meaning of the result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically correct and produce identical results. The reference query is functionally equivalent to the generated query, as they both filter for 2023, group by category, and calculate the sum of allocated amounts. The generated query improves on elegance by explicitly naming the aggregated column as 'total_budget', which enhances readability without altering the semantic meaning. While both fulfill the business intent of showing total budgets per category, the generated query's alias makes the output more self-explanatory.", "overall_assessment": "correct"}}
{"example_id": 4328, "sql_complexity": "aggregation", "prompt": "What is the average cargo handling time in hours for each port?", "context": "CREATE TABLE cargo_handling (id INT, port_id INT, time_in_hours DECIMAL(5,2)); INSERT INTO cargo_handling (id, port_id, time_in_hours) VALUES (1, 1, 20.5), (2, 1, 22.3), (3, 2, 18.7);", "reference_sql": "SELECT port_id, AVG(time_in_hours) FROM cargo_handling GROUP BY port_id;", "generated_sql": "SELECT port_id, AVG(time_in_hours) AS average_time_in_hours\nFROM cargo_handling\nGROUP BY port_id;", "raw_model_output": "SELECT port_id, AVG(time_in_hours) AS average_time_in_hours\nFROM cargo_handling\nGROUP BY port_id;", "latency_sec": 0.5214829444885254, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 152, "prompt_eval_sec": null, "tokens_completion": 26, "completion_eval_sec": null, "tokens_total": 178, "tokens_per_sec": 341.33426966548984, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average time_in_hours per port_id. The generated query adds an alias (average_time_in_hours) for the computed column, but this does not affect the semantic result. The GROUP BY clause and aggregate function remain identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the average cargo handling time per port using GROUP BY port_id. The reference query omits an explicit column alias, while the generated query adds AS average_time_in_hours. This difference doesn't affect result accuracy but makes the generated query more readable by explicitly naming the calculated column. Both satisfy the business requirement of showing average handling times per port.", "overall_assessment": "correct"}}
{"example_id": 4915, "sql_complexity": "window functions", "prompt": "Calculate the percentage of total Europium production for each country.", "context": "CREATE TABLE europium_production (country VARCHAR(50), quantity INT);", "reference_sql": "SELECT country, quantity * 100.0 / SUM(quantity) OVER (PARTITION BY NULL) AS percentage FROM europium_production;", "generated_sql": "SELECT \n    country,\n    (quantity * 100.0) / (SELECT SUM(quantity) FROM europium_production) AS percentage_of_total\nFROM \n    europium_production;", "raw_model_output": "SELECT \n    country,\n    (quantity * 100.0) / (SELECT SUM(quantity) FROM europium_production) AS percentage_of_total\nFROM \n    europium_production;", "latency_sec": 0.5762350559234619, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 94, "prompt_eval_sec": null, "tokens_completion": 40, "completion_eval_sec": null, "tokens_total": 134, "tokens_per_sec": 232.54399159255328, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the percentage of each country's production relative to the total production. The reference query uses a window function SUM(quantity) OVER (PARTITION BY NULL) to get the total, while the generated query uses a subquery (SELECT SUM(quantity) FROM europium_production). Both approaches correctly compute the same percentage value by dividing each row's quantity by the total sum.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the percentage of total Europium production per country. The reference query uses a window function (SUM(quantity) OVER (PARTITION BY NULL)) to compute the total, while the generated query uses a scalar subquery (SELECT SUM(quantity) FROM ...). Both approaches are mathematically equivalent and produce identical results. The reference query may be more efficient in some databases due to window function optimization, but the generated query is equally valid. Neither query handles edge cases like division by zero, but this is not addressed in the original question. Both fulfill the business intent of calculating country-specific production percentages.", "overall_assessment": "correct"}}
{"example_id": 5030, "sql_complexity": "subqueries", "prompt": "What is the success rate of diverse-led startups (at least 1 female or underrepresented racial or ethnic group executive) in the past 3 years?", "context": "CREATE TABLE DiverseStartups(id INT, name TEXT, country TEXT, year INT, success BOOLEAN);   INSERT INTO DiverseStartups VALUES (1, 'FemTech', 'USA', 2020, true), (2, 'GreenCity', 'Canada', 2019, false), (3, 'AI-Health', 'UK', 2021, true), (4, 'SolarEnergy', 'USA', 2020, false), (5, 'DataAnalytics', 'Germany', 2019, true), (6, 'SmartGrid', 'USA', 2021, true), (7, 'CloudServices', 'India', 2020, false), (8, 'RenewableEnergy', 'USA', 2019, true);", "reference_sql": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3) AS success_rate FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3 AND success = true;", "generated_sql": "SELECT \n    (SUM(CASE WHEN success = TRUE THEN 1 ELSE 0 END) * 100.0) / COUNT(*) AS success_rate_percentage\nFROM \n    DiverseStartups\nWHERE \n    year >= (EXTRACT(YEAR FROM CURRENT_DATE) - 3);", "raw_model_output": "SELECT \n    (SUM(CASE WHEN success = TRUE THEN 1 ELSE 0 END) * 100.0) / COUNT(*) AS success_rate_percentage\nFROM \n    DiverseStartups\nWHERE \n    year >= (EXTRACT(YEAR FROM CURRENT_DATE) - 3);", "latency_sec": 0.6959118843078613, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 255, "prompt_eval_sec": null, "tokens_completion": 59, "completion_eval_sec": null, "tokens_total": 314, "tokens_per_sec": 451.2065493928121, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the success rate percentage of startups in the last three years. The Reference SQL uses a subquery to get the total count and multiplies by 100.0, while the Generated SQL uses SUM(CASE) to count successes and divides by COUNT(*) directly. The WHERE conditions (year >= YEAR(CURRENT_DATE) - 3) are equivalent, and both compute (success_count / total_count) * 100.0.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries calculate the success rate of diverse-led startups in the past 3 years by filtering the correct time frame and computing the ratio of successful entries. The reference query uses a subquery to calculate the denominator, while the generated query uses a single scan with conditional aggregation. Both handle edge cases (e.g., division by zero) similarly. The generated query is more efficient and elegant by avoiding a subquery and using explicit aggregation. The business intent is fully addressed by both, but the generated query is structurally superior.", "overall_assessment": "correct"}}
{"example_id": 4626, "sql_complexity": "aggregation", "prompt": "What was the maximum number of training hours for farmers in each country in 2020?", "context": "CREATE TABLE training (id INT, country_id INT, farmer_id INT, hours INT, date DATE);", "reference_sql": "SELECT country_id, MAX(hours) FROM training WHERE YEAR(date) = 2020 GROUP BY country_id;", "generated_sql": "SELECT country_id, MAX(hours) AS max_hours\nFROM training\nWHERE YEAR(date) = 2020\nGROUP BY country_id;", "raw_model_output": "SELECT country_id, MAX(hours) AS max_hours\nFROM training\nWHERE YEAR(date) = 2020\nGROUP BY country_id;", "latency_sec": 0.46986985206604004, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 106, "prompt_eval_sec": null, "tokens_completion": 29, "completion_eval_sec": null, "tokens_total": 135, "tokens_per_sec": 287.3136027059378, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. The only difference is that the generated query explicitly aliases the MAX(hours) column as 'max_hours', while the reference query omits the alias. Both queries select the same data: country_id and maximum hours for training records in 2020, grouped by country_id.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically correct and produce identical results. They both filter training records for 2020, group by country_id, and calculate maximum hours. The generated query improves upon the reference by adding an explicit alias (max_hours) for the calculated column, enhancing readability and clarity without altering functionality. This makes the generated query more elegant while fully addressing the business intent of identifying maximum training hours per country.", "overall_assessment": "correct"}}
{"example_id": 2703, "sql_complexity": "set operations", "prompt": "Identify the species unique to 'MarineResearchAreaA' and 'MarineResearchAreaB'", "context": "CREATE TABLE ResearchAreaSpecies (area VARCHAR(255), species VARCHAR(255)); INSERT INTO ResearchAreaSpecies (area, species) VALUES ('MarineResearchAreaA', 'Coral'), ('MarineResearchAreaA', 'Starfish'), ('MarineResearchAreaB', 'Jellyfish');", "reference_sql": "(SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB') UNION (SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA');", "generated_sql": "SELECT species\nFROM ResearchAreaSpecies\nGROUP BY species\nHAVING COUNT(DISTINCT area) = 1\n   AND species IN (\n       SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA'\n       UNION\n       SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB'\n   )\n   AND species IN (\n       SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA'\n       INTERSECT\n       SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB'\n   );", "raw_model_output": "SELECT species\nFROM ResearchAreaSpecies\nGROUP BY species\nHAVING COUNT(DISTINCT area) = 1\n   AND species IN (\n       SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA'\n       UNION\n       SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB'\n   )\n   AND species IN (\n       SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA'\n       INTERSECT\n       SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB'\n   );", "latency_sec": 1.00291109085083, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 143, "prompt_eval_sec": null, "tokens_completion": 111, "completion_eval_sec": null, "tokens_total": 254, "tokens_per_sec": 253.26272918620978, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query computes the symmetric difference between species in 'MarineResearchAreaA' and 'MarineResearchAreaB' (species present in one area but not the other). The generated query attempts to find species present in exactly one area (COUNT(DISTINCT area) = 1) but also requires those species to be in the intersection of both areas (which is impossible since intersection implies presence in both areas). This contradiction makes the generated query return no results, while the reference query returns all species unique to each area. Thus, they are not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query correctly identifies species unique to each area using EXCEPT (which finds set differences) and combines results with UNION. The generated query contains logical contradictions: the HAVING clause requires species to be in both areas (via INTERSECT) while also being in only one area (COUNT(DISTINCT area) = 1), making it impossible to return any results. The reference query is both technically correct and semantically aligned with the business intent of finding exclusive species per area.", "overall_assessment": "correct"}}
{"example_id": 200, "sql_complexity": "window functions", "prompt": "List the top three categories of workforce development programs with the highest budget increases.", "context": "CREATE TABLE programs (program_id INT, program_name VARCHAR(50), budget DECIMAL(10, 2), category VARCHAR(50), budget_date DATE);", "reference_sql": "SELECT category, SUM(budget - LAG(budget) OVER (PARTITION BY category ORDER BY budget_date)) as total_budget_increase FROM programs GROUP BY category ORDER BY total_budget_increase DESC LIMIT 3;", "generated_sql": "SELECT category, \n       (MAX(budget) - MIN(budget)) AS budget_increase\nFROM programs\nGROUP BY category\nORDER BY budget_increase DESC\nLIMIT 3;", "raw_model_output": "SELECT category, \n       (MAX(budget) - MIN(budget)) AS budget_increase\nFROM programs\nGROUP BY category\nORDER BY budget_increase DESC\nLIMIT 3;", "latency_sec": 0.8514413833618164, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 114, "prompt_eval_sec": null, "tokens_completion": 39, "completion_eval_sec": null, "tokens_total": 153, "tokens_per_sec": 179.69528259936985, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query calculates the sum of consecutive budget differences within each category (equivalent to last budget - first budget when ordered by date), while the generated query uses MAX(budget) - MIN(budget). These values differ when there are fluctuations in budget values over time (e.g., 100, 300, 200: reference sum is 100, generated value is 200).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent. The Reference SQL calculates the total budget increase by summing consecutive differences (current - previous) within each category, which mathematically equals the final budget minus the initial budget. The Generated SQL calculates the maximum possible increase (MAX(budget) - MIN(budget)). While both approaches measure 'budget increase,' they differ in interpretation: the Reference SQL captures cumulative changes over time, while the Generated SQL reflects the peak-to-trough range. The original question's ambiguity about 'budget increases' (total vs. maximum) affects interpretation, but the Reference SQL better aligns with the intent of tracking actual budget growth over time, assuming the data is ordered by budget_date. The Generated SQL is simpler but may overstate increases if budgets fluctuate.", "overall_assessment": "differently_correct"}}
{"example_id": 5131, "sql_complexity": "basic SQL", "prompt": "How many wells were drilled in the Eagle Ford Shale and Bakken Formation?", "context": "CREATE TABLE wells (id INT, region VARCHAR(255), well_type VARCHAR(255), num_drilled INT); INSERT INTO wells (id, region, well_type, num_drilled) VALUES (1, 'Eagle Ford Shale', 'Oil', 2000), (2, 'Eagle Ford Shale', 'Gas', 1500), (3, 'Bakken Formation', 'Oil', 1000), (4, 'Bakken Formation', 'Gas', 1200);", "reference_sql": "SELECT SUM(num_drilled) as total_wells FROM wells WHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "generated_sql": "SELECT SUM(num_drilled) AS total_wells_drilled\nFROM wells\nWHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "raw_model_output": "SELECT SUM(num_drilled) AS total_wells_drilled\nFROM wells\nWHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "latency_sec": 0.7470710277557373, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 186, "prompt_eval_sec": null, "tokens_completion": 32, "completion_eval_sec": null, "tokens_total": 218, "tokens_per_sec": 291.8062565682541, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of num_drilled for wells in the specified regions. The only differences are the column alias name (total_wells vs. total_wells_drilled) and formatting, which do not affect the semantic result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically identical except for the alias name ('total_wells' vs 'total_wells_drilled'). The WHERE clause correctly filters for the specified regions, and the SUM operation accurately aggregates the num_drilled values. The business intent to count total wells drilled in the two formations is fulfilled equally by both queries. The alias difference is a stylistic choice with no impact on results or functionality.", "overall_assessment": "correct"}}
{"example_id": 1160, "sql_complexity": "subqueries", "prompt": "What is the total revenue generated from ads on Instagram in March 2021, for users in the 'brand' category who have posted more than 10 times?", "context": "CREATE TABLE ads (ad_id INT, user_id INT, platform VARCHAR(255), ad_revenue DECIMAL(10,2), post_count INT); INSERT INTO ads (ad_id, user_id, platform, ad_revenue, post_count) VALUES (1, 1, 'Instagram', 150.50, 12), (2, 2, 'Twitter', 80.00, 15), (3, 3, 'Instagram', 120.75, 8);", "reference_sql": "SELECT SUM(ad_revenue) FROM ads WHERE platform = 'Instagram' AND MONTH(ad_date) = 3 AND YEAR(ad_date) = 2021 AND user_id IN (SELECT user_id FROM users WHERE category = 'brand' AND post_count > 10);", "generated_sql": "SELECT SUM(ad_revenue) AS total_revenue\nFROM ads\nWHERE platform = 'Instagram'\n  AND post_count > 10;", "raw_model_output": "SELECT SUM(ad_revenue) AS total_revenue\nFROM ads\nWHERE platform = 'Instagram'\n  AND post_count > 10;", "latency_sec": 0.5823509693145752, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 202, "prompt_eval_sec": null, "tokens_completion": 29, "completion_eval_sec": null, "tokens_total": 231, "tokens_per_sec": 396.6680097946537, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL includes additional conditions: filtering by ad_date (MONTH(ad_date) = 3 and YEAR(ad_date) = 2021) and restricting user_id to those in the 'users' table with category 'brand' and post_count > 10. The Generated SQL omits these conditions and uses a different post_count column (from ads instead of users).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL contains two critical errors: 1) It references an 'ad_date' column that doesn't exist in the provided schema (ads table only has ad_id, user_id, platform, ad_revenue, post_count), and 2) It references a 'users' table that isn't defined in the context. The Generated SQL is technically valid (no syntax errors) but fails to address key requirements: it omits the date filter (March 2021), the 'brand' category filter, and the user_id subquery. While the Generated SQL is more syntactically correct, neither query fully meets the business intent. However, the Generated SQL's structure is valid and could be corrected with additional filters, whereas the Reference SQL is fundamentally flawed.", "overall_assessment": "incorrect"}}
{"example_id": 4708, "sql_complexity": "subqueries", "prompt": "What is the maximum number of high-level threats reported by a single agency in a month?", "context": "CREATE TABLE Threat_Intelligence (Threat_ID INT, Threat_Type VARCHAR(50), Threat_Level VARCHAR(50), Reported_Date DATE, Reporting_Agency VARCHAR(50)); CREATE VIEW High_Level_Threats AS SELECT Threat_Type, Threat_Level, Reported_Date FROM Threat_Intelligence WHERE Threat_Level = 'High';", "reference_sql": "SELECT Reporting_Agency, MAX(Number_of_High_Level_Threats) as Max_High_Level_Threats_in_a_Month FROM (SELECT Reporting_Agency, TO_CHAR(Reported_Date, 'YYYY-MM') as Month, COUNT(*) as Number_of_High_Level_Threats FROM High_Level_Threats GROUP BY Reporting_Agency, Month) GROUP BY Reporting_Agency;", "generated_sql": "SELECT MAX(Threat_Count) AS Max_High_Level_Threats_Per_Agency_Per_Month\nFROM (\n    SELECT Reporting_Agency, \n           EXTRACT(YEAR FROM Reported_Date) AS Year,\n           EXTRACT(MONTH FROM Reported_Date) AS Month,\n           COUNT(*) AS Threat_Count\n    FROM Threat_Intelligence\n    WHERE Threat_Level = 'High'\n    GROUP BY Reporting_Agency, Year, Month\n) AS Monthly_Threats;", "raw_model_output": "SELECT MAX(Threat_Count) AS Max_High_Level_Threats_Per_Agency_Per_Month\nFROM (\n    SELECT Reporting_Agency, \n           EXTRACT(YEAR FROM Reported_Date) AS Year,\n           EXTRACT(MONTH FROM Reported_Date) AS Month,\n           COUNT(*) AS Threat_Count\n    FROM Threat_Intelligence\n    WHERE Threat_Level = 'High'\n    GROUP BY Reporting_Agency, Year, Month\n) AS Monthly_Threats;", "latency_sec": 1.0990791320800781, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 148, "prompt_eval_sec": null, "tokens_completion": 97, "completion_eval_sec": null, "tokens_total": 245, "tokens_per_sec": 222.9138856783876, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their aggregation structure. The reference query groups by Reporting_Agency and returns the maximum monthly count per agency, while the generated query calculates a single maximum value across all agencies and months. Additionally, the date formatting approach differs (TO_CHAR vs EXTRACT) but this is secondary to the aggregation structure difference.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL groups by Reporting_Agency and calculates MAX(Number_of_High_Level_Threats) per agency, but the original question requires the absolute maximum across all agencies. The Generated SQL correctly computes the maximum Threat_Count from all agency-month combinations. The Reference SQL's structure would return multiple rows (one per agency) with their individual maxima, while the Generated SQL returns a single value. The Generated SQL also avoids the High_Level_Threats view, directly filtering on Threat_Level = 'High' in the main query, which is more efficient.", "overall_assessment": "incorrect"}}
{"example_id": 5608, "sql_complexity": "set operations", "prompt": "List the suppliers that provide materials for both product A and product C.", "context": "CREATE TABLE products (product_id INT, product_name TEXT); CREATE TABLE materials (material_id INT, material_name TEXT, product_id INT, supplier_id INT); INSERT INTO products (product_id, product_name) VALUES (1, 'Product A'), (2, 'Product B'), (3, 'Product C'); INSERT INTO materials (material_id, material_name, product_id, supplier_id) VALUES (1, 'Material 1', 1, 101), (2, 'Material 2', 1, 102), (3, 'Material 3', 2, 103), (4, 'Material 4', 3, 101), (5, 'Material 5', 3, 102);", "reference_sql": "SELECT supplier_id FROM materials WHERE product_id = 1 INTERSECT SELECT supplier_id FROM materials WHERE product_id = 3;", "generated_sql": "SELECT DISTINCT m1.supplier_id\nFROM materials m1\nJOIN materials m2 ON m1.supplier_id = m2.supplier_id\nWHERE m1.product_id = (SELECT product_id FROM products WHERE product_name = 'Product A')\n  AND m2.product_id = (SELECT product_id FROM products WHERE product_name = 'Product C');", "raw_model_output": "SELECT DISTINCT m1.supplier_id\nFROM materials m1\nJOIN materials m2 ON m1.supplier_id = m2.supplier_id\nWHERE m1.product_id = (SELECT product_id FROM products WHERE product_name = 'Product A')\n  AND m2.product_id = (SELECT product_id FROM products WHERE product_name = 'Product C');", "latency_sec": 0.8182830810546875, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 232, "prompt_eval_sec": null, "tokens_completion": 72, "completion_eval_sec": null, "tokens_total": 304, "tokens_per_sec": 371.50957540045124, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve supplier_ids that are common between product_id 1 (Product A) and product_id 3 (Product C). The Reference SQL uses INTERSECT to find common supplier_ids directly, while the Generated SQL uses a JOIN on supplier_id with DISTINCT to achieve the same result. The sample data shows both would return [101, 102].", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries correctly identify suppliers providing materials for both Product A and Product C. The Reference query uses INTERSECT, which is semantically precise for finding common supplier_ids between two sets. The Generated query achieves the same result through a self-join with DISTINCT, which also works but is less efficient. While both are technically correct, the Reference query is more elegant and directly expresses the set-based nature of the problem. The Generated query's use of subqueries to resolve product names adds unnecessary complexity compared to the Reference's direct product_id filtering.", "overall_assessment": "correct"}}
{"example_id": 1506, "sql_complexity": "basic SQL", "prompt": "How many habitats are in the 'animal_habitats' table?", "context": "CREATE TABLE animal_habitats (id INT PRIMARY KEY, habitat_name VARCHAR, num_animals INT);", "reference_sql": "SELECT COUNT(*) FROM animal_habitats;", "generated_sql": "SELECT COUNT(*) AS total_habitats FROM animal_habitats;", "raw_model_output": "SELECT COUNT(*) AS total_habitats FROM animal_habitats;", "latency_sec": 0.4239523410797119, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 102, "prompt_eval_sec": null, "tokens_completion": 15, "completion_eval_sec": null, "tokens_total": 117, "tokens_per_sec": 275.97441661019525, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries return the same numeric count of rows from the animal_habitats table. The generated query adds an alias (total_habitats) for the column name, but this does not affect the actual value returned by the COUNT(*) aggregation.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly count the number of rows in the 'animal_habitats' table. The reference query uses the minimal syntax (SELECT COUNT(*)), while the generated query adds an alias (AS total_habitats). The alias does not affect the result but improves readability. Since the original question only asks for the count, both satisfy the business intent equally. Neither query is more efficient than the other, and the difference in syntax does not impact correctness.", "overall_assessment": "correct"}}
{"example_id": 3117, "sql_complexity": "aggregation", "prompt": "What is the percentage of the population that has access to clean water in each continent?", "context": "CREATE TABLE water_data (id INT, country VARCHAR(50), continent CHAR(2), access_to_clean_water BOOLEAN); INSERT INTO water_data VALUES (1, 'Canada', 'NA', true), (2, 'Mexico', 'NA', false), (3, 'Brazil', 'SA', true), (4, 'Russia', 'EU', true);", "reference_sql": "SELECT continent, COUNT(*) FILTER (WHERE access_to_clean_water) * 100.0 / COUNT(*) AS percentage FROM water_data GROUP BY continent;", "generated_sql": "SELECT \n    continent,\n    ROUND(AVG(CASE WHEN access_to_clean_water THEN 1 ELSE 0 END) * 100, 2) AS percentage_with_access\nFROM water_data\nGROUP BY continent;", "raw_model_output": "SELECT \n    continent,\n    ROUND(AVG(CASE WHEN access_to_clean_water THEN 1 ELSE 0 END) * 100, 2) AS percentage_with_access\nFROM water_data\nGROUP BY continent;", "latency_sec": 0.6601390838623047, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 157, "prompt_eval_sec": null, "tokens_completion": 45, "completion_eval_sec": null, "tokens_total": 202, "tokens_per_sec": 305.99612254155556, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in how they handle precision. The reference query calculates the exact percentage using division and 100.0, while the generated query uses ROUND() to two decimal places, which can alter results for non-integer percentages. For example, 33.333...% would become 33.33% in the generated query but remain 33.333...% in the reference query.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent due to the ROUND function in the generated query, which introduces rounding to two decimal places. The reference query calculates the exact percentage without rounding. However, both correctly compute the proportion of populations with access to clean water per continent. The generated query better fulfills the business intent by presenting a more user-friendly percentage format (rounded to two decimals), which is standard for such metrics. While the reference is technically precise, the generated query's rounding aligns better with typical reporting requirements. Both are efficient and semantically correct.", "overall_assessment": "differently_correct"}}
{"example_id": 3542, "sql_complexity": "window functions", "prompt": "What is the average yield of crops for each country, ranked by average yield?", "context": "CREATE TABLE farming (id INT, name TEXT, country TEXT, crop TEXT, yield INT); INSERT INTO farming VALUES (1, 'Smith Farm', 'USA', 'Corn', 120), (2, 'Brown Farm', 'Canada', 'Soybeans', 45), (3, 'Jones Farm', 'Mexico', 'Wheat', 80);", "reference_sql": "SELECT country, AVG(yield) as avg_yield, ROW_NUMBER() OVER (ORDER BY AVG(yield) DESC) as rank FROM farming GROUP BY country;", "generated_sql": "SELECT country, AVG(yield) AS average_yield\nFROM farming\nGROUP BY country\nORDER BY average_yield DESC;", "raw_model_output": "SELECT country, AVG(yield) AS average_yield\nFROM farming\nGROUP BY country\nORDER BY average_yield DESC;", "latency_sec": 0.7458629608154297, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 156, "prompt_eval_sec": null, "tokens_completion": 27, "completion_eval_sec": null, "tokens_total": 183, "tokens_per_sec": 245.3533820742775, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a ROW_NUMBER() column for ranking, while the Generated SQL only returns country and average_yield. The output structures differ, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The Reference SQL correctly addresses the ranking requirement by using ROW_NUMBER() to assign ranks based on average yield, while the Generated SQL only orders results without explicit ranking. Both queries correctly calculate average yields, but the Reference SQL explicitly fulfills the 'ranked by average yield' requirement. The Generated SQL is technically correct for showing ordered averages but lacks the ranking mechanism requested in the question. The Reference SQL is more comprehensive for the business intent despite slightly higher complexity.", "overall_assessment": "differently_correct"}}
{"example_id": 2274, "sql_complexity": "subqueries", "prompt": "Add a new crop 'amaranth' to farm 'Nourishing Harvest' with yield 50 in 2023", "context": "CREATE TABLE farms (id INT, name TEXT, location TEXT, size FLOAT); INSERT INTO farms (id, name, location, size) VALUES (1, 'Nourishing Harvest', 'Mexico', 120.0); CREATE TABLE crops (id INT, farm_id INT, crop TEXT, yield INT, year INT);", "reference_sql": "INSERT INTO crops (id, farm_id, crop, yield, year) VALUES (5, (SELECT id FROM farms WHERE name = 'Nourishing Harvest'), 'amaranth', 50, 2023);", "generated_sql": "INSERT INTO crops (farm_id, crop, yield, year)\nSELECT id, 'amaranth', 50, 2023\nFROM farms\nWHERE name = 'Nourishing Harvest';", "raw_model_output": "INSERT INTO crops (farm_id, crop, yield, year)\nSELECT id, 'amaranth', 50, 2023\nFROM farms\nWHERE name = 'Nourishing Harvest';", "latency_sec": 0.5681090354919434, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 159, "prompt_eval_sec": null, "tokens_completion": 41, "completion_eval_sec": null, "tokens_total": 200, "tokens_per_sec": 352.04509610873157, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL explicitly sets the 'id' column to 5, while the Generated SQL omits the 'id' column entirely. The Generated SQL inserts rows with the farm_id, crop, yield, and year, but does not specify the 'id' value, which would likely be auto-generated or null if not set. This difference in column specification makes the queries semantically distinct.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query explicitly sets the 'id' to 5, which assumes knowledge of existing primary key values and may fail if 5 is already used. The generated query dynamically retrieves the farm_id via a subquery, avoiding hardcoded values and ensuring correctness regardless of existing IDs. Both insert the correct data, but the generated version is more robust and aligns better with typical database practices where IDs are auto-generated. The business intent to add the crop to the specific farm is fulfilled by both, but the generated query does so more elegantly.", "overall_assessment": "differently_correct"}}
{"example_id": 3705, "sql_complexity": "subqueries", "prompt": "What is the percentage of unions with collective bargaining agreements in the Midwest region?", "context": "CREATE TABLE collective_bargaining (bargaining_id INT, union_name VARCHAR(50), contract_start_date DATE, contract_end_date DATE, region VARCHAR(50));CREATE VIEW union_region AS SELECT DISTINCT union_name, region FROM collective_bargaining;", "reference_sql": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM union_region) as percentage FROM union_region ur WHERE ur.region = 'Midwest' AND EXISTS (SELECT 1 FROM collective_bargaining cb WHERE cb.union_name = ur.union_name);", "generated_sql": "SELECT \n  (COUNT(DISTINCT union_name) * 100.0) / NULLIF((SELECT COUNT(DISTINCT union_name) FROM union_region), 0) AS percentage_unions_midwest\nFROM \n  union_region\nWHERE \n  region = 'Midwest';", "raw_model_output": "SELECT \n  (COUNT(DISTINCT union_name) * 100.0) / NULLIF((SELECT COUNT(DISTINCT union_name) FROM union_region), 0) AS percentage_unions_midwest\nFROM \n  union_region\nWHERE \n  region = 'Midwest';", "latency_sec": 0.7006771564483643, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 133, "prompt_eval_sec": null, "tokens_completion": 59, "completion_eval_sec": null, "tokens_total": 192, "tokens_per_sec": 274.0206359419814, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their numerator and denominator calculations. The reference query counts (union_name, region) pairs in the Midwest divided by total pairs, while the generated query counts distinct union_names in the Midwest divided by distinct union_names overall. The EXISTS clause in the reference query is redundant (since union_region already comes from collective_bargaining), but the denominator calculation differs: the reference uses COUNT(*) (total rows) while the generated uses COUNT(DISTINCT union_name) (unique unions). This leads to different percentages when unions appear in multiple regions.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly identifies unions with CBAs in the Midwest via the EXISTS clause, but its denominator incorrectly counts all union-region pairs instead of just Midwest unions. The generated query lacks any CBA check in the numerator and uses an incorrect denominator. While both have flaws, the reference query better aligns with the business intent by addressing CBAs, even though its denominator is flawed. The generated query fails to filter for CBAs entirely, making it less accurate.", "overall_assessment": "differently_correct"}}
{"example_id": 240, "sql_complexity": "aggregation", "prompt": "What is the average capacity of renewable energy projects for each country?", "context": "CREATE TABLE projects (name TEXT, type TEXT, capacity INTEGER, country TEXT); INSERT INTO projects (name, type, capacity, country) VALUES ('Project 1', 'Wind', 100, 'USA'), ('Project 2', 'Solar', 200, 'Germany'), ('Project 3', 'Wind', 300, 'France');", "reference_sql": "SELECT country, AVG(capacity) FROM projects GROUP BY country", "generated_sql": "SELECT country, AVG(capacity) AS average_capacity\nFROM projects\nWHERE type IN ('Wind', 'Solar')\nGROUP BY country;", "raw_model_output": "SELECT country, AVG(capacity) AS average_capacity\nFROM projects\nWHERE type IN ('Wind', 'Solar')\nGROUP BY country;", "latency_sec": 0.8037858009338379, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 151, "prompt_eval_sec": null, "tokens_completion": 28, "completion_eval_sec": null, "tokens_total": 179, "tokens_per_sec": 222.6961459035951, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes all projects in the calculation, while the Generated SQL filters projects to only those with type 'Wind' or 'Solar'. Although the sample data contains no projects outside these types, the WHERE clause makes the Generated SQL semantically different. If other project types existed, the results would differ.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because the generated query explicitly filters for 'Wind' and 'Solar' projects (assumed renewable), while the reference query includes all project types. The original question specifies 'renewable energy projects,' which implies excluding non-renewable types. Although the context only shows Wind/Solar projects, the generated query better aligns with the business intent by explicitly restricting to renewable categories. The reference query could include non-renewable projects if present in the dataset, making it less precise. Both queries calculate the correct average, but the generated version more accurately addresses the question's requirements.", "overall_assessment": "differently_correct"}}
{"example_id": 2132, "sql_complexity": "set operations", "prompt": "What is the average caseload per attorney in community legal clinics in California, and how does it compare to the state average?", "context": "CREATE TABLE cali_community_legal_clinics(id INT, attorney_count INT, cases_handled INT, state VARCHAR(255));", "reference_sql": "SELECT state, AVG(cases_handled/attorney_count) AS avg_caseload FROM cali_community_legal_clinics WHERE state = 'California' GROUP BY state UNION ALL SELECT 'California', AVG(cases_handled/attorney_count) FROM cali_community_legal_clinics WHERE state = 'California';", "generated_sql": "SELECT \n    AVG(cases_handled * 1.0 / attorney_count) AS avg_caseload_per_attorney_in_CA,\n    (SELECT AVG(cases_handled * 1.0 / attorney_count) FROM cali_community_legal_clinics) AS overall_avg_caseload\nFROM cali_community_legal_clinics\nWHERE state = 'California';", "raw_model_output": "SELECT \n    AVG(cases_handled * 1.0 / attorney_count) AS avg_caseload_per_attorney_in_CA,\n    (SELECT AVG(cases_handled * 1.0 / attorney_count) FROM cali_community_legal_clinics) AS overall_avg_caseload\nFROM cali_community_legal_clinics\nWHERE state = 'California';", "latency_sec": 1.037421703338623, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 120, "prompt_eval_sec": null, "tokens_completion": 81, "completion_eval_sec": null, "tokens_total": 201, "tokens_per_sec": 193.74956139161466, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two rows with the same average caseload for California, while the Generated SQL returns a single row with two different averages (California-specific and overall). Additionally, the Reference SQL uses integer division (cases_handled/attorney_count) whereas the Generated SQL uses floating-point division (cases_handled * 1.0 / attorney_count), leading to different numerical results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL contains a logical error: the second part of the UNION ALL incorrectly repeats the same California average instead of calculating the true state average. It also redundantly returns two identical rows for California. The Generated SQL correctly calculates the California caseload average in the main query and the overall state average in a subquery, addressing both parts of the question. While the Generated SQL assumes the table contains multiple states (which is implied by the 'state' column), it better fulfills the business intent by explicitly comparing the two metrics. The Reference SQL fails to provide a meaningful comparison.", "overall_assessment": "differently_correct"}}
{"example_id": 3276, "sql_complexity": "basic SQL", "prompt": "What is the total energy consumption of the Chemical Plant B in the last quarter?", "context": "CREATE TABLE EnergyConsumption (EnergyID INT, Plant VARCHAR(255), EnergyQuantity DECIMAL(5,2), Timestamp DATETIME);", "reference_sql": "SELECT SUM(EnergyQuantity) FROM EnergyConsumption WHERE Plant = 'Chemical Plant B' AND Timestamp BETWEEN DATE_SUB(CURRENT_DATE(), INTERVAL 3 MONTH) AND CURRENT_DATE();", "generated_sql": "SELECT SUM(EnergyQuantity) AS TotalEnergyConsumption\nFROM EnergyConsumption\nWHERE Plant = 'Chemical Plant B'\n  AND Timestamp >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH)\n  AND Timestamp < CURDATE();", "raw_model_output": "SELECT SUM(EnergyQuantity) AS TotalEnergyConsumption\nFROM EnergyConsumption\nWHERE Plant = 'Chemical Plant B'\n  AND Timestamp >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH)\n  AND Timestamp < CURDATE();", "latency_sec": 0.8663461208343506, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 110, "prompt_eval_sec": null, "tokens_completion": 47, "completion_eval_sec": null, "tokens_total": 157, "tokens_per_sec": 181.22087261012754, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses BETWEEN with CURRENT_DATE() which includes the entire current date (up to 23:59:59.999...), while the Generated SQL uses Timestamp < CURDATE() which excludes any records from the current day. The upper bound behavior differs between BETWEEN (inclusive) and the explicit range (exclusive).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries differ in their time range logic. The reference query uses BETWEEN with CURRENT_DATE(), which includes the entire current day (up to midnight) in the last quarter calculation. The generated query uses < CURDATE(), which excludes the current day entirely. While both target the last three months, the reference query is more inclusive of the full quarter period. Both correctly filter by 'Chemical Plant B', but the reference's approach better aligns with typical business definitions of 'last quarter' (past 3 months including current day). The generated query might undercount if the current day's data is relevant.", "overall_assessment": "correct"}}
{"example_id": 3074, "sql_complexity": "multiple_joins", "prompt": "Find the top 5 players with the highest scores in the 'historical_tournaments' view, including their scores and the names of the tournaments they participated in.", "context": "CREATE VIEW historical_tournaments AS SELECT tournaments.tournament_name, players.player_name, players.score FROM tournaments JOIN players_scores ON tournaments.tournament_id = players_scores.tournament_id JOIN players ON players_scores.player_id = players.player_id;  CREATE TABLE tournaments (tournament_id INT, tournament_name TEXT);  CREATE TABLE players_scores (player_id INT, tournament_id INT, score INT);  CREATE TABLE players (player_id INT, player_name TEXT);", "reference_sql": "SELECT players.player_name, MAX(players_scores.score) as high_score, tournaments.tournament_name FROM historical_tournaments JOIN players ON historical_tournaments.player_id = players.player_id JOIN players_scores ON historical_tournaments.player_id = players_scores.player_id JOIN tournaments ON players_scores.tournament_id = tournaments.tournament_id GROUP BY players.player_id, tournaments.tournament_name ORDER BY high_score DESC LIMIT 5;", "generated_sql": "SELECT \n    player_name, \n    tournament_name, \n    score\nFROM \n    historical_tournaments\nORDER BY \n    score DESC\nLIMIT 5;", "raw_model_output": "SELECT \n    player_name, \n    tournament_name, \n    score\nFROM \n    historical_tournaments\nORDER BY \n    score DESC\nLIMIT 5;", "latency_sec": 0.5574009418487549, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 190, "prompt_eval_sec": null, "tokens_completion": 34, "completion_eval_sec": null, "tokens_total": 224, "tokens_per_sec": 401.86512648695907, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL groups by player_id and tournament_name to find the maximum score per player-tournament pair, while the Generated SQL selects all rows from the view and orders by score without grouping. The Reference SQL also includes redundant joins to tables already included in the view, and the Generated SQL lacks the grouping/aggregation logic, leading to different result sets.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries are not technically equivalent. The Reference SQL contains redundant joins and incorrect grouping logic (grouping by tournament_name instead of player_id), which would produce incorrect results. The Generated SQL is simpler and directly queries the view, but it fails to address the business intent of identifying top players by their highest scores (it returns raw tournament-player score entries without aggregation). While the Generated SQL is more efficient and syntactically correct, neither query fully fulfills the intent of finding the top 5 players with their maximum scores across tournaments.", "overall_assessment": "differently_correct"}}
{"example_id": 2219, "sql_complexity": "window functions", "prompt": "What is the average population of cities with a UNESCO World Heritage designation, ordered by designation date?", "context": "CREATE TABLE cities (name VARCHAR(255), population INT, designation_date DATE); INSERT INTO cities (name, population, designation_date) VALUES ('Paris', 2141000, '1991-09-16'); INSERT INTO cities (name, population, designation_date) VALUES ('Rio de Janeiro', 6727000, '2012-07-01');", "reference_sql": "SELECT AVG(population) FROM (SELECT population, ROW_NUMBER() OVER (ORDER BY designation_date) rn FROM cities WHERE name IN (SELECT name FROM heritagesites)) t WHERE rn % 2 = 1;", "generated_sql": "SELECT AVG(population) AS average_population\nFROM cities\nWHERE designation_date IS NOT NULL\nORDER BY designation_date;", "raw_model_output": "SELECT AVG(population) AS average_population\nFROM cities\nWHERE designation_date IS NOT NULL\nORDER BY designation_date;", "latency_sec": 0.7536880970001221, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 160, "prompt_eval_sec": null, "tokens_completion": 25, "completion_eval_sec": null, "tokens_total": 185, "tokens_per_sec": 245.45962810922572, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates the average of populations from cities in heritagesites, ordered by designation_date, and only includes odd-numbered rows. The generated query averages all cities with non-null designation dates without filtering or row numbering. Differences include: 1) Heritagesites filter 2) Row number filtering 3) Missing ORDER BY in the generated query's outer query.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query is technically flawed: it references a non-existent 'heritagesites' table (missing from the context), uses ROW_NUMBER() to select every other row (which distorts the average), and incorrectly assumes designation_date ordering affects the average. The generated query correctly filters cities with non-null designation dates (assuming this indicates UNESCO status) and includes the required ORDER BY clause. However, neither query fully addresses the intent: the original question requires filtering for UNESCO-designated cities, which the generated query does via designation_date IS NOT NULL (assuming this field indicates designation), while the reference query's subquery is invalid. The generated query is more aligned with the context but still lacks explicit filtering for UNESCO sites (which might require a separate table).", "overall_assessment": "differently_correct"}}
{"example_id": 3786, "sql_complexity": "aggregation", "prompt": "Display the names and average co-owner percentages for all properties in the 'property_coownership' table where the co-owner percentage is greater than 60.", "context": "CREATE TABLE property_coownership (property_id INT, owner VARCHAR(255), percentage INT); INSERT INTO property_coownership (property_id, owner, percentage) VALUES (1, 'Mohammed', 70), (1, 'Fatima', 30), (2, 'Jamal', 65), (2, 'Aisha', 35), (3, 'Ali', 75), (3, 'Khadija', 25);", "reference_sql": "SELECT owner, AVG(percentage) FROM property_coownership WHERE percentage > 60 GROUP BY owner;", "generated_sql": "SELECT owner, AVG(percentage) AS average_percentage\nFROM property_coownership\nWHERE percentage > 60\nGROUP BY owner;", "raw_model_output": "SELECT owner, AVG(percentage) AS average_percentage\nFROM property_coownership\nWHERE percentage > 60\nGROUP BY owner;", "latency_sec": 0.5407919883728027, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 189, "prompt_eval_sec": null, "tokens_completion": 27, "completion_eval_sec": null, "tokens_total": 216, "tokens_per_sec": 399.4142011051711, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. The generated query adds an explicit column alias (average_percentage) for the AVG(percentage) expression, but this does not affect the actual data returned. Both queries select the same columns, apply the same WHERE condition (percentage > 60), and group by the same column (owner). The semantic meaning and result set remain identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": false, "superiority": "equal", "explanation": "The queries are technically equivalent as they produce identical results (same columns, same aggregation logic, and same filtering). However, they do not fulfill the business intent. The original question asks for 'average co-owner percentages for all properties' where the percentage exceeds 60, but the queries group by 'owner' instead of 'property_id'. This grouping by owner calculates averages per owner across properties, whereas the intended result likely requires grouping by property to compute averages per property. The generated SQL adds an alias ('average_percentage') which improves readability but does not alter functionality. The reference SQL is functionally identical but lacks the alias.", "overall_assessment": "differently_correct"}}
{"example_id": 2357, "sql_complexity": "basic SQL", "prompt": "What is the total amount of climate finance invested in renewable energy projects by public and private sectors in Africa?", "context": "CREATE TABLE renewable_energy_projects (project_id INT, sector TEXT, investor_type TEXT, region TEXT, amount FLOAT); INSERT INTO renewable_energy_projects (project_id, sector, investor_type, region, amount) VALUES (1, 'Renewable Energy', 'Public', 'Africa', 5000000); INSERT INTO renewable_energy_projects (project_id, sector, investor_type, region, amount) VALUES (2, 'Renewable Energy', 'Private', 'Africa', 7000000);", "reference_sql": "SELECT SUM(amount) FROM renewable_energy_projects WHERE sector = 'Renewable Energy' AND region = 'Africa';", "generated_sql": "SELECT \n    SUM(amount) AS total_investment\nFROM \n    renewable_energy_projects\nWHERE \n    sector = 'Renewable Energy' AND\n    region = 'Africa' AND\n    investor_type IN ('Public', 'Private');", "raw_model_output": "SELECT \n    SUM(amount) AS total_investment\nFROM \n    renewable_energy_projects\nWHERE \n    sector = 'Renewable Energy' AND\n    region = 'Africa' AND\n    investor_type IN ('Public', 'Private');", "latency_sec": 0.680152177810669, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 187, "prompt_eval_sec": null, "tokens_completion": 50, "completion_eval_sec": null, "tokens_total": 237, "tokens_per_sec": 348.451431505925, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL sums all projects in 'Renewable Energy' sector and 'Africa' region regardless of investor_type. The Generated SQL adds an explicit filter for investor_type IN ('Public', 'Private'). While the sample data contains only these two investor types, the queries would differ if other investor_types existed in the table. The additional condition in the Generated SQL makes it more restrictive, so they are not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The Reference SQL omits the investor_type filter, while the Generated SQL explicitly includes both 'Public' and 'Private' investor types. Although the sample data matches both queries, the Generated version strictly adheres to the business requirement of capturing investments from both sectors. The Reference SQL might include other investor types if present in the dataset, potentially overcounting. The Generated SQL is more precise and aligns better with the explicit mention of 'public and private sectors' in the question.", "overall_assessment": "differently_correct"}}
{"example_id": 1009, "sql_complexity": "multiple_joins", "prompt": "Find the number of IoT sensors installed in each farm that use Sprinkler irrigation.", "context": "CREATE TABLE IoT_Sensors (id INT, sensor_type VARCHAR(50), Farm_id INT); INSERT INTO IoT_Sensors (id, sensor_type, Farm_id) VALUES (1, 'Soil Moisture', 1), (2, 'Temperature', 1), (3, 'Humidity', 2); CREATE TABLE Irrigation (id INT, Farm_id INT, irrigation_type VARCHAR(50), duration INT); INSERT INTO Irrigation (id, Farm_id, irrigation_type, duration) VALUES (1, 1, 'Sprinkler', 30), (2, 2, 'Drip', 45);", "reference_sql": "SELECT f.id, COUNT(s.id) FROM Farmers f JOIN Irrigation i ON f.id = i.Farm_id JOIN IoT_Sensors s ON f.id = s.Farm_id WHERE i.irrigation_type = 'Sprinkler' GROUP BY f.id;", "generated_sql": "SELECT \n    i.Farm_id, \n    COUNT(s.id) AS sensor_count\nFROM \n    IoT_Sensors s\nJOIN \n    Irrigation i ON s.Farm_id = i.Farm_id\nWHERE \n    i.irrigation_type = 'Sprinkler'\nGROUP BY \n    i.Farm_id;", "raw_model_output": "SELECT \n    i.Farm_id, \n    COUNT(s.id) AS sensor_count\nFROM \n    IoT_Sensors s\nJOIN \n    Irrigation i ON s.Farm_id = i.Farm_id\nWHERE \n    i.irrigation_type = 'Sprinkler'\nGROUP BY \n    i.Farm_id;", "latency_sec": 0.7264800071716309, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 215, "prompt_eval_sec": null, "tokens_completion": 68, "completion_eval_sec": null, "tokens_total": 283, "tokens_per_sec": 389.5496052283532, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count IoT_Sensors per Farm_id where Irrigation is 'Sprinkler'. The Reference uses Farmers table but the Generated directly joins IoT_Sensors and Irrigation. Since the Farm_id in both cases is linked through joins and the grouping/columns are equivalent, the results will match. The Farmers table isn't needed as the Farm_id in Irrigation and IoT_Sensors is sufficient.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The Reference SQL incorrectly references a 'Farmers' table that does not exist in the provided schema, while the Generated SQL properly joins only the existing 'IoT_Sensors' and 'Irrigation' tables. Both queries correctly filter for 'Sprinkler' irrigation and group by Farm_id, but the Reference SQL would fail due to a non-existent table. The Generated SQL directly addresses the business intent by counting sensors per farm with Sprinkler irrigation using valid schema elements. The Generated SQL is more efficient as it avoids unnecessary joins and uses explicit table aliases.", "overall_assessment": "incorrect"}}
{"example_id": 4217, "sql_complexity": "subqueries", "prompt": "Show consumer preference data for foundations, excluding products from the USA.", "context": "CREATE TABLE cosmetics (product_id INT, product_name VARCHAR(100), product_type VARCHAR(50), is_cruelty_free BOOLEAN, consumer_preference_score INT); INSERT INTO cosmetics (product_id, product_name, product_type, is_cruelty_free, consumer_preference_score) VALUES (1, 'Lipstick A', 'Lipstick', TRUE, 80), (2, 'Foundation B', 'Foundation', FALSE, 90), (3, 'Mascara C', 'Mascara', TRUE, 85), (4, 'Eyeshadow D', 'Eyeshadow', TRUE, 70), (5, 'Blush E', 'Blush', FALSE, 95); CREATE TABLE ingredient_sourcing (ingredient_id INT, ingredient_name VARCHAR(100), sourcing_country VARCHAR(50), is_organic BOOLEAN); INSERT INTO ingredient_sourcing (ingredient_id, ingredient_name, sourcing_country, is_organic) VALUES (1, 'Rosehip Oil', 'Chile', TRUE), (2, 'Shea Butter', 'Ghana', TRUE), (3, 'Jojoba Oil', 'India', TRUE), (4, 'Coconut Oil', 'Philippines', FALSE), (5, 'Aloe Vera', 'USA', TRUE);", "reference_sql": "SELECT * FROM cosmetics WHERE product_type = 'Foundation' AND product_id NOT IN (SELECT cosmetics.product_id FROM cosmetics INNER JOIN ingredient_sourcing ON cosmetics.product_id = ingredient_sourcing.ingredient_id WHERE ingredient_sourcing.sourcing_country = 'USA');", "generated_sql": "SELECT product_name, consumer_preference_score\nFROM cosmetics\nWHERE product_type = 'Foundation' AND product_id NOT IN (\n    SELECT product_id FROM cosmetics WHERE product_name LIKE '%USA%'\n);", "raw_model_output": "SELECT product_name, consumer_preference_score\nFROM cosmetics\nWHERE product_type = 'Foundation' AND product_id NOT IN (\n    SELECT product_id FROM cosmetics WHERE product_name LIKE '%USA%'\n);\n", "latency_sec": 0.8927292823791504, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 336, "prompt_eval_sec": null, "tokens_completion": 40, "completion_eval_sec": null, "tokens_total": 376, "tokens_per_sec": 421.1803145943064, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL excludes products linked to ingredients sourced from 'USA' via a join between cosmetics.product_id and ingredient_sourcing.ingredient_id, while the Generated SQL excludes products with 'USA' in their name. These subqueries target different conditions (ingredient sourcing vs. product name), leading to different results in general cases. In the provided data, both return the same result due to specific values, but this does not make them equivalent in all scenarios.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query attempts to exclude products with ingredients sourced from the USA by joining cosmetics with ingredient_sourcing on product_id = ingredient_id, which is logically flawed (product_id and ingredient_id are unrelated). The generated query incorrectly filters by product_name containing 'USA', which is unrelated to sourcing country. Both queries fail to correctly address the business intent, but the reference query's approach aligns more closely with the intent (using ingredient sourcing data) despite its technical error. The generated query's logic is fundamentally misaligned with the question.", "overall_assessment": "differently_correct"}}
{"example_id": 5620, "sql_complexity": "basic SQL", "prompt": "What is the recycling rate of plastic in the residential sector in the state of New York?", "context": "CREATE TABLE recycling_rates_city (sector VARCHAR(20), city VARCHAR(20), material VARCHAR(20), recycling_rate DECIMAL(5,2)); INSERT INTO recycling_rates_city (sector, city, material, recycling_rate) VALUES ('residential', 'New York City', 'plastic', 0.25), ('commercial', 'New York City', 'plastic', 0.30), ('residential', 'New York City', 'paper', 0.45), ('commercial', 'New York City', 'paper', 0.50), ('residential', 'Los Angeles', 'plastic', 0.20), ('commercial', 'Los Angeles', 'plastic', 0.35), ('residential', 'Los Angeles', 'paper', 0.40), ('commercial', 'Los Angeles', 'paper', 0.50);", "reference_sql": "SELECT recycling_rate FROM recycling_rates_city WHERE sector = 'residential' AND material = 'plastic' AND city = 'New York City';", "generated_sql": "SELECT recycling_rate\nFROM recycling_rates_city\nWHERE sector = 'residential'\n  AND city = 'New York City'\n  AND material = 'plastic';", "raw_model_output": "SELECT recycling_rate\nFROM recycling_rates_city\nWHERE sector = 'residential'\n  AND city = 'New York City'\n  AND material = 'plastic';", "latency_sec": 0.8447470664978027, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 259, "prompt_eval_sec": null, "tokens_completion": 33, "completion_eval_sec": null, "tokens_total": 292, "tokens_per_sec": 345.66559811872344, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select the same column ('recycling_rate') from the same table ('recycling_rates_city') and apply identical WHERE conditions (sector = 'residential', city = 'New York City', material = 'plastic'). The order of conditions in the WHERE clause does not affect the result set.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are structurally identical in terms of logic and syntax, with the only difference being the order of conditions in the WHERE clause. Since SQL evaluates conditions in WHERE clauses as logical conjunctions (AND), the order does not affect the result. Both queries correctly filter for 'residential' sector, 'plastic' material, and 'New York City' to retrieve the recycling rate. The business intent is fully addressed as the question specifically asks for this exact combination of parameters.", "overall_assessment": "correct"}}
{"example_id": 3151, "sql_complexity": "basic SQL", "prompt": "List all biotech startups that received funding in 2022 and their respective funding amounts.", "context": "CREATE TABLE biotech_startups (name TEXT, funding FLOAT, date DATE); INSERT INTO biotech_startups (name, funding, date) VALUES ('StartupA', 3500000, '2022-02-28'); INSERT INTO biotech_startups (name, funding, date) VALUES ('StartupB', 4500000, '2022-07-12');", "reference_sql": "SELECT name, funding FROM biotech_startups WHERE date BETWEEN '2022-01-01' AND '2022-12-31';", "generated_sql": "SELECT name, funding\nFROM biotech_startups\nWHERE EXTRACT(YEAR FROM date) = 2022;", "raw_model_output": "SELECT name, funding\nFROM biotech_startups\nWHERE EXTRACT(YEAR FROM date) = 2022;", "latency_sec": 0.5153563022613525, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 159, "prompt_eval_sec": null, "tokens_completion": 24, "completion_eval_sec": null, "tokens_total": 183, "tokens_per_sec": 355.09413428536135, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select startups with dates in 2022. The reference query uses BETWEEN '2022-01-01' AND '2022-12-31' which includes all dates in that year. The generated query uses EXTRACT(YEAR FROM date) = 2022, which also captures all dates in 2022. Since the date column is of DATE type (no time component), both conditions are equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries correctly retrieve biotech startups funded in 2022. The reference query uses a date range (BETWEEN '2022-01-01' AND '2022-12-31') which is semantically precise for DATE-typed columns and may leverage indexes for better performance. The generated query uses EXTRACT(YEAR FROM date) = 2022 which is functionally equivalent but less efficient due to the function applied to the column. Both satisfy the business intent, but the reference query is more optimized.", "overall_assessment": "correct"}}
{"example_id": 2136, "sql_complexity": "window functions", "prompt": "What is the total military equipment sales revenue for each sales representative by fiscal year?", "context": "CREATE TABLE SalesReps (SalesRepID INT, SalesRepName VARCHAR(50), FiscalYear INT, Revenue DECIMAL(10,2)); INSERT INTO SalesReps (SalesRepID, SalesRepName, FiscalYear, Revenue) VALUES (1, 'John Doe', 2020, 150000.00), (2, 'Jane Smith', 2020, 200000.00), (1, 'John Doe', 2021, 180000.00), (2, 'Jane Smith', 2021, 250000.00);", "reference_sql": "SELECT SalesRepName, FiscalYear, SUM(Revenue) OVER (PARTITION BY SalesRepName ORDER BY FiscalYear) AS TotalRevenue FROM SalesReps;", "generated_sql": "SELECT \n    SalesRepID,\n    FiscalYear,\n    SUM(Revenue) AS TotalRevenue\nFROM \n    SalesReps\nGROUP BY \n    SalesRepID,\n    FiscalYear;", "raw_model_output": "SELECT \n    SalesRepID,\n    FiscalYear,\n    SUM(Revenue) AS TotalRevenue\nFROM \n    SalesReps\nGROUP BY \n    SalesRepID,\n    FiscalYear;", "latency_sec": 0.8482959270477295, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 201, "prompt_eval_sec": null, "tokens_completion": 40, "completion_eval_sec": null, "tokens_total": 241, "tokens_per_sec": 284.09897102622784, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL uses a window function to calculate a running total of Revenue per SalesRepName across FiscalYears, while the Generated SQL aggregates Revenue by SalesRepID and FiscalYear, returning individual year values instead of cumulative sums. Additionally, the Reference SQL includes SalesRepName whereas the Generated SQL uses SalesRepID.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query calculates a running total (cumulative sum) of revenue per sales representative over fiscal years using a window function, which does not match the requirement for 'total revenue for each sales representative by fiscal year.' The generated query correctly aggregates revenue by SalesRepID and FiscalYear, producing the total revenue per representative per year as requested. While the generated query uses SalesRepID instead of SalesRepName, the question does not explicitly require names, and the schema includes both identifiers. The generated query is more efficient and directly addresses the business intent.", "overall_assessment": "differently_correct"}}
{"example_id": 5452, "sql_complexity": "basic SQL", "prompt": "What is the name of the farms with a size greater than 150 acres located in 'Texas'?", "context": "CREATE TABLE farms (id INT PRIMARY KEY, name VARCHAR(50), size INT, location VARCHAR(50)); INSERT INTO farms (id, name, size, location) VALUES (1, 'Smith Farms', 200, 'Texas'), (2, 'Johnson Farms', 100, 'California');", "reference_sql": "SELECT name FROM farms WHERE size > 150 AND location = 'Texas'", "generated_sql": "SELECT name\nFROM farms\nWHERE size > 150 AND location = 'Texas';", "raw_model_output": "SELECT name\nFROM farms\nWHERE size > 150 AND location = 'Texas';", "latency_sec": 0.750108003616333, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 149, "prompt_eval_sec": null, "tokens_completion": 18, "completion_eval_sec": null, "tokens_total": 167, "tokens_per_sec": 222.63460620987794, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in logic and structure. The only differences are formatting (line breaks and semicolon placement), which do not affect the semantic meaning or result of the SQL statement.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are syntactically identical in structure and logic, with the only difference being whitespace formatting. They both select the 'name' column from the 'farms' table where 'size' > 150 and 'location' = 'Texas'. The reference query uses a single line while the generated query uses line breaks, but SQL is whitespace-insensitive. Both would return the same result ('Smith Farms') from the provided sample data. Both correctly address the business intent of identifying large Texas farms.", "overall_assessment": "correct"}}
{"example_id": 5152, "sql_complexity": "aggregation", "prompt": "How many international tourists visited Portugal in 2020, broken down by continent?", "context": "CREATE TABLE international_tourists(tourist_id INT, country TEXT, arrival_year INT, continent TEXT);INSERT INTO international_tourists (tourist_id, country, arrival_year, continent) VALUES (1, 'Spain', 2020, 'Europe'), (2, 'France', 2020, 'Europe'), (3, 'Brazil', 2020, 'South America'), (4, 'United States', 2020, 'North America'), (5, 'China', 2020, 'Asia');", "reference_sql": "SELECT continent, COUNT(*) FROM international_tourists WHERE arrival_year = 2020 GROUP BY continent;", "generated_sql": "SELECT continent, COUNT(tourist_id) AS tourist_count\nFROM international_tourists\nWHERE country = 'Portugal' AND arrival_year = 2020\nGROUP BY continent;", "raw_model_output": "SELECT continent, COUNT(tourist_id) AS tourist_count\nFROM international_tourists\nWHERE country = 'Portugal' AND arrival_year = 2020\nGROUP BY continent;", "latency_sec": 0.5961589813232422, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 192, "prompt_eval_sec": null, "tokens_completion": 38, "completion_eval_sec": null, "tokens_total": 230, "tokens_per_sec": 385.8031283693639, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query counts all tourists from 2020 across all countries, grouped by continent. The generated query filters for 'Portugal' (which has no entries in the data) and would return an empty result. The WHERE conditions differ significantly, leading to different outputs.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly counts all international tourists in 2020 grouped by continent, aligning with the business intent of analyzing visitors by origin continent. The Generated SQL incorrectly filters for tourists from Portugal (country='Portugal') instead of tourists visiting Portugal, which misrepresents the data. While both queries are syntactically valid, the Generated SQL fails to address the actual question by filtering on the wrong column. The Reference SQL is more elegant and directly answers the query without unnecessary conditions.", "overall_assessment": "incorrect"}}
{"example_id": 2477, "sql_complexity": "set operations", "prompt": "What is the carbon price in Europe and Australia for the last quarter of 2020?", "context": "CREATE TABLE CarbonPrices (Country TEXT, Year INT, Quarter INT, CarbonPrice NUMBER); INSERT INTO CarbonPrices (Country, Year, Quarter, CarbonPrice) VALUES ('Europe', 2020, 4, 25), ('Australia', 2020, 4, 15); CREATE TABLE CarbonTaxes (Country TEXT, Year INT, Quarter INT, CarbonPrice NUMBER); INSERT INTO CarbonTaxes (Country, Year, Quarter, CarbonPrice) VALUES ('Europe', 2019, 4, 20), ('Australia', 2019, 4, 10);", "reference_sql": "SELECT Context.Country, Context.CarbonPrice FROM ( SELECT * FROM CarbonPrices WHERE CarbonPrices.Country IN ('Europe', 'Australia') AND CarbonPrices.Year = 2020 AND CarbonPrices.Quarter = 4 UNION SELECT * FROM CarbonTaxes WHERE CarbonTaxes.Country IN ('Europe', 'Australia') AND CarbonTaxes.Year = 2020 AND CarbonTaxes.Quarter = 4 ) AS Context;", "generated_sql": "SELECT Country, Year, Quarter, CarbonPrice\nFROM CarbonPrices\nWHERE (Country IN ('Europe', 'Australia')) AND (Year = 2020) AND (Quarter = 4);", "raw_model_output": "SELECT Country, Year, Quarter, CarbonPrice\nFROM CarbonPrices\nWHERE (Country IN ('Europe', 'Australia')) AND (Year = 2020) AND (Quarter = 4);", "latency_sec": 0.588181734085083, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 203, "prompt_eval_sec": null, "tokens_completion": 40, "completion_eval_sec": null, "tokens_total": 243, "tokens_per_sec": 413.13761702917657, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL combines data from both CarbonPrices and CarbonTaxes tables using a UNION, while the Generated SQL only queries CarbonPrices. Additionally, the Reference SQL selects only Country and CarbonPrice columns, whereas the Generated SQL retrieves all four columns (Country, Year, Quarter, CarbonPrice). These differences in data sources and output structure make them non-equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries return the correct carbon price data for Europe and Australia in Q4 2020. However, the generated query is more efficient and directly addresses the question. The reference query incorrectly combines CarbonPrices and CarbonTaxes tables, which represent different data types (prices vs. taxes). The original question specifically asks for 'carbon price,' making CarbonPrices the appropriate table. The generated query avoids unnecessary complexity and directly retrieves the required data from the correct table.", "overall_assessment": "correct"}}
{"example_id": 4573, "sql_complexity": "subqueries", "prompt": "Find the names of all the indigenous communities in the 'Arctic_Communities' table that have a population size greater than the average population size in the 'Antarctic_Communities' table.", "context": "CREATE TABLE Arctic_Communities (name TEXT, population INTEGER); CREATE TABLE Antarctic_Communities (name TEXT, population INTEGER);", "reference_sql": "SELECT name FROM Arctic_Communities WHERE Arctic_Communities.population > (SELECT AVG(population) FROM Antarctic_Communities)", "generated_sql": "SELECT name\nFROM Arctic_Communities\nWHERE population > (\n    SELECT AVG(population)\n    FROM Antarctic_Communities\n);", "raw_model_output": "SELECT name\nFROM Arctic_Communities\nWHERE population > (\n    SELECT AVG(population)\n    FROM Antarctic_Communities\n);", "latency_sec": 0.5737237930297852, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 134, "prompt_eval_sec": null, "tokens_completion": 28, "completion_eval_sec": null, "tokens_total": 162, "tokens_per_sec": 282.36583869825614, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select names from Arctic_Communities where population exceeds the average population of Antarctic_Communities. The Generated SQL omits the table alias in the main query's WHERE clause, but since the main query is explicitly from Arctic_Communities, the population column is unambiguously from that table. The subquery structure and logic remain identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically correct and produce identical results. The reference query explicitly qualifies the 'population' column with the table name 'Arctic_Communities', while the generated query relies on implicit table context. Since the 'population' column exists only in the Arctic_Communities table, both versions are semantically equivalent. The generated query is more concise and elegant by avoiding redundant table qualification, but both correctly address the business intent of comparing Arctic community populations to the Antarctic average.", "overall_assessment": "correct"}}
{"example_id": 3596, "sql_complexity": "window functions", "prompt": "What is the total revenue for each game in the \"Gaming\" category?", "context": "CREATE TABLE Games (GameID int, GameName varchar(50), Category varchar(50), Revenue decimal(10,2));", "reference_sql": "SELECT Category, SUM(Revenue) OVER(PARTITION BY Category) as TotalRevenue FROM Games;", "generated_sql": "SELECT GameName, SUM(Revenue) AS TotalRevenue\nFROM Games\nWHERE Category = 'Gaming'\nGROUP BY GameName;", "raw_model_output": "SELECT GameName, SUM(Revenue) AS TotalRevenue\nFROM Games\nWHERE Category = 'Gaming'\nGROUP BY GameName;", "latency_sec": 0.5105299949645996, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 108, "prompt_eval_sec": null, "tokens_completion": 27, "completion_eval_sec": null, "tokens_total": 135, "tokens_per_sec": 264.43108403329165, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates the total revenue per category for each row using a window function, while the generated query filters to only 'Gaming' category, groups by GameName, and sums revenue per game. The generated query lacks the category-level aggregation and includes a WHERE clause restricting results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL calculates total revenue per category for all games (not just 'Gaming') using a window function, and returns duplicate category totals for each game row. The Generated SQL correctly filters to 'Gaming' category and groups by GameName to calculate per-game revenue. However, the original question's phrasing is ambiguous: if it intends 'total revenue per category' (Gaming), neither query is fully correct. If it intends 'per-game revenue' (assuming each game has a single revenue value), the Generated SQL is technically correct but redundant (SUM is unnecessary). The Reference SQL fails to filter and misrepresents the data structure.", "overall_assessment": "differently_correct"}}
{"example_id": 5039, "sql_complexity": "subqueries", "prompt": "What is the total number of community policing events in 'City Park' in 2021?", "context": "CREATE TABLE locations (id INT, name VARCHAR(255)); CREATE TABLE community_policing (id INT, location_id INT, year INT, events INT); INSERT INTO locations (id, name) VALUES (1, 'City Park'); INSERT INTO community_policing (id, location_id, year, events) VALUES (1, 1, 2021, 5);", "reference_sql": "SELECT SUM(events) FROM community_policing WHERE location_id = (SELECT id FROM locations WHERE name = 'City Park') AND year = 2021;", "generated_sql": "SELECT SUM(cp.events) AS total_events\nFROM community_policing cp\nJOIN locations l ON cp.location_id = l.id\nWHERE l.name = 'City Park' AND cp.year = 2021;", "raw_model_output": "SELECT SUM(cp.events) AS total_events\nFROM community_policing cp\nJOIN locations l ON cp.location_id = l.id\nWHERE l.name = 'City Park' AND cp.year = 2021;", "latency_sec": 0.6548459529876709, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 162, "prompt_eval_sec": null, "tokens_completion": 43, "completion_eval_sec": null, "tokens_total": 205, "tokens_per_sec": 313.05072447146915, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of events for 'City Park' in 2021. The reference query uses a subquery to get the location ID, while the generated query uses a JOIN to link locations and community_policing. Since the name 'City Park' is unique in the locations table, both approaches filter the same data and produce identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the total community policing events in 'City Park' for 2021. The reference query uses a subquery to get the location_id, while the generated query uses an explicit JOIN. Both handle the specific context where 'City Park' is unique. The JOIN version may be more readable and scalable for complex scenarios, but both produce identical results in this case. Neither query has efficiency advantages in this simplified dataset.", "overall_assessment": "correct"}}
{"example_id": 2724, "sql_complexity": "basic SQL", "prompt": "What is the earliest installation date for solar panels in Italy?", "context": "CREATE TABLE solar_panels_italy (id INT, installation_date DATE); INSERT INTO solar_panels_italy (id, installation_date) VALUES (1, '2018-01-01'), (2, '2019-01-01'), (3, '2020-01-01');", "reference_sql": "SELECT MIN(installation_date) as earliest_date FROM solar_panels_italy;", "generated_sql": "SELECT MIN(installation_date) AS earliest_installation_date\nFROM solar_panels_italy;", "raw_model_output": "SELECT MIN(installation_date) AS earliest_installation_date\nFROM solar_panels_italy;", "latency_sec": 0.5785231590270996, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 143, "prompt_eval_sec": null, "tokens_completion": 21, "completion_eval_sec": null, "tokens_total": 164, "tokens_per_sec": 283.48044056835727, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the minimum installation_date from the same table. The only difference is the column alias name ('earliest_date' vs 'earliest_installation_date'), which does not affect the semantic result as the computed value remains identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly retrieve the earliest installation date using MIN(installation_date). The reference query uses 'earliest_date' while the generated query uses 'earliest_installation_date' as the alias. The generated version's alias is more explicitly descriptive of the data it represents, improving clarity without altering functionality. Both queries are syntactically correct, semantically equivalent, and fulfill the business intent of identifying the earliest installation date.", "overall_assessment": "correct"}}
{"example_id": 2200, "sql_complexity": "single join", "prompt": "Which diversity programs are currently being participated in by employees in the HR department?", "context": "CREATE TABLE Employees (Employee_ID INT, First_Name VARCHAR(20), Last_Name VARCHAR(20), Department VARCHAR(20), Salary DECIMAL(10,2), Date_Hired DATE); CREATE TABLE Diversity_Programs (Program_ID INT, Program_Name VARCHAR(50), Participant_ID INT, Date_Started DATE, Date_Ended DATE);", "reference_sql": "SELECT dp.Program_Name FROM Diversity_Programs dp JOIN Employees e ON dp.Participant_ID = e.Employee_ID WHERE e.Department = 'HR' AND dp.Date_Ended IS NULL;", "generated_sql": "SELECT DISTINCT dp.Program_Name\nFROM Diversity_Programs dp\nJOIN Employees e ON dp.Participant_ID = e.Employee_ID\nWHERE e.Department = 'HR' AND dp.Date_Ended IS NULL;", "raw_model_output": "SELECT DISTINCT dp.Program_Name\nFROM Diversity_Programs dp\nJOIN Employees e ON dp.Participant_ID = e.Employee_ID\nWHERE e.Department = 'HR' AND dp.Date_Ended IS NULL;", "latency_sec": 0.5560898780822754, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 150, "prompt_eval_sec": null, "tokens_completion": 41, "completion_eval_sec": null, "tokens_total": 191, "tokens_per_sec": 343.4696575644934, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The generated query adds the DISTINCT keyword, which ensures unique Program_Name values. The reference query may return duplicate Program_Name entries if multiple Diversity_Programs records match the same program name for HR employees. This difference in output uniqueness makes them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because the generated query includes DISTINCT to eliminate duplicate program names, while the reference query does not. Both correctly join the tables and filter for HR employees with active programs (Date_Ended IS NULL). However, the original question asks for 'which diversity programs' (implying unique programs), making the generated query's DISTINCT clause more appropriate. The reference query might return duplicate program names if multiple HR employees are enrolled in the same program, which could mislead the interpretation. The generated query better fulfills the business intent by ensuring each program is listed once.", "overall_assessment": "differently_correct"}}
{"example_id": 4359, "sql_complexity": "window functions", "prompt": "Which destinations have the least hotel awards?", "context": "CREATE TABLE Destinations (destination_id INT, destination_name TEXT, country TEXT, awards INT); INSERT INTO Destinations (destination_id, destination_name, country, awards) VALUES (1, 'City A', 'Germany', 3), (2, 'City B', 'Switzerland', 5), (3, 'City C', 'Norway', 2);", "reference_sql": "SELECT destination_name, country, awards, RANK() OVER (PARTITION BY country ORDER BY awards ASC) AS rank FROM Destinations;", "generated_sql": "SELECT destination_name\nFROM Destinations\nWHERE awards = (SELECT MIN(awards) FROM Destinations);", "raw_model_output": "SELECT destination_name\nFROM Destinations\nWHERE awards = (SELECT MIN(awards) FROM Destinations);", "latency_sec": 0.5526058673858643, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 151, "prompt_eval_sec": null, "tokens_completion": 23, "completion_eval_sec": null, "tokens_total": 174, "tokens_per_sec": 314.87179248225794, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates rankings within each country based on awards, while the Generated SQL only selects destinations with the minimum awards value. They produce different structures and results: the first returns ranked data for all rows, the second returns only specific rows matching the minimum awards value.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query ranks destinations within each country by awards, which introduces country-level partitioning not mentioned in the original question. The generated query correctly identifies destinations with the absolute minimum awards across all destinations, aligning with the business intent of finding 'least hotel awards' without geographic constraints. While both queries are technically valid, they produce different results: the reference shows ranked lists per country, while the generated query returns all destinations sharing the global minimum. The generated query better addresses the explicit question by focusing on absolute values rather than relative rankings.", "overall_assessment": "differently_correct"}}
{"example_id": 1373, "sql_complexity": "subqueries", "prompt": "What is the total value of military equipment sales to Africa in the last 12 months?", "context": "CREATE TABLE Military_Equipment_Sales(sale_id INT, sale_date DATE, equipment_type VARCHAR(50), country VARCHAR(50), sale_value DECIMAL(10,2));", "reference_sql": "SELECT SUM(sale_value) FROM Military_Equipment_Sales WHERE country IN (SELECT country FROM World_Countries WHERE continent = 'Africa') AND sale_date >= DATE_SUB(CURRENT_DATE, INTERVAL 12 MONTH);", "generated_sql": "SELECT SUM(sale_value) AS total_sales\nFROM Military_Equipment_Sales\nWHERE country = 'Africa'\n  AND sale_date >= DATE_SUB(CURDATE(), INTERVAL 12 MONTH);", "raw_model_output": "SELECT SUM(sale_value) AS total_sales\nFROM Military_Equipment_Sales\nWHERE country = 'Africa'\n  AND sale_date >= DATE_SUB(CURDATE(), INTERVAL 12 MONTH);", "latency_sec": 0.6249790191650391, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 121, "prompt_eval_sec": null, "tokens_completion": 41, "completion_eval_sec": null, "tokens_total": 162, "tokens_per_sec": 259.2087014639774, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query uses a subquery to select countries in Africa from World_Countries, while the generated query directly filters country = 'Africa'. The generated query incorrectly assumes 'Africa' is a valid country value, whereas the reference query retrieves actual country names associated with the Africa continent. This difference in logic makes them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly identifies African countries via a subquery on World_Countries, ensuring all relevant countries are included. The Generated SQL incorrectly filters WHERE country = 'Africa', assuming 'Africa' is a valid country value (which it's not - it's a continent). This would return 0 results unless there's a malformed 'Africa' country entry. Both queries calculate SUM(sale_value) with date filtering, but the Generated SQL's logic fundamentally misinterprets the data model. The Reference SQL better fulfills the business intent of aggregating sales to African countries.", "overall_assessment": "incorrect"}}
{"example_id": 904, "sql_complexity": "basic SQL", "prompt": "What is the minimum Shariah-compliant loan amount issued in the last quarter of 2021?", "context": "CREATE TABLE loans (id INT, amount DECIMAL, date DATE, loan_type VARCHAR); INSERT INTO loans (id, amount, date, loan_type) VALUES (1, 5000, '2021-09-05', 'Shariah-compliant'), (2, 7000, '2021-10-07', 'socially responsible'), (3, 9000, '2021-11-03', 'Shariah-compliant'), (4, 11000, '2021-12-31', 'Shariah-compliant');", "reference_sql": "SELECT MIN(amount) FROM loans WHERE EXTRACT(YEAR FROM date) = 2021 AND EXTRACT(QUARTER FROM date) = 4 AND loan_type = 'Shariah-compliant';", "generated_sql": "SELECT MIN(amount) AS min_shariah_compliant_loan_amount\nFROM loans\nWHERE loan_type = 'Shariah-compliant'\n  AND date >= '2021-10-01'\n  AND date <= '2021-12-31';", "raw_model_output": "SELECT MIN(amount) AS min_shariah_compliant_loan_amount\nFROM loans\nWHERE loan_type = 'Shariah-compliant'\n  AND date >= '2021-10-01'\n  AND date <= '2021-12-31';", "latency_sec": 0.6597378253936768, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 206, "prompt_eval_sec": null, "tokens_completion": 54, "completion_eval_sec": null, "tokens_total": 260, "tokens_per_sec": 394.09594234627, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter loans with 'Shariah-compliant' type and dates in the fourth quarter of 2021. The reference query uses EXTRACT(QUARTER) = 4 and EXTRACT(YEAR) = 2021, while the generated query uses a date range from 2021-10-01 to 2021-12-31. Since the fourth quarter of 2021 corresponds exactly to October-December 2021, both conditions select the same rows. The MIN(amount) calculation will produce identical results for these rows.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify the minimum Shariah-compliant loan amount for Q4 2021. The reference query uses EXTRACT() to explicitly target the 4th quarter, while the generated query uses a date range ('2021-10-01' to '2021-12-31') which is functionally equivalent. The generated query is more efficient as date ranges can leverage indexes, and it avoids potential issues with EXTRACT() in some SQL dialects. Both satisfy the business intent, but the generated version is more elegant and performant.", "overall_assessment": "correct"}}
{"example_id": 3299, "sql_complexity": "set operations", "prompt": "How many schools and hospitals are there in Colombia and which ones need repairs?", "context": "CREATE TABLE schools (id INT, country VARCHAR(20), name VARCHAR(50), needs_repair BOOLEAN); CREATE TABLE hospitals (id INT, country VARCHAR(20), name VARCHAR(50), needs_repair BOOLEAN);", "reference_sql": "SELECT 'Schools' as facility_type, COUNT(*) as total, SUM(needs_repair) as repairs_needed FROM schools WHERE country = 'Colombia' UNION ALL SELECT 'Hospitals' as facility_type, COUNT(*) as total, SUM(needs_repair) as repairs_needed FROM hospitals WHERE country = 'Colombia';", "generated_sql": "SELECT \n    (SELECT COUNT(*) FROM schools WHERE country = 'Colombia' AND needs_repair = TRUE) AS schools_needing_repairs,\n    (SELECT COUNT(*) FROM hospitals WHERE country = 'Colombia' AND needs_repair = TRUE) AS hospitals_needing_repairs,\n    (SELECT COUNT(*) FROM schools WHERE country = 'Colombia') AS total_schools,\n    (SELECT COUNT(*) FROM hospitals WHERE country = 'Colombia') AS total_hospitals;", "raw_model_output": "SELECT \n    (SELECT COUNT(*) FROM schools WHERE country = 'Colombia' AND needs_repair = TRUE) AS schools_needing_repairs,\n    (SELECT COUNT(*) FROM hospitals WHERE country = 'Colombia' AND needs_repair = TRUE) AS hospitals_needing_repairs,\n    (SELECT COUNT(*) FROM schools WHERE country = 'Colombia') AS total_schools,\n    (SELECT COUNT(*) FROM hospitals WHERE country = 'Colombia') AS total_hospitals;", "latency_sec": 1.161252737045288, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 126, "prompt_eval_sec": null, "tokens_completion": 99, "completion_eval_sec": null, "tokens_total": 225, "tokens_per_sec": 193.7562709841218, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries have different structures and outputs. The Reference SQL returns two rows (Schools/Hospitals) with columns facility_type, total, repairs_needed, while the Generated SQL returns a single row with four separate columns for schools/hospitals needing repairs and total counts. The data is related but structured differently, so they are not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent due to differences in output structure. The reference query returns two rows (one per facility type) with columns for total facilities and repairs needed, while the generated query returns a single row with four separate columns. Both correctly count facilities and repairs, but the reference better fulfills the business intent by explicitly separating schools and hospitals in distinct rows, making the results more interpretable. The generated query's compact format may obscure the relationship between facility types. Neither query addresses the 'which ones' part of the question (i.e., listing specific facilities needing repairs), but both answer the counting aspects correctly.", "overall_assessment": "differently_correct"}}
{"example_id": 907, "sql_complexity": "set operations", "prompt": "What is the total quantity of items with type 'E' or type 'F' in warehouse O and warehouse P?", "context": "CREATE TABLE warehouse_o(item_id INT, item_type VARCHAR(10), quantity INT);CREATE TABLE warehouse_p(item_id INT, item_type VARCHAR(10), quantity INT);INSERT INTO warehouse_o(item_id, item_type, quantity) VALUES (1, 'E', 200), (2, 'F', 300), (3, 'E', 50), (4, 'F', 400);INSERT INTO warehouse_p(item_id, item_type, quantity) VALUES (1, 'E', 150), (2, 'F', 250), (3, 'E', 40), (4, 'F', 350);", "reference_sql": "SELECT quantity FROM warehouse_o WHERE item_type IN ('E', 'F') UNION ALL SELECT quantity FROM warehouse_p WHERE item_type IN ('E', 'F');", "generated_sql": "SELECT \n    SUM(quantity) AS total_quantity\nFROM (\n    SELECT quantity FROM warehouse_o WHERE item_type IN ('E', 'F')\n    UNION ALL\n    SELECT quantity FROM warehouse_p WHERE item_type IN ('E', 'F')\n) AS combined;", "raw_model_output": "SELECT \n    SUM(quantity) AS total_quantity\nFROM (\n    SELECT quantity FROM warehouse_o WHERE item_type IN ('E', 'F')\n    UNION ALL\n    SELECT quantity FROM warehouse_p WHERE item_type IN ('E', 'F')\n) AS combined;", "latency_sec": 0.6728391647338867, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 223, "prompt_eval_sec": null, "tokens_completion": 53, "completion_eval_sec": null, "tokens_total": 276, "tokens_per_sec": 410.2020430234025, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns individual quantity values from both tables using UNION ALL, producing multiple rows. The Generated SQL aggregates all quantities into a single summed value. The first returns a list of quantities, while the second returns a single total, making their result sets structurally and semantically different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query returns individual quantities from both warehouses without aggregation, while the generated query properly sums all qualifying quantities. The original question explicitly asks for 'total quantity,' which requires aggregation. The generated query correctly combines results from both warehouses using UNION ALL and sums them, whereas the reference query only retrieves raw data. The generated query is both technically correct and aligned with the business intent, while the reference query fails to fulfill the requirement for a total value.", "overall_assessment": "correct"}}
{"example_id": 1400, "sql_complexity": "single join", "prompt": "What is the maximum co-ownership duration for properties in the neighborhood of 'Chinatown' in San Francisco?'", "context": "CREATE TABLE sf_neighborhoods (neighborhood_id INT, name VARCHAR(255), city VARCHAR(255)); INSERT INTO sf_neighborhoods (neighborhood_id, name, city) VALUES (1, 'Chinatown', 'San Francisco'); CREATE TABLE co_ownership (co_ownership_id INT, property_id INT, co_owner_id INT, start_date DATE, end_date DATE); INSERT INTO co_ownership (co_ownership_id, property_id, co_owner_id, start_date, end_date) VALUES (1, 1, 2, '2010-01-01', '2020-01-01'), (2, 2, 3, '2015-01-01', '2022-01-01'); CREATE TABLE properties (property_id INT, city VARCHAR(255)); INSERT INTO properties (property_id, city) VALUES (1, 'San Francisco'), (2, 'San Francisco');", "reference_sql": "SELECT MAX(DATEDIFF(end_date, start_date)) as max_duration FROM co_ownership JOIN properties ON co_ownership.property_id = properties.property_id WHERE properties.city = 'San Francisco' AND name = 'Chinatown';", "generated_sql": "SELECT MAX(DATEDIFF(end_date, start_date)) AS max_co_ownership_duration\nFROM co_ownership\nJOIN properties ON co_ownership.property_id = properties.property_id\nJOIN sf_neighborhoods ON properties.city = sf_neighborhoods.city\nWHERE sf_neighborhoods.name = 'Chinatown' AND sf_neighborhoods.city = 'San Francisco';", "raw_model_output": "SELECT MAX(DATEDIFF(end_date, start_date)) AS max_co_ownership_duration\nFROM co_ownership\nJOIN properties ON co_ownership.property_id = properties.property_id\nJOIN sf_neighborhoods ON properties.city = sf_neighborhoods.city\nWHERE sf_neighborhoods.name = 'Chinatown' AND sf_neighborhoods.city = 'San Francisco';", "latency_sec": 0.7978267669677734, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 280, "prompt_eval_sec": null, "tokens_completion": 74, "completion_eval_sec": null, "tokens_total": 354, "tokens_per_sec": 443.7053438873894, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references a 'name' column in the WHERE clause, but this column exists only in sf_neighborhoods, which is not joined in the Reference SQL. The Generated SQL correctly joins sf_neighborhoods to access the 'name' column. The Reference SQL would result in an error due to an invalid column reference, making the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query is technically incorrect because it references 'name' in the WHERE clause without joining the sf_neighborhoods table, which contains the 'name' column. The generated query correctly joins sf_neighborhoods on properties.city = sf_neighborhoods.city, ensuring proper filtering by neighborhood name. Both queries calculate max duration correctly, but the generated query properly addresses the business intent of filtering properties in 'Chinatown' by including the necessary join. The reference query would fail or return incorrect results due to the missing join.", "overall_assessment": "differently_correct"}}
{"example_id": 5248, "sql_complexity": "window functions", "prompt": "Find the top 5 games by rating", "context": "CREATE TABLE games (game_id INT PRIMARY KEY, name VARCHAR(50), genre VARCHAR(50), rating DECIMAL(3,2));", "reference_sql": "SELECT * FROM (SELECT name, rating, ROW_NUMBER() OVER (ORDER BY rating DESC) as rn FROM games) t WHERE rn <= 5;", "generated_sql": "SELECT name, genre, rating\nFROM games\nORDER BY rating DESC\nLIMIT 5;", "raw_model_output": "SELECT name, genre, rating\nFROM games\nORDER BY rating DESC\nLIMIT 5;", "latency_sec": 0.4749469757080078, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 104, "prompt_eval_sec": null, "tokens_completion": 20, "completion_eval_sec": null, "tokens_total": 124, "tokens_per_sec": 261.081776160701, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in selected columns and output structure. The Reference SQL includes a 'rn' (row number) column and excludes 'genre', while the Generated SQL includes 'genre' and omits 'rn'. Both retrieve top 5 games by rating, but their result schemas differ.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in three key aspects: 1) Column selection - the reference query returns name, rating, and row number, while the generated query returns name, genre, and rating. 2) Handling of ties - the reference query uses ROW_NUMBER() (unique ranks) while the generated query uses simple ordering (could return ties). 3) Efficiency - the generated query is simpler with direct ordering and limiting. Both fulfill the business intent of finding top-rated games, but the generated query is more efficient and returns more business-relevant columns (genre). The reference query's row number column is unnecessary for the original question.", "overall_assessment": "differently_correct"}}
{"example_id": 778, "sql_complexity": "single join", "prompt": "What is the maximum property price in wheelchair-accessible neighborhoods in Singapore?", "context": "CREATE TABLE Singapore_Neighborhoods (Neighborhood_Name TEXT, Wheelchair_Accessibility BOOLEAN); INSERT INTO Singapore_Neighborhoods (Neighborhood_Name, Wheelchair_Accessibility) VALUES ('Orchard', true), ('Marina Bay', true), ('Chinatown', false), ('Little India', false), ('Bugis', true); CREATE TABLE Singapore_Properties (Neighborhood_Name TEXT, Property_Price INTEGER); INSERT INTO Singapore_Properties (Neighborhood_Name, Property_Price) VALUES ('Orchard', 2000000), ('Marina Bay', 3000000), ('Chinatown', 1500000), ('Little India', 1200000), ('Bugis', 1800000);", "reference_sql": "SELECT MAX(Singapore_Properties.Property_Price) FROM Singapore_Properties INNER JOIN Singapore_Neighborhoods ON Singapore_Properties.Neighborhood_Name = Singapore_Neighborhoods.Neighborhood_Name WHERE Singapore_Neighborhoods.Wheelchair_Accessibility = true;", "generated_sql": "SELECT MAX(Property_Price) AS Max_Price\nFROM Singapore_Properties sp\nJOIN Singapore_Neighborhoods sn ON sp.Neighborhood_Name = sn.Neighborhood_Name\nWHERE sn.Wheelchair_Accessibility = TRUE;", "raw_model_output": "SELECT MAX(Property_Price) AS Max_Price\nFROM Singapore_Properties sp\nJOIN Singapore_Neighborhoods sn ON sp.Neighborhood_Name = sn.Neighborhood_Name\nWHERE sn.Wheelchair_Accessibility = TRUE;", "latency_sec": 0.6181619167327881, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 226, "prompt_eval_sec": null, "tokens_completion": 47, "completion_eval_sec": null, "tokens_total": 273, "tokens_per_sec": 441.63186474331013, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the maximum property price from Singapore_Properties where the corresponding neighborhood has wheelchair accessibility enabled. The generated query uses table aliases and shorter column references, but the join condition, filter, and aggregation logic are identical. The result will be the same maximum value.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly identify the maximum property price in wheelchair-accessible neighborhoods by joining the two tables on Neighborhood_Name and filtering where Wheelchair_Accessibility = true. The Reference SQL uses explicit table names without aliases, while the Generated SQL employs table aliases (sp and sn) and adds an alias (Max_Price) for the result. These are stylistic differences that do not affect functionality. Both queries would return the same result (3,000,000 from Marina Bay) and are equally efficient. The Generated SQL is slightly more concise and readable due to aliases, but neither query has a clear technical advantage over the other.", "overall_assessment": "correct"}}
{"example_id": 3859, "sql_complexity": "aggregation", "prompt": "What is the total number of mental health parity violations by month and year?", "context": "CREATE TABLE mental_health_parity_reports (report_id INT, violation_date DATE); INSERT INTO mental_health_parity_reports (report_id, violation_date) VALUES (1, '2022-01-01'), (2, '2022-02-15'), (3, '2022-03-05'), (4, '2022-04-20'), (5, '2021-06-12'), (6, '2021-07-28');", "reference_sql": "SELECT EXTRACT(MONTH FROM violation_date) AS month, EXTRACT(YEAR FROM violation_date) AS year, COUNT(*) FROM mental_health_parity_reports GROUP BY month, year;", "generated_sql": "SELECT \n    EXTRACT(YEAR FROM violation_date) AS year,\n    EXTRACT(MONTH FROM violation_date) AS month,\n    COUNT(*) AS total_violations\nFROM \n    mental_health_parity_reports\nGROUP BY \n    year, month\nORDER BY \n    year, month;", "raw_model_output": "SELECT \n    EXTRACT(YEAR FROM violation_date) AS year,\n    EXTRACT(MONTH FROM violation_date) AS month,\n    COUNT(*) AS total_violations\nFROM \n    mental_health_parity_reports\nGROUP BY \n    year, month\nORDER BY \n    year, month;", "latency_sec": 0.7288620471954346, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 179, "prompt_eval_sec": null, "tokens_completion": 62, "completion_eval_sec": null, "tokens_total": 241, "tokens_per_sec": 330.652420341183, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries group by year and month, count violations, and return the same data. The generated query adds an ORDER BY clause, but semantic equivalence focuses on result content, not row order. Column aliases differ but do not affect the underlying data.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly group violations by month and year, using EXTRACT functions to isolate date components. The reference query uses implicit column ordering in GROUP BY, while the generated query explicitly names columns and adds ORDER BY, which improves readability and ensures consistent output ordering. The generated query's explicit 'total_violations' alias also enhances clarity compared to the reference's implicit COUNT(*). Though the reference is technically correct, the generated query better addresses the business intent through improved readability and structured output.", "overall_assessment": "correct"}}
{"example_id": 3551, "sql_complexity": "multiple_joins", "prompt": "List all artists who have performed in New York and Chicago, along with their highest-earning performance.", "context": "CREATE TABLE artist_events (artist_id INT, event_id INT, earnings DECIMAL(5,2)); CREATE TABLE artists (id INT, name VARCHAR(50)); CREATE TABLE events (id INT, city VARCHAR(20));", "reference_sql": "SELECT artists.name, MAX(artist_events.earnings) FROM artists INNER JOIN artist_events ON artists.id = artist_events.artist_id INNER JOIN events ON artist_events.event_id = events.id WHERE city IN ('New York', 'Chicago') GROUP BY artists.name;", "generated_sql": "SELECT a.id, a.name, MAX(ae.earnings) AS highest_earning\nFROM artists a\nJOIN artist_events ae ON a.id = ae.artist_id\nJOIN events e ON ae.event_id = e.id\nWHERE e.city IN ('New York', 'Chicago')\nGROUP BY a.id, a.name\nHAVING COUNT(DISTINCT e.city) = 2;", "raw_model_output": "SELECT a.id, a.name, MAX(ae.earnings) AS highest_earning\nFROM artists a\nJOIN artist_events ae ON a.id = ae.artist_id\nJOIN events e ON ae.event_id = e.id\nWHERE e.city IN ('New York', 'Chicago')\nGROUP BY a.id, a.name\nHAVING COUNT(DISTINCT e.city) = 2;", "latency_sec": 0.7386488914489746, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 132, "prompt_eval_sec": null, "tokens_completion": 79, "completion_eval_sec": null, "tokens_total": 211, "tokens_per_sec": 285.6566935152244, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. 1) The Generated SQL includes a HAVING clause that filters for artists with events in *both* New York and Chicago (COUNT(DISTINCT e.city) = 2), while the Reference SQL includes artists with events in *either* city. 2) The Generated SQL groups by a.id and a.name, while the Reference SQL groups by artists.name only. This could lead to different results if there are artists with the same name but different IDs.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL is technically incorrect for the business question. It lacks the HAVING clause to ensure artists performed in *both* cities, instead including any artist who performed in either city. The Generated SQL correctly filters artists with performances in both cities using COUNT(DISTINCT e.city) = 2. While both queries retrieve highest earnings, only the Generated SQL enforces the dual-city requirement. The Reference SQL's GROUP BY on name (which may not be unique) could also lead to incorrect aggregations. The Generated SQL is more precise and aligns with the business intent.", "overall_assessment": "differently_correct"}}
{"example_id": 5168, "sql_complexity": "aggregation", "prompt": "Get the number of renewable energy projects in Australia for each project type.", "context": "CREATE TABLE renewable_projects (id INT PRIMARY KEY, project_name VARCHAR(255), project_location VARCHAR(255), project_type VARCHAR(255), capacity_mw FLOAT);", "reference_sql": "SELECT project_type, COUNT(*) FROM renewable_projects WHERE project_location = 'Australia' GROUP BY project_type;", "generated_sql": "SELECT \n    project_type, \n    COUNT(*) AS project_count\nFROM \n    renewable_projects\nWHERE \n    project_location = 'Australia'\nGROUP BY \n    project_type;", "raw_model_output": "SELECT \n    project_type, \n    COUNT(*) AS project_count\nFROM \n    renewable_projects\nWHERE \n    project_location = 'Australia'\nGROUP BY \n    project_type;", "latency_sec": 0.6306703090667725, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 114, "prompt_eval_sec": null, "tokens_completion": 37, "completion_eval_sec": null, "tokens_total": 151, "tokens_per_sec": 239.42779266625158, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select project_type and count the number of projects in Australia, grouping by project_type. The generated query adds an alias (project_count) for the count column, but this does not affect the semantic result set content. The WHERE condition, GROUP BY clause, and aggregate function are identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically correct and produce identical results. The reference query returns project_type and COUNT(*) without an alias, while the generated query adds an explicit alias (project_count) for the count column. This makes the generated query more readable and semantically clearer, as the alias directly indicates the meaning of the aggregated value. Both satisfy the business intent of counting projects by type in Australia, but the generated query's explicit alias improves clarity without altering functionality.", "overall_assessment": "correct"}}
{"example_id": 4916, "sql_complexity": "aggregation", "prompt": "What is the maximum revenue generated from selling Yttrium in India in the past 3 years?", "context": "CREATE TABLE Yttrium_Sales (id INT PRIMARY KEY, year INT, country VARCHAR(20), quantity INT, price PER_KG); INSERT INTO Yttrium_Sales (id, year, country, quantity, price) VALUES (1, 2019, 'India', 120, 40), (2, 2020, 'India', 130, 45), (3, 2021, 'India', 140, 50), (4, 2019, 'China', 150, 35), (5, 2020, 'China', 160, 40), (6, 2021, 'China', 170, 45);", "reference_sql": "SELECT MAX(quantity * price) FROM Yttrium_Sales WHERE country = 'India' GROUP BY year ORDER BY year DESC LIMIT 3;", "generated_sql": "SELECT MAX(quantity * price) AS max_revenue\nFROM Yttrium_Sales\nWHERE country = 'India' AND year >= (SELECT MAX(year) FROM Yttrium_Sales) - 2;", "raw_model_output": "SELECT MAX(quantity * price) AS max_revenue\nFROM Yttrium_Sales\nWHERE country = 'India' AND year >= (SELECT MAX(year) FROM Yttrium_Sales) - 2;", "latency_sec": 0.6312520503997803, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 234, "prompt_eval_sec": null, "tokens_completion": 46, "completion_eval_sec": null, "tokens_total": 280, "tokens_per_sec": 443.56291567318044, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns the maximum revenue (quantity * price) per year for India, grouped by year and ordered descendingly with a limit of 3. The Generated SQL calculates the maximum revenue across all entries in the last 3 years (based on a subquery) without grouping, resulting in a single value. The Reference SQL produces multiple rows (one per year), while the Generated SQL returns a single row, making them semantically different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL groups by year and returns the maximum revenue per year, but the query structure (GROUP BY + ORDER BY + LIMIT 3) would return three separate values (one per year) rather than a single maximum value across the three years. The Generated SQL correctly filters the last three years (2019-2021) and calculates the absolute maximum revenue from any single sale within that period. While both queries technically return the same maximum value (7000) from the sample data, the Generated SQL better aligns with the business intent of finding the 'maximum revenue' across the entire 3-year period rather than per-year maxima. The Reference SQL's grouping and ordering are unnecessary for the question's requirements.", "overall_assessment": "differently_correct"}}
{"example_id": 812, "sql_complexity": "multiple_joins", "prompt": "What is the average salary of 'engineer' workers in each factory?", "context": "CREATE TABLE factories (factory_id INT, factory_name VARCHAR(20)); INSERT INTO factories VALUES (1, 'Factory X'), (2, 'Factory Y'), (3, 'Factory Z'); CREATE TABLE roles (role_id INT, role_name VARCHAR(20)); INSERT INTO roles VALUES (1, 'engineer'), (2, 'manager'), (3, 'assistant'); CREATE TABLE workers (worker_id INT, factory_id INT, role_id INT, salary DECIMAL(5,2)); INSERT INTO workers VALUES (1, 1, 1, 50000.00), (2, 1, 2, 70000.00), (3, 2, 1, 55000.00), (4, 2, 3, 40000.00), (5, 3, 1, 60000.00);", "reference_sql": "SELECT f.factory_name, AVG(salary) FROM workers w INNER JOIN factories f ON w.factory_id = f.factory_id INNER JOIN roles r ON w.role_id = r.role_id WHERE r.role_name = 'engineer' GROUP BY f.factory_name;", "generated_sql": "SELECT \n    f.factory_name,\n    AVG(w.salary) AS average_salary\nFROM \n    workers w\nJOIN \n    factories f ON w.factory_id = f.factory_id\nJOIN \n    roles r ON w.role_id = r.role_id\nWHERE \n    r.role_name = 'engineer'\nGROUP BY \n    f.factory_name;", "raw_model_output": "SELECT \n    f.factory_name,\n    AVG(w.salary) AS average_salary\nFROM \n    workers w\nJOIN \n    factories f ON w.factory_id = f.factory_id\nJOIN \n    roles r ON w.role_id = r.role_id\nWHERE \n    r.role_name = 'engineer'\nGROUP BY \n    f.factory_name;", "latency_sec": 1.4441778659820557, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 261, "prompt_eval_sec": null, "tokens_completion": 70, "completion_eval_sec": null, "tokens_total": 331, "tokens_per_sec": 229.1961452926137, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the average salary of engineers per factory. They use identical JOIN conditions, WHERE clauses, and GROUP BY logic. The only difference is the alias name for the average salary column ('average_salary' vs. implicit name), which doesn't affect the semantic result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically correct and semantically equivalent. They both join the workers, factories, and roles tables; filter for 'engineer' roles; group by factory name; and calculate the average salary. The reference query uses implicit join syntax while the generated query uses explicit aliases, but both produce identical results. Both correctly address the business intent of calculating average engineer salaries per factory. The generated query has slightly better formatting with consistent indentation and explicit aliases, but neither query has significant efficiency advantages over the other.", "overall_assessment": "correct"}}
{"example_id": 5784, "sql_complexity": "set operations", "prompt": "List the number of users who have completed a workout of a specific type (e.g. Running) and have a membership status of 'Active'.", "context": "CREATE TABLE workouts (id INT, user_id INT, workout_type VARCHAR(20)); CREATE TABLE members (id INT, name VARCHAR(50), membership_status VARCHAR(20), state VARCHAR(20)); INSERT INTO workouts (id, user_id, workout_type) VALUES (1, 1, 'Running'), (2, 1, 'Cycling'), (3, 2, 'Running'), (4, 3, 'Cycling'), (5, 3, 'Swimming'), (6, 4, 'Running'), (7, 4, 'Swimming'); INSERT INTO members (id, name, membership_status, state) VALUES (1, 'John Doe', 'Active', 'Texas'), (2, 'Jane Doe', 'Inactive', 'California'), (3, 'Bob Smith', 'Active', 'Texas'), (4, 'Alice Johnson', 'Active', 'California');", "reference_sql": "SELECT COUNT(*) FROM (SELECT user_id FROM workouts WHERE workout_type = 'Running' INTERSECT SELECT id FROM members WHERE membership_status = 'Active') AS user_set;", "generated_sql": "SELECT COUNT(DISTINCT w.user_id) AS user_count\nFROM workouts w\nJOIN members m ON w.user_id = m.id\nWHERE w.workout_type = 'Running' AND m.membership_status = 'Active';", "raw_model_output": "SELECT COUNT(DISTINCT w.user_id) AS user_count\nFROM workouts w\nJOIN members m ON w.user_id = m.id\nWHERE w.workout_type = 'Running' AND m.membership_status = 'Active';", "latency_sec": 0.6574349403381348, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 280, "prompt_eval_sec": null, "tokens_completion": 47, "completion_eval_sec": null, "tokens_total": 327, "tokens_per_sec": 497.38761957466994, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of unique user_ids that have at least one 'Running' workout and are active members. The Reference SQL uses INTERSECT to find common user_ids between the two sets, while the Generated SQL uses a JOIN to combine matching rows and COUNT(DISTINCT) to ensure uniqueness. Both approaches yield the same result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count users with 'Running' workouts and active memberships. The Reference SQL uses INTERSECT to find overlapping user_ids between workouts and members, while the Generated SQL uses a JOIN with COUNT(DISTINCT). They produce identical results because INTERSECT implicitly removes duplicates, and COUNT(DISTINCT) achieves the same outcome. However, the Generated SQL is more efficient and readable, as JOINs are standard for relational data and avoid the overhead of set operations. Both fulfill the business intent, but the Generated query is superior in elegance and performance.", "overall_assessment": "correct"}}
{"example_id": 3038, "sql_complexity": "subqueries", "prompt": "What is the total assets of clients who have invested in mutual funds but not in stocks?", "context": "CREATE TABLE clients (client_id INT, name TEXT, age INT, gender TEXT, total_assets DECIMAL(10,2)); INSERT INTO clients VALUES (1, 'John Doe', 35, 'Male', 250000.00), (2, 'Jane Smith', 45, 'Female', 500000.00); CREATE TABLE investments (client_id INT, investment_type TEXT); INSERT INTO investments VALUES (1, 'Stocks'), (1, 'Bonds'), (2, 'Stocks'), (3, 'Mutual Funds');", "reference_sql": "SELECT c.total_assets FROM clients c INNER JOIN investments i ON c.client_id = i.client_id WHERE i.investment_type = 'Mutual Funds' AND c.client_id NOT IN (SELECT client_id FROM investments WHERE investment_type = 'Stocks');", "generated_sql": "SELECT SUM(total_assets) AS total_assets\nFROM clients\nWHERE client_id IN (\n    SELECT client_id FROM investments WHERE investment_type = 'Mutual Funds'\n)\nAND client_id NOT IN (\n    SELECT client_id FROM investments WHERE investment_type = 'Stocks'\n);", "raw_model_output": "SELECT SUM(total_assets) AS total_assets\nFROM clients\nWHERE client_id IN (\n    SELECT client_id FROM investments WHERE investment_type = 'Mutual Funds'\n)\nAND client_id NOT IN (\n    SELECT client_id FROM investments WHERE investment_type = 'Stocks'\n);", "latency_sec": 0.9495000839233398, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 196, "prompt_eval_sec": null, "tokens_completion": 54, "completion_eval_sec": null, "tokens_total": 250, "tokens_per_sec": 263.29644855532666, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL selects individual client total_assets values, while the Generated SQL returns a single summed value. The Reference query returns multiple rows (if matches exist) with raw asset values, whereas the Generated query aggregates all matching assets into one summed value. This difference in output structure makes them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ fundamentally in their output. The reference query returns individual client assets (not aggregated), while the generated query correctly uses SUM() to calculate total assets. Both filter clients with mutual funds and without stocks, but the generated query addresses the 'total' requirement in the original question. The reference query would return multiple rows of individual asset values rather than a single aggregated total. The generated query is more efficient as it avoids joins and directly uses subqueries with proper aggregation.", "overall_assessment": "differently_correct"}}
{"example_id": 1078, "sql_complexity": "basic SQL", "prompt": "What is the maximum and minimum temperature difference between any two Arctic research stations?", "context": "CREATE TABLE arctic_stations (id INT, name TEXT, location TEXT, temperature DECIMAL(5,2)); INSERT INTO arctic_stations (id, name, location, temperature) VALUES (1, 'Station A', 'Greenland', 2.3), (2, 'Station B', 'Canada', -5.2);", "reference_sql": "SELECT a.name as station1, b.name as station2, MAX(ABS(a.temperature - b.temperature)) as temp_diff FROM arctic_stations a, arctic_stations b ORDER BY temp_diff DESC LIMIT 1", "generated_sql": "SELECT \n    MAX(temperature) - MIN(temperature) AS temperature_difference\nFROM \n    arctic_stations;", "raw_model_output": "SELECT \n    MAX(temperature) - MIN(temperature) AS temperature_difference\nFROM \n    arctic_stations;", "latency_sec": 0.6623039245605469, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 153, "prompt_eval_sec": null, "tokens_completion": 25, "completion_eval_sec": null, "tokens_total": 178, "tokens_per_sec": 268.75878792067687, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the maximum temperature difference between any two stations (including station names), while the Generated SQL computes the overall temperature range (max - min) without station identifiers. Though both capture the maximum temperature difference value, their result structures differ (station names vs. single value), making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference SQL calculates the maximum temperature difference between any two stations but does not address the 'minimum' component of the question. It also returns station names and requires a self-join, which is inefficient. The generated SQL correctly computes the maximum temperature difference (MAX(temperature) - MIN(temperature)) but also fails to address the minimum difference. However, the generated query is more efficient and technically correct for the maximum difference, while the reference query's structure is flawed (e.g., it would return multiple rows if multiple pairs have the same max difference). Neither query fully answers the original question, but the generated query better addresses the maximum difference aspect with simpler logic.", "overall_assessment": "differently_correct"}}
{"example_id": 5015, "sql_complexity": "basic SQL", "prompt": "Calculate the average recycling rate", "context": "CREATE TABLE recycling_rates (id INT PRIMARY KEY, location VARCHAR(50), rate FLOAT);", "reference_sql": "SELECT AVG(rate) FROM recycling_rates;", "generated_sql": "SELECT AVG(rate) AS average_recycling_rate FROM recycling_rates;", "raw_model_output": "SELECT AVG(rate) AS average_recycling_rate FROM recycling_rates;", "latency_sec": 0.6609170436859131, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 91, "prompt_eval_sec": null, "tokens_completion": 14, "completion_eval_sec": null, "tokens_total": 105, "tokens_per_sec": 158.8701653303089, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average of the 'rate' column from the recycling_rates table. The generated query adds an alias ('average_recycling_rate') to the result, but this does not affect the computed value. The semantic result (the average value) remains identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the average recycling rate using the AVG() function. The reference query is more concise, while the generated query adds an explicit alias (average_recycling_rate) for clarity. Since the original question only requires the calculation without specifying output column naming, both achieve the same technical result and business intent. The difference is purely stylistic and does not affect correctness or efficiency.", "overall_assessment": "correct"}}
{"example_id": 1533, "sql_complexity": "subqueries", "prompt": "Which programs had the highest volunteer participation rate in the last quarter?", "context": "CREATE TABLE Programs (ProgramID INT, ProgramName TEXT, Budget DECIMAL(10,2), NumVolunteers INT); CREATE TABLE VolunteerEvents (EventID INT, ProgramID INT, EventDate DATE, NumVolunteers INT);", "reference_sql": "SELECT p.ProgramName, COUNT(v.EventID) / (SELECT COUNT(*) FROM VolunteerEvents WHERE EventDate >= DATEADD(quarter, -1, GETDATE())) * 100.0 AS VolunteerParticipationRate FROM Programs p INNER JOIN VolunteerEvents v ON p.ProgramID = v.ProgramID WHERE v.EventDate >= DATEADD(quarter, -1, GETDATE()) GROUP BY p.ProgramName ORDER BY VolunteerParticipationRate DESC;", "generated_sql": "SELECT \n    p.ProgramID, \n    p.ProgramName, \n    p.Budget, \n    p.NumVolunteers\nFROM \n    Programs p\nJOIN \n    VolunteerEvents ve ON p.ProgramID = ve.ProgramID\nWHERE \n    ve.EventDate >= DATE_SUB(CURRENT_DATE, INTERVAL 3 MONTH)\nGROUP BY \n    p.ProgramID, p.ProgramName, p.Budget, p.NumVolunteers\nHAVING \n    p.NumVolunteers = (\n        SELECT MAX(p2.NumVolunteers)\n        FROM Programs p2\n        JOIN VolunteerEvents ve2 ON p2.ProgramID = ve2.ProgramID\n        WHERE ve2.EventDate >= DATE_SUB(CURRENT_DATE, INTERVAL 3 MONTH)\n    );", "raw_model_output": "SELECT \n    p.ProgramID, \n    p.ProgramName, \n    p.Budget, \n    p.NumVolunteers\nFROM \n    Programs p\nJOIN \n    VolunteerEvents ve ON p.ProgramID = ve.ProgramID\nWHERE \n    ve.EventDate >= DATE_SUB(CURRENT_DATE, INTERVAL 3 MONTH)\nGROUP BY \n    p.ProgramID, p.ProgramName, p.Budget, p.NumVolunteers\nHAVING \n    p.NumVolunteers = (\n        SELECT MAX(p2.NumVolunteers)\n        FROM Programs p2\n        JOIN VolunteerEvents ve2 ON p2.ProgramID = ve2.ProgramID\n        WHERE ve2.EventDate >= DATE_SUB(CURRENT_DATE, INTERVAL 3 MONTH)\n    );", "latency_sec": 1.640458106994629, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 127, "prompt_eval_sec": null, "tokens_completion": 151, "completion_eval_sec": null, "tokens_total": 278, "tokens_per_sec": 169.46485790442085, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries have different purposes and structures. The reference query calculates a participation rate by comparing event counts in the last quarter, while the generated query filters programs with maximum NumVolunteers in the same period. They differ in selected columns, aggregation logic, and filtering conditions.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query attempts to calculate a participation rate by comparing program-specific event counts to total events in the last quarter, while the generated query incorrectly focuses on static program attributes (NumVolunteers) rather than calculating a rate. Neither query accurately addresses the 'volunteer participation rate' metric, but the reference query at least attempts to compute a rate (albeit based on events instead of volunteers). The generated query's HAVING clause compares program-level NumVolunteers to a subquery result, which is unrelated to participation rates. The reference query's structure is more aligned with the intent of measuring participation, even if the metric is flawed.", "overall_assessment": "differently_correct"}}
{"example_id": 4021, "sql_complexity": "subqueries", "prompt": "What is the percentage of energy efficiency improvement, per sector, compared to 2015 levels?", "context": "CREATE TABLE energy_efficiency (id INT, sector VARCHAR(50), year INT, efficiency FLOAT); INSERT INTO energy_efficiency (id, sector, year, efficiency) VALUES (1, 'Industry', 2015, 100.0), (2, 'Industry', 2020, 105.0), (3, 'Residential', 2015, 100.0), (4, 'Residential', 2020, 103.0);", "reference_sql": "SELECT sector, (SUM(efficiency) / (SELECT SUM(efficiency) FROM energy_efficiency WHERE year = 2015 AND sector = e.sector) * 100.0) - 100.0 AS improvement FROM energy_efficiency e WHERE year = 2020 GROUP BY sector;", "generated_sql": "SELECT \n    sector,\n    ((MAX(CASE WHEN year = 2020 THEN efficiency END) - MAX(CASE WHEN year = 2015 THEN efficiency END)) / MAX(CASE WHEN year = 2015 THEN efficiency END)) * 100 AS efficiency_improvement_percentage\nFROM \n    energy_efficiency\nWHERE \n    year IN (2015, 2020)\nGROUP BY \n    sector;", "raw_model_output": "SELECT \n    sector,\n    ((MAX(CASE WHEN year = 2020 THEN efficiency END) - MAX(CASE WHEN year = 2015 THEN efficiency END)) / MAX(CASE WHEN year = 2015 THEN efficiency END)) * 100 AS efficiency_improvement_percentage\nFROM \n    energy_efficiency\nWHERE \n    year IN (2015, 2020)\nGROUP BY \n    sector;", "latency_sec": 0.8712210655212402, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 181, "prompt_eval_sec": null, "tokens_completion": 84, "completion_eval_sec": null, "tokens_total": 265, "tokens_per_sec": 304.1707902706117, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the percentage improvement in efficiency from 2015 to 2020 for each sector. In the given data, each sector has exactly one entry per year, so the SUM in the Reference SQL equals the single value, and the MAX in the Generated SQL also equals the single value. Thus, both queries produce the same results for the provided data.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries produce the same numerical results for the sample data. However, the Generated SQL is more robust and semantically precise. The Reference SQL uses SUM(efficiency) which assumes efficiency is additive (e.g., multiple entries per sector/year), while the Generated SQL explicitly retrieves individual 2020 and 2015 values using CASE statements. The Generated SQL directly calculates percentage change [(2020 - 2015)/2015 * 100] which matches the business intent of comparing to 2015 levels. The Reference SQL's approach of (SUM/2015_SUM * 100) - 100 is mathematically equivalent but less intuitive for this specific question. Both are technically correct for the sample data, but the Generated SQL better handles edge cases and clearly expresses the business logic.", "overall_assessment": "correct"}}
{"example_id": 1551, "sql_complexity": "single join", "prompt": "How many unique donors made donations in the healthcare industry in Q3 2022?", "context": "CREATE TABLE donations (id INT, donor_id INT, amount FLOAT, donation_date DATE); INSERT INTO donations (id, donor_id, amount, donation_date) VALUES (1, 7, 100, '2022-07-01'); INSERT INTO donations (id, donor_id, amount, donation_date) VALUES (2, 8, 200, '2022-09-15'); INSERT INTO donors (id, name, industry, first_donation_date DATE) VALUES (7, 'Charlie Davis', 'Healthcare', '2022-07-01'); INSERT INTO donors (id, name, industry, first_donation_date DATE) VALUES (8, 'Dana Wilson', 'Healthcare', '2022-09-15');", "reference_sql": "SELECT COUNT(DISTINCT donor_id) FROM donations d JOIN donors don ON d.donor_id = don.id WHERE industry = 'Healthcare' AND donation_date BETWEEN '2022-07-01' AND '2022-09-30';", "generated_sql": "SELECT COUNT(DISTINCT donors.id) AS unique_donors_count\nFROM donors\nJOIN donations ON donors.id = donations.donor_id\nWHERE donors.industry = 'Healthcare'\n  AND donations.donation_date >= '2022-07-01'\n  AND donations.donation_date < '2022-10-01';", "raw_model_output": "SELECT COUNT(DISTINCT donors.id) AS unique_donors_count\nFROM donors\nJOIN donations ON donors.id = donations.donor_id\nWHERE donors.industry = 'Healthcare'\n  AND donations.donation_date >= '2022-07-01'\n  AND donations.donation_date < '2022-10-01';", "latency_sec": 1.1871929168701172, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 236, "prompt_eval_sec": null, "tokens_completion": 68, "completion_eval_sec": null, "tokens_total": 304, "tokens_per_sec": 256.0662177815694, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count distinct donors with Healthcare industry who made donations between 2022-07-01 and 2022-09-30. The date range in the generated query uses >= and < to achieve the same inclusive range as BETWEEN. The JOIN conditions and aggregation logic are identical, and COUNT(DISTINCT donor_id) is equivalent to COUNT(DISTINCT donors.id) since the join ensures donor_id matches donors.id.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count unique healthcare donors who made donations in Q3 2022. The reference query uses BETWEEN for date filtering, while the generated query uses explicit range conditions (>= and <). The generated query's date range is slightly more precise (avoiding potential edge cases with DATETIME types) and uses explicit aliases, making it more readable. Both achieve the same result through equivalent JOINs and COUNT(DISTINCT) logic. The generated query's use of 'donors.id' instead of 'donor_id' is functionally identical since the foreign key relationship ensures they represent the same values.", "overall_assessment": "correct"}}
{"example_id": 2592, "sql_complexity": "window functions", "prompt": "What is the third highest account balance for Shariah-compliant finance customers?", "context": "CREATE TABLE shariah_compliant_finance(customer_id INT, account_balance DECIMAL(10, 2)); INSERT INTO shariah_compliant_finance VALUES (1, 5000), (2, 7000), (3, 6000), (4, 8000), (5, 9000);", "reference_sql": "SELECT account_balance FROM (SELECT account_balance, RANK() OVER (ORDER BY account_balance DESC) as rn FROM shariah_compliant_finance) t WHERE rn = 3;", "generated_sql": "SELECT account_balance\nFROM shariah_compliant_finance\nORDER BY account_balance DESC\nLIMIT 1 OFFSET 2;", "raw_model_output": "SELECT account_balance\nFROM shariah_compliant_finance\nORDER BY account_balance DESC\nLIMIT 1 OFFSET 2;", "latency_sec": 0.5750982761383057, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 151, "prompt_eval_sec": null, "tokens_completion": 27, "completion_eval_sec": null, "tokens_total": 178, "tokens_per_sec": 309.5123170864673, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the third highest account balance. The reference query uses RANK() to assign ranks and filters for rank 3, while the generated query uses ORDER BY with LIMIT 1 OFFSET 2. In the given data with unique values, both approaches return the same result (7000).", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries return the third highest account balance (7000) in this specific dataset. The Reference SQL uses RANK() which would behave differently with ties (e.g., duplicate balances), but the Generated SQL uses LIMIT/OFFSET which directly retrieves the third record after sorting. While both are technically correct for the given data, the Generated SQL is more efficient, simpler, and directly addresses the business intent without unnecessary complexity. The Reference SQL's use of RANK() could lead to incorrect results if there are duplicate balances, making the Generated SQL more robust for the stated question.", "overall_assessment": "correct"}}
{"example_id": 3795, "sql_complexity": "single join", "prompt": "What is the total quantity of unsold garments for each manufacturer based in 'Italy' or 'Spain'?", "context": "CREATE TABLE manufacturers (id INT PRIMARY KEY, name VARCHAR(255), country VARCHAR(255)); CREATE TABLE garments (id INT PRIMARY KEY, manufacturer_id INT, quantity_manufactured INT, quantity_sold INT);", "reference_sql": "SELECT m.name, SUM(g.quantity_manufactured - g.quantity_sold) as total_unsold_quantity FROM manufacturers m JOIN garments g ON m.id = g.manufacturer_id WHERE m.country IN ('Italy', 'Spain') GROUP BY m.name;", "generated_sql": "SELECT \n    m.name AS manufacturer_name,\n    SUM(g.quantity_manufactured - g.quantity_sold) AS total_unsold_garments\nFROM \n    manufacturers m\nJOIN \n    garments g ON m.id = g.manufacturer_id\nWHERE \n    m.country IN ('Italy', 'Spain')\nGROUP BY \n    m.name;", "raw_model_output": "SELECT \n    m.name AS manufacturer_name,\n    SUM(g.quantity_manufactured - g.quantity_sold) AS total_unsold_garments\nFROM \n    manufacturers m\nJOIN \n    garments g ON m.id = g.manufacturer_id\nWHERE \n    m.country IN ('Italy', 'Spain')\nGROUP BY \n    m.name;", "latency_sec": 1.185067892074585, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 132, "prompt_eval_sec": null, "tokens_completion": 70, "completion_eval_sec": null, "tokens_total": 202, "tokens_per_sec": 170.45436919768193, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries perform the same operations: joining manufacturers with garments, filtering by country ('Italy' or 'Spain'), grouping by manufacturer name, and calculating the total unsold quantity as the sum of (quantity_manufactured - quantity_sold). The only differences are in column aliases (e.g., 'total_unsold_quantity' vs 'total_unsold_garments'), which do not affect the semantic meaning of the result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent as they perform the same operations: joining manufacturers with garments, filtering by country, calculating unsold quantity (manufactured - sold), and grouping by manufacturer. The differences are purely syntactic (column aliases) and do not affect results. Both correctly address the business intent of calculating total unsold garments for Italian/Spanish manufacturers. The generated query uses slightly more descriptive column aliases, but neither query has an advantage in efficiency or elegance.", "overall_assessment": "correct"}}
{"example_id": 4138, "sql_complexity": "window functions", "prompt": "How many lifelong learning courses has a student with ID '2' completed, in chronological order?", "context": "CREATE TABLE lifelong_learning (student_id INT, course_id INT, completion_date DATE); INSERT INTO lifelong_learning VALUES (2, 1001, '2015-01-01'), (2, 1002, '2016-01-01');", "reference_sql": "SELECT student_id, course_id, COUNT(course_id) OVER (PARTITION BY student_id ORDER BY completion_date) as completed_courses FROM lifelong_learning WHERE student_id = 2;", "generated_sql": "SELECT COUNT(*) AS total_courses\nFROM lifelong_learning\nWHERE student_id = 2\nORDER BY completion_date;", "raw_model_output": "SELECT COUNT(*) AS total_courses\nFROM lifelong_learning\nWHERE student_id = 2\nORDER BY completion_date;", "latency_sec": 1.1580440998077393, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 138, "prompt_eval_sec": null, "tokens_completion": 24, "completion_eval_sec": null, "tokens_total": 162, "tokens_per_sec": 139.89104562330186, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns multiple rows with a running count of courses per student, while the Generated SQL returns a single row with a total count. The first query includes course-level details and window function results, whereas the second only aggregates the total number of courses.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL calculates a running count of courses per student_id using a window function, returning multiple rows with cumulative counts (e.g., 1, 2). The Generated SQL correctly returns a single total count of courses for student_id = 2. While both queries filter for student_id = 2, the original question asks for the *number* of completed courses (a single value), not a running tally. The Generated SQL's ORDER BY is redundant but doesn't affect the result, whereas the Reference SQL's output structure doesn't align with the question's requirement for a count. The Generated SQL better fulfills the business intent of quantifying completed courses.", "overall_assessment": "correct"}}
{"example_id": 312, "sql_complexity": "aggregation", "prompt": "List the top 3 most represented ethnicities in movies produced in the USA.", "context": "CREATE TABLE movies (title VARCHAR(255), production_country VARCHAR(64), lead_actor_ethnicity VARCHAR(64));", "reference_sql": "SELECT lead_actor_ethnicity, COUNT(*) AS count FROM movies WHERE production_country = 'USA' GROUP BY lead_actor_ethnicity ORDER BY count DESC LIMIT 3;", "generated_sql": "SELECT lead_actor_ethnicity, COUNT(*) AS count\nFROM movies\nWHERE production_country = 'USA'\nGROUP BY lead_actor_ethnicity\nORDER BY count DESC\nLIMIT 3;", "raw_model_output": "SELECT lead_actor_ethnicity, COUNT(*) AS count\nFROM movies\nWHERE production_country = 'USA'\nGROUP BY lead_actor_ethnicity\nORDER BY count DESC\nLIMIT 3;", "latency_sec": 0.8869888782501221, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 106, "prompt_eval_sec": null, "tokens_completion": 38, "completion_eval_sec": null, "tokens_total": 144, "tokens_per_sec": 162.3470186955303, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure, logic, and syntax. The Generated SQL is exactly the same as the Reference SQL, with only whitespace/formatting differences (line breaks) that do not affect semantic meaning.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "The queries are identical in structure, logic, and output. Both correctly filter USA-produced movies, group by lead actor ethnicity, count occurrences, order by descending count, and limit to top 3 results. The business intent is fully addressed by analyzing lead actor ethnicity representation in US movies. Both queries are equally efficient and elegant with no redundant elements.", "overall_assessment": "correct"}}
{"example_id": 4298, "sql_complexity": "single join", "prompt": "How many users joined the gym in Q1 2023?", "context": "CREATE TABLE memberships (id INT, user_id INT, join_date DATE); INSERT INTO memberships (id, user_id, join_date) VALUES (1, 5, '2023-01-15'), (2, 6, '2023-02-03'), (3, 7, '2023-03-20'), (4, 8, '2022-12-31');", "reference_sql": "SELECT COUNT(*) FROM memberships WHERE join_date BETWEEN '2023-01-01' AND '2023-03-31';", "generated_sql": "SELECT COUNT(*) AS num_users_joined_q1_2023\nFROM memberships\nWHERE join_date >= '2023-01-01' AND join_date < '2023-04-01';", "raw_model_output": "SELECT COUNT(*) AS num_users_joined_q1_2023\nFROM memberships\nWHERE join_date >= '2023-01-01' AND join_date < '2023-04-01';", "latency_sec": 0.6723251342773438, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 164, "prompt_eval_sec": null, "tokens_completion": 42, "completion_eval_sec": null, "tokens_total": 206, "tokens_per_sec": 306.39937360280516, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count memberships with join_date in the first quarter of 2023. The Reference SQL uses BETWEEN '2023-01-01' AND '2023-03-31' (inclusive), while the Generated SQL uses >= '2023-01-01' and < '2023-04-01' (which also includes all dates up to 2023-03-31). The date ranges are functionally identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly count users who joined in Q1 2023 (January-March). The reference query uses BETWEEN '2023-01-01' AND '2023-03-31' which includes both endpoints. The generated query uses join_date >= '2023-01-01' AND join_date < '2023-04-01' which achieves the same result by using an exclusive upper bound. Since join_date is a DATE type (no time component), both approaches capture exactly the same set of dates. Both queries are semantically equivalent and fulfill the business intent of counting Q1 2023 gym members. The generated query's explicit range boundary might be slightly more robust for datetime types, but with DATE types, both are equally valid.", "overall_assessment": "correct"}}
{"example_id": 5211, "sql_complexity": "multiple_joins", "prompt": "What is the average transaction value in the last week, split by product category and customer demographics?", "context": "CREATE TABLE transactions (transaction_id INT, customer_id INT, product_id INT, category_id INT, transaction_date DATE, amount DECIMAL(10,2)); CREATE TABLE customers (customer_id INT, age INT, gender VARCHAR(10), location VARCHAR(255)); CREATE TABLE products (product_id INT, name VARCHAR(255), category_id INT);", "reference_sql": "SELECT c.age, c.gender, p.category_id, AVG(t.amount) as avg_transaction_value FROM transactions t INNER JOIN customers c ON t.customer_id = c.customer_id INNER JOIN products p ON t.product_id = p.product_id WHERE t.transaction_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 WEEK) GROUP BY c.age, c.gender, p.category_id;", "generated_sql": "SELECT \n    p.category_id,\n    c.age,\n    c.gender,\n    AVG(t.amount) AS average_transaction_value\nFROM \n    transactions t\nJOIN \n    products p ON t.product_id = p.product_id\nJOIN \n    customers c ON t.customer_id = c.customer_id\nWHERE \n    t.transaction_date >= CURRENT_DATE - INTERVAL '7 days'\nGROUP BY \n    p.category_id,\n    c.age,\n    c.gender;", "raw_model_output": "SELECT \n    p.category_id,\n    c.age,\n    c.gender,\n    AVG(t.amount) AS average_transaction_value\nFROM \n    transactions t\nJOIN \n    products p ON t.product_id = p.product_id\nJOIN \n    customers c ON t.customer_id = c.customer_id\nWHERE \n    t.transaction_date >= CURRENT_DATE - INTERVAL '7 days'\nGROUP BY \n    p.category_id,\n    c.age,\n    c.gender;", "latency_sec": 0.9984009265899658, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 156, "prompt_eval_sec": null, "tokens_completion": 92, "completion_eval_sec": null, "tokens_total": 248, "tokens_per_sec": 248.39720536622792, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same data by joining the same tables on identical keys. The date filter uses equivalent expressions (DATE_SUB(...) vs CURRENT_DATE - INTERVAL '7 days') to capture transactions from the last week. The GROUP BY clause includes the same columns (age, gender, category_id) in both queries, and the aggregation (AVG(amount)) is identical. The column order in the SELECT list differs but does not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically correct and produce identical results. They join the same tables (transactions, customers, products), filter transactions from the last 7 days using equivalent date calculations (DATE_SUB vs. CURRENT_DATE - INTERVAL), and group by the required dimensions (product category, customer age, gender). The only differences are syntax variations in date calculation (DATE_SUB vs. INTERVAL '7 days') and column alias naming (avg_transaction_value vs. average_transaction_value). Both queries fully address the business intent of calculating average transaction value by product category and customer demographics.", "overall_assessment": "correct"}}
{"example_id": 382, "sql_complexity": "window functions", "prompt": "What is the average annual precipitation in the past 10 years for each weather station?", "context": "CREATE TABLE WeatherStation (ID INT, Name VARCHAR(100), Location VARCHAR(100), Elevation FLOAT, AnnualPrecipitation FLOAT); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (1, 'Station A', 'Arctic Circle', 100, 450); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (2, 'Station B', 'North Pole', 200, 300);", "reference_sql": "SELECT Name, AVG(AnnualPrecipitation) OVER (PARTITION BY Name ORDER BY Name ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS AvgAnnualPrecipitation FROM WeatherStation WHERE YEAR(CurrentDate) - YEAR(DateInstalled) BETWEEN 1 AND 10;", "generated_sql": "SELECT \n    Name,\n    (AnnualPrecipitation * 10) / 10 AS AverageAnnualPrecipitation\nFROM \n    WeatherStation;", "raw_model_output": "SELECT \n    Name,\n    (AnnualPrecipitation * 10) / 10 AS AverageAnnualPrecipitation\nFROM \n    WeatherStation;", "latency_sec": 0.6146492958068848, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 187, "prompt_eval_sec": null, "tokens_completion": 32, "completion_eval_sec": null, "tokens_total": 219, "tokens_per_sec": 356.3007417303006, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL references a non-existent 'DateInstalled' column in the WHERE clause, making it invalid. The Generated SQL lacks this filter and instead simplifies 'AnnualPrecipitation' to itself via a redundant calculation. Additionally, the Reference SQL's window function would return the same value as 'AnnualPrecipitation' due to partitioning by unique 'Name' values, but the invalid column renders the query non-functional. The two queries differ in both structure and validity.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL contains a critical error: it references a non-existent 'DateInstalled' column in the WHERE clause, making it syntactically invalid. Additionally, the window function logic is inappropriate for calculating a 10-year average when the schema only contains a single AnnualPrecipitation value per station. The Generated SQL is technically correct (though it simplifies to just selecting AnnualPrecipitation) but fails to address the 10-year time frame requirement. Neither query properly handles the business intent, but the Generated SQL avoids invalid syntax. The schema itself is problematic as it lacks yearly data to calculate a 10-year average, but given the constraints, the Generated SQL is less erroneous.", "overall_assessment": "incorrect"}}
{"example_id": 2190, "sql_complexity": "single join", "prompt": "What is the total number of humanitarian assistance events by each country in the last 3 years?", "context": "CREATE TABLE Humanitarian_Assistance (id INT, country VARCHAR(50), year INT, events INT); CREATE TABLE Countries (id INT, name VARCHAR(50), region VARCHAR(50));", "reference_sql": "SELECT co.name, SUM(ha.events) FROM Humanitarian_Assistance ha INNER JOIN Countries co ON ha.country = co.name WHERE ha.year BETWEEN (YEAR(CURRENT_DATE) - 3) AND YEAR(CURRENT_DATE) GROUP BY co.name;", "generated_sql": "SELECT \n    c.name AS country,\n    SUM(ha.events) AS total_events\nFROM \n    Humanitarian_Assistance ha\nJOIN \n    Countries c ON ha.country = c.name\nWHERE \n    ha.year >= (SELECT MAX(year) FROM Humanitarian_Assistance) - 2\nGROUP BY \n    c.name;", "raw_model_output": "SELECT \n    c.name AS country,\n    SUM(ha.events) AS total_events\nFROM \n    Humanitarian_Assistance ha\nJOIN \n    Countries c ON ha.country = c.name\nWHERE \n    ha.year >= (SELECT MAX(year) FROM Humanitarian_Assistance) - 2\nGROUP BY \n    c.name;", "latency_sec": 1.209758996963501, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 124, "prompt_eval_sec": null, "tokens_completion": 68, "completion_eval_sec": null, "tokens_total": 192, "tokens_per_sec": 158.7092970433951, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query filters years between (CURRENT_YEAR - 3) and CURRENT_YEAR (inclusive), capturing 4 years. The generated query uses MAX(year) - 2, which captures the last 3 years relative to the maximum year in the table. If the maximum year in the table is not the current year, the generated query may exclude recent years or include older ones, leading to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries differ in their year filtering logic. The Reference SQL uses `YEAR(CURRENT_DATE) - 3` which includes 4 years (e.g., 2020-2023 if current year is 2023) due to inclusive BETWEEN, violating the 'last 3 years' requirement. The Generated SQL uses `MAX(year) - 2` which correctly captures 3 years if the latest data is current, but relies on existing data rather than the actual current date. Neither fully meets the intent, but the Generated SQL's approach aligns better with the 3-year requirement when data is up-to-date. The Reference SQL's logic is technically flawed for the stated timeframe.", "overall_assessment": "differently_correct"}}
{"example_id": 1852, "sql_complexity": "set operations", "prompt": "Compare coal production and employment rates in China and India between 2018 and 2020.", "context": "CREATE TABLE china_coal_production (year INT, production FLOAT); INSERT INTO china_coal_production (year, production) VALUES (2018, 3500.0), (2019, 3600.0), (2020, 3700.0); CREATE TABLE china_employment (year INT, employment FLOAT); INSERT INTO china_employment (year, employment) VALUES (2018, 8000000.0), (2019, 8100000.0), (2020, 8200000.0); CREATE TABLE india_coal_production (year INT, production FLOAT); INSERT INTO india_coal_production (year, production) VALUES (2018, 700.0), (2019, 750.0), (2020, 800.0); CREATE TABLE india_employment (year INT, employment FLOAT); INSERT INTO india_employment (year, employment) VALUES (2018, 1000000.0), (2019, 1050000.0), (2020, 1100000.0);", "reference_sql": "SELECT 'China' AS country, china_coal_production.production, china_employment.employment FROM china_coal_production INNER JOIN china_employment ON china_coal_production.year = china_employment.year WHERE china_coal_production.year BETWEEN 2018 AND 2020 UNION ALL SELECT 'India', india_coal_production.production, india_employment.employment FROM india_coal_production INNER JOIN india_employment ON india_coal_production.year = india_employment.year WHERE india_coal_production.year BETWEEN 2018 AND 2020;", "generated_sql": "SELECT \n    c.year,\n    c.production AS china_coal_production,\n    c.employment AS china_employment,\n    i.production AS india_coal_production,\n    i.employment AS india_employment\nFROM \n    (SELECT year, production, employment FROM china_coal_production JOIN china_employment USING (year)) c\nJOIN \n    (SELECT year, production, employment FROM india_coal_production JOIN india_employment USING (year)) i\nON c.year = i.year\nWHERE c.year BETWEEN 2018 AND 2020\nORDER BY c.year;", "raw_model_output": "SELECT \n    c.year,\n    c.production AS china_coal_production,\n    c.employment AS china_employment,\n    i.production AS india_coal_production,\n    i.employment AS india_employment\nFROM \n    (SELECT year, production, employment FROM china_coal_production JOIN china_employment USING (year)) c\nJOIN \n    (SELECT year, production, employment FROM india_coal_production JOIN india_employment USING (year)) i\nON c.year = i.year\nWHERE c.year BETWEEN 2018 AND 2020\nORDER BY c.year;", "latency_sec": 2.980644941329956, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 309, "prompt_eval_sec": null, "tokens_completion": 121, "completion_eval_sec": null, "tokens_total": 430, "tokens_per_sec": 144.26407991021404, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL returns two rows per year (China and India separated by 'country' column), while the Generated SQL returns one row per year with combined columns for both countries. The structure and column organization differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent due to differences in output structure. The Reference SQL returns separate rows for China and India per year (2 rows/year), while the Generated SQL returns a single row per year with all four metrics (China production, China employment, India production, India employment). Both are syntactically correct, but the Generated SQL better fulfills the business intent by enabling direct year-over-year comparisons between countries in a single row. The Generated SQL is more efficient as it avoids UNION ALL and provides a normalized structure for analysis. The Reference SQL requires post-query processing to compare countries side-by-side.", "overall_assessment": "differently_correct"}}
{"example_id": 2535, "sql_complexity": "subqueries", "prompt": "What is the maximum safety rating for vehicles in the vehiclesafety schema?", "context": "CREATE TABLE VehicleSafety (id INT, vehicle_id INT, safetyrating INT, PRIMARY KEY (id)); CREATE TABLE Vehicles (id INT, make VARCHAR(50), model VARCHAR(50), PRIMARY KEY (id)); CREATE TABLE LuxuryVehicles (id INT, vehicle_id INT, PRIMARY KEY (id), FOREIGN KEY (vehicle_id) REFERENCES Vehicles(id));", "reference_sql": "SELECT MAX(safetyrating) FROM vehicleSafety JOIN Vehicles ON vehicleSafety.vehicle_id = Vehicles.id WHERE EXISTS (SELECT * FROM LuxuryVehicles WHERE Vehicles.id = LuxuryVehicles.vehicle_id);", "generated_sql": "SELECT MAX(safetyrating) AS max_safety_rating FROM VehicleSafety;", "raw_model_output": "SELECT MAX(safetyrating) AS max_safety_rating FROM VehicleSafety;", "latency_sec": 0.5239641666412354, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 153, "prompt_eval_sec": null, "tokens_completion": 17, "completion_eval_sec": null, "tokens_total": 170, "tokens_per_sec": 324.4496681705356, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters vehicles using an EXISTS clause to only include luxury vehicles, while the Generated SQL retrieves the maximum safety rating from all vehicles without any restrictions. The Generated SQL lacks the join and existence check, so it may include non-luxury vehicles, leading to potentially different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query incorrectly filters results to only luxury vehicles using a JOIN and EXISTS clause, which was not part of the original question. The generated query directly retrieves the maximum safety rating from the VehicleSafety table as requested. While both queries technically execute, they produce different results (generated returns all vehicles, reference only luxury vehicles). The generated query better fulfills the business intent by directly addressing the question without unnecessary constraints. The generated query is also more efficient as it avoids complex joins and subqueries.", "overall_assessment": "differently_correct"}}
{"example_id": 2140, "sql_complexity": "aggregation", "prompt": "What was the total amount of minerals extracted in the 'north' region for each month in 2020?", "context": "CREATE TABLE extraction(id INT, location TEXT, month INT, year INT, minerals_extracted FLOAT);INSERT INTO extraction(id, location, month, year, minerals_extracted) VALUES (1, 'north', 1, 2020, 1500), (2, 'north', 2, 2020, 1800), (3, 'south', 1, 2020, 1200);", "reference_sql": "SELECT month, SUM(minerals_extracted) FROM extraction WHERE location = 'north' AND year = 2020 GROUP BY month;", "generated_sql": "SELECT month, SUM(minerals_extracted) AS total_minerals_extracted\nFROM extraction\nWHERE location = 'north' AND year = 2020\nGROUP BY month;", "raw_model_output": "SELECT month, SUM(minerals_extracted) AS total_minerals_extracted\nFROM extraction\nWHERE location = 'north' AND year = 2020\nGROUP BY month;", "latency_sec": 0.6841728687286377, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 176, "prompt_eval_sec": null, "tokens_completion": 39, "completion_eval_sec": null, "tokens_total": 215, "tokens_per_sec": 314.24806481952896, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (month and SUM(minerals_extracted)), apply identical WHERE conditions (location = 'north' and year = 2020), and group by the same column (month). The only difference is the addition of an alias (total_minerals_extracted) in the generated query, which does not affect the semantic result set. The output data rows will be identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically equivalent as they produce identical results through the same logic: filtering for 'north' region and 2020 year, then aggregating by month. The generated query improves upon the reference by adding an explicit alias (total_minerals_extracted) which enhances readability and clarity of the output column. While both fulfill the business intent of calculating monthly totals, the generated query's alias makes the results more interpretable without altering functionality. The reference query is correct but less elegant in presentation.", "overall_assessment": "correct"}}
{"example_id": 4779, "sql_complexity": "window functions", "prompt": "What is the average CO2 emission for the top 3 highest emitting countries since 2015?", "context": "CREATE TABLE emissions (country VARCHAR(50), year INT, co2_emission INT); INSERT INTO emissions (country, year, co2_emission) VALUES ('USA', 2015, 5373978000); INSERT INTO emissions (country, year, co2_emission) VALUES ('China', 2015, 10498600000); INSERT INTO emissions (country, year, co2_emission) VALUES ('India', 2015, 2633830000); INSERT INTO emissions (country, year, co2_emission) VALUES ('USA', 2016, 5518004000); INSERT INTO emissions (country, year, co2_emission) VALUES ('China', 2016, 10813000000); INSERT INTO emissions (country, year, co2_emission) VALUES ('India', 2016, 2799280000);", "reference_sql": "SELECT AVG(co2_emission) as avg_emission FROM (SELECT country, year, co2_emission, ROW_NUMBER() OVER (ORDER BY co2_emission DESC) as rn FROM emissions WHERE year >= 2015) t WHERE rn <= 3 GROUP BY country;", "generated_sql": "SELECT AVG(co2_emission) AS average_emission\nFROM (\n    SELECT country, SUM(co2_emission) AS total_emission\n    FROM emissions\n    WHERE year >= 2015\n    GROUP BY country\n    ORDER BY total_emission DESC\n    LIMIT 3\n) AS top_countries;", "raw_model_output": "SELECT AVG(co2_emission) AS average_emission\nFROM (\n    SELECT country, SUM(co2_emission) AS total_emission\n    FROM emissions\n    WHERE year >= 2015\n    GROUP BY country\n    ORDER BY total_emission DESC\n    LIMIT 3\n) AS top_countries;", "latency_sec": 0.7761061191558838, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 267, "prompt_eval_sec": null, "tokens_completion": 66, "completion_eval_sec": null, "tokens_total": 333, "tokens_per_sec": 429.0650360574154, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL calculates the average of the top 3 co2_emission values (per row) grouped by country, while the Generated SQL sums emissions per country, selects the top 3 countries by total emission, and then averages those totals. The Reference SQL's grouping by country after row numbering leads to different aggregation logic compared to the Generated SQL's approach of summing first and then averaging.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is technically flawed because it applies ROW_NUMBER() without partitioning by country, leading to incorrect ranking of individual yearly emissions rather than country-level totals. It then groups by country after ranking, which would average emissions across years for each country but fails to aggregate emissions per country first. The Generated SQL correctly aggregates emissions per country (SUM(co2_emission)), identifies the top 3 countries by total emissions, and then calculates their average. While both queries aim to find the top 3 countries, the Generated SQL properly addresses the business intent by considering total emissions per country rather than individual yearly values. The Reference SQL's approach would incorrectly include multiple entries per country and fail to aggregate emissions properly.", "overall_assessment": "differently_correct"}}
{"example_id": 1015, "sql_complexity": "subqueries", "prompt": "List the top 3 most expensive eco-friendly products in Europe and their suppliers.", "context": "CREATE TABLE Suppliers (supplierID INT, supplierName VARCHAR(50), country VARCHAR(50)); CREATE TABLE Products (productID INT, productName VARCHAR(50), price DECIMAL(10,2), ecoFriendly BOOLEAN, supplierID INT);", "reference_sql": "SELECT P.productName, P.price, S.supplierName FROM (SELECT * FROM Products WHERE ecoFriendly = TRUE ORDER BY price DESC LIMIT 3) P JOIN Suppliers S ON P.supplierID = S.supplierID;", "generated_sql": "SELECT p.productName, p.price, s.supplierName\nFROM Products p\nJOIN Suppliers s ON p.supplierID = s.supplierID\nWHERE p.ecoFriendly = TRUE AND s.country = 'Europe'\nORDER BY p.price DESC\nLIMIT 3;", "raw_model_output": "SELECT p.productName, p.price, s.supplierName\nFROM Products p\nJOIN Suppliers s ON p.supplierID = s.supplierID\nWHERE p.ecoFriendly = TRUE AND s.country = 'Europe'\nORDER BY p.price DESC\nLIMIT 3;", "latency_sec": 1.0705273151397705, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 132, "prompt_eval_sec": null, "tokens_completion": 56, "completion_eval_sec": null, "tokens_total": 188, "tokens_per_sec": 175.6143886673777, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL filters eco-friendly products first, then joins with suppliers. The Generated SQL adds an additional filter for suppliers in 'Europe' and applies this after joining. This extra condition (s.country = 'Europe') in the Generated SQL restricts results to European suppliers, which is not present in the Reference SQL.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries differ in critical aspects. The Reference query correctly identifies eco-friendly products and joins with suppliers but **fails to filter suppliers located in Europe**, which is explicitly required by the question. The Generated query properly applies both `ecoFriendly = TRUE` and `s.country = 'Europe'` in the WHERE clause, ensuring only European suppliers are considered. While both order by price and limit to 3, the Reference's omission of the country filter makes it technically incorrect for the business requirement. The Generated query is more precise and fulfills the intent.", "overall_assessment": "differently_correct"}}
{"example_id": 3715, "sql_complexity": "aggregation", "prompt": "What is the average age of engines still in service for each engine type?", "context": "CREATE TABLE Engine (id INT, aircraft_id INT, engine_type VARCHAR(255), hours_since_last_service INT, manufacture_year INT); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (1, 1, 'GE90-115B', 500, 2000); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (2, 2, 'CFM56-5B', 1000, 1995); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (3, 1, 'GE90-115B', 700, 2002);", "reference_sql": "SELECT engine_type, AVG(YEAR(CURRENT_DATE) - manufacture_year) as avg_age FROM Engine GROUP BY engine_type;", "generated_sql": "SELECT \n    engine_type,\n    AVG(CURRENT_YEAR - manufacture_year) AS average_age\nFROM \n    Engine\nGROUP BY \n    engine_type;", "raw_model_output": "SELECT \n    engine_type,\n    AVG(CURRENT_YEAR - manufacture_year) AS average_age\nFROM \n    Engine\nGROUP BY \n    engine_type;\n\n-- Note: Replace CURRENT_YEAR with the actual current year, e.g., 2023.\n-- Since the schema does not specify a date for \"still in service,\" \n-- we assume all engines in the table are still in service.", "latency_sec": 0.8531079292297363, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 234, "prompt_eval_sec": null, "tokens_completion": 80, "completion_eval_sec": null, "tokens_total": 314, "tokens_per_sec": 368.0659729461287, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average age of engines per type by subtracting the manufacture_year from the current year. The Reference SQL uses YEAR(CURRENT_DATE) to get the current year, while the Generated SQL uses CURRENT_YEAR. Assuming CURRENT_YEAR represents the same value as YEAR(CURRENT_DATE), the semantic logic and result are equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query uses YEAR(CURRENT_DATE) - manufacture_year, which is a valid expression in most SQL dialects to calculate the age by subtracting the manufacture year from the current year. The generated query uses CURRENT_YEAR - manufacture_year, which is not a valid SQL function in standard SQL (CURRENT_YEAR does not exist as a built-in function). This makes the generated query technically incorrect and non-functional. Both queries aim to calculate engine age based on manufacture year, but only the reference query is syntactically valid. The business intent of calculating average age is fulfilled by the reference query, while the generated query would fail to execute.", "overall_assessment": "differently_correct"}}
{"example_id": 1957, "sql_complexity": "set operations", "prompt": "What is the average temperature recorded for the 'polar_bear' species in the 'Arctic_Animals' table compared to the 'penguin' species in the 'Antarctic_Animals' table?", "context": "CREATE TABLE Arctic_Animals (species TEXT, avg_temp FLOAT); CREATE TABLE Antarctic_Animals (species TEXT, avg_temp FLOAT);", "reference_sql": "SELECT AVG(Arctic_Animals.avg_temp) FROM Arctic_Animals WHERE Arctic_Animals.species = 'polar_bear' INTERSECT SELECT AVG(Antarctic_Animals.avg_temp) FROM Antarctic_Animals WHERE Antarctic_Animals.species = 'penguin'", "generated_sql": "SELECT \n  (SELECT AVG(avg_temp) FROM Arctic_Animals WHERE species = 'polar_bear') AS Arctic_Polar_Bear_Temp,\n  (SELECT AVG(avg_temp) FROM Antarctic_Animals WHERE species = 'penguin') AS Antarctic_Penguin_Temp;", "raw_model_output": "SELECT \n  (SELECT AVG(avg_temp) FROM Arctic_Animals WHERE species = 'polar_bear') AS Arctic_Polar_Bear_Temp,\n  (SELECT AVG(avg_temp) FROM Antarctic_Animals WHERE species = 'penguin') AS Antarctic_Penguin_Temp;", "latency_sec": 0.750586748123169, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 135, "prompt_eval_sec": null, "tokens_completion": 57, "completion_eval_sec": null, "tokens_total": 192, "tokens_per_sec": 255.79987986744126, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses INTERSECT to find common values between two subqueries, which would return a single column with one row if the averages are equal. The Generated SQL returns two separate columns with the averages directly. The output structures and logic differ: the first checks for equality between the two averages, while the second simply retrieves both values independently.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is technically incorrect because it uses INTERSECT, which returns only common rows between two result sets. Since each subquery returns a single value (average temperature), INTERSECT would only return a result if both averages are exactly equal (which is unlikely). This fundamentally misrepresents the comparison intent. The Generated SQL correctly calculates separate averages for each species using correlated subqueries, returning both values in a single row for direct comparison. While both queries are syntactically valid, only the Generated SQL fulfills the business intent of comparing two distinct averages. The Generated SQL is also more efficient and elegant.", "overall_assessment": "differently_correct"}}
{"example_id": 1311, "sql_complexity": "basic SQL", "prompt": "What is the total number of veteran job applications in Texas in the last year?", "context": "CREATE TABLE veteran_jobs (id INT, state VARCHAR(50), application_date DATE); INSERT INTO veteran_jobs (id, state, application_date) VALUES (1, 'Texas', '2021-02-15'), (2, 'California', '2021-04-10'), (3, 'Texas', '2022-01-05');", "reference_sql": "SELECT COUNT(*) FROM veteran_jobs WHERE state = 'Texas' AND application_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR);", "generated_sql": "SELECT COUNT(*) AS total_applications\nFROM veteran_jobs\nWHERE state = 'Texas' AND application_date >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR);", "raw_model_output": "SELECT COUNT(*) AS total_applications\nFROM veteran_jobs\nWHERE state = 'Texas' AND application_date >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR);", "latency_sec": 0.9419019222259521, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 155, "prompt_eval_sec": null, "tokens_completion": 35, "completion_eval_sec": null, "tokens_total": 190, "tokens_per_sec": 201.7195161370751, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count rows where state is 'Texas' and application_date is within the last year. The only differences are the use of CURRENT_DATE vs CURDATE() (which behave identically in this context) and an alias in the generated query (which doesn't affect the result value).", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent as they use identical logic with only syntactic differences (CURRENT_DATE vs. CURDATE() in MySQL, which are functionally identical). Both correctly filter for Texas applications within the last year using DATE_SUB. The generated query adds an explicit alias (total_applications), which improves readability but doesn't affect functionality. Neither query has performance issues. Both fully address the business intent of counting Texas veteran job applications from the past year.", "overall_assessment": "correct"}}
{"example_id": 2997, "sql_complexity": "window functions", "prompt": "What is the earliest capture time for each satellite image in the 'satellite_images' table?", "context": "CREATE TABLE satellite_images (image_id INT, image_url TEXT, capture_time TIMESTAMP); INSERT INTO satellite_images (image_id, image_url, capture_time) VALUES (1, 'image1.jpg', '2022-01-01 10:00:00'), (2, 'image2.jpg', '2021-05-01 10:00:00');", "reference_sql": "SELECT image_id, MIN(capture_time) OVER (PARTITION BY image_id) FROM satellite_images;", "generated_sql": "SELECT image_id, capture_time AS earliest_capture_time\nFROM satellite_images\nWHERE capture_time = (\n    SELECT MIN(capture_time)\n    FROM satellite_images AS si2\n    WHERE si2.image_id = satellite_images.image_id\n);", "raw_model_output": "SELECT image_id, capture_time AS earliest_capture_time\nFROM satellite_images\nWHERE capture_time = (\n    SELECT MIN(capture_time)\n    FROM satellite_images AS si2\n    WHERE si2.image_id = satellite_images.image_id\n);", "latency_sec": 0.733593225479126, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 163, "prompt_eval_sec": null, "tokens_completion": 49, "completion_eval_sec": null, "tokens_total": 212, "tokens_per_sec": 288.9884920373114, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns all rows with the minimum capture_time per image_id (which equals the capture_time itself when image_id is unique). The Generated SQL filters to only rows where capture_time equals the minimum for their specific image_id. If image_id were not unique, the Generated SQL would return fewer rows (only the earliest capture_time per image_id), while the Reference SQL would return all rows with the min value. Thus, they are not semantically equivalent in general.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": false, "superiority": "reference", "explanation": "Both queries return all rows with image_id and capture_time, but neither correctly addresses the business intent. The original question asks for the earliest capture time per satellite image, which implies grouping by image_id and finding the minimum capture_time. The Reference SQL uses a window function that returns the same value as the original capture_time (since image_id is unique), making it redundant. The Generated SQL uses a correlated subquery that also returns all rows (as each image_id has only one capture_time). Neither query properly aggregates data, but the Reference SQL is simpler and more efficient.", "overall_assessment": "differently_correct"}}
{"example_id": 3743, "sql_complexity": "aggregation", "prompt": "What is the maximum budget spent on peacekeeping operations by each department?", "context": "CREATE TABLE DepartmentPeacekeeping (id INT, department VARCHAR(50), budget INT);", "reference_sql": "SELECT department, MAX(budget) FROM DepartmentPeacekeeping GROUP BY department;", "generated_sql": "SELECT department, MAX(budget) AS max_budget\nFROM DepartmentPeacekeeping\nGROUP BY department;", "raw_model_output": "SELECT department, MAX(budget) AS max_budget\nFROM DepartmentPeacekeeping\nGROUP BY department;", "latency_sec": 1.244385004043579, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 98, "prompt_eval_sec": null, "tokens_completion": 21, "completion_eval_sec": null, "tokens_total": 119, "tokens_per_sec": 95.62956770879934, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries group by 'department' and select the maximum 'budget' for each group. The generated query adds an explicit alias 'max_budget' for the MAX(budget) column, but this does not affect the semantic result set. The core logic and output data remain identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically correct and produce identical results. The reference query omits the column alias, while the generated query explicitly names the calculated column 'max_budget'. This makes the generated query more readable and semantically explicit, which better aligns with standard SQL best practices. Both correctly group by department and calculate the maximum budget per department, fully addressing the business question. The generated query's added clarity makes it slightly superior without compromising functionality.", "overall_assessment": "correct"}}
{"example_id": 4664, "sql_complexity": "multiple_joins", "prompt": "Calculate the total number of volunteer hours contributed by volunteers from 'California' in 'Health' projects in 2021.", "context": "CREATE TABLE volunteers (volunteer_id INT, name VARCHAR(255), state VARCHAR(255));", "reference_sql": "SELECT SUM(vh.hours) as total_hours FROM volunteer_projects vp JOIN volunteer_hours vh ON vp.project_id = vh.project_id JOIN volunteers vol ON vh.volunteer_id = vol.volunteer_id WHERE vp.cause = 'Health' AND vol.state = 'California' AND vh.volunteer_date BETWEEN '2021-01-01' AND '2021-12-31';", "generated_sql": "SELECT SUM(hours) AS total_hours\nFROM volunteer_hours vh\nJOIN volunteers v ON vh.volunteer_id = v.volunteer_id\nJOIN projects p ON vh.project_id = p.project_id\nWHERE v.state = 'California'\n  AND p.category = 'Health'\n  AND YEAR(vh.date) = 2021;", "raw_model_output": "SELECT SUM(hours) AS total_hours\nFROM volunteer_hours vh\nJOIN volunteers v ON vh.volunteer_id = v.volunteer_id\nJOIN projects p ON vh.project_id = p.project_id\nWHERE v.state = 'California'\n  AND p.category = 'Health'\n  AND YEAR(vh.date) = 2021;", "latency_sec": 0.7096989154815674, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 110, "prompt_eval_sec": null, "tokens_completion": 67, "completion_eval_sec": null, "tokens_total": 177, "tokens_per_sec": 249.40153653735874, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in table/column names and conditions. The Reference SQL uses 'volunteer_projects.cause' and 'volunteer_date', while the Generated SQL uses 'projects.category' and 'YEAR(vh.date)'. The 'cause' vs 'category' columns and 'volunteer_date' vs 'date' columns may represent different data, and the date conditions (BETWEEN vs YEAR()) could behave differently if dates have time components. These discrepancies make the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent due to differences in table structure assumptions and date filtering. The reference query explicitly joins with 'volunteer_projects' (which likely contains the 'cause' column) and uses a precise date range ('BETWEEN'), while the generated query assumes a 'projects' table with a 'category' column and uses the less efficient 'YEAR()' function. Both fulfill the business intent of calculating California volunteers' Health project hours in 2021, but the reference query is more precise and efficient. The reference better aligns with the original question's implied schema (volunteer_projects with 'cause') and avoids potential performance issues with 'YEAR()'.", "overall_assessment": "differently_correct"}}
{"example_id": 251, "sql_complexity": "set operations", "prompt": "Compare the number of economic diversification projects in two regions, one in Europe and one in Oceania, by showing the project type and the number of projects in each region.", "context": "CREATE TABLE economic_diversification (region VARCHAR(50), project_type VARCHAR(50), project_start_date DATE);", "reference_sql": "SELECT 'Europe' as region, project_type, COUNT(*) as project_count FROM economic_diversification WHERE region = 'Europe' UNION ALL SELECT 'Oceania' as region, project_type, COUNT(*) as project_count FROM economic_diversification WHERE region = 'Oceania';", "generated_sql": "SELECT \n    project_type,\n    COUNT(*) AS project_count,\n    'Europe' AS region\nFROM \n    economic_diversification\nWHERE \n    region = 'Europe'\nGROUP BY \n    project_type\n\nUNION ALL\n\nSELECT \n    project_type,\n    COUNT(*) AS project_count,\n    'Oceania' AS region\nFROM \n    economic_diversification\nWHERE \n    region = 'Oceania'\nGROUP BY \n    project_type;", "raw_model_output": "SELECT \n    project_type,\n    COUNT(*) AS project_count,\n    'Europe' AS region\nFROM \n    economic_diversification\nWHERE \n    region = 'Europe'\nGROUP BY \n    project_type\n\nUNION ALL\n\nSELECT \n    project_type,\n    COUNT(*) AS project_count,\n    'Oceania' AS region\nFROM \n    economic_diversification\nWHERE \n    region = 'Oceania'\nGROUP BY \n    project_type;", "latency_sec": 1.3247921466827393, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 124, "prompt_eval_sec": null, "tokens_completion": 95, "completion_eval_sec": null, "tokens_total": 219, "tokens_per_sec": 165.30895095383295, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference SQL is invalid because it lacks GROUP BY clauses for project_type, leading to ambiguous results. The generated SQL correctly groups by project_type, ensuring accurate counts. Without GROUP BY, the reference SQL would return incorrect or undefined values for project_type.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL is technically incorrect because it lacks GROUP BY clauses in both subqueries, which would cause an error when combining non-aggregated columns (project_type) with aggregate functions (COUNT(*)). The Generated SQL correctly uses GROUP BY project_type in both subqueries, ensuring valid aggregation. Both queries aim to fulfill the business intent by comparing project counts by type between regions, but only the Generated SQL is syntactically valid. The Generated version also explicitly includes the region identifier in each subquery, making the output structure more transparent and reliable.", "overall_assessment": "differently_correct"}}
{"example_id": 610, "sql_complexity": "subqueries", "prompt": "What is the percentage of community development projects completed in 'Caribbean' in 2020?", "context": "CREATE TABLE community_projects (project_id INT, project_name TEXT, location TEXT, completion_year INT); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (1, 'Community Center', 'Southern Region, Caribbean', 2020); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (2, 'Park Renovation', 'Northern Region, Caribbean', 2019); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (3, 'Library Construction', 'Caribbean', 2020);", "reference_sql": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM community_projects WHERE location = 'Caribbean')) FROM community_projects WHERE completion_year = 2020 AND location = 'Caribbean';", "generated_sql": "SELECT \n  (COUNT(*) * 100.0) / (SELECT COUNT(*) FROM community_projects) AS percentage_completed_in_caribbean_2020\nFROM \n  community_projects\nWHERE \n  location LIKE '%Caribbean%' AND completion_year = 2020;", "raw_model_output": "SELECT \n  (COUNT(*) * 100.0) / (SELECT COUNT(*) FROM community_projects) AS percentage_completed_in_caribbean_2020\nFROM \n  community_projects\nWHERE \n  location LIKE '%Caribbean%' AND completion_year = 2020;", "latency_sec": 1.0157051086425781, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 207, "prompt_eval_sec": null, "tokens_completion": 55, "completion_eval_sec": null, "tokens_total": 262, "tokens_per_sec": 257.9488847409121, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. 1) The Reference SQL uses an exact match for 'Caribbean' in the location column, while the Generated SQL uses a LIKE '%Caribbean%' pattern match, which would include locations with 'Caribbean' as part of a longer string. 2) The denominator in the Reference SQL is the count of all Caribbean projects, while the Generated SQL uses the total count of all projects. These differences in filtering and denominator calculation will produce different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly calculates the percentage of Caribbean projects completed in 2020 by using the count of Caribbean projects as the denominator. The Generated SQL incorrectly uses the total project count as the denominator, which would only match if all projects were in the Caribbean (which isn't the case here). While both queries return 66.666...% in this specific dataset due to coincidental data distribution, the Generated SQL's logic is fundamentally flawed for the business question. The Reference SQL properly addresses the requirement to measure 'percentage of community development projects completed in Caribbean' (i.e., of all Caribbean projects, how many were completed in 2020), whereas the Generated SQL measures 'percentage of all projects that are Caribbean and completed in 2020'.", "overall_assessment": "incorrect"}}
{"example_id": 421, "sql_complexity": "set operations", "prompt": "What is the combined landfill capacity for 'City A' and 'City B'?", "context": "CREATE TABLE landfill_capacity (city VARCHAR(255), capacity INT); INSERT INTO landfill_capacity (city, capacity) VALUES ('City A', 500000), ('City B', 600000);", "reference_sql": "SELECT SUM(capacity) FROM (SELECT capacity FROM landfill_capacity WHERE city = 'City A' UNION ALL SELECT capacity FROM landfill_capacity WHERE city = 'City B') AS combined_capacity;", "generated_sql": "SELECT SUM(capacity) AS total_capacity\nFROM landfill_capacity\nWHERE city IN ('City A', 'City B');", "raw_model_output": "SELECT SUM(capacity) AS total_capacity\nFROM landfill_capacity\nWHERE city IN ('City A', 'City B');", "latency_sec": 0.8411078453063965, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 123, "prompt_eval_sec": null, "tokens_completion": 25, "completion_eval_sec": null, "tokens_total": 148, "tokens_per_sec": 175.95841107163488, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of capacities for 'City A' and 'City B'. The reference query uses a subquery with UNION ALL to combine the capacities before summing, while the generated query directly sums the capacities where the city is in the specified list. Since both approaches aggregate the same values, they produce identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the combined landfill capacity for 'City A' and 'City B'. The Reference query uses a subquery with UNION ALL to combine individual city capacities before summing, while the Generated query directly sums capacities where the city is in the specified list. Both produce identical results (500000 + 600000 = 1100000). However, the Generated query is more efficient and elegant as it avoids unnecessary subquery complexity and performs a single table scan with a simple WHERE clause. The business intent of summing capacities for the two cities is fully addressed by both, but the Generated query does so with better performance and clarity.", "overall_assessment": "correct"}}
{"example_id": 880, "sql_complexity": "aggregation", "prompt": "Show veteran employment statistics for each state in the 'veteran_employment' table", "context": "CREATE TABLE veteran_employment (employee_id INT, state VARCHAR(2), job_title VARCHAR(50), employment_date DATE);", "reference_sql": "SELECT state, COUNT(*) as veteran_employees FROM veteran_employment WHERE state IN ('CA', 'NY', 'TX', 'FL', 'PA') GROUP BY state;", "generated_sql": "SELECT \n    state,\n    COUNT(*) AS total_employees,\n    COUNT(DISTINCT employee_id) AS unique_employees,\n    MIN(employment_date) AS earliest_employment,\n    MAX(employment_date) AS latest_employment\nFROM \n    veteran_employment\nGROUP BY \n    state;", "raw_model_output": "SELECT \n    state,\n    COUNT(*) AS total_employees,\n    COUNT(DISTINCT employee_id) AS unique_employees,\n    MIN(employment_date) AS earliest_employment,\n    MAX(employment_date) AS latest_employment\nFROM \n    veteran_employment\nGROUP BY \n    state;", "latency_sec": 0.6715030670166016, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 110, "prompt_eval_sec": null, "tokens_completion": 62, "completion_eval_sec": null, "tokens_total": 172, "tokens_per_sec": 256.14179360963016, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL only returns 'state' and 'veteran_employees' (COUNT(*)), while the Generated SQL includes additional columns: 'total_employees' (COUNT(*)), 'unique_employees' (COUNT(DISTINCT employee_id)), 'earliest_employment', and 'latest_employment'. The Generated SQL also lacks the WHERE state IN (...) filter present in the Reference SQL. The additional aggregates and missing filter make the results structurally and semantically different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query explicitly filters for specific states ('CA', 'NY', 'TX', 'FL', 'PA') and only returns a count of employees per state, while the generated query returns broader statistics (total employees, unique employees, employment date ranges) without state restrictions. The original question asks for statistics 'for each state in the table' without specifying particular states, making the generated query more aligned with the implicit requirement to include all states. The generated query also provides more comprehensive statistical insights (e.g., MIN/MAX dates) that better fulfill the 'statistics' request. However, neither query uses the term 'veteran' in the calculation, which could be a semantic issue if the table contains non-veteran employees.", "overall_assessment": "differently_correct"}}
{"example_id": 454, "sql_complexity": "single join", "prompt": "Which excavation sites have more than 10 artifacts?", "context": "CREATE TABLE ExcavationSite (SiteID INT, SiteName VARCHAR(50)); INSERT INTO ExcavationSite (SiteID, SiteName) VALUES (1, 'Site A'), (2, 'Site B'), (3, 'Site C'); CREATE TABLE Artifact (ArtifactID INT, SiteID INT, ObjectType VARCHAR(50)); INSERT INTO Artifact (ArtifactID, SiteID, ObjectType) VALUES (1, 1, 'Pottery'), (2, 1, 'Tool'), (3, 2, 'Statue'), (4, 2, 'Bead'), (5, 3, 'Bead'), (6, 3, 'Bead'), (7, 3, 'Bead'), (8, 3, 'Bead'), (9, 3, 'Bead'), (10, 3, 'Bead'), (11, 3, 'Bead');", "reference_sql": "SELECT e.SiteName FROM ExcavationSite e JOIN Artifact a ON e.SiteID = a.SiteID GROUP BY e.SiteName HAVING COUNT(a.ArtifactID) > 10;", "generated_sql": "SELECT SiteID, SiteName\nFROM ExcavationSite\nWHERE SiteID IN (\n    SELECT SiteID\n    FROM Artifact\n    GROUP BY SiteID\n    HAVING COUNT(*) > 10\n);", "raw_model_output": "SELECT SiteID, SiteName\nFROM ExcavationSite\nWHERE SiteID IN (\n    SELECT SiteID\n    FROM Artifact\n    GROUP BY SiteID\n    HAVING COUNT(*) > 10\n);", "latency_sec": 0.6158618927001953, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 268, "prompt_eval_sec": null, "tokens_completion": 43, "completion_eval_sec": null, "tokens_total": 311, "tokens_per_sec": 504.98334721839393, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries identify excavation sites with more than 10 artifacts. The Reference SQL groups by SiteName (which is unique in the data) and counts artifacts, while the Generated SQL uses a subquery to find SiteIDs with >10 artifacts and retrieves their details. Since SiteID and SiteName are uniquely correlated in the given data, both produce the same result. However, the Generated SQL is more robust as it groups by the primary key (SiteID), avoiding potential issues with non-unique SiteNames in other scenarios.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query groups by SiteName (which may not be unique) and counts ArtifactID, while the generated query groups by SiteID (the true primary key) and counts all artifacts. The generated query is more accurate because it uses SiteID for grouping, avoiding potential errors if SiteNames were non-unique. Both fulfill the business intent of identifying sites with >10 artifacts, but the generated query is more efficient and semantically precise. The reference query's GROUP BY on SiteName could produce incorrect results if multiple sites shared the same name, which is not explicitly ruled out in the schema.", "overall_assessment": "differently_correct"}}
{"example_id": 1086, "sql_complexity": "aggregation", "prompt": "What is the total CO2 emission for each equipment type, excluding equipment that is older than 8 years?", "context": "CREATE TABLE EmissionData (EquipmentID INT, EquipmentType VARCHAR(50), CO2Emission INT, Age INT); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (1, 'Excavator', 50, 8); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (2, 'Haul Truck', 70, 7); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (3, 'Shovel', 30, 6); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (4, 'Drilling Rig', 40, 3);", "reference_sql": "SELECT EquipmentType, SUM(CO2Emission) as TotalCO2Emission FROM EmissionData WHERE Age <= 8 GROUP BY EquipmentType;", "generated_sql": "SELECT EquipmentType, SUM(CO2Emission) AS TotalCO2Emission\nFROM EmissionData\nWHERE Age <= 8\nGROUP BY EquipmentType;", "raw_model_output": "SELECT EquipmentType, SUM(CO2Emission) AS TotalCO2Emission\nFROM EmissionData\nWHERE Age <= 8\nGROUP BY EquipmentType;", "latency_sec": 1.1268188953399658, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 244, "prompt_eval_sec": null, "tokens_completion": 33, "completion_eval_sec": null, "tokens_total": 277, "tokens_per_sec": 245.82477374629752, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select EquipmentType and sum CO2Emission with the same WHERE condition (Age <= 8) and GROUP BY clause. The only differences are whitespace and formatting, which do not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure, logic, and output. They correctly filter equipment with Age <= 8 (excluding those older than 8 years) and calculate total CO2 emissions per EquipmentType. The WHERE condition aligns with the business requirement to exclude equipment older than 8 years. The GROUP BY and SUM operations properly aggregate emissions by equipment type. No differences exist in syntax, efficiency, or semantic meaning between the two queries.", "overall_assessment": "correct"}}
{"example_id": 3455, "sql_complexity": "basic SQL", "prompt": "What are the names of all innovation projects in the 'rural_infrastructure' table, excluding those with a budget over 50000?", "context": "CREATE TABLE rural_infrastructure (name VARCHAR(255), budget INT); INSERT INTO rural_infrastructure (name, budget) VALUES ('Dam Construction', 40000), ('Well Digging', 30000), ('Irrigation System', 70000);", "reference_sql": "SELECT name FROM rural_infrastructure WHERE budget <= 50000;", "generated_sql": "SELECT name\nFROM rural_infrastructure\nWHERE name LIKE '%innovation%'\n  AND budget <= 50000;", "raw_model_output": "SELECT name\nFROM rural_infrastructure\nWHERE name LIKE '%innovation%'\n  AND budget <= 50000;", "latency_sec": 0.5774788856506348, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 147, "prompt_eval_sec": null, "tokens_completion": 23, "completion_eval_sec": null, "tokens_total": 170, "tokens_per_sec": 294.3830575008195, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query selects all projects with a budget <= 50000, which includes 'Dam Construction' (40000) and 'Well Digging' (30000). The generated query adds an additional condition WHERE name LIKE '%innovation%', which matches no rows in the given data. This makes the generated query return an empty result set, while the reference query returns two rows. The extra name filter in the generated query changes the semantic meaning.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query selects all projects with budget \u226450000 without checking for 'innovation' in the name, while the generated query adds a name filter for 'innovation' which is explicitly required by the question. The reference query fails to fulfill the business intent because it does not filter for 'innovation projects' as specified. The generated query correctly incorporates both conditions (name pattern and budget limit), even though the sample data contains no matching rows. The generated query better addresses the original question's requirements.", "overall_assessment": "differently_correct"}}
{"example_id": 3936, "sql_complexity": "window functions", "prompt": "What is the total investment per client for each investment type?", "context": "CREATE TABLE clients (client_id INT, name TEXT, investment_type TEXT, investment FLOAT); INSERT INTO clients (client_id, name, investment_type, investment) VALUES (1, 'John Doe', 'Stocks', 3000.00), (1, 'John Doe', 'Bonds', 2000.00), (2, 'Jane Smith', 'Stocks', 5000.00);", "reference_sql": "SELECT client_id, name, investment_type, SUM(investment) OVER (PARTITION BY client_id, investment_type ORDER BY client_id) as total_investment FROM clients;", "generated_sql": "SELECT \n    client_id, \n    investment_type, \n    SUM(investment) AS total_investment\nFROM \n    clients\nGROUP BY \n    client_id, \n    investment_type;", "raw_model_output": "SELECT \n    client_id, \n    investment_type, \n    SUM(investment) AS total_investment\nFROM \n    clients\nGROUP BY \n    client_id, \n    investment_type;", "latency_sec": 0.8790988922119141, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 161, "prompt_eval_sec": null, "tokens_completion": 42, "completion_eval_sec": null, "tokens_total": 203, "tokens_per_sec": 230.91827529122307, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL includes the 'name' column and uses a window function to calculate a running total, while the Generated SQL groups by client_id and investment_type, omitting the 'name' column and aggregating values. The presence of the 'name' column and different aggregation logic (window function vs. GROUP BY) result in different output structures and potential data differences.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query uses a window function to calculate a running total per client/investment type, but it includes redundant rows (one per original record) with the same total value. The generated query properly aggregates data into one row per client/investment type combination using GROUP BY, which directly answers the question. While both queries calculate the correct sum, the generated version is more efficient and semantically aligned with the business requirement for 'total investment per client for each investment type'. The reference query's inclusion of the name column and window function logic introduces unnecessary complexity.", "overall_assessment": "correct"}}
{"example_id": 1838, "sql_complexity": "window functions", "prompt": "What are the top 3 species with the most sightings across all arctic research stations?", "context": "CREATE TABLE research_station (id INT, name TEXT); INSERT INTO research_station (id, name) VALUES (1, 'Station A'); INSERT INTO research_station (id, name) VALUES (2, 'Station B'); CREATE TABLE species_observations (station_id INT, species_name TEXT, sightings INT); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (1, 'Species 1', 10); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (1, 'Species 2', 5); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (2, 'Species 1', 8); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (2, 'Species 3', 15);", "reference_sql": "SELECT species_name, SUM(sightings) as total_sightings, RANK() OVER (ORDER BY SUM(sightings) DESC) as rank FROM species_observations GROUP BY species_name HAVING rank <= 3;", "generated_sql": "SELECT species_name, SUM(sightings) AS total_sightings\nFROM species_observations\nGROUP BY species_name\nORDER BY total_sightings DESC\nLIMIT 3;", "raw_model_output": "SELECT species_name, SUM(sightings) AS total_sightings\nFROM species_observations\nGROUP BY species_name\nORDER BY total_sightings DESC\nLIMIT 3;", "latency_sec": 1.138988971710205, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 256, "prompt_eval_sec": null, "tokens_completion": 39, "completion_eval_sec": null, "tokens_total": 295, "tokens_per_sec": 259.00162980248535, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses a RANK() window function in the SELECT clause and attempts to filter with HAVING rank <= 3, but HAVING cannot reference window function aliases. The Generated SQL correctly uses ORDER BY and LIMIT to achieve the same result. The Reference SQL is invalid syntax and would not execute, making the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL contains a critical technical error: the HAVING clause attempts to filter using 'rank', which is an alias from the SELECT clause. In SQL, aliases from the SELECT cannot be used in HAVING clauses. Additionally, RANK() is a window function that requires a valid OVER() clause, which is missing here. The Generated SQL correctly groups by species_name, sums sightings, orders by total sightings in descending order, and limits to 3 results, which directly answers the business question. While both queries aim to find top species, the Reference SQL would fail execution due to syntax issues, whereas the Generated SQL is technically correct and semantically equivalent to the intended result.", "overall_assessment": "incorrect"}}
{"example_id": 3091, "sql_complexity": "single join", "prompt": "Find the number of hybrid vehicles sold in the US, Germany, and Japan.", "context": "CREATE TABLE vehicle_sales (sale_id INT, vehicle_id INT, country VARCHAR(20), quantity INT); CREATE TABLE vehicles (vehicle_id INT, model VARCHAR(20), manufacture VARCHAR(20), vehicle_type VARCHAR(20));", "reference_sql": "SELECT SUM(vs.quantity) FROM vehicle_sales vs JOIN vehicles v ON vs.vehicle_id = v.vehicle_id WHERE v.vehicle_type = 'hybrid' AND vs.country IN ('US', 'Germany', 'Japan');", "generated_sql": "SELECT country, SUM(quantity) AS total_hybrid_vehicles_sold\nFROM vehicle_sales\nJOIN vehicles ON vehicle_sales.vehicle_id = vehicles.vehicle_id\nWHERE vehicle_type = 'hybrid' AND country IN ('US', 'Germany', 'Japan')\nGROUP BY country;", "raw_model_output": "SELECT country, SUM(quantity) AS total_hybrid_vehicles_sold\nFROM vehicle_sales\nJOIN vehicles ON vehicle_sales.vehicle_id = vehicles.vehicle_id\nWHERE vehicle_type = 'hybrid' AND country IN ('US', 'Germany', 'Japan')\nGROUP BY country;", "latency_sec": 1.3305389881134033, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 128, "prompt_eval_sec": null, "tokens_completion": 56, "completion_eval_sec": null, "tokens_total": 184, "tokens_per_sec": 138.28982212757037, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns a single total sum of quantities for all 'hybrid' vehicles sold in specified countries, while the Generated SQL groups results by country, returning separate sums for each country. The output structure and results differ.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query correctly aggregates total hybrid vehicle sales across all three countries in a single value, matching the original question's request for 'the number' (singular) of hybrid vehicles. The generated query groups results by country, producing separate totals for each country instead of a combined total. While both queries correctly filter for hybrid vehicles in the specified countries, their output structures differ: the reference returns a single scalar value whereas the generated query returns three rows. The original question implies a single numerical answer rather than per-country breakdowns.", "overall_assessment": "correct"}}
{"example_id": 2399, "sql_complexity": "set operations", "prompt": "What is the average duration of criminal trials for Indigenous defendants compared to non-Indigenous defendants in Canada and New Zealand?", "context": "CREATE TABLE canada_criminal_trials (id INT, defendant_type VARCHAR(255), days_to_completion INT); INSERT INTO canada_criminal_trials (id, defendant_type, days_to_completion) VALUES (1, 'Indigenous', 60), (2, 'Non-Indigenous', 45);CREATE TABLE nz_criminal_trials (id INT, defendant_type VARCHAR(255), days_to_completion INT); INSERT INTO nz_criminal_trials (id, defendant_type, days_to_completion) VALUES (1, 'Indigenous', 70), (2, 'Non-Indigenous', 50);", "reference_sql": "SELECT AVG(days_to_completion) AS avg_duration FROM canada_criminal_trials WHERE defendant_type = 'Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM canada_criminal_trials WHERE defendant_type = 'Non-Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM nz_criminal_trials WHERE defendant_type = 'Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM nz_criminal_trials WHERE defendant_type = 'Non-Indigenous';", "generated_sql": "SELECT \n    'Canada' AS country,\n    AVG(CASE WHEN defendant_type = 'Indigenous' THEN days_to_completion END) AS avg_days_indigenous,\n    AVG(CASE WHEN defendant_type = 'Non-Indigenous' THEN days_to_completion END) AS avg_days_non_indigenous\nFROM canada_criminal_trials\n\nUNION ALL\n\nSELECT \n    'New Zealand' AS country,\n    AVG(CASE WHEN defendant_type = 'Indigenous' THEN days_to_completion END) AS avg_days_indigenous,\n    AVG(CASE WHEN defendant_type = 'Non-Indigenous' THEN days_to_completion END) AS avg_days_non_indigenous\nFROM nz_criminal_trials;", "raw_model_output": "SELECT \n    'Canada' AS country,\n    AVG(CASE WHEN defendant_type = 'Indigenous' THEN days_to_completion END) AS avg_days_indigenous,\n    AVG(CASE WHEN defendant_type = 'Non-Indigenous' THEN days_to_completion END) AS avg_days_non_indigenous\nFROM canada_criminal_trials\n\nUNION ALL\n\nSELECT \n    'New Zealand' AS country,\n    AVG(CASE WHEN defendant_type = 'Indigenous' THEN days_to_completion END) AS avg_days_indigenous,\n    AVG(CASE WHEN defendant_type = 'Non-Indigenous' THEN days_to_completion END) AS avg_days_non_indigenous\nFROM nz_criminal_trials;", "latency_sec": 1.0849967002868652, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 208, "prompt_eval_sec": null, "tokens_completion": 136, "completion_eval_sec": null, "tokens_total": 344, "tokens_per_sec": 317.05165546498796, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns four rows with single average values for each combination of country and defendant type, while the Generated SQL returns two rows with two average values per row (structured by country). The result set structures differ: the Reference has 4 rows \u00d7 1 column, and the Generated has 2 rows \u00d7 2 columns. Although the computed averages are numerically identical, the semantic structure of the output differs, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query returns four separate rows with individual averages, while the generated query returns two rows with combined averages per country. The generated query better fulfills the business intent by structuring results to directly compare Indigenous and non-Indigenous averages within each country. It is more efficient as it processes each country's data once with conditional aggregation rather than executing four separate queries. The generated query also produces a more interpretable result set for comparative analysis.", "overall_assessment": "differently_correct"}}
{"example_id": 2972, "sql_complexity": "set operations", "prompt": "How many indigenous communities are in the Arctic Research Station 13 and 14?", "context": "CREATE TABLE Arctic_Research_Station_13 (id INT, community TEXT); CREATE TABLE Arctic_Research_Station_14 (id INT, community TEXT);", "reference_sql": "SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_13; SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_14; SELECT COUNT(DISTINCT community) FROM (SELECT * FROM Arctic_Research_Station_13 UNION ALL SELECT * FROM Arctic_Research_Station_14) AS Arctic_Communities;", "generated_sql": "SELECT \n  (SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_13) +\n  (SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_14) AS total_indigenous_communities;", "raw_model_output": "SELECT \n  (SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_13) +\n  (SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_14) AS total_indigenous_communities;", "latency_sec": 1.7269082069396973, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 115, "prompt_eval_sec": null, "tokens_completion": 48, "completion_eval_sec": null, "tokens_total": 163, "tokens_per_sec": 94.38834058751559, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL computes three separate counts: distinct communities in each table individually and a combined count across both tables. The Generated SQL sums the individual counts from each table. However, this sum overcounts communities present in both tables, whereas the third Reference query uses UNION ALL (which preserves duplicates) before counting distinct values. The generated query does not replicate the third Reference query's behavior of counting distinct communities across both tables combined.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference queries correctly address the need to count unique communities across both stations. The third reference query uses UNION ALL to combine records from both stations before counting distinct communities, ensuring overlapping communities are not double-counted. The generated SQL incorrectly sums individual counts from each station, which would overcount communities present in both stations. While the generated query is more efficient, it fails to meet the business requirement of identifying unique communities across the combined dataset.", "overall_assessment": "incorrect"}}
{"example_id": 5576, "sql_complexity": "window functions", "prompt": "Who are the top 5 users with the most followers, and what is their location?", "context": "CREATE TABLE user_data (user_id INT, name VARCHAR(50), followers INT, location VARCHAR(50)); INSERT INTO user_data (user_id, name, followers, location) VALUES (1, 'Alice', 10000, 'New York'), (2, 'Bob', 15000, 'California'), (3, 'Charlie', 12000, 'Texas'), (4, 'David', 8000, 'Florida'), (5, 'Eve', 9000, 'Illinois');", "reference_sql": "SELECT name, location FROM (SELECT name, location, ROW_NUMBER() OVER (ORDER BY followers DESC) AS rank FROM user_data) AS user_ranks WHERE rank <= 5;", "generated_sql": "SELECT name, location\nFROM user_data\nORDER BY followers DESC\nLIMIT 5;", "raw_model_output": "SELECT name, location\nFROM user_data\nORDER BY followers DESC\nLIMIT 5;", "latency_sec": 0.566910982131958, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 189, "prompt_eval_sec": null, "tokens_completion": 19, "completion_eval_sec": null, "tokens_total": 208, "tokens_per_sec": 366.90063617710007, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the top 5 users by followers in descending order. The Reference SQL uses ROW_NUMBER() to assign ranks and filters where rank <= 5, while the Generated SQL directly orders by followers and limits to 5 rows. Since all followers values in the sample data are unique, both approaches yield the same result. The subquery in the Reference SQL is redundant but does not affect the outcome in this case.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly retrieve the top 5 users by followers and their locations. The Reference SQL uses a window function with ROW_NUMBER() and a subquery, which works but is unnecessarily complex. The Generated SQL achieves the same result with simpler, more efficient syntax using ORDER BY and LIMIT. While both produce identical results in this specific case (due to unique follower counts), the Generated SQL is more elegant and efficient. The Reference SQL could behave differently if there were ties in follower counts (due to ROW_NUMBER() vs. OFFSET FETCH logic), but this scenario isn't present in the sample data.", "overall_assessment": "correct"}}
{"example_id": 1560, "sql_complexity": "basic SQL", "prompt": "What is the average media literacy score for users in the 'Young Adult' age group who have completed at least one disinformation detection course?", "context": "CREATE TABLE users (id INT, age VARCHAR(20), media_literacy_score INT, courses_completed INT);", "reference_sql": "SELECT AVG(media_literacy_score) FROM users WHERE age = 'Young Adult' AND courses_completed > 0;", "generated_sql": "SELECT AVG(media_literacy_score) AS average_score\nFROM users\nWHERE age = 'Young Adult' AND courses_completed >= 1;", "raw_model_output": "SELECT AVG(media_literacy_score) AS average_score\nFROM users\nWHERE age = 'Young Adult' AND courses_completed >= 1;", "latency_sec": 1.2091989517211914, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 118, "prompt_eval_sec": null, "tokens_completion": 30, "completion_eval_sec": null, "tokens_total": 148, "tokens_per_sec": 122.39507798889062, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The conditions 'courses_completed > 0' and 'courses_completed >= 1' are equivalent for integer values. Both ensure only rows with a positive count of completed courses are included. The generated query adds an alias ('average_score') which does not affect the result's semantic meaning.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the average media literacy score for 'Young Adult' users with at least one completed course. The conditions 'courses_completed > 0' (reference) and 'courses_completed >= 1' (generated) are logically equivalent. The generated query adds an alias for clarity but does not alter the result. Both address the business intent accurately, with no differences in efficiency or correctness.", "overall_assessment": "correct"}}
{"example_id": 1201, "sql_complexity": "basic SQL", "prompt": "What is the maximum energy efficiency rating of hydroelectric dams in Canada?", "context": "CREATE TABLE hydro_dams (id INT, name TEXT, country TEXT, energy_efficiency_rating FLOAT); INSERT INTO hydro_dams (id, name, country, energy_efficiency_rating) VALUES (1, 'Robert-Bourassa', 'Canada', 0.94), (2, 'Churchill Falls', 'Canada', 0.92);", "reference_sql": "SELECT MAX(energy_efficiency_rating) FROM hydro_dams WHERE country = 'Canada';", "generated_sql": "SELECT MAX(energy_efficiency_rating) AS max_efficiency_rating\nFROM hydro_dams\nWHERE country = 'Canada';", "raw_model_output": "SELECT MAX(energy_efficiency_rating) AS max_efficiency_rating\nFROM hydro_dams\nWHERE country = 'Canada';", "latency_sec": 7.735118865966797, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 153, "prompt_eval_sec": null, "tokens_completion": 26, "completion_eval_sec": null, "tokens_total": 179, "tokens_per_sec": 23.14120870043374, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the maximum energy_efficiency_rating from hydro_dams where country is 'Canada'. The generated query adds an alias (max_efficiency_rating) for the MAX column, but this does not affect the actual data returned - the scalar value remains the same.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the maximum energy efficiency rating for Canadian hydroelectric dams. The reference query uses minimal syntax, while the generated query adds an explicit column alias ('max_efficiency_rating'). The alias improves readability and clarity in results without altering the computation. Since the original question only requires the maximum value (not the column name), both queries produce identical results and fulfill the business intent equally well. The generated query is slightly more elegant due to the alias, but neither is technically superior in this context.", "overall_assessment": "correct"}}
{"example_id": 4243, "sql_complexity": "single join", "prompt": "How many orders were placed by new and returning customers in each month of the year 2021?'", "context": "CREATE TABLE customer (id INT, first_order_date DATE, last_order_date DATE);", "reference_sql": "INSERT INTO customer (id, first_order_date, last_order_date) SELECT customer_id, MIN(order_date) AS first_order_date, MAX(order_date) AS last_order_date FROM orders GROUP BY customer_id; SELECT YEAR(order_date) AS year, MONTH(order_date) AS month, CASE WHEN DATEDIFF(last_order_date, first_order_date) > 30 THEN 'returning' ELSE 'new' END AS customer_type, COUNT(DISTINCT id) AS num_orders FROM orders JOIN customer ON orders.customer_id = customer.id WHERE YEAR(order_date) = 2021 GROUP BY year, month, customer_type;", "generated_sql": "SELECT\n    EXTRACT(YEAR FROM first_order_date) AS year,\n    EXTRACT(MONTH FROM first_order_date) AS month,\n    COUNT(*) AS total_orders,\n    CASE\n        WHEN first_order_date = last_order_date THEN 'New Customer'\n        ELSE 'Returning Customer'\n    END AS customer_type\nFROM customer\nWHERE\n    first_order_date >= '2021-01-01' AND first_order_date < '2022-01-01'\nGROUP BY\n    year,\n    month,\n    customer_type\nORDER BY\n    year,\n    month,\n    customer_type;", "raw_model_output": "```sql\nSELECT\n    EXTRACT(YEAR FROM first_order_date) AS year,\n    EXTRACT(MONTH FROM first_order_date) AS month,\n    COUNT(*) AS total_orders,\n    CASE\n        WHEN first_order_date = last_order_date THEN 'New Customer'\n        ELSE 'Returning Customer'\n    END AS customer_type\nFROM customer\nWHERE\n    first_order_date >= '2021-01-01' AND first_order_date < '2022-01-01'\nGROUP BY\n    year,\n    month,\n    customer_type\nORDER BY\n    year,\n    month,\n    customer_type;\n```", "latency_sec": 1.0790038108825684, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 105, "prompt_eval_sec": null, "tokens_completion": 127, "completion_eval_sec": null, "tokens_total": 232, "tokens_per_sec": 215.01314236345115, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query analyzes order data to categorize customers as 'new' or 'returning' based on the 30-day gap between first/last orders, while the generated query uses a different logic (first_order_date = last_order_date) to classify customers. Additionally, the reference query counts distinct customer IDs from orders in 2021, whereas the generated query counts all customers with first orders in 2021, leading to different aggregation targets and results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly counts orders (not customers) by analyzing order data with proper customer-type classification based on order history. It uses a JOIN between orders and customer tables, grouping by order month and customer_type. The Generated SQL incorrectly counts customers instead of orders (COUNT(*) vs COUNT(DISTINCT id)), and uses a flawed customer_type logic (first_order_date = last_order_date) that doesn't align with the business definition of 'new/returning'. The Reference SQL also properly filters for 2021 orders. While both have logical issues (e.g., the Reference's DATEDIFF approach might not accurately define returning customers), the Generated SQL fundamentally misrepresents the metric being measured.", "overall_assessment": "incorrect"}}
{"example_id": 2321, "sql_complexity": "subqueries", "prompt": "What are the names and types of vessels used in research expeditions in the regions with the lowest ocean acidification levels?", "context": "CREATE TABLE ocean_acidification (id INT PRIMARY KEY, region VARCHAR(255), year INT, acidification_level INT); INSERT INTO ocean_acidification (id, region, year, acidification_level) VALUES (1, 'Arctic Ocean', 2018, 20), (2, 'Southern Ocean', 2019, 22); CREATE TABLE expedition_vessels (id INT PRIMARY KEY, name VARCHAR(255), type VARCHAR(255), region VARCHAR(255)); INSERT INTO expedition_vessels (id, name, type, region) VALUES (1, 'Sea Researcher', 'Research Vessel', 'Arctic Ocean');", "reference_sql": "SELECT v.name, v.type FROM expedition_vessels v INNER JOIN ocean_acidification oa ON v.region = oa.region WHERE oa.acidification_level = (SELECT MIN(acidification_level) FROM ocean_acidification);", "generated_sql": "SELECT name, type\nFROM expedition_vessels\nWHERE region IN (\n    SELECT region\n    FROM ocean_acidification\n    WHERE acidification_level = (\n        SELECT MIN(acidification_level)\n        FROM ocean_acidification\n    )\n)\nAND type = 'Research Vessel';", "raw_model_output": "SELECT name, type\nFROM expedition_vessels\nWHERE region IN (\n    SELECT region\n    FROM ocean_acidification\n    WHERE acidification_level = (\n        SELECT MIN(acidification_level)\n        FROM ocean_acidification\n    )\n)\nAND type = 'Research Vessel';", "latency_sec": 0.8856751918792725, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 223, "prompt_eval_sec": null, "tokens_completion": 59, "completion_eval_sec": null, "tokens_total": 282, "tokens_per_sec": 318.40115042811294, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL performs an INNER JOIN between expedition_vessels and ocean_acidification on region, filtering for rows where acidification_level equals the minimum value. The Generated SQL uses a subquery to find regions with the minimum acidification_level and adds an explicit AND type = 'Research Vessel' condition. The Generated SQL introduces an additional filter on the vessel type that the Reference SQL does not include, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL is technically correct but fails to filter for 'Research Vessel' type, which is critical to the business question. It would return all vessel types in regions with the lowest acidification levels, not just research vessels. The Generated SQL explicitly includes the 'Research Vessel' filter, directly addressing the question's requirement. While both queries correctly identify regions with minimum acidification levels, the Generated SQL's additional type filter ensures it fulfills the business intent. The Reference SQL's lack of this filter makes it incomplete for the specific question asked.", "overall_assessment": "differently_correct"}}
{"example_id": 4349, "sql_complexity": "multiple_joins", "prompt": "Show the research grants awarded to professors in the Computer Science department.", "context": "CREATE TABLE departments (id INT, name VARCHAR(50)); INSERT INTO departments (id, name) VALUES (1, 'Computer Science'), (2, 'Mathematics'); CREATE TABLE professors (id INT, name VARCHAR(50), department_id INT); INSERT INTO professors (id, name, department_id) VALUES (1, 'John Smith', 1), (2, 'Jane Doe', 2); CREATE TABLE grants (id INT, professor_id INT, year INT, amount FLOAT); INSERT INTO grants (id, professor_id, year, amount) VALUES (1, 1, 2021, 5000.0), (2, 2, 2020, 7000.0);", "reference_sql": "SELECT professors.name, grants.amount FROM professors INNER JOIN grants ON professors.id = grants.professor_id INNER JOIN departments ON professors.department_id = departments.id WHERE departments.name = 'Computer Science';", "generated_sql": "SELECT g.*\nFROM grants g\nJOIN professors p ON g.professor_id = p.id\nJOIN departments d ON p.department_id = d.id\nWHERE d.name = 'Computer Science';", "raw_model_output": "SELECT g.*\nFROM grants g\nJOIN professors p ON g.professor_id = p.id\nJOIN departments d ON p.department_id = d.id\nWHERE d.name = 'Computer Science';", "latency_sec": 1.3289077281951904, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 227, "prompt_eval_sec": null, "tokens_completion": 39, "completion_eval_sec": null, "tokens_total": 266, "tokens_per_sec": 200.16438640270277, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL selects specific columns (professors.name, grants.amount) while the Generated SQL selects all columns from the grants table (g.*). This difference in selected columns makes them non-equivalent, even though both filter for 'Computer Science' department professors.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent because the Reference SQL explicitly selects professor names and grant amounts, while the Generated SQL uses g.* which returns all grant columns. Both correctly join the necessary tables and filter by 'Computer Science' department, fulfilling the business intent of identifying grants awarded to CS professors. The Reference query is more precise and elegant by explicitly selecting relevant columns, whereas the Generated query may return unnecessary data. Both are correct but the Reference better aligns with the specific information requested.", "overall_assessment": "differently_correct"}}
{"example_id": 476, "sql_complexity": "basic SQL", "prompt": "Insert new food safety records for locations \"A123\", \"B456\", and \"C789\"", "context": "CREATE TABLE food_safety_records (id INT, location VARCHAR(255), inspection_date DATE, violation_count INT);", "reference_sql": "INSERT INTO food_safety_records (location, inspection_date, violation_count) VALUES ('A123', '2022-03-01', 0), ('B456', '2022-03-05', 2), ('C789', '2022-03-10', 1);", "generated_sql": "INSERT INTO food_safety_records (location, inspection_date, violation_count)\nVALUES \n('A123', CURRENT_DATE, 0),\n('B456', CURRENT_DATE, 0),\n('C789', CURRENT_DATE, 0);", "raw_model_output": "INSERT INTO food_safety_records (location, inspection_date, violation_count)\nVALUES \n('A123', CURRENT_DATE, 0),\n('B456', CURRENT_DATE, 0),\n('C789', CURRENT_DATE, 0);", "latency_sec": 0.602532148361206, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 110, "prompt_eval_sec": null, "tokens_completion": 48, "completion_eval_sec": null, "tokens_total": 158, "tokens_per_sec": 262.2266719373157, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL inserts specific historical dates (2022-03-01, 2022-03-05, 2022-03-10) with varying violation counts (0, 2, 1), while the Generated SQL uses CURRENT_DATE (which would insert today's date) and sets all violation_counts to 0. The inspection dates and violation counts differ between the two queries.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because the reference SQL uses specific dates and violation counts while the generated SQL uses CURRENT_DATE and zeros. Both fulfill the business intent of inserting records for the specified locations, but the generated SQL is more efficient and elegant by leveraging database functions (CURRENT_DATE) instead of hardcoded values. The reference SQL may be more precise if specific data was required, but the original question lacked details about inspection dates or violation counts. The generated SQL better addresses the implicit need to record current inspections with baseline violation counts.", "overall_assessment": "differently_correct"}}
{"example_id": 2908, "sql_complexity": "single join", "prompt": "List all co-owners and the properties they own in New York, NY.", "context": "CREATE TABLE properties (id INT, city VARCHAR(50), price INT); CREATE TABLE co_owners (property_id INT, owner_name VARCHAR(50)); INSERT INTO properties (id, city, price) VALUES (1, 'New York', 800000), (2, 'Los Angeles', 600000); INSERT INTO co_owners (property_id, owner_name) VALUES (1, 'David'), (1, 'Ella'), (2, 'Frank');", "reference_sql": "SELECT properties.city, co_owners.owner_name FROM properties INNER JOIN co_owners ON properties.id = co_owners.property_id WHERE properties.city = 'New York';", "generated_sql": "SELECT co_owners.owner_name, properties.id AS property_id, properties.city, properties.price\nFROM co_owners\nJOIN properties ON co_owners.property_id = properties.id\nWHERE properties.city = 'New York';", "raw_model_output": "SELECT co_owners.owner_name, properties.id AS property_id, properties.city, properties.price\nFROM co_owners\nJOIN properties ON co_owners.property_id = properties.id\nWHERE properties.city = 'New York';", "latency_sec": 0.9498929977416992, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 178, "prompt_eval_sec": null, "tokens_completion": 45, "completion_eval_sec": null, "tokens_total": 223, "tokens_per_sec": 234.76328442273615, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects only 'city' and 'owner_name', while the Generated SQL includes additional columns ('property_id', 'price'). Although both queries retrieve data from the same tables with the same join condition and filter, the differing column sets result in different output structures.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because the generated query includes additional columns (property_id, price) not present in the reference. Both correctly join properties and co_owners tables with the same filter for New York, but the generated query provides more detailed property information (ID and price) which better fulfills the business intent of 'listing properties they own.' While the reference query is syntactically correct, it only returns the city (which is redundant for all New York properties) and owner names, making the generated query more informative and aligned with the requirement to show 'properties' (which implies specific property details). Both are efficient, but the generated query's additional context makes it superior for this specific question.", "overall_assessment": "differently_correct"}}
{"example_id": 636, "sql_complexity": "set operations", "prompt": "Insert new data into the 'cosmetic_ingredients' table for a vegan eyeshadow product by brand 'Ara' with ingredients 'Mica', 'Iron Oxide', 'Titanium Dioxide' and 'Zinc Oxide'.", "context": "CREATE TABLE cosmetic_ingredients (ingredient_id INT, product_name TEXT, brand_name TEXT, ingredient_type TEXT);", "reference_sql": "INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type) VALUES (NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient'); INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type, ingredient_name) SELECT ingredient_id, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Mica' FROM cosmetic_ingredients WHERE ingredient_name = 'Mica' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Iron Oxide' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Titanium Dioxide' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Zinc Oxide';", "generated_sql": "INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type)\nVALUES\n(NULL, 'Vegan Eyeshadow', 'Ara', 'Mica'),\n(NULL, 'Vegan Eyeshadow', 'Ara', 'Iron Oxide'),\n(NULL, 'Vegan Eyeshadow', 'Ara', 'Titanium Dioxide'),\n(NULL, 'Vegan Eyeshadow', 'Ara', 'Zinc Oxide');", "raw_model_output": "INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type)\nVALUES\n(NULL, 'Vegan Eyeshadow', 'Ara', 'Mica'),\n(NULL, 'Vegan Eyeshadow', 'Ara', 'Iron Oxide'),\n(NULL, 'Vegan Eyeshadow', 'Ara', 'Titanium Dioxide'),\n(NULL, 'Vegan Eyeshadow', 'Ara', 'Zinc Oxide');", "latency_sec": 0.8349978923797607, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 136, "prompt_eval_sec": null, "tokens_completion": 86, "completion_eval_sec": null, "tokens_total": 222, "tokens_per_sec": 265.86893455179336, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL attempts to insert a row with 'Ingredient' as the ingredient_type and references a non-existent 'ingredient_name' column in its SELECT clause, which would cause an error. The Generated SQL directly inserts four rows with specific ingredient names as the ingredient_type. Additionally, the Reference SQL's first INSERT statement adds a row with 'Ingredient' as the type, while the Generated SQL does not include this. The schema mismatch and differing logic make them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL contains critical technical errors: it references a non-existent 'ingredient_name' column in the schema. The Generated SQL correctly uses only the columns present in the schema (ingredient_id, product_name, brand_name, ingredient_type). While both insert the required ingredients, the Generated SQL directly maps the ingredient names to the ingredient_type column (assuming this is the intended usage), whereas the Reference SQL's first INSERT uses 'Ingredient' as a placeholder. The Generated SQL is simpler, avoids unnecessary complexity, and adheres to the schema constraints.", "overall_assessment": "correct"}}
{"example_id": 3404, "sql_complexity": "multiple_joins", "prompt": "What are the names of startups that have received funding from investors with over 3 million funds, and are involved in Genetic Research or Bioprocess Engineering?", "context": "CREATE TABLE public.investors ( id SERIAL PRIMARY KEY, name VARCHAR(100), type VARCHAR(50), funds INTEGER ); CREATE TABLE public.investments ( id SERIAL PRIMARY KEY, investor_id INTEGER, startup_id INTEGER ); CREATE TABLE public.startups ( id SERIAL PRIMARY KEY, name VARCHAR(100), industry VARCHAR(50), funding INTEGER );", "reference_sql": "SELECT startups.name FROM public.startups JOIN public.investments ON startups.id = investments.startup_id JOIN public.investors ON investments.investor_id = investors.id WHERE (startups.industry = 'Genetic Research' OR startups.industry = 'Bioprocess Engineering') AND investors.funds > 3000000;", "generated_sql": "SELECT s.name\nFROM startups s\nJOIN investments i ON s.id = i.startup_id\nJOIN investors inv ON i.investor_id = inv.id\nWHERE inv.funds > 3000000\n  AND (s.industry = 'Genetic Research' OR s.industry = 'Bioprocess Engineering');", "raw_model_output": "SELECT s.name\nFROM startups s\nJOIN investments i ON s.id = i.startup_id\nJOIN investors inv ON i.investor_id = inv.id\nWHERE inv.funds > 3000000\n  AND (s.industry = 'Genetic Research' OR s.industry = 'Bioprocess Engineering');", "latency_sec": 0.765509843826294, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 167, "prompt_eval_sec": null, "tokens_completion": 67, "completion_eval_sec": null, "tokens_total": 234, "tokens_per_sec": 305.6786295919902, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform the same three-table join (startups-investments-investors) with identical conditions. The only differences are table aliases (public. prefix removed in generated version) and the order of WHERE clause conditions (AND order doesn't affect logic). The semantic meaning remains identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are structurally identical in terms of table joins, filtering conditions, and result selection. The only differences are cosmetic (table aliases: 'startups' vs 's', 'investors' vs 'inv') and formatting (line breaks). Both correctly implement the business logic: filtering startups in specified industries with investments from high-fund investors. Neither query has efficiency issues, as both use equivalent join strategies and WHERE conditions. The business intent is fully addressed by both queries.", "overall_assessment": "correct"}}
{"example_id": 134, "sql_complexity": "subqueries", "prompt": "Who are the top 3 authors with the most citations in the Mathematics department in the past 5 years?", "context": "CREATE TABLE authors (id INT, name VARCHAR(50), department VARCHAR(50)); INSERT INTO authors (id, name, department) VALUES (1, 'Author Name', 'Mathematics'); CREATE TABLE publications (id INT, title VARCHAR(100), author VARCHAR(50), journal VARCHAR(50), year INT, cites INT); INSERT INTO publications (id, title, author, journal, year, cites) VALUES (1, 'Publication Title', 'Author Name', 'Journal Name', 2021, 10);", "reference_sql": "SELECT author, SUM(cites) as total_cites FROM publications WHERE author IN (SELECT name FROM authors WHERE department = 'Mathematics') AND year BETWEEN YEAR(CURRENT_DATE) - 5 AND YEAR(CURRENT_DATE) GROUP BY author ORDER BY total_cites DESC LIMIT 3;", "generated_sql": "SELECT a.name\nFROM authors a\nJOIN publications p ON a.name = p.author\nWHERE a.department = 'Mathematics'\n  AND p.year >= (EXTRACT(YEAR FROM CURRENT_DATE) - 5)\nGROUP BY a.name\nORDER BY SUM(p.cites) DESC\nLIMIT 3;", "raw_model_output": "SELECT a.name\nFROM authors a\nJOIN publications p ON a.name = p.author\nWHERE a.department = 'Mathematics'\n  AND p.year >= (EXTRACT(YEAR FROM CURRENT_DATE) - 5)\nGROUP BY a.name\nORDER BY SUM(p.cites) DESC\nLIMIT 3;", "latency_sec": 0.8574988842010498, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 196, "prompt_eval_sec": null, "tokens_completion": 64, "completion_eval_sec": null, "tokens_total": 260, "tokens_per_sec": 303.2073916250604, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their selected columns. The Reference SQL returns both 'author' and 'total_cites', while the Generated SQL only returns 'a.name'. Additionally, the Generated SQL's ORDER BY clause references 'SUM(p.cites)' but does not include it in the output, making the result sets structurally different.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify the top 3 Mathematics authors by citations in the past 5 years. The Reference uses a subquery to filter authors and aggregates citations directly from publications, while the Generated uses an explicit JOIN between authors and publications. The Generated query is more efficient due to the JOIN, which avoids potential issues with duplicate author names (e.g., multiple authors with the same name in different departments). Both handle the year range correctly (past 5 years), but the Generated's use of EXTRACT(YEAR FROM CURRENT_DATE) is more precise than YEAR(CURRENT_DATE) in some SQL dialects. The Generated query also avoids selecting unnecessary columns (total_cites) while still achieving the same result. Both fulfill the business intent, but the Generated query is more elegant and robust.", "overall_assessment": "correct"}}
{"example_id": 592, "sql_complexity": "set operations", "prompt": "How many public healthcare facilities and public parks are there in total, in the 'StateData' schema's 'StateHealthcare' and 'StateParks' tables?", "context": "CREATE SCHEMA StateData; CREATE TABLE StateHealthcare (Name varchar(255), Type varchar(255)); INSERT INTO StateHealthcare (Name, Type) VALUES ('FacilityA', 'Public'), ('FacilityB', 'Public'), ('FacilityC', 'Private'); CREATE TABLE StateParks (Name varchar(255), Type varchar(255)); INSERT INTO StateParks (Name, Type) VALUES ('ParkA', 'Public'), ('ParkB', 'Public'), ('ParkC', 'Private');", "reference_sql": "SELECT COUNT(*) FROM StateData.StateHealthcare WHERE Type = 'Public' UNION ALL SELECT COUNT(*) FROM StateData.StateParks WHERE Type = 'Public';", "generated_sql": "SELECT \n  (SELECT COUNT(*) FROM StateData.StateHealthcare WHERE Type = 'Public') +\n  (SELECT COUNT(*) FROM StateData.StateParks WHERE Type = 'Public') AS TotalPublicFacilitiesAndParks;", "raw_model_output": "SELECT \n  (SELECT COUNT(*) FROM StateData.StateHealthcare WHERE Type = 'Public') +\n  (SELECT COUNT(*) FROM StateData.StateParks WHERE Type = 'Public') AS TotalPublicFacilitiesAndParks;", "latency_sec": 1.052612066268921, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 200, "prompt_eval_sec": null, "tokens_completion": 45, "completion_eval_sec": null, "tokens_total": 245, "tokens_per_sec": 232.75431457709274, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate counts (one from StateHealthcare and one from StateParks) as two rows via UNION ALL, while the Generated SQL returns a single summed value. The output structure differs (two rows vs. one row with a total), so they are not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query returns two separate counts (one for healthcare, one for parks) in two rows, while the generated query correctly calculates a single total sum of both counts. Both queries correctly filter for 'Public' types, but the generated query better fulfills the business intent of providing a combined total. The generated query is also more efficient as it requires a single query execution with subqueries rather than two separate queries joined by UNION ALL.", "overall_assessment": "differently_correct"}}
{"example_id": 1989, "sql_complexity": "single join", "prompt": "What are the names and production dates of garments made from fabrics with a sustainability score over 70, produced after 2021-01-01?", "context": "CREATE TABLE fabrics (id INT, name VARCHAR(50), type VARCHAR(50), sustainability_score INT); INSERT INTO fabrics (id, name, type, sustainability_score) VALUES (1, 'Organic Linen', 'Natural', 80); INSERT INTO fabrics (id, name, type, sustainability_score) VALUES (2, 'Recycled Nylon', 'Synthetic', 72);", "reference_sql": "SELECT garments.name, garments.production_date FROM garments JOIN fabrics ON garments.fabric_id = fabrics.id WHERE fabrics.sustainability_score > 70 AND garments.production_date > '2021-01-01';", "generated_sql": "SELECT g.name, g.production_date\nFROM garments g\nJOIN fabrics f ON g.fabric_id = f.id\nWHERE f.sustainability_score > 70\n  AND g.production_date > '2021-01-01';", "raw_model_output": "SELECT g.name, g.production_date\nFROM garments g\nJOIN fabrics f ON g.fabric_id = f.id\nWHERE f.sustainability_score > 70\n  AND g.production_date > '2021-01-01';", "latency_sec": 1.0027320384979248, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 173, "prompt_eval_sec": null, "tokens_completion": 48, "completion_eval_sec": null, "tokens_total": 221, "tokens_per_sec": 220.39786454919118, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between 'garments' and 'fabrics' on fabric_id, apply the same filters (sustainability_score > 70 and production_date > '2021-01-01'), and select the same columns. The generated query uses table aliases ('g' for garments, 'f' for fabrics) which do not affect semantic equivalence. The logical structure and conditions are identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent, producing identical results by joining garments and fabrics tables with the same conditions (sustainability_score > 70 and production_date > '2021-01-01'). They both fulfill the business intent by retrieving garment names and production dates meeting the sustainability and temporal criteria. The generated query uses table aliases (g/f) for conciseness, which improves readability without altering logic. Neither query is more efficient than the other, as they execute the same operations. The superiority is 'equal' because both achieve the same outcome with equivalent correctness and elegance.", "overall_assessment": "correct"}}
{"example_id": 1388, "sql_complexity": "aggregation", "prompt": "What was the total donation amount by each organization in the last 30 days?", "context": "CREATE TABLE organization_donations (id INT, organization TEXT, donation_date DATE, donation_amount DECIMAL(10,2)); INSERT INTO organization_donations (id, organization, donation_date, donation_amount) VALUES (1, 'Organization A', '2021-03-15', 100.00), (2, 'Organization B', '2021-03-25', 200.00);", "reference_sql": "SELECT organization, SUM(donation_amount) FROM organization_donations WHERE donation_date >= DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY) GROUP BY organization;", "generated_sql": "SELECT \n    organization, \n    SUM(donation_amount) AS total_donation_amount\nFROM \n    organization_donations\nWHERE \n    donation_date >= CURRENT_DATE - INTERVAL '30 days'\nGROUP BY \n    organization;", "raw_model_output": "SELECT \n    organization, \n    SUM(donation_amount) AS total_donation_amount\nFROM \n    organization_donations\nWHERE \n    donation_date >= CURRENT_DATE - INTERVAL '30 days'\nGROUP BY \n    organization;", "latency_sec": 0.7333199977874756, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 167, "prompt_eval_sec": null, "tokens_completion": 48, "completion_eval_sec": null, "tokens_total": 215, "tokens_per_sec": 293.1871497418368, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the total donations per organization for the last 30 days. The date calculation syntax differs (DATE_SUB vs. CURRENT_DATE - INTERVAL '30 days') but produces the same date range. The column alias difference (total_donation_amount vs. implicit column name) doesn't affect semantic equivalence as the result set structure and values remain the same.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the total donation amount per organization for the last 30 days. The reference query uses MySQL's DATE_SUB function while the generated query uses standard SQL's INTERVAL syntax. The semantic logic (date filtering, aggregation, grouping) is identical. The generated query adds an explicit alias for the sum, which improves readability but doesn't affect functionality. Both would produce identical results given the same database context.", "overall_assessment": "correct"}}
{"example_id": 1628, "sql_complexity": "window functions", "prompt": "What is the ranking of national security measures for Russia based on the publication date?", "context": "CREATE TABLE national_security (id INT, title VARCHAR(255), description TEXT, agency VARCHAR(255), date DATE); INSERT INTO national_security (id, title, description, agency, date) VALUES (1, 'National Cyber Strategy', 'Outlines the approach to protecting the American people and the American way of life in the digital age', 'White House', '2018-09-20'); INSERT INTO national_security (id, title, description, agency, date) VALUES (2, 'Cybersecurity and Infrastructure Security Agency Act of 2018', 'Establishes the Cybersecurity and Infrastructure Security Agency within the Department of Homeland Security', 'Congress', '2018-11-16'); INSERT INTO national_security (id, title, description, agency, date) VALUES (3, 'Russian Military Doctrine', 'Outlines the country\u2019s stance on military security', 'Russian Government', '2014-12-26');", "reference_sql": "SELECT title, description, agency, date, ROW_NUMBER() OVER (PARTITION BY agency ORDER BY date DESC) as ranking FROM national_security WHERE agency = 'Russian Government';", "generated_sql": "SELECT id, title, date\nFROM national_security\nWHERE agency = 'Russian Government'\nORDER BY date ASC;", "raw_model_output": "SELECT id, title, date\nFROM national_security\nWHERE agency = 'Russian Government'\nORDER BY date ASC;", "latency_sec": 0.9108657836914062, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 272, "prompt_eval_sec": null, "tokens_completion": 24, "completion_eval_sec": null, "tokens_total": 296, "tokens_per_sec": 324.9655495899957, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL selects title, description, agency, date, and adds a ranking column using ROW_NUMBER(), while the Generated SQL selects id, title, date and orders by date ascending. The column sets differ, and the Reference SQL includes an additional calculated ranking column. The WHERE clause filters the same agency, but the result structures are incompatible.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL uses ROW_NUMBER() to explicitly calculate a ranking based on date, directly addressing the 'ranking' requirement. The Generated SQL only orders results by date without assigning numerical ranks. While both filter for 'Russian Government', the Reference includes descriptive fields (title, description) and the ranking metric, whereas the Generated SQL omits critical context and fails to implement the ranking logic. The original question explicitly asks for 'ranking', making the Reference SQL the only one that fulfills this requirement.", "overall_assessment": "differently_correct"}}
{"example_id": 2300, "sql_complexity": "aggregation", "prompt": "What is the minimum capacity for schools in each location ('community_development')?", "context": "CREATE TABLE community_development.schools (id INT, name VARCHAR(50), capacity INT, location VARCHAR(50));", "reference_sql": "SELECT location, MIN(capacity) FROM community_development.schools GROUP BY location;", "generated_sql": "SELECT location, MIN(capacity) AS min_capacity\nFROM community_development.schools\nGROUP BY location;", "raw_model_output": "SELECT location, MIN(capacity) AS min_capacity\nFROM community_development.schools\nGROUP BY location;", "latency_sec": 0.5128059387207031, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 107, "prompt_eval_sec": null, "tokens_completion": 23, "completion_eval_sec": null, "tokens_total": 130, "tokens_per_sec": 253.507204546638, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries group schools by location and calculate the minimum capacity per location. The generated query adds an explicit column alias ('min_capacity') for clarity, but this does not affect the semantic result set. The core logic and output structure remain identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the minimum capacity per location using GROUP BY. The reference query omits an alias for the aggregated column, while the generated query explicitly names it 'min_capacity'. This makes the generated query more readable and semantically clear, though both produce identical results. The generated version better fulfills the business intent by providing a descriptive column name, enhancing usability for end-users or downstream systems.", "overall_assessment": "correct"}}
{"example_id": 4976, "sql_complexity": "set operations", "prompt": "What is the most common hashtag used in posts made by users from Brazil?", "context": "CREATE TABLE posts (id INT, user_id INT, content TEXT, hashtags TEXT, post_date DATE); INSERT INTO posts (id, user_id, content, hashtags, post_date) VALUES (1, 1, 'Hello World', '#datascience', '2022-06-01'), (2, 1, 'I love data', '#ai', '2022-06-02'), (3, 2, 'Ol\u00e1 Mundo', '#brasil', '2022-06-03'); CREATE TABLE users (id INT, name VARCHAR(100), country VARCHAR(50)); INSERT INTO users (id, name, country) VALUES (1, 'Jo\u00e3o Silva', 'Brazil'), (2, 'Maria Souza', 'Brazil');", "reference_sql": "SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(hashtags, ' ', n.n), ' ', -1) hashtag, COUNT(*) count FROM posts JOIN users ON posts.user_id = users.id CROSS JOIN (SELECT 1 n UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5) n WHERE users.country = 'Brazil' GROUP BY hashtag ORDER BY count DESC LIMIT 1;", "generated_sql": "SELECT hashtags, COUNT(*) AS usage_count\nFROM posts\nJOIN users ON posts.user_id = users.id\nWHERE users.country = 'Brazil'\nGROUP BY hashtags\nORDER BY usage_count DESC\nLIMIT 1;", "raw_model_output": "SELECT hashtags, COUNT(*) AS usage_count\nFROM posts\nJOIN users ON posts.user_id = users.id\nWHERE users.country = 'Brazil'\nGROUP BY hashtags\nORDER BY usage_count DESC\nLIMIT 1;", "latency_sec": 0.6888148784637451, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 235, "prompt_eval_sec": null, "tokens_completion": 44, "completion_eval_sec": null, "tokens_total": 279, "tokens_per_sec": 405.0435156427661, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL splits multi-tag entries in the 'hashtags' column into individual hashtags using SUBSTRING_INDEX, while the Generated SQL groups by the entire 'hashtags' string as a single value. This means the Reference treats each hashtag as a separate entity, whereas the Generated SQL counts combined hashtag strings. For example, a post with '#a #b' would contribute to two entries in the Reference but one in the Generated, leading to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly handles the structure of the hashtags column (which appears to store multiple hashtags separated by spaces) by splitting them into individual elements using SUBSTRING_INDEX. The generated query assumes each row contains a single hashtag, which would only work if the hashtags column strictly contained single tags. In the provided sample data, both queries might return the same result, but the generated query would fail to count multiple hashtags in a single post. The reference query properly addresses the data structure, making it technically correct and better aligned with the business intent of identifying the most common individual hashtag.", "overall_assessment": "incorrect"}}
{"example_id": 4637, "sql_complexity": "single join", "prompt": "What is the total value of transactions for each customer in the last 30 days?", "context": "CREATE TABLE transactions (id INT, customer_id INT, value DECIMAL(10, 2), transaction_date DATE); INSERT INTO transactions (id, customer_id, value, transaction_date) VALUES (1, 1, 100, '2022-01-01'), (2, 1, 200, '2022-01-15'), (3, 2, 50, '2022-01-05'), (4, 2, 150, '2022-01-30'), (5, 3, 300, '2022-01-20');", "reference_sql": "SELECT c.id, SUM(t.value) FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE t.transaction_date >= CURDATE() - INTERVAL 30 DAY GROUP BY c.id;", "generated_sql": "SELECT \n    customer_id, \n    SUM(value) AS total_value_last_30_days\nFROM \n    transactions\nWHERE \n    transaction_date >= CURRENT_DATE - INTERVAL '30 days'\nGROUP BY \n    customer_id;", "raw_model_output": "SELECT \n    customer_id, \n    SUM(value) AS total_value_last_30_days\nFROM \n    transactions\nWHERE \n    transaction_date >= CURRENT_DATE - INTERVAL '30 days'\nGROUP BY \n    customer_id;", "latency_sec": 0.717155933380127, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 208, "prompt_eval_sec": null, "tokens_completion": 47, "completion_eval_sec": null, "tokens_total": 255, "tokens_per_sec": 355.5712058298454, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the total transaction value for each customer over the last 30 days. The Reference SQL joins customers with transactions and groups by customer.id, while the Generated SQL directly groups by customer_id from transactions. Since customer_id in transactions corresponds to customer.id in the customers table, and both use equivalent date filters (CURDATE() - INTERVAL 30 DAY vs CURRENT_DATE - INTERVAL '30 days'), the results will be identical. The join in the Reference SQL is redundant but doesn't affect the outcome due to the foreign key relationship between transactions.customer_id and customers.id.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries differ in three key aspects: 1) The Reference SQL joins with the customers table, ensuring all customers are included (even those with no recent transactions), while the Generated SQL only returns customers with transactions. 2) The date calculation syntax differs: the Reference uses MySQL-compatible syntax (CURDATE() - INTERVAL 30 DAY), while the Generated uses PostgreSQL-style INTERVAL '30 days' which may fail in MySQL. 3) The Reference explicitly references customer IDs from the customers table, avoiding ambiguity. Both fulfill the business intent of calculating 30-day transaction totals, but the Reference is more robust for MySQL environments and handles edge cases (e.g., customers with no transactions).", "overall_assessment": "correct"}}
{"example_id": 4947, "sql_complexity": "aggregation", "prompt": "What is the total revenue for drugs approved between 2017 and 2019?", "context": "CREATE TABLE drug_sales_3 (drug_name TEXT, revenue FLOAT, year INT); INSERT INTO drug_sales_3 (drug_name, revenue, year) VALUES ('DrugG', 20000000, 2019), ('DrugG', 19000000, 2018), ('DrugH', 15000000, 2017), ('DrugH', 16000000, 2018);", "reference_sql": "SELECT drug_name, SUM(revenue) FROM drug_sales_3 WHERE year BETWEEN 2017 AND 2019 GROUP BY drug_name;", "generated_sql": "SELECT SUM(revenue) AS total_revenue\nFROM drug_sales_3\nWHERE year BETWEEN 2017 AND 2019;", "raw_model_output": "SELECT SUM(revenue) AS total_revenue\nFROM drug_sales_3\nWHERE year BETWEEN 2017 AND 2019;", "latency_sec": 0.8029568195343018, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 168, "prompt_eval_sec": null, "tokens_completion": 28, "completion_eval_sec": null, "tokens_total": 196, "tokens_per_sec": 244.09780853928848, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query groups results by drug_name and returns individual drug totals, while the generated query returns a single total revenue without grouping. The first produces multiple rows (one per drug) with drug names, while the second produces a single row without drug names.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query groups results by drug_name, returning per-drug totals, while the generated query returns a single total revenue across all drugs. The original question asks for 'total revenue for drugs' (singular), which implies an overall sum rather than per-drug breakdowns. The generated query directly answers this by aggregating all revenues from 2017-2019. The reference query, while technically correct for a different interpretation, introduces unnecessary grouping that doesn't align with the phrasing of the question. The generated query is more efficient and directly addresses the business intent of calculating a single total revenue figure.", "overall_assessment": "correct"}}
{"example_id": 4767, "sql_complexity": "window functions", "prompt": "List the top 2 AI algorithms with the highest explainability scores, by algorithm subtype, ordered by scores in descending order for the European region.", "context": "CREATE TABLE ai_algorithms (algorithm_id INT, algorithm_name VARCHAR(50), algorithm_subtype VARCHAR(50), region VARCHAR(50), explainability_score FLOAT); INSERT INTO ai_algorithms (algorithm_id, algorithm_name, algorithm_subtype, region, explainability_score) VALUES (1, 'AlgoA', 'Tree-based', 'Europe', 0.85), (2, 'AlgoB', 'Computer Vision', 'Europe', 0.92), (3, 'AlgoC', 'Tree-based', 'Europe', 0.78), (4, 'AlgoD', 'Transformer', 'Europe', 0.90), (5, 'AlgoE', 'Tree-based', 'Europe', 0.80);", "reference_sql": "SELECT algorithm_subtype, region, * FROM (SELECT algorithm_subtype, region, algorithm_id, algorithm_name, explainability_score, RANK() OVER (PARTITION BY algorithm_subtype ORDER BY explainability_score DESC) AS rank FROM ai_algorithms WHERE region = 'Europe') ranked WHERE rank <= 2 ORDER BY algorithm_subtype, region, explainability_score DESC;", "generated_sql": "SELECT algorithm_name, algorithm_subtype, explainability_score\nFROM ai_algorithms\nWHERE region = 'Europe'\nORDER BY algorithm_subtype, explainability_score DESC\nLIMIT 2;", "raw_model_output": "SELECT algorithm_name, algorithm_subtype, explainability_score\nFROM ai_algorithms\nWHERE region = 'Europe'\nORDER BY algorithm_subtype, explainability_score DESC\nLIMIT 2;", "latency_sec": 1.004683017730713, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 246, "prompt_eval_sec": null, "tokens_completion": 39, "completion_eval_sec": null, "tokens_total": 285, "tokens_per_sec": 283.6715610499043, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL selects top 2 algorithms per subtype (e.g., 2 Tree-based, 1 Computer Vision, 1 Transformer) using window functions, while the Generated SQL only returns 2 total rows ordered by subtype and score. The column sets also differ (Generated excludes algorithm_id and region). The result sets have different row counts and content.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly uses a window function to rank algorithms within each algorithm_subtype partition, ensuring the top 2 per subtype are selected. The generated query lacks partitioning and simply limits results globally, which would return only 2 rows total (not 2 per subtype) and fail to group by algorithm_subtype. While both filter for Europe, the generated query's ORDER BY and LIMIT clauses do not address the requirement to rank within subtypes. The reference query explicitly handles the 'by algorithm subtype' requirement through its RANK() implementation.", "overall_assessment": "incorrect"}}
{"example_id": 4495, "sql_complexity": "basic SQL", "prompt": "Which countries are the top 3 sources of sustainable textiles?", "context": "CREATE TABLE Textile_Sources (Source_ID INT, Source_Country TEXT, Sustainable BOOLEAN, Quantity INT); INSERT INTO Textile_Sources (Source_ID, Source_Country, Sustainable, Quantity) VALUES (1, 'India', true, 1000), (2, 'Bangladesh', false, 800), (3, 'China', true, 1200), (4, 'Vietnam', false, 900), (5, 'Italy', true, 1100), (6, 'USA', false, 700);", "reference_sql": "SELECT Source_Country FROM Textile_Sources WHERE Sustainable = true ORDER BY Quantity DESC LIMIT 3;", "generated_sql": "SELECT Source_Country\nFROM Textile_Sources\nWHERE Sustainable = TRUE\nORDER BY Quantity DESC\nLIMIT 3;", "raw_model_output": "SELECT Source_Country\nFROM Textile_Sources\nWHERE Sustainable = TRUE\nORDER BY Quantity DESC\nLIMIT 3;", "latency_sec": 0.8573942184448242, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 188, "prompt_eval_sec": null, "tokens_completion": 25, "completion_eval_sec": null, "tokens_total": 213, "tokens_per_sec": 248.427147533544, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. The only differences are formatting (whitespace and uppercase TRUE) which do not affect SQL execution. Both select Source_Country from Textile_Sources where Sustainable is true, order by Quantity descending, and limit to 3 results. The database schema and data ensure identical output.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are syntactically identical except for the case of the BOOLEAN literal ('true' vs 'TRUE'). SQL is case-insensitive for boolean values, so they will produce identical results. The queries correctly filter sustainable sources (Sustainable = true), order by Quantity descending, and limit to 3 records, which directly addresses the business question about top sustainable textile sources. Neither query has efficiency advantages over the other.", "overall_assessment": "correct"}}
{"example_id": 2513, "sql_complexity": "single join", "prompt": "What is the total number of concert ticket sales for artists who released their first album between 2015 and 2017?", "context": "CREATE TABLE ConcertTicketSales (id INT, year INT, artist_id INT); CREATE TABLE ArtistAlbums (id INT, artist_id INT, year INT);", "reference_sql": "SELECT COUNT(DISTINCT cts.artist_id) FROM ConcertTicketSales cts JOIN ArtistAlbums a ON cts.artist_id = a.artist_id WHERE a.year BETWEEN 2015 AND 2017;", "generated_sql": "SELECT SUM(CTS.id) AS total_ticket_sales\nFROM ConcertTicketSales AS CTS\nJOIN (\n    SELECT artist_id, MIN(year) AS first_album_year\n    FROM ArtistAlbums\n    GROUP BY artist_id\n) AS AA ON CTS.artist_id = AA.artist_id\nWHERE AA.first_album_year BETWEEN 2015 AND 2017;", "raw_model_output": "SELECT SUM(CTS.id) AS total_ticket_sales\nFROM ConcertTicketSales AS CTS\nJOIN (\n    SELECT artist_id, MIN(year) AS first_album_year\n    FROM ArtistAlbums\n    GROUP BY artist_id\n) AS AA ON CTS.artist_id = AA.artist_id\nWHERE AA.first_album_year BETWEEN 2015 AND 2017;", "latency_sec": 0.7605531215667725, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 123, "prompt_eval_sec": null, "tokens_completion": 71, "completion_eval_sec": null, "tokens_total": 194, "tokens_per_sec": 255.07751463875604, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query counts distinct artist_ids from ConcertTicketSales joined with ArtistAlbums where album year is between 2015-2017. The generated query sums CTS.id by joining with a subquery that filters artists based on their first album year (not any album year) in 2015-2017. Additionally, the aggregate functions differ (COUNT(DISTINCT) vs SUM) and the conditions on album years are logically different (any album vs first album).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL incorrectly counts distinct artist_ids where any album was released between 2015-2017, not their first album. The Generated SQL correctly identifies artists with first albums in 2015-2017 via a subquery with MIN(year), but it sums ticket IDs (which likely represent transaction IDs, not actual sales volume). The original question asks for 'total number of concert ticket sales' which likely refers to the count of sales (e.g., COUNT(*) on ConcertTicketSales) rather than artist counts or ID sums. While the Generated SQL better addresses the first-album constraint, both queries fail to accurately measure 'ticket sales' as defined by the schema.", "overall_assessment": "differently_correct"}}
{"example_id": 873, "sql_complexity": "subqueries", "prompt": "Identify attorneys who have never handled cases in the 'West' region but have in the 'North' or 'South'.", "context": "CREATE TABLE attorney_regions(attorney_id INT, region VARCHAR(20)); INSERT INTO attorney_regions(attorney_id, region) VALUES (1, 'North'), (2, 'South'), (3, 'East'), (4, 'West'), (5, 'West'), (6, 'North'); CREATE TABLE handled_cases(attorney_id INT, case_id INT); INSERT INTO handled_cases(attorney_id, case_id) VALUES (1, 101), (2, 102), (3, 103), (4, 104), (5, 105), (6, 106), (1, 107), (1, 108);", "reference_sql": "SELECT h.attorney_id FROM attorney_regions h LEFT JOIN handled_cases i ON h.attorney_id = i.attorney_id WHERE h.region IN ('North', 'South') AND h.region != 'West' AND i.attorney_id IS NOT NULL AND h.attorney_id NOT IN (SELECT attorney_id FROM attorney_regions WHERE region = 'West');", "generated_sql": "SELECT DISTINCT ar.attorney_id\nFROM attorney_regions ar\nWHERE ar.region IN ('North', 'South')\n  AND ar.attorney_id NOT IN (\n    SELECT ar2.attorney_id\n    FROM attorney_regions ar2\n    WHERE ar2.region = 'West'\n  )\n  AND ar.attorney_id IN (\n    SELECT hc.attorney_id\n    FROM handled_cases hc\n    JOIN attorney_regions ar3 ON hc.attorney_id = ar3.attorney_id\n    WHERE ar3.region IN ('North', 'South')\n  );", "raw_model_output": "SELECT DISTINCT ar.attorney_id\nFROM attorney_regions ar\nWHERE ar.region IN ('North', 'South')\n  AND ar.attorney_id NOT IN (\n    SELECT ar2.attorney_id\n    FROM attorney_regions ar2\n    WHERE ar2.region = 'West'\n  )\n  AND ar.attorney_id IN (\n    SELECT hc.attorney_id\n    FROM handled_cases hc\n    JOIN attorney_regions ar3 ON hc.attorney_id = ar3.attorney_id\n    WHERE ar3.region IN ('North', 'South')\n  );", "latency_sec": 1.6722888946533203, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 225, "prompt_eval_sec": null, "tokens_completion": 111, "completion_eval_sec": null, "tokens_total": 336, "tokens_per_sec": 200.92222167728718, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL may return duplicate attorney_ids due to multiple cases, while the Generated SQL uses DISTINCT to eliminate duplicates. Additionally, the Generated SQL's subquery for handled cases includes a redundant join with attorney_regions, but the core difference lies in handling duplicates, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify attorneys in North/South regions who have handled cases and exclude those in West. However, the generated query uses DISTINCT to avoid duplicates (which could occur if an attorney has multiple entries in attorney_regions), making it more robust. The reference query's LEFT JOIN with handled_cases is functionally equivalent to an INNER JOIN due to the i.attorney_id IS NOT NULL condition, but the generated query's structure is more explicit and avoids potential duplicates. Both fulfill the business intent, but the generated query is more elegant and efficient.", "overall_assessment": "correct"}}
{"example_id": 471, "sql_complexity": "set operations", "prompt": "Find the number of donations made by first-time donors in the last quarter.", "context": "CREATE TABLE Donations (DonationID INT, DonorID INT, DonationDate DATE, DonationType TEXT, DonationAmount FLOAT); INSERT INTO Donations (DonationID, DonorID, DonationDate, DonationType, DonationAmount) VALUES (1, 1, '2021-01-01', 'Individual', 100), (2, 2, '2021-02-01', 'Corporate', 5000);", "reference_sql": "SELECT COUNT(*) FROM (SELECT DonationID FROM Donations WHERE DonationType = 'Individual' AND DonationDate >= DATEADD(quarter, -1, CURRENT_DATE) EXCEPT SELECT DonationID FROM PreviousDonations) AS FirstTimeDonors;", "generated_sql": "SELECT COUNT(*) AS FirstTimeDonationsCount\nFROM Donations d1\nWHERE d1.DonationDate >= DATE_SUB(CURRENT_DATE, INTERVAL 3 MONTH)\n  AND NOT EXISTS (\n    SELECT 1\n    FROM Donations d2\n    WHERE d2.DonorID = d1.DonorID\n      AND d2.DonationDate < d1.DonationDate\n  );", "raw_model_output": "SELECT COUNT(*) AS FirstTimeDonationsCount\nFROM Donations d1\nWHERE d1.DonationDate >= DATE_SUB(CURRENT_DATE, INTERVAL 3 MONTH)\n  AND NOT EXISTS (\n    SELECT 1\n    FROM Donations d2\n    WHERE d2.DonorID = d1.DonorID\n      AND d2.DonationDate < d1.DonationDate\n  );", "latency_sec": 7.031239986419678, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 169, "prompt_eval_sec": null, "tokens_completion": 81, "completion_eval_sec": null, "tokens_total": 250, "tokens_per_sec": 35.55560619220174, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL filters for 'Individual' donations in the last quarter and uses an undefined 'PreviousDonations' table in an EXCEPT clause, which is ambiguous. The Generated SQL counts all first-time donations (regardless of type) in the last 3 months by checking for no prior donations from the same donor. The Reference SQL's use of 'DonationType' and undefined table makes it incompatible with the Generated SQL's logic.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL contains an undefined table 'PreviousDonations' which makes it syntactically invalid. The Generated SQL correctly identifies first-time donors by checking for the absence of prior donations using NOT EXISTS. Both queries target donations in the last quarter (DATE_SUB/CURRENT_DATE vs DATEADD(quarter, -1, ...)), but the Generated SQL properly enforces the 'first-time' condition by ensuring no earlier donations exist for the same DonorID. The Generated SQL is both technically correct and semantically aligned with the business intent.", "overall_assessment": "differently_correct"}}
{"example_id": 1301, "sql_complexity": "multiple_joins", "prompt": "What is the total quantity of corn sold by farmers in 'Summerfield'?", "context": "CREATE TABLE farmers (id INT, name VARCHAR(50), location VARCHAR(50), crops VARCHAR(50)); CREATE TABLE crops (id INT, name VARCHAR(50), yield INT); CREATE TABLE sales (id INT, farmer_id INT, crop_name VARCHAR(50), quantity INT, price DECIMAL(5,2)); INSERT INTO farmers VALUES (1, 'Jane Doe', 'Summerfield', 'Corn'); INSERT INTO crops VALUES (1, 'Corn', 100); INSERT INTO sales VALUES (1, 1, 'Corn', 50, 2.50);", "reference_sql": "SELECT SUM(quantity) FROM sales INNER JOIN farmers ON sales.farmer_id = farmers.id INNER JOIN crops ON sales.crop_name = crops.name WHERE farmers.location = 'Summerfield' AND crops.name = 'Corn';", "generated_sql": "SELECT SUM(sales.quantity) AS total_corn_sold\nFROM sales\nJOIN farmers ON sales.farmer_id = farmers.id\nWHERE farmers.location = 'Summerfield' AND sales.crop_name = 'Corn';", "raw_model_output": "SELECT SUM(sales.quantity) AS total_corn_sold\nFROM sales\nJOIN farmers ON sales.farmer_id = farmers.id\nWHERE farmers.location = 'Summerfield' AND sales.crop_name = 'Corn';", "latency_sec": 1.6252460479736328, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 200, "prompt_eval_sec": null, "tokens_completion": 45, "completion_eval_sec": null, "tokens_total": 245, "tokens_per_sec": 150.74640563222263, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the total quantity of 'Corn' sold by farmers in 'Summerfield'. The Reference SQL uses an explicit join with the crops table and filters on crops.name = 'Corn', while the Generated SQL relies on the sales.crop_name = 'Corn' condition. Since the sales.crop_name is joined with crops.name in the Reference SQL, the WHERE clause crops.name = 'Corn' is semantically equivalent to sales.crop_name = 'Corn' in this context. Both queries ultimately filter the same data and aggregate the same column, producing identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the total corn quantity sold by Summerfield farmers. The reference query includes an unnecessary JOIN with the 'crops' table and filters on crops.name = 'Corn', which is redundant since the sales.crop_name is already 'Corn' (as per sample data). The generated query simplifies the logic by directly filtering sales.crop_name = 'Corn' and omitting the redundant join. While both produce identical results in this specific dataset, the generated query is more efficient and elegant by avoiding unnecessary joins and conditions.", "overall_assessment": "correct"}}
{"example_id": 4667, "sql_complexity": "aggregation", "prompt": "Find the number of unique organizations in each country in the Philanthropy Trends table?", "context": "CREATE TABLE PhilanthropyTrends (OrgID INT, Name TEXT, Country TEXT);", "reference_sql": "SELECT Country, COUNT(DISTINCT OrgID) as UniqueOrganizations FROM PhilanthropyTrends GROUP BY Country;", "generated_sql": "SELECT Country, COUNT(DISTINCT OrgID) AS UniqueOrganizations\nFROM PhilanthropyTrends\nGROUP BY Country;", "raw_model_output": "SELECT Country, COUNT(DISTINCT OrgID) AS UniqueOrganizations\nFROM PhilanthropyTrends\nGROUP BY Country;", "latency_sec": 1.688293695449829, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 102, "prompt_eval_sec": null, "tokens_completion": 26, "completion_eval_sec": null, "tokens_total": 128, "tokens_per_sec": 75.81619261208914, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. The only differences are formatting (line breaks, capitalization of keywords) which do not affect semantic meaning. Both count distinct OrgID per Country in the PhilanthropyTrends table.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in logic, syntax, and structure. They both select 'Country' and count distinct 'OrgID' values, grouping by 'Country' to calculate the number of unique organizations per country. The only differences are cosmetic (whitespace and line breaks), which do not affect execution or results. Both queries perfectly address the business intent of counting unique organizations by country.", "overall_assessment": "correct"}}
{"example_id": 1006, "sql_complexity": "subqueries", "prompt": "What is the average word count of news articles written by investigative journalists?", "context": "CREATE TABLE reporters (id INT, name VARCHAR(50), gender VARCHAR(10), age INT, position VARCHAR(20), country VARCHAR(50)); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (1, 'Anna Smith', 'Female', 35, 'News Reporter', 'USA'); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (2, 'Mike Johnson', 'Male', 40, 'Investigative Journalist', 'Canada'); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (3, 'Sofia Rodriguez', 'Female', 32, 'Investigative Journalist', 'Mexico'); CREATE TABLE news_articles (id INT, title VARCHAR(100), content TEXT, publication_date DATE, reporter_id INT); INSERT INTO news_articles (id, title, content, publication_date, reporter_id) VALUES (1, 'News Article 1', 'Content of News Article 1', '2021-01-01', 2); INSERT INTO news_articles (id, title, content, publication_date, reporter_id) VALUES (2, 'News Article 2', 'Content of News Article 2', '2021-02-01', 3);", "reference_sql": "SELECT AVG(LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1) AS avg_word_count FROM news_articles WHERE reporter_id IN (SELECT id FROM reporters WHERE position = 'Investigative Journalist');", "generated_sql": "SELECT AVG(LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1) AS average_word_count\nFROM news_articles\nJOIN reporters ON news_articles.reporter_id = reporters.id\nWHERE reporters.position = 'Investigative Journalist';", "raw_model_output": "SELECT AVG(LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1) AS average_word_count\nFROM news_articles\nJOIN reporters ON news_articles.reporter_id = reporters.id\nWHERE reporters.position = 'Investigative Journalist';", "latency_sec": 1.1136047840118408, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 341, "prompt_eval_sec": null, "tokens_completion": 51, "completion_eval_sec": null, "tokens_total": 392, "tokens_per_sec": 352.00998202234007, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average word count of news articles written by investigative journalists. The Reference SQL uses a subquery with IN to filter reporter_ids, while the Generated SQL uses a JOIN to combine tables and filter on position. Both approaches effectively restrict the dataset to articles by investigative journalists, and the word count calculation formula is identical. The final result will be the same.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the average word count of articles by investigative journalists. The reference query uses a subquery to filter reporter IDs, while the generated query uses an explicit JOIN. Both employ the same word count calculation (length-based) and filter criteria. The generated query is more efficient and elegant by avoiding a subquery and using a JOIN, which is typically better optimized by databases. Both fulfill the business intent of identifying investigative journalists' article word counts.", "overall_assessment": "correct"}}
{"example_id": 3635, "sql_complexity": "set operations", "prompt": "Which brands have certifications related to cruelty-free, vegan, or organic products?", "context": "CREATE TABLE brands (brand_name VARCHAR(50), is_cruelty_free BOOLEAN, is_vegan BOOLEAN, is_organic BOOLEAN); INSERT INTO brands (brand_name, is_cruelty_free, is_vegan, is_organic) VALUES ('Lush', TRUE, TRUE, FALSE), ('The Body Shop', TRUE, FALSE, FALSE), ('Est\u00e9e Lauder', FALSE, FALSE, FALSE), ('Urban Decay', TRUE, TRUE, FALSE), ('Maybelline', FALSE, FALSE, FALSE), ('Kat Von D', TRUE, TRUE, FALSE), ('Tarte', TRUE, TRUE, TRUE);", "reference_sql": "SELECT brand_name, 'Cruelty-free' as certification FROM brands WHERE is_cruelty_free = TRUE UNION SELECT brand_name, 'Vegan' as certification FROM brands WHERE is_vegan = TRUE UNION SELECT brand_name, 'Organic' as certification FROM brands WHERE is_organic = TRUE;", "generated_sql": "SELECT brand_name\nFROM brands\nWHERE is_cruelty_free = TRUE\n   OR is_vegan = TRUE\n   OR is_organic = TRUE;", "raw_model_output": "SELECT brand_name\nFROM brands\nWHERE is_cruelty_free = TRUE\n   OR is_vegan = TRUE\n   OR is_organic = TRUE;", "latency_sec": 1.3171660900115967, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 209, "prompt_eval_sec": null, "tokens_completion": 34, "completion_eval_sec": null, "tokens_total": 243, "tokens_per_sec": 184.4869844757851, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns brand names with their corresponding certification type (Cruelty-free/Vegan/Organic) as separate rows, allowing multiple certifications per brand. The Generated SQL returns only brand names (without certification types) and collapses multiple certifications into a single row per brand. The output structures and row counts differ.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because they produce different output formats. The reference query returns brand names with explicit certification types (e.g., 'Cruelty-free'), while the generated query only returns brand names. Both fulfill the business intent of identifying brands with at least one certification, but the generated query is more efficient (single query vs. three UNIONed queries) and avoids potential duplicates. However, the reference query provides more detailed certification information, which might be critical if the business needs to distinguish between certification types. The generated query is simpler and more performant but sacrifices granularity.", "overall_assessment": "correct"}}
{"example_id": 4932, "sql_complexity": "basic SQL", "prompt": "Delete the workout row with the id of 2.", "context": "CREATE TABLE Workouts (id INT, user_id INT, workout_name TEXT, calories INT); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (1, 1, 'Running', 300); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (2, 1, 'Cycling', 400); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (3, 2, 'Yoga', 200);", "reference_sql": "DELETE FROM Workouts WHERE id = 2;", "generated_sql": "DELETE FROM Workouts WHERE id = 2;", "raw_model_output": "DELETE FROM Workouts WHERE id = 2;", "latency_sec": 0.8198850154876709, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 182, "prompt_eval_sec": null, "tokens_completion": 11, "completion_eval_sec": null, "tokens_total": 193, "tokens_per_sec": 235.39886246756544, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and intent. They both delete the record with id = 2 from the Workouts table, resulting in the same database state change.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in syntax, logic, and outcome. They correctly delete the row with id=2 from the Workouts table as required. The DELETE statement directly targets the specific record using the WHERE clause, ensuring precise execution. Neither query has redundancy or inefficiency. Both perfectly align with the business intent of removing the specified workout entry.", "overall_assessment": "correct"}}
{"example_id": 365, "sql_complexity": "aggregation", "prompt": "Identify the total number of military personnel and their corresponding rank for each branch and country in the 'military_personnel' table, sorted by the total number of personnel in descending order.", "context": "CREATE TABLE military_personnel (id INT, branch VARCHAR(255), rank VARCHAR(255), country VARCHAR(255), personnel INT);", "reference_sql": "SELECT branch, country, SUM(personnel) as total_personnel FROM military_personnel GROUP BY branch, country ORDER BY total_personnel DESC;", "generated_sql": "SELECT branch, country, rank, SUM(personnel) AS total_personnel\nFROM military_personnel\nGROUP BY branch, country, rank\nORDER BY total_personnel DESC;", "raw_model_output": "SELECT branch, country, rank, SUM(personnel) AS total_personnel\nFROM military_personnel\nGROUP BY branch, country, rank\nORDER BY total_personnel DESC;", "latency_sec": 0.6158468723297119, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 131, "prompt_eval_sec": null, "tokens_completion": 37, "completion_eval_sec": null, "tokens_total": 168, "tokens_per_sec": 272.79508518808586, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their GROUP BY clauses. The reference query groups by (branch, country), while the generated query groups by (branch, country, rank). This causes the generated query to split results into finer-grained groups (by rank) and include the rank column in the output, leading to different aggregation results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly groups by only 'branch' and 'country' to calculate total personnel per combination, while the generated query adds 'rank' to the GROUP BY clause. This causes the generated query to aggregate personnel by branch/country/rank triplets instead of the required branch/country pairs. The original question asks for total personnel per branch/country (without rank aggregation), making the reference query technically correct and semantically aligned with the business intent. The generated query introduces unnecessary granularity (rank) and omits the required 'rank' column from the output (despite including it in GROUP BY), creating a mismatch between the requested and actual results.", "overall_assessment": "incorrect"}}
{"example_id": 521, "sql_complexity": "subqueries", "prompt": "How many vessels have not had an inspection in the past year?", "context": "CREATE TABLE safety_records(id INT, vessel_name VARCHAR(50), inspection_date DATE); CREATE TABLE vessels(id INT, name VARCHAR(50), country VARCHAR(50)); INSERT INTO vessels(id, name, country) VALUES (1, 'Vessel A', 'Philippines'), (2, 'Vessel B', 'Philippines'); INSERT INTO safety_records(id, vessel_name, inspection_date) VALUES (1, 'Vessel A', '2022-01-01');", "reference_sql": "SELECT COUNT(*) FROM vessels WHERE name NOT IN (SELECT vessel_name FROM safety_records WHERE inspection_date BETWEEN DATE_SUB(NOW(), INTERVAL 1 YEAR) AND NOW());", "generated_sql": "SELECT COUNT(*) AS vessels_without_recent_inspection\nFROM vessels v\nLEFT JOIN safety_records s ON v.name = s.vessel_name AND s.inspection_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR)\nWHERE s.vessel_name IS NULL;", "raw_model_output": "SELECT COUNT(*) AS vessels_without_recent_inspection\nFROM vessels v\nLEFT JOIN safety_records s ON v.name = s.vessel_name AND s.inspection_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR)\nWHERE s.vessel_name IS NULL;", "latency_sec": 1.097330093383789, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 176, "prompt_eval_sec": null, "tokens_completion": 54, "completion_eval_sec": null, "tokens_total": 230, "tokens_per_sec": 209.59964680341446, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in date calculation logic. The Reference SQL uses `NOW()` (current datetime) for the date range, while the Generated SQL uses `CURRENT_DATE` (current date). This causes discrepancies when comparing DATE-typed inspection dates. For example, a record with inspection_date '2022-10-05' would be excluded by the Reference SQL's `BETWEEN` (since it's before the datetime-based lower bound) but included by the Generated SQL's `>=` condition. This difference in date handling makes the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent due to differences in date handling. The reference query uses `NOW()` (DATETIME) with `DATE_SUB`, which may not align with the `DATE` type of `inspection_date`, potentially excluding valid inspections. The generated query uses `CURRENT_DATE` (DATE) for precise date comparisons. Both correctly identify vessels without recent inspections, but the generated query's date logic is more accurate. The LEFT JOIN approach in the generated query is also more efficient and avoids potential NULL handling issues in NOT IN subqueries. Both fulfill the business intent, but the generated query is more robust and elegant.", "overall_assessment": "differently_correct"}}
{"example_id": 5687, "sql_complexity": "multiple_joins", "prompt": "List organizations with more than 200 volunteers, and their average donation amounts, excluding donations less than $10.", "context": "CREATE TABLE organizations (org_id INT, org_name TEXT, social_impact_score INT);CREATE TABLE volunteers (vol_id INT, org_id INT, vol_country TEXT);CREATE TABLE donations (donation_id INT, donor_id INT, donation_amount INT, donation_date DATE);", "reference_sql": "SELECT o.org_name, AVG(donation_amount) AS avg_donation_amount FROM organizations o JOIN volunteers v ON o.org_id = v.org_id JOIN donations don ON o.org_id = don.org_id WHERE donation_amount >= 10 GROUP BY o.org_name HAVING COUNT(v.vol_id) > 200;", "generated_sql": "SELECT \n    o.org_id, \n    o.org_name, \n    COUNT(v.vol_id) AS volunteer_count, \n    AVG(d.donation_amount) AS average_donation\nFROM \n    organizations o\nJOIN \n    volunteers v ON o.org_id = v.org_id\nLEFT JOIN \n    donations d ON d.donor_id = v.vol_id\nWHERE \n    d.donation_amount >= 10 OR d.donation_amount IS NULL\nGROUP BY \n    o.org_id, o.org_name\nHAVING \n    COUNT(v.vol_id) > 200;", "raw_model_output": "SELECT \n    o.org_id, \n    o.org_name, \n    COUNT(v.vol_id) AS volunteer_count, \n    AVG(d.donation_amount) AS average_donation\nFROM \n    organizations o\nJOIN \n    volunteers v ON o.org_id = v.org_id\nLEFT JOIN \n    donations d ON d.donor_id = v.vol_id\nWHERE \n    d.donation_amount >= 10 OR d.donation_amount IS NULL\nGROUP BY \n    o.org_id, o.org_name\nHAVING \n    COUNT(v.vol_id) > 200;", "latency_sec": 1.2694671154022217, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 144, "prompt_eval_sec": null, "tokens_completion": 117, "completion_eval_sec": null, "tokens_total": 261, "tokens_per_sec": 205.59807877914506, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in join conditions and data relationships. The Reference SQL joins donations on org_id, while the Generated SQL LEFT JOINs donations on donor_id = vol_id (a different relationship). The Generated SQL also includes NULL donations in its WHERE clause, and groups by org_id (not just org_name). These differences in table relationships and filtering logic result in non-equivalent semantics.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly addresses the business intent by joining donations to organizations (via org_id) and filtering donations >= $10. It groups by org_name (though this is risky due to potential name duplication) and counts volunteers accurately. The Generated SQL has critical flaws: 1) It incorrectly joins donations to volunteers via donor_id = vol_id (schema mismatch), 2) Its WHERE clause includes NULL donations (which would include volunteers with no donations, skewing averages), and 3) It uses LEFT JOIN which may include organizations with no donations. While both count volunteers >200, the Generated SQL's data relationships are fundamentally flawed. The Reference SQL is technically correct and better aligns with the business question.", "overall_assessment": "incorrect"}}
{"example_id": 1281, "sql_complexity": "subqueries", "prompt": "Find the top 3 contributors with the lowest recycling rate in the 'waste_contributors' table.", "context": "CREATE TABLE waste_contributors (contributor VARCHAR(20), recycling_rate FLOAT); INSERT INTO waste_contributors (contributor, recycling_rate) VALUES ('Manufacturing', 0.4), ('Commercial', 0.38), ('Residential', 0.35), ('Institutional', 0.32), ('Agricultural', 0.2), ('Industrial', 0.15);", "reference_sql": "SELECT contributor FROM waste_contributors WHERE recycling_rate IN (SELECT MIN(recycling_rate) FROM waste_contributors) LIMIT 3;", "generated_sql": "SELECT contributor, recycling_rate\nFROM waste_contributors\nORDER BY recycling_rate ASC\nLIMIT 3;", "raw_model_output": "SELECT contributor, recycling_rate\nFROM waste_contributors\nORDER BY recycling_rate ASC\nLIMIT 3;", "latency_sec": 0.850308895111084, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 168, "prompt_eval_sec": null, "tokens_completion": 22, "completion_eval_sec": null, "tokens_total": 190, "tokens_per_sec": 223.44820934182803, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL selects contributors with the minimum recycling rate (only 'Industrial' in this case) and limits to 3 rows. The Generated SQL returns the top 3 contributors ordered by ascending recycling rate (Industrial, Agricultural, Institutional) with both columns. The result sets differ in both content (1 row vs 3 rows) and columns returned.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query uses a subquery to find contributors with the minimum recycling rate (which would only return 1 row in the sample data) and applies LIMIT 3. This approach would fail to return multiple contributors with the same minimum rate and incorrectly returns 3 rows when only one exists. The generated query properly sorts contributors by recycling_rate in ascending order (lowest first) and explicitly returns the top 3, which aligns with the business requirement. While both queries are technically valid SQL, only the generated query fulfills the intent of finding the 'top 3 contributors with the lowest recycling rate'.", "overall_assessment": "differently_correct"}}
{"example_id": 5669, "sql_complexity": "window functions", "prompt": "What is the total number of new and returning volunteers in each program in each month?", "context": "CREATE TABLE Volunteers (VolunteerID INT, VolunteerName TEXT, ProgramID INT, VolunteerDate DATE, IsReturning BOOLEAN); INSERT INTO Volunteers (VolunteerID, VolunteerName, ProgramID, VolunteerDate, IsReturning) VALUES (6, 'David Kim', 1, '2022-03-01', FALSE), (7, 'Emily Chen', 2, '2022-03-15', TRUE), (8, 'James Lee', 2, '2022-04-01', FALSE), (9, 'Grace Park', 3, '2022-04-15', TRUE), (10, 'Daniel Kim', 1, '2022-04-01', FALSE);", "reference_sql": "SELECT ProgramID, EXTRACT(MONTH FROM VolunteerDate) AS Month, SUM(CASE WHEN IsReturning THEN 1 ELSE 0 END) OVER (PARTITION BY ProgramID, EXTRACT(MONTH FROM VolunteerDate) ORDER BY ProgramID, EXTRACT(MONTH FROM VolunteerDate)) + COUNT(DISTINCT VolunteerID) OVER (PARTITION BY ProgramID, EXTRACT(MONTH FROM VolunteerDate) ORDER BY ProgramID, EXTRACT(MONTH FROM VolunteerDate)) AS TotalVolunteers FROM Volunteers;", "generated_sql": "SELECT\n    ProgramID,\n    strftime('%Y-%m', VolunteerDate) AS YearMonth,\n    COUNT(CASE WHEN IsReturning = FALSE THEN 1 END) AS NewVolunteers,\n    COUNT(CASE WHEN IsReturning = TRUE THEN 1 END) AS ReturningVolunteers\nFROM Volunteers\nGROUP BY ProgramID, YearMonth;", "raw_model_output": "SELECT\n    ProgramID,\n    strftime('%Y-%m', VolunteerDate) AS YearMonth,\n    COUNT(CASE WHEN IsReturning = FALSE THEN 1 END) AS NewVolunteers,\n    COUNT(CASE WHEN IsReturning = TRUE THEN 1 END) AS ReturningVolunteers\nFROM Volunteers\nGROUP BY ProgramID, YearMonth;", "latency_sec": 1.0233500003814697, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 228, "prompt_eval_sec": null, "tokens_completion": 71, "completion_eval_sec": null, "tokens_total": 299, "tokens_per_sec": 292.177651720861, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL uses window functions to calculate cumulative totals across rows within partitions, while the Generated SQL aggregates data per group (ProgramID and YearMonth). The Reference SQL's 'TotalVolunteers' combines a running sum of returning volunteers with a running count of distinct volunteers, whereas the Generated SQL provides separate counts of new and returning volunteers per group. Additionally, the month formatting differs (numeric month vs. 'YYYY-MM' string), and the output structures differ in both column counts and semantics.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query fails to separate new and returning volunteers, instead incorrectly combining them into a 'TotalVolunteers' column through flawed window function logic. It uses SUM(CASE WHEN IsReturning THEN 1 ELSE 0 END) + COUNT(DISTINCT VolunteerID) which would double-count returning volunteers. The generated query correctly separates new and returning volunteers using COUNT(CASE WHEN IsReturning = FALSE THEN 1 END) and COUNT(CASE WHEN IsReturning = TRUE THEN 1 END), and groups by ProgramID and YearMonth (using strftime for proper date formatting). The generated query better addresses the business intent of distinguishing between new and returning volunteers in each program per month.", "overall_assessment": "differently_correct"}}
{"example_id": 3576, "sql_complexity": "window functions", "prompt": "What is the difference in the number of eco-friendly hotels between the top 2 countries?", "context": "CREATE TABLE eco_hotel_count (country TEXT, num_hotels INT); INSERT INTO eco_hotel_count (country, num_hotels) VALUES ('France', 100), ('Italy', 120), ('Germany', 150), ('Spain', 110), ('UK', 160);", "reference_sql": "SELECT (MAX(num_hotels) OVER (PARTITION BY num_hotels <= 2) - MIN(num_hotels) OVER (PARTITION BY num_hotels <= 2)) AS hotel_difference FROM eco_hotel_count WHERE country IN ('France', 'Italy');", "generated_sql": "SELECT \n    MAX(num_hotels) - MIN(num_hotels) AS difference\nFROM (\n    SELECT country, num_hotels\n    FROM eco_hotel_count\n    ORDER BY num_hotels DESC\n    LIMIT 2\n) AS top_countries;", "raw_model_output": "SELECT \n    MAX(num_hotels) - MIN(num_hotels) AS difference\nFROM (\n    SELECT country, num_hotels\n    FROM eco_hotel_count\n    ORDER BY num_hotels DESC\n    LIMIT 2\n) AS top_countries;", "latency_sec": 1.3760619163513184, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 144, "prompt_eval_sec": null, "tokens_completion": 54, "completion_eval_sec": null, "tokens_total": 198, "tokens_per_sec": 143.88887421941354, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the difference between MAX and MIN num_hotels for all rows (partitioned by a boolean condition that evaluates to false for all rows) and returns two rows with the same difference. The Generated SQL computes the difference between the top 2 num_hotels (after ordering) and returns a single row. The number of rows and the approach differ, leading to different result structures.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL contains multiple critical issues: 1) The PARTITION BY clause uses invalid syntax (num_hotels <= 2) which doesn't properly partition data, 2) The WHERE clause restricts results to France and Italy (not the top 2 countries), and 3) The window functions are misapplied. The Generated SQL correctly identifies the top 2 countries by ordering and limiting results, then calculates the difference between their hotel counts. While both queries attempt to solve the problem, only the Generated SQL addresses the actual business intent of comparing the top 2 countries.", "overall_assessment": "differently_correct"}}
{"example_id": 1970, "sql_complexity": "multiple_joins", "prompt": "List all players who have played a specific VR game, 'CyberSphere', and their ages.", "context": "CREATE TABLE Players (PlayerID INT, Age INT, Gender VARCHAR(10), Country VARCHAR(50)); CREATE TABLE VRPlayers (PlayerID INT, VRGameID INT); CREATE TABLE VRGames (VRGameID INT, Title VARCHAR(50)); INSERT INTO Players (PlayerID, Age, Gender, Country) VALUES (1, 25, 'Male', 'USA'); INSERT INTO Players (PlayerID, Age, Gender, Country) VALUES (2, 28, 'Female', 'Canada'); INSERT INTO VRPlayers (PlayerID, VRGameID) VALUES (1, 1); INSERT INTO VRPlayers (PlayerID, VRGameID) VALUES (2, 1); INSERT INTO VRGames (VRGameID, Title) VALUES (1, 'CyberSphere');", "reference_sql": "SELECT Players.Age, Players.PlayerID FROM Players INNER JOIN VRPlayers ON Players.PlayerID = VRPlayers.PlayerID INNER JOIN VRGames ON VRPlayers.VRGameID = VRGames.VRGameID WHERE VRGames.Title = 'CyberSphere';", "generated_sql": "SELECT p.PlayerID, p.Age\nFROM Players p\nJOIN VRPlayers vp ON p.PlayerID = vp.PlayerID\nJOIN VRGames vg ON vp.VRGameID = vg.VRGameID\nWHERE vg.Title = 'CyberSphere';", "raw_model_output": "SELECT p.PlayerID, p.Age\nFROM Players p\nJOIN VRPlayers vp ON p.PlayerID = vp.PlayerID\nJOIN VRGames vg ON vp.VRGameID = vg.VRGameID\nWHERE vg.Title = 'CyberSphere';", "latency_sec": 1.2452998161315918, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 245, "prompt_eval_sec": null, "tokens_completion": 52, "completion_eval_sec": null, "tokens_total": 297, "tokens_per_sec": 238.4967829856451, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (PlayerID and Age) from the Players table, join with VRPlayers and VRGames on identical conditions, and filter using the same WHERE clause (vg.Title = 'CyberSphere'). The differences are purely syntactic (alias names and column order in SELECT) and do not affect the result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically correct and produce identical results. They join the same tables (Players, VRPlayers, VRGames) with equivalent conditions, filter for 'CyberSphere' via the VRGames.Title column, and select the same columns (PlayerID and Age). The only difference is the use of table aliases in the generated query, which improves readability without altering functionality. Neither query has performance issues, and both fully address the business intent of identifying players who played 'CyberSphere' with their ages.", "overall_assessment": "correct"}}
{"example_id": 2414, "sql_complexity": "window functions", "prompt": "List the policy areas with the lowest citizen satisfaction scores.", "context": "CREATE TABLE Policy (Area VARCHAR(20), Score INT); INSERT INTO Policy (Area, Score) VALUES ('Transportation', 70), ('Education', 85), ('Healthcare', 75), ('PublicSafety', 80);", "reference_sql": "SELECT Area, Score FROM (SELECT Area, Score, ROW_NUMBER() OVER (ORDER BY Score) AS RN FROM Policy) X WHERE RN IN (1, 2);", "generated_sql": "SELECT Area\nFROM Policy\nWHERE Score = (SELECT MIN(Score) FROM Policy);", "raw_model_output": "SELECT Area\nFROM Policy\nWHERE Score = (SELECT MIN(Score) FROM Policy);", "latency_sec": 0.5437300205230713, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 124, "prompt_eval_sec": null, "tokens_completion": 19, "completion_eval_sec": null, "tokens_total": 143, "tokens_per_sec": 262.9981693165171, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL retrieves the top 2 rows ordered by Score (lowest first), returning both the minimum and second-lowest scores (70 and 75). The Generated SQL only returns the row with the minimum Score (70). The first query returns two rows, while the second returns only one, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL uses ROW_NUMBER() to return the two rows with the lowest scores (assuming distinct values), while the Generated SQL correctly identifies all policies sharing the absolute minimum score. The original question asks for 'lowest citizen satisfaction scores' (plural), which implies finding the minimum value(s), not just the first two ordered values. The Generated SQL accurately captures this intent by using a subquery with MIN(), ensuring all policies with the minimum score are included. The Reference SQL could fail if multiple policies share the lowest score or if the dataset has ties. While both are technically correct, the Generated SQL better fulfills the business intent of identifying the true minimum scores.", "overall_assessment": "correct"}}
{"example_id": 1898, "sql_complexity": "single join", "prompt": "What are the total sales for each drug in Q2 2020?", "context": "CREATE TABLE drugs (drug_id INT, drug_name TEXT); INSERT INTO drugs (drug_id, drug_name) VALUES (1001, 'Ibuprofen'), (1002, 'Paracetamol'), (1003, 'Aspirin'); CREATE TABLE sales (sale_id INT, drug_id INT, sale_date DATE, revenue FLOAT); INSERT INTO sales (sale_id, drug_id, sale_date, revenue) VALUES (1, 1001, '2020-04-05', 1800.0), (2, 1002, '2020-04-10', 2300.0), (3, 1003, '2020-04-15', 1400.0), (4, 1001, '2020-05-20', 1900.0), (5, 1002, '2020-06-25', 2400.0);", "reference_sql": "SELECT drug_name, SUM(revenue) as total_sales FROM sales JOIN drugs ON sales.drug_id = drugs.drug_id WHERE sale_date BETWEEN '2020-04-01' AND '2020-06-30' GROUP BY drug_name;", "generated_sql": "SELECT \n    d.drug_name,\n    SUM(s.revenue) AS total_sales\nFROM \n    drugs d\nJOIN \n    sales s ON d.drug_id = s.drug_id\nWHERE \n    s.sale_date >= '2020-04-01' AND s.sale_date < '2020-07-01'\nGROUP BY \n    d.drug_name;", "raw_model_output": "SELECT \n    d.drug_name,\n    SUM(s.revenue) AS total_sales\nFROM \n    drugs d\nJOIN \n    sales s ON d.drug_id = s.drug_id\nWHERE \n    s.sale_date >= '2020-04-01' AND s.sale_date < '2020-07-01'\nGROUP BY \n    d.drug_name;", "latency_sec": 0.7899188995361328, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 271, "prompt_eval_sec": null, "tokens_completion": 78, "completion_eval_sec": null, "tokens_total": 349, "tokens_per_sec": 441.81750836059837, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate total sales per drug within the same date range. The Reference uses BETWEEN '2020-04-01' AND '2020-06-30' (inclusive), while the Generated uses >= '2020-04-01' AND < '2020-07-01' (exclusive of July 1st). These date ranges are equivalent. Both group by drug_name (via alias) and join on drug_id, producing identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate total sales per drug for Q2 2020. The Reference uses BETWEEN '2020-04-01' AND '2020-06-30' while the Generated uses >= '2020-04-01' AND < '2020-07-01'. These date ranges are functionally equivalent for Q2 2020 (April-June). Both join drugs and sales on drug_id, group by drug_name, and sum revenue. The Generated query uses table aliases which improves readability but doesn't affect functionality. Both queries would produce identical results for the given data.", "overall_assessment": "correct"}}
{"example_id": 2403, "sql_complexity": "multiple_joins", "prompt": "Who is the most frequent customer ordering vegetarian items?", "context": "CREATE TABLE customers (customer_id INT, customer_name VARCHAR(50)); INSERT INTO customers VALUES (1, 'John Doe'), (2, 'Jane Smith'), (3, 'Alice Johnson'); CREATE TABLE orders (order_id INT, customer_id INT, menu_id INT, order_date DATE); INSERT INTO orders VALUES (1, 1, 1, '2022-01-01'), (2, 2, 3, '2022-01-02'), (3, 3, 2, '2022-01-03'); CREATE TABLE menu (menu_id INT, item_name VARCHAR(50), is_vegetarian BOOLEAN, price DECIMAL(5,2)); INSERT INTO menu VALUES (1, 'Veggie Burger', true, 8.99), (2, 'Cheeseburger', false, 7.99), (3, 'Tofu Stir Fry', true, 11.99);", "reference_sql": "SELECT customers.customer_name, COUNT(orders.order_id) as order_count FROM customers INNER JOIN orders ON customers.customer_id = orders.customer_id INNER JOIN menu ON orders.menu_id = menu.menu_id WHERE menu.is_vegetarian = true GROUP BY customers.customer_name ORDER BY order_count DESC LIMIT 1;", "generated_sql": "SELECT c.customer_id, c.customer_name\nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nJOIN menu m ON o.menu_id = m.menu_id\nWHERE m.is_vegetarian = TRUE\nGROUP BY c.customer_id, c.customer_name\nORDER BY COUNT(*) DESC\nLIMIT 1;", "raw_model_output": "SELECT c.customer_id, c.customer_name\nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nJOIN menu m ON o.menu_id = m.menu_id\nWHERE m.is_vegetarian = TRUE\nGROUP BY c.customer_id, c.customer_name\nORDER BY COUNT(*) DESC\nLIMIT 1;", "latency_sec": 0.8067078590393066, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 270, "prompt_eval_sec": null, "tokens_completion": 67, "completion_eval_sec": null, "tokens_total": 337, "tokens_per_sec": 417.74726280877815, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in selected columns and grouping. The Reference SQL returns customer_name and order_count, while the Generated SQL returns customer_id and customer_name. Additionally, the Reference groups by customer_name (which may not be functionally dependent on customer_id in all SQL dialects) whereas the Generated groups by both customer_id and customer_name (more robust). The result sets have different structures, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify the most frequent customer for vegetarian items by joining customers, orders, and menu tables with a vegetarian filter. The Reference SQL groups by customer_name, which could be problematic if names are not unique, while the Generated SQL groups by customer_id (and name) which is more reliable. Both produce the same results in this specific dataset. The Generated SQL is more robust due to grouping by primary key (customer_id) and uses COUNT(*) which is functionally equivalent to COUNT(orders.order_id). The Reference SQL's use of customer_name in GROUP BY is less precise but still valid here.", "overall_assessment": "correct"}}
{"example_id": 124, "sql_complexity": "set operations", "prompt": "Find the intersection of AI and accessibility research projects in the EU and those in Africa.", "context": "CREATE SCHEMA if not exists accessibility; CREATE TABLE if not exists accessibility.research (id INT PRIMARY KEY, project_name VARCHAR(255), region VARCHAR(255)); INSERT INTO accessibility.research (id, project_name, region) VALUES (1, 'AI for Accessibility EU', 'EU'), (2, 'Accessibility Africa', 'Africa'), (3, 'AI for Accessibility Africa', 'Africa'), (4, 'Accessibility EU', 'EU');", "reference_sql": "SELECT project_name FROM accessibility.research WHERE region = 'EU' INTERSECT SELECT project_name FROM accessibility.research WHERE region = 'Africa';", "generated_sql": "SELECT project_name, region\nFROM accessibility.research\nWHERE project_name LIKE '%AI%' AND region IN ('EU', 'Africa')\nGROUP BY project_name, region\nHAVING COUNT(DISTINCT region) = 2;", "raw_model_output": "SELECT project_name, region\nFROM accessibility.research\nWHERE project_name LIKE '%AI%' AND region IN ('EU', 'Africa')\nGROUP BY project_name, region\nHAVING COUNT(DISTINCT region) = 2;", "latency_sec": 1.894118070602417, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 175, "prompt_eval_sec": null, "tokens_completion": 47, "completion_eval_sec": null, "tokens_total": 222, "tokens_per_sec": 117.20494273590545, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses INTERSECT to find project_names present in both 'EU' and 'Africa' regions. The Generated SQL attempts to find project_names with entries in both regions but incorrectly groups by project_name and region, making the HAVING COUNT(DISTINCT region) = 2 condition impossible (each group has only one region). Thus, the Generated SQL returns an empty set regardless of data, while the Reference SQL would return matching project_names if they existed. They are not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL finds projects in both EU and Africa regions but ignores the 'AI and accessibility' filter. The Generated SQL correctly applies the AI filter and identifies projects in both regions, though it misses the 'accessibility' keyword in project names. While neither query fully meets the business intent (which requires both AI and accessibility in project names), the Generated SQL better addresses the intersection requirement by using GROUP BY/HAVING to enforce dual-region presence. The Reference SQL's INTERSECT approach is technically valid for region intersection but fails to incorporate the AI/accessibility criteria.", "overall_assessment": "differently_correct"}}
{"example_id": 1231, "sql_complexity": "basic SQL", "prompt": "What is the average ticket price for performances at the 'Downtown Theater'?", "context": "CREATE TABLE DowntownTheater (show_name TEXT, date DATE, ticket_price FLOAT); INSERT INTO DowntownTheater (show_name, date, ticket_price) VALUES ('Play 1', '2022-01-01', 30.0), ('Play 2', '2022-01-02', 40.0), ('Concert 1', '2022-01-03', 50.0);", "reference_sql": "SELECT AVG(ticket_price) FROM DowntownTheater WHERE show_name = 'Downtown Theater'", "generated_sql": "SELECT AVG(ticket_price) AS average_ticket_price\nFROM DowntownTheater;", "raw_model_output": "SELECT AVG(ticket_price) AS average_ticket_price\nFROM DowntownTheater;", "latency_sec": 0.7225427627563477, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 169, "prompt_eval_sec": null, "tokens_completion": 16, "completion_eval_sec": null, "tokens_total": 185, "tokens_per_sec": 256.04020901719946, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters for show_name = 'Downtown Theater' which doesn't exist in the data, returning no rows. The Generated SQL calculates the average of all tickets. The first returns NULL/empty, the second returns 40.0.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query is incorrect because it filters for 'show_name = 'Downtown Theater'', but the sample data shows show_names like 'Play 1' and 'Concert 1'\u2014there are no entries matching 'Downtown Theater'. This would return NULL or 0. The generated query correctly calculates the average of all ticket prices in the DowntownTheater table, which contains the three sample entries. While neither query explicitly references a 'theater' column (the table name itself may imply the context), the generated query aligns with the data structure by averaging all performances in the table. The reference query's WHERE clause is semantically flawed given the schema.", "overall_assessment": "differently_correct"}}
{"example_id": 1485, "sql_complexity": "set operations", "prompt": "How many public schools and public libraries exist in total, in the 'CityData' schema's 'CityEducation' and 'CityLibrary' tables?", "context": "CREATE SCHEMA CityData; CREATE TABLE CityEducation (Name varchar(255), Type varchar(255)); INSERT INTO CityEducation (Name, Type) VALUES ('SchoolA', 'Public'), ('SchoolB', 'Public'), ('SchoolC', 'Private'); CREATE TABLE CityLibrary (Name varchar(255), Type varchar(255)); INSERT INTO CityLibrary (Name, Type) VALUES ('LibraryA', 'Public'), ('LibraryB', 'Public'), ('LibraryC', 'Private');", "reference_sql": "SELECT COUNT(*) FROM CityData.CityEducation WHERE Type = 'Public' UNION ALL SELECT COUNT(*) FROM CityData.CityLibrary WHERE Type = 'Public';", "generated_sql": "SELECT \n  (SELECT COUNT(*) FROM CityData.CityEducation WHERE Type = 'Public') + \n  (SELECT COUNT(*) FROM CityData.CityLibrary WHERE Type = 'Public') AS TotalPublicFacilities;", "raw_model_output": "SELECT \n  (SELECT COUNT(*) FROM CityData.CityEducation WHERE Type = 'Public') + \n  (SELECT COUNT(*) FROM CityData.CityLibrary WHERE Type = 'Public') AS TotalPublicFacilities;", "latency_sec": 0.9666428565979004, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 195, "prompt_eval_sec": null, "tokens_completion": 42, "completion_eval_sec": null, "tokens_total": 237, "tokens_per_sec": 245.17845280947043, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate rows with individual counts from CityEducation and CityLibrary, while the Generated SQL returns a single row with the summed total. The output structure differs (two rows vs. one row with a combined value), so they are not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL returns two separate counts (schools and libraries) as individual rows via UNION ALL, while the Generated SQL correctly combines them into a single total value using arithmetic addition. Both queries correctly filter for 'Public' entries, but the Generated SQL directly addresses the request for a 'total' count. The Generated SQL is more efficient as it avoids the overhead of UNION ALL and produces a single scalar result matching the business requirement.", "overall_assessment": "differently_correct"}}
{"example_id": 5806, "sql_complexity": "single join", "prompt": "List the top 3 countries with the most veteran employment in the IT industry", "context": "CREATE TABLE veteran_employment (employee_id INT, industry VARCHAR(255), salary DECIMAL(10,2), state VARCHAR(2), country VARCHAR(255)); CREATE TABLE countries (country_id INT, country VARCHAR(255));", "reference_sql": "SELECT country, COUNT(*) as num_veterans FROM veteran_employment JOIN countries ON veteran_employment.country = countries.country WHERE industry = 'IT' GROUP BY country ORDER BY num_veterans DESC LIMIT 3;", "generated_sql": "SELECT \n    c.country, \n    COUNT(*) AS veteran_count\nFROM \n    veteran_employment ve\nJOIN \n    countries c ON ve.country = c.country\nWHERE \n    ve.industry = 'IT'\nGROUP BY \n    c.country\nORDER BY \n    veteran_count DESC\nLIMIT 3;", "raw_model_output": "SELECT \n    c.country, \n    COUNT(*) AS veteran_count\nFROM \n    veteran_employment ve\nJOIN \n    countries c ON ve.country = c.country\nWHERE \n    ve.industry = 'IT'\nGROUP BY \n    c.country\nORDER BY \n    veteran_count DESC\nLIMIT 3;", "latency_sec": 1.0450479984283447, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 129, "prompt_eval_sec": null, "tokens_completion": 64, "completion_eval_sec": null, "tokens_total": 193, "tokens_per_sec": 184.68051256043177, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between veteran_employment and countries on the country column, filter for industry 'IT', group by country, and order by count descending with a limit of 3. The differences are purely syntactic (table aliases and column aliases) and do not affect the semantic result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly join the veteran_employment and countries tables on the country field, filter for IT industry, group by country to count veterans, and order by count descending to show top 3. The reference query uses implicit table names while the generated query uses aliases, but this has no impact on results. Both achieve the same technical outcome and business objective with equivalent efficiency.", "overall_assessment": "correct"}}
{"example_id": 4126, "sql_complexity": "window functions", "prompt": "What is the average crime rate per capita in each neighborhood?", "context": "CREATE TABLE neighborhoods (name VARCHAR(255), population INT, crime_count INT); INSERT INTO neighborhoods (name, population, crime_count) VALUES ('Central Park', 1000, 25), ('Harlem', 2500, 75), ('Brooklyn', 5000, 120);", "reference_sql": "SELECT name, AVG(crime_count/population) OVER (PARTITION BY name) FROM neighborhoods;", "generated_sql": "SELECT \n    name,\n    (CAST(crime_count AS FLOAT) / population) AS crime_rate_per_capita\nFROM \n    neighborhoods;", "raw_model_output": "SELECT \n    name,\n    (CAST(crime_count AS FLOAT) / population) AS crime_rate_per_capita\nFROM \n    neighborhoods;", "latency_sec": 0.5885412693023682, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 140, "prompt_eval_sec": null, "tokens_completion": 30, "completion_eval_sec": null, "tokens_total": 170, "tokens_per_sec": 288.84975254413473, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses AVG(crime_count/population) OVER (PARTITION BY name), which calculates the average of crime_count/population within each neighborhood. Since each neighborhood has a unique name, this reduces to the same value as crime_count/population for each row. However, the Generated SQL directly computes (CAST(crime_count AS FLOAT)/population). The key difference is that the Reference SQL may perform integer division (if the database does not automatically cast to float), while the Generated SQL explicitly uses float division. This leads to different results when crime_count and population are integers, making the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query incorrectly uses an analytic function (AVG() OVER) which is unnecessary since each neighborhood has a single row. This would return the same value as the ratio but with redundant computation. The generated query directly calculates the crime rate per capita (crime_count/population) which matches the business intent. While both queries technically produce the same numerical result for the given sample data, the generated query is more efficient and semantically accurate for the question. The reference query's structure implies a need for aggregation that doesn't exist in the schema.", "overall_assessment": "differently_correct"}}
{"example_id": 4559, "sql_complexity": "basic SQL", "prompt": "List the top 3 energy efficient appliances in the US by energy star rating?", "context": "CREATE TABLE appliances (id INT, name VARCHAR(255), country VARCHAR(255), energy_star_rating INT); INSERT INTO appliances (id, name, country, energy_star_rating) VALUES (1, 'Fridge A', 'USA', 5), (2, 'TV B', 'USA', 4), (3, 'Laptop C', 'USA', 5), (4, 'Microwave D', 'USA', 3);", "reference_sql": "SELECT name, energy_star_rating FROM appliances WHERE country = 'USA' ORDER BY energy_star_rating DESC LIMIT 3;", "generated_sql": "SELECT name, country, energy_star_rating\nFROM appliances\nWHERE country = 'USA'\nORDER BY energy_star_rating DESC\nLIMIT 3;", "raw_model_output": "SELECT name, country, energy_star_rating\nFROM appliances\nWHERE country = 'USA'\nORDER BY energy_star_rating DESC\nLIMIT 3;", "latency_sec": 1.0514729022979736, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 174, "prompt_eval_sec": null, "tokens_completion": 30, "completion_eval_sec": null, "tokens_total": 204, "tokens_per_sec": 194.01355903149, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent because the Generated SQL includes an additional 'country' column in the SELECT clause, while the Reference SQL only selects 'name' and 'energy_star_rating'. Although the WHERE clause restricts country to 'USA', the presence of the extra column changes the result set structure.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries correctly filter US appliances, order by energy star rating descending, and limit to 3 results. The reference query is more precise by only selecting the name and rating (directly answering the question), while the generated query includes an unnecessary 'country' column. Though functionally equivalent in result sets, the reference better aligns with the business intent by avoiding extraneous data. Both are technically correct, but the reference is more efficient and elegant.", "overall_assessment": "correct"}}
{"example_id": 456, "sql_complexity": "window functions", "prompt": "List the intelligence operations and their corresponding threat levels, and rank them based on their threat level and budget.", "context": "CREATE TABLE intel_ops_threat (id INT, operation VARCHAR, threat VARCHAR, budget INT); INSERT INTO intel_ops_threat (id, operation, threat, budget) VALUES (1, 'Operation Red Folder', 'High', 5000000), (2, 'Operation Black Vault', 'Medium', 7000000), (3, 'Operation Blue Sail', 'Low', 6000000);", "reference_sql": "SELECT operation, threat, budget, ROW_NUMBER() OVER (PARTITION BY threat ORDER BY budget DESC) as rank FROM intel_ops_threat;", "generated_sql": "SELECT \n    operation, \n    threat, \n    RANK() OVER (ORDER BY \n        CASE \n            WHEN threat = 'High' THEN 1\n            WHEN threat = 'Medium' THEN 2\n            WHEN threat = 'Low' THEN 3\n        END, \n        budget DESC\n    ) AS threat_rank\nFROM \n    intel_ops_threat;", "raw_model_output": "SELECT \n    operation, \n    threat, \n    RANK() OVER (ORDER BY \n        CASE \n            WHEN threat = 'High' THEN 1\n            WHEN threat = 'Medium' THEN 2\n            WHEN threat = 'Low' THEN 3\n        END, \n        budget DESC\n    ) AS threat_rank\nFROM \n    intel_ops_threat;", "latency_sec": 0.8451797962188721, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 171, "prompt_eval_sec": null, "tokens_completion": 78, "completion_eval_sec": null, "tokens_total": 249, "tokens_per_sec": 294.61186970389633, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL uses ROW_NUMBER() with PARTITION BY threat, assigning unique ranks within each threat category. The Generated SQL uses RANK() without partitioning, ordering first by a custom threat priority (High=1, Medium=2, Low=3) and then by budget DESC. This results in a global ranking across all rows rather than per-threat group rankings. Additionally, RANK() and ROW_NUMBER() handle ties differently, though in this specific dataset with unique budgets, the difference in ranking logic (global vs. per-group) makes the results non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries are not technically equivalent. The Reference query ranks operations within each threat level (e.g., High, Medium, Low) separately, while the Generated query ranks all operations globally based on a composite key of threat level (converted to numerical values) and budget. The original question requires ranking operations across all threat levels, not within groups. The Generated query better fulfills the business intent by ordering by threat level priority (High > Medium > Low) and budget, whereas the Reference query only ranks within threat categories. The Generated query also uses RANK() which handles ties appropriately, while the Reference uses ROW_NUMBER() which may produce inconsistent results if threat levels have multiple entries.", "overall_assessment": "differently_correct"}}
{"example_id": 459, "sql_complexity": "set operations", "prompt": "What is the total installed capacity of hydroelectric power plants in Brazil and Canada?", "context": "CREATE TABLE hydroelectric_power (country TEXT, capacity INTEGER); INSERT INTO hydroelectric_power (country, capacity) VALUES ('Brazil', 104000), ('Canada', 78000), ('China', 350000), ('United States', 100000), ('Russia', 45000);", "reference_sql": "(SELECT capacity FROM hydroelectric_power WHERE country = 'Brazil') UNION (SELECT capacity FROM hydroelectric_power WHERE country = 'Canada');", "generated_sql": "SELECT SUM(capacity) AS total_capacity\nFROM hydroelectric_power\nWHERE country IN ('Brazil', 'Canada');", "raw_model_output": "SELECT SUM(capacity) AS total_capacity\nFROM hydroelectric_power\nWHERE country IN ('Brazil', 'Canada');", "latency_sec": 1.6086020469665527, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 142, "prompt_eval_sec": null, "tokens_completion": 24, "completion_eval_sec": null, "tokens_total": 166, "tokens_per_sec": 103.195193810077, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns individual capacities of Brazil and Canada as separate rows, while the Generated SQL returns the sum of their capacities as a single value. The first query produces two rows with distinct values, whereas the second query produces one row with a aggregated total. The results have different structure and content.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query retrieves individual capacities for Brazil and Canada using UNION, but does not calculate a total. The generated query correctly uses SUM(capacity) to compute the combined total. While both queries focus on the correct countries, only the generated query addresses the 'total' requirement in the question. The generated query is more efficient as it performs a single aggregation rather than combining separate row sets.", "overall_assessment": "correct"}}
{"example_id": 2356, "sql_complexity": "window functions", "prompt": "Find the total billing amount for attorneys in the 'Criminal Law' practice area, for the year 2020, partitioned by attorney's last name and ordered by the total billing amount in descending order.", "context": "CREATE TABLE Attorneys (AttorneyID INT, FirstName VARCHAR(50), LastName VARCHAR(50), PracticeArea VARCHAR(50), TotalBilling FLOAT, BillingYear INT); INSERT INTO Attorneys (AttorneyID, FirstName, LastName, PracticeArea, TotalBilling, BillingYear) VALUES (1, 'Clara', 'Rivera', 'Personal Injury', 8000.00, 2020), (2, 'Jamal', 'Lee', 'Personal Injury', 6000.00, 2019), (3, 'Sophia', 'Gomez', 'Criminal Law', 9000.00, 2020);", "reference_sql": "SELECT LastName, SUM(TotalBilling) OVER (PARTITION BY PracticeArea, LastName, BillingYear) AS TotalBilling FROM Attorneys WHERE PracticeArea = 'Criminal Law' AND BillingYear = 2020 ORDER BY TotalBilling DESC;", "generated_sql": "SELECT LastName, SUM(TotalBilling) AS TotalBillingAmount\nFROM Attorneys\nWHERE PracticeArea = 'Criminal Law' AND BillingYear = 2020\nGROUP BY LastName\nORDER BY TotalBillingAmount DESC;", "raw_model_output": "SELECT LastName, SUM(TotalBilling) AS TotalBillingAmount\nFROM Attorneys\nWHERE PracticeArea = 'Criminal Law' AND BillingYear = 2020\nGROUP BY LastName\nORDER BY TotalBillingAmount DESC;", "latency_sec": 0.6988308429718018, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 241, "prompt_eval_sec": null, "tokens_completion": 47, "completion_eval_sec": null, "tokens_total": 288, "tokens_per_sec": 412.1168990986006, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL uses a window function to calculate the sum per (PracticeArea, LastName, BillingYear) without grouping, retaining all rows. The Generated SQL groups by LastName, aggregating rows and returning one row per LastName. If multiple entries exist for the same LastName in the filtered data, the Generated SQL would consolidate them into a single row with a summed TotalBilling, while the Reference SQL would show individual rows with the same sum. In the given sample data, they produce the same result, but they differ in general cases with multiple entries per LastName.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL incorrectly uses a window function (SUM() OVER) instead of an aggregate function with GROUP BY. While both queries filter for 'Criminal Law' in 2020, the Reference SQL's window function would return individual rows with the same TotalBilling value (since PracticeArea and BillingYear are fixed in the WHERE clause), whereas the Generated SQL properly aggregates billing amounts by LastName. The Generated SQL correctly partitions (groups) by LastName and sums billing amounts, fulfilling the business requirement. The Reference SQL's approach would fail if multiple entries existed per attorney, as it wouldn't aggregate them.", "overall_assessment": "differently_correct"}}
