{"example_id": 2656, "sql_complexity": "multiple_joins", "prompt": "Find the drugs and their respective total sales for rare diseases indication with sales greater than the average sales for infectious diseases.", "context": "CREATE TABLE sales (id INT, drug_id INT, quarter INT, year INT, revenue FLOAT); INSERT INTO sales (id, drug_id, quarter, year, revenue) VALUES (1, 1, 1, 2022, 1500000); CREATE TABLE drugs (id INT, name VARCHAR(50), company VARCHAR(50), indication VARCHAR(50)); INSERT INTO drugs (id, name, company, indication) VALUES (1, 'DrugA', 'ABC Corp', 'Rare_Diseases');", "reference_sql": "SELECT s.drug_id, d.name, SUM(s.revenue) as total_sales FROM sales s JOIN drugs d ON s.drug_id = d.id WHERE d.indication = 'Rare_Diseases' GROUP BY s.drug_id HAVING total_sales > (SELECT AVG(s2.revenue) FROM sales s2 JOIN drugs d2 ON s2.drug_id = d2.id WHERE d2.indication = 'Infectious_Diseases')", "generated_sql": "SELECT\n  d.name,\n  SUM(s.revenue)\nFROM drugs AS d\nJOIN sales AS s\n  ON d.id = s.drug_id\nWHERE\n  d.indication = 'Rare_Diseases'\n  AND s.revenue > (\n    SELECT\n      AVG(revenue)\n    FROM sales\n    JOIN drugs AS d2\n      ON sales.drug_id = d2.id\n    WHERE\n      d2.indication = 'Infectious_Diseases'\n  )\nGROUP BY\n  d.name;", "raw_model_output": "```sql\nSELECT\n  d.name,\n  SUM(s.revenue)\nFROM drugs AS d\nJOIN sales AS s\n  ON d.id = s.drug_id\nWHERE\n  d.indication = 'Rare_Diseases'\n  AND s.revenue > (\n    SELECT\n      AVG(revenue)\n    FROM sales\n    JOIN drugs AS d2\n      ON sales.drug_id = d2.id\n    WHERE\n      d2.indication = 'Infectious_Diseases'\n  )\nGROUP BY\n  d.name;\n```", "latency_sec": 6.230682849884033, "total_duration_sec": 6.160299432, "load_duration_sec": 3.40304004, "tokens_prompt": 220, "prompt_eval_sec": 0.175715716, "tokens_completion": 128, "completion_eval_sec": 2.567314462, "tokens_total": 348, "tokens_per_sec": 55.85262617025629, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters drugs with 'Rare_Diseases' indication and groups by drug_id to compare total_sales (aggregated revenue) against the average revenue of 'Infectious_Diseases' drugs. The Generated SQL filters individual sales records where revenue exceeds the same average, then groups by drug name to sum those filtered revenues. The key difference is that the Reference uses HAVING to compare aggregated totals, while the Generated SQL uses WHERE to filter individual rows before aggregation, leading to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent. The Reference SQL correctly groups by drug_id and uses HAVING to compare total_sales (sum of revenue) against the average revenue per sale for infectious diseases. The Generated SQL incorrectly filters individual sales (s.revenue > ...) instead of comparing total sales, and groups by drug name (which may cause inaccuracies if multiple drugs share the same name). Both queries misinterpret the business intent: the original question likely requires comparing total sales (sum) of rare disease drugs to the average total sales (sum) of infectious disease drugs, not average revenue per sale. The Reference SQL better aligns with this intent by using SUM and HAVING, even though its subquery may still have semantic issues.", "overall_assessment": "differently_correct"}}
{"example_id": 3008, "sql_complexity": "multiple_joins", "prompt": "Who are the users who used electric vehicles and their trip details?", "context": "CREATE TABLE users (id INT, name VARCHAR(50), age INT, gender VARCHAR(10), city VARCHAR(50));CREATE TABLE vehicles (id INT, vehicle_type VARCHAR(20), is_electric BOOLEAN);CREATE TABLE trips (id INT, user_id INT, vehicle_id INT, trip_distance FLOAT, trip_duration INT, departure_time TIMESTAMP, arrival_time TIMESTAMP);INSERT INTO users (id, name, age, gender, city) VALUES (3, 'Alex', 30, 'Female', 'New York');INSERT INTO vehicles (id, vehicle_type, is_electric) VALUES (1, 'Tesla', true), (2, 'Bike', false);INSERT INTO trips (id, user_id, vehicle_id, trip_distance, trip_duration, departure_time, arrival_time) VALUES (3, 3, 1, 15.3, 25, '2022-01-03 12:00:00', '2022-01-03 12:25:00');", "reference_sql": "SELECT u.name, v.vehicle_type, t.trip_distance, t.trip_duration FROM users u JOIN trips t ON u.id = t.user_id JOIN vehicles v ON t.vehicle_id = v.id WHERE v.is_electric = true;", "generated_sql": "SELECT\n  T1.name,\n  T2.trip_distance,\n  T2.trip_duration\nFROM users AS T1\nINNER JOIN trips AS T2\n  ON T1.id = T2.user_id\nINNER JOIN vehicles AS T3\n  ON T2.vehicle_id = T3.id\nWHERE\n  T3.is_electric = TRUE;", "raw_model_output": "```sql\nSELECT\n  T1.name,\n  T2.trip_distance,\n  T2.trip_duration\nFROM users AS T1\nINNER JOIN trips AS T2\n  ON T1.id = T2.user_id\nINNER JOIN vehicles AS T3\n  ON T2.vehicle_id = T3.id\nWHERE\n  T3.is_electric = TRUE;\n```", "latency_sec": 2.161785125732422, "total_duration_sec": 2.000081562, "load_duration_sec": 0.029075811, "tokens_prompt": 334, "prompt_eval_sec": 0.122397034, "tokens_completion": 92, "completion_eval_sec": 1.847413618, "tokens_total": 426, "tokens_per_sec": 197.05936308340054, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent because the Generated SQL omits the 'vehicle_type' column present in the Reference SQL. The Reference SQL selects u.name, v.vehicle_type, t.trip_distance, and t.trip_duration, while the Generated SQL only selects T1.name, T2.trip_distance, and T2.trip_duration. This difference in selected columns makes their result sets non-identical.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because the reference query includes 'vehicle_type' while the generated query does not. However, the original question asks for 'trip details,' which typically refers to trip_distance and trip_duration. The generated query focuses precisely on these metrics, omitting redundant vehicle_type information. The reference query includes an extra column that isn't explicitly requested. Both queries correctly filter electric vehicles via the WHERE clause, but the generated query is more concise and directly addresses the trip details aspect of the question. The generated query also uses clearer table aliases (T1, T2, T3) for readability.", "overall_assessment": "differently_correct"}}
{"example_id": 2531, "sql_complexity": "basic SQL", "prompt": "Who is the top customer by sales in 2022?", "context": "CREATE TABLE customers (customer_id INT, total_sales_2022 FLOAT); INSERT INTO customers (customer_id, total_sales_2022) VALUES (1, 25000.0), (2, 30000.0), (3, 22000.0), (4, 35000.0);", "reference_sql": "SELECT customer_id, total_sales_2022 FROM customers ORDER BY total_sales_2022 DESC LIMIT 1;", "generated_sql": "SELECT customer_id FROM customers ORDER BY total_sales_2022 DESC LIMIT 1;", "raw_model_output": "```sql\nSELECT customer_id FROM customers ORDER BY total_sales_2022 DESC LIMIT 1;\n```", "latency_sec": 0.886735200881958, "total_duration_sec": 0.608004979, "load_duration_sec": 0.028908562, "tokens_prompt": 179, "prompt_eval_sec": 0.052784068, "tokens_completion": 27, "completion_eval_sec": 0.525567187, "tokens_total": 206, "tokens_per_sec": 232.31287062373278, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query selects both customer_id and total_sales_2022, while the generated query only selects customer_id. Although both order by total_sales_2022 DESC and limit to 1 result, the generated query omits the total_sales_2022 column, making their result sets structurally and semantically different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because the reference query returns both customer_id and total_sales_2022, while the generated query only returns customer_id. However, both correctly identify the top customer by sales (customer_id 4). The generated query fulfills the business intent of identifying the top customer, as the question only asks for 'who' the top customer is, not the sales amount. The generated query is more efficient by selecting fewer columns, though the reference query provides additional context (sales value) that could be useful for verification. Neither query is incorrect, but the generated query is more aligned with the specific question asked.", "overall_assessment": "differently_correct"}}
{"example_id": 3792, "sql_complexity": "single join", "prompt": "What is the maximum distance traveled by an electric vehicle in a single trip, grouped by vehicle model?", "context": "CREATE TABLE Trips (trip_id INT, vehicle_id INT, distance FLOAT); CREATE TABLE ElectricVehicleModels (vehicle_id INT, vehicle_model TEXT);", "reference_sql": "SELECT evm.vehicle_model, MAX(trips.distance) AS max_distance_traveled FROM Trips trips INNER JOIN ElectricVehicleModels evm ON trips.vehicle_id = evm.vehicle_id GROUP BY 1;", "generated_sql": "SELECT\n  ElectricVehicleModels.vehicle_model,\n  MAX(Trips.distance)\nFROM Trips\nJOIN ElectricVehicleModels\n  ON Trips.vehicle_id = ElectricVehicleModels.vehicle_id\nGROUP BY\n  ElectricVehicleModels.vehicle_model;", "raw_model_output": "```sql\nSELECT\n  ElectricVehicleModels.vehicle_model,\n  MAX(Trips.distance)\nFROM Trips\nJOIN ElectricVehicleModels\n  ON Trips.vehicle_id = ElectricVehicleModels.vehicle_id\nGROUP BY\n  ElectricVehicleModels.vehicle_model;\n```", "latency_sec": 1.5807340145111084, "total_duration_sec": 1.304392941, "load_duration_sec": 0.031009262, "tokens_prompt": 133, "prompt_eval_sec": 0.038761564, "tokens_completion": 63, "completion_eval_sec": 1.233897383, "tokens_total": 196, "tokens_per_sec": 123.9930299473053, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between Trips and ElectricVehicleModels on vehicle_id, select vehicle_model and max(distance), and group by vehicle_model. The reference uses table aliases (trips, evm) while the generated query uses full table names, but this does not affect semantic equivalence. The GROUP BY clause references the same column in both cases.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically correct and produce identical results. They both join the Trips and ElectricVehicleModels tables on vehicle_id, group by vehicle_model, and calculate the maximum distance per model. The reference query uses a column position (GROUP BY 1) while the generated query explicitly names the column in GROUP BY. Both approaches are valid, and the semantic equivalence is maintained. The business intent of identifying maximum trip distances per vehicle model is fully addressed by both queries. The superiority is equal as both are equally efficient and readable.", "overall_assessment": "correct"}}
{"example_id": 2311, "sql_complexity": "subqueries", "prompt": "Determine the percentage of sales from each ingredient category", "context": "CREATE TABLE Sales_Details (sale_id INT, ingredient_id INT, quantity INT); INSERT INTO Sales_Details (sale_id, ingredient_id, quantity) VALUES (1, 1, 2), (1, 2, 8), (2, 1, 3), (2, 2, 7); CREATE TABLE Ingredient_Categories (ingredient_id INT, ingredient_category VARCHAR(255)); INSERT INTO Ingredient_Categories (ingredient_id, ingredient_category) VALUES (1, 'Legumes'), (2, 'Poultry');", "reference_sql": "SELECT ingredient_category, SUM(quantity) AS total_quantity, SUM(quantity) * 100.0 / (SELECT SUM(quantity) FROM Sales_Details) AS percentage_of_sales FROM Sales_Details, Ingredient_Categories WHERE Sales_Details.ingredient_id = Ingredient_Categories.ingredient_id GROUP BY ingredient_category;", "generated_sql": "SELECT\n  ic.ingredient_category,\n  SUM(sd.quantity) * 100.0 / (\n    SELECT\n      SUM(quantity)\n    FROM Sales_Details\n  ) AS percentage\nFROM Sales_Details AS sd\nJOIN Ingredient_Categories AS ic\n  ON sd.ingredient_id = ic.ingredient_id\nGROUP BY\n  ic.ingredient_category;", "raw_model_output": "```sql\nSELECT\n  ic.ingredient_category,\n  SUM(sd.quantity) * 100.0 / (\n    SELECT\n      SUM(quantity)\n    FROM Sales_Details\n  ) AS percentage\nFROM Sales_Details AS sd\nJOIN Ingredient_Categories AS ic\n  ON sd.ingredient_id = ic.ingredient_id\nGROUP BY\n  ic.ingredient_category;\n```", "latency_sec": 1.9595692157745361, "total_duration_sec": 1.906994437, "load_duration_sec": 0.031947903, "tokens_prompt": 210, "prompt_eval_sec": 0.070460086, "tokens_completion": 91, "completion_eval_sec": 1.80382993, "tokens_total": 301, "tokens_per_sec": 153.60518912878882, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the total quantity and percentage of sales per ingredient category. They use equivalent JOIN logic (implicit vs explicit) and the same aggregation/percentage calculation. The grouping by ingredient_category ensures identical results. Column aliases differ but do not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the percentage of sales per ingredient category by summing quantities and dividing by total sales. The reference query uses an implicit join (comma-separated tables) with a WHERE clause, while the generated query uses an explicit JOIN syntax. The generated version is more modern, readable, and avoids potential ambiguity from implicit joins. Both handle the business intent equally well, but the generated query demonstrates better SQL practices and clarity.", "overall_assessment": "correct"}}
{"example_id": 3329, "sql_complexity": "set operations", "prompt": "Which causes received funding from donors in both the United States and Canada?", "context": "CREATE TABLE donor_location (donor_id INT, country VARCHAR(50), cause VARCHAR(50), donation DECIMAL(10,2)); INSERT INTO donor_location (donor_id, country, cause, donation) VALUES (1, 'United States', 'Global Health', 1000.00), (2, 'Canada', 'Education', 2000.00), (3, 'United States', 'Environment', 1500.00), (4, 'Canada', 'Animal Welfare', 2500.00);", "reference_sql": "SELECT cause FROM donor_location WHERE country = 'United States' INTERSECT SELECT cause FROM donor_location WHERE country = 'Canada';", "generated_sql": "SELECT DISTINCT cause\nFROM donor_location\nWHERE country IN ('United States', 'Canada');", "raw_model_output": "```sql\nSELECT DISTINCT cause\nFROM donor_location\nWHERE country IN ('United States', 'Canada');\n```", "latency_sec": 0.6758761405944824, "total_duration_sec": 0.585763111, "load_duration_sec": 0.028471957, "tokens_prompt": 218, "prompt_eval_sec": 0.070467797, "tokens_completion": 25, "completion_eval_sec": 0.486052951, "tokens_total": 243, "tokens_per_sec": 359.5333307464645, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL finds causes common to both 'United States' and 'Canada' using INTERSECT, while the Generated SQL returns all distinct causes from either country. In the sample data, no causes are shared between the two countries, so the Reference query returns empty, but the Generated query returns all four causes (Global Health, Environment, Education, Animal Welfare).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly uses INTERSECT to find causes present in both countries, while the Generated SQL returns all causes from either country. The question requires identifying causes with funding from *both* nations, which only the Reference achieves. The Generated query's WHERE country IN (...) clause incorrectly includes causes from either country individually, not their intersection. Though both queries are syntactically correct, their semantic results differ fundamentally. The Reference directly addresses the business intent of finding overlapping causes, while the Generated query answers a different question (all causes in either country).", "overall_assessment": "incorrect"}}
{"example_id": 2912, "sql_complexity": "single join", "prompt": "Which company has manufactured the most satellites?", "context": "CREATE TABLE manufacturers (id INT, name TEXT); CREATE TABLE satellites (id INT, manufacturer_id INT, name TEXT, launch_date DATE); INSERT INTO manufacturers (id, name) VALUES (1, 'SpaceX'), (2, 'Blue Origin'), (3, 'ISRO'), (4, 'CAST'); INSERT INTO satellites (id, manufacturer_id, name, launch_date) VALUES (1, 1, 'StarDragon', '2012-05-25'), (2, 1, 'Falcon', '2015-12-21'), (3, 2, 'New Glenn', '2022-01-11'), (4, 3, 'ChinaSat 1E', '2000-12-05'), (5, 3, 'ChinaSat 2A', '2003-08-13'), (6, 4, 'Shijian 9', '2017-11-19'), (7, 1, 'StarLink', '2020-05-24'), (8, 1, 'StarLink', '2020-06-13');", "reference_sql": "SELECT m.name, COUNT(s.id) FROM manufacturers m JOIN satellites s ON m.id = s.manufacturer_id GROUP BY m.name ORDER BY COUNT(s.id) DESC;", "generated_sql": "SELECT\n  m.name\nFROM manufacturers AS m\nJOIN satellites AS s\n  ON m.id = s.manufacturer_id\nGROUP BY\n  m.name\nORDER BY\n  COUNT(s.id) DESC\nLIMIT 1;", "raw_model_output": "```sql\nSELECT\n  m.name\nFROM manufacturers AS m\nJOIN satellites AS s\n  ON m.id = s.manufacturer_id\nGROUP BY\n  m.name\nORDER BY\n  COUNT(s.id) DESC\nLIMIT 1;\n```", "latency_sec": 1.5346870422363281, "total_duration_sec": 1.339235487, "load_duration_sec": 0.03364034, "tokens_prompt": 355, "prompt_eval_sec": 0.121353986, "tokens_completion": 59, "completion_eval_sec": 1.183434184, "tokens_total": 414, "tokens_per_sec": 269.7618397798707, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns all manufacturers with their satellite counts ordered by count descending, while the Generated SQL adds a LIMIT 1 which only returns the top result. This makes them non-equivalent as the Generated SQL restricts output to a single row.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count satellites per manufacturer and order by count. The key difference is the LIMIT 1 in the generated query, which directly answers 'which company' by returning a single result. The reference query returns all manufacturers ordered by count, requiring additional interpretation to identify the top entry. While both are technically correct, the generated query is more efficient (avoids unnecessary data transfer) and better aligns with the business intent of identifying a single 'most' manufacturer.", "overall_assessment": "differently_correct"}}
{"example_id": 3170, "sql_complexity": "aggregation", "prompt": "Determine the total production quantity of silver for mining sites in Mexico, between the dates '2017-05-01' and '2017-09-30', having less than 40 employees.", "context": "CREATE TABLE silver_mine_2 (site_id INT, country VARCHAR(50), num_employees INT, extraction_date DATE, quantity INT); INSERT INTO silver_mine_2 (site_id, country, num_employees, extraction_date, quantity) VALUES (1, 'Mexico', 35, '2017-05-02', 1200), (2, 'Mexico', 30, '2017-08-31', 1800), (3, 'Mexico', 37, '2017-07-04', 2200);", "reference_sql": "SELECT country, SUM(quantity) as total_silver_prod FROM silver_mine_2 WHERE num_employees < 40 AND country = 'Mexico' AND extraction_date >= '2017-05-01' AND extraction_date <= '2017-09-30' GROUP BY country;", "generated_sql": "SELECT\n  SUM(quantity)\nFROM silver_mine_2\nWHERE\n  country = 'Mexico' AND extraction_date BETWEEN '2017-05-01' AND '2017-09-30' AND num_employees < 40;", "raw_model_output": "```sql\nSELECT\n  SUM(quantity)\nFROM silver_mine_2\nWHERE\n  country = 'Mexico' AND extraction_date BETWEEN '2017-05-01' AND '2017-09-30' AND num_employees < 40;\n```", "latency_sec": 1.602597713470459, "total_duration_sec": 1.476939538, "load_duration_sec": 0.032065706, "tokens_prompt": 270, "prompt_eval_sec": 0.090201099, "tokens_completion": 68, "completion_eval_sec": 1.353893148, "tokens_total": 338, "tokens_per_sec": 210.9075765920406, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes 'country' in the SELECT list with an explicit GROUP BY, while the Generated SQL omits the 'country' column. Although both calculate the same SUM(quantity) under identical filtering conditions, the result sets differ in structure (one includes 'country', the other does not). Semantic equivalence requires identical output columns and values.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the total silver production for Mexican sites with <40 employees between the specified dates. The reference query includes redundant GROUP BY country (since country is filtered to Mexico) and selects an unnecessary column. The generated query is more efficient by omitting the GROUP BY and unnecessary column, while maintaining identical logic. Both produce the same numerical result (1200+1800+2200=5200) from the given data.", "overall_assessment": "correct"}}
{"example_id": 3518, "sql_complexity": "basic SQL", "prompt": "Insert new records of ticket sales for a new event, including event and salesperson information.", "context": "CREATE TABLE salesperson (salesperson_id INT, name VARCHAR(50), position VARCHAR(50)); CREATE TABLE tickets (ticket_id INT, salesperson_id INT, event_id INT, price DECIMAL(5,2), quantity INT); CREATE TABLE events (event_id INT, name VARCHAR(50), date DATE); INSERT INTO salesperson VALUES (1, 'John Doe', 'Senior Salesperson'); INSERT INTO events VALUES (2, 'New Event', '2023-04-15');", "reference_sql": "INSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity) VALUES (2, 1, 2, 75, 50), (3, 2, 2, 65, 75); INSERT INTO events (event_id, name, date) VALUES (2, 'New Event', '2023-04-15');", "generated_sql": "INSERT INTO tickets (salesperson_id, event_id, price, quantity) VALUES (1, 2, 100.00, 5);", "raw_model_output": "```sql\nINSERT INTO tickets (salesperson_id, event_id, price, quantity) VALUES (1, 2, 100.00, 5);\n```", "latency_sec": 1.1712429523468018, "total_duration_sec": 0.900380891, "load_duration_sec": 0.027976362, "tokens_prompt": 205, "prompt_eval_sec": 0.069653653, "tokens_completion": 41, "completion_eval_sec": 0.801787753, "tokens_total": 246, "tokens_per_sec": 210.033280889412, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL inserts two rows into the tickets table and one row into the events table, while the Generated SQL only inserts a single row into the tickets table. Additionally, the Generated SQL omits the ticket_id column in the INSERT, which may cause an error if the column is non-nullable. The data values (e.g., price, quantity) also differ between the two queries.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is not technically equivalent to the Generated SQL. The Reference inserts two ticket records and redundantly re-inserts the event (which already exists in the context), while the Generated SQL inserts a single ticket record. The Generated SQL omits the required ticket_id column in the INSERT, which may be critical if the database enforces it (though this depends on schema specifics). However, the Generated SQL better fulfills the business intent by focusing on ticket sales for the existing event without redundant data. The Reference SQL fails to address the 'new event' requirement properly (as the event already exists) and includes unnecessary operations. The Generated SQL is more efficient but may lack completeness if ticket_id is mandatory.", "overall_assessment": "differently_correct"}}
{"example_id": 3925, "sql_complexity": "set operations", "prompt": "What is the total number of students and staff with accommodations in the \"disability_services\" schema, excluding the \"accessibility_parking\" type?", "context": "CREATE SCHEMA disability_services; CREATE TABLE staff (id INT, name VARCHAR(50), accommodation VARCHAR(50)); CREATE TABLE students (id INT, name VARCHAR(50), accommodation VARCHAR(50));", "reference_sql": "SELECT COUNT(*) FROM disability_services.staff WHERE accommodation != 'accessibility_parking' UNION SELECT COUNT(*) FROM disability_services.students WHERE accommodation != 'accessibility_parking';", "generated_sql": "SELECT\n  COUNT(T1.id)\nFROM (\n  SELECT\n    id\n  FROM students\n  WHERE\n    accommodation IS NOT NULL\n  UNION ALL SELECT\n    id\n  FROM staff\n  WHERE\n    accommodation IS NOT NULL\n) AS T1;", "raw_model_output": "```sql\nSELECT\n  COUNT(T1.id)\nFROM (\n  SELECT\n    id\n  FROM students\n  WHERE\n    accommodation IS NOT NULL\n  UNION ALL SELECT\n    id\n  FROM staff\n  WHERE\n    accommodation IS NOT NULL\n) AS T1;\n```", "latency_sec": 1.3638889789581299, "total_duration_sec": 1.348220614, "load_duration_sec": 0.028326908, "tokens_prompt": 154, "prompt_eval_sec": 0.046697371, "tokens_completion": 65, "completion_eval_sec": 1.272444165, "tokens_total": 219, "tokens_per_sec": 160.5702541619578, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL counts staff and students where accommodation != 'accessibility_parking' separately, returning two rows. The Generated SQL counts all non-null accommodation entries from both tables combined into a single row. The conditions (!= 'accessibility_parking' vs. IS NOT NULL) and result structure differ.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly filters out the 'accessibility_parking' type in both staff and student tables, aligning with the business intent. However, it returns two separate counts (staff and students) instead of a single total. The Generated SQL fails to exclude the 'accessibility_parking' type entirely, instead only checking for non-null accommodations. While it combines counts using UNION ALL, this approach is incomplete and incorrect for the specified exclusion. The Reference SQL better addresses the business intent despite its structural limitation, while the Generated SQL fundamentally misses the exclusion requirement.", "overall_assessment": "differently_correct"}}
{"example_id": 3340, "sql_complexity": "subqueries", "prompt": "Calculate the total revenue for garments manufactured in the US and sold in California.", "context": "CREATE TABLE garment_manufacturing(id INT PRIMARY KEY, garment_id INT, country VARCHAR(50), material VARCHAR(50), manufacturing_date DATE, quantity INT); CREATE TABLE garment_sales(id INT PRIMARY KEY, garment_id INT, store_id INT, sale_date DATE, units INT, revenue DECIMAL(10,2));", "reference_sql": "SELECT SUM(gs.revenue) FROM garment_manufacturing gm JOIN garment_sales gs ON gm.garment_id = gs.garment_id WHERE gm.country = 'United States' AND gs.store_id IN (SELECT id FROM stores WHERE region = 'California');", "generated_sql": "SELECT SUM(gs.revenue)\nFROM garment_sales AS gs\nJOIN garment_manufacturing AS gm ON gs.garment_id = gm.garment_id\nWHERE gm.country = 'US'\nAND gs.store_id IN (SELECT id FROM store WHERE state = 'California');", "raw_model_output": "```sql\nSELECT SUM(gs.revenue)\nFROM garment_sales AS gs\nJOIN garment_manufacturing AS gm ON gs.garment_id = gm.garment_id\nWHERE gm.country = 'US'\nAND gs.store_id IN (SELECT id FROM store WHERE state = 'California');\n```", "latency_sec": 1.5729541778564453, "total_duration_sec": 1.434001914, "load_duration_sec": 0.030277486, "tokens_prompt": 168, "prompt_eval_sec": 0.051596569, "tokens_completion": 69, "completion_eval_sec": 1.351255825, "tokens_total": 237, "tokens_per_sec": 150.67190343902672, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects: 1) The country condition uses 'United States' vs 'US' which may not match identical data, and 2) The subquery references 'stores' (with region) vs 'store' (with state) which could refer to different tables/columns. These differences could lead to different results depending on the actual data and schema.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "equal", "explanation": "The queries differ in two critical aspects: 1) The reference query references a 'stores' table with a 'region' column, while the generated query references a 'store' table with a 'state' column. Neither table exists in the provided schema, making both queries technically invalid. 2) The country filter uses 'United States' vs 'US' which may or may not match the data. Both queries attempt to address the business intent but fail due to schema inconsistencies. Neither query is superior as both contain fundamental flaws.", "overall_assessment": "incorrect"}}
{"example_id": 596, "sql_complexity": "basic SQL", "prompt": "What is the minimum energy production cost of wind farms in Spain?", "context": "CREATE TABLE wind_farm_costs (id INT, name TEXT, country TEXT, energy_production_cost FLOAT); INSERT INTO wind_farm_costs (id, name, country, energy_production_cost) VALUES (1, 'Las Tiesas', 'Spain', 0.045), (2, 'Eolo', 'Spain', 0.050);", "reference_sql": "SELECT MIN(energy_production_cost) FROM wind_farm_costs WHERE country = 'Spain';", "generated_sql": "SELECT min(energy_production_cost) FROM wind_farm_costs WHERE country = 'Spain';", "raw_model_output": "```sql\nSELECT min(energy_production_cost) FROM wind_farm_costs WHERE country = 'Spain';\n```", "latency_sec": 0.6744871139526367, "total_duration_sec": 0.605743893, "load_duration_sec": 0.033808478, "tokens_prompt": 173, "prompt_eval_sec": 0.051406722, "tokens_completion": 27, "completion_eval_sec": 0.519657987, "tokens_total": 200, "tokens_per_sec": 296.5216026559171, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The only difference is the case of the MIN function (uppercase vs lowercase), which does not affect SQL semantics as SQL keywords are case-insensitive. Both queries select the minimum energy_production_cost from Spanish wind farms.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the minimum energy production cost for Spanish wind farms by filtering on 'Spain' and using the MIN() function. The only difference is case sensitivity in the SQL keyword (MIN vs min), which is irrelevant in standard SQL implementations. Both queries would return the same result (0.045) from the provided dataset. Neither query is more efficient or elegant than the other, as they execute identical operations with no syntactic or semantic differences.", "overall_assessment": "correct"}}
{"example_id": 2604, "sql_complexity": "subqueries", "prompt": "What is the maximum number of virtual tours taken by a single user in the UK?", "context": "CREATE TABLE virtual_tour_data (user_id INT, hotel_id INT, tour_date DATE); INSERT INTO virtual_tour_data (user_id, hotel_id, tour_date) VALUES (1, 10, '2022-01-01'), (2, 11, '2022-01-03'), (3, 12, '2022-01-05'), (4, 10, '2022-01-07'), (5, 10, '2022-01-09'); CREATE TABLE hotels (hotel_id INT, hotel_name TEXT, country TEXT); INSERT INTO hotels (hotel_id, hotel_name, country) VALUES (10, 'Royal Park Hotel', 'UK'), (11, 'The Ritz London', 'UK'), (12, 'Hotel de Crillon', 'France');", "reference_sql": "SELECT MAX(vt.user_tours) FROM (SELECT user_id, COUNT(DISTINCT hotel_id) as user_tours FROM virtual_tour_data WHERE country = 'UK' GROUP BY user_id) as vt;", "generated_sql": "SELECT\n  MAX(virtual_tour_count)\nFROM (\n  SELECT\n    user_id,\n    COUNT(hotel_id) AS virtual_tour_count\n  FROM virtual_tour_data AS vtd\n  JOIN hotels AS h\n    ON vtd.hotel_id = h.hotel_id\n  WHERE\n    h.country = 'UK'\n  GROUP BY\n    user_id\n) AS user_tours;", "raw_model_output": "```sql\nSELECT\n  MAX(virtual_tour_count)\nFROM (\n  SELECT\n    user_id,\n    COUNT(hotel_id) AS virtual_tour_count\n  FROM virtual_tour_data AS vtd\n  JOIN hotels AS h\n    ON vtd.hotel_id = h.hotel_id\n  WHERE\n    h.country = 'UK'\n  GROUP BY\n    user_id\n) AS user_tours;\n```", "latency_sec": 2.4914300441741943, "total_duration_sec": 2.230035023, "load_duration_sec": 0.028321715, "tokens_prompt": 305, "prompt_eval_sec": 0.101340324, "tokens_completion": 104, "completion_eval_sec": 2.099380587, "tokens_total": 409, "tokens_per_sec": 164.16274699599944, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references a 'country' column in virtual_tour_data, which does not exist. The Generated SQL correctly joins with the hotels table to filter by country. Additionally, the Reference SQL uses COUNT(DISTINCT hotel_id) while the Generated SQL uses COUNT(hotel_id), which would produce different results if users visited the same hotel multiple times. However, the primary issue is the invalid column reference in the Reference SQL.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL is technically incorrect because it references a 'country' column in the virtual_tour_data table, which does not exist. The Generated SQL correctly joins the virtual_tour_data and hotels tables to filter by UK hotels. Both queries aim to find the maximum number of tours per user, but the Generated SQL properly incorporates the country filter via a JOIN. The Generated SQL also uses COUNT(hotel_id) which aligns with the question's focus on 'number of virtual tours' (each row representing a tour), whereas the Reference SQL's COUNT(DISTINCT hotel_id) would incorrectly count unique hotels instead of total tours. The Generated SQL is both syntactically correct and semantically aligned with the business intent.", "overall_assessment": "correct"}}
{"example_id": 5812, "sql_complexity": "single join", "prompt": "Calculate the percentage of Shariah-compliant investments held by each investor in the top 5 countries with the highest percentage?", "context": "CREATE TABLE investors (investor_id INT, investor_name TEXT, country TEXT); INSERT INTO investors (investor_id, investor_name, country) VALUES (1, 'Al Thani', 'Qatar'), (2, 'Saudi Investment Group', 'Saudi Arabia'), (3, 'Temasek Holdings', 'Singapore'); CREATE TABLE investments (investment_id INT, investor_id INT, investment_type TEXT, investment_value DECIMAL, is_shariah_compliant BOOLEAN); INSERT INTO investments (investment_id, investor_id, investment_type, investment_value, is_shariah_compliant) VALUES (1, 1, 'Real Estate', 15000000, true), (2, 2, 'Stocks', 20000000, false);", "reference_sql": "SELECT investor_name, ROUND((SUM(CASE WHEN is_shariah_compliant THEN investment_value ELSE 0 END) / SUM(investment_value)) * 100, 2) AS percentage FROM investments JOIN investors ON investments.investor_id = investors.investor_id GROUP BY investor_name ORDER BY percentage DESC LIMIT 5;", "generated_sql": "SELECT\n  T1.country,\n  SUM(CASE WHEN T2.is_shariah_compliant = TRUE THEN T2.investment_value ELSE 0 END) * 100.0 / SUM(T2.investment_value)\nFROM investors AS T1\nJOIN investments AS T2\n  ON T1.investor_id = T2.investor_id\nGROUP BY\n  T1.country\nORDER BY\n  SUM(T2.investment_value) DESC\nLIMIT 5;", "raw_model_output": "```sql\nSELECT\n  T1.country,\n  SUM(CASE WHEN T2.is_shariah_compliant = TRUE THEN T2.investment_value ELSE 0 END) * 100.0 / SUM(T2.investment_value)\nFROM investors AS T1\nJOIN investments AS T2\n  ON T1.investor_id = T2.investor_id\nGROUP BY\n  T1.country\nORDER BY\n  SUM(T2.investment_value) DESC\nLIMIT 5;\n```", "latency_sec": 2.554537057876587, "total_duration_sec": 2.509962981, "load_duration_sec": 0.031810352, "tokens_prompt": 276, "prompt_eval_sec": 0.090918016, "tokens_completion": 119, "completion_eval_sec": 2.385841304, "tokens_total": 395, "tokens_per_sec": 154.62684277061797, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL groups by investor_name and calculates the percentage of shariah-compliant investments per investor, while the Generated SQL groups by country and calculates the same ratio but aggregates across investors in the same country. Additionally, the Reference SQL orders by percentage DESC, whereas the Generated SQL orders by total investment value DESC. The selected columns (investor_name vs country) and ordering criteria differ, leading to different result structures and values.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL calculates Shariah compliance percentages per investor, but the question explicitly asks for results grouped by country, not investor. The Generated SQL correctly groups by country but has two critical issues: 1) It orders by total investment value (SUM(investment_value)) instead of the calculated percentage, which misaligns with the 'highest percentage' requirement. 2) It doesn't filter to only show investors from the top 5 countries (though this is implied by the LIMIT 5). While both queries fail to fully meet the intent, the Generated SQL addresses the country-level analysis more directly, making it technically superior despite its ordering flaw.", "overall_assessment": "differently_correct"}}
{"example_id": 4706, "sql_complexity": "multiple_joins", "prompt": "Who are the top 3 customers by total spend on makeup products from Italy and Spain?", "context": "CREATE TABLE customers (customer_id INT, customer_name TEXT, country TEXT); INSERT INTO customers (customer_id, customer_name, country) VALUES (1, 'Alessandro Martini', 'IT'), (2, 'Laura Rossi', 'ES'), (3, 'Daniela Gonzalez', 'MX'), (4, 'Jose Hernandez', 'ES'), (5, 'Sophia Rodriguez', 'IT'); CREATE TABLE sales (sale_id INT, customer_id INT, product_id INT, sale_quantity INT, sale_country TEXT); INSERT INTO sales (sale_id, customer_id, product_id, sale_quantity, sale_country) VALUES (1, 1, 1, 100, 'IT'), (2, 2, 2, 150, 'ES'), (3, 3, 3, 200, 'MX'), (4, 4, 4, 250, 'ES'), (5, 5, 5, 300, 'IT'); CREATE TABLE products (product_id INT, product_name TEXT, category TEXT); INSERT INTO products (product_id, product_name, category) VALUES (1, 'Eyeshadow Palette', 'makeup'), (2, 'Liquid Lipstick', 'makeup'), (3, 'BB Cream', 'makeup'), (4, 'Volumizing Mascara', 'makeup'), (5, 'Nourishing Lip Balm', 'makeup');", "reference_sql": "SELECT c.customer_name, SUM(s.sale_quantity) as total_spent_on_makeup FROM sales s JOIN customers c ON s.customer_id = c.customer_id JOIN products p ON s.product_id = p.product_id WHERE c.country IN ('IT', 'ES') AND p.category = 'makeup' GROUP BY c.customer_name ORDER BY total_spent_on_makeup DESC LIMIT 3;", "generated_sql": "SELECT\n  c.customer_name\nFROM customers AS c\nJOIN sales AS s\n  ON c.customer_id = s.customer_id\nJOIN products AS p\n  ON s.product_id = p.product_id\nWHERE\n  p.category = 'makeup' AND s.sale_country IN ('IT', 'ES')\nGROUP BY\n  c.customer_name\nORDER BY\n  SUM(s.sale_quantity) DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT\n  c.customer_name\nFROM customers AS c\nJOIN sales AS s\n  ON c.customer_id = s.customer_id\nJOIN products AS p\n  ON s.product_id = p.product_id\nWHERE\n  p.category = 'makeup' AND s.sale_country IN ('IT', 'ES')\nGROUP BY\n  c.customer_name\nORDER BY\n  SUM(s.sale_quantity) DESC\nLIMIT 3;\n```", "latency_sec": 2.719604969024658, "total_duration_sec": 2.408023845, "load_duration_sec": 0.030866656, "tokens_prompt": 409, "prompt_eval_sec": 0.146299901, "tokens_completion": 110, "completion_eval_sec": 2.229568692, "tokens_total": 519, "tokens_per_sec": 190.83653909712146, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Reference SQL filters customers by their country ('IT', 'ES') while the Generated SQL filters sales by sale_country ('IT', 'ES'), which may include different data. Second, the Reference SQL selects both customer_name and the aggregated total, while the Generated SQL only selects customer_name. These differences in filtering logic and selected columns make the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in their filtering logic. The reference query correctly filters customers by their country (c.country IN ('IT', 'ES')), while the generated query incorrectly filters by sale_country (s.sale_country IN ('IT', 'ES')). This means the generated query may include customers from other countries who made purchases in Italy/Spain, violating the original requirement to focus on customers from those countries. Both queries aggregate makeup product sales correctly, but the generated query's WHERE clause misaligns with the business intent. The reference query also explicitly includes the total spend metric, which provides transparency for validation.", "overall_assessment": "incorrect"}}
{"example_id": 1515, "sql_complexity": "multiple_joins", "prompt": "What is the average age of clients who lost cases in the 'personal injury' category?", "context": "CREATE TABLE Cases (CaseID int, ClientID int, Category varchar(50)); INSERT INTO Cases (CaseID, ClientID, Category) VALUES (701, 7, 'Personal Injury'); CREATE TABLE Clients (ClientID int, Age int, Gender varchar(10)); INSERT INTO Clients (ClientID, Age, Gender) VALUES (7, 45, 'Male'); CREATE TABLE CaseOutcomes (CaseID int, Outcome varchar(50)); INSERT INTO CaseOutcomes (CaseID, Outcome) VALUES (701, 'Lost');", "reference_sql": "SELECT AVG(C.Age) as AvgAge FROM Clients C INNER JOIN Cases CA ON C.ClientID = CA.ClientID INNER JOIN CaseOutcomes CO ON CA.CaseID = CO.CaseID WHERE CA.Category = 'Personal Injury' AND CO.Outcome = 'Lost';", "generated_sql": "SELECT AVG(C.Age)\nFROM Clients AS C\nJOIN Cases AS CA ON C.ClientID = CA.ClientID\nJOIN CaseOutcomes AS CO ON CA.CaseID = CO.CaseID\nWHERE CA.Category = 'Personal Injury' AND CO.Outcome = 'Lost';", "raw_model_output": "```sql\nSELECT AVG(C.Age)\nFROM Clients AS C\nJOIN Cases AS CA ON C.ClientID = CA.ClientID\nJOIN CaseOutcomes AS CO ON CA.CaseID = CO.CaseID\nWHERE CA.Category = 'Personal Injury' AND CO.Outcome = 'Lost';\n```", "latency_sec": 1.6083488464355469, "total_duration_sec": 1.400011702, "load_duration_sec": 0.028722528, "tokens_prompt": 214, "prompt_eval_sec": 0.070237174, "tokens_completion": 66, "completion_eval_sec": 1.300324793, "tokens_total": 280, "tokens_per_sec": 174.09158505665067, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform the same operations: joining Clients, Cases, and CaseOutcomes tables with identical conditions, filtering on 'Personal Injury' category and 'Lost' outcome, and calculating the average age. The only difference is the optional use of 'AS' keyword for table aliases, which does not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are structurally identical in terms of table joins, filtering conditions, and aggregation logic. The only difference is the use of explicit 'AS' keywords for table aliases in the generated query, which is a stylistic choice rather than a functional change. Both correctly calculate the average age of clients who lost 'Personal Injury' cases by joining the three relevant tables and applying the necessary filters. The business intent is fully addressed in both cases.", "overall_assessment": "correct"}}
{"example_id": 4388, "sql_complexity": "subqueries", "prompt": "Insert a new drug with a price 10% higher than the average price", "context": "CREATE TABLE drugs (drug_id INT, drug_name VARCHAR(50), price DECIMAL(10, 2)); INSERT INTO drugs (drug_id, drug_name, price) VALUES (1, 'DrugA', 50), (2, 'DrugB', 75), (3, 'DrugC', 100)", "reference_sql": "INSERT INTO drugs (drug_id, drug_name, price) VALUES ((SELECT MAX(drug_id) FROM drugs) + 1, 'DrugD', (SELECT AVG(price) * 1.1 FROM drugs))", "generated_sql": "INSERT INTO drugs (drug_id, drug_name, price) VALUES (4, 'DrugD', (SELECT AVG(price) * 1.1 FROM drugs));", "raw_model_output": "```sql\nINSERT INTO drugs (drug_id, drug_name, price) VALUES (4, 'DrugD', (SELECT AVG(price) * 1.1 FROM drugs));\n```", "latency_sec": 1.1451480388641357, "total_duration_sec": 0.899781512, "load_duration_sec": 0.0295583, "tokens_prompt": 171, "prompt_eval_sec": 0.051223999, "tokens_completion": 42, "completion_eval_sec": 0.81819465, "tokens_total": 213, "tokens_per_sec": 186.00215236038233, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "In the given context, both queries insert a new drug with drug_id 4 (since MAX(drug_id) is 3 and 3+1=4), drug_name 'DrugD', and price calculated as AVG(price)*1.1. The Generated SQL hardcodes drug_id=4, which matches the dynamic calculation in the Reference SQL for the current dataset. The price calculation is identical in both queries.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries insert a new drug with a price 10% above the average. The reference query dynamically calculates drug_id using (SELECT MAX(drug_id) + 1), which ensures correct sequencing even if existing drug_ids are non-sequential. The generated query hardcodes drug_id=4, which works in this specific context but would fail if drug_ids weren't sequential. The price calculation (AVG(price) * 1.1) is identical in both. While both fulfill the business intent, the reference query is more robust for general cases.", "overall_assessment": "correct"}}
{"example_id": 5431, "sql_complexity": "basic SQL", "prompt": "What is the average CO2 emission of ride-hailing vehicles in San Francisco?", "context": "CREATE TABLE SFRideHailing (id INT, company VARCHAR(20), co2_emission DECIMAL(5,2));", "reference_sql": "SELECT AVG(co2_emission) FROM SFRideHailing WHERE company = 'Uber';", "generated_sql": "SELECT AVG(co2_emission) FROM SFRideHailing;", "raw_model_output": "```sql\nSELECT AVG(co2_emission) FROM SFRideHailing;\n```", "latency_sec": 0.7109677791595459, "total_duration_sec": 0.448832604, "load_duration_sec": 0.030667395, "tokens_prompt": 123, "prompt_eval_sec": 0.037058173, "tokens_completion": 20, "completion_eval_sec": 0.380332115, "tokens_total": 143, "tokens_per_sec": 201.13429073965088, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query calculates the average co2_emission specifically for 'Uber' entries, while the generated query calculates the average for all entries in the table without any company filter. Without the WHERE company = 'Uber' condition, the generated query would include data from all companies, leading to a different result.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL incorrectly filters for only 'Uber' vehicles, while the original question asks about all ride-hailing vehicles in San Francisco. The Generated SQL correctly calculates the average CO2 emission for the entire SFRideHailing dataset. Although neither query explicitly filters by location (but the table name implies SF), the Reference SQL's company-specific filter violates the business intent. The Generated SQL is more comprehensive and aligns better with the question's scope.", "overall_assessment": "differently_correct"}}
{"example_id": 3531, "sql_complexity": "single join", "prompt": "What is the total number of workouts and total workout time per user for users with a membership type of 'Basic'?", "context": "CREATE TABLE Members (id INT, user_name VARCHAR, membership_type VARCHAR, signup_date DATE); CREATE TABLE Workouts (id INT, user_id INT, workout_date DATE, workout_duration INT); INSERT INTO Members (id, user_name, membership_type, signup_date) VALUES (1, 'John Doe', 'Premium', '2020-01-01'), (2, 'Jane Smith', 'Basic', '2019-06-15'), (3, 'Alice Johnson', 'Premium', '2020-03-20'); INSERT INTO Workouts (id, user_id, workout_date, workout_duration) VALUES (1, 1, '2020-01-01', 60), (2, 1, '2020-01-02', 70), (3, 2, '2019-06-15', 90), (4, 3, '2020-03-20', 65), (5, 3, '2020-03-21', 70);", "reference_sql": "SELECT Members.user_name, SUM(Workouts.workout_duration) AS total_workout_time, COUNT(Workouts.id) AS total_workouts FROM Members JOIN Workouts ON Members.id = Workouts.user_id WHERE Members.membership_type = 'Basic' GROUP BY Members.user_name;", "generated_sql": "SELECT\n  m.user_name,\n  COUNT(w.id) AS total_workouts,\n  SUM(w.workout_duration) AS total_workout_time\nFROM Members AS m\nJOIN Workouts AS w\n  ON m.id = w.user_id\nWHERE\n  m.membership_type = 'Basic'\nGROUP BY\n  m.user_name;", "raw_model_output": "```sql\nSELECT\n  m.user_name,\n  COUNT(w.id) AS total_workouts,\n  SUM(w.workout_duration) AS total_workout_time\nFROM Members AS m\nJOIN Workouts AS w\n  ON m.id = w.user_id\nWHERE\n  m.membership_type = 'Basic'\nGROUP BY\n  m.user_name;\n```", "latency_sec": 2.3252358436584473, "total_duration_sec": 2.00137222, "load_duration_sec": 0.028758766, "tokens_prompt": 363, "prompt_eval_sec": 0.130422545, "tokens_completion": 91, "completion_eval_sec": 1.841285284, "tokens_total": 454, "tokens_per_sec": 195.2490115091688, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same data by joining Members and Workouts tables on user_id, filtering for 'Basic' membership. The generated query uses aliases and reorders columns in the SELECT clause, but these are syntactic differences that do not affect the semantic result. The aggregation functions (SUM and COUNT) and grouping logic are identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically equivalent, producing identical results by joining Members and Workouts tables, filtering for 'Basic' membership, and aggregating total workouts and workout time per user. The generated query uses table aliases (m/w) which makes it more concise and readable without altering functionality. While both fulfill the business intent, the generated version is more elegant due to its compact syntax and standard aliasing conventions. Neither query has performance advantages over the other in this scenario.", "overall_assessment": "correct"}}
{"example_id": 5678, "sql_complexity": "set operations", "prompt": "How many public works projects are there in 'Sydney' and 'Melbourne' combined?", "context": "CREATE TABLE PublicWorksC(id INT, city VARCHAR(20), project VARCHAR(30)); INSERT INTO PublicWorksC(id, city, project) VALUES (1, 'Sydney', 'Park Renovation'), (2, 'Melbourne', 'Sidewalk Repair');", "reference_sql": "SELECT COUNT(*) FROM (SELECT city FROM PublicWorksC WHERE city = 'Sydney' UNION ALL SELECT city FROM PublicWorksC WHERE city = 'Melbourne') AS Total;", "generated_sql": "SELECT\n  COUNT(id)\nFROM PublicWorksC\nWHERE\n  city IN ('Sydney', 'Melbourne');", "raw_model_output": "```sql\nSELECT\n  COUNT(id)\nFROM PublicWorksC\nWHERE\n  city IN ('Sydney', 'Melbourne');\n```", "latency_sec": 0.7672100067138672, "total_duration_sec": 0.655627104, "load_duration_sec": 0.028171679, "tokens_prompt": 153, "prompt_eval_sec": 0.046448028, "tokens_completion": 30, "completion_eval_sec": 0.580152647, "tokens_total": 183, "tokens_per_sec": 238.5266073155512, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of rows where the city is either 'Sydney' or 'Melbourne'. The Reference SQL uses a subquery with UNION ALL to combine results from two separate selects, while the Generated SQL uses a single WHERE clause with IN. Since the data contains exactly one row for each city, both approaches yield the same count of 2.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count projects in Sydney and Melbourne. The reference query uses a UNION ALL subquery to combine results from two separate SELECTs, while the generated query uses a single WHERE clause with IN. Both produce identical counts. However, the generated query is more efficient as it requires a single table scan and avoids the overhead of subquery processing. The generated version is also more concise and directly addresses the business intent of counting projects in either city.", "overall_assessment": "correct"}}
{"example_id": 5792, "sql_complexity": "multiple_joins", "prompt": "How many cases were handled by attorneys in the 'Los Angeles' office?", "context": "CREATE TABLE offices (office_id INT, office_name VARCHAR(20), city VARCHAR(20), state VARCHAR(20)); INSERT INTO offices (office_id, office_name, city, state) VALUES (1, 'Boston', 'Boston', 'MA'), (2, 'New York', 'New York', 'NY'), (3, 'Los Angeles', 'Los Angeles', 'CA'); CREATE TABLE attorneys (attorney_id INT, office_id INT); INSERT INTO attorneys (attorney_id, office_id) VALUES (1, 1), (2, 2), (3, 3); CREATE TABLE cases (case_id INT, attorney_id INT); INSERT INTO cases (case_id, attorney_id) VALUES (1, 1), (2, 2), (3, 3);", "reference_sql": "SELECT COUNT(*) FROM cases JOIN attorneys ON cases.attorney_id = attorneys.attorney_id JOIN offices ON attorneys.office_id = offices.office_id WHERE offices.city = 'Los Angeles';", "generated_sql": "SELECT\n  COUNT(T1.case_id)\nFROM cases AS T1\nINNER JOIN attorneys AS T2\n  ON T1.attorney_id = T2.attorney_id\nINNER JOIN offices AS T3\n  ON T2.office_id = T3.office_id\nWHERE\n  T3.office_name = 'Los Angeles';", "raw_model_output": "```sql\nSELECT\n  COUNT(T1.case_id)\nFROM cases AS T1\nINNER JOIN attorneys AS T2\n  ON T1.attorney_id = T2.attorney_id\nINNER JOIN offices AS T3\n  ON T2.office_id = T3.office_id\nWHERE\n  T3.office_name = 'Los Angeles';\n```", "latency_sec": 2.1931991577148438, "total_duration_sec": 1.872681052, "load_duration_sec": 0.038464819, "tokens_prompt": 273, "prompt_eval_sec": 0.089748974, "tokens_completion": 87, "completion_eval_sec": 1.743605601, "tokens_total": 360, "tokens_per_sec": 164.14377998170224, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters on 'offices.city = 'Los Angeles'', while the Generated SQL filters on 'T3.office_name = 'Los Angeles''. Since the 'city' and 'office_name' columns are distinct in the schema, these conditions are not equivalent. The sample data happens to have matching values, but semantically the queries target different columns.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries produce the same result in this specific dataset because the 'Los Angeles' office has both city = 'Los Angeles' and office_name = 'Los Angeles'. However, the generated query explicitly uses offices.office_name = 'Los Angeles' which better aligns with the business intent of identifying cases handled by the 'Los Angeles' office (as named in the offices table). The reference query mistakenly uses the city column instead of the office_name, which would fail if an office had a different name than its city. The generated query is more semantically accurate while maintaining technical correctness.", "overall_assessment": "differently_correct"}}
{"example_id": 5148, "sql_complexity": "window functions", "prompt": "List the unique types of smart city technologies that have been implemented in the top 3 most populous countries in the world.", "context": "CREATE TABLE smart_city_tech (tech_type VARCHAR(255), country VARCHAR(255)); CREATE TABLE country_populations (country VARCHAR(255), population INT);", "reference_sql": "SELECT DISTINCT tech_type FROM smart_city_tech SCT WHERE country IN (SELECT country FROM (SELECT country, ROW_NUMBER() OVER (ORDER BY population DESC) as rank FROM country_populations) CP WHERE rank <= 3);", "generated_sql": "SELECT DISTINCT\n  smart_city_tech.tech_type\nFROM smart_city_tech\nJOIN country_populations\n  ON smart_city_tech.country = country_populations.country\nWHERE\n  country_populations.country IN (\n    SELECT\n      country\n    FROM country_populations\n    ORDER BY\n      population DESC\n    LIMIT 3\n  );", "raw_model_output": "```sql\nSELECT DISTINCT\n  smart_city_tech.tech_type\nFROM smart_city_tech\nJOIN country_populations\n  ON smart_city_tech.country = country_populations.country\nWHERE\n  country_populations.country IN (\n    SELECT\n      country\n    FROM country_populations\n    ORDER BY\n      population DESC\n    LIMIT 3\n  );\n```", "latency_sec": 1.8100640773773193, "total_duration_sec": 1.773301299, "load_duration_sec": 0.033052129, "tokens_prompt": 144, "prompt_eval_sec": 0.04190874, "tokens_completion": 86, "completion_eval_sec": 1.697536763, "tokens_total": 230, "tokens_per_sec": 127.06732478402478, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries aim to retrieve distinct tech_types from smart_city_tech where the country is among the top 3 most populous countries. The Reference SQL uses a window function (ROW_NUMBER()) to rank countries by population and filters for rank <= 3, while the Generated SQL uses ORDER BY population DESC LIMIT 3. Both approaches effectively identify the same top 3 countries, assuming consistent ordering. The final result sets of tech_types would be identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify unique smart city technologies in the top 3 most populous countries. The reference query uses a window function with ROW_NUMBER() to rank countries, while the generated query uses LIMIT 3 for simplicity. Semantically, they produce the same results if the top 3 countries are unambiguously defined. However, the generated query is more efficient and readable, avoiding complex window functions. Both handle the business intent, but the generated version is more elegant and performant.", "overall_assessment": "correct"}}
{"example_id": 5547, "sql_complexity": "multiple_joins", "prompt": "Which species have a population growth rate higher than the average for protected areas?", "context": "CREATE TABLE species (id INT, name VARCHAR(50), population DECIMAL(5,2), protected_area_id INT, growth_rate DECIMAL(5,2)); INSERT INTO species (id, name, population, protected_area_id, growth_rate) VALUES (1, 'Species 1', 500.00, 1, 0.05), (2, 'Species 2', 800.00, 1, 0.03), (3, 'Species 3', 1200.00, 2, 0.07), (4, 'Species 4', 700.00, 2, 0.02); CREATE TABLE protected_areas (id INT, name VARCHAR(50)); INSERT INTO protected_areas (id, name) VALUES (1, 'Area 1'), (2, 'Area 2');", "reference_sql": "SELECT s.name, s.growth_rate FROM species s INNER JOIN protected_areas pa ON s.protected_area_id = pa.id GROUP BY s.name, s.growth_rate HAVING s.growth_rate > (SELECT AVG(s.growth_rate) FROM species s INNER JOIN protected_areas pa ON s.protected_area_id = pa.id);", "generated_sql": "SELECT\n  name\nFROM species\nWHERE\n  growth_rate > (\n    SELECT\n      AVG(growth_rate)\n    FROM species\n  );", "raw_model_output": "```sql\nSELECT\n  name\nFROM species\nWHERE\n  growth_rate > (\n    SELECT\n      AVG(growth_rate)\n    FROM species\n  );\n```", "latency_sec": 1.0423579216003418, "total_duration_sec": 0.93112564, "load_duration_sec": 0.044195971, "tokens_prompt": 295, "prompt_eval_sec": 0.098807166, "tokens_completion": 40, "completion_eval_sec": 0.787256259, "tokens_total": 335, "tokens_per_sec": 321.38672624627, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL includes a JOIN with protected_areas in both the main query and the subquery, but the Generated SQL omits this JOIN. While the subquery in the Reference SQL (averaging growth_rate) would produce the same result as the Generated SQL's subquery (since all species have valid protected_area_id values), the main query differs: the Reference SQL selects (name, growth_rate) and groups by both, while the Generated SQL only selects name. Additionally, the Reference SQL's GROUP BY and HAVING clause could return multiple rows per species if growth_rate varies, whereas the Generated SQL returns distinct names. The column sets and potential row counts differ, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly calculates the average growth rate of species within protected areas by joining the species and protected_areas tables in both the main query and subquery. The Generated SQL incorrectly calculates the average growth rate of all species without considering the protected_areas context, which violates the business requirement to compare against the protected area-specific average. While both queries might return the same results in this specific dataset (since all species are in protected areas), the Generated SQL fails to address the actual business intent of analyzing protected area data. The Reference SQL is more precise and aligns with the question's requirements.", "overall_assessment": "differently_correct"}}
{"example_id": 5498, "sql_complexity": "aggregation", "prompt": "Identify the destinations with the highest number of repeat visitors from the US.", "context": "CREATE TABLE RepeatTravelers (Visitor VARCHAR(20), Destination VARCHAR(20), VisitCount INT); INSERT INTO RepeatTravelers (Visitor, Destination, VisitCount) VALUES ('David', 'Paris', 3), ('Ella', 'London', 4), ('Fiona', 'Paris', 2);", "reference_sql": "SELECT Destination, AVG(VisitCount) AS AvgVisitCount FROM RepeatTravelers WHERE Visitor LIKE '%USA%' GROUP BY Destination ORDER BY AvgVisitCount DESC;", "generated_sql": "SELECT Destination FROM RepeatTravelers WHERE Visitor = 'David' ORDER BY VisitCount DESC LIMIT 1;", "raw_model_output": "```sql\nSELECT Destination FROM RepeatTravelers WHERE Visitor = 'David' ORDER BY VisitCount DESC LIMIT 1;\n```", "latency_sec": 1.1134920120239258, "total_duration_sec": 0.605767019, "load_duration_sec": 0.038813039, "tokens_prompt": 158, "prompt_eval_sec": 0.04695387, "tokens_completion": 27, "completion_eval_sec": 0.519085663, "tokens_total": 185, "tokens_per_sec": 166.14398487128517, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates the average VisitCount per destination for visitors from USA, while the Generated SQL selects David's destination with the highest VisitCount. In the sample data, the Reference SQL returns no rows (no USA visitors), whereas the Generated SQL returns 'Paris'. Their logic, filtering, aggregation, and output structures differ fundamentally.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query attempts to address the business intent by aggregating visit counts per destination and ordering by average visits, but it incorrectly filters for 'USA' in the Visitor column (which contains names, not countries). The generated query is technically correct but only returns a single destination for a specific visitor, failing to address the 'repeat visitors from the US' requirement. Neither query properly identifies US visitors due to schema limitations, but the reference query better aligns with the intent of aggregating destination-level data.", "overall_assessment": "incorrect"}}
{"example_id": 3546, "sql_complexity": "window functions", "prompt": "What are the cryptocurrency exchanges with their corresponding blockchain companies, ranked by exchange ID in ascending order, for the Bitcoin platform?", "context": "CREATE TABLE cryptocurrency_exchanges (exchange_id INT, exchange_name VARCHAR(50), company_id INT); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (1, 'Binance', 1); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (2, 'Coinbase', 2); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (3, 'Kraken', 3); CREATE TABLE blockchain_companies (company_id INT, company_name VARCHAR(50), platform VARCHAR(50)); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (1, 'Binance', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (2, 'Blockstream', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (3, 'Blockchair', 'Bitcoin');", "reference_sql": "SELECT ce.exchange_name, bc.company_name, ce.exchange_id, ROW_NUMBER() OVER (PARTITION BY bc.platform ORDER BY ce.exchange_id ASC) as rank FROM cryptocurrency_exchanges ce JOIN blockchain_companies bc ON ce.company_id = bc.company_id WHERE bc.platform = 'Bitcoin';", "generated_sql": "SELECT\n  ce.exchange_name,\n  bc.company_name\nFROM cryptocurrency_exchanges AS ce\nJOIN blockchain_companies AS bc\n  ON ce.company_id = bc.company_id\nWHERE\n  bc.platform = 'Bitcoin'\nORDER BY\n  ce.exchange_id;", "raw_model_output": "```sql\nSELECT\n  ce.exchange_name,\n  bc.company_name\nFROM cryptocurrency_exchanges AS ce\nJOIN blockchain_companies AS bc\n  ON ce.company_id = bc.company_id\nWHERE\n  bc.platform = 'Bitcoin'\nORDER BY\n  ce.exchange_id;\n```", "latency_sec": 1.8528099060058594, "total_duration_sec": 1.597444177, "load_duration_sec": 0.033483213, "tokens_prompt": 325, "prompt_eval_sec": 0.102309936, "tokens_completion": 73, "completion_eval_sec": 1.4605309, "tokens_total": 398, "tokens_per_sec": 214.80886879430435, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL includes an additional 'exchange_id' column and a 'rank' column generated by ROW_NUMBER(), while the Generated SQL omits these. Additionally, the Generated SQL includes an ORDER BY clause not present in the Reference SQL, which could affect result ordering. The result sets differ in both structure and content.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL includes a ROW_NUMBER() ranking that wasn't explicitly requested in the original question, adding unnecessary complexity. While it correctly joins tables and filters for Bitcoin, the ranking column introduces extraneous data. The Generated SQL directly addresses the requirements by joining tables, filtering for Bitcoin, and ordering by exchange_id as specified. It avoids the redundant window function and produces a cleaner result set that matches the exact columns requested (exchange_name, company_name) without additional metadata. Both queries are technically correct, but the Generated version better aligns with the business intent of simply listing and ordering exchanges.", "overall_assessment": "differently_correct"}}
{"example_id": 486, "sql_complexity": "single join", "prompt": "What is the average price of paintings from African artists in our collection?", "context": "CREATE TABLE Artworks (id INT, title VARCHAR(50), price DECIMAL(10,2), medium VARCHAR(50), artist_nationality VARCHAR(50)); CREATE TABLE Collections (id INT, name VARCHAR(50), continent VARCHAR(50));", "reference_sql": "SELECT AVG(Artworks.price) FROM Artworks INNER JOIN Collections ON Artworks.artist_nationality = Collections.continent WHERE Artworks.medium = 'Painting' AND Collections.continent = 'Africa';", "generated_sql": "SELECT AVG(price)\nFROM Artworks\nWHERE artist_nationality = 'African' AND medium = 'painting';", "raw_model_output": "```sql\nSELECT AVG(price)\nFROM Artworks\nWHERE artist_nationality = 'African' AND medium = 'painting';\n```", "latency_sec": 0.9526491165161133, "total_duration_sec": 0.661516141, "load_duration_sec": 0.038875958, "tokens_prompt": 149, "prompt_eval_sec": 0.042244444, "tokens_completion": 30, "completion_eval_sec": 0.579551994, "tokens_total": 179, "tokens_per_sec": 187.89709337537855, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their filtering conditions. The Reference SQL joins Artworks with Collections on artist_nationality = continent and filters Collections.continent = 'Africa', which implies Artworks.artist_nationality must be 'Africa'. The Generated SQL directly filters Artworks.artist_nationality = 'African' (a different value) and omits the join. Additionally, the Generated SQL lacks the join logic, which could affect the dataset. These differences in conditions and logic make the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query incorrectly joins Artworks.artist_nationality (a nationality) with Collections.continent (a continent), which is a logical mismatch. The generated query directly filters Artworks where artist_nationality = 'African' and medium = 'painting', which more accurately addresses the business question. While both queries calculate AVG(price), the reference query's join condition and schema interpretation are flawed. The generated query is simpler, avoids unnecessary joins, and directly targets the correct filtering criteria for African artists.", "overall_assessment": "differently_correct"}}
{"example_id": 794, "sql_complexity": "multiple_joins", "prompt": "Which suppliers have provided raw materials for the production of chemicals with high environmental impact?", "context": "CREATE TABLE suppliers (id INT, name TEXT); INSERT INTO suppliers (id, name) VALUES (1, 'Supplier1'), (2, 'Supplier2'), (3, 'Supplier3'); CREATE TABLE chemicals (id INT, name TEXT, environmental_impact INT); INSERT INTO chemicals (id, name, environmental_impact) VALUES (1, 'ChemA', 10), (2, 'ChemB', 20), (3, 'ChemC', 15); CREATE TABLE raw_materials (chemical_id INT, supplier_id INT); INSERT INTO raw_materials (chemical_id, supplier_id) VALUES (1, 1), (1, 2), (2, 3), (3, 1);", "reference_sql": "SELECT s.name FROM suppliers s INNER JOIN raw_materials rm ON s.id = rm.supplier_id INNER JOIN chemicals c ON rm.chemical_id = c.id WHERE c.environmental_impact > 10;", "generated_sql": "SELECT DISTINCT\n  T1.name\nFROM suppliers AS T1\nINNER JOIN raw_materials AS T2\n  ON T1.id = T2.supplier_id\nINNER JOIN chemicals AS T3\n  ON T2.chemical_id = T3.id\nWHERE\n  T3.environmental_impact > 10;", "raw_model_output": "```sql\nSELECT DISTINCT\n  T1.name\nFROM suppliers AS T1\nINNER JOIN raw_materials AS T2\n  ON T1.id = T2.supplier_id\nINNER JOIN chemicals AS T3\n  ON T2.chemical_id = T3.id\nWHERE\n  T3.environmental_impact > 10;\n```", "latency_sec": 1.7284762859344482, "total_duration_sec": 1.684408031, "load_duration_sec": 0.029192204, "tokens_prompt": 252, "prompt_eval_sec": 0.080955843, "tokens_completion": 79, "completion_eval_sec": 1.573352036, "tokens_total": 331, "tokens_per_sec": 191.49814359243865, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Generated SQL includes a DISTINCT keyword which ensures unique supplier names, while the Reference SQL does not. If a supplier provides multiple chemicals meeting the environmental impact condition, the Reference SQL would return duplicates whereas the Generated SQL would not. This difference in handling duplicates makes them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent due to the use of DISTINCT in the generated query, which ensures unique supplier names. The reference query may return duplicate supplier names if a supplier provided multiple high-impact chemicals. Both correctly join the tables and filter by environmental impact > 10, but the generated query better fulfills the business intent by avoiding duplicates. The generated query is more elegant and practical for reporting purposes.", "overall_assessment": "differently_correct"}}
{"example_id": 3164, "sql_complexity": "set operations", "prompt": "What is the average age of patients who received therapy in 'clinic_a' and 'clinic_b'?", "context": "CREATE TABLE clinic_a (patient_id INT, age INT, therapy_received BOOLEAN); INSERT INTO clinic_a (patient_id, age, therapy_received) VALUES (1, 35, true), (2, 42, true), (3, 28, false); CREATE TABLE clinic_b (patient_id INT, age INT, therapy_received BOOLEAN); INSERT INTO clinic_b (patient_id, age, therapy_received) VALUES (4, 50, true), (5, 32, false), (6, 45, true);", "reference_sql": "SELECT AVG(age) FROM (SELECT age FROM clinic_a WHERE therapy_received = true UNION ALL SELECT age FROM clinic_b WHERE therapy_received = true) AS combined_clinics;", "generated_sql": "SELECT AVG(age) FROM clinic_a WHERE therapy_received = TRUE UNION ALL SELECT AVG(age) FROM clinic_b WHERE therapy_received = TRUE;", "raw_model_output": "```sql\nSELECT AVG(age) FROM clinic_a WHERE therapy_received = TRUE UNION ALL SELECT AVG(age) FROM clinic_b WHERE therapy_received = TRUE;\n```", "latency_sec": 1.1698460578918457, "total_duration_sec": 0.864064619, "load_duration_sec": 0.029965293, "tokens_prompt": 230, "prompt_eval_sec": 0.071787039, "tokens_completion": 39, "completion_eval_sec": 0.761501682, "tokens_total": 269, "tokens_per_sec": 229.94478477344197, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the average age of all patients (from both clinics) who received therapy, while the Generated SQL computes two separate averages (one for each clinic) and returns them as distinct rows. The result structures differ: the first produces a single value, while the second produces two values.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly combines all therapy-receiving patients from both clinics first (using UNION ALL) and then calculates a single average age. The Generated SQL instead calculates two separate averages (one for each clinic) and returns them as two rows, which does not answer the original question about a combined average. While both queries filter for therapy_received = TRUE, the Generated SQL's structure violates the requirement for a single aggregated result. The Reference SQL is both semantically correct and technically superior for this use case.", "overall_assessment": "incorrect"}}
{"example_id": 3704, "sql_complexity": "aggregation", "prompt": "What is the total sales revenue for each category of garments in the South America region in Q1 2022?", "context": "CREATE TABLE sales_category (sale_id INT, garment_category VARCHAR(50), sale_date DATE, total_sales DECIMAL(10, 2), region VARCHAR(50));", "reference_sql": "SELECT garment_category, SUM(total_sales) FROM sales_category WHERE sale_date BETWEEN '2022-01-01' AND '2022-03-31' AND region = 'South America' GROUP BY garment_category;", "generated_sql": "SELECT\n  garment_category,\n  SUM(total_sales) AS total_sales_revenue\nFROM sales_category\nWHERE\n  region = 'South America' AND sale_date BETWEEN '2022-01-01' AND '2022-03-31'\nGROUP BY\n  garment_category;", "raw_model_output": "```sql\nSELECT\n  garment_category,\n  SUM(total_sales) AS total_sales_revenue\nFROM sales_category\nWHERE\n  region = 'South America' AND sale_date BETWEEN '2022-01-01' AND '2022-03-31'\nGROUP BY\n  garment_category;\n```", "latency_sec": 1.7926812171936035, "total_duration_sec": 1.699184685, "load_duration_sec": 0.028755819, "tokens_prompt": 146, "prompt_eval_sec": 0.042168086, "tokens_completion": 83, "completion_eval_sec": 1.62737961, "tokens_total": 229, "tokens_per_sec": 127.74161842254009, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (garment_category and SUM(total_sales)), apply identical WHERE conditions (region = 'South America' and sale_date between '2022-01-01' and '2022-03-31'), and group by the same column (garment_category). The only difference is the column alias (total_sales_revenue vs. implicit name), which does not affect the semantic result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically equivalent as they produce identical results by aggregating total_sales for South America region during Q1 2022. The generated query improves upon the reference by explicitly naming the aggregated column as 'total_sales_revenue', which better aligns with the business question's phrasing of 'total sales revenue'. The WHERE clause conditions are logically equivalent despite different ordering. Both correctly address the business intent, but the generated query's column alias enhances clarity and direct relevance to the question.", "overall_assessment": "correct"}}
{"example_id": 2851, "sql_complexity": "single join", "prompt": "How many cases were handled by attorneys who joined the firm in 2015 or later?", "context": "CREATE TABLE attorneys (attorney_id INT, join_year INT); CREATE TABLE cases (case_id INT, attorney_id INT, billing_amount INT);", "reference_sql": "SELECT COUNT(DISTINCT cases.case_id) FROM cases INNER JOIN attorneys ON cases.attorney_id = attorneys.attorney_id WHERE attorneys.join_year >= 2015;", "generated_sql": "SELECT\n  COUNT(c.case_id)\nFROM cases AS c\nJOIN attorneys AS a\n  ON c.attorney_id = a.attorney_id\nWHERE\n  a.join_year >= 2015;", "raw_model_output": "```sql\nSELECT\n  COUNT(c.case_id)\nFROM cases AS c\nJOIN attorneys AS a\n  ON c.attorney_id = a.attorney_id\nWHERE\n  a.join_year >= 2015;\n```", "latency_sec": 1.4300651550292969, "total_duration_sec": 1.222833133, "load_duration_sec": 0.02829865, "tokens_prompt": 134, "prompt_eval_sec": 0.038149665, "tokens_completion": 59, "completion_eval_sec": 1.155562746, "tokens_total": 193, "tokens_per_sec": 134.95888583904846, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query uses COUNT(DISTINCT cases.case_id) while the generated query uses COUNT(c.case_id). The DISTINCT keyword in the reference query ensures unique case_id counts, whereas the generated query counts all case_id entries, potentially including duplicates. This difference in aggregation logic makes them non-equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly join the cases and attorneys tables on attorney_id and filter for attorneys who joined in 2015 or later. The reference query uses COUNT(DISTINCT cases.case_id) while the generated query uses COUNT(c.case_id). Since case_id is likely a primary key (implied by typical database design) and thus unique, both approaches yield the same result. The reference query's DISTINCT is redundant but not incorrect. Both queries fulfill the business intent of counting unique cases handled by qualifying attorneys. The generated query is slightly more concise but functionally equivalent.", "overall_assessment": "correct"}}
{"example_id": 3246, "sql_complexity": "single join", "prompt": "What is the average eco-friendliness score of accommodations in Oceania by year?", "context": "CREATE TABLE Accommodations (Accommodation_ID INT, Accommodation_Name VARCHAR(50), City VARCHAR(30), Country VARCHAR(50), Eco_Friendliness_Score INT, Visit_Year INT); INSERT INTO Accommodations (Accommodation_ID, Accommodation_Name, City, Country, Eco_Friendliness_Score, Visit_Year) VALUES (1, 'EcoLodge', 'Sydney', 'Australia', 85, 2019), (2, 'GreenHotel', 'Melbourne', 'Australia', 90, 2019), (3, 'SustainableResort', 'Auckland', 'New Zealand', 80, 2019), (4, 'EcoVilla', 'Wellington', 'New Zealand', 88, 2019); CREATE TABLE Countries (Country VARCHAR(50), Continent VARCHAR(30)); INSERT INTO Countries (Country, Continent) VALUES ('Australia', 'Oceania'), ('New Zealand', 'Oceania');", "reference_sql": "SELECT C.Continent, V.Visit_Year, AVG(A.Eco_Friendliness_Score) AS Avg_Eco_Score  FROM Accommodations A  JOIN Countries C  ON A.Country = C.Country  WHERE C.Continent = 'Oceania'  GROUP BY C.Continent, V.Visit_Year  ORDER BY V.Visit_Year;", "generated_sql": "SELECT\n  AVG(T1.Eco_Friendliness_Score),\n  T1.Visit_Year\nFROM Accommodations AS T1\nJOIN Countries AS T2\n  ON T1.Country = T2.Country\nWHERE\n  T2.Continent = 'Oceania'\nGROUP BY\n  T1.Visit_Year;", "raw_model_output": "```sql\nSELECT\n  AVG(T1.Eco_Friendliness_Score),\n  T1.Visit_Year\nFROM Accommodations AS T1\nJOIN Countries AS T2\n  ON T1.Country = T2.Country\nWHERE\n  T2.Continent = 'Oceania'\nGROUP BY\n  T1.Visit_Year;\n```", "latency_sec": 1.969242811203003, "total_duration_sec": 1.70971419, "load_duration_sec": 0.028417878, "tokens_prompt": 306, "prompt_eval_sec": 0.100078795, "tokens_completion": 79, "completion_eval_sec": 1.580045789, "tokens_total": 385, "tokens_per_sec": 195.50661696451996, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their SELECT and GROUP BY clauses. The Reference SQL includes 'Continent' in both SELECT and GROUP BY, while the Generated SQL omits 'Continent' entirely. Although the WHERE clause restricts to 'Oceania', the output structure differs (one includes Continent, the other doesn't), making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the average eco-friendliness score for Oceania accommodations by year. The reference query includes 'Continent' in SELECT and GROUP BY, which is redundant since the WHERE clause filters exclusively to Oceania. The generated query is more efficient by omitting unnecessary columns and grouping only by 'Visit_Year', which achieves the same result with simpler syntax. Both satisfy the business intent, but the generated query is technically superior due to its conciseness and optimized structure.", "overall_assessment": "correct"}}
{"example_id": 3056, "sql_complexity": "multiple_joins", "prompt": "Identify all suppliers who provide non-GMO ingredients to restaurants with Michelin stars.", "context": "CREATE TABLE Suppliers (id INT, name VARCHAR(50), isNonGMO BOOLEAN); CREATE TABLE Restaurants (id INT, name VARCHAR(50), numStars INT); CREATE TABLE Ingredients (supplierId INT, restaurantId INT, isNonGMO BOOLEAN);", "reference_sql": "SELECT Suppliers.name FROM Suppliers INNER JOIN Ingredients ON Suppliers.id = Ingredients.supplierId INNER JOIN Restaurants ON Ingredients.restaurantId = Restaurants.id WHERE Restaurants.numStars > 2 AND Ingredients.isNonGMO = TRUE;", "generated_sql": "SELECT DISTINCT\n  S.name\nFROM Suppliers AS S\nJOIN Ingredients AS I\n  ON S.id = I.supplierId\nJOIN Restaurants AS R\n  ON I.restaurantId = R.id\nWHERE\n  I.isNonGMO = TRUE AND R.numStars > 0;", "raw_model_output": "```sql\nSELECT DISTINCT\n  S.name\nFROM Suppliers AS S\nJOIN Ingredients AS I\n  ON S.id = I.supplierId\nJOIN Restaurants AS R\n  ON I.restaurantId = R.id\nWHERE\n  I.isNonGMO = TRUE AND R.numStars > 0;\n```", "latency_sec": 1.6510071754455566, "total_duration_sec": 1.452911086, "load_duration_sec": 0.02946589, "tokens_prompt": 149, "prompt_eval_sec": 0.042752232, "tokens_completion": 70, "completion_eval_sec": 1.379956957, "tokens_total": 219, "tokens_per_sec": 132.6463041815058, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. 1) The reference query filters for restaurants with numStars > 2, while the generated query uses numStars > 0. This would return different sets of restaurants. 2) The generated query includes a DISTINCT keyword, which would eliminate duplicate supplier names from the result set, while the reference query does not. These differences in filtering and duplicate handling make the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries differ in two key aspects. 1) The reference query incorrectly filters for restaurants with more than 2 stars (implying 3-star restaurants), while the generated query correctly filters for restaurants with more than 0 stars (any Michelin-starred restaurant). 2) The generated query uses DISTINCT to avoid duplicate supplier names, which is more appropriate for the business question of 'identifying all suppliers'. While both queries correctly join the necessary tables and filter for non-GMO ingredients, the generated query better aligns with the business intent of identifying suppliers for any Michelin-starred restaurant, not just 3-star ones. The reference query's condition is too restrictive and may exclude valid suppliers.", "overall_assessment": "differently_correct"}}
{"example_id": 264, "sql_complexity": "set operations", "prompt": "List the number of community health centers and infectious disease tracking facilities in 'southwest' regions.", "context": "CREATE TABLE centers (id INT, name TEXT, region TEXT); INSERT INTO centers (id, name, region) VALUES (1, 'Center A', 'southwest'); INSERT INTO centers (id, name, region) VALUES (2, 'Center B', 'northeast'); INSERT INTO centers (id, name, region) VALUES (3, 'Center C', 'northwest'); CREATE TABLE diseases (id INT, name TEXT, region TEXT); INSERT INTO diseases (id, name, region) VALUES (1, 'Disease A', 'southwest'); INSERT INTO diseases (id, name, region) VALUES (2, 'Disease B', 'southeast');", "reference_sql": "SELECT COUNT(*) FROM ( (SELECT * FROM centers WHERE region = 'southwest') UNION (SELECT * FROM diseases WHERE region = 'southwest') );", "generated_sql": "SELECT\n  COUNT(DISTINCT T1.id)\nFROM centers AS T1\nWHERE\n  T1.region = 'southwest';", "raw_model_output": "```sql\nSELECT\n  COUNT(DISTINCT T1.id)\nFROM centers AS T1\nWHERE\n  T1.region = 'southwest';\n```", "latency_sec": 1.0407721996307373, "total_duration_sec": 0.842761231, "load_duration_sec": 0.041682214, "tokens_prompt": 234, "prompt_eval_sec": 0.079316841, "tokens_completion": 37, "completion_eval_sec": 0.720867625, "tokens_total": 271, "tokens_per_sec": 260.38358835502135, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL combines rows from both 'centers' and 'diseases' tables where region = 'southwest' using UNION, then counts all unique rows. The Generated SQL only queries the 'centers' table and counts distinct ids. The Reference includes data from two tables, while the Generated only uses one, leading to different results. For example, the Reference would count 2 rows (Center A and Disease A), while the Generated counts 1 (Center A's id).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly combines both tables (centers and diseases) to count all facilities in the 'southwest' region, while the Generated SQL only counts centers. However, the Reference SQL's use of UNION may not be ideal for counting distinct entities. The original question asks for two separate counts (community health centers and infectious disease facilities), but neither query explicitly provides both. The Reference SQL better addresses the intent by including both tables, though it could be improved with separate aggregation.", "overall_assessment": "differently_correct"}}
{"example_id": 2838, "sql_complexity": "basic SQL", "prompt": "What is the minimum safety rating of electric vehicles in the 'green_cars' table?", "context": "CREATE TABLE green_cars (id INT, make VARCHAR(50), model VARCHAR(50), type VARCHAR(50), safety_rating INT);", "reference_sql": "SELECT MIN(safety_rating) FROM green_cars WHERE type = 'Electric';", "generated_sql": "SELECT MIN(safety_rating) FROM green_cars WHERE type = 'electric';", "raw_model_output": "```sql\nSELECT MIN(safety_rating) FROM green_cars WHERE type = 'electric';\n```", "latency_sec": 0.5682399272918701, "total_duration_sec": 0.503669715, "load_duration_sec": 0.027877171, "tokens_prompt": 130, "prompt_eval_sec": 0.037620371, "tokens_completion": 23, "completion_eval_sec": 0.437418743, "tokens_total": 153, "tokens_per_sec": 269.25246300303223, "match_exact": true, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The two queries differ in the case of the string literal in the WHERE clause ('Electric' vs 'electric'). While they may produce the same result in case-insensitive collations, they are not guaranteed to be equivalent in case-sensitive environments. Semantic equivalence requires identical logical conditions, which is not satisfied here.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in the WHERE clause condition: 'Electric' (reference) vs 'electric' (generated). While both are syntactically correct, their semantic equivalence depends on case sensitivity of the database. If the database is case-sensitive (e.g., PostgreSQL with default settings), the generated query would fail to find any records where type = 'Electric', leading to incorrect results. The reference query correctly matches the expected casing for electric vehicle types. Both queries fulfill the business intent of finding minimum safety ratings but the reference is more likely to produce accurate results in case-sensitive systems. The reference query is superior as it aligns with typical data storage conventions where vehicle types might be stored with proper capitalization.", "overall_assessment": "differently_correct"}}
{"example_id": 1187, "sql_complexity": "multiple_joins", "prompt": "Who are the top 3 authors with the highest number of articles published in The Guardian?", "context": "CREATE TABLE authors (id INT, name VARCHAR(100), publisher VARCHAR(50)); CREATE TABLE articles_authors (article_id INT, author_id INT); INSERT INTO authors (id, name, publisher) VALUES (1, 'Author1', 'The Guardian'), (2, 'Author2', 'The Guardian'), (3, 'Author3', 'The Guardian'); INSERT INTO articles_authors (article_id, author_id) VALUES (1, 1), (2, 2), (3, 1), (3, 2), (3, 3); INSERT INTO articles (id, title, publication_date, publisher) VALUES (1, 'Article1', '2021-01-01', 'The Guardian'), (2, 'Article2', '2021-01-02', 'The Guardian'), (3, 'Article3', '2021-01-03', 'The Guardian');", "reference_sql": "SELECT a.name, COUNT(aa.article_id) AS articles_count FROM authors a JOIN articles_authors aa ON a.id = aa.author_id JOIN articles ar ON aa.article_id = ar.id WHERE ar.publisher = 'The Guardian' GROUP BY a.name ORDER BY articles_count DESC LIMIT 3;", "generated_sql": "SELECT\n  A.name\nFROM authors AS A\nJOIN articles_authors AS AA\n  ON A.id = AA.author_id\nJOIN articles AS AR\n  ON AR.id = AA.article_id\nWHERE\n  AR.publisher = 'The Guardian'\nGROUP BY\n  A.name\nORDER BY\n  COUNT(AR.id) DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT\n  A.name\nFROM authors AS A\nJOIN articles_authors AS AA\n  ON A.id = AA.author_id\nJOIN articles AS AR\n  ON AR.id = AA.article_id\nWHERE\n  AR.publisher = 'The Guardian'\nGROUP BY\n  A.name\nORDER BY\n  COUNT(AR.id) DESC\nLIMIT 3;\n```", "latency_sec": 2.1164891719818115, "total_duration_sec": 1.938146419, "load_duration_sec": 0.028935025, "tokens_prompt": 307, "prompt_eval_sec": 0.100287729, "tokens_completion": 90, "completion_eval_sec": 1.808046903, "tokens_total": 397, "tokens_per_sec": 187.57478434357503, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes an 'articles_count' column in the SELECT clause, while the Generated SQL only selects the author's name. This difference in selected columns makes the result sets semantically distinct.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly identify the top 3 authors with the most articles in The Guardian. They both join the necessary tables (authors, articles_authors, articles), filter for 'The Guardian' publications, group by author, and count articles. The only difference is the column used in the COUNT function (aa.article_id vs ar.id) - since these columns are functionally equivalent in this context (each article_author record corresponds to a specific article), the results will be identical. Both queries are semantically equivalent, technically correct, and fulfill the business intent equally well.", "overall_assessment": "correct"}}
{"example_id": 360, "sql_complexity": "window functions", "prompt": "What is the change in crime rate for each category, between this year and last year, for the same time period?", "context": "CREATE TABLE CrimeStatistics (ID INT, CrimeType VARCHAR(50), Date TIMESTAMP, Count INT); INSERT INTO CrimeStatistics (ID, CrimeType, Date, Count) VALUES (1, 'Theft', '2022-01-01 00:00:00', 100), (2, 'Vandalism', '2022-01-01 00:00:00', 50), (3, 'Theft', '2022-01-02 00:00:00', 120), (4, 'Vandalism', '2022-01-02 00:00:00', 60), (5, 'Theft', '2021-01-01 00:00:00', 80), (6, 'Vandalism', '2021-01-01 00:00:00', 40), (7, 'Theft', '2021-01-02 00:00:00', 90), (8, 'Vandalism', '2021-01-02 00:00:00', 45);", "reference_sql": "SELECT CrimeType, (SUM(Count) OVER (PARTITION BY CrimeType ORDER BY EXTRACT(YEAR FROM Date) ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)) - SUM(Count) OVER (PARTITION BY CrimeType ORDER BY EXTRACT(YEAR FROM Date)) AS CrimeRateChange FROM CrimeStatistics WHERE Date BETWEEN DATE_TRUNC('year', CURRENT_DATE - INTERVAL '1 year') AND CURRENT_DATE;", "generated_sql": "SELECT\n  CrimeType,\n  SUM(CASE WHEN Date BETWEEN '2022-01-01' AND '2022-01-02' THEN Count ELSE 0 END) - SUM(CASE WHEN Date BETWEEN '2021-01-01' AND '2021-01-02' THEN Count ELSE 0 END) AS CrimeRateChange\nFROM CrimeStatistics\nGROUP BY CrimeType;", "raw_model_output": "```sql\nSELECT\n  CrimeType,\n  SUM(CASE WHEN Date BETWEEN '2022-01-01' AND '2022-01-02' THEN Count ELSE 0 END) - SUM(CASE WHEN Date BETWEEN '2021-01-01' AND '2021-01-02' THEN Count ELSE 0 END) AS CrimeRateChange\nFROM CrimeStatistics\nGROUP BY CrimeType;\n```", "latency_sec": 2.5908069610595703, "total_duration_sec": 2.294991514, "load_duration_sec": 0.028178952, "tokens_prompt": 402, "prompt_eval_sec": 0.135572272, "tokens_completion": 105, "completion_eval_sec": 2.130561383, "tokens_total": 507, "tokens_per_sec": 195.69192441595519, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses window functions to calculate the difference between the previous year's sum and the current cumulative sum, while the Generated SQL directly computes the difference between two fixed date ranges. The Reference SQL returns multiple rows per CrimeType with row-level calculations, whereas the Generated SQL aggregates results into one row per CrimeType. The logic and output structure differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL has critical flaws: 1) It uses DATE_TRUNC('year', CURRENT_DATE - INTERVAL '1 year') which captures the entire previous year, not the 'same time period' as requested. 2) The window function logic (ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING) only compares adjacent rows, not full year aggregates. 3) It doesn't properly isolate the same time period across years. The Generated SQL correctly compares specific date ranges (2021-01-01 to 2021-01-02 vs 2022-01-01 to 2022-01-02) for each crime type, directly addressing the 'same time period' requirement. While the Generated SQL hardcodes dates, this aligns with the sample data's specific time frame and clearly fulfills the business intent of comparing identical periods across years.", "overall_assessment": "differently_correct"}}
{"example_id": 335, "sql_complexity": "single join", "prompt": "List the policy numbers, claim amounts, and claim dates for policies that have more than two claims and the total claim amount exceeds $5000", "context": "CREATE TABLE policies (policy_number INT);CREATE TABLE claims (claim_id INT, policy_number INT, claim_amount DECIMAL(10,2), claim_date DATE);", "reference_sql": "SELECT p.policy_number, c.claim_amount, c.claim_date FROM policies p INNER JOIN claims c ON p.policy_number = c.policy_number GROUP BY p.policy_number, c.claim_amount, c.claim_date HAVING COUNT(c.claim_id) > 2 AND SUM(c.claim_amount) > 5000;", "generated_sql": "SELECT\n  p.policy_number,\n  c.claim_amount,\n  c.claim_date\nFROM policies AS p\nJOIN claims AS c\n  ON p.policy_number = c.policy_number\nWHERE\n  p.policy_number IN (\n    SELECT\n      policy_number\n    FROM claims\n    GROUP BY\n      policy_number\n    HAVING\n      COUNT(*) > 2\n  )\n  AND (\n    SELECT\n      SUM(claim_amount)\n    FROM claims\n    WHERE\n      policy_number = p.policy_number\n  ) > 5000;", "raw_model_output": "```sql\nSELECT\n  p.policy_number,\n  c.claim_amount,\n  c.claim_date\nFROM policies AS p\nJOIN claims AS c\n  ON p.policy_number = c.policy_number\nWHERE\n  p.policy_number IN (\n    SELECT\n      policy_number\n    FROM claims\n    GROUP BY\n      policy_number\n    HAVING\n      COUNT(*) > 2\n  )\n  AND (\n    SELECT\n      SUM(claim_amount)\n    FROM claims\n    WHERE\n      policy_number = p.policy_number\n  ) > 5000;\n```", "latency_sec": 2.955720901489258, "total_duration_sec": 2.900147886, "load_duration_sec": 0.02785046, "tokens_prompt": 148, "prompt_eval_sec": 0.042303306, "tokens_completion": 143, "completion_eval_sec": 2.829195568, "tokens_total": 291, "tokens_per_sec": 98.45313874303149, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their logic. The reference query groups by policy_number, claim_amount, and claim_date, filtering groups with >2 claims and sum >5000. The generated query filters policies with >2 claims overall and total sum >5000, then returns all claims for those policies. This leads to different result sets: the reference groups by claim details, while the generated query returns individual claims for qualifying policies.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL is technically incorrect because it groups by individual claim details (claim_amount, claim_date) rather than policy-level aggregation, making the HAVING clause impossible to satisfy (COUNT(c.claim_id) > 2 would always be 1 per group). The Generated SQL correctly identifies policies with >2 claims via a subquery and verifies the total claim amount via a correlated subquery. While the Generated SQL has potential efficiency issues due to the correlated subquery, it semantically fulfills the business intent by returning all claims for qualifying policies. The Reference SQL fails to meet the requirements due to flawed aggregation logic.", "overall_assessment": "differently_correct"}}
{"example_id": 2866, "sql_complexity": "basic SQL", "prompt": "What is the number of hospitals in 'rural_healthcare' table?", "context": "CREATE TABLE rural_healthcare (name VARCHAR(255), type VARCHAR(255), location VARCHAR(255)); INSERT INTO rural_healthcare (name, type, location) VALUES ('Rural General Hospital', 'Hospital', 'Bushland'), ('Rural Community Hospital', 'Hospital', 'Forest Region');", "reference_sql": "SELECT COUNT(*) FROM rural_healthcare WHERE type = 'Hospital';", "generated_sql": "SELECT\n  COUNT(*)\nFROM rural_healthcare\nWHERE\n  type = 'Hospital';", "raw_model_output": "```sql\nSELECT\n  COUNT(*)\nFROM rural_healthcare\nWHERE\n  type = 'Hospital';\n```", "latency_sec": 0.8711459636688232, "total_duration_sec": 0.569640051, "load_duration_sec": 0.038790152, "tokens_prompt": 158, "prompt_eval_sec": 0.047113306, "tokens_completion": 25, "completion_eval_sec": 0.482971659, "tokens_total": 183, "tokens_per_sec": 210.06812593069614, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries count the number of rows in the rural_healthcare table where the type is 'Hospital'. The generated SQL has identical logic but uses different formatting (line breaks and capitalization) which does not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are syntactically correct and semantically identical. They count rows where type = 'Hospital' in the rural_healthcare table. The only difference is formatting (line breaks), which doesn't affect execution. Both accurately answer the business question about hospital counts. Neither query is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 4440, "sql_complexity": "multiple_joins", "prompt": "What is the average session length for each game genre in the last month, sorted by average session length.", "context": "CREATE TABLE game_sessions(id INT, user_id INT, game_name VARCHAR(50), start_time DATETIME, end_time DATETIME); CREATE TABLE games(id INT, name VARCHAR(50), genre VARCHAR(50));", "reference_sql": "SELECT genres.genre, AVG(TIMESTAMPDIFF(SECOND, start_time, end_time)) as avg_session_length FROM game_sessions JOIN games ON game_sessions.game_name = games.name JOIN (SELECT DISTINCT game_name, genre FROM game_sessions JOIN games ON game_sessions.game_name = games.name) genres ON games.name = genres.game_name WHERE start_time >= DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH) GROUP BY genres.genre ORDER BY avg_session_length DESC;", "generated_sql": "SELECT\n  g.genre,\n  AVG(strftime('%s', gs.end_time) - strftime('%s', gs.start_time)) / 60\nFROM game_sessions AS gs\nJOIN games AS g\n  ON gs.game_name = g.name\nWHERE\n  gs.start_time >= strftime('%Y-%m-%d %H:%M:%S', date('now', '-1 month'))\nGROUP BY\n  g.genre\nORDER BY\n  AVG(strftime('%s', gs.end_time) - strftime('%s', gs.start_time)) / 60;", "raw_model_output": "```sql\nSELECT\n  g.genre,\n  AVG(strftime('%s', gs.end_time) - strftime('%s', gs.start_time)) / 60\nFROM game_sessions AS gs\nJOIN games AS g\n  ON gs.game_name = g.name\nWHERE\n  gs.start_time >= strftime('%Y-%m-%d %H:%M:%S', date('now', '-1 month'))\nGROUP BY\n  g.genre\nORDER BY\n  AVG(strftime('%s', gs.end_time) - strftime('%s', gs.start_time)) / 60;\n```", "latency_sec": 3.177238941192627, "total_duration_sec": 2.884481376, "load_duration_sec": 0.028659795, "tokens_prompt": 154, "prompt_eval_sec": 0.046669788, "tokens_completion": 142, "completion_eval_sec": 2.808285077, "tokens_total": 296, "tokens_per_sec": 93.16265017477461, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the calculation of average session length. The Reference SQL uses TIMESTAMPDIFF(SECOND, ...) to compute seconds, while the Generated SQL calculates seconds difference and divides by 60 to get minutes. This results in different numerical outputs (seconds vs. minutes), making the results non-equivalent. Additionally, the Reference includes a subquery with DISTINCT to deduplicate game_name/genre pairs, which the Generated SQL lacks, potentially leading to different grouping behavior if game_name/genre duplicates exist.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in critical aspects. The Reference SQL correctly calculates session length in seconds using TIMESTAMPDIFF, while the Generated SQL converts seconds to minutes (dividing by 60), which misrepresents the actual session duration. The date filtering in the Reference uses standard MySQL syntax (DATE_SUB), whereas the Generated SQL uses SQLite-specific functions (strftime/date). The Reference's subquery ensures genre uniqueness, while the Generated SQL's direct join is simpler but potentially less robust. Both handle grouping and sorting correctly, but the Generated SQL's unit conversion error prevents it from fulfilling the business intent.", "overall_assessment": "incorrect"}}
{"example_id": 451, "sql_complexity": "single join", "prompt": "Which customers have made a transaction over 500 in the \"risk_management\" category?", "context": "CREATE TABLE customers (id INT, name VARCHAR(50), category VARCHAR(50)); INSERT INTO customers (id, name, category) VALUES (1, 'John Doe', 'risk_management'); INSERT INTO customers (id, name, category) VALUES (2, 'Jane Smith', 'compliance'); INSERT INTO customers (id, name, category) VALUES (3, 'Jim Brown', 'risk_management'); CREATE TABLE transactions (id INT, customer_id INT, amount DECIMAL(10, 2)); INSERT INTO transactions (id, customer_id, amount) VALUES (1, 1, 500.00); INSERT INTO transactions (id, customer_id, amount) VALUES (2, 1, 200.00); INSERT INTO transactions (id, customer_id, amount) VALUES (3, 2, 100.00); INSERT INTO transactions (id, customer_id, amount) VALUES (4, 3, 750.00);", "reference_sql": "SELECT c.name FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE c.category = 'risk_management' AND t.amount > 500;", "generated_sql": "SELECT\n  c.name\nFROM customers AS c\nJOIN transactions AS t\n  ON c.id = t.customer_id\nWHERE\n  c.category = 'risk_management' AND t.amount > 500.00;", "raw_model_output": "```sql\nSELECT\n  c.name\nFROM customers AS c\nJOIN transactions AS t\n  ON c.id = t.customer_id\nWHERE\n  c.category = 'risk_management' AND t.amount > 500.00;\n```", "latency_sec": 1.5408921241760254, "total_duration_sec": 1.330057744, "load_duration_sec": 0.028595083, "tokens_prompt": 315, "prompt_eval_sec": 0.102040162, "tokens_completion": 60, "completion_eval_sec": 1.198109897, "tokens_total": 375, "tokens_per_sec": 243.36551152179263, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select customer names from the customers table joined with transactions on customer_id, filtering for 'risk_management' category and transactions with amount > 500. The only differences are syntax variations (e.g., 'AS' keyword usage and decimal literal formatting) that do not affect the semantic result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are syntactically correct and semantically equivalent. They join the customers and transactions tables on customer_id, filter for 'risk_management' category and transactions over 500. The reference query uses implicit JOIN syntax while the generated uses explicit JOIN, but this doesn't affect results. The amount comparison uses 500 vs 500.00 which are numerically equivalent. Both correctly identify Jim Brown (customer 3) as the only customer meeting the criteria. The queries are equally efficient and well-structured.", "overall_assessment": "correct"}}
{"example_id": 2879, "sql_complexity": "basic SQL", "prompt": "Update the FoodSafetyRecords.OrganicFarms table to include a new record for a certified organic farm in Kenya.", "context": "CREATE TABLE FoodSafetyRecords.OrganicFarms (farmName TEXT, country TEXT, certified BOOLEAN);", "reference_sql": "INSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('Ngong Organic Farm', 'Kenya', TRUE);", "generated_sql": "INSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('NewFarm', 'Kenya', TRUE);", "raw_model_output": "```sql\nINSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('NewFarm', 'Kenya', TRUE);\n```", "latency_sec": 0.9017658233642578, "total_duration_sec": 0.703912901, "load_duration_sec": 0.029512744, "tokens_prompt": 124, "prompt_eval_sec": 0.037160957, "tokens_completion": 33, "completion_eval_sec": 0.636554053, "tokens_total": 157, "tokens_per_sec": 174.10285013272417, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The two queries differ in the farmName value being inserted ('Ngong Organic Farm' vs 'NewFarm'). While the structure and other values (country 'Kenya', certified TRUE) are identical, the semantic equivalence requires identical data output. Since the farmName is different, the inserted records are not identical, making the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent because they insert different farm names ('Ngong Organic Farm' vs 'NewFarm'), resulting in distinct data records. Both fulfill the business intent of adding a certified organic farm in Kenya, but the reference query uses a specific, realistic farm name that better aligns with typical data entry practices. The generated query's generic 'NewFarm' name is technically valid but less contextually meaningful. Both queries are efficient and syntactically correct, but the reference provides more realistic data.", "overall_assessment": "differently_correct"}}
{"example_id": 5688, "sql_complexity": "single join", "prompt": "What is the total amount donated to a specific cause?", "context": "CREATE TABLE causes (id INT, name TEXT); CREATE TABLE donations (id INT, donor_id INT, cause_id INT, donation_amount DECIMAL(10,2)); INSERT INTO causes (id, name) VALUES (1, 'Cause A'), (2, 'Cause B'); INSERT INTO donations (id, donor_id, cause_id, donation_amount) VALUES (1, 1, 1, 50.00), (2, 2, 1, 100.00);", "reference_sql": "SELECT SUM(donation_amount) FROM donations JOIN causes ON donations.cause_id = causes.id WHERE causes.name = 'Cause A';", "generated_sql": "SELECT SUM(donation_amount) FROM donations WHERE cause_id = 1;", "raw_model_output": "```sql\nSELECT SUM(donation_amount) FROM donations WHERE cause_id = 1;\n```", "latency_sec": 0.8578958511352539, "total_duration_sec": 0.55231474, "load_duration_sec": 0.039025039, "tokens_prompt": 203, "prompt_eval_sec": 0.0691805, "tokens_completion": 23, "completion_eval_sec": 0.443258506, "tokens_total": 226, "tokens_per_sec": 263.4352406541355, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the total donations for 'Cause A'. The reference query uses a JOIN with the causes table to filter by name, while the generated query directly uses the known cause_id (1) for 'Cause A'. Since the data shows cause_id 1 corresponds to 'Cause A', both queries sum the same donations (50.00 + 100.00 = 150.00).", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the total donations for a specific cause. The reference query uses a JOIN to filter by cause name ('Cause A'), while the generated query directly filters by cause_id = 1. Since the context explicitly states that 'Cause A' has id 1, both produce identical results. The generated query is more efficient by avoiding a JOIN and is simpler, though it assumes prior knowledge of the cause's ID. The reference query is more readable for business users but less efficient. Both fulfill the intent of calculating the total donation amount for a specific cause.", "overall_assessment": "correct"}}
{"example_id": 3273, "sql_complexity": "multiple_joins", "prompt": "List all departments, the number of chemicals they handle, and the number of machines used in their manufacturing processes.", "context": "CREATE TABLE Departments (DepartmentID INT, DepartmentName VARCHAR(20)); INSERT INTO Departments (DepartmentID, DepartmentName) VALUES (1, 'Manufacturing'), (2, 'Engineering'), (3, 'Chemical Safety'), (4, 'Product Development'); CREATE TABLE Chemicals (ChemicalID INT, ChemicalName VARCHAR(20), DepartmentID INT); INSERT INTO Chemicals (ChemicalID, ChemicalName, DepartmentID) VALUES (1, 'Hydrochloric Acid', 1), (2, 'Nitric Acid', 2), (3, 'Sodium Hydroxide', 3), (4, 'New Chemical', 4); CREATE TABLE Machinery (MachineID INT, MachineName VARCHAR(20), DepartmentID INT); INSERT INTO Machinery (MachineID, MachineName, DepartmentID) VALUES (1, 'Mixer 1', 1), (2, 'Cutter 2', 2), (3, 'Dispenser 3', 3), (4, 'Innovator 4', 4);", "reference_sql": "SELECT D.DepartmentName, COUNT(C.ChemicalID) AS ChemicalCount, COUNT(M.MachineID) AS MachineCount FROM Departments D LEFT JOIN Chemicals C ON D.DepartmentID = C.DepartmentID LEFT JOIN Machinery M ON D.DepartmentID = M.DepartmentID GROUP BY D.DepartmentName;", "generated_sql": "SELECT\n  D.DepartmentName,\n  COUNT(C.ChemicalID) AS NumberOfChemicals,\n  COUNT(M.MachineID) AS NumberOfMachines\nFROM Departments AS D\nLEFT JOIN Chemicals AS C\n  ON D.DepartmentID = C.DepartmentID\nLEFT JOIN Machinery AS M\n  ON D.DepartmentID = M.DepartmentID\nGROUP BY\n  D.DepartmentName;", "raw_model_output": "```sql\nSELECT\n  D.DepartmentName,\n  COUNT(C.ChemicalID) AS NumberOfChemicals,\n  COUNT(M.MachineID) AS NumberOfMachines\nFROM Departments AS D\nLEFT JOIN Chemicals AS C\n  ON D.DepartmentID = C.DepartmentID\nLEFT JOIN Machinery AS M\n  ON D.DepartmentID = M.DepartmentID\nGROUP BY\n  D.DepartmentName;\n```", "latency_sec": 2.0879039764404297, "total_duration_sec": 1.997610825, "load_duration_sec": 0.028286251, "tokens_prompt": 312, "prompt_eval_sec": 0.100455175, "tokens_completion": 93, "completion_eval_sec": 1.867847582, "tokens_total": 405, "tokens_per_sec": 193.97443779501089, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. Both perform identical LEFT JOINs on DepartmentID between Departments and Chemicals/Machinery, group by DepartmentName, and count ChemicalID and MachineID. The only differences are the column aliases (ChemicalCount/MachineCount vs. NumberOfChemicals/NumberOfMachines), which do not affect the result's data or logic.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent as they produce identical results by using LEFT JOINs on DepartmentID, grouping by DepartmentName, and counting chemical/machine records. The reference and generated queries differ only in column alias names (ChemicalCount vs NumberOfChemicals, MachineCount vs NumberOfMachines) and formatting (AS keyword usage). Both correctly address the business intent by listing departments with their respective counts. The generated query uses more descriptive column names, but neither query is objectively more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 1895, "sql_complexity": "window functions", "prompt": "What is the average safety score of chemical production sites in the United States, partitioned by state and ranked in descending order?", "context": "CREATE TABLE production_sites (site_id INT, site_name TEXT, country TEXT, state TEXT, safety_score FLOAT); INSERT INTO production_sites (site_id, site_name, country, state, safety_score) VALUES (1, 'Site A', 'USA', 'NY', 92.5), (2, 'Site B', 'USA', 'CA', 87.4), (3, 'Site C', 'USA', 'TX', 95.3), (4, 'Site D', 'USA', 'FL', 89.2);", "reference_sql": "SELECT state, AVG(safety_score) as avg_safety_score, ROW_NUMBER() OVER (ORDER BY AVG(safety_score) DESC) as rank FROM production_sites WHERE country = 'USA' GROUP BY state ORDER BY rank;", "generated_sql": "SELECT\n  state,\n  AVG(safety_score) AS average_safety_score\nFROM production_sites\nWHERE\n  country = 'USA'\nGROUP BY\n  state\nORDER BY\n  average_safety_score DESC;", "raw_model_output": "```sql\nSELECT\n  state,\n  AVG(safety_score) AS average_safety_score\nFROM production_sites\nWHERE\n  country = 'USA'\nGROUP BY\n  state\nORDER BY\n  average_safety_score DESC;\n```", "latency_sec": 1.5042650699615479, "total_duration_sec": 1.224138064, "load_duration_sec": 0.028398944, "tokens_prompt": 230, "prompt_eval_sec": 0.071864531, "tokens_completion": 57, "completion_eval_sec": 1.122976765, "tokens_total": 287, "tokens_per_sec": 190.7908424725546, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a 'rank' column generated by ROW_NUMBER() and orders by this rank, while the Generated SQL orders directly by the average_safety_score. Although both group by state and calculate the same average, the Reference SQL's ordering mechanism and additional column make the result sets structurally different. The Generated SQL lacks the rank column and orders by a different expression (the average value directly vs. the row number based on that average).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL contains a critical technical error: the ROW_NUMBER() window function attempts to reference the alias 'avg_safety_score' in the ORDER BY clause, which is invalid in standard SQL (aliases cannot be used in window function ORDER BY). Additionally, the main query's ORDER BY references 'rank' which is not a column in the result set. The Generated SQL is technically correct, properly groups by state, calculates the average safety score, and sorts in descending order. However, it fails to include the requested ranking functionality. While neither query fully meets the business intent (which requires ranking), the Generated SQL is technically valid and addresses the grouping/averaging portion correctly.", "overall_assessment": "differently_correct"}}
{"example_id": 4669, "sql_complexity": "set operations", "prompt": "Identify the number of IoT devices in each country and the total number of devices.", "context": "CREATE TABLE device_country (device_id INT, country TEXT); INSERT INTO device_country (device_id, country) VALUES (1, 'USA'), (2, 'Canada'), (3, 'Mexico'), (4, 'Brazil'); CREATE TABLE device_info (device_id INT, device_type TEXT); INSERT INTO device_info (device_id, device_type) VALUES (1, 'Soil Sensor'), (2, 'Temperature Sensor'), (3, 'Humidity Sensor'), (4, 'Precision Sprayer');", "reference_sql": "SELECT country, COUNT(*) AS device_count FROM device_country GROUP BY country UNION SELECT 'Total' AS country, COUNT(*) FROM device_country;", "generated_sql": "SELECT\n  country,\n  COUNT(device_id) AS device_count\nFROM device_country\nGROUP BY\n  country;", "raw_model_output": "```sql\nSELECT\n  country,\n  COUNT(device_id) AS device_count\nFROM device_country\nGROUP BY\n  country;\n```", "latency_sec": 0.8812921047210693, "total_duration_sec": 0.779595947, "load_duration_sec": 0.029093737, "tokens_prompt": 207, "prompt_eval_sec": 0.069868348, "tokens_completion": 35, "completion_eval_sec": 0.679562957, "tokens_total": 242, "tokens_per_sec": 274.5968092799305, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a 'Total' row via UNION, while the Generated SQL only returns grouped country counts. The Generated query omits the total summary row present in the Reference query.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly addresses both parts of the business question by first grouping devices by country and then adding a 'Total' row via UNION. The generated query only provides country-level counts without the total device count. While both are technically correct in their own right, they produce different results. The reference query is more elegant in combining both requirements into a single result set, whereas the generated query fails to fulfill the full business intent of including the total number of devices.", "overall_assessment": "differently_correct"}}
{"example_id": 5302, "sql_complexity": "multiple_joins", "prompt": "Find the supplier with the lowest average delivery time for orders in the last month.", "context": "CREATE TABLE Suppliers (SupplierID int, SupplierName varchar(50)); CREATE TABLE Products (ProductID int, ProductName varchar(50), SupplierID int); CREATE TABLE Orders (OrderID int, ProductID int, OrderDate date, DeliveryTime int); INSERT INTO Suppliers VALUES (1, 'SupplierA'), (2, 'SupplierB'); INSERT INTO Products VALUES (1, 'Organic Apples', 1), (2, 'Bananas', 2); INSERT INTO Orders VALUES (1, 1, '2022-01-01', 2), (2, 2, '2022-01-03', 3);", "reference_sql": "SELECT SupplierName, AVG(DeliveryTime) as AvgDeliveryTime FROM Orders o JOIN Products p ON o.ProductID = p.ProductID JOIN Suppliers sp ON p.SupplierID = sp.SupplierID WHERE OrderDate >= DATEADD(month, -1, GETDATE()) GROUP BY SupplierName ORDER BY AvgDeliveryTime ASC;", "generated_sql": "SELECT\n  S.SupplierName\nFROM Suppliers AS S\nJOIN Products AS P\n  ON S.SupplierID = P.SupplierID\nJOIN Orders AS O\n  ON P.ProductID = O.ProductID\nWHERE\n  O.OrderDate >= date('now', '-1 month')\nGROUP BY\n  S.SupplierID\nORDER BY\n  AVG(O.DeliveryTime)\nLIMIT 1;", "raw_model_output": "```sql\nSELECT\n  S.SupplierName\nFROM Suppliers AS S\nJOIN Products AS P\n  ON S.SupplierID = P.SupplierID\nJOIN Orders AS O\n  ON P.ProductID = O.ProductID\nWHERE\n  O.OrderDate >= date('now', '-1 month')\nGROUP BY\n  S.SupplierID\nORDER BY\n  AVG(O.DeliveryTime)\nLIMIT 1;\n```", "latency_sec": 2.0525338649749756, "total_duration_sec": 1.970674435, "load_duration_sec": 0.039034193, "tokens_prompt": 235, "prompt_eval_sec": 0.07976774, "tokens_completion": 93, "completion_eval_sec": 1.851066966, "tokens_total": 328, "tokens_per_sec": 159.8024790709112, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in several key aspects.  The Reference SQL returns all suppliers with their average delivery times for orders in the last month, sorted by average delivery time. The Generated SQL only returns the supplier with the lowest average delivery time (due to the LIMIT 1 clause). Additionally, the Generated SQL groups by SupplierID (more reliable) while the Reference SQL groups by SupplierName (which could lead to incorrect groupings if multiple suppliers share the same name).  The date filtering is functionally similar but uses different syntax (DATEADD vs. date('now', '-1 month')).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries differ in technical implementation and dialect-specific functions. The Reference uses SQL Server's GETDATE() and DATEADD, while the Generated uses SQLite's date('now', '-1 month') syntax. The Reference explicitly calculates AVG(DeliveryTime) in the SELECT clause and orders by it, ensuring clarity. The Generated uses LIMIT 1 which may not handle ties correctly, whereas the Reference allows viewing all suppliers' averages. Both correctly join tables and filter by last month, but the Reference is more universally compatible and semantically explicit.", "overall_assessment": "differently_correct"}}
{"example_id": 267, "sql_complexity": "subqueries", "prompt": "What is the total number of disability support programs offered in urban and rural areas, and the percentage of total programs for each area type?", "context": "CREATE TABLE programs (program_id INT, program_name VARCHAR(255), area_type VARCHAR(255));", "reference_sql": "SELECT area_type, COUNT(*) as total_programs, ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM programs) , 2) as percentage_of_total FROM programs WHERE area_type IN ('urban', 'rural') GROUP BY area_type;", "generated_sql": "SELECT\n  area_type,\n  COUNT(program_id) AS total_programs,\n  CAST(COUNT(program_id) AS REAL) * 100 / (SELECT COUNT(*) FROM programs) AS percentage\nFROM programs\nWHERE area_type IN ('urban', 'rural')\nGROUP BY area_type;", "raw_model_output": "```sql\nSELECT\n  area_type,\n  COUNT(program_id) AS total_programs,\n  CAST(COUNT(program_id) AS REAL) * 100 / (SELECT COUNT(*) FROM programs) AS percentage\nFROM programs\nWHERE area_type IN ('urban', 'rural')\nGROUP BY area_type;\n```", "latency_sec": 1.7487030029296875, "total_duration_sec": 1.553298481, "load_duration_sec": 0.029381369, "tokens_prompt": 134, "prompt_eval_sec": 0.038093099, "tokens_completion": 76, "completion_eval_sec": 1.485085262, "tokens_total": 210, "tokens_per_sec": 120.0890029056831, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in how they calculate the percentage. The Reference SQL uses ROUND(..., 2) to limit decimal precision, while the Generated SQL does not round the result. Additionally, the Reference uses COUNT(*) while the Generated uses COUNT(program_id), but since program_id is non-nullable, this difference does not affect the result. The rounding discrepancy means the percentage values may differ in precision.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries correctly count programs by area type and calculate percentages. The key difference is in the percentage calculation: Reference uses ROUND() with 2 decimal places, while Generated uses CAST(REAL) without rounding. This makes them technically non-equivalent due to potential decimal precision differences. However, both fulfill the business intent of showing counts and percentages. The Reference query is more user-friendly for percentage presentation, making it superior for this specific question.", "overall_assessment": "differently_correct"}}
{"example_id": 3028, "sql_complexity": "basic SQL", "prompt": "What is the number of startups founded by non-binary individuals in the technology industry?", "context": "CREATE TABLE company (id INT, name TEXT, founder_gender TEXT, industry TEXT); INSERT INTO company (id, name, founder_gender, industry) VALUES (1, 'CodeForAll', 'Non-binary', 'Technology'); INSERT INTO company (id, name, founder_gender, industry) VALUES (2, 'TechVillage', 'Male', 'Technology');", "reference_sql": "SELECT COUNT(*) FROM company WHERE founder_gender = 'Non-binary' AND industry = 'Technology';", "generated_sql": "SELECT\n  COUNT(id)\nFROM company\nWHERE\n  founder_gender = 'Non-binary' AND industry = 'Technology';", "raw_model_output": "```sql\nSELECT\n  COUNT(id)\nFROM company\nWHERE\n  founder_gender = 'Non-binary' AND industry = 'Technology';\n```", "latency_sec": 0.7716059684753418, "total_duration_sec": 0.761083682, "load_duration_sec": 0.028328476, "tokens_prompt": 173, "prompt_eval_sec": 0.051777548, "tokens_completion": 35, "completion_eval_sec": 0.680098227, "tokens_total": 208, "tokens_per_sec": 269.56764008837115, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. While both filter rows where founder_gender is 'Non-binary' and industry is 'Technology', COUNT(*) counts all rows, whereas COUNT(id) only counts non-null values in the id column. If any row in the table has a NULL id (allowed by the schema), COUNT(id) would exclude it while COUNT(*) would include it. The schema does not enforce NOT NULL on id, so the results could differ in edge cases.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent as they produce identical results by counting rows where founder_gender is 'Non-binary' and industry is 'Technology'. The reference uses COUNT(*) while the generated query uses COUNT(id), but since the id column is non-nullable and unique, both aggregate functions yield the same count. Both queries correctly address the business intent by filtering the company table with the specified criteria. The reference query is more concise, while the generated query explicitly counts the primary key column. Neither query demonstrates significant efficiency differences in this context.", "overall_assessment": "correct"}}
{"example_id": 3282, "sql_complexity": "aggregation", "prompt": "Which marine species have been observed in both the Arctic and Antarctic oceans?", "context": "CREATE TABLE marine_species (id INT, species_name VARCHAR(50), common_name VARCHAR(50), region VARCHAR(20));INSERT INTO marine_species (id, species_name, common_name, region) VALUES (1, 'Orcinus_orca', 'Killer Whale', 'Arctic');INSERT INTO marine_species (id, species_name, common_name, region) VALUES (2, 'Balaenoptera_bonaerensis', 'Antarctic Minke Whale', 'Antarctic');", "reference_sql": "SELECT species_name FROM marine_species WHERE region IN ('Arctic', 'Antarctic') GROUP BY species_name HAVING COUNT(DISTINCT region) = 2;", "generated_sql": "SELECT species_name\nFROM marine_species\nWHERE region = 'Arctic'\nINTERSECT\nSELECT species_name\nFROM marine_species\nWHERE region = 'Antarctic';", "raw_model_output": "```sql\nSELECT species_name\nFROM marine_species\nWHERE region = 'Arctic'\nINTERSECT\nSELECT species_name\nFROM marine_species\nWHERE region = 'Antarctic';\n```", "latency_sec": 1.6473751068115234, "total_duration_sec": 0.964050681, "load_duration_sec": 0.035672497, "tokens_prompt": 203, "prompt_eval_sec": 0.069269916, "tokens_completion": 44, "completion_eval_sec": 0.858283098, "tokens_total": 247, "tokens_per_sec": 149.9354937310336, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve species present in both 'Arctic' and 'Antarctic' regions. The Reference SQL uses GROUP BY and HAVING to ensure a species appears in exactly two distinct regions, while the Generated SQL uses INTERSECT to find common species between the two regions. Both approaches logically identify species existing in both regions.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify species observed in both regions. The reference query uses GROUP BY and HAVING to count distinct regions, while the generated query uses INTERSECT to find common species between two subqueries. Both produce identical results. However, the generated query is more elegant and efficient, as INTERSECT explicitly expresses the intent to find intersections, avoiding the need for aggregation. The reference query requires grouping and counting, which could be less efficient on large datasets. Both fulfill the business intent, but the generated query is more direct and readable.", "overall_assessment": "correct"}}
{"example_id": 3474, "sql_complexity": "subqueries", "prompt": "What is the total transaction volume for the top 3 digital assets by market capitalization in the 'developed_markets' schema?", "context": "CREATE SCHEMA developed_markets; CREATE TABLE developed_markets.digital_assets (asset_name VARCHAR(10), market_cap BIGINT, daily_transaction_volume BIGINT); INSERT INTO developed_markets.digital_assets (asset_name, market_cap, daily_transaction_volume) VALUES ('AssetG', 30000000, 15000000), ('AssetH', 25000000, 12000000), ('AssetI', 20000000, 10000000), ('AssetJ', 15000000, 8000000), ('AssetK', 10000000, 6000000);", "reference_sql": "SELECT SUM(daily_transaction_volume) FROM (SELECT daily_transaction_volume FROM developed_markets.digital_assets ORDER BY market_cap DESC FETCH NEXT 3 ROWS ONLY) t;", "generated_sql": "SELECT SUM(daily_transaction_volume)\nFROM developed_markets.digital_assets\nORDER BY market_cap DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT SUM(daily_transaction_volume)\nFROM developed_markets.digital_assets\nORDER BY market_cap DESC\nLIMIT 3;\n```", "latency_sec": 1.4405131340026855, "total_duration_sec": 0.829819838, "load_duration_sec": 0.029246176, "tokens_prompt": 286, "prompt_eval_sec": 0.091288673, "tokens_completion": 36, "completion_eval_sec": 0.708561222, "tokens_total": 322, "tokens_per_sec": 223.53145722821276, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select the top 3 rows ordered by market_cap descending and sum their daily_transaction_volume. The Reference SQL uses a subquery with FETCH NEXT 3 ROWS ONLY, while the Generated SQL uses LIMIT 3. Both achieve the same result of summing the top 3 values in the ordered dataset.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify the top 3 digital assets by market capitalization and sum their daily transaction volumes. The reference query uses a subquery with FETCH NEXT 3 ROWS ONLY (SQL:2011 standard), while the generated query uses LIMIT 3 (common in PostgreSQL/MySQL). Both achieve the same result. However, the generated query is more concise, avoids unnecessary subquery syntax, and is generally more efficient in modern SQL implementations. The business intent of summing the top 3 assets by market cap is fully addressed by both.", "overall_assessment": "correct"}}
{"example_id": 1626, "sql_complexity": "aggregation", "prompt": "Find the total value of social impact bonds issued by each organization.", "context": "CREATE TABLE social_impact_bonds (id INT, organization_name VARCHAR(255), issue_year INT, value FLOAT); INSERT INTO social_impact_bonds (id, organization_name, issue_year, value) VALUES (1, 'Acme Corp', 2018, 2000000), (2, 'XYZ Foundation', 2019, 3000000), (3, 'Global Giving', 2018, 1500000), (4, 'Acme Corp', 2019, 2500000), (5, 'XYZ Foundation', 2018, 1000000);", "reference_sql": "SELECT organization_name, SUM(value) as total_value FROM social_impact_bonds GROUP BY organization_name;", "generated_sql": "SELECT organization_name, SUM(value) AS total_value\nFROM social_impact_bonds\nGROUP BY organization_name;", "raw_model_output": "```sql\nSELECT organization_name, SUM(value) AS total_value\nFROM social_impact_bonds\nGROUP BY organization_name;\n```", "latency_sec": 0.8904139995574951, "total_duration_sec": 0.777778622, "load_duration_sec": 0.028244953, "tokens_prompt": 256, "prompt_eval_sec": 0.081189939, "tokens_completion": 34, "completion_eval_sec": 0.667560772, "tokens_total": 290, "tokens_per_sec": 325.69119549346703, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. The only differences are formatting (line breaks and capitalization of 'AS' vs 'as'), which do not affect semantic meaning. Both group by organization_name and calculate the sum of value, producing the same result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic. They correctly aggregate the total value of social impact bonds by organization using SUM(value) with GROUP BY organization_name. The semantic meaning is identical, and both would produce the same results. The queries are equally efficient and elegantly structured for the given task.", "overall_assessment": "correct"}}
{"example_id": 1315, "sql_complexity": "single join", "prompt": "List all the transactions made by clients living in New York with a transaction amount greater than $1000.", "context": "CREATE TABLE transactions (id INT, client_id INT, transaction_amount DECIMAL(10,2), transaction_date DATE); INSERT INTO transactions (id, client_id, transaction_amount, transaction_date) VALUES (1, 3, 1500.00, '2022-01-01'), (2, 4, 800.00, '2022-01-02'), (3, 3, 1200.00, '2022-01-03'); CREATE TABLE clients (id INT, name VARCHAR(255), state VARCHAR(255)); INSERT INTO clients (id, name, state) VALUES (3, 'Mike Johnson', 'New York'), (4, 'Sara Lee', 'California');", "reference_sql": "SELECT transactions.id, transactions.client_id, transactions.transaction_amount, transactions.transaction_date FROM transactions INNER JOIN clients ON transactions.client_id = clients.id WHERE clients.state = 'New York' AND transactions.transaction_amount > 1000.00;", "generated_sql": "SELECT\n  t.transaction_amount\nFROM transactions AS t\nJOIN clients AS c\n  ON t.client_id = c.id\nWHERE\n  c.state = 'New York' AND t.transaction_amount > 1000.00;", "raw_model_output": "```sql\nSELECT\n  t.transaction_amount\nFROM transactions AS t\nJOIN clients AS c\n  ON t.client_id = c.id\nWHERE\n  c.state = 'New York' AND t.transaction_amount > 1000.00;\n```", "latency_sec": 1.6887407302856445, "total_duration_sec": 1.393752708, "load_duration_sec": 0.027944755, "tokens_prompt": 282, "prompt_eval_sec": 0.090457181, "tokens_completion": 64, "completion_eval_sec": 1.274449872, "tokens_total": 346, "tokens_per_sec": 204.88639481175736, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent because they select different columns. The Reference SQL returns all columns from transactions, while the Generated SQL only returns transaction_amount. Although both apply the same JOIN and WHERE conditions, the result sets differ in structure and content.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent because the reference query selects all transaction columns while the generated query only selects transaction_amount. The business intent requires listing 'all transactions' which implies retrieving all transaction details (id, client_id, amount, date), not just the amount. The generated query fails to fulfill the intent as it omits critical transaction fields. The reference query correctly addresses the requirement by returning complete transaction records while applying the necessary filters. Both queries are logically correct but differ in data completeness.", "overall_assessment": "differently_correct"}}
{"example_id": 520, "sql_complexity": "multiple_joins", "prompt": "What is the total number of electric vehicles sold in 'California' in the 'sales' schema?", "context": "CREATE TABLE sales_regions (id INT, name VARCHAR(50));   CREATE TABLE sales (id INT, region_id INT, vehicle_count INT);   CREATE TABLE vehicles (id INT, type VARCHAR(50));   INSERT INTO sales_regions VALUES (1, 'California');   INSERT INTO sales VALUES (1, 1, 5000);   INSERT INTO vehicles VALUES (1, 'electric');", "reference_sql": "SELECT SUM(sales.vehicle_count) FROM sales INNER JOIN sales_regions ON sales.region_id = sales_regions.id INNER JOIN vehicles ON sales.id = vehicles.id WHERE vehicles.type = 'electric' AND sales_regions.name = 'California';", "generated_sql": "SELECT\n  SUM(s.vehicle_count)\nFROM sales AS s\nJOIN sales_regions AS sr\n  ON s.region_id = sr.id\nJOIN vehicles AS v\n  ON v.id = ANY (SELECT id FROM vehicles WHERE type = 'electric')\nWHERE\n  sr.name = 'California';", "raw_model_output": "```sql\nSELECT\n  SUM(s.vehicle_count)\nFROM sales AS s\nJOIN sales_regions AS sr\n  ON s.region_id = sr.id\nJOIN vehicles AS v\n  ON v.id = ANY (SELECT id FROM vehicles WHERE type = 'electric')\nWHERE\n  sr.name = 'California';\n```", "latency_sec": 1.7103540897369385, "total_duration_sec": 1.585428662, "load_duration_sec": 0.028956416, "tokens_prompt": 188, "prompt_eval_sec": 0.056223199, "tokens_completion": 76, "completion_eval_sec": 1.499322863, "tokens_total": 264, "tokens_per_sec": 154.35400282558135, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their join condition between 'sales' and 'vehicles'. The reference query uses 'sales.id = vehicles.id' to directly link each sale to its associated vehicle. The generated query uses 'v.id = ANY (SELECT id FROM vehicles WHERE type = 'electric')', which joins every sale with all electric vehicles (creating a Cartesian product). This causes the generated query to multiply the 'vehicle_count' by the number of electric vehicles, leading to an incorrect sum. The semantic equivalence is broken due to this flawed join logic.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": false, "superiority": "reference", "explanation": "Both queries return the same result in the given context (5000) due to the specific sample data. However, the reference query uses a standard JOIN on sales.id = vehicles.id, which aligns with the schema's structure (even though it's logically flawed). The generated query uses a subquery in the ON clause (v.id = ANY(SELECT ...)) which is less efficient and introduces a logical flaw: it would multiply vehicle_count by the number of electric vehicles in a general case (e.g., 2 electric vehicles would return 10000 instead of 5000). While both queries technically produce the same result here, the reference query is more logically aligned with the schema's intended structure.", "overall_assessment": "differently_correct"}}
{"example_id": 3999, "sql_complexity": "single join", "prompt": "What is the total number of tickets sold for performances with a rating of 5?", "context": "CREATE TABLE performance (id INT PRIMARY KEY, name VARCHAR(255), date DATE, artist_id INT, rating INT); INSERT INTO performance (id, name, date, artist_id, rating) VALUES (1, 'Dance Recital', '2022-03-01', 1, 5);", "reference_sql": "SELECT SUM(t.quantity) as total_tickets_sold FROM performance p INNER JOIN ticket t ON p.id = t.performance_id WHERE p.rating = 5;", "generated_sql": "SELECT COUNT(*) AS total_tickets_sold\nFROM performance\nWHERE rating = 5;", "raw_model_output": "```sql\nSELECT COUNT(*) AS total_tickets_sold\nFROM performance\nWHERE rating = 5;\n```", "latency_sec": 0.8460280895233154, "total_duration_sec": 0.571428061, "load_duration_sec": 0.041696386, "tokens_prompt": 167, "prompt_eval_sec": 0.051555728, "tokens_completion": 25, "completion_eval_sec": 0.477331255, "tokens_total": 192, "tokens_per_sec": 226.9428194850837, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the total tickets sold (summing ticket quantities) for performances with a rating of 5, while the Generated SQL counts the number of performances with a rating of 5. They aggregate different data (sum vs. count) and rely on different tables (ticket.quantity vs. performance rows).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly joins the performance and ticket tables to sum ticket quantities for 5-rated performances, while the generated query only counts the number of 5-rated performances without considering ticket data. The original question requires aggregating ticket quantities (SUM(t.quantity)), but the generated query uses COUNT(*) which measures rows in the performance table. This results in fundamentally different metrics: the reference answers 'total tickets sold' while the generated query answers 'number of high-rated performances'.", "overall_assessment": "incorrect"}}
{"example_id": 2261, "sql_complexity": "multiple_joins", "prompt": "What is the total number of animals that have been released into 'protected' habitats, and the average weight of those animals?", "context": "CREATE TABLE habitats (habitat_id INT, habitat_name VARCHAR(50), habitat_status VARCHAR(50)); INSERT INTO habitats (habitat_id, habitat_name, habitat_status) VALUES (1, 'Habitat A', 'protected'), (2, 'Habitat B', 'unprotected'); CREATE TABLE animal_habitats (animal_id INT, habitat_id INT, animal_weight FLOAT); INSERT INTO animal_habitats (animal_id, habitat_id, animal_weight) VALUES (101, 1, 25.5), (102, 2, 15.2); CREATE TABLE animals (animal_id INT, animal_name VARCHAR(50)); INSERT INTO animals (animal_id, animal_name) VALUES (101, 'Dog'), (102, 'Cat');", "reference_sql": "SELECT COUNT(*), AVG(animal_habitats.animal_weight) FROM animal_habitats INNER JOIN animals ON animal_habitats.animal_id = animals.animal_id INNER JOIN habitats ON animal_habitats.habitat_id = habitats.habitat_id WHERE habitats.habitat_status = 'protected';", "generated_sql": "SELECT COUNT(T1.animal_id), AVG(T1.animal_weight) FROM animal_habitats AS T1 INNER JOIN habitats AS T2 ON T1.habitat_id = T2.habitat_id WHERE T2.habitat_status = 'protected';", "raw_model_output": "```sql\nSELECT COUNT(T1.animal_id), AVG(T1.animal_weight) FROM animal_habitats AS T1 INNER JOIN habitats AS T2 ON T1.habitat_id = T2.habitat_id WHERE T2.habitat_status = 'protected';\n```", "latency_sec": 1.6073169708251953, "total_duration_sec": 1.393692286, "load_duration_sec": 0.028288986, "tokens_prompt": 284, "prompt_eval_sec": 0.090852652, "tokens_completion": 64, "completion_eval_sec": 1.273597365, "tokens_total": 348, "tokens_per_sec": 216.50987721565403, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the count and average animal weight for protected habitats. The Reference SQL includes an unnecessary join with the 'animals' table (no columns from it are used), while the Generated SQL simplifies the query by omitting this join. Since both queries filter on 'habitats.habitat_status = 'protected'' and aggregate values from 'animal_habitats', they produce identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries produce identical results by counting entries in 'animal_habitats' and averaging weights for 'protected' habitats. The reference query includes an unnecessary join with the 'animals' table, which doesn't affect the result but reduces efficiency. The generated query is more efficient by directly joining 'animal_habitats' with 'habitats' and avoiding redundant table access. Both correctly address the business intent, but the generated query achieves it with simpler logic.", "overall_assessment": "correct"}}
{"example_id": 3439, "sql_complexity": "multiple_joins", "prompt": "How many menu items contain ingredients sourced from local suppliers for each restaurant?", "context": "CREATE TABLE restaurants (id INT, name VARCHAR(50), location VARCHAR(50)); INSERT INTO restaurants VALUES (1, 'Restaurant A', 'City A'); INSERT INTO restaurants VALUES (2, 'Restaurant B', 'City B'); CREATE TABLE menu_items (id INT, name VARCHAR(50), restaurant_id INT, price DECIMAL(5,2)); INSERT INTO menu_items VALUES (1, 'Item A', 1, 10.99); INSERT INTO menu_items VALUES (2, 'Item B', 1, 12.99); INSERT INTO menu_items VALUES (3, 'Item C', 2, 11.99); CREATE TABLE ingredients (id INT, name VARCHAR(50), local_source BOOLEAN, menu_item_id INT); INSERT INTO ingredients VALUES (1, 'Ingredient A', TRUE, 1); INSERT INTO ingredients VALUES (2, 'Ingredient B', FALSE, 1); INSERT INTO ingredients VALUES (3, 'Ingredient C', TRUE, 2); INSERT INTO ingredients VALUES (4, 'Ingredient D', FALSE, 2); INSERT INTO ingredients VALUES (5, 'Ingredient E', TRUE, 3);", "reference_sql": "SELECT r.name, COUNT(DISTINCT mi.id) as num_local_items FROM restaurants r JOIN menu_items mi ON r.id = mi.restaurant_id JOIN ingredients i ON mi.id = i.menu_item_id WHERE i.local_source = TRUE GROUP BY r.name;", "generated_sql": "SELECT\n  r.name AS restaurant_name,\n  COUNT(mi.id) AS menu_item_count\nFROM restaurants AS r\nJOIN menu_items AS mi\n  ON r.id = mi.restaurant_id\nJOIN ingredients AS i\n  ON mi.id = i.menu_item_id\nWHERE\n  i.local_source = TRUE\nGROUP BY\n  r.name;", "raw_model_output": "```sql\nSELECT\n  r.name AS restaurant_name,\n  COUNT(mi.id) AS menu_item_count\nFROM restaurants AS r\nJOIN menu_items AS mi\n  ON r.id = mi.restaurant_id\nJOIN ingredients AS i\n  ON mi.id = i.menu_item_id\nWHERE\n  i.local_source = TRUE\nGROUP BY\n  r.name;\n```", "latency_sec": 2.2453927993774414, "total_duration_sec": 2.045865006, "load_duration_sec": 0.027934799, "tokens_prompt": 345, "prompt_eval_sec": 0.120451396, "tokens_completion": 94, "completion_eval_sec": 1.896434959, "tokens_total": 439, "tokens_per_sec": 195.51144909777804, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses COUNT(DISTINCT mi.id) to count unique menu items, while the Generated SQL uses COUNT(mi.id) which counts all rows. If a menu item has multiple local ingredients, the Generated query would overcount ingredients instead of unique menu items. For example, a menu item with 2 local ingredients would contribute 2 to the Generated query's count but 1 to the Reference query's count.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries differ in their aggregation approach. The reference uses COUNT(DISTINCT mi.id) which correctly counts unique menu items (as required by the business question), while the generated query uses COUNT(mi.id) which would overcount menu items with multiple local ingredients. Both queries correctly join tables and filter for local ingredients, but the reference's use of DISTINCT ensures accurate item counting. The generated query technically fulfills the intent but risks overcounting in edge cases.", "overall_assessment": "differently_correct"}}
{"example_id": 2265, "sql_complexity": "aggregation", "prompt": "Hourly revenue for a specific movie?", "context": "CREATE TABLE Movie_Revenue (id INT, movie_title VARCHAR(100), revenue_time TIME, revenue DECIMAL(10,2));", "reference_sql": "SELECT revenue_time, SUM(revenue) FROM Movie_Revenue WHERE movie_title = 'Spider-Man: No Way Home' GROUP BY revenue_time;", "generated_sql": "SELECT revenue_time, SUM(revenue)\nFROM Movie_Revenue\nWHERE movie_title = 'Specific Movie Title'\nGROUP BY revenue_time\nORDER BY revenue_time;", "raw_model_output": "```sql\nSELECT revenue_time, SUM(revenue)\nFROM Movie_Revenue\nWHERE movie_title = 'Specific Movie Title'\nGROUP BY revenue_time\nORDER BY revenue_time;\n```", "latency_sec": 1.1832561492919922, "total_duration_sec": 0.918346556, "load_duration_sec": 0.028313733, "tokens_prompt": 118, "prompt_eval_sec": 0.033798398, "tokens_completion": 44, "completion_eval_sec": 0.855471163, "tokens_total": 162, "tokens_per_sec": 136.91033855766022, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the movie title condition ('Spider-Man: No Way Home' vs 'Specific Movie Title') which would filter different rows. The generated query also includes an ORDER BY clause not present in the reference, though this alone wouldn't affect semantic equivalence. However, the different WHERE condition ensures different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in two key ways: 1) The reference uses the specific movie title 'Spider-Man: No Way Home' while the generated query uses a generic placeholder 'Specific Movie Title' which doesn't identify a real movie. 2) The generated query includes an unnecessary ORDER BY clause that isn't required for the original question. While both queries correctly structure the hourly revenue calculation, the generated query fails to specify a real movie title (making it non-functional as written) and adds an irrelevant sorting step. The reference query directly addresses the business intent by targeting a specific movie with proper syntax.", "overall_assessment": "differently_correct"}}
{"example_id": 1763, "sql_complexity": "multiple_joins", "prompt": "What is the total food and beverage revenue last month for hotels in 'Bangkok'?", "context": "CREATE TABLE revenue (hotel_id INT, revenue_source VARCHAR(50), revenue INT, revenue_date DATE); INSERT INTO revenue (hotel_id, revenue_source, revenue, revenue_date) VALUES (5, 'Room revenue', 12000, '2022-03-01'), (5, 'Food and beverage', 4000, '2022-03-02'), (5, 'Other revenue', 1000, '2022-03-03'); CREATE TABLE hotels (hotel_id INT, city VARCHAR(50)); INSERT INTO hotels (hotel_id, city) VALUES (5, 'Bangkok'); CREATE TABLE dates (date DATE); INSERT INTO dates (date) VALUES ('2022-03-01'), ('2022-03-02'), ('2022-03-03');", "reference_sql": "SELECT SUM(revenue) FROM revenue JOIN hotels ON revenue.hotel_id = hotels.hotel_id JOIN dates ON revenue.revenue_date = dates.date WHERE hotels.city = 'Bangkok' AND revenue_source = 'Food and beverage' AND dates.date >= DATEADD(month, -1, GETDATE());", "generated_sql": "SELECT SUM(r.revenue)\nFROM revenue r\nJOIN hotels h ON r.hotel_id = h.hotel_id\nWHERE r.revenue_source = 'Food and beverage'\nAND h.city = 'Bangkok'\nAND r.revenue_date >= date('now', '-1 month')\nAND r.revenue_date < date('now');", "raw_model_output": "```sql\nSELECT SUM(r.revenue)\nFROM revenue r\nJOIN hotels h ON r.hotel_id = h.hotel_id\nWHERE r.revenue_source = 'Food and beverage'\nAND h.city = 'Bangkok'\nAND r.revenue_date >= date('now', '-1 month')\nAND r.revenue_date < date('now');\n```", "latency_sec": 2.0070180892944336, "total_duration_sec": 1.810241574, "load_duration_sec": 0.028589965, "tokens_prompt": 301, "prompt_eval_sec": 0.099702385, "tokens_completion": 84, "completion_eval_sec": 1.68100975, "tokens_total": 385, "tokens_per_sec": 191.82687094531698, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their date filtering logic. The Reference SQL uses `dates.date >= DATEADD(month, -1, GETDATE())` without an upper bound, while the Generated SQL adds `AND r.revenue_date < date('now')`, creating a strict upper bound. This makes the Generated SQL exclude dates equal to the current date, whereas the Reference SQL includes them if they meet the lower bound. Additionally, the Reference SQL joins with the `dates` table, which could filter results if the `dates` table doesn't contain all revenue dates, but this is not explicitly shown in the example data.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in date logic and structure. The Reference SQL incorrectly uses a dates table join and DATEADD(month, -1, GETDATE()) which may not capture the full previous month (e.g., if today is April 5, it would include March 5 - April 5 instead of full March). The Generated SQL correctly uses date('now', '-1 month') and date('now') to capture the entire previous month. The Generated SQL also avoids unnecessary joins, making it more efficient. Both fulfill the business intent, but the Generated SQL's date logic is more precise for 'last month'.", "overall_assessment": "differently_correct"}}
{"example_id": 5499, "sql_complexity": "set operations", "prompt": "How many legal aid clinics and community mediation centers are there in total, and what is the sum of cases handled by each type of center, for centers located in the state of California?", "context": "CREATE TABLE LegalAidClinics (ClinicName text, State text, NumCases int); INSERT INTO LegalAidClinics VALUES ('Clinic1', 'CA', 30, '2022-01-01'), ('Clinic2', 'CA', 25, '2022-01-01'); CREATE TABLE CommunityMediationCenters (CenterName text, State text, NumCases int); INSERT INTO CommunityMediationCenters VALUES ('CM1', 'CA', 22, '2022-01-01'), ('CM2', 'CA', 28, '2022-01-01');", "reference_sql": "SELECT State, 'Legal Aid Clinics' AS CenterType, COUNT(*) AS NumCenters, SUM(NumCases) AS TotalCases FROM LegalAidClinics WHERE State = 'CA' UNION ALL SELECT State, 'Community Mediation Centers', COUNT(*), SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA';", "generated_sql": "SELECT\n  COUNT(CASE WHEN State = 'CA' THEN 1 ELSE NULL END) AS TotalCenters,\n  SUM(CASE WHEN State = 'CA' THEN NumCases ELSE 0 END) AS TotalCases\nFROM (\n  SELECT\n    ClinicName,\n    State,\n    NumCases\n  FROM LegalAidClinics\n  UNION ALL\n  SELECT\n    CenterName,\n    State,\n    NumCases\n  FROM CommunityMediationCenters\n) AS CombinedCenters;", "raw_model_output": "```sql\nSELECT\n  COUNT(CASE WHEN State = 'CA' THEN 1 ELSE NULL END) AS TotalCenters,\n  SUM(CASE WHEN State = 'CA' THEN NumCases ELSE 0 END) AS TotalCases\nFROM (\n  SELECT\n    ClinicName,\n    State,\n    NumCases\n  FROM LegalAidClinics\n  UNION ALL\n  SELECT\n    CenterName,\n    State,\n    NumCases\n  FROM CommunityMediationCenters\n) AS CombinedCenters;\n```", "latency_sec": 2.6037991046905518, "total_duration_sec": 2.326816537, "load_duration_sec": 0.028687891, "tokens_prompt": 259, "prompt_eval_sec": 0.099553877, "tokens_completion": 110, "completion_eval_sec": 2.197588853, "tokens_total": 369, "tokens_per_sec": 141.7160023349243, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two rows (one for each center type) with State, CenterType, NumCenters, and TotalCases, while the Generated SQL returns a single row with aggregated totals for all CA centers combined. The Generated SQL lacks the CenterType column and combines both center types into one row, making the result sets structurally and semantically different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference SQL correctly separates legal aid clinics and community mediation centers into distinct rows with their respective counts and case totals, while the generated SQL combines both types into a single row without distinguishing between them. The reference query uses explicit filtering and UNION ALL to maintain type separation, directly answering the question's requirement for per-type aggregation. The generated query incorrectly aggregates all centers together, failing to meet the business intent of separating the two center types. Additionally, the generated query's subquery structure is less efficient for this specific question.", "overall_assessment": "incorrect"}}
{"example_id": 2408, "sql_complexity": "aggregation", "prompt": "What is the average number of victories for players from Japan and South Korea, partitioned by game mode?", "context": "CREATE TABLE PlayerVictories (PlayerID INT, GameMode VARCHAR(255), Victories INT, Country VARCHAR(255)); INSERT INTO PlayerVictories (PlayerID, GameMode, Victories, Country) VALUES (1, 'Battle Royale', 25, 'Japan'), (2, 'Team Deathmatch', 18, 'South Korea');", "reference_sql": "SELECT GameMode, AVG(Victories) as AvgVictories FROM PlayerVictories WHERE Country IN ('Japan', 'South Korea') GROUP BY GameMode, Country WITH ROLLUP;", "generated_sql": "SELECT\n  GameMode,\n  AVG(Victories)\nFROM PlayerVictories\nWHERE\n  Country IN ('Japan', 'South Korea')\nGROUP BY\n  GameMode;", "raw_model_output": "```sql\nSELECT\n  GameMode,\n  AVG(Victories)\nFROM PlayerVictories\nWHERE\n  Country IN ('Japan', 'South Korea')\nGROUP BY\n  GameMode;\n```", "latency_sec": 1.2706570625305176, "total_duration_sec": 0.964839077, "load_duration_sec": 0.028153997, "tokens_prompt": 177, "prompt_eval_sec": 0.052049116, "tokens_completion": 45, "completion_eval_sec": 0.883899592, "tokens_total": 222, "tokens_per_sec": 174.7127581047606, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query uses GROUP BY GameMode, Country WITH ROLLUP, which creates subtotals for each GameMode/Country combination and a grand total. The generated query only groups by GameMode, omitting Country entirely. This changes the grouping logic and eliminates the rollup summary rows, leading to different result structures and aggregate values.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL groups by both GameMode and Country (with ROLLUP), which introduces unnecessary granularity and adds a summary row not requested in the original question. The Generated SQL correctly groups only by GameMode, aligning with the requirement to partition results by game mode. While both queries filter for Japan/South Korea, the Reference's additional grouping and ROLLUP clause produce different results (e.g., per-country averages and a total row) that deviate from the business intent. The Generated SQL is more efficient and directly addresses the question.", "overall_assessment": "differently_correct"}}
{"example_id": 2729, "sql_complexity": "subqueries", "prompt": "Find the total number of trips made by shared autonomous vehicles in Seattle", "context": "CREATE TABLE shared_vehicles (id INT, vehicle_type VARCHAR(20), is_autonomous BOOLEAN, trip_count INT); INSERT INTO shared_vehicles (id, vehicle_type, is_autonomous, trip_count) VALUES (1, 'ebike', false, 1200), (2, 'escooter', false, 800), (3, 'car', true, 1500); CREATE TABLE city_data (city VARCHAR(20), has_autonomous_vehicles BOOLEAN); INSERT INTO city_data (city, has_autonomous_vehicles) VALUES ('Seattle', true), ('Denver', false), ('Portland', true);", "reference_sql": "SELECT SUM(trip_count) FROM shared_vehicles WHERE is_autonomous = true AND vehicle_type != 'ebike' AND vehicle_type != 'escooter' AND city IN (SELECT city FROM city_data WHERE has_autonomous_vehicles = true AND city = 'Seattle');", "generated_sql": "SELECT\n  SUM(T1.trip_count)\nFROM shared_vehicles AS T1\nINNER JOIN city_data AS T2\n  ON T2.city = 'Seattle'\nWHERE\n  T1.is_autonomous = TRUE;", "raw_model_output": "```sql\nSELECT\n  SUM(T1.trip_count)\nFROM shared_vehicles AS T1\nINNER JOIN city_data AS T2\n  ON T2.city = 'Seattle'\nWHERE\n  T1.is_autonomous = TRUE;\n```", "latency_sec": 1.5435731410980225, "total_duration_sec": 1.271021799, "load_duration_sec": 0.030132394, "tokens_prompt": 235, "prompt_eval_sec": 0.079610555, "tokens_completion": 59, "completion_eval_sec": 1.160453218, "tokens_total": 294, "tokens_per_sec": 190.46716489952837, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL includes conditions for vehicle_type (not 'ebike' or 'escooter') and a city filter via a subquery. The Generated SQL incorrectly joins city_data on 'Seattle' without linking it to shared_vehicles' city, and omits the vehicle_type restrictions. This causes the Generated SQL to sum all autonomous vehicles (regardless of type) instead of the specific subset in the Reference SQL.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL contains a critical error: it references a 'city' column in the shared_vehicles table, which does not exist in the schema. This makes it syntactically invalid. The Generated SQL is technically correct, as it properly joins the shared_vehicles table with city_data on a valid condition (T2.city = 'Seattle'). However, it fails to address the business intent because the shared_vehicles table lacks a city column to filter trips specifically in Seattle. While the Generated SQL correctly sums autonomous vehicles, it cannot verify if those vehicles are located in Seattle due to the schema's limitations. Neither query fully satisfies the original question, but the Generated SQL is more technically sound and closer to a valid approach.", "overall_assessment": "incorrect"}}
{"example_id": 2952, "sql_complexity": "aggregation", "prompt": "Show the total budget allocated for each program category in 2023.", "context": "CREATE TABLE Budget (id INT, category TEXT, year INT, allocated_amount INT); INSERT INTO Budget (id, category, year, allocated_amount) VALUES (1, 'Education', 2023, 30000); INSERT INTO Budget (id, category, year, allocated_amount) VALUES (2, 'Healthcare', 2023, 50000);", "reference_sql": "SELECT category, SUM(allocated_amount) FROM Budget WHERE year = 2023 GROUP BY category;", "generated_sql": "SELECT\n  category,\n  SUM(allocated_amount)\nFROM Budget\nWHERE\n  year = 2023\nGROUP BY\n  category;", "raw_model_output": "```sql\nSELECT\n  category,\n  SUM(allocated_amount)\nFROM Budget\nWHERE\n  year = 2023\nGROUP BY\n  category;\n```", "latency_sec": 1.0870749950408936, "total_duration_sec": 0.859845406, "load_duration_sec": 0.029828015, "tokens_prompt": 182, "prompt_eval_sec": 0.052725198, "tokens_completion": 40, "completion_eval_sec": 0.776468717, "tokens_total": 222, "tokens_per_sec": 204.21774119792795, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are structurally identical except for formatting differences (line breaks and spacing). Both select category and sum allocated_amount from Budget where year = 2023, grouping by category. Semantic meaning remains unchanged.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are syntactically identical in structure and logic. The Reference SQL and Generated SQL perform the same operations: filtering for year = 2023, grouping by category, and summing allocated_amount. The only difference is formatting (line breaks/indentation), which does not affect execution. Both correctly calculate total budgets per category, fully addressing the business question. While the Generated SQL is more readable, neither query is more efficient or semantically superior.", "overall_assessment": "correct"}}
{"example_id": 4328, "sql_complexity": "aggregation", "prompt": "What is the average cargo handling time in hours for each port?", "context": "CREATE TABLE cargo_handling (id INT, port_id INT, time_in_hours DECIMAL(5,2)); INSERT INTO cargo_handling (id, port_id, time_in_hours) VALUES (1, 1, 20.5), (2, 1, 22.3), (3, 2, 18.7);", "reference_sql": "SELECT port_id, AVG(time_in_hours) FROM cargo_handling GROUP BY port_id;", "generated_sql": "SELECT port_id, AVG(time_in_hours) AS average_handling_time\nFROM cargo_handling\nGROUP BY port_id;", "raw_model_output": "```sql\nSELECT port_id, AVG(time_in_hours) AS average_handling_time\nFROM cargo_handling\nGROUP BY port_id;\n```", "latency_sec": 0.9921689033508301, "total_duration_sec": 0.831833496, "load_duration_sec": 0.035025898, "tokens_prompt": 173, "prompt_eval_sec": 0.053220381, "tokens_completion": 37, "completion_eval_sec": 0.742795456, "tokens_total": 210, "tokens_per_sec": 211.6575104206266, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average time_in_hours per port_id. The generated query adds an alias (average_handling_time) for the calculated column, but this does not affect the semantic result set. The grouping and aggregation logic remain identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the average cargo handling time per port using GROUP BY port_id. The reference query omits the column alias, while the generated query adds an explicit alias (average_handling_time). This difference does not affect the results or business intent. The generated query improves readability by clarifying the meaning of the calculated column, but both are functionally identical. Neither query contains syntax errors or logical flaws.", "overall_assessment": "correct"}}
{"example_id": 4915, "sql_complexity": "window functions", "prompt": "Calculate the percentage of total Europium production for each country.", "context": "CREATE TABLE europium_production (country VARCHAR(50), quantity INT);", "reference_sql": "SELECT country, quantity * 100.0 / SUM(quantity) OVER (PARTITION BY NULL) AS percentage FROM europium_production;", "generated_sql": "SELECT\n  country,\n  (\n    quantity * 100.0 / (\n      SELECT\n        SUM(quantity)\n      FROM europium_production\n    )\n  ) AS percentage\nFROM europium_production;", "raw_model_output": "```sql\nSELECT\n  country,\n  (\n    quantity * 100.0 / (\n      SELECT\n        SUM(quantity)\n      FROM europium_production\n    )\n  ) AS percentage\nFROM europium_production;\n```", "latency_sec": 1.4673218727111816, "total_duration_sec": 1.17044546, "load_duration_sec": 0.028750357, "tokens_prompt": 108, "prompt_eval_sec": 0.03113926, "tokens_completion": 57, "completion_eval_sec": 1.109854531, "tokens_total": 165, "tokens_per_sec": 112.44976515965666, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the percentage of each country's production relative to the total production. The reference query uses a window function SUM(quantity) OVER (PARTITION BY NULL) which computes the total sum across all rows, while the generated query uses a scalar subquery (SELECT SUM(quantity) FROM europium_production) that also returns the total sum. Since both approaches compute the same denominator, the resulting percentages will be identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries correctly calculate the percentage of total Europium production per country. The reference query uses a window function (SUM(quantity) OVER (PARTITION BY NULL)) which is more efficient as it calculates the total once and reuses it for all rows. The generated query uses a scalar subquery to compute the total, which is functionally equivalent but may have slightly higher overhead due to repeated subquery execution (though modern optimizers might mitigate this). Both handle division by zero gracefully (since SUM(quantity) would be zero only if all quantities are zero). The reference query is more elegant and efficient for large datasets.", "overall_assessment": "correct"}}
{"example_id": 5030, "sql_complexity": "subqueries", "prompt": "What is the success rate of diverse-led startups (at least 1 female or underrepresented racial or ethnic group executive) in the past 3 years?", "context": "CREATE TABLE DiverseStartups(id INT, name TEXT, country TEXT, year INT, success BOOLEAN);   INSERT INTO DiverseStartups VALUES (1, 'FemTech', 'USA', 2020, true), (2, 'GreenCity', 'Canada', 2019, false), (3, 'AI-Health', 'UK', 2021, true), (4, 'SolarEnergy', 'USA', 2020, false), (5, 'DataAnalytics', 'Germany', 2019, true), (6, 'SmartGrid', 'USA', 2021, true), (7, 'CloudServices', 'India', 2020, false), (8, 'RenewableEnergy', 'USA', 2019, true);", "reference_sql": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3) AS success_rate FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3 AND success = true;", "generated_sql": "SELECT CAST(SUM(success) AS REAL) / COUNT(*)\nFROM DiverseStartups\nWHERE year >= strftime('%Y', 'now') - 3;", "raw_model_output": "```sql\nSELECT CAST(SUM(success) AS REAL) / COUNT(*)\nFROM DiverseStartups\nWHERE year >= strftime('%Y', 'now') - 3;\n```", "latency_sec": 1.073819875717163, "total_duration_sec": 0.91380925, "load_duration_sec": 0.031467239, "tokens_prompt": 287, "prompt_eval_sec": 0.092585191, "tokens_completion": 40, "completion_eval_sec": 0.788869633, "tokens_total": 327, "tokens_per_sec": 304.5203459114679, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates a percentage (multiplied by 100.0) while the Generated SQL returns a decimal ratio. The WHERE conditions are equivalent (both filter for the last 3 years), but the Generated SQL lacks the 100.0 multiplier, leading to different numerical results (e.g., 0.5 vs 50.0).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries differ in output format and technical implementation. The Reference SQL explicitly calculates a percentage (60.0% vs 0.6) by multiplying by 100.0, which aligns with the business requirement for a success rate. The Generated SQL uses a simpler approach but returns a decimal instead of a percentage. While both filter the same time frame (past 3 years), the Reference SQL's structure ensures clarity and precision for business reporting. The Generated SQL is more efficient but fails to meet the explicit percentage requirement. Both fulfill the intent of calculating success rate, but the Reference better addresses the question's phrasing.", "overall_assessment": "correct"}}
{"example_id": 4626, "sql_complexity": "aggregation", "prompt": "What was the maximum number of training hours for farmers in each country in 2020?", "context": "CREATE TABLE training (id INT, country_id INT, farmer_id INT, hours INT, date DATE);", "reference_sql": "SELECT country_id, MAX(hours) FROM training WHERE YEAR(date) = 2020 GROUP BY country_id;", "generated_sql": "SELECT\n  country_id,\n  MAX(hours) AS max_hours\nFROM training\nWHERE\n  STRFTIME('%Y', date) = '2020'\nGROUP BY\n  country_id;", "raw_model_output": "```sql\nSELECT\n  country_id,\n  MAX(hours) AS max_hours\nFROM training\nWHERE\n  STRFTIME('%Y', date) = '2020'\nGROUP BY\n  country_id;\n```", "latency_sec": 1.3125519752502441, "total_duration_sec": 1.134735156, "load_duration_sec": 0.038704838, "tokens_prompt": 123, "prompt_eval_sec": 0.036794171, "tokens_completion": 54, "completion_eval_sec": 1.058645565, "tokens_total": 177, "tokens_per_sec": 134.8518027000448, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter records to those in the year 2020. The reference uses YEAR(date) = 2020 (numeric comparison) while the generated uses STRFTIME('%Y', date) = '2020' (string comparison). Since both effectively extract the year part of the date and compare it to 2020, they produce the same filtering. The alias change (max_hours) does not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries correctly calculate the maximum training hours per country for 2020. The reference query uses standard SQL's YEAR() function, while the generated query uses SQLite-specific STRFTIME(). Both achieve the same result, but the reference is more portable across SQL dialects. The generated query includes an explicit alias (max_hours) which improves readability but isn't required for correctness. The core logic (filtering by year and grouping by country) is identical in both.", "overall_assessment": "correct"}}
{"example_id": 2703, "sql_complexity": "set operations", "prompt": "Identify the species unique to 'MarineResearchAreaA' and 'MarineResearchAreaB'", "context": "CREATE TABLE ResearchAreaSpecies (area VARCHAR(255), species VARCHAR(255)); INSERT INTO ResearchAreaSpecies (area, species) VALUES ('MarineResearchAreaA', 'Coral'), ('MarineResearchAreaA', 'Starfish'), ('MarineResearchAreaB', 'Jellyfish');", "reference_sql": "(SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB') UNION (SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA');", "generated_sql": "SELECT species\nFROM ResearchAreaSpecies\nWHERE area IN ('MarineResearchAreaA', 'MarineResearchAreaB')\nGROUP BY species\nHAVING COUNT(area) = 1;", "raw_model_output": "```sql\nSELECT species\nFROM ResearchAreaSpecies\nWHERE area IN ('MarineResearchAreaA', 'MarineResearchAreaB')\nGROUP BY species\nHAVING COUNT(area) = 1;\n```", "latency_sec": 1.0229430198669434, "total_duration_sec": 0.935627405, "load_duration_sec": 0.029830617, "tokens_prompt": 159, "prompt_eval_sec": 0.047326599, "tokens_completion": 44, "completion_eval_sec": 0.85739481, "tokens_total": 203, "tokens_per_sec": 198.44702594129308, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve species that are present in exactly one of the two research areas. The Reference SQL uses EXCEPT and UNION to compute the symmetric difference between the two areas, while the Generated SQL uses GROUP BY and HAVING to filter species appearing in only one area. With the given data, both approaches yield the same result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify species unique to each area. The Reference SQL uses EXCEPT and UNION to explicitly compute set differences, while the Generated SQL leverages GROUP BY/HAVING to find species appearing in only one area. They produce identical results: Coral (A-only), Starfish (A-only), and Jellyfish (B-only). The Generated query is more efficient as it requires a single table scan with aggregation, whereas the Reference involves multiple set operations. Both fulfill the business intent of finding area-specific species.", "overall_assessment": "correct"}}
{"example_id": 200, "sql_complexity": "window functions", "prompt": "List the top three categories of workforce development programs with the highest budget increases.", "context": "CREATE TABLE programs (program_id INT, program_name VARCHAR(50), budget DECIMAL(10, 2), category VARCHAR(50), budget_date DATE);", "reference_sql": "SELECT category, SUM(budget - LAG(budget) OVER (PARTITION BY category ORDER BY budget_date)) as total_budget_increase FROM programs GROUP BY category ORDER BY total_budget_increase DESC LIMIT 3;", "generated_sql": "SELECT category\nFROM (\n    SELECT category, (budget - LAG(budget, 1, budget) OVER (ORDER BY budget_date)) AS budget_increase\n    FROM programs\n    WHERE category LIKE '%workforce%'\n) AS subquery\nORDER BY budget_increase DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT category\nFROM (\n    SELECT category, (budget - LAG(budget, 1, budget) OVER (ORDER BY budget_date)) AS budget_increase\n    FROM programs\n    WHERE category LIKE '%workforce%'\n) AS subquery\nORDER BY budget_increase DESC\nLIMIT 3;\n```", "latency_sec": 1.7394049167633057, "total_duration_sec": 1.437062015, "load_duration_sec": 0.02915479, "tokens_prompt": 132, "prompt_eval_sec": 0.038300978, "tokens_completion": 70, "completion_eval_sec": 1.368646685, "tokens_total": 202, "tokens_per_sec": 116.1316712705876, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates the total budget increase per category by summing (budget - LAG(budget)) across all entries in each category, then groups and orders by that sum. The generated query filters for 'workforce' categories, calculates individual budget differences without grouping, and orders by single-row differences. Key differences: 1) Partitioning/ grouping 2) Filtering 3) Aggregation vs. row-level calculation.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly calculates budget increases per category using a window function with proper partitioning, then aggregates and sorts by total increase. However, it lacks a filter for 'workforce' categories. The Generated SQL incorrectly applies LAG without partitioning by category, leading to invalid budget increase calculations across different categories. While the Generated SQL includes a 'workforce' filter, its flawed calculation methodology prevents it from accurately measuring category-specific budget growth. The Reference SQL better addresses the business intent through correct aggregation, despite missing the category filter.", "overall_assessment": "differently_correct"}}
{"example_id": 5131, "sql_complexity": "basic SQL", "prompt": "How many wells were drilled in the Eagle Ford Shale and Bakken Formation?", "context": "CREATE TABLE wells (id INT, region VARCHAR(255), well_type VARCHAR(255), num_drilled INT); INSERT INTO wells (id, region, well_type, num_drilled) VALUES (1, 'Eagle Ford Shale', 'Oil', 2000), (2, 'Eagle Ford Shale', 'Gas', 1500), (3, 'Bakken Formation', 'Oil', 1000), (4, 'Bakken Formation', 'Gas', 1200);", "reference_sql": "SELECT SUM(num_drilled) as total_wells FROM wells WHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "generated_sql": "SELECT SUM(num_drilled) FROM wells WHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "raw_model_output": "```sql\nSELECT SUM(num_drilled) FROM wells WHERE region IN ('Eagle Ford Shale', 'Bakken Formation');\n```", "latency_sec": 0.7855567932128906, "total_duration_sec": 0.654786722, "load_duration_sec": 0.02355626, "tokens_prompt": 210, "prompt_eval_sec": 0.069685219, "tokens_completion": 29, "completion_eval_sec": 0.560972826, "tokens_total": 239, "tokens_per_sec": 304.2428021308315, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of num_drilled for wells in the specified regions. The only difference is the alias name (total_wells vs. no alias), which doesn't affect the result's value or structure.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent as they produce identical results by summing the 'num_drilled' column for the specified regions. The reference query includes an explicit alias ('total_wells'), while the generated query omits it. However, the original question does not require a column name, so both satisfy the business intent. Neither query is more efficient or elegant than the other, as they execute the same logic with minimal complexity. The absence of an alias in the generated query does not affect the correctness or clarity of the result for this specific question.", "overall_assessment": "correct"}}
{"example_id": 1160, "sql_complexity": "subqueries", "prompt": "What is the total revenue generated from ads on Instagram in March 2021, for users in the 'brand' category who have posted more than 10 times?", "context": "CREATE TABLE ads (ad_id INT, user_id INT, platform VARCHAR(255), ad_revenue DECIMAL(10,2), post_count INT); INSERT INTO ads (ad_id, user_id, platform, ad_revenue, post_count) VALUES (1, 1, 'Instagram', 150.50, 12), (2, 2, 'Twitter', 80.00, 15), (3, 3, 'Instagram', 120.75, 8);", "reference_sql": "SELECT SUM(ad_revenue) FROM ads WHERE platform = 'Instagram' AND MONTH(ad_date) = 3 AND YEAR(ad_date) = 2021 AND user_id IN (SELECT user_id FROM users WHERE category = 'brand' AND post_count > 10);", "generated_sql": "SELECT SUM(ad_revenue)\nFROM ads\nWHERE platform = 'Instagram'\n  AND post_count > 10;", "raw_model_output": "```sql\nSELECT SUM(ad_revenue)\nFROM ads\nWHERE platform = 'Instagram'\n  AND post_count > 10;\n```", "latency_sec": 1.0970878601074219, "total_duration_sec": 0.775447328, "load_duration_sec": 0.029754693, "tokens_prompt": 236, "prompt_eval_sec": 0.080191468, "tokens_completion": 34, "completion_eval_sec": 0.664373344, "tokens_total": 270, "tokens_per_sec": 246.10608668439994, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL includes additional conditions: filtering by ad_date (MONTH and YEAR), and a subquery joining users table with category='brand' and post_count>10. The Generated SQL omits these conditions and uses ads.post_count instead of users.post_count. These differences would produce different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL contains two critical errors: 1) It references an 'ad_date' column that doesn't exist in the ads table, and 2) It references a 'users' table that isn't part of the provided schema. The Generated SQL is syntactically valid but fails to address key requirements: it omits the date filter (March 2021), the 'brand' category filter, and the user_id subquery. While the Generated SQL is technically correct in structure, it doesn't fulfill the business intent. The Reference SQL is invalid due to schema inconsistencies. Neither query fully meets the requirements, but the Generated SQL avoids invalid column/table references.", "overall_assessment": "differently_correct"}}
{"example_id": 4708, "sql_complexity": "subqueries", "prompt": "What is the maximum number of high-level threats reported by a single agency in a month?", "context": "CREATE TABLE Threat_Intelligence (Threat_ID INT, Threat_Type VARCHAR(50), Threat_Level VARCHAR(50), Reported_Date DATE, Reporting_Agency VARCHAR(50)); CREATE VIEW High_Level_Threats AS SELECT Threat_Type, Threat_Level, Reported_Date FROM Threat_Intelligence WHERE Threat_Level = 'High';", "reference_sql": "SELECT Reporting_Agency, MAX(Number_of_High_Level_Threats) as Max_High_Level_Threats_in_a_Month FROM (SELECT Reporting_Agency, TO_CHAR(Reported_Date, 'YYYY-MM') as Month, COUNT(*) as Number_of_High_Level_Threats FROM High_Level_Threats GROUP BY Reporting_Agency, Month) GROUP BY Reporting_Agency;", "generated_sql": "SELECT\n  MAX(MonthlyThreatCount)\nFROM (\n  SELECT\n    Reporting_Agency,\n    STRFTIME('%Y-%m', Reported_Date) AS ReportingMonth,\n    COUNT(Threat_ID) AS MonthlyThreatCount\n  FROM Threat_Intelligence\n  WHERE\n    Threat_Level = 'High'\n  GROUP BY\n    Reporting_Agency,\n    STRFTIME('%Y-%m', Reported_Date)\n) AS MonthlyAgencyThreats;", "raw_model_output": "```sql\nSELECT\n  MAX(MonthlyThreatCount)\nFROM (\n  SELECT\n    Reporting_Agency,\n    STRFTIME('%Y-%m', Reported_Date) AS ReportingMonth,\n    COUNT(Threat_ID) AS MonthlyThreatCount\n  FROM Threat_Intelligence\n  WHERE\n    Threat_Level = 'High'\n  GROUP BY\n    Reporting_Agency,\n    STRFTIME('%Y-%m', Reported_Date)\n) AS MonthlyAgencyThreats;\n```", "latency_sec": 2.2884631156921387, "total_duration_sec": 2.195955191, "load_duration_sec": 0.028472115, "tokens_prompt": 172, "prompt_eval_sec": 0.051645095, "tokens_completion": 107, "completion_eval_sec": 2.114778824, "tokens_total": 279, "tokens_per_sec": 121.9158823609081, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL groups by Reporting_Agency in the outer query to find the maximum monthly count per agency, while the Generated SQL lacks a GROUP BY in the outer query, returning a single maximum value across all agencies. This structural difference changes the output format and meaning.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL calculates the maximum monthly high-threat count per agency (grouping by agency and then taking MAX), which would return multiple rows showing each agency's peak month. This does not answer the original question, which seeks the single maximum value across all agencies and months. The Generated SQL correctly computes the overall maximum by first aggregating agency-month counts and then selecting the MAX() of those values. The Generated SQL also avoids the High_Level_Threats view, directly filtering on Threat_Level='High' in the main query, making it more efficient and semantically aligned with the business intent.", "overall_assessment": "{'reference': 'incorrect', 'generated': 'correct'}"}}
{"example_id": 5608, "sql_complexity": "set operations", "prompt": "List the suppliers that provide materials for both product A and product C.", "context": "CREATE TABLE products (product_id INT, product_name TEXT); CREATE TABLE materials (material_id INT, material_name TEXT, product_id INT, supplier_id INT); INSERT INTO products (product_id, product_name) VALUES (1, 'Product A'), (2, 'Product B'), (3, 'Product C'); INSERT INTO materials (material_id, material_name, product_id, supplier_id) VALUES (1, 'Material 1', 1, 101), (2, 'Material 2', 1, 102), (3, 'Material 3', 2, 103), (4, 'Material 4', 3, 101), (5, 'Material 5', 3, 102);", "reference_sql": "SELECT supplier_id FROM materials WHERE product_id = 1 INTERSECT SELECT supplier_id FROM materials WHERE product_id = 3;", "generated_sql": "SELECT DISTINCT\n  supplier_id\nFROM materials\nWHERE\n  product_id IN (1, 3);", "raw_model_output": "```sql\nSELECT DISTINCT\n  supplier_id\nFROM materials\nWHERE\n  product_id IN (1, 3);\n```", "latency_sec": 0.8861548900604248, "total_duration_sec": 0.704380175, "load_duration_sec": 0.02883895, "tokens_prompt": 267, "prompt_eval_sec": 0.090158803, "tokens_completion": 30, "completion_eval_sec": 0.584182375, "tokens_total": 297, "tokens_per_sec": 335.1558551798414, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses INTERSECT to find supplier_ids common to both product_id=1 and product_id=3, while the Generated SQL retrieves all distinct supplier_ids for either product_id=1 or product_id=3. These are semantically different operations (intersection vs. union). Although the sample data produces the same result, the queries are not equivalent in general.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly uses INTERSECT to find suppliers present in both product_id=1 (Product A) and product_id=3 (Product C) material records. The generated query returns suppliers that provide materials for either product (1 or 3), not both. While both queries return supplier_id values, they differ fundamentally in logic: INTERSECT explicitly finds common suppliers, whereas IN with DISTINCT returns any supplier associated with either product. The reference query strictly fulfills the business intent of identifying suppliers serving both products, while the generated query fails to meet this requirement.", "overall_assessment": "incorrect"}}
{"example_id": 1506, "sql_complexity": "basic SQL", "prompt": "How many habitats are in the 'animal_habitats' table?", "context": "CREATE TABLE animal_habitats (id INT PRIMARY KEY, habitat_name VARCHAR, num_animals INT);", "reference_sql": "SELECT COUNT(*) FROM animal_habitats;", "generated_sql": "SELECT COUNT(*) FROM animal_habitats;", "raw_model_output": "```sql\nSELECT COUNT(*) FROM animal_habitats;\n```", "latency_sec": 0.9581189155578613, "total_duration_sec": 0.345779203, "load_duration_sec": 0.029742854, "tokens_prompt": 116, "prompt_eval_sec": 0.033519134, "tokens_completion": 15, "completion_eval_sec": 0.281782462, "tokens_total": 131, "tokens_per_sec": 136.7262433429004, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical: they select the count of all rows from the 'animal_habitats' table. Since the schema and data remain unchanged, they will produce the same result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in syntax, logic, and result. They both correctly count all rows in the 'animal_habitats' table, which directly answers the question about the number of habitats. Since the queries are exactly the same, neither is more efficient or elegant than the other. The business intent is fully satisfied as the count of habitats is accurately retrieved.", "overall_assessment": "correct"}}
{"example_id": 3117, "sql_complexity": "aggregation", "prompt": "What is the percentage of the population that has access to clean water in each continent?", "context": "CREATE TABLE water_data (id INT, country VARCHAR(50), continent CHAR(2), access_to_clean_water BOOLEAN); INSERT INTO water_data VALUES (1, 'Canada', 'NA', true), (2, 'Mexico', 'NA', false), (3, 'Brazil', 'SA', true), (4, 'Russia', 'EU', true);", "reference_sql": "SELECT continent, COUNT(*) FILTER (WHERE access_to_clean_water) * 100.0 / COUNT(*) AS percentage FROM water_data GROUP BY continent;", "generated_sql": "SELECT\n  continent,\n  CAST(SUM(access_to_clean_water) AS REAL) * 100 / COUNT(country) AS percentage\nFROM water_data\nGROUP BY continent;", "raw_model_output": "```sql\nSELECT\n  continent,\n  CAST(SUM(access_to_clean_water) AS REAL) * 100 / COUNT(country) AS percentage\nFROM water_data\nGROUP BY continent;\n```", "latency_sec": 1.25606107711792, "total_duration_sec": 1.056716459, "load_duration_sec": 0.028859989, "tokens_prompt": 177, "prompt_eval_sec": 0.051705828, "tokens_completion": 50, "completion_eval_sec": 0.97526824, "tokens_total": 227, "tokens_per_sec": 180.72369579420467, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the percentage of countries with access to clean water per continent. The reference uses COUNT(*) FILTER (WHERE ...) while the generated query uses SUM(boolean) to count true values. Since SUM(access_to_clean_water) effectively counts true values (1s) and COUNT(country) equals COUNT(*), the results are mathematically equivalent. The cast to REAL and 100.0/100 ensure floating-point division in both cases.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the percentage of populations with access to clean water per continent. The reference query uses PostgreSQL's COUNT(*) FILTER syntax, while the generated query uses SUM(access_to_clean_water) with explicit type casting. Both approaches accurately count true values (1s) and compute the ratio. The calculations are mathematically equivalent, and both handle division correctly (via 100.0/REAL conversion). The reference query is more concise but less portable, while the generated query uses standard SQL. However, since the question doesn't specify database compatibility requirements, both are equally valid.", "overall_assessment": "correct"}}
{"example_id": 3542, "sql_complexity": "window functions", "prompt": "What is the average yield of crops for each country, ranked by average yield?", "context": "CREATE TABLE farming (id INT, name TEXT, country TEXT, crop TEXT, yield INT); INSERT INTO farming VALUES (1, 'Smith Farm', 'USA', 'Corn', 120), (2, 'Brown Farm', 'Canada', 'Soybeans', 45), (3, 'Jones Farm', 'Mexico', 'Wheat', 80);", "reference_sql": "SELECT country, AVG(yield) as avg_yield, ROW_NUMBER() OVER (ORDER BY AVG(yield) DESC) as rank FROM farming GROUP BY country;", "generated_sql": "SELECT country, AVG(yield) AS average_yield\nFROM farming\nGROUP BY country\nORDER BY average_yield DESC;", "raw_model_output": "```sql\nSELECT country, AVG(yield) AS average_yield\nFROM farming\nGROUP BY country\nORDER BY average_yield DESC;\n```", "latency_sec": 0.9317996501922607, "total_duration_sec": 0.70591009, "load_duration_sec": 0.03467105, "tokens_prompt": 172, "prompt_eval_sec": 0.051629524, "tokens_completion": 32, "completion_eval_sec": 0.618785107, "tokens_total": 204, "tokens_per_sec": 218.9311832837758, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a ROW_NUMBER() column that ranks countries by their average yield, while the Generated SQL only returns country and average_yield without the rank. The Generated SQL also lacks the explicit ORDER BY clause present in the Reference SQL, though it implicitly orders results similarly. However, the additional 'rank' column in the Reference SQL makes the result sets structurally different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The Reference SQL correctly addresses the ranking requirement by using ROW_NUMBER() to assign ranks based on average yield, while the Generated SQL only calculates averages and sorts them without explicit ranking. The Reference query produces three columns (country, avg_yield, rank) whereas the Generated query only returns two columns (country, average_yield). The original question explicitly asks for 'ranked by average yield,' which requires a ranking column that the Generated SQL lacks. Both queries are technically correct in calculating averages, but the Reference query better fulfills the business intent by including the requested ranking.", "overall_assessment": "differently_correct"}}
{"example_id": 2274, "sql_complexity": "subqueries", "prompt": "Add a new crop 'amaranth' to farm 'Nourishing Harvest' with yield 50 in 2023", "context": "CREATE TABLE farms (id INT, name TEXT, location TEXT, size FLOAT); INSERT INTO farms (id, name, location, size) VALUES (1, 'Nourishing Harvest', 'Mexico', 120.0); CREATE TABLE crops (id INT, farm_id INT, crop TEXT, yield INT, year INT);", "reference_sql": "INSERT INTO crops (id, farm_id, crop, yield, year) VALUES (5, (SELECT id FROM farms WHERE name = 'Nourishing Harvest'), 'amaranth', 50, 2023);", "generated_sql": "INSERT INTO crops (farm_id, crop, yield, year)\nSELECT id, 'amaranth', 50, 2023\nFROM farms\nWHERE name = 'Nourishing Harvest';", "raw_model_output": "```sql\nINSERT INTO crops (farm_id, crop, yield, year)\nSELECT id, 'amaranth', 50, 2023\nFROM farms\nWHERE name = 'Nourishing Harvest';\n```", "latency_sec": 1.220984935760498, "total_duration_sec": 1.061713155, "load_duration_sec": 0.030974868, "tokens_prompt": 176, "prompt_eval_sec": 0.051586848, "tokens_completion": 50, "completion_eval_sec": 0.978409733, "tokens_total": 226, "tokens_per_sec": 185.09646874491085, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL explicitly sets the 'id' column to 5, while the Generated SQL omits the 'id' column entirely. The Generated SQL also uses a SELECT statement that could insert multiple rows if multiple farms had the same name, though in this specific case only one row would be inserted. However, the explicit value assignment in the Reference SQL vs. the dynamic selection in the Generated SQL makes them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because the reference query explicitly specifies an id value (5) while the generated query omits it. The reference query's hardcoded id could be problematic if the crops table uses auto-incrementing ids or requires specific id management. Both correctly identify the farm via a subquery/selection, but the generated query is more robust as it relies on the database to handle id generation (assuming it's auto-incremented). The generated query better fulfills the business intent by avoiding arbitrary id assignment and focusing on the required data fields (farm_id, crop, yield, year).", "overall_assessment": "differently_correct"}}
{"example_id": 3705, "sql_complexity": "subqueries", "prompt": "What is the percentage of unions with collective bargaining agreements in the Midwest region?", "context": "CREATE TABLE collective_bargaining (bargaining_id INT, union_name VARCHAR(50), contract_start_date DATE, contract_end_date DATE, region VARCHAR(50));CREATE VIEW union_region AS SELECT DISTINCT union_name, region FROM collective_bargaining;", "reference_sql": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM union_region) as percentage FROM union_region ur WHERE ur.region = 'Midwest' AND EXISTS (SELECT 1 FROM collective_bargaining cb WHERE cb.union_name = ur.union_name);", "generated_sql": "SELECT\n  CAST(SUM(CASE WHEN region = 'Midwest' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*)\nFROM collective_bargaining;", "raw_model_output": "```sql\nSELECT\n  CAST(SUM(CASE WHEN region = 'Midwest' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*)\nFROM collective_bargaining;\n```", "latency_sec": 1.100590705871582, "total_duration_sec": 0.992550702, "load_duration_sec": 0.027890068, "tokens_prompt": 155, "prompt_eval_sec": 0.046506285, "tokens_completion": 47, "completion_eval_sec": 0.917436624, "tokens_total": 202, "tokens_per_sec": 183.53780285654125, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their approach and data handling. The reference query counts distinct union-region pairs from a view, filtering for 'Midwest' and ensuring existence in collective_bargaining. The generated query aggregates all rows from collective_bargaining, counting Midwest entries directly. The reference query uses a subquery with EXISTS to validate union existence, while the generated query lacks this check. Additionally, the reference query calculates a percentage based on distinct pairs, whereas the generated query uses total rows, leading to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly calculates the percentage of distinct unions in the Midwest by using the union_region view (which ensures uniqueness) and explicitly checks for existence in collective_bargaining. The generated query counts all rows in collective_bargaining, which may include multiple entries for the same union, leading to overcounting. Additionally, the generated query doesn't properly handle distinct union names, violating the business requirement to count unions rather than agreements. While both queries address the Midwest region, the reference query's use of DISTINCT and existence check aligns with the intent to measure unions, not contracts.", "overall_assessment": "differently_correct"}}
{"example_id": 240, "sql_complexity": "aggregation", "prompt": "What is the average capacity of renewable energy projects for each country?", "context": "CREATE TABLE projects (name TEXT, type TEXT, capacity INTEGER, country TEXT); INSERT INTO projects (name, type, capacity, country) VALUES ('Project 1', 'Wind', 100, 'USA'), ('Project 2', 'Solar', 200, 'Germany'), ('Project 3', 'Wind', 300, 'France');", "reference_sql": "SELECT country, AVG(capacity) FROM projects GROUP BY country", "generated_sql": "SELECT country, AVG(capacity) FROM projects WHERE type IN ('Wind', 'Solar') GROUP BY country;", "raw_model_output": "```sql\nSELECT country, AVG(capacity) FROM projects WHERE type IN ('Wind', 'Solar') GROUP BY country;\n```", "latency_sec": 0.8332881927490234, "total_duration_sec": 0.632873986, "load_duration_sec": 0.039738612, "tokens_prompt": 170, "prompt_eval_sec": 0.05129969, "tokens_completion": 28, "completion_eval_sec": 0.540718523, "tokens_total": 198, "tokens_per_sec": 237.61287118061358, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "In the given context, all projects in the table are either 'Wind' or 'Solar' types. The WHERE clause in the generated query does not exclude any rows from the sample data, so both queries group by country and calculate the same average capacity values. However, this equivalence is data-dependent and would not hold if other project types existed.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries calculate the average capacity per country, and in the given context (where all projects are renewable), they produce identical results. However, the generated query explicitly filters for 'Wind' and 'Solar' projects, which aligns more precisely with the business intent of focusing on renewable energy projects. The reference query might include non-renewable projects if they existed in the dataset, making the generated query more semantically accurate for the question's context.", "overall_assessment": "differently_correct"}}
{"example_id": 2132, "sql_complexity": "set operations", "prompt": "What is the average caseload per attorney in community legal clinics in California, and how does it compare to the state average?", "context": "CREATE TABLE cali_community_legal_clinics(id INT, attorney_count INT, cases_handled INT, state VARCHAR(255));", "reference_sql": "SELECT state, AVG(cases_handled/attorney_count) AS avg_caseload FROM cali_community_legal_clinics WHERE state = 'California' GROUP BY state UNION ALL SELECT 'California', AVG(cases_handled/attorney_count) FROM cali_community_legal_clinics WHERE state = 'California';", "generated_sql": "SELECT\n  AVG(cases_handled * 1.0 / attorney_count) AS average_caseload_per_attorney,\n  AVG(AVG(cases_handled * 1.0 / attorney_count) ) OVER () AS state_average_caseload_per_attorney\nFROM cali_community_legal_clinics\nWHERE state = 'California';", "raw_model_output": "```sql\nSELECT\n  AVG(cases_handled * 1.0 / attorney_count) AS average_caseload_per_attorney,\n  AVG(AVG(cases_handled * 1.0 / attorney_count) ) OVER () AS state_average_caseload_per_attorney\nFROM cali_community_legal_clinics\nWHERE state = 'California';\n```", "latency_sec": 1.8869531154632568, "total_duration_sec": 1.790934275, "load_duration_sec": 0.039864184, "tokens_prompt": 136, "prompt_eval_sec": 0.041840516, "tokens_completion": 87, "completion_eval_sec": 1.708371624, "tokens_total": 223, "tokens_per_sec": 118.17993683709112, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in structure and calculation. The Reference SQL returns two rows with state and average caseload, while the Generated SQL returns one row with two columns (average and windowed average). Additionally, the Reference uses integer division (cases_handled/attorney_count) whereas the Generated uses float division (cases_handled * 1.0 / attorney_count). The output formats and calculation methods make them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL is technically flawed. It calculates the California average twice via a redundant UNION ALL, producing two identical rows. The Generated SQL correctly computes the California average and uses a window function to derive the 'state average' (which, in this context, is the same as the California average since the table contains only California clinics). While both queries technically return the same numerical value, the Generated SQL is more efficient, avoids redundancy, and better structures the comparison. However, neither query truly compares to an external 'state average' if the table contains only California data. The Generated SQL's use of a window function is more elegant and avoids the redundancy of the Reference SQL.", "overall_assessment": "differently_correct"}}
{"example_id": 3276, "sql_complexity": "basic SQL", "prompt": "What is the total energy consumption of the Chemical Plant B in the last quarter?", "context": "CREATE TABLE EnergyConsumption (EnergyID INT, Plant VARCHAR(255), EnergyQuantity DECIMAL(5,2), Timestamp DATETIME);", "reference_sql": "SELECT SUM(EnergyQuantity) FROM EnergyConsumption WHERE Plant = 'Chemical Plant B' AND Timestamp BETWEEN DATE_SUB(CURRENT_DATE(), INTERVAL 3 MONTH) AND CURRENT_DATE();", "generated_sql": "SELECT SUM(EnergyQuantity)\nFROM EnergyConsumption\nWHERE Plant = 'Chemical Plant B'\nAND Timestamp >= DATE('now', '-3 months');", "raw_model_output": "```sql\nSELECT SUM(EnergyQuantity)\nFROM EnergyConsumption\nWHERE Plant = 'Chemical Plant B'\nAND Timestamp >= DATE('now', '-3 months');\n```", "latency_sec": 0.8832921981811523, "total_duration_sec": 0.781252463, "load_duration_sec": 0.029207685, "tokens_prompt": 124, "prompt_eval_sec": 0.037804098, "tokens_completion": 37, "completion_eval_sec": 0.713391948, "tokens_total": 161, "tokens_per_sec": 182.2726390332963, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query uses BETWEEN with CURRENT_DATE() as the upper bound, which includes records up to the start of the current day (midnight). The generated query uses a single >= condition with DATE('now', '-3 months'), which includes all records from three months ago up to the current moment (including the entire current day). This makes the generated query's upper bound more inclusive than the reference query's, leading to potential differences in results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the total energy consumption for 'Chemical Plant B' over the last quarter. The reference query uses MySQL-specific DATE_SUB and BETWEEN, while the generated query uses SQLite-style DATE('now', '-3 months') with a single >= condition. Semantically, both date ranges are equivalent (three months from current date to now). The generated query is slightly more concise but lacks an explicit upper bound, which is implicitly handled by the current date in both cases. Neither query has logical errors, and both meet the business intent of aggregating energy usage for the specified plant and time frame.", "overall_assessment": "correct"}}
{"example_id": 3074, "sql_complexity": "multiple_joins", "prompt": "Find the top 5 players with the highest scores in the 'historical_tournaments' view, including their scores and the names of the tournaments they participated in.", "context": "CREATE VIEW historical_tournaments AS SELECT tournaments.tournament_name, players.player_name, players.score FROM tournaments JOIN players_scores ON tournaments.tournament_id = players_scores.tournament_id JOIN players ON players_scores.player_id = players.player_id;  CREATE TABLE tournaments (tournament_id INT, tournament_name TEXT);  CREATE TABLE players_scores (player_id INT, tournament_id INT, score INT);  CREATE TABLE players (player_id INT, player_name TEXT);", "reference_sql": "SELECT players.player_name, MAX(players_scores.score) as high_score, tournaments.tournament_name FROM historical_tournaments JOIN players ON historical_tournaments.player_id = players.player_id JOIN players_scores ON historical_tournaments.player_id = players_scores.player_id JOIN tournaments ON players_scores.tournament_id = tournaments.tournament_id GROUP BY players.player_id, tournaments.tournament_name ORDER BY high_score DESC LIMIT 5;", "generated_sql": "SELECT player_name, score, tournament_name\nFROM historical_tournaments\nORDER BY score DESC\nLIMIT 5;", "raw_model_output": "```sql\nSELECT player_name, score, tournament_name\nFROM historical_tournaments\nORDER BY score DESC\nLIMIT 5;\n```", "latency_sec": 0.8833787441253662, "total_duration_sec": 0.724648257, "load_duration_sec": 0.030493004, "tokens_prompt": 223, "prompt_eval_sec": 0.071036916, "tokens_completion": 32, "completion_eval_sec": 0.622246711, "tokens_total": 255, "tokens_per_sec": 288.6644054951488, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references 'player_id' in joins, but the historical_tournaments view does not include a 'player_id' column. The view only contains 'tournament_name', 'player_name', and 'score'. This makes the Reference SQL invalid, as it attempts to join on a non-existent column. The Generated SQL is valid and selects directly from the view, but the two queries cannot be semantically equivalent due to this structural discrepancy.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL contains unnecessary joins and incorrect grouping logic. It joins the historical_tournaments view with tables it already contains, and groups by player_id and tournament_name which would split players across tournaments rather than aggregating their highest scores. The Generated SQL directly selects from the view, orders by score, and limits 5 results - this correctly retrieves the top 5 scores with associated tournament names. While both queries return player names, scores, and tournament names, the Generated SQL is simpler, avoids redundant operations, and directly addresses the business intent of finding top scores without overcomplicating the logic.", "overall_assessment": "differently_correct"}}
{"example_id": 2219, "sql_complexity": "window functions", "prompt": "What is the average population of cities with a UNESCO World Heritage designation, ordered by designation date?", "context": "CREATE TABLE cities (name VARCHAR(255), population INT, designation_date DATE); INSERT INTO cities (name, population, designation_date) VALUES ('Paris', 2141000, '1991-09-16'); INSERT INTO cities (name, population, designation_date) VALUES ('Rio de Janeiro', 6727000, '2012-07-01');", "reference_sql": "SELECT AVG(population) FROM (SELECT population, ROW_NUMBER() OVER (ORDER BY designation_date) rn FROM cities WHERE name IN (SELECT name FROM heritagesites)) t WHERE rn % 2 = 1;", "generated_sql": "SELECT AVG(population)\nFROM cities\nWHERE designation_date IS NOT NULL\nORDER BY designation_date;", "raw_model_output": "```sql\nSELECT AVG(population)\nFROM cities\nWHERE designation_date IS NOT NULL\nORDER BY designation_date;\n```", "latency_sec": 0.8348240852355957, "total_duration_sec": 0.644984344, "load_duration_sec": 0.028357447, "tokens_prompt": 194, "prompt_eval_sec": 0.059579817, "tokens_completion": 29, "completion_eval_sec": 0.556366615, "tokens_total": 223, "tokens_per_sec": 267.1221445857868, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates the average of populations from cities in heritagesites, ordered by designation_date with row numbering, and selects only odd-numbered rows. The generated query averages all cities with non-null designation dates without filtering by heritagesites or using row numbering. Differences in filtering conditions (heritagesites vs. designation_date IS NOT NULL) and processing logic (row numbering vs. simple ordering) lead to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference SQL is invalid due to referencing a non-existent 'heritagesites' table and includes unnecessary ROW_NUMBER() logic that doesn't align with the original question. The generated SQL correctly filters cities with non-null designation dates (assuming this indicates UNESCO designation) but includes an unnecessary ORDER BY clause that doesn't affect the average calculation. While the generated query's WHERE condition may not perfectly capture UNESCO designation (if 'designation_date' isn't explicitly tied to UNESCO), it's the only query that addresses the core requirement of filtering by designation. The reference query fails due to schema inconsistencies and incorrect logic.", "overall_assessment": "differently_correct"}}
{"example_id": 3786, "sql_complexity": "aggregation", "prompt": "Display the names and average co-owner percentages for all properties in the 'property_coownership' table where the co-owner percentage is greater than 60.", "context": "CREATE TABLE property_coownership (property_id INT, owner VARCHAR(255), percentage INT); INSERT INTO property_coownership (property_id, owner, percentage) VALUES (1, 'Mohammed', 70), (1, 'Fatima', 30), (2, 'Jamal', 65), (2, 'Aisha', 35), (3, 'Ali', 75), (3, 'Khadija', 25);", "reference_sql": "SELECT owner, AVG(percentage) FROM property_coownership WHERE percentage > 60 GROUP BY owner;", "generated_sql": "SELECT owner, AVG(percentage) AS average_percentage\nFROM property_coownership\nWHERE percentage > 60\nGROUP BY owner;", "raw_model_output": "```sql\nSELECT owner, AVG(percentage) AS average_percentage\nFROM property_coownership\nWHERE percentage > 60\nGROUP BY owner;\n```", "latency_sec": 0.8084690570831299, "total_duration_sec": 0.780077595, "load_duration_sec": 0.029153783, "tokens_prompt": 217, "prompt_eval_sec": 0.070763045, "tokens_completion": 35, "completion_eval_sec": 0.678821235, "tokens_total": 252, "tokens_per_sec": 311.70024108181593, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (owner and AVG(percentage)), apply identical WHERE and GROUP BY clauses. The only difference is the alias name for the aggregated column (missing in Reference vs. 'average_percentage' in Generated), which does not affect the semantic result set content.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries are technically equivalent as they produce identical results (both select owner and average percentage with the same filtering and grouping). However, they do not fully fulfill the business intent. The original question asks for 'average co-owner percentages for all properties' where co-owner percentages exceed 60. The current queries group by 'owner' instead of 'property_id', which would aggregate percentages across different properties for the same owner. This would incorrectly calculate averages for owners across multiple properties rather than per property. The generated query improves readability with an alias ('average_percentage') but does not address the grouping logic. To fulfill the intent, the GROUP BY clause should reference 'property_id' instead of 'owner'.", "overall_assessment": "differently_correct"}}
{"example_id": 2357, "sql_complexity": "basic SQL", "prompt": "What is the total amount of climate finance invested in renewable energy projects by public and private sectors in Africa?", "context": "CREATE TABLE renewable_energy_projects (project_id INT, sector TEXT, investor_type TEXT, region TEXT, amount FLOAT); INSERT INTO renewable_energy_projects (project_id, sector, investor_type, region, amount) VALUES (1, 'Renewable Energy', 'Public', 'Africa', 5000000); INSERT INTO renewable_energy_projects (project_id, sector, investor_type, region, amount) VALUES (2, 'Renewable Energy', 'Private', 'Africa', 7000000);", "reference_sql": "SELECT SUM(amount) FROM renewable_energy_projects WHERE sector = 'Renewable Energy' AND region = 'Africa';", "generated_sql": "SELECT SUM(amount) FROM renewable_energy_projects WHERE sector = 'Renewable Energy' AND region = 'Africa';", "raw_model_output": "```sql\nSELECT SUM(amount) FROM renewable_energy_projects WHERE sector = 'Renewable Energy' AND region = 'Africa';\n```", "latency_sec": 0.8031911849975586, "total_duration_sec": 0.706403608, "load_duration_sec": 0.028688073, "tokens_prompt": 220, "prompt_eval_sec": 0.070678336, "tokens_completion": 31, "completion_eval_sec": 0.606111765, "tokens_total": 251, "tokens_per_sec": 312.50342967940185, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They select the sum of the 'amount' column from the 'renewable_energy_projects' table where 'sector' is 'Renewable Energy' and 'region' is 'Africa'. Since the SQL statements are exactly the same, they will produce the same result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": false, "superiority": "equal", "explanation": "The Reference and Generated SQL queries are technically identical, both summing the 'amount' column where 'sector' is 'Renewable Energy' and 'region' is 'Africa'. However, they do not explicitly filter for 'investor_type' as required by the original question, which specifies 'public and private sectors'. While the sample data contains only public and private investors, the queries lack the explicit condition (e.g., `investor_type IN ('Public', 'Private')`) to ensure this requirement is met in all cases. This omission means the queries may include non-target investor types in broader datasets, failing to fully fulfill the business intent.", "overall_assessment": "differently_correct"}}
{"example_id": 1009, "sql_complexity": "multiple_joins", "prompt": "Find the number of IoT sensors installed in each farm that use Sprinkler irrigation.", "context": "CREATE TABLE IoT_Sensors (id INT, sensor_type VARCHAR(50), Farm_id INT); INSERT INTO IoT_Sensors (id, sensor_type, Farm_id) VALUES (1, 'Soil Moisture', 1), (2, 'Temperature', 1), (3, 'Humidity', 2); CREATE TABLE Irrigation (id INT, Farm_id INT, irrigation_type VARCHAR(50), duration INT); INSERT INTO Irrigation (id, Farm_id, irrigation_type, duration) VALUES (1, 1, 'Sprinkler', 30), (2, 2, 'Drip', 45);", "reference_sql": "SELECT f.id, COUNT(s.id) FROM Farmers f JOIN Irrigation i ON f.id = i.Farm_id JOIN IoT_Sensors s ON f.id = s.Farm_id WHERE i.irrigation_type = 'Sprinkler' GROUP BY f.id;", "generated_sql": "SELECT\n  COUNT(T1.id)\nFROM IoT_Sensors AS T1\nINNER JOIN Irrigation AS T2\n  ON T1.Farm_id = T2.Farm_id\nWHERE\n  T2.irrigation_type = 'Sprinkler';", "raw_model_output": "```sql\nSELECT\n  COUNT(T1.id)\nFROM IoT_Sensors AS T1\nINNER JOIN Irrigation AS T2\n  ON T1.Farm_id = T2.Farm_id\nWHERE\n  T2.irrigation_type = 'Sprinkler';\n```", "latency_sec": 1.5746791362762451, "total_duration_sec": 1.372096793, "load_duration_sec": 0.02776625, "tokens_prompt": 233, "prompt_eval_sec": 0.079381167, "tokens_completion": 64, "completion_eval_sec": 1.264016298, "tokens_total": 297, "tokens_per_sec": 188.60985273630845, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL groups results by Farmer.id and counts IoT_Sensors per farmer where irrigation_type is 'Sprinkler', while the Generated SQL performs a non-grouped count of all matching IoT_Sensors/Irrigation pairs. The Generated SQL lacks the Farmers table join and GROUP BY clause, leading to a different result structure (single value vs multiple rows).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query attempts to answer the question by joining IoT_Sensors with Irrigation via a Farmers table, but the context does not include a 'Farmers' table, making it invalid. The generated query lacks a GROUP BY clause, so it returns a single total count instead of per-farm counts. While the reference query's structure aligns with the business intent (grouping by farm), its use of a non-existent table makes it technically incorrect. The generated query fails to fulfill the intent entirely due to missing grouping.", "overall_assessment": "differently_correct"}}
{"example_id": 4217, "sql_complexity": "subqueries", "prompt": "Show consumer preference data for foundations, excluding products from the USA.", "context": "CREATE TABLE cosmetics (product_id INT, product_name VARCHAR(100), product_type VARCHAR(50), is_cruelty_free BOOLEAN, consumer_preference_score INT); INSERT INTO cosmetics (product_id, product_name, product_type, is_cruelty_free, consumer_preference_score) VALUES (1, 'Lipstick A', 'Lipstick', TRUE, 80), (2, 'Foundation B', 'Foundation', FALSE, 90), (3, 'Mascara C', 'Mascara', TRUE, 85), (4, 'Eyeshadow D', 'Eyeshadow', TRUE, 70), (5, 'Blush E', 'Blush', FALSE, 95); CREATE TABLE ingredient_sourcing (ingredient_id INT, ingredient_name VARCHAR(100), sourcing_country VARCHAR(50), is_organic BOOLEAN); INSERT INTO ingredient_sourcing (ingredient_id, ingredient_name, sourcing_country, is_organic) VALUES (1, 'Rosehip Oil', 'Chile', TRUE), (2, 'Shea Butter', 'Ghana', TRUE), (3, 'Jojoba Oil', 'India', TRUE), (4, 'Coconut Oil', 'Philippines', FALSE), (5, 'Aloe Vera', 'USA', TRUE);", "reference_sql": "SELECT * FROM cosmetics WHERE product_type = 'Foundation' AND product_id NOT IN (SELECT cosmetics.product_id FROM cosmetics INNER JOIN ingredient_sourcing ON cosmetics.product_id = ingredient_sourcing.ingredient_id WHERE ingredient_sourcing.sourcing_country = 'USA');", "generated_sql": "SELECT\n  cosmetics.consumer_preference_score\nFROM cosmetics\nWHERE\n  product_type = 'Foundation'\n  AND cosmetics.product_id NOT IN (\n    SELECT\n      cosmetics.product_id\n    FROM cosmetics\n    JOIN ingredient_sourcing\n      ON TRUE\n    WHERE\n      ingredient_sourcing.sourcing_country = 'USA'\n  );", "raw_model_output": "```sql\nSELECT\n  cosmetics.consumer_preference_score\nFROM cosmetics\nWHERE\n  product_type = 'Foundation'\n  AND cosmetics.product_id NOT IN (\n    SELECT\n      cosmetics.product_id\n    FROM cosmetics\n    JOIN ingredient_sourcing\n      ON TRUE\n    WHERE\n      ingredient_sourcing.sourcing_country = 'USA'\n  );\n```", "latency_sec": 2.2413880825042725, "total_duration_sec": 1.963555676, "load_duration_sec": 0.028878974, "tokens_prompt": 377, "prompt_eval_sec": 0.132418923, "tokens_completion": 89, "completion_eval_sec": 1.801209312, "tokens_total": 466, "tokens_per_sec": 207.90687861574804, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL correctly joins cosmetics.product_id with ingredient_sourcing.ingredient_id, filtering for USA-sourced ingredients. The Generated SQL uses a Cartesian join (ON TRUE), which incorrectly includes all products if any ingredient is from USA. This leads to different subquery results, causing the NOT IN clause to exclude different sets of products.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent. The Reference SQL correctly uses a JOIN between cosmetics and ingredient_sourcing on product_id = ingredient_id (though this is logically flawed given the schema). The Generated SQL incorrectly uses a Cartesian product (ON TRUE) which would return all combinations of cosmetics and ingredients, leading to incorrect results. Both queries fail to properly link products to their ingredients (no explicit product-ingredient relationship exists in the schema), but the Reference SQL's structure is more logically aligned with the intent. The Generated SQL's subquery would incorrectly include all products if any ingredient is from the USA due to the flawed join. Neither query fully addresses the business intent due to schema limitations, but the Reference SQL's approach is more structured.", "overall_assessment": "incorrect"}}
{"example_id": 5620, "sql_complexity": "basic SQL", "prompt": "What is the recycling rate of plastic in the residential sector in the state of New York?", "context": "CREATE TABLE recycling_rates_city (sector VARCHAR(20), city VARCHAR(20), material VARCHAR(20), recycling_rate DECIMAL(5,2)); INSERT INTO recycling_rates_city (sector, city, material, recycling_rate) VALUES ('residential', 'New York City', 'plastic', 0.25), ('commercial', 'New York City', 'plastic', 0.30), ('residential', 'New York City', 'paper', 0.45), ('commercial', 'New York City', 'paper', 0.50), ('residential', 'Los Angeles', 'plastic', 0.20), ('commercial', 'Los Angeles', 'plastic', 0.35), ('residential', 'Los Angeles', 'paper', 0.40), ('commercial', 'Los Angeles', 'paper', 0.50);", "reference_sql": "SELECT recycling_rate FROM recycling_rates_city WHERE sector = 'residential' AND material = 'plastic' AND city = 'New York City';", "generated_sql": "SELECT\n  recycling_rate\nFROM recycling_rates_city\nWHERE\n  sector = 'residential' AND material = 'plastic' AND city = 'New York City';", "raw_model_output": "```sql\nSELECT\n  recycling_rate\nFROM recycling_rates_city\nWHERE\n  sector = 'residential' AND material = 'plastic' AND city = 'New York City';\n```", "latency_sec": 1.6023001670837402, "total_duration_sec": 0.971979197, "load_duration_sec": 0.028390961, "tokens_prompt": 284, "prompt_eval_sec": 0.091567618, "tokens_completion": 43, "completion_eval_sec": 0.851015476, "tokens_total": 327, "tokens_per_sec": 204.08161137195347, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the same column ('recycling_rate') from the same table ('recycling_rates_city') with identical WHERE conditions (sector = 'residential', material = 'plastic', city = 'New York City'). The structure and logic are identical, so they will produce the same result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are syntactically identical in structure and logic, with the generated SQL merely using whitespace for formatting. They both correctly filter for 'residential' sector, 'plastic' material, and 'New York City' as required by the question. The result would be the same (0.25) from the sample data. Neither query is more efficient or elegant than the other, as they perform the same operation with equivalent conditions.", "overall_assessment": "correct"}}
{"example_id": 3151, "sql_complexity": "basic SQL", "prompt": "List all biotech startups that received funding in 2022 and their respective funding amounts.", "context": "CREATE TABLE biotech_startups (name TEXT, funding FLOAT, date DATE); INSERT INTO biotech_startups (name, funding, date) VALUES ('StartupA', 3500000, '2022-02-28'); INSERT INTO biotech_startups (name, funding, date) VALUES ('StartupB', 4500000, '2022-07-12');", "reference_sql": "SELECT name, funding FROM biotech_startups WHERE date BETWEEN '2022-01-01' AND '2022-12-31';", "generated_sql": "SELECT\n  name,\n  funding\nFROM biotech_startups\nWHERE\n  STRFTIME('%Y', date) = '2022';", "raw_model_output": "```sql\nSELECT\n  name,\n  funding\nFROM biotech_startups\nWHERE\n  STRFTIME('%Y', date) = '2022';\n```", "latency_sec": 1.0736441612243652, "total_duration_sec": 0.856966897, "load_duration_sec": 0.038589971, "tokens_prompt": 193, "prompt_eval_sec": 0.056842688, "tokens_completion": 39, "completion_eval_sec": 0.760724749, "tokens_total": 232, "tokens_per_sec": 216.0864915759717, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select startups with dates in 2022. The reference query uses BETWEEN '2022-01-01' AND '2022-12-31' which includes all dates in that year. The generated query uses STRFTIME('%Y', date) = '2022' which also captures all dates in 2022. Since the date column is of type DATE (without time components), both approaches yield identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries are technically correct and produce the same results for the given schema. The reference query uses a date range (BETWEEN '2022-01-01' AND '2022-12-31') which is semantically precise for DATE-typed values. The generated query uses STRFTIME('%Y', date) = '2022' which also correctly isolates 2022 entries. However, the reference query is more efficient as it allows potential index usage on the date column, while the generated query applies a function to the date column (which may prevent index utilization). The reference query also uses standard SQL syntax rather than SQLite-specific STRFTIME function. Both fulfill the business intent of identifying 2022 funding events.", "overall_assessment": "correct"}}
{"example_id": 2136, "sql_complexity": "window functions", "prompt": "What is the total military equipment sales revenue for each sales representative by fiscal year?", "context": "CREATE TABLE SalesReps (SalesRepID INT, SalesRepName VARCHAR(50), FiscalYear INT, Revenue DECIMAL(10,2)); INSERT INTO SalesReps (SalesRepID, SalesRepName, FiscalYear, Revenue) VALUES (1, 'John Doe', 2020, 150000.00), (2, 'Jane Smith', 2020, 200000.00), (1, 'John Doe', 2021, 180000.00), (2, 'Jane Smith', 2021, 250000.00);", "reference_sql": "SELECT SalesRepName, FiscalYear, SUM(Revenue) OVER (PARTITION BY SalesRepName ORDER BY FiscalYear) AS TotalRevenue FROM SalesReps;", "generated_sql": "SELECT\n  SalesRepName,\n  FiscalYear,\n  SUM(Revenue) AS TotalRevenue\nFROM SalesReps\nGROUP BY\n  SalesRepName,\n  FiscalYear;", "raw_model_output": "```sql\nSELECT\n  SalesRepName,\n  FiscalYear,\n  SUM(Revenue) AS TotalRevenue\nFROM SalesReps\nGROUP BY\n  SalesRepName,\n  FiscalYear;\n```", "latency_sec": 1.256465196609497, "total_duration_sec": 0.972774615, "load_duration_sec": 0.029598964, "tokens_prompt": 241, "prompt_eval_sec": 0.079848298, "tokens_completion": 44, "completion_eval_sec": 0.862403343, "tokens_total": 285, "tokens_per_sec": 226.82681603044557, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates a cumulative running total of Revenue for each SalesRepName ordered by FiscalYear using a window function, while the Generated SQL aggregates Revenue per SalesRepName and FiscalYear. The Reference query shows progressive sums (e.g., 2020: 150000, 2021: 150000+180000=330000), whereas the Generated query returns individual year totals (e.g., 2020: 150000, 2021: 180000).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL uses a window function to create a running total per sales representative ordered by fiscal year, which does not align with the requirement for 'total revenue for each sales representative by fiscal year.' The Generated SQL correctly groups by SalesRepName and FiscalYear, then aggregates Revenue with SUM, which accurately computes the total revenue per sales rep per fiscal year. While both queries are syntactically valid, their semantic outputs differ: the Reference provides cumulative sums while the Generated delivers per-group totals. The Generated SQL directly addresses the business intent of isolating annual revenue per representative.", "overall_assessment": "incorrect"}}
{"example_id": 5452, "sql_complexity": "basic SQL", "prompt": "What is the name of the farms with a size greater than 150 acres located in 'Texas'?", "context": "CREATE TABLE farms (id INT PRIMARY KEY, name VARCHAR(50), size INT, location VARCHAR(50)); INSERT INTO farms (id, name, size, location) VALUES (1, 'Smith Farms', 200, 'Texas'), (2, 'Johnson Farms', 100, 'California');", "reference_sql": "SELECT name FROM farms WHERE size > 150 AND location = 'Texas'", "generated_sql": "SELECT name FROM farms WHERE size > 150 AND location = 'Texas';", "raw_model_output": "```sql\nSELECT name FROM farms WHERE size > 150 AND location = 'Texas';\n```", "latency_sec": 0.8193991184234619, "total_duration_sec": 0.519261791, "load_duration_sec": 0.029390088, "tokens_prompt": 169, "prompt_eval_sec": 0.051307615, "tokens_completion": 23, "completion_eval_sec": 0.437800255, "tokens_total": 192, "tokens_per_sec": 234.31804560567667, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. The only difference is the presence of a trailing semicolon in the generated SQL, which does not affect the query's semantics as semicolons are statement terminators in SQL and not part of the query logic itself.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are syntactically identical except for a single whitespace character after the semicolon in the generated query, which has no impact on SQL execution. They both select farm names with size > 150 and location 'Texas' from the farms table. The queries correctly address the business question by filtering for Texas farms exceeding 150 acres. Both are equally efficient and elegant, with no performance differences. The minor formatting difference does not affect functionality or business intent fulfillment.", "overall_assessment": "correct"}}
{"example_id": 5152, "sql_complexity": "aggregation", "prompt": "How many international tourists visited Portugal in 2020, broken down by continent?", "context": "CREATE TABLE international_tourists(tourist_id INT, country TEXT, arrival_year INT, continent TEXT);INSERT INTO international_tourists (tourist_id, country, arrival_year, continent) VALUES (1, 'Spain', 2020, 'Europe'), (2, 'France', 2020, 'Europe'), (3, 'Brazil', 2020, 'South America'), (4, 'United States', 2020, 'North America'), (5, 'China', 2020, 'Asia');", "reference_sql": "SELECT continent, COUNT(*) FROM international_tourists WHERE arrival_year = 2020 GROUP BY continent;", "generated_sql": "SELECT\n  continent,\n  COUNT(tourist_id)\nFROM international_tourists\nWHERE\n  country = 'Portugal' AND arrival_year = 2020\nGROUP BY\n  continent;", "raw_model_output": "```sql\nSELECT\n  continent,\n  COUNT(tourist_id)\nFROM international_tourists\nWHERE\n  country = 'Portugal' AND arrival_year = 2020\nGROUP BY\n  continent;\n```", "latency_sec": 1.2856829166412354, "total_duration_sec": 1.124546691, "load_duration_sec": 0.02878677, "tokens_prompt": 221, "prompt_eval_sec": 0.070515106, "tokens_completion": 52, "completion_eval_sec": 1.024152485, "tokens_total": 273, "tokens_per_sec": 212.3385140040556, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL counts all tourists from 2020 grouped by continent, while the Generated SQL only includes tourists from 'Portugal' (which doesn't exist in the data) and would return no results. The WHERE clause in the Generated SQL drastically changes the filtering criteria, making the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly counts all international tourists in 2020 by continent, aligning with the question's requirement to analyze tourists visiting Portugal (assuming the table represents arrivals in Portugal). The Generated SQL incorrectly filters for tourists from 'Portugal' (country = 'Portugal'), which would count domestic tourists rather than international visitors. The Reference SQL does not filter by country, which is appropriate if the table already represents tourists arriving in Portugal. The Generated SQL fails to address the actual question by misinterpreting the 'country' column's meaning.", "overall_assessment": "incorrect"}}
{"example_id": 2477, "sql_complexity": "set operations", "prompt": "What is the carbon price in Europe and Australia for the last quarter of 2020?", "context": "CREATE TABLE CarbonPrices (Country TEXT, Year INT, Quarter INT, CarbonPrice NUMBER); INSERT INTO CarbonPrices (Country, Year, Quarter, CarbonPrice) VALUES ('Europe', 2020, 4, 25), ('Australia', 2020, 4, 15); CREATE TABLE CarbonTaxes (Country TEXT, Year INT, Quarter INT, CarbonPrice NUMBER); INSERT INTO CarbonTaxes (Country, Year, Quarter, CarbonPrice) VALUES ('Europe', 2019, 4, 20), ('Australia', 2019, 4, 10);", "reference_sql": "SELECT Context.Country, Context.CarbonPrice FROM ( SELECT * FROM CarbonPrices WHERE CarbonPrices.Country IN ('Europe', 'Australia') AND CarbonPrices.Year = 2020 AND CarbonPrices.Quarter = 4 UNION SELECT * FROM CarbonTaxes WHERE CarbonTaxes.Country IN ('Europe', 'Australia') AND CarbonTaxes.Year = 2020 AND CarbonTaxes.Quarter = 4 ) AS Context;", "generated_sql": "SELECT\n  Country,\n  CarbonPrice\nFROM CarbonPrices\nWHERE\n  Year = 2020 AND Quarter = 4 AND Country IN ('Europe', 'Australia');", "raw_model_output": "```sql\nSELECT\n  Country,\n  CarbonPrice\nFROM CarbonPrices\nWHERE\n  Year = 2020 AND Quarter = 4 AND Country IN ('Europe', 'Australia');\n```", "latency_sec": 1.170992136001587, "total_duration_sec": 0.969538585, "load_duration_sec": 0.028577146, "tokens_prompt": 232, "prompt_eval_sec": 0.079177236, "tokens_completion": 44, "completion_eval_sec": 0.861041631, "tokens_total": 276, "tokens_per_sec": 235.69756919326227, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL combines data from both CarbonPrices and CarbonTaxes tables using a UNION, while the Generated SQL only queries the CarbonPrices table. Although in the provided sample data the CarbonTaxes table has no matching entries for 2020 Q4, the queries would produce different results if CarbonTaxes had entries for 2020 Q4. The Generated SQL explicitly excludes the CarbonTaxes table, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries return the same results because the CarbonTaxes table has no 2020 Q4 data (the generated query correctly filters CarbonPrices, while the reference query's CarbonTaxes subquery returns no rows). However, the generated query is more efficient and directly addresses the business intent by focusing on the CarbonPrices table, which aligns with the question's focus on 'carbon price' rather than 'carbon tax'. The reference query's union with CarbonTaxes is unnecessary and could be misleading if users assume tax data is relevant.", "overall_assessment": "correct"}}
{"example_id": 4573, "sql_complexity": "subqueries", "prompt": "Find the names of all the indigenous communities in the 'Arctic_Communities' table that have a population size greater than the average population size in the 'Antarctic_Communities' table.", "context": "CREATE TABLE Arctic_Communities (name TEXT, population INTEGER); CREATE TABLE Antarctic_Communities (name TEXT, population INTEGER);", "reference_sql": "SELECT name FROM Arctic_Communities WHERE Arctic_Communities.population > (SELECT AVG(population) FROM Antarctic_Communities)", "generated_sql": "SELECT name\nFROM Arctic_Communities\nWHERE population > (SELECT AVG(population) FROM Antarctic_Communities);", "raw_model_output": "```sql\nSELECT name\nFROM Arctic_Communities\nWHERE population > (SELECT AVG(population) FROM Antarctic_Communities);\n```", "latency_sec": 0.8091661930084229, "total_duration_sec": 0.61113297, "load_duration_sec": 0.028311458, "tokens_prompt": 141, "prompt_eval_sec": 0.041583785, "tokens_completion": 28, "completion_eval_sec": 0.54038326, "tokens_total": 169, "tokens_per_sec": 208.85697086734422, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select names from Arctic_Communities where population exceeds the average population of Antarctic_Communities. The generated query omits the table alias in the WHERE clause, but since the FROM clause specifies Arctic_Communities, the population column is unambiguously referenced from that table. The subquery structure and logic remain identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically correct and semantically equivalent. The reference query explicitly qualifies the 'population' column with the table name 'Arctic_Communities', while the generated query relies on implicit table qualification since the main query is from Arctic_Communities. Both correctly calculate the average population from Antarctic_Communities and compare it to Arctic_Communities' population. The business intent of identifying Arctic communities with population above the Antarctic average is fully satisfied by both. The queries are equally efficient and elegant, with only minor stylistic differences.", "overall_assessment": "correct"}}
{"example_id": 3596, "sql_complexity": "window functions", "prompt": "What is the total revenue for each game in the \"Gaming\" category?", "context": "CREATE TABLE Games (GameID int, GameName varchar(50), Category varchar(50), Revenue decimal(10,2));", "reference_sql": "SELECT Category, SUM(Revenue) OVER(PARTITION BY Category) as TotalRevenue FROM Games;", "generated_sql": "SELECT\n  GameName,\n  SUM(Revenue)\nFROM Games\nWHERE\n  Category = 'Gaming'\nGROUP BY\n  GameName;", "raw_model_output": "```sql\nSELECT\n  GameName,\n  SUM(Revenue)\nFROM Games\nWHERE\n  Category = 'Gaming'\nGROUP BY\n  GameName;\n```", "latency_sec": 1.0025560855865479, "total_duration_sec": 0.804245179, "load_duration_sec": 0.028691217, "tokens_prompt": 124, "prompt_eval_sec": 0.037045282, "tokens_completion": 38, "completion_eval_sec": 0.737853541, "tokens_total": 162, "tokens_per_sec": 161.58696987532772, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates the total revenue per category for each row using a window function, while the generated query filters to only 'Gaming' category, groups by GameName, and sums revenue per game. The output structure, filtering, and aggregation logic differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL calculates total revenue per category (not per game) using a window function, which would show the same category total for every row. The Generated SQL correctly groups by GameName and filters for 'Gaming' to get each game's revenue. While both are syntactically valid, only the Generated SQL addresses the business intent of aggregating revenue per game within the specified category. The Reference SQL's approach would produce incorrect results for the question asked.", "overall_assessment": "incorrect"}}
{"example_id": 5039, "sql_complexity": "subqueries", "prompt": "What is the total number of community policing events in 'City Park' in 2021?", "context": "CREATE TABLE locations (id INT, name VARCHAR(255)); CREATE TABLE community_policing (id INT, location_id INT, year INT, events INT); INSERT INTO locations (id, name) VALUES (1, 'City Park'); INSERT INTO community_policing (id, location_id, year, events) VALUES (1, 1, 2021, 5);", "reference_sql": "SELECT SUM(events) FROM community_policing WHERE location_id = (SELECT id FROM locations WHERE name = 'City Park') AND year = 2021;", "generated_sql": "SELECT\n  SUM(T1.events)\nFROM community_policing AS T1\nINNER JOIN locations AS T2\n  ON T1.location_id = T2.id\nWHERE\n  T2.name = 'City Park' AND T1.year = 2021;", "raw_model_output": "```sql\nSELECT\n  SUM(T1.events)\nFROM community_policing AS T1\nINNER JOIN locations AS T2\n  ON T1.location_id = T2.id\nWHERE\n  T2.name = 'City Park' AND T1.year = 2021;\n```", "latency_sec": 1.676651954650879, "total_duration_sec": 1.477697213, "load_duration_sec": 0.027774123, "tokens_prompt": 185, "prompt_eval_sec": 0.055986476, "tokens_completion": 71, "completion_eval_sec": 1.393113427, "tokens_total": 256, "tokens_per_sec": 152.68523636636658, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of events for 'City Park' in 2021. The reference query uses a subquery to get the location ID, while the generated query uses an INNER JOIN. Since there's a one-to-one relationship between location names and IDs in the sample data, both approaches yield the same result. The JOIN version is more robust for multiple matching locations but behaves identically in this specific case.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries correctly calculate the total community policing events in 'City Park' for 2021. The reference query uses a subquery to directly obtain the location_id, which is efficient and concise. The generated query uses an explicit JOIN, which is also valid but slightly more verbose. Since the location name 'City Park' is unique (as implied by the schema and sample data), both approaches yield identical results. The reference query is more efficient due to its direct approach, avoiding unnecessary table joining.", "overall_assessment": "correct"}}
{"example_id": 2724, "sql_complexity": "basic SQL", "prompt": "What is the earliest installation date for solar panels in Italy?", "context": "CREATE TABLE solar_panels_italy (id INT, installation_date DATE); INSERT INTO solar_panels_italy (id, installation_date) VALUES (1, '2018-01-01'), (2, '2019-01-01'), (3, '2020-01-01');", "reference_sql": "SELECT MIN(installation_date) as earliest_date FROM solar_panels_italy;", "generated_sql": "SELECT MIN(installation_date) FROM solar_panels_italy;", "raw_model_output": "```sql\nSELECT MIN(installation_date) FROM solar_panels_italy;\n```", "latency_sec": 0.783257246017456, "total_duration_sec": 0.482492541, "load_duration_sec": 0.028893651, "tokens_prompt": 170, "prompt_eval_sec": 0.051209744, "tokens_completion": 21, "completion_eval_sec": 0.401765379, "tokens_total": 191, "tokens_per_sec": 243.85347339096725, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the minimum installation_date from the solar_panels_italy table. The only difference is the column alias ('earliest_date' vs. no alias), which does not affect the actual data returned. The result set's values remain identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly retrieve the earliest installation date using MIN(installation_date). The reference query adds an alias ('earliest_date') which improves readability but doesn't affect functionality. The generated query is syntactically valid and produces identical results. Neither query contains errors, and both address the business intent of finding the minimum installation date. The difference is purely stylistic, with no impact on correctness or efficiency.", "overall_assessment": "correct"}}
{"example_id": 2200, "sql_complexity": "single join", "prompt": "Which diversity programs are currently being participated in by employees in the HR department?", "context": "CREATE TABLE Employees (Employee_ID INT, First_Name VARCHAR(20), Last_Name VARCHAR(20), Department VARCHAR(20), Salary DECIMAL(10,2), Date_Hired DATE); CREATE TABLE Diversity_Programs (Program_ID INT, Program_Name VARCHAR(50), Participant_ID INT, Date_Started DATE, Date_Ended DATE);", "reference_sql": "SELECT dp.Program_Name FROM Diversity_Programs dp JOIN Employees e ON dp.Participant_ID = e.Employee_ID WHERE e.Department = 'HR' AND dp.Date_Ended IS NULL;", "generated_sql": "SELECT\n  Diversity_Programs.Program_Name\nFROM Diversity_Programs\nJOIN Employees\n  ON Diversity_Programs.Participant_ID = Employees.Employee_ID\nWHERE\n  Employees.Department = 'HR' AND Diversity_Programs.Date_Ended IS NULL;", "raw_model_output": "```sql\nSELECT\n  Diversity_Programs.Program_Name\nFROM Diversity_Programs\nJOIN Employees\n  ON Diversity_Programs.Participant_ID = Employees.Employee_ID\nWHERE\n  Employees.Department = 'HR' AND Diversity_Programs.Date_Ended IS NULL;\n```", "latency_sec": 1.5016210079193115, "total_duration_sec": 1.301349498, "load_duration_sec": 0.030826388, "tokens_prompt": 174, "prompt_eval_sec": 0.051979102, "tokens_completion": 62, "completion_eval_sec": 1.217930997, "tokens_total": 236, "tokens_per_sec": 157.16349115747138, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between Diversity_Programs and Employees on Participant_ID = Employee_ID, filter for HR department employees with unended diversity programs, and select Program_Name. The only differences are table alias usage and formatting, which do not affect semantic meaning.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are structurally identical in logic, syntax, and result set. They correctly join the Employees and Diversity_Programs tables on Employee_ID/Participant_ID, filter for HR department employees, and identify active programs (Date_Ended IS NULL). The only difference is the use of table aliases ('dp' and 'e') in the reference query, which does not affect functionality. Neither query has efficiency issues, and both precisely address the business intent of identifying current HR employee participation in diversity programs.", "overall_assessment": "correct"}}
{"example_id": 4359, "sql_complexity": "window functions", "prompt": "Which destinations have the least hotel awards?", "context": "CREATE TABLE Destinations (destination_id INT, destination_name TEXT, country TEXT, awards INT); INSERT INTO Destinations (destination_id, destination_name, country, awards) VALUES (1, 'City A', 'Germany', 3), (2, 'City B', 'Switzerland', 5), (3, 'City C', 'Norway', 2);", "reference_sql": "SELECT destination_name, country, awards, RANK() OVER (PARTITION BY country ORDER BY awards ASC) AS rank FROM Destinations;", "generated_sql": "SELECT destination_name FROM Destinations ORDER BY awards ASC LIMIT 1;", "raw_model_output": "```sql\nSELECT destination_name FROM Destinations ORDER BY awards ASC LIMIT 1;\n```", "latency_sec": 0.6573069095611572, "total_duration_sec": 0.458521699, "load_duration_sec": 0.032075347, "tokens_prompt": 164, "prompt_eval_sec": 0.047630034, "tokens_completion": 20, "completion_eval_sec": 0.378029261, "tokens_total": 184, "tokens_per_sec": 279.9301168503543, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates a rank for each destination within its country based on awards, returning all rows with additional rank information. The Generated SQL only retrieves the destination with the lowest awards (single row) without any ranking or country partitioning. The output structures and purposes differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query calculates ranks within countries, which introduces unnecessary complexity not required by the question. The generated query directly identifies the destination with the absolute minimum awards (LIMIT 1), aligning with the business intent of finding 'least hotel awards.' However, the generated query would only return one destination even if multiple exist with the same minimum awards. The reference query's partitioning by country is irrelevant to the original question, which makes it less aligned with the business intent. While the generated query is more efficient, it has a limitation in handling ties, but it better addresses the core requirement of finding the destination with the least awards.", "overall_assessment": "differently_correct"}}
{"example_id": 1373, "sql_complexity": "subqueries", "prompt": "What is the total value of military equipment sales to Africa in the last 12 months?", "context": "CREATE TABLE Military_Equipment_Sales(sale_id INT, sale_date DATE, equipment_type VARCHAR(50), country VARCHAR(50), sale_value DECIMAL(10,2));", "reference_sql": "SELECT SUM(sale_value) FROM Military_Equipment_Sales WHERE country IN (SELECT country FROM World_Countries WHERE continent = 'Africa') AND sale_date >= DATE_SUB(CURRENT_DATE, INTERVAL 12 MONTH);", "generated_sql": "SELECT SUM(sale_value)\nFROM Military_Equipment_Sales\nWHERE country LIKE '%Africa%'\nAND sale_date >= DATE('now', '-12 months');", "raw_model_output": "```sql\nSELECT SUM(sale_value)\nFROM Military_Equipment_Sales\nWHERE country LIKE '%Africa%'\nAND sale_date >= DATE('now', '-12 months');\n```", "latency_sec": 1.192983627319336, "total_duration_sec": 0.88694056, "load_duration_sec": 0.028267752, "tokens_prompt": 141, "prompt_eval_sec": 0.041774343, "tokens_completion": 42, "completion_eval_sec": 0.816163106, "tokens_total": 183, "tokens_per_sec": 153.39690823017042, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in how they filter countries. The Reference SQL uses a subquery to select countries explicitly in the 'Africa' continent from World_Countries, while the Generated SQL uses a LIKE '%Africa%' pattern match on the country column. This could include countries with 'Africa' in their name (e.g., 'South Africa') that aren't part of the continent 'Africa' in the World_Countries table. The date conditions are functionally equivalent (both filter last 12 months) but the country filtering logic is not identical.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in three key aspects:\n1. **Country Filtering**: The reference uses a subquery to precisely identify African countries from a dedicated table, while the generated query uses a wildcard match on country names (LIKE '%Africa%') which could include non-African countries or exclude valid African countries without 'Africa' in their name.\n2. **Date Calculation**: The reference uses DATE_SUB(CURRENT_DATE, INTERVAL 12 MONTH) which is standard SQL for date calculations, whereas the generated query uses DATE('now', '-12 months)' which is SQLite-specific syntax and may not work in other SQL dialects.\n3. **Semantic Accuracy**: The reference ensures sales are explicitly tied to African countries via a structured relationship, while the generated query relies on ambiguous string matching. The reference better fulfills the business intent of accurately capturing all military equipment sales to Africa.", "overall_assessment": "differently_correct"}}
{"example_id": 904, "sql_complexity": "basic SQL", "prompt": "What is the minimum Shariah-compliant loan amount issued in the last quarter of 2021?", "context": "CREATE TABLE loans (id INT, amount DECIMAL, date DATE, loan_type VARCHAR); INSERT INTO loans (id, amount, date, loan_type) VALUES (1, 5000, '2021-09-05', 'Shariah-compliant'), (2, 7000, '2021-10-07', 'socially responsible'), (3, 9000, '2021-11-03', 'Shariah-compliant'), (4, 11000, '2021-12-31', 'Shariah-compliant');", "reference_sql": "SELECT MIN(amount) FROM loans WHERE EXTRACT(YEAR FROM date) = 2021 AND EXTRACT(QUARTER FROM date) = 4 AND loan_type = 'Shariah-compliant';", "generated_sql": "SELECT MIN(amount) FROM loans WHERE loan_type = 'Shariah-compliant' AND date BETWEEN '2021-10-01' AND '2021-12-31';", "raw_model_output": "```sql\nSELECT MIN(amount) FROM loans WHERE loan_type = 'Shariah-compliant' AND date BETWEEN '2021-10-01' AND '2021-12-31';\n```", "latency_sec": 1.2302563190460205, "total_duration_sec": 1.156818063, "load_duration_sec": 0.028988411, "tokens_prompt": 243, "prompt_eval_sec": 0.079998718, "tokens_completion": 52, "completion_eval_sec": 1.047155841, "tokens_total": 295, "tokens_per_sec": 239.78742919910567, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter for 'Shariah-compliant' loans in the fourth quarter of 2021. The reference query uses EXTRACT(YEAR) = 2021 and EXTRACT(QUARTER) = 4, while the generated query uses date BETWEEN '2021-10-01' AND '2021-12-31', which covers the same period. The MIN(amount) calculation will yield identical results since both conditions select the same subset of rows.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly identify the minimum Shariah-compliant loan amount in Q4 2021. The reference query uses EXTRACT() to explicitly target the year and quarter, while the generated query uses a date range. Since Q4 2021 corresponds to October-December 2021, both conditions filter the same dataset. The MIN() function will return the same result (9000) from the sample data. Both approaches are semantically equivalent and technically valid. The generated query may be slightly more efficient in some databases due to direct date comparisons, but neither has a clear advantage in this specific case.", "overall_assessment": "correct"}}
{"example_id": 3299, "sql_complexity": "set operations", "prompt": "How many schools and hospitals are there in Colombia and which ones need repairs?", "context": "CREATE TABLE schools (id INT, country VARCHAR(20), name VARCHAR(50), needs_repair BOOLEAN); CREATE TABLE hospitals (id INT, country VARCHAR(20), name VARCHAR(50), needs_repair BOOLEAN);", "reference_sql": "SELECT 'Schools' as facility_type, COUNT(*) as total, SUM(needs_repair) as repairs_needed FROM schools WHERE country = 'Colombia' UNION ALL SELECT 'Hospitals' as facility_type, COUNT(*) as total, SUM(needs_repair) as repairs_needed FROM hospitals WHERE country = 'Colombia';", "generated_sql": "SELECT\n  COUNT(CASE WHEN country = 'Colombia' THEN 1 END) AS colombia_count,\n  SUM(CASE WHEN country = 'Colombia' AND needs_repair = TRUE THEN 1 ELSE 0 END) AS colombia_needs_repair\nFROM (\n  SELECT country, needs_repair FROM schools\n  UNION ALL\n  SELECT country, needs_repair FROM hospitals\n) AS combined;", "raw_model_output": "```sql\nSELECT\n  COUNT(CASE WHEN country = 'Colombia' THEN 1 END) AS colombia_count,\n  SUM(CASE WHEN country = 'Colombia' AND needs_repair = TRUE THEN 1 ELSE 0 END) AS colombia_needs_repair\nFROM (\n  SELECT country, needs_repair FROM schools\n  UNION ALL\n  SELECT country, needs_repair FROM hospitals\n) AS combined;\n```", "latency_sec": 2.1131019592285156, "total_duration_sec": 1.909611846, "load_duration_sec": 0.028538636, "tokens_prompt": 145, "prompt_eval_sec": 0.043047032, "tokens_completion": 93, "completion_eval_sec": 1.83698901, "tokens_total": 238, "tokens_per_sec": 112.63062767065568, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The reference query returns two rows (one for Schools and one for Hospitals) with columns facility_type, total, and repairs_needed. The generated query returns a single row with columns colombia_count and colombia_needs_repair. The structure and output format differ, and the generated query combines data from both tables without distinguishing between them, while the reference query separates them.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly separates schools and hospitals into distinct rows with their respective counts and repair needs, directly answering the question. The generated query combines both facility types into a single row, losing the distinction between schools and hospitals. While both count Colombian facilities, the generated query fails to categorize results by facility type, which is critical for the original question. The reference query also explicitly filters each table separately, ensuring accuracy for each facility type.", "overall_assessment": "incorrect"}}
{"example_id": 907, "sql_complexity": "set operations", "prompt": "What is the total quantity of items with type 'E' or type 'F' in warehouse O and warehouse P?", "context": "CREATE TABLE warehouse_o(item_id INT, item_type VARCHAR(10), quantity INT);CREATE TABLE warehouse_p(item_id INT, item_type VARCHAR(10), quantity INT);INSERT INTO warehouse_o(item_id, item_type, quantity) VALUES (1, 'E', 200), (2, 'F', 300), (3, 'E', 50), (4, 'F', 400);INSERT INTO warehouse_p(item_id, item_type, quantity) VALUES (1, 'E', 150), (2, 'F', 250), (3, 'E', 40), (4, 'F', 350);", "reference_sql": "SELECT quantity FROM warehouse_o WHERE item_type IN ('E', 'F') UNION ALL SELECT quantity FROM warehouse_p WHERE item_type IN ('E', 'F');", "generated_sql": "SELECT SUM(quantity) FROM warehouse_o WHERE item_type IN ('E', 'F') UNION ALL SELECT SUM(quantity) FROM warehouse_p WHERE item_type IN ('E', 'F');", "raw_model_output": "```sql\nSELECT SUM(quantity) FROM warehouse_o WHERE item_type IN ('E', 'F') UNION ALL SELECT SUM(quantity) FROM warehouse_p WHERE item_type IN ('E', 'F');\n```", "latency_sec": 1.1623079776763916, "total_duration_sec": 1.072375774, "load_duration_sec": 0.030292278, "tokens_prompt": 268, "prompt_eval_sec": 0.089636271, "tokens_completion": 48, "completion_eval_sec": 0.951299262, "tokens_total": 316, "tokens_per_sec": 271.87286508325104, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query returns individual quantity values from both tables, while the generated query returns summed totals for each table. The first produces 8 rows of raw quantities, the second produces 2 rows of aggregated sums. UNION ALL behavior differs due to scalar vs. row-level results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL returns individual quantities for each item in warehouses O and P, but does not aggregate them. The Generated SQL correctly uses SUM to calculate total quantities per warehouse but fails to combine the two warehouses into a single total. Neither query fully meets the business intent of returning a single total quantity across both warehouses. However, the Generated SQL is technically superior as it uses SUM (required for aggregation) while the Reference SQL does not. The Generated SQL's output would require an additional step (e.g., SUM(unioned results)) to achieve the correct answer.", "overall_assessment": "incorrect"}}
{"example_id": 1400, "sql_complexity": "single join", "prompt": "What is the maximum co-ownership duration for properties in the neighborhood of 'Chinatown' in San Francisco?'", "context": "CREATE TABLE sf_neighborhoods (neighborhood_id INT, name VARCHAR(255), city VARCHAR(255)); INSERT INTO sf_neighborhoods (neighborhood_id, name, city) VALUES (1, 'Chinatown', 'San Francisco'); CREATE TABLE co_ownership (co_ownership_id INT, property_id INT, co_owner_id INT, start_date DATE, end_date DATE); INSERT INTO co_ownership (co_ownership_id, property_id, co_owner_id, start_date, end_date) VALUES (1, 1, 2, '2010-01-01', '2020-01-01'), (2, 2, 3, '2015-01-01', '2022-01-01'); CREATE TABLE properties (property_id INT, city VARCHAR(255)); INSERT INTO properties (property_id, city) VALUES (1, 'San Francisco'), (2, 'San Francisco');", "reference_sql": "SELECT MAX(DATEDIFF(end_date, start_date)) as max_duration FROM co_ownership JOIN properties ON co_ownership.property_id = properties.property_id WHERE properties.city = 'San Francisco' AND name = 'Chinatown';", "generated_sql": "SELECT\n  MAX(T1.end_date - T1.start_date)\nFROM co_ownership AS T1\nINNER JOIN properties AS T2\n  ON T1.property_id = T2.property_id\nINNER JOIN sf_neighborhoods AS T3\n  ON T2.city = T3.city\nWHERE\n  T3.name = 'Chinatown';", "raw_model_output": "```sql\nSELECT\n  MAX(T1.end_date - T1.start_date)\nFROM co_ownership AS T1\nINNER JOIN properties AS T2\n  ON T1.property_id = T2.property_id\nINNER JOIN sf_neighborhoods AS T3\n  ON T2.city = T3.city\nWHERE\n  T3.name = 'Chinatown';\n```", "latency_sec": 2.1999051570892334, "total_duration_sec": 2.005822182, "load_duration_sec": 0.028891883, "tokens_prompt": 330, "prompt_eval_sec": 0.117905991, "tokens_completion": 92, "completion_eval_sec": 1.85809619, "tokens_total": 422, "tokens_per_sec": 191.82645153592077, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references 'name' without joining sf_neighborhoods, causing an error. The Generated SQL correctly joins sf_neighborhoods and filters on T3.name. Additionally, the Reference SQL's WHERE clause incorrectly assumes 'name' exists in properties/co_ownership tables.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in two critical aspects. 1) The reference query correctly filters for properties in San Francisco by including 'properties.city = 'San Francisco'' in the WHERE clause, while the generated query only filters on the neighborhood name, potentially including properties in other cities with a 'Chinatown' neighborhood. 2) The reference query uses the standard DATEDIFF function to calculate the duration between dates, while the generated query uses a date subtraction operator, which may not be supported in all SQL dialects and could yield different results.  Both queries join the necessary tables, but the reference query's explicit city filter ensures the correct data is considered.  The generated query's approach is less robust and could lead to incorrect results if there are multiple 'Chinatown' neighborhoods in different cities.", "overall_assessment": "incorrect"}}
{"example_id": 5248, "sql_complexity": "window functions", "prompt": "Find the top 5 games by rating", "context": "CREATE TABLE games (game_id INT PRIMARY KEY, name VARCHAR(50), genre VARCHAR(50), rating DECIMAL(3,2));", "reference_sql": "SELECT * FROM (SELECT name, rating, ROW_NUMBER() OVER (ORDER BY rating DESC) as rn FROM games) t WHERE rn <= 5;", "generated_sql": "SELECT game_id, name, genre, rating\nFROM games\nORDER BY rating DESC\nLIMIT 5;", "raw_model_output": "```sql\nSELECT game_id, name, genre, rating\nFROM games\nORDER BY rating DESC\nLIMIT 5;\n```", "latency_sec": 0.7233908176422119, "total_duration_sec": 0.619631884, "load_duration_sec": 0.028199694, "tokens_prompt": 118, "prompt_eval_sec": 0.033462184, "tokens_completion": 29, "completion_eval_sec": 0.557255779, "tokens_total": 147, "tokens_per_sec": 203.2096570967341, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL selects only 'name', 'rating', and a row number ('rn'), while the Generated SQL selects all columns ('game_id', 'name', 'genre', 'rating'). Additionally, the Reference SQL uses a subquery with ROW_NUMBER() which may handle ties differently compared to the Generated SQL's LIMIT 5, though the primary discrepancy is the column selection.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "While both queries aim to retrieve top-rated games, they differ in approach. The reference query uses ROW_NUMBER() with a subquery, which is unnecessarily complex for this task. The generated query directly orders by rating and limits results, which is more efficient and straightforward. Semantically, they would produce the same results if all ratings are unique, but the generated query handles ties more predictably (though the original question doesn't specify tie-breaking logic). The generated query better fulfills the business intent with simpler, more efficient execution.", "overall_assessment": "differently_correct"}}
{"example_id": 778, "sql_complexity": "single join", "prompt": "What is the maximum property price in wheelchair-accessible neighborhoods in Singapore?", "context": "CREATE TABLE Singapore_Neighborhoods (Neighborhood_Name TEXT, Wheelchair_Accessibility BOOLEAN); INSERT INTO Singapore_Neighborhoods (Neighborhood_Name, Wheelchair_Accessibility) VALUES ('Orchard', true), ('Marina Bay', true), ('Chinatown', false), ('Little India', false), ('Bugis', true); CREATE TABLE Singapore_Properties (Neighborhood_Name TEXT, Property_Price INTEGER); INSERT INTO Singapore_Properties (Neighborhood_Name, Property_Price) VALUES ('Orchard', 2000000), ('Marina Bay', 3000000), ('Chinatown', 1500000), ('Little India', 1200000), ('Bugis', 1800000);", "reference_sql": "SELECT MAX(Singapore_Properties.Property_Price) FROM Singapore_Properties INNER JOIN Singapore_Neighborhoods ON Singapore_Properties.Neighborhood_Name = Singapore_Neighborhoods.Neighborhood_Name WHERE Singapore_Neighborhoods.Wheelchair_Accessibility = true;", "generated_sql": "SELECT\n  MAX(Property_Price)\nFROM Singapore_Properties\nWHERE\n  Neighborhood_Name IN (\n    SELECT\n      Neighborhood_Name\n    FROM Singapore_Neighborhoods\n    WHERE\n      Wheelchair_Accessibility = TRUE\n  );", "raw_model_output": "```sql\nSELECT\n  MAX(Property_Price)\nFROM Singapore_Properties\nWHERE\n  Neighborhood_Name IN (\n    SELECT\n      Neighborhood_Name\n    FROM Singapore_Neighborhoods\n    WHERE\n      Wheelchair_Accessibility = TRUE\n  );\n```", "latency_sec": 1.3600451946258545, "total_duration_sec": 1.263937737, "load_duration_sec": 0.032726944, "tokens_prompt": 258, "prompt_eval_sec": 0.082788632, "tokens_completion": 58, "completion_eval_sec": 1.147196291, "tokens_total": 316, "tokens_per_sec": 232.34522003287614, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the maximum property price from neighborhoods with wheelchair accessibility. The Reference SQL uses an INNER JOIN to combine tables and filter accessible neighborhoods, while the Generated SQL uses a subquery with IN to achieve the same filtering. Both approaches ensure only properties in accessible neighborhoods are considered, resulting in the same maximum value.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly identify wheelchair-accessible neighborhoods by linking the two tables and filter for Wheelchair_Accessibility = true. The reference query uses an explicit INNER JOIN, while the generated query uses a subquery with IN. Both approaches produce the same result set because they filter the same neighborhoods. The business intent is fully addressed by both queries, as they both calculate the maximum property price in the correct subset of neighborhoods. Neither query is more efficient than the other in this specific case, and both are syntactically correct.", "overall_assessment": "correct"}}
{"example_id": 3859, "sql_complexity": "aggregation", "prompt": "What is the total number of mental health parity violations by month and year?", "context": "CREATE TABLE mental_health_parity_reports (report_id INT, violation_date DATE); INSERT INTO mental_health_parity_reports (report_id, violation_date) VALUES (1, '2022-01-01'), (2, '2022-02-15'), (3, '2022-03-05'), (4, '2022-04-20'), (5, '2021-06-12'), (6, '2021-07-28');", "reference_sql": "SELECT EXTRACT(MONTH FROM violation_date) AS month, EXTRACT(YEAR FROM violation_date) AS year, COUNT(*) FROM mental_health_parity_reports GROUP BY month, year;", "generated_sql": "SELECT\n  STRFTIME('%Y', violation_date) AS violation_year,\n  STRFTIME('%m', violation_date) AS violation_month,\n  COUNT(*) AS total_violations\nFROM mental_health_parity_reports\nGROUP BY\n  violation_year,\n  violation_month\nORDER BY\n  violation_year,\n  violation_month;", "raw_model_output": "```sql\nSELECT\n  STRFTIME('%Y', violation_date) AS violation_year,\n  STRFTIME('%m', violation_date) AS violation_month,\n  COUNT(*) AS total_violations\nFROM mental_health_parity_reports\nGROUP BY\n  violation_year,\n  violation_month\nORDER BY\n  violation_year,\n  violation_month;\n```", "latency_sec": 1.9961910247802734, "total_duration_sec": 1.899682518, "load_duration_sec": 0.02829677, "tokens_prompt": 224, "prompt_eval_sec": 0.071094192, "tokens_completion": 91, "completion_eval_sec": 1.79944233, "tokens_total": 315, "tokens_per_sec": 157.800529152601, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in data types: Reference uses EXTRACT (integer month/year) while Generated uses STRFTIME (string month/year). For example, month 1 becomes '01' as a string in Generated, whereas Reference returns 1 as an integer. This type difference makes the results non-equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly group violations by month and year, producing identical counts. The Reference SQL uses EXTRACT() for numeric month/year values, while the Generated SQL uses STRFTIME() to format dates as strings. The Generated version has more descriptive column names ('violation_year', 'violation_month') and includes an ORDER BY clause, which improves readability and ensures chronological presentation. However, STRFTIME is SQLite-specific, whereas EXTRACT() is standard SQL. Despite this, both satisfy the business requirement of aggregating violations by time period.", "overall_assessment": "correct"}}
{"example_id": 3551, "sql_complexity": "multiple_joins", "prompt": "List all artists who have performed in New York and Chicago, along with their highest-earning performance.", "context": "CREATE TABLE artist_events (artist_id INT, event_id INT, earnings DECIMAL(5,2)); CREATE TABLE artists (id INT, name VARCHAR(50)); CREATE TABLE events (id INT, city VARCHAR(20));", "reference_sql": "SELECT artists.name, MAX(artist_events.earnings) FROM artists INNER JOIN artist_events ON artists.id = artist_events.artist_id INNER JOIN events ON artist_events.event_id = events.id WHERE city IN ('New York', 'Chicago') GROUP BY artists.name;", "generated_sql": "SELECT\n  A.name,\n  MAX(AE.earnings) AS highest_earnings\nFROM artists AS A\nJOIN artist_events AS AE\n  ON A.id = AE.artist_id\nJOIN events AS E\n  ON AE.event_id = E.id\nWHERE\n  E.city IN ('New York', 'Chicago')\nGROUP BY\n  A.name;", "raw_model_output": "```sql\nSELECT\n  A.name,\n  MAX(AE.earnings) AS highest_earnings\nFROM artists AS A\nJOIN artist_events AS AE\n  ON A.id = AE.artist_id\nJOIN events AS E\n  ON AE.event_id = E.id\nWHERE\n  E.city IN ('New York', 'Chicago')\nGROUP BY\n  A.name;\n```", "latency_sec": 2.1240670680999756, "total_duration_sec": 1.841218998, "load_duration_sec": 0.029897137, "tokens_prompt": 150, "prompt_eval_sec": 0.042367129, "tokens_completion": 90, "completion_eval_sec": 1.767970201, "tokens_total": 240, "tokens_per_sec": 112.99078244957926, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform the same operations: joining artists, artist_events, and events tables; filtering by city in ('New York', 'Chicago'); grouping by artist name; and selecting the maximum earnings per artist. The differences are purely syntactic (explicit vs. implicit joins, table aliases) and do not affect the result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": false, "superiority": "equal", "explanation": "The queries are technically equivalent as they produce identical results through equivalent logic (JOINs, WHERE filters, and GROUP BY). However, they do not fully fulfill the business intent. The original question asks for artists who performed in 'New York AND Chicago' (implying both cities), but the queries use WHERE city IN ('New York', 'Chicago') which filters for events in either city. To satisfy the 'AND' condition, the queries would need to ensure artists have events in both cities (e.g., using HAVING COUNT(DISTINCT city) = 2). The generated query is more concise but functionally identical to the reference.", "overall_assessment": "incorrect"}}
{"example_id": 5168, "sql_complexity": "aggregation", "prompt": "Get the number of renewable energy projects in Australia for each project type.", "context": "CREATE TABLE renewable_projects (id INT PRIMARY KEY, project_name VARCHAR(255), project_location VARCHAR(255), project_type VARCHAR(255), capacity_mw FLOAT);", "reference_sql": "SELECT project_type, COUNT(*) FROM renewable_projects WHERE project_location = 'Australia' GROUP BY project_type;", "generated_sql": "SELECT\n  project_type,\n  COUNT(id)\nFROM renewable_projects\nWHERE\n  project_location = 'Australia'\nGROUP BY\n  project_type;", "raw_model_output": "```sql\nSELECT\n  project_type,\n  COUNT(id)\nFROM renewable_projects\nWHERE\n  project_location = 'Australia'\nGROUP BY\n  project_type;\n```", "latency_sec": 1.0235021114349365, "total_duration_sec": 0.927216607, "load_duration_sec": 0.02854196, "tokens_prompt": 137, "prompt_eval_sec": 0.041320672, "tokens_completion": 44, "completion_eval_sec": 0.856650613, "tokens_total": 181, "tokens_per_sec": 176.84379736768727, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of projects per type in Australia. COUNT(*) and COUNT(id) yield the same result because 'id' is a primary key (non-null) column. The WHERE and GROUP BY clauses are identical, ensuring equivalent aggregation.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly count renewable energy projects in Australia by project type. The reference query uses COUNT(*) while the generated query uses COUNT(id). Since id is a primary key (non-null and unique), both forms produce identical results. The WHERE clause correctly filters for 'Australia' and GROUP BY ensures aggregation by project_type. Both queries technically and semantically fulfill the business intent with equivalent efficiency. The choice between COUNT(*) and COUNT(id) is stylistic rather than functional in this context.", "overall_assessment": "correct"}}
{"example_id": 4916, "sql_complexity": "aggregation", "prompt": "What is the maximum revenue generated from selling Yttrium in India in the past 3 years?", "context": "CREATE TABLE Yttrium_Sales (id INT PRIMARY KEY, year INT, country VARCHAR(20), quantity INT, price PER_KG); INSERT INTO Yttrium_Sales (id, year, country, quantity, price) VALUES (1, 2019, 'India', 120, 40), (2, 2020, 'India', 130, 45), (3, 2021, 'India', 140, 50), (4, 2019, 'China', 150, 35), (5, 2020, 'China', 160, 40), (6, 2021, 'China', 170, 45);", "reference_sql": "SELECT MAX(quantity * price) FROM Yttrium_Sales WHERE country = 'India' GROUP BY year ORDER BY year DESC LIMIT 3;", "generated_sql": "SELECT MAX(quantity * price)\nFROM Yttrium_Sales\nWHERE country = 'India'\nAND year >= strftime('%Y', 'now') - 3;", "raw_model_output": "```sql\nSELECT MAX(quantity * price)\nFROM Yttrium_Sales\nWHERE country = 'India'\nAND year >= strftime('%Y', 'now') - 3;\n```", "latency_sec": 1.086913824081421, "total_duration_sec": 0.968236385, "load_duration_sec": 0.029404521, "tokens_prompt": 275, "prompt_eval_sec": 0.09021988, "tokens_completion": 43, "completion_eval_sec": 0.847900892, "tokens_total": 318, "tokens_per_sec": 292.5714927480567, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query groups by year, returns one MAX(quantity*price) per year, orders results descending, and limits 3. The generated query has no GROUP BY, so it returns a single MAX(quantity*price) value for all India records in the last 3 years (based on current year). They differ in structure (grouping vs single value) and logic (year-based aggregation vs temporal filtering).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL groups by year and returns the maximum revenue per year, but it includes 2019 (not in the past 3 years) and returns multiple rows instead of a single maximum. The Generated SQL correctly filters for the past 3 years (assuming current year is 2023) but lacks grouping by year, which could lead to incorrect results if multiple sales exist in the same year. Neither query fully aligns with the business intent, but the Generated SQL better addresses the time frame constraint. The Reference SQL's grouping and ordering are unnecessary for the question's requirement of a single maximum value.", "overall_assessment": "differently_correct"}}
{"example_id": 812, "sql_complexity": "multiple_joins", "prompt": "What is the average salary of 'engineer' workers in each factory?", "context": "CREATE TABLE factories (factory_id INT, factory_name VARCHAR(20)); INSERT INTO factories VALUES (1, 'Factory X'), (2, 'Factory Y'), (3, 'Factory Z'); CREATE TABLE roles (role_id INT, role_name VARCHAR(20)); INSERT INTO roles VALUES (1, 'engineer'), (2, 'manager'), (3, 'assistant'); CREATE TABLE workers (worker_id INT, factory_id INT, role_id INT, salary DECIMAL(5,2)); INSERT INTO workers VALUES (1, 1, 1, 50000.00), (2, 1, 2, 70000.00), (3, 2, 1, 55000.00), (4, 2, 3, 40000.00), (5, 3, 1, 60000.00);", "reference_sql": "SELECT f.factory_name, AVG(salary) FROM workers w INNER JOIN factories f ON w.factory_id = f.factory_id INNER JOIN roles r ON w.role_id = r.role_id WHERE r.role_name = 'engineer' GROUP BY f.factory_name;", "generated_sql": "SELECT\n  f.factory_name,\n  AVG(w.salary)\nFROM workers AS w\nJOIN factories AS f\n  ON w.factory_id = f.factory_id\nJOIN roles AS r\n  ON w.role_id = r.role_id\nWHERE\n  r.role_name = 'engineer'\nGROUP BY\n  f.factory_name;", "raw_model_output": "```sql\nSELECT\n  f.factory_name,\n  AVG(w.salary)\nFROM workers AS w\nJOIN factories AS f\n  ON w.factory_id = f.factory_id\nJOIN roles AS r\n  ON w.role_id = r.role_id\nWHERE\n  r.role_name = 'engineer'\nGROUP BY\n  f.factory_name;\n```", "latency_sec": 2.2245898246765137, "total_duration_sec": 1.932642078, "load_duration_sec": 0.028170822, "tokens_prompt": 300, "prompt_eval_sec": 0.099262496, "tokens_completion": 90, "completion_eval_sec": 1.804339857, "tokens_total": 390, "tokens_per_sec": 175.31321759808526, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the average salary of engineers per factory. They use identical table joins (workers-factories-roles), same WHERE condition (role_name = 'engineer'), and same GROUP BY clause. The generated SQL uses explicit table aliases and explicit JOIN syntax, but the semantic logic remains identical to the reference query.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are structurally identical in terms of logic, joins, filtering, and aggregation. They correctly join the workers, factories, and roles tables, filter for 'engineer' roles, and calculate the average salary per factory. The only differences are formatting (e.g., capitalization, spacing) and minor syntax variations (e.g., 'AS' keyword usage), which do not affect functionality. Both queries would produce identical results and fully address the business question.", "overall_assessment": "correct"}}
{"example_id": 5784, "sql_complexity": "set operations", "prompt": "List the number of users who have completed a workout of a specific type (e.g. Running) and have a membership status of 'Active'.", "context": "CREATE TABLE workouts (id INT, user_id INT, workout_type VARCHAR(20)); CREATE TABLE members (id INT, name VARCHAR(50), membership_status VARCHAR(20), state VARCHAR(20)); INSERT INTO workouts (id, user_id, workout_type) VALUES (1, 1, 'Running'), (2, 1, 'Cycling'), (3, 2, 'Running'), (4, 3, 'Cycling'), (5, 3, 'Swimming'), (6, 4, 'Running'), (7, 4, 'Swimming'); INSERT INTO members (id, name, membership_status, state) VALUES (1, 'John Doe', 'Active', 'Texas'), (2, 'Jane Doe', 'Inactive', 'California'), (3, 'Bob Smith', 'Active', 'Texas'), (4, 'Alice Johnson', 'Active', 'California');", "reference_sql": "SELECT COUNT(*) FROM (SELECT user_id FROM workouts WHERE workout_type = 'Running' INTERSECT SELECT id FROM members WHERE membership_status = 'Active') AS user_set;", "generated_sql": "SELECT\n  COUNT(DISTINCT T1.user_id)\nFROM workouts AS T1\nINNER JOIN members AS T2\n  ON T1.user_id = T2.id\nWHERE\n  T2.membership_status = 'Active' AND T1.workout_type = 'Running';", "raw_model_output": "```sql\nSELECT\n  COUNT(DISTINCT T1.user_id)\nFROM workouts AS T1\nINNER JOIN members AS T2\n  ON T1.user_id = T2.id\nWHERE\n  T2.membership_status = 'Active' AND T1.workout_type = 'Running';\n```", "latency_sec": 1.7488210201263428, "total_duration_sec": 1.57185137, "load_duration_sec": 0.028433662, "tokens_prompt": 302, "prompt_eval_sec": 0.099549763, "tokens_completion": 72, "completion_eval_sec": 1.44295077, "tokens_total": 374, "tokens_per_sec": 213.85836268881337, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of distinct user_ids that appear in both the 'Running' workouts and active members. The Reference SQL uses INTERSECT to find the intersection of user_id from workouts and id from members, while the Generated SQL achieves the same via an INNER JOIN and COUNT(DISTINCT). Both approaches ensure uniqueness and correct filtering, producing identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count users with 'Running' workouts and 'Active' membership. The Reference query uses INTERSECT to find users present in both subqueries, while the Generated query uses an INNER JOIN with COUNT(DISTINCT). They produce identical results because INTERSECT effectively acts as a JOIN with distinct values. However, the Generated query is more efficient (avoids INTERSECT's sorting overhead) and directly expresses the relationship between tables, making it more readable and maintainable. Both fulfill the business intent, but the Generated query better addresses the question through standard JOIN semantics.", "overall_assessment": "correct"}}
{"example_id": 3038, "sql_complexity": "subqueries", "prompt": "What is the total assets of clients who have invested in mutual funds but not in stocks?", "context": "CREATE TABLE clients (client_id INT, name TEXT, age INT, gender TEXT, total_assets DECIMAL(10,2)); INSERT INTO clients VALUES (1, 'John Doe', 35, 'Male', 250000.00), (2, 'Jane Smith', 45, 'Female', 500000.00); CREATE TABLE investments (client_id INT, investment_type TEXT); INSERT INTO investments VALUES (1, 'Stocks'), (1, 'Bonds'), (2, 'Stocks'), (3, 'Mutual Funds');", "reference_sql": "SELECT c.total_assets FROM clients c INNER JOIN investments i ON c.client_id = i.client_id WHERE i.investment_type = 'Mutual Funds' AND c.client_id NOT IN (SELECT client_id FROM investments WHERE investment_type = 'Stocks');", "generated_sql": "SELECT\n  SUM(c.total_assets)\nFROM clients AS c\nWHERE\n  c.client_id IN (\n    SELECT\n      client_id\n    FROM investments\n    WHERE\n      investment_type = 'Mutual Funds'\n  )\n  AND c.client_id NOT IN (\n    SELECT\n      client_id\n    FROM investments\n    WHERE\n      investment_type = 'Stocks'\n  );", "raw_model_output": "```sql\nSELECT\n  SUM(c.total_assets)\nFROM clients AS c\nWHERE\n  c.client_id IN (\n    SELECT\n      client_id\n    FROM investments\n    WHERE\n      investment_type = 'Mutual Funds'\n  )\n  AND c.client_id NOT IN (\n    SELECT\n      client_id\n    FROM investments\n    WHERE\n      investment_type = 'Stocks'\n  );\n```", "latency_sec": 2.369671106338501, "total_duration_sec": 2.067806204, "load_duration_sec": 0.029183571, "tokens_prompt": 224, "prompt_eval_sec": 0.070997302, "tokens_completion": 99, "completion_eval_sec": 1.966905706, "tokens_total": 323, "tokens_per_sec": 136.30583549591557, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL selects individual client total_assets values, while the Generated SQL aggregates them with SUM. The Reference returns multiple rows (if matches exist) and the Generated returns a single summed value. Additionally, the Generated query's structure with SUM changes the result's nature compared to the Reference's row-level selection.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query returns individual client assets rather than a total, while the generated query correctly uses SUM() to aggregate the total assets. Both identify clients with mutual funds but no stocks, but the generated query addresses the 'total assets' requirement. The generated query is more efficient as it avoids unnecessary JOIN operations and directly filters client IDs with subqueries.", "overall_assessment": "correct"}}
{"example_id": 1078, "sql_complexity": "basic SQL", "prompt": "What is the maximum and minimum temperature difference between any two Arctic research stations?", "context": "CREATE TABLE arctic_stations (id INT, name TEXT, location TEXT, temperature DECIMAL(5,2)); INSERT INTO arctic_stations (id, name, location, temperature) VALUES (1, 'Station A', 'Greenland', 2.3), (2, 'Station B', 'Canada', -5.2);", "reference_sql": "SELECT a.name as station1, b.name as station2, MAX(ABS(a.temperature - b.temperature)) as temp_diff FROM arctic_stations a, arctic_stations b ORDER BY temp_diff DESC LIMIT 1", "generated_sql": "SELECT\n  MAX(temperature_diff) - MIN(temperature_diff)\nFROM (\n  SELECT\n    temperature\n  FROM arctic_stations\n) AS temperatures,\narctic_stations AS other_temperatures\nWHERE\n  temperatures.id != other_temperatures.id\nORDER BY\n  temperature DESC\nLIMIT 1;", "raw_model_output": "```sql\nSELECT\n  MAX(temperature_diff) - MIN(temperature_diff)\nFROM (\n  SELECT\n    temperature\n  FROM arctic_stations\n) AS temperatures,\narctic_stations AS other_temperatures\nWHERE\n  temperatures.id != other_temperatures.id\nORDER BY\n  temperature DESC\nLIMIT 1;\n```", "latency_sec": 1.9100890159606934, "total_duration_sec": 1.606699518, "load_duration_sec": 0.029896194, "tokens_prompt": 163, "prompt_eval_sec": 0.047749545, "tokens_completion": 78, "completion_eval_sec": 1.528264252, "tokens_total": 241, "tokens_per_sec": 126.17213019194672, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates the maximum absolute temperature difference between all station pairs, while the generated query contains a syntax error (temperature_diff column does not exist) and incorrectly attempts to compute MAX-MIN on unrelated temperature values without proper pairing. The generated query would fail execution and does not match the reference's logic.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference SQL correctly calculates the maximum temperature difference between any two stations using a self-join and ABS() to ensure positive values. However, it only returns the maximum difference, not both maximum and minimum as requested. The generated SQL contains a critical syntax error: it references a column 'temperature_diff' that doesn't exist in the subquery (which only selects 'temperature'). Additionally, its logic is flawed - it attempts to compute MAX - MIN on a cross-join without proper aggregation. While the reference fails to address the 'minimum' part of the question, it is technically valid and closer to the correct approach.", "overall_assessment": "incorrect"}}
{"example_id": 5015, "sql_complexity": "basic SQL", "prompt": "Calculate the average recycling rate", "context": "CREATE TABLE recycling_rates (id INT PRIMARY KEY, location VARCHAR(50), rate FLOAT);", "reference_sql": "SELECT AVG(rate) FROM recycling_rates;", "generated_sql": "SELECT AVG(rate) FROM recycling_rates;", "raw_model_output": "```sql\nSELECT AVG(rate) FROM recycling_rates;\n```", "latency_sec": 0.9690899848937988, "total_duration_sec": 0.372207554, "load_duration_sec": 0.041566155, "tokens_prompt": 105, "prompt_eval_sec": 0.030958497, "tokens_completion": 16, "completion_eval_sec": 0.298844627, "tokens_total": 121, "tokens_per_sec": 124.8594061296178, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They both calculate the average of the 'rate' column from the 'recycling_rates' table using the AVG() aggregate function. Since the SQL statements are exactly the same, they will produce the same result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic. They correctly calculate the average recycling rate using the AVG() function on the 'rate' column from the 'recycling_rates' table. The queries are technically identical, produce the same results, and directly address the business intent of calculating the average recycling rate. Since they are exactly the same, neither is superior to the other.", "overall_assessment": "correct"}}
{"example_id": 1533, "sql_complexity": "subqueries", "prompt": "Which programs had the highest volunteer participation rate in the last quarter?", "context": "CREATE TABLE Programs (ProgramID INT, ProgramName TEXT, Budget DECIMAL(10,2), NumVolunteers INT); CREATE TABLE VolunteerEvents (EventID INT, ProgramID INT, EventDate DATE, NumVolunteers INT);", "reference_sql": "SELECT p.ProgramName, COUNT(v.EventID) / (SELECT COUNT(*) FROM VolunteerEvents WHERE EventDate >= DATEADD(quarter, -1, GETDATE())) * 100.0 AS VolunteerParticipationRate FROM Programs p INNER JOIN VolunteerEvents v ON p.ProgramID = v.ProgramID WHERE v.EventDate >= DATEADD(quarter, -1, GETDATE()) GROUP BY p.ProgramName ORDER BY VolunteerParticipationRate DESC;", "generated_sql": "SELECT\n  ProgramName\nFROM Programs\nWHERE\n  ProgramID IN (\n    SELECT\n      ProgramID\n    FROM VolunteerEvents\n    WHERE\n      EventDate >= DATE('now', '-3 months')\n    GROUP BY\n      ProgramID\n    ORDER BY\n      SUM(NumVolunteers) DESC\n    LIMIT 1\n  );", "raw_model_output": "```sql\nSELECT\n  ProgramName\nFROM Programs\nWHERE\n  ProgramID IN (\n    SELECT\n      ProgramID\n    FROM VolunteerEvents\n    WHERE\n      EventDate >= DATE('now', '-3 months')\n    GROUP BY\n      ProgramID\n    ORDER BY\n      SUM(NumVolunteers) DESC\n    LIMIT 1\n  );\n```", "latency_sec": 1.82676362991333, "total_duration_sec": 1.611478696, "load_duration_sec": 0.028546401, "tokens_prompt": 140, "prompt_eval_sec": 0.038421935, "tokens_completion": 79, "completion_eval_sec": 1.543608971, "tokens_total": 219, "tokens_per_sec": 119.88414725028785, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates a participation rate percentage for each program based on event counts, while the generated query selects only the program with the highest total volunteers in the last 3 months. They differ in purpose, aggregation logic, and result structure.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent. The reference query attempts to calculate a participation rate as (program events / total events) * 100, while the generated query focuses on total volunteer counts without calculating a rate. Neither fully addresses the business intent of 'volunteer participation rate' (which likely requires volunteers/total possible volunteers or similar). However, the reference query better aligns with the intent by attempting to calculate a rate, even if its metric is flawed. The generated query incorrectly identifies the program with the highest total volunteers rather than a rate. Both have logical issues: the reference's denominator counts all events (not volunteers) and the generated query lacks proper rate calculation.", "overall_assessment": "differently_correct"}}
{"example_id": 4021, "sql_complexity": "subqueries", "prompt": "What is the percentage of energy efficiency improvement, per sector, compared to 2015 levels?", "context": "CREATE TABLE energy_efficiency (id INT, sector VARCHAR(50), year INT, efficiency FLOAT); INSERT INTO energy_efficiency (id, sector, year, efficiency) VALUES (1, 'Industry', 2015, 100.0), (2, 'Industry', 2020, 105.0), (3, 'Residential', 2015, 100.0), (4, 'Residential', 2020, 103.0);", "reference_sql": "SELECT sector, (SUM(efficiency) / (SELECT SUM(efficiency) FROM energy_efficiency WHERE year = 2015 AND sector = e.sector) * 100.0) - 100.0 AS improvement FROM energy_efficiency e WHERE year = 2020 GROUP BY sector;", "generated_sql": "SELECT\n  sector,\n  (efficiency - LAG(efficiency, 1, efficiency) OVER (PARTITION BY sector ORDER BY year)) * 100.0 / LAG(efficiency, 1, efficiency) OVER (PARTITION BY sector ORDER BY year) AS percentage_improvement\nFROM energy_efficiency\nWHERE\n  year = 2020;", "raw_model_output": "```sql\nSELECT\n  sector,\n  (efficiency - LAG(efficiency, 1, efficiency) OVER (PARTITION BY sector ORDER BY year)) * 100.0 / LAG(efficiency, 1, efficiency) OVER (PARTITION BY sector ORDER BY year) AS percentage_improvement\nFROM energy_efficiency\nWHERE\n  year = 2020;\n```", "latency_sec": 1.8398041725158691, "total_duration_sec": 1.740806421, "load_duration_sec": 0.028772042, "tokens_prompt": 213, "prompt_eval_sec": 0.070415734, "tokens_completion": 83, "completion_eval_sec": 1.640901122, "tokens_total": 296, "tokens_per_sec": 160.8866880626921, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL calculates the percentage improvement of total efficiency for each sector from 2015 to 2020 using SUM and a subquery. The Generated SQL uses LAG to compute the percentage change between consecutive years for individual rows. If there are multiple entries per sector/year, the Reference SQL aggregates values while the Generated SQL would return multiple rows per sector. Additionally, the Generated SQL's LAG function may not handle cases with missing years or non-consecutive data correctly.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries calculate percentage improvement compared to 2015, but with different approaches. The reference query explicitly compares 2020 values to 2015 values using a subquery, ensuring direct comparison to the base year. The generated query uses LAG() to get the previous year's value (which happens to be 2015 in this dataset) but would fail if there were intervening years. While both produce the same results for the given data, the reference query is more robust for the business intent of comparing to a specific base year (2015) rather than the immediately preceding year.", "overall_assessment": "correct"}}
{"example_id": 1551, "sql_complexity": "single join", "prompt": "How many unique donors made donations in the healthcare industry in Q3 2022?", "context": "CREATE TABLE donations (id INT, donor_id INT, amount FLOAT, donation_date DATE); INSERT INTO donations (id, donor_id, amount, donation_date) VALUES (1, 7, 100, '2022-07-01'); INSERT INTO donations (id, donor_id, amount, donation_date) VALUES (2, 8, 200, '2022-09-15'); INSERT INTO donors (id, name, industry, first_donation_date DATE) VALUES (7, 'Charlie Davis', 'Healthcare', '2022-07-01'); INSERT INTO donors (id, name, industry, first_donation_date DATE) VALUES (8, 'Dana Wilson', 'Healthcare', '2022-09-15');", "reference_sql": "SELECT COUNT(DISTINCT donor_id) FROM donations d JOIN donors don ON d.donor_id = don.id WHERE industry = 'Healthcare' AND donation_date BETWEEN '2022-07-01' AND '2022-09-30';", "generated_sql": "SELECT\n  COUNT(DISTINCT T1.donor_id)\nFROM donations AS T1\nINNER JOIN donors AS T2\n  ON T1.donor_id = T2.id\nWHERE\n  T2.industry = 'Healthcare' AND STRFTIME('%Y-%m', T1.donation_date) BETWEEN '2022-07' AND '2022-09';", "raw_model_output": "```sql\nSELECT\n  COUNT(DISTINCT T1.donor_id)\nFROM donations AS T1\nINNER JOIN donors AS T2\n  ON T1.donor_id = T2.id\nWHERE\n  T2.industry = 'Healthcare' AND STRFTIME('%Y-%m', T1.donation_date) BETWEEN '2022-07' AND '2022-09';\n```", "latency_sec": 2.0310230255126953, "total_duration_sec": 2.017667111, "load_duration_sec": 0.028011713, "tokens_prompt": 279, "prompt_eval_sec": 0.091197537, "tokens_completion": 95, "completion_eval_sec": 1.89769512, "tokens_total": 374, "tokens_per_sec": 184.14365337172404, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count distinct donor_ids from donations joined with donors where industry is 'Healthcare'. The date condition in the Reference SQL (BETWEEN '2022-07-01' AND '2022-09-30') includes all dates in July, August, and September 2022. The Generated SQL uses STRFTIME('%Y-%m', donation_date) to extract the year-month string, which effectively captures the same date range (July-September 2022) as the BETWEEN clause. The COUNT(DISTINCT) logic and join conditions are identical, making the queries semantically equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries correctly count unique healthcare donors who made donations in Q3 2022. The Reference SQL uses explicit date range filtering (BETWEEN '2022-07-01' AND '2022-09-30') which precisely captures Q3. The Generated SQL uses STRFTIME('%Y-%m') to extract month values, which also correctly captures Q3 (July-September). Both achieve the same result. However, the Reference SQL is more efficient as it avoids function-based filtering on the donation_date column, which could prevent index usage. The Generated SQL's STRFTIME approach is dialect-specific (SQLite) and less readable for generic SQL implementations.", "overall_assessment": "correct"}}
{"example_id": 2592, "sql_complexity": "window functions", "prompt": "What is the third highest account balance for Shariah-compliant finance customers?", "context": "CREATE TABLE shariah_compliant_finance(customer_id INT, account_balance DECIMAL(10, 2)); INSERT INTO shariah_compliant_finance VALUES (1, 5000), (2, 7000), (3, 6000), (4, 8000), (5, 9000);", "reference_sql": "SELECT account_balance FROM (SELECT account_balance, RANK() OVER (ORDER BY account_balance DESC) as rn FROM shariah_compliant_finance) t WHERE rn = 3;", "generated_sql": "SELECT account_balance\nFROM shariah_compliant_finance\nORDER BY account_balance DESC\nLIMIT 1 OFFSET 2;", "raw_model_output": "```sql\nSELECT account_balance\nFROM shariah_compliant_finance\nORDER BY account_balance DESC\nLIMIT 1 OFFSET 2;\n```", "latency_sec": 1.0433108806610107, "total_duration_sec": 0.738161949, "load_duration_sec": 0.043439167, "tokens_prompt": 174, "prompt_eval_sec": 0.052030247, "tokens_completion": 33, "completion_eval_sec": 0.642014957, "tokens_total": 207, "tokens_per_sec": 198.40682565186222, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the third highest account balance. The reference query uses RANK() to find the third rank, while the generated query uses ORDER BY with LIMIT 1 OFFSET 2. In the given dataset with unique values, both approaches yield the same result (7000).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent. The Reference SQL uses RANK() to identify the third distinct rank, which handles ties properly (e.g., if multiple customers have the same balance). The Generated SQL uses LIMIT/OFFSET, which directly picks the third record in sorted order. In the provided sample data (no duplicates), both return 7000, but in cases with duplicates, they would differ. The Reference SQL better fulfills the business intent of finding the 'third highest' (distinct rank) balance, while the Generated SQL retrieves the third record, which may not align with the intent if duplicates exist. The Reference is more robust for edge cases.", "overall_assessment": "differently_correct"}}
{"example_id": 3795, "sql_complexity": "single join", "prompt": "What is the total quantity of unsold garments for each manufacturer based in 'Italy' or 'Spain'?", "context": "CREATE TABLE manufacturers (id INT PRIMARY KEY, name VARCHAR(255), country VARCHAR(255)); CREATE TABLE garments (id INT PRIMARY KEY, manufacturer_id INT, quantity_manufactured INT, quantity_sold INT);", "reference_sql": "SELECT m.name, SUM(g.quantity_manufactured - g.quantity_sold) as total_unsold_quantity FROM manufacturers m JOIN garments g ON m.id = g.manufacturer_id WHERE m.country IN ('Italy', 'Spain') GROUP BY m.name;", "generated_sql": "SELECT\n  m.name,\n  SUM(g.quantity_manufactured - g.quantity_sold) AS total_unsold_garments\nFROM manufacturers AS m\nJOIN garments AS g\n  ON m.id = g.manufacturer_id\nWHERE\n  m.country IN ('Italy', 'Spain')\nGROUP BY\n  m.name;", "raw_model_output": "```sql\nSELECT\n  m.name,\n  SUM(g.quantity_manufactured - g.quantity_sold) AS total_unsold_garments\nFROM manufacturers AS m\nJOIN garments AS g\n  ON m.id = g.manufacturer_id\nWHERE\n  m.country IN ('Italy', 'Spain')\nGROUP BY\n  m.name;\n```", "latency_sec": 1.9086790084838867, "total_duration_sec": 1.706625265, "load_duration_sec": 0.029214995, "tokens_prompt": 148, "prompt_eval_sec": 0.042687315, "tokens_completion": 83, "completion_eval_sec": 1.633374607, "tokens_total": 231, "tokens_per_sec": 121.02611228668005, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. The only differences are: 1) column alias name ('total_unsold_quantity' vs 'total_unsold_garments') which doesn't affect result computation, 2) use of 'AS' keyword in JOIN clause (optional syntax), and 3) whitespace/formatting. The core logic of joining manufacturers with garments, filtering by country, and calculating the unsold quantity remains identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are structurally identical in logic, syntax, and result structure. The only differences are stylistic: the reference query uses implicit JOIN syntax while the generated query uses explicit JOIN syntax with AS keywords. The column alias differs ('total_unsold_quantity' vs 'total_unsold_garments'), but this doesn't affect the calculation. Both correctly calculate unsold quantity as (manufactured - sold), filter by Italy/Spain manufacturers, and group by manufacturer name. The business intent of measuring unsold inventory for European manufacturers is fully addressed.", "overall_assessment": "correct"}}
{"example_id": 4138, "sql_complexity": "window functions", "prompt": "How many lifelong learning courses has a student with ID '2' completed, in chronological order?", "context": "CREATE TABLE lifelong_learning (student_id INT, course_id INT, completion_date DATE); INSERT INTO lifelong_learning VALUES (2, 1001, '2015-01-01'), (2, 1002, '2016-01-01');", "reference_sql": "SELECT student_id, course_id, COUNT(course_id) OVER (PARTITION BY student_id ORDER BY completion_date) as completed_courses FROM lifelong_learning WHERE student_id = 2;", "generated_sql": "SELECT\n  COUNT(course_id)\nFROM lifelong_learning\nWHERE\n  student_id = 2\nORDER BY\n  completion_date;", "raw_model_output": "```sql\nSELECT\n  COUNT(course_id)\nFROM lifelong_learning\nWHERE\n  student_id = 2\nORDER BY\n  completion_date;\n```", "latency_sec": 1.0327701568603516, "total_duration_sec": 0.837737244, "load_duration_sec": 0.028538209, "tokens_prompt": 168, "prompt_eval_sec": 0.052046969, "tokens_completion": 39, "completion_eval_sec": 0.756216164, "tokens_total": 207, "tokens_per_sec": 200.43181788800467, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns multiple rows with a running count of courses per student, while the Generated SQL returns a single aggregated count. The Reference includes student_id, course_id, and a window function-based count, whereas the Generated SQL only returns a total count without per-row details.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL calculates a running total of courses per completion date for student 2, returning multiple rows with cumulative counts (e.g., 1 and 2 for the sample data). The Generated SQL correctly returns a single total count of courses (2) for student 2. While both queries filter for student_id = 2, the Reference SQL's window function misinterprets the requirement for 'how many' courses (a scalar value) by producing a running tally. The Generated SQL's ORDER BY is redundant for a count but doesn't affect correctness. The original question asks for a simple count, not a chronological breakdown, making the Generated SQL the accurate choice.", "overall_assessment": "incorrect"}}
{"example_id": 312, "sql_complexity": "aggregation", "prompt": "List the top 3 most represented ethnicities in movies produced in the USA.", "context": "CREATE TABLE movies (title VARCHAR(255), production_country VARCHAR(64), lead_actor_ethnicity VARCHAR(64));", "reference_sql": "SELECT lead_actor_ethnicity, COUNT(*) AS count FROM movies WHERE production_country = 'USA' GROUP BY lead_actor_ethnicity ORDER BY count DESC LIMIT 3;", "generated_sql": "SELECT lead_actor_ethnicity\nFROM movies\nWHERE production_country = 'USA'\nGROUP BY lead_actor_ethnicity\nORDER BY COUNT(*) DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT lead_actor_ethnicity\nFROM movies\nWHERE production_country = 'USA'\nGROUP BY lead_actor_ethnicity\nORDER BY COUNT(*) DESC\nLIMIT 3;\n```", "latency_sec": 1.0113770961761475, "total_duration_sec": 0.940763568, "load_duration_sec": 0.028371276, "tokens_prompt": 125, "prompt_eval_sec": 0.037184346, "tokens_completion": 45, "completion_eval_sec": 0.874429892, "tokens_total": 170, "tokens_per_sec": 168.08765063272878, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a COUNT(*) column in the output, while the Generated SQL only returns the lead_actor_ethnicity column. Although both queries group by lead_actor_ethnicity and order by count, the result sets differ in structure (one has two columns, the other has one).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because the reference query includes a COUNT(*) column in the output while the generated query does not. However, both correctly identify the top 3 ethnicities by grouping, filtering, and ordering by count. The generated query is more efficient as it avoids unnecessary column projection, and the original question only explicitly asks for the list of ethnicities (not their counts). Both fulfill the business intent, but the generated query is more elegant and efficient.", "overall_assessment": "differently_correct"}}
{"example_id": 4298, "sql_complexity": "single join", "prompt": "How many users joined the gym in Q1 2023?", "context": "CREATE TABLE memberships (id INT, user_id INT, join_date DATE); INSERT INTO memberships (id, user_id, join_date) VALUES (1, 5, '2023-01-15'), (2, 6, '2023-02-03'), (3, 7, '2023-03-20'), (4, 8, '2022-12-31');", "reference_sql": "SELECT COUNT(*) FROM memberships WHERE join_date BETWEEN '2023-01-01' AND '2023-03-31';", "generated_sql": "SELECT\n  COUNT(user_id)\nFROM memberships\nWHERE\n  STRFTIME('%Y', join_date) = '2023' AND STRFTIME('%m', join_date) BETWEEN '01' AND '03';", "raw_model_output": "```sql\nSELECT\n  COUNT(user_id)\nFROM memberships\nWHERE\n  STRFTIME('%Y', join_date) = '2023' AND STRFTIME('%m', join_date) BETWEEN '01' AND '03';\n```", "latency_sec": 1.5784480571746826, "total_duration_sec": 1.276598719, "load_duration_sec": 0.028517852, "tokens_prompt": 199, "prompt_eval_sec": 0.068859483, "tokens_completion": 60, "completion_eval_sec": 1.178512797, "tokens_total": 259, "tokens_per_sec": 164.08522207793953, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count memberships joined in the first quarter of 2023. The reference uses a date range (BETWEEN '2023-01-01' AND '2023-03-31'), while the generated query uses STRFTIME to filter by year '2023' and months 01-03. Both approaches capture the same date range (January-March 2023).", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries correctly count users who joined in Q1 2023. The reference query uses a simple date range filter (BETWEEN '2023-01-01' AND '2023-03-31') which is semantically equivalent to the generated query's STRFTIME-based conditions. However, the reference query is more efficient as it allows for index utilization on the join_date column, while the generated query requires function-based filtering. The reference also uses standard SQL without database-specific functions (STRFTIME), making it more portable. Both handle the sample data correctly, but the reference is technically superior for performance and simplicity.", "overall_assessment": "correct"}}
{"example_id": 5211, "sql_complexity": "multiple_joins", "prompt": "What is the average transaction value in the last week, split by product category and customer demographics?", "context": "CREATE TABLE transactions (transaction_id INT, customer_id INT, product_id INT, category_id INT, transaction_date DATE, amount DECIMAL(10,2)); CREATE TABLE customers (customer_id INT, age INT, gender VARCHAR(10), location VARCHAR(255)); CREATE TABLE products (product_id INT, name VARCHAR(255), category_id INT);", "reference_sql": "SELECT c.age, c.gender, p.category_id, AVG(t.amount) as avg_transaction_value FROM transactions t INNER JOIN customers c ON t.customer_id = c.customer_id INNER JOIN products p ON t.product_id = p.product_id WHERE t.transaction_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 WEEK) GROUP BY c.age, c.gender, p.category_id;", "generated_sql": "SELECT\n  p.category_id,\n  c.age,\n  c.gender,\n  AVG(t.amount) AS average_transaction_value\nFROM transactions AS t\nJOIN customers AS c\n  ON t.customer_id = c.customer_id\nJOIN products AS p\n  ON t.product_id = p.product_id\nWHERE\n  t.transaction_date >= DATE('now', '-7 days')\nGROUP BY\n  p.category_id,\n  c.age,\n  c.gender;", "raw_model_output": "```sql\nSELECT\n  p.category_id,\n  c.age,\n  c.gender,\n  AVG(t.amount) AS average_transaction_value\nFROM transactions AS t\nJOIN customers AS c\n  ON t.customer_id = c.customer_id\nJOIN products AS p\n  ON t.product_id = p.product_id\nWHERE\n  t.transaction_date >= DATE('now', '-7 days')\nGROUP BY\n  p.category_id,\n  c.age,\n  c.gender;\n```", "latency_sec": 2.7645230293273926, "total_duration_sec": 2.561253391, "load_duration_sec": 0.029221665, "tokens_prompt": 182, "prompt_eval_sec": 0.053121616, "tokens_completion": 125, "completion_eval_sec": 2.477735847, "tokens_total": 307, "tokens_per_sec": 111.04989784610078, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform the same joins, filter transactions from the last week using equivalent date calculations (DATE_SUB/CURRENT_DATE vs DATE('now', '-7 days')), and group by the same columns (age, gender, category_id). The select list order and alias differ but do not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the average transaction value for the last week, grouped by product category and customer demographics (age/gender). The reference uses MySQL's DATE_SUB function while the generated query uses SQLite's DATE('now', '-7 days') syntax. These date functions are semantically equivalent for this purpose. The GROUP BY clauses and column selections are identical in logic and output. Both queries omit customer location, which is not explicitly required by the original question's 'demographics' specification. The generated query uses modern AS syntax but the reference is equally valid. No significant efficiency differences exist between the two approaches.", "overall_assessment": "correct"}}
{"example_id": 382, "sql_complexity": "window functions", "prompt": "What is the average annual precipitation in the past 10 years for each weather station?", "context": "CREATE TABLE WeatherStation (ID INT, Name VARCHAR(100), Location VARCHAR(100), Elevation FLOAT, AnnualPrecipitation FLOAT); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (1, 'Station A', 'Arctic Circle', 100, 450); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (2, 'Station B', 'North Pole', 200, 300);", "reference_sql": "SELECT Name, AVG(AnnualPrecipitation) OVER (PARTITION BY Name ORDER BY Name ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS AvgAnnualPrecipitation FROM WeatherStation WHERE YEAR(CurrentDate) - YEAR(DateInstalled) BETWEEN 1 AND 10;", "generated_sql": "SELECT\n  Name,\n  AVG(AnnualPrecipitation) AS AverageAnnualPrecipitation\nFROM WeatherStation\nGROUP BY\n  Name;", "raw_model_output": "```sql\nSELECT\n  Name,\n  AVG(AnnualPrecipitation) AS AverageAnnualPrecipitation\nFROM WeatherStation\nGROUP BY\n  Name;\n```", "latency_sec": 0.9185512065887451, "total_duration_sec": 0.821649133, "load_duration_sec": 0.02861004, "tokens_prompt": 209, "prompt_eval_sec": 0.070247195, "tokens_completion": 37, "completion_eval_sec": 0.721636407, "tokens_total": 246, "tokens_per_sec": 267.8130497629834, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL references a non-existent 'DateInstalled' column in its WHERE clause, making it invalid. The Generated SQL uses GROUP BY to aggregate AnnualPrecipitation by Name, while the Reference SQL attempts to use a window function. Even if the WHERE clause were valid, the window function (which would return the same value as the original column for unique Names) differs semantically from GROUP BY aggregation. Additionally, the Reference SQL's window function logic is redundant in this schema due to unique Names.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query contains a critical error: it references a 'DateInstalled' column that does not exist in the WeatherStation table. The generated query is syntactically correct and properly groups by station name to calculate the average annual precipitation. However, neither query addresses the 'past 10 years' requirement because the schema design is flawed - the AnnualPrecipitation column appears to store a single value per station rather than yearly data. The generated query would return the same value for each station (since there's only one AnnualPrecipitation value per station), while the reference query would fail entirely.", "overall_assessment": "incorrect"}}
{"example_id": 2190, "sql_complexity": "single join", "prompt": "What is the total number of humanitarian assistance events by each country in the last 3 years?", "context": "CREATE TABLE Humanitarian_Assistance (id INT, country VARCHAR(50), year INT, events INT); CREATE TABLE Countries (id INT, name VARCHAR(50), region VARCHAR(50));", "reference_sql": "SELECT co.name, SUM(ha.events) FROM Humanitarian_Assistance ha INNER JOIN Countries co ON ha.country = co.name WHERE ha.year BETWEEN (YEAR(CURRENT_DATE) - 3) AND YEAR(CURRENT_DATE) GROUP BY co.name;", "generated_sql": "SELECT\n  c.name,\n  SUM(ha.events) AS total_events\nFROM Humanitarian_Assistance AS ha\nJOIN Countries AS c\n  ON ha.country = c.id\nWHERE\n  ha.year >= strftime('%Y', 'now') - 3\nGROUP BY\n  c.name;", "raw_model_output": "```sql\nSELECT\n  c.name,\n  SUM(ha.events) AS total_events\nFROM Humanitarian_Assistance AS ha\nJOIN Countries AS c\n  ON ha.country = c.id\nWHERE\n  ha.year >= strftime('%Y', 'now') - 3\nGROUP BY\n  c.name;\n```", "latency_sec": 1.669154167175293, "total_duration_sec": 1.569335044, "load_duration_sec": 0.039011871, "tokens_prompt": 140, "prompt_eval_sec": 0.041541847, "tokens_completion": 76, "completion_eval_sec": 1.488012087, "tokens_total": 216, "tokens_per_sec": 129.40686022162737, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their join conditions. The Reference SQL joins on 'ha.country = co.name' (country name matching), while the Generated SQL joins on 'ha.country = c.id' (assuming country names are numeric IDs, which contradicts the schema where 'Countries.id' is an INT and 'Countries.name' is the actual country name). This fundamental difference in join logic ensures they are not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ fundamentally in their join conditions and date logic. The Reference SQL correctly joins Humanitarian_Assistance.country with Countries.name (both VARCHAR) and uses YEAR(CURRENT_DATE) to capture the last 3 years. The Generated SQL incorrectly joins on ha.country = c.id (mismatched INT/VARCHAR types) and uses strftime('%Y', 'now') - 3, which produces a string result compared to integer years. This would cause type conversion errors and incorrect filtering. While both aggregate events by country, the Generated SQL's technical flaws prevent it from fulfilling the business intent.", "overall_assessment": "incorrect"}}
{"example_id": 1852, "sql_complexity": "set operations", "prompt": "Compare coal production and employment rates in China and India between 2018 and 2020.", "context": "CREATE TABLE china_coal_production (year INT, production FLOAT); INSERT INTO china_coal_production (year, production) VALUES (2018, 3500.0), (2019, 3600.0), (2020, 3700.0); CREATE TABLE china_employment (year INT, employment FLOAT); INSERT INTO china_employment (year, employment) VALUES (2018, 8000000.0), (2019, 8100000.0), (2020, 8200000.0); CREATE TABLE india_coal_production (year INT, production FLOAT); INSERT INTO india_coal_production (year, production) VALUES (2018, 700.0), (2019, 750.0), (2020, 800.0); CREATE TABLE india_employment (year INT, employment FLOAT); INSERT INTO india_employment (year, employment) VALUES (2018, 1000000.0), (2019, 1050000.0), (2020, 1100000.0);", "reference_sql": "SELECT 'China' AS country, china_coal_production.production, china_employment.employment FROM china_coal_production INNER JOIN china_employment ON china_coal_production.year = china_employment.year WHERE china_coal_production.year BETWEEN 2018 AND 2020 UNION ALL SELECT 'India', india_coal_production.production, india_employment.employment FROM india_coal_production INNER JOIN india_employment ON india_coal_production.year = india_employment.year WHERE india_coal_production.year BETWEEN 2018 AND 2020;", "generated_sql": "SELECT\n  'China' AS country,\n  year,\n  production AS coal_production,\n  employment\nFROM china_coal_production\nJOIN china_employment\n  ON china_coal_production.year = china_employment.year\nWHERE\n  year BETWEEN 2018 AND 2020\nUNION ALL\nSELECT\n  'India' AS country,\n  year,\n  production AS coal_production,\n  employment\nFROM india_coal_production\nJOIN india_employment\n  ON india_coal_production.year = india_employment.year\nWHERE\n  year BETWEEN 2018 AND 2020\nORDER BY\n  country,\n  year;", "raw_model_output": "```sql\nSELECT\n  'China' AS country,\n  year,\n  production AS coal_production,\n  employment\nFROM china_coal_production\nJOIN china_employment\n  ON china_coal_production.year = china_employment.year\nWHERE\n  year BETWEEN 2018 AND 2020\nUNION ALL\nSELECT\n  'India' AS country,\n  year,\n  production AS coal_production,\n  employment\nFROM india_coal_production\nJOIN india_employment\n  ON india_coal_production.year = india_employment.year\nWHERE\n  year BETWEEN 2018 AND 2020\nORDER BY\n  country,\n  year;\n```", "latency_sec": 3.412726879119873, "total_duration_sec": 3.385751086, "load_duration_sec": 0.02754887, "tokens_prompt": 386, "prompt_eval_sec": 0.133482141, "tokens_completion": 159, "completion_eval_sec": 3.223728206, "tokens_total": 545, "tokens_per_sec": 159.6963423397518, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Generated SQL includes an extra 'year' column and renames 'production' to 'coal_production', altering the result structure. Additionally, the Generated SQL adds an ORDER BY clause, which affects output ordering but not data content. The Reference SQL returns three columns (country, production, employment), while the Generated SQL returns four columns (country, year, coal_production, employment).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because the Generated SQL includes a 'year' column and adds an ORDER BY clause, while the Reference SQL omits the year and lacks sorting. Both correctly join tables and filter data, but the Generated SQL provides explicit year context (critical for comparison) and structured output. The Reference SQL's absence of the year column makes it harder to directly compare data across years. The Generated SQL better fulfills the business intent by explicitly showing year-based comparisons, which is essential for analyzing trends between 2018-2020. The added ORDER BY improves readability, making the Generated SQL more elegant and practical for analysis.", "overall_assessment": "differently_correct"}}
{"example_id": 2535, "sql_complexity": "subqueries", "prompt": "What is the maximum safety rating for vehicles in the vehiclesafety schema?", "context": "CREATE TABLE VehicleSafety (id INT, vehicle_id INT, safetyrating INT, PRIMARY KEY (id)); CREATE TABLE Vehicles (id INT, make VARCHAR(50), model VARCHAR(50), PRIMARY KEY (id)); CREATE TABLE LuxuryVehicles (id INT, vehicle_id INT, PRIMARY KEY (id), FOREIGN KEY (vehicle_id) REFERENCES Vehicles(id));", "reference_sql": "SELECT MAX(safetyrating) FROM vehicleSafety JOIN Vehicles ON vehicleSafety.vehicle_id = Vehicles.id WHERE EXISTS (SELECT * FROM LuxuryVehicles WHERE Vehicles.id = LuxuryVehicles.vehicle_id);", "generated_sql": "SELECT MAX(safetyrating) FROM VehicleSafety;", "raw_model_output": "```sql\nSELECT MAX(safetyrating) FROM VehicleSafety;\n```", "latency_sec": 0.4634280204772949, "total_duration_sec": 0.386854133, "load_duration_sec": 0.031523776, "tokens_prompt": 171, "prompt_eval_sec": 0.051318331, "tokens_completion": 16, "completion_eval_sec": 0.303178663, "tokens_total": 187, "tokens_per_sec": 403.514659746738, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters results to only include vehicles that exist in LuxuryVehicles (via the EXISTS clause), while the Generated SQL selects the maximum safetyrating from all entries in VehicleSafety without any filtering. The Generated SQL could include safety ratings from non-luxury vehicles, making the results potentially different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query incorrectly filters results to only include luxury vehicles via the EXISTS clause, while the original question makes no such requirement. The generated query directly retrieves the maximum safety rating from the VehicleSafety table as requested. The reference query would return a lower or equal value if not all vehicles are luxury vehicles, thus failing to answer the original question accurately. The generated query is both technically correct and more efficient, as it avoids unnecessary joins and subqueries.", "overall_assessment": "correct"}}
{"example_id": 2140, "sql_complexity": "aggregation", "prompt": "What was the total amount of minerals extracted in the 'north' region for each month in 2020?", "context": "CREATE TABLE extraction(id INT, location TEXT, month INT, year INT, minerals_extracted FLOAT);INSERT INTO extraction(id, location, month, year, minerals_extracted) VALUES (1, 'north', 1, 2020, 1500), (2, 'north', 2, 2020, 1800), (3, 'south', 1, 2020, 1200);", "reference_sql": "SELECT month, SUM(minerals_extracted) FROM extraction WHERE location = 'north' AND year = 2020 GROUP BY month;", "generated_sql": "SELECT\n  month,\n  SUM(minerals_extracted)\nFROM extraction\nWHERE\n  location = 'north' AND year = 2020\nGROUP BY\n  month;", "raw_model_output": "```sql\nSELECT\n  month,\n  SUM(minerals_extracted)\nFROM extraction\nWHERE\n  location = 'north' AND year = 2020\nGROUP BY\n  month;\n```", "latency_sec": 1.1126339435577393, "total_duration_sec": 1.018827675, "load_duration_sec": 0.028487003, "tokens_prompt": 205, "prompt_eval_sec": 0.06949447, "tokens_completion": 47, "completion_eval_sec": 0.919914362, "tokens_total": 252, "tokens_per_sec": 226.489584880189, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select the 'month' and sum of 'minerals_extracted' from the 'extraction' table where 'location' is 'north' and 'year' is 2020, grouping by 'month'. The only difference is formatting (line breaks and spacing), which does not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are syntactically identical and produce the same results. They correctly filter for 'north' location and 2020 year, group by month, and calculate the sum of minerals extracted. The structure, logic, and output match exactly. The generated SQL is essentially a formatted version of the reference query with no functional differences.", "overall_assessment": "correct"}}
{"example_id": 4779, "sql_complexity": "window functions", "prompt": "What is the average CO2 emission for the top 3 highest emitting countries since 2015?", "context": "CREATE TABLE emissions (country VARCHAR(50), year INT, co2_emission INT); INSERT INTO emissions (country, year, co2_emission) VALUES ('USA', 2015, 5373978000); INSERT INTO emissions (country, year, co2_emission) VALUES ('China', 2015, 10498600000); INSERT INTO emissions (country, year, co2_emission) VALUES ('India', 2015, 2633830000); INSERT INTO emissions (country, year, co2_emission) VALUES ('USA', 2016, 5518004000); INSERT INTO emissions (country, year, co2_emission) VALUES ('China', 2016, 10813000000); INSERT INTO emissions (country, year, co2_emission) VALUES ('India', 2016, 2799280000);", "reference_sql": "SELECT AVG(co2_emission) as avg_emission FROM (SELECT country, year, co2_emission, ROW_NUMBER() OVER (ORDER BY co2_emission DESC) as rn FROM emissions WHERE year >= 2015) t WHERE rn <= 3 GROUP BY country;", "generated_sql": "SELECT AVG(co2_emission)\nFROM emissions\nWHERE year >= 2015\nGROUP BY country\nORDER BY SUM(co2_emission) DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT AVG(co2_emission)\nFROM emissions\nWHERE year >= 2015\nGROUP BY country\nORDER BY SUM(co2_emission) DESC\nLIMIT 3;\n```", "latency_sec": 1.1613612174987793, "total_duration_sec": 1.063846883, "load_duration_sec": 0.028284861, "tokens_prompt": 333, "prompt_eval_sec": 0.119177739, "tokens_completion": 46, "completion_eval_sec": 0.915673671, "tokens_total": 379, "tokens_per_sec": 326.3411885031354, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL calculates the average of the top 3 highest CO2 emissions entries (regardless of country) grouped by country, while the Generated SQL calculates the average emissions per country, then orders by total emissions (SUM) and limits to 3 countries. The logic, grouping, and ordering criteria differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL incorrectly uses ROW_NUMBER() on individual rows rather than per-country totals, leading to potential duplicates from the same country in the top 3. It then groups by country, which would return separate averages for each country rather than a single average of the top 3. The Generated SQL groups by country and orders by SUM(co2_emission), which aligns with identifying top emitters, but its final AVG(co2_emission) calculates per-country averages instead of the average of the top 3 countries' totals. While both queries fail to fully address the question, the Generated SQL better captures the intent of ranking countries by total emissions, even though it has a critical flaw in the final aggregation.", "overall_assessment": "differently_correct"}}
{"example_id": 1015, "sql_complexity": "subqueries", "prompt": "List the top 3 most expensive eco-friendly products in Europe and their suppliers.", "context": "CREATE TABLE Suppliers (supplierID INT, supplierName VARCHAR(50), country VARCHAR(50)); CREATE TABLE Products (productID INT, productName VARCHAR(50), price DECIMAL(10,2), ecoFriendly BOOLEAN, supplierID INT);", "reference_sql": "SELECT P.productName, P.price, S.supplierName FROM (SELECT * FROM Products WHERE ecoFriendly = TRUE ORDER BY price DESC LIMIT 3) P JOIN Suppliers S ON P.supplierID = S.supplierID;", "generated_sql": "SELECT\n  p.productName,\n  p.price,\n  s.supplierName\nFROM Products AS p\nJOIN Suppliers AS s\n  ON p.supplierID = s.supplierID\nWHERE\n  p.ecoFriendly = TRUE AND s.country = 'Europe'\nORDER BY\n  p.price DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT\n  p.productName,\n  p.price,\n  s.supplierName\nFROM Products AS p\nJOIN Suppliers AS s\n  ON p.supplierID = s.supplierID\nWHERE\n  p.ecoFriendly = TRUE AND s.country = 'Europe'\nORDER BY\n  p.price DESC\nLIMIT 3;\n```", "latency_sec": 2.2963221073150635, "total_duration_sec": 1.639938087, "load_duration_sec": 0.028010223, "tokens_prompt": 149, "prompt_eval_sec": 0.042338082, "tokens_completion": 80, "completion_eval_sec": 1.568779015, "tokens_total": 229, "tokens_per_sec": 99.72468551798879, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their filtering conditions. The Reference SQL only filters for ecoFriendly = TRUE, while the Generated SQL adds an additional condition WHERE s.country = 'Europe'. This makes the Generated SQL more restrictive, potentially returning fewer or different results. Additionally, the Reference SQL applies ORDER BY and LIMIT to the Products table before joining, whereas the Generated SQL applies these after the join, which could affect result ordering if there are ties in price. However, the critical difference is the extra country filter in the Generated SQL.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference query is technically incorrect because it does not filter suppliers by 'Europe' in the WHERE clause, potentially including non-European suppliers. The Generated query correctly applies the 'Europe' country filter on suppliers. While both queries select eco-friendly products and order by price, the Reference's lack of geographic filtering means it may not fulfill the business intent of identifying European products. The Generated query is more precise, efficient, and directly addresses the requirement for European suppliers.", "overall_assessment": "differently_correct"}}
{"example_id": 3715, "sql_complexity": "aggregation", "prompt": "What is the average age of engines still in service for each engine type?", "context": "CREATE TABLE Engine (id INT, aircraft_id INT, engine_type VARCHAR(255), hours_since_last_service INT, manufacture_year INT); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (1, 1, 'GE90-115B', 500, 2000); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (2, 2, 'CFM56-5B', 1000, 1995); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (3, 1, 'GE90-115B', 700, 2002);", "reference_sql": "SELECT engine_type, AVG(YEAR(CURRENT_DATE) - manufacture_year) as avg_age FROM Engine GROUP BY engine_type;", "generated_sql": "SELECT\n  engine_type,\n  AVG(YEAR(CURRENT_TIMESTAMP) - manufacture_year) AS average_age\nFROM Engine\nGROUP BY\n  engine_type;", "raw_model_output": "```sql\nSELECT\n  engine_type,\n  AVG(YEAR(CURRENT_TIMESTAMP) - manufacture_year) AS average_age\nFROM Engine\nGROUP BY\n  engine_type;\n```", "latency_sec": 1.1918220520019531, "total_duration_sec": 0.990589501, "load_duration_sec": 0.028244075, "tokens_prompt": 292, "prompt_eval_sec": 0.092120124, "tokens_completion": 44, "completion_eval_sec": 0.869392645, "tokens_total": 336, "tokens_per_sec": 281.9212813151148, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average age of engines by engine type. The only difference is the use of CURRENT_DATE vs. CURRENT_TIMESTAMP in the YEAR() function. Since YEAR() extracts the year part from both date and timestamp values, the result of YEAR(CURRENT_DATE) and YEAR(CURRENT_TIMESTAMP) will be identical. The column alias difference (avg_age vs. average_age) does not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": false, "superiority": "equal", "explanation": "Both queries are technically equivalent as they calculate the average age by subtracting the manufacture year from the current year (YEAR(CURRENT_DATE) vs. YEAR(CURRENT_TIMESTAMP)). However, neither query properly addresses the business intent of calculating the average age of engines 'still in service' because the Engine table lacks a status field to filter active engines. The original question assumes a business rule (engines in service) not enforced in the schema, making both queries incomplete. The generated query is slightly more precise with CURRENT_TIMESTAMP, but this doesn't impact the year calculation. Neither query fulfills the intent due to missing service status filtering.", "overall_assessment": "differently_correct"}}
{"example_id": 1957, "sql_complexity": "set operations", "prompt": "What is the average temperature recorded for the 'polar_bear' species in the 'Arctic_Animals' table compared to the 'penguin' species in the 'Antarctic_Animals' table?", "context": "CREATE TABLE Arctic_Animals (species TEXT, avg_temp FLOAT); CREATE TABLE Antarctic_Animals (species TEXT, avg_temp FLOAT);", "reference_sql": "SELECT AVG(Arctic_Animals.avg_temp) FROM Arctic_Animals WHERE Arctic_Animals.species = 'polar_bear' INTERSECT SELECT AVG(Antarctic_Animals.avg_temp) FROM Antarctic_Animals WHERE Antarctic_Animals.species = 'penguin'", "generated_sql": "SELECT AVG(CASE WHEN species = 'polar_bear' THEN avg_temp ELSE NULL END) AS arctic_avg_temp,\n       AVG(CASE WHEN species = 'penguin' THEN avg_temp ELSE NULL END) AS antarctic_avg_temp\nFROM Arctic_Animals\nFULL OUTER JOIN Antarctic_Animals ON 1=1;", "raw_model_output": "```sql\nSELECT AVG(CASE WHEN species = 'polar_bear' THEN avg_temp ELSE NULL END) AS arctic_avg_temp,\n       AVG(CASE WHEN species = 'penguin' THEN avg_temp ELSE NULL END) AS antarctic_avg_temp\nFROM Arctic_Animals\nFULL OUTER JOIN Antarctic_Animals ON 1=1;\n```", "latency_sec": 1.7761757373809814, "total_duration_sec": 1.580997002, "load_duration_sec": 0.028321267, "tokens_prompt": 147, "prompt_eval_sec": 0.042209839, "tokens_completion": 77, "completion_eval_sec": 1.50963264, "tokens_total": 224, "tokens_per_sec": 126.11364702588156, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL computes the average temperature for 'polar_bear' in Arctic_Animals and 'penguin' in Antarctic_Animals, then returns their intersection (only matching values). The Generated SQL calculates both averages in a single query using a Cartesian product (FULL OUTER JOIN ON 1=1), which would aggregate all rows from both tables. The results differ in structure (single value vs. two columns) and logic (intersection vs. combined aggregation).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is fundamentally flawed because it uses INTERSECT, which returns only matching values between two queries. This would only return a result if the average temperatures for both species were identical, which is not the intended comparison. The Generated SQL attempts to calculate both averages in a single query but has critical issues: 1) The FULL OUTER JOIN ON 1=1 creates a Cartesian product, leading to incorrect aggregation; 2) The CASE statements lack table qualifiers for 'species' and 'avg_temp', causing ambiguous column references. While the Generated SQL better aligns with the intent of comparing both averages, its technical implementation is incorrect. Neither query fully satisfies the requirements, but the Generated SQL's approach is more conceptually aligned with the business question.", "overall_assessment": "differently_correct"}}
{"example_id": 1311, "sql_complexity": "basic SQL", "prompt": "What is the total number of veteran job applications in Texas in the last year?", "context": "CREATE TABLE veteran_jobs (id INT, state VARCHAR(50), application_date DATE); INSERT INTO veteran_jobs (id, state, application_date) VALUES (1, 'Texas', '2021-02-15'), (2, 'California', '2021-04-10'), (3, 'Texas', '2022-01-05');", "reference_sql": "SELECT COUNT(*) FROM veteran_jobs WHERE state = 'Texas' AND application_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR);", "generated_sql": "SELECT COUNT(*)\nFROM veteran_jobs\nWHERE state = 'Texas'\nAND application_date >= DATE('now', '-1 year');", "raw_model_output": "```sql\nSELECT COUNT(*)\nFROM veteran_jobs\nWHERE state = 'Texas'\nAND application_date >= DATE('now', '-1 year');\n```", "latency_sec": 0.9055559635162354, "total_duration_sec": 0.766391629, "load_duration_sec": 0.028991072, "tokens_prompt": 185, "prompt_eval_sec": 0.055880851, "tokens_completion": 35, "completion_eval_sec": 0.680781296, "tokens_total": 220, "tokens_per_sec": 242.94467582737718, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count records where state is 'Texas' and application_date is within the last year. DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR) and DATE('now', '-1 year') both calculate the date one year before the current date. The logical condition (application_date >= [one year ago]) is equivalent in both queries.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries differ in date calculation syntax. The reference uses standard SQL DATE_SUB function, while the generated query uses SQLite-specific DATE('now', '-1 year') syntax. Although both aim to calculate the date one year prior, the generated query's syntax is not universally portable across all SQL databases. Both correctly filter for Texas applications, but the reference query is more technically robust and standard. The business intent of counting Texas veteran applications within the last year is fulfilled by both, but the reference query's syntax ensures broader compatibility.", "overall_assessment": "differently_correct"}}
{"example_id": 2997, "sql_complexity": "window functions", "prompt": "What is the earliest capture time for each satellite image in the 'satellite_images' table?", "context": "CREATE TABLE satellite_images (image_id INT, image_url TEXT, capture_time TIMESTAMP); INSERT INTO satellite_images (image_id, image_url, capture_time) VALUES (1, 'image1.jpg', '2022-01-01 10:00:00'), (2, 'image2.jpg', '2021-05-01 10:00:00');", "reference_sql": "SELECT image_id, MIN(capture_time) OVER (PARTITION BY image_id) FROM satellite_images;", "generated_sql": "SELECT MIN(capture_time) AS earliest_capture_time\nFROM satellite_images;", "raw_model_output": "```sql\nSELECT MIN(capture_time) AS earliest_capture_time\nFROM satellite_images;\n```", "latency_sec": 0.7965447902679443, "total_duration_sec": 0.590963402, "load_duration_sec": 0.042036668, "tokens_prompt": 199, "prompt_eval_sec": 0.068769165, "tokens_completion": 25, "completion_eval_sec": 0.479444139, "tokens_total": 224, "tokens_per_sec": 281.2145691451326, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns each image_id with its own capture_time (since MIN() over a single-row partition equals the row's value), producing two rows. The Generated SQL returns a single row with the absolute earliest capture_time across all images. The result structures and outputs differ.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query correctly addresses the requirement to find the earliest capture time for each satellite image. It uses a window function (MIN() OVER PARTITION BY image_id) which, although redundant in this specific schema (since each image_id has only one capture_time), technically fulfills the 'per image' requirement. The generated query incorrectly returns a single global minimum capture time instead of per-image results. While both queries are syntactically valid, they produce fundamentally different outputs: the reference returns per-image results (even if redundant) while the generated returns a single value. The reference better fulfills the business intent of analyzing individual image capture times.", "overall_assessment": "differently_correct"}}
{"example_id": 3743, "sql_complexity": "aggregation", "prompt": "What is the maximum budget spent on peacekeeping operations by each department?", "context": "CREATE TABLE DepartmentPeacekeeping (id INT, department VARCHAR(50), budget INT);", "reference_sql": "SELECT department, MAX(budget) FROM DepartmentPeacekeeping GROUP BY department;", "generated_sql": "SELECT department, MAX(budget) AS max_budget\nFROM DepartmentPeacekeeping\nGROUP BY department;", "raw_model_output": "```sql\nSELECT department, MAX(budget) AS max_budget\nFROM DepartmentPeacekeeping\nGROUP BY department;\n```", "latency_sec": 0.7501740455627441, "total_duration_sec": 0.582115067, "load_duration_sec": 0.028740227, "tokens_prompt": 111, "prompt_eval_sec": 0.033807692, "tokens_completion": 27, "completion_eval_sec": 0.518567452, "tokens_total": 138, "tokens_per_sec": 183.9573107284445, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries group by 'department' and calculate the maximum 'budget' for each group. The generated query adds an alias 'max_budget' to the MAX(budget) column, but this does not affect the semantic result (the actual data returned). The core logic and output values remain identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the maximum budget per department using GROUP BY and MAX(). The reference query omits an explicit alias for the calculated column, while the generated query adds 'AS max_budget' for clarity. Semantically, they produce identical results. The generated query improves readability by explicitly naming the computed column, making the output more intuitive for end-users. This minor enhancement does not alter the technical correctness or business intent fulfillment but makes the query slightly more elegant and user-friendly.", "overall_assessment": "correct"}}
{"example_id": 4664, "sql_complexity": "multiple_joins", "prompt": "Calculate the total number of volunteer hours contributed by volunteers from 'California' in 'Health' projects in 2021.", "context": "CREATE TABLE volunteers (volunteer_id INT, name VARCHAR(255), state VARCHAR(255));", "reference_sql": "SELECT SUM(vh.hours) as total_hours FROM volunteer_projects vp JOIN volunteer_hours vh ON vp.project_id = vh.project_id JOIN volunteers vol ON vh.volunteer_id = vol.volunteer_id WHERE vp.cause = 'Health' AND vol.state = 'California' AND vh.volunteer_date BETWEEN '2021-01-01' AND '2021-12-31';", "generated_sql": "-- Unable to answer question due to missing information. The database schema does not contain information about project names, project hours, or years.\n-- Returning 0 as a placeholder.\nSELECT 0;", "raw_model_output": "```sql\n-- Unable to answer question due to missing information. The database schema does not contain information about project names, project hours, or years.\n-- Returning 0 as a placeholder.\nSELECT 0;\n```", "latency_sec": 1.1544699668884277, "total_duration_sec": 0.978105467, "load_duration_sec": 0.029039023, "tokens_prompt": 129, "prompt_eval_sec": 0.03778212, "tokens_completion": 47, "completion_eval_sec": 0.910741617, "tokens_total": 176, "tokens_per_sec": 152.45091258143512, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the total hours volunteered by California residents on Health projects in 2021 through multiple table joins and aggregation. The Generated SQL simply returns a constant 0 value without any database queries. They cannot produce the same result unless the actual total hours happen to be 0, which is not guaranteed. The Generated SQL lacks all semantic complexity of the Reference SQL.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL assumes the existence of tables (volunteer_projects, volunteer_hours) not present in the provided schema, making it technically invalid. The Generated SQL correctly identifies missing schema elements (project details, hours, dates) and returns 0 as a placeholder, acknowledging the data gap. While neither query fully fulfills the intent due to schema limitations, the Generated SQL is more honest about the constraints. The Reference SQL's logic would fail in this context, while the Generated SQL avoids incorrect assumptions.", "overall_assessment": "differently_correct"}}
{"example_id": 251, "sql_complexity": "set operations", "prompt": "Compare the number of economic diversification projects in two regions, one in Europe and one in Oceania, by showing the project type and the number of projects in each region.", "context": "CREATE TABLE economic_diversification (region VARCHAR(50), project_type VARCHAR(50), project_start_date DATE);", "reference_sql": "SELECT 'Europe' as region, project_type, COUNT(*) as project_count FROM economic_diversification WHERE region = 'Europe' UNION ALL SELECT 'Oceania' as region, project_type, COUNT(*) as project_count FROM economic_diversification WHERE region = 'Oceania';", "generated_sql": "SELECT\n  project_type,\n  COUNT(*) AS project_count\nFROM economic_diversification\nWHERE\n  region IN ('Europe', 'Oceania')\nGROUP BY\n  project_type;", "raw_model_output": "```sql\nSELECT\n  project_type,\n  COUNT(*) AS project_count\nFROM economic_diversification\nWHERE\n  region IN ('Europe', 'Oceania')\nGROUP BY\n  project_type;\n```", "latency_sec": 1.2184100151062012, "total_duration_sec": 1.024856395, "load_duration_sec": 0.028734045, "tokens_prompt": 141, "prompt_eval_sec": 0.041612543, "tokens_completion": 49, "completion_eval_sec": 0.953862305, "tokens_total": 190, "tokens_per_sec": 155.9409374876477, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query separates counts by region (Europe and Oceania) with two distinct rows per project_type, while the generated query aggregates counts across both regions into a single row per project_type. The generated query's WHERE clause filters to only Europe/Oceania but groups by project_type, combining counts from both regions rather than separating them.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The Reference SQL correctly separates counts by region using UNION ALL, producing rows like ('Europe', 'TypeA', 5) and ('Oceania', 'TypeA', 3) for each project type. The Generated SQL aggregates both regions into a single count per project type (e.g., 'TypeA' with total 8), failing to distinguish between regions. While the Generated SQL is more efficient, it doesn't fulfill the business intent of comparing regions. The Reference SQL explicitly addresses the requirement to show regional breakdowns.", "overall_assessment": "differently_correct"}}
{"example_id": 610, "sql_complexity": "subqueries", "prompt": "What is the percentage of community development projects completed in 'Caribbean' in 2020?", "context": "CREATE TABLE community_projects (project_id INT, project_name TEXT, location TEXT, completion_year INT); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (1, 'Community Center', 'Southern Region, Caribbean', 2020); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (2, 'Park Renovation', 'Northern Region, Caribbean', 2019); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (3, 'Library Construction', 'Caribbean', 2020);", "reference_sql": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM community_projects WHERE location = 'Caribbean')) FROM community_projects WHERE completion_year = 2020 AND location = 'Caribbean';", "generated_sql": "SELECT CAST(SUM(CASE WHEN location = 'Caribbean' AND completion_year = 2020 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*)\nFROM community_projects;", "raw_model_output": "```sql\nSELECT CAST(SUM(CASE WHEN location = 'Caribbean' AND completion_year = 2020 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*)\nFROM community_projects;\n```", "latency_sec": 1.4368607997894287, "total_duration_sec": 1.155023605, "load_duration_sec": 0.028479634, "tokens_prompt": 242, "prompt_eval_sec": 0.080126883, "tokens_completion": 53, "completion_eval_sec": 1.045496664, "tokens_total": 295, "tokens_per_sec": 205.30868407241127, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the percentage of Caribbean projects completed in 2020 relative to all Caribbean projects (denominator: COUNT(*) from Caribbean projects). The Generated SQL calculates the percentage of 2020 Caribbean projects relative to all projects (denominator: COUNT(*) from entire table). The denominators differ, leading to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly calculates the percentage of Caribbean projects completed in 2020 by using the total Caribbean projects as the denominator. The generated query incorrectly uses the total projects (COUNT(*)) as the denominator instead of restricting to Caribbean projects, leading to a different business metric. Both queries have valid syntax, but their semantic outputs differ. The reference query directly addresses the question by focusing on the Caribbean subset, while the generated query measures a different ratio (Caribbean 2020 projects / total projects).", "overall_assessment": "incorrect"}}
{"example_id": 421, "sql_complexity": "set operations", "prompt": "What is the combined landfill capacity for 'City A' and 'City B'?", "context": "CREATE TABLE landfill_capacity (city VARCHAR(255), capacity INT); INSERT INTO landfill_capacity (city, capacity) VALUES ('City A', 500000), ('City B', 600000);", "reference_sql": "SELECT SUM(capacity) FROM (SELECT capacity FROM landfill_capacity WHERE city = 'City A' UNION ALL SELECT capacity FROM landfill_capacity WHERE city = 'City B') AS combined_capacity;", "generated_sql": "SELECT SUM(capacity) FROM landfill_capacity WHERE city IN ('City A', 'City B');", "raw_model_output": "```sql\nSELECT SUM(capacity) FROM landfill_capacity WHERE city IN ('City A', 'City B');\n```", "latency_sec": 0.842026948928833, "total_duration_sec": 0.574446922, "load_duration_sec": 0.029899614, "tokens_prompt": 147, "prompt_eval_sec": 0.0420515, "tokens_completion": 26, "completion_eval_sec": 0.50157331, "tokens_total": 173, "tokens_per_sec": 205.4566070837499, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of capacities for 'City A' and 'City B'. The reference query uses a subquery with UNION ALL to combine the two cities' capacities, while the generated query uses a WHERE clause with IN. Since UNION ALL preserves all rows (and there are no duplicates in this specific case), the final SUM is identical. The result is the same sum of 500,000 + 600,000 = 1,100,000.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the combined landfill capacity for 'City A' and 'City B'. The Reference SQL uses a subquery with UNION ALL to isolate each city's capacity before summing, while the Generated SQL directly filters and sums the relevant rows. Technically, they produce identical results. However, the Generated SQL is more efficient and elegant as it avoids unnecessary subquery complexity. Both fulfill the business intent of combining capacities, but the Generated query achieves this with simpler logic.", "overall_assessment": "correct"}}
{"example_id": 880, "sql_complexity": "aggregation", "prompt": "Show veteran employment statistics for each state in the 'veteran_employment' table", "context": "CREATE TABLE veteran_employment (employee_id INT, state VARCHAR(2), job_title VARCHAR(50), employment_date DATE);", "reference_sql": "SELECT state, COUNT(*) as veteran_employees FROM veteran_employment WHERE state IN ('CA', 'NY', 'TX', 'FL', 'PA') GROUP BY state;", "generated_sql": "SELECT state, COUNT(*) AS veteran_count\nFROM veteran_employment\nGROUP BY state;", "raw_model_output": "```sql\nSELECT state, COUNT(*) AS veteran_count\nFROM veteran_employment\nGROUP BY state;\n```", "latency_sec": 0.6461350917816162, "total_duration_sec": 0.549452619, "load_duration_sec": 0.027992749, "tokens_prompt": 125, "prompt_eval_sec": 0.037314086, "tokens_completion": 25, "completion_eval_sec": 0.483208899, "tokens_total": 150, "tokens_per_sec": 232.14959519749735, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters results to only include records where state is in ('CA', 'NY', 'TX', 'FL', 'PA'), while the Generated SQL includes all states. The GROUP BY logic is identical, but the WHERE clause in the Reference SQL restricts the dataset being aggregated, making the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query restricts results to specific states ('CA', 'NY', 'TX', 'FL', 'PA'), while the generated query includes all states present in the table. The original question asked for statistics 'for each state' in the table without specifying particular states, making the generated query more aligned with the explicit requirement to show data for all states. The reference query may have been intended for a different business context (e.g., focusing on specific regions). Both queries are technically correct, but the generated query better fulfills the stated business intent of showing statistics for every state in the dataset.", "overall_assessment": "differently_correct"}}
{"example_id": 454, "sql_complexity": "single join", "prompt": "Which excavation sites have more than 10 artifacts?", "context": "CREATE TABLE ExcavationSite (SiteID INT, SiteName VARCHAR(50)); INSERT INTO ExcavationSite (SiteID, SiteName) VALUES (1, 'Site A'), (2, 'Site B'), (3, 'Site C'); CREATE TABLE Artifact (ArtifactID INT, SiteID INT, ObjectType VARCHAR(50)); INSERT INTO Artifact (ArtifactID, SiteID, ObjectType) VALUES (1, 1, 'Pottery'), (2, 1, 'Tool'), (3, 2, 'Statue'), (4, 2, 'Bead'), (5, 3, 'Bead'), (6, 3, 'Bead'), (7, 3, 'Bead'), (8, 3, 'Bead'), (9, 3, 'Bead'), (10, 3, 'Bead'), (11, 3, 'Bead');", "reference_sql": "SELECT e.SiteName FROM ExcavationSite e JOIN Artifact a ON e.SiteID = a.SiteID GROUP BY e.SiteName HAVING COUNT(a.ArtifactID) > 10;", "generated_sql": "SELECT SiteName\nFROM ExcavationSite\nWHERE SiteID IN (SELECT SiteID FROM Artifact GROUP BY SiteID HAVING COUNT(*) > 10);", "raw_model_output": "```sql\nSELECT SiteName\nFROM ExcavationSite\nWHERE SiteID IN (SELECT SiteID FROM Artifact GROUP BY SiteID HAVING COUNT(*) > 10);\n```", "latency_sec": 1.1569437980651855, "total_duration_sec": 0.859644548, "load_duration_sec": 0.034611751, "tokens_prompt": 286, "prompt_eval_sec": 0.092413056, "tokens_completion": 37, "completion_eval_sec": 0.731560142, "tokens_total": 323, "tokens_per_sec": 279.18382944804137, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in how they group and filter. The Reference SQL groups by SiteName (which may combine multiple SiteIDs with the same name) and counts artifacts, while the Generated SQL filters SiteIDs directly with a subquery. If multiple SiteIDs share the same SiteName, the Reference SQL could aggregate artifacts across those sites, leading to different results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify excavation sites with more than 10 artifacts. The Reference SQL uses a JOIN and GROUP BY SiteName, which works in this case but is less efficient due to the join operation. The Generated SQL uses a subquery with WHERE SiteID IN (SELECT ...), which is more direct and avoids unnecessary joins. While both produce identical results, the Generated SQL is more efficient and aligns better with the business intent of counting artifacts per site using primary keys (SiteID) rather than potentially non-unique identifiers (SiteName).", "overall_assessment": "correct"}}
{"example_id": 1086, "sql_complexity": "aggregation", "prompt": "What is the total CO2 emission for each equipment type, excluding equipment that is older than 8 years?", "context": "CREATE TABLE EmissionData (EquipmentID INT, EquipmentType VARCHAR(50), CO2Emission INT, Age INT); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (1, 'Excavator', 50, 8); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (2, 'Haul Truck', 70, 7); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (3, 'Shovel', 30, 6); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (4, 'Drilling Rig', 40, 3);", "reference_sql": "SELECT EquipmentType, SUM(CO2Emission) as TotalCO2Emission FROM EmissionData WHERE Age <= 8 GROUP BY EquipmentType;", "generated_sql": "SELECT EquipmentType, SUM(CO2Emission)\nFROM EmissionData\nWHERE Age <= 8\nGROUP BY EquipmentType;", "raw_model_output": "```sql\nSELECT EquipmentType, SUM(CO2Emission)\nFROM EmissionData\nWHERE Age <= 8\nGROUP BY EquipmentType;\n```", "latency_sec": 0.8073170185089111, "total_duration_sec": 0.747343332, "load_duration_sec": 0.040051786, "tokens_prompt": 257, "prompt_eval_sec": 0.082228435, "tokens_completion": 32, "completion_eval_sec": 0.624066352, "tokens_total": 289, "tokens_per_sec": 357.9758550535375, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. The only difference is the presence of an alias (TotalCO2Emission) in the Reference SQL, which does not affect the semantic result set. Both queries select EquipmentType, sum CO2Emission, filter by Age <= 8, and group by EquipmentType.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are structurally identical except for the column alias in the SELECT clause. The reference query explicitly names the aggregated column 'TotalCO2Emission', while the generated query omits the alias. However, SQL does not require column aliases for correctness, and both queries will produce the same numerical results. The WHERE clause (Age <= 8) correctly filters out equipment older than 8 years, and the GROUP BY ensures aggregation by EquipmentType. Both queries technically fulfill the business intent of calculating total CO2 emissions per equipment type while excluding outdated equipment.", "overall_assessment": "correct"}}
{"example_id": 3455, "sql_complexity": "basic SQL", "prompt": "What are the names of all innovation projects in the 'rural_infrastructure' table, excluding those with a budget over 50000?", "context": "CREATE TABLE rural_infrastructure (name VARCHAR(255), budget INT); INSERT INTO rural_infrastructure (name, budget) VALUES ('Dam Construction', 40000), ('Well Digging', 30000), ('Irrigation System', 70000);", "reference_sql": "SELECT name FROM rural_infrastructure WHERE budget <= 50000;", "generated_sql": "SELECT name\nFROM rural_infrastructure\nWHERE budget <= 50000;", "raw_model_output": "```sql\nSELECT name\nFROM rural_infrastructure\nWHERE budget <= 50000;\n```", "latency_sec": 0.8472719192504883, "total_duration_sec": 0.544503288, "load_duration_sec": 0.028914077, "tokens_prompt": 172, "prompt_eval_sec": 0.051591023, "tokens_completion": 24, "completion_eval_sec": 0.46308389, "tokens_total": 196, "tokens_per_sec": 231.33069271714453, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the 'name' column from the 'rural_infrastructure' table where the 'budget' is less than or equal to 50000. The only difference is formatting (line breaks and spacing), which does not affect semantic meaning.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are syntactically valid and semantically identical. They select project names from the rural_infrastructure table where the budget is less than or equal to 50000, perfectly matching the business requirement to exclude projects with budgets over 50000. The reference query is a single-line version while the generated query uses formatting for readability, but they produce identical results. Both efficiently address the question by applying the correct filter condition.", "overall_assessment": "correct"}}
{"example_id": 3936, "sql_complexity": "window functions", "prompt": "What is the total investment per client for each investment type?", "context": "CREATE TABLE clients (client_id INT, name TEXT, investment_type TEXT, investment FLOAT); INSERT INTO clients (client_id, name, investment_type, investment) VALUES (1, 'John Doe', 'Stocks', 3000.00), (1, 'John Doe', 'Bonds', 2000.00), (2, 'Jane Smith', 'Stocks', 5000.00);", "reference_sql": "SELECT client_id, name, investment_type, SUM(investment) OVER (PARTITION BY client_id, investment_type ORDER BY client_id) as total_investment FROM clients;", "generated_sql": "SELECT client_id, investment_type, SUM(investment) AS total_investment\nFROM clients\nGROUP BY client_id, investment_type;", "raw_model_output": "```sql\nSELECT client_id, investment_type, SUM(investment) AS total_investment\nFROM clients\nGROUP BY client_id, investment_type;\n```", "latency_sec": 1.102491855621338, "total_duration_sec": 0.802915985, "load_duration_sec": 0.028384417, "tokens_prompt": 187, "prompt_eval_sec": 0.056197128, "tokens_completion": 37, "completion_eval_sec": 0.717438912, "tokens_total": 224, "tokens_per_sec": 203.17610407539834, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL uses a window function to retain all rows while adding a cumulative sum per client-investment type, including the 'name' column. The Generated SQL aggregates rows via GROUP BY, omitting 'name' and reducing rows to unique client-investment type combinations. Column differences and row count variations (retained vs aggregated) make them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query uses a window function to calculate a running total per client_id/investment_type, but retains individual rows with repeated totals. The generated query properly aggregates (GROUP BY) to produce one row per client-investment_type combination with the correct total. While both return similar numerical results, the generated query's structure aligns with the business requirement for 'total investment per client for each investment type' by collapsing duplicates and providing a clean summary. The reference query's inclusion of the name column and window function's ordering clause are unnecessary for this specific question.", "overall_assessment": "differently_correct"}}
{"example_id": 1838, "sql_complexity": "window functions", "prompt": "What are the top 3 species with the most sightings across all arctic research stations?", "context": "CREATE TABLE research_station (id INT, name TEXT); INSERT INTO research_station (id, name) VALUES (1, 'Station A'); INSERT INTO research_station (id, name) VALUES (2, 'Station B'); CREATE TABLE species_observations (station_id INT, species_name TEXT, sightings INT); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (1, 'Species 1', 10); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (1, 'Species 2', 5); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (2, 'Species 1', 8); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (2, 'Species 3', 15);", "reference_sql": "SELECT species_name, SUM(sightings) as total_sightings, RANK() OVER (ORDER BY SUM(sightings) DESC) as rank FROM species_observations GROUP BY species_name HAVING rank <= 3;", "generated_sql": "SELECT species_name\nFROM species_observations\nORDER BY sightings DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT species_name\nFROM species_observations\nORDER BY sightings DESC\nLIMIT 3;\n```", "latency_sec": 0.8172600269317627, "total_duration_sec": 0.616040063, "load_duration_sec": 0.034276535, "tokens_prompt": 278, "prompt_eval_sec": 0.090182621, "tokens_completion": 25, "completion_eval_sec": 0.487611536, "tokens_total": 303, "tokens_per_sec": 370.7510339610664, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates total sightings per species, ranks them, and returns top 3. The Generated SQL orders individual sightings records (not aggregated) and limits to 3, which may include multiple entries from the same species. For example, the Reference would return 'Species 1' (18), 'Species 3' (15), 'Species 2' (5), while the Generated could return 'Species 3' (15), 'Species 1' (10), 'Species 1' (8). The aggregation and ranking logic differ, leading to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL attempts to aggregate sightings per species and rank them, but contains a technical error: the HAVING clause cannot reference the RANK() window function, which is evaluated after aggregation. The Generated SQL fails to aggregate sightings across stations, instead sorting individual observations (not totals) and returning only 3 rows without considering species-wide totals. While both queries are technically flawed, the Reference SQL better aligns with the business intent of summing sightings across all stations, even though it requires correction.", "overall_assessment": "incorrect"}}
{"example_id": 3091, "sql_complexity": "single join", "prompt": "Find the number of hybrid vehicles sold in the US, Germany, and Japan.", "context": "CREATE TABLE vehicle_sales (sale_id INT, vehicle_id INT, country VARCHAR(20), quantity INT); CREATE TABLE vehicles (vehicle_id INT, model VARCHAR(20), manufacture VARCHAR(20), vehicle_type VARCHAR(20));", "reference_sql": "SELECT SUM(vs.quantity) FROM vehicle_sales vs JOIN vehicles v ON vs.vehicle_id = v.vehicle_id WHERE v.vehicle_type = 'hybrid' AND vs.country IN ('US', 'Germany', 'Japan');", "generated_sql": "SELECT\n  SUM(vehicle_sales.quantity)\nFROM vehicle_sales\nJOIN vehicles\n  ON vehicle_sales.vehicle_id = vehicles.vehicle_id\nWHERE\n  vehicles.vehicle_type = 'hybrid' AND country IN ('US', 'Germany', 'Japan');", "raw_model_output": "```sql\nSELECT\n  SUM(vehicle_sales.quantity)\nFROM vehicle_sales\nJOIN vehicles\n  ON vehicle_sales.vehicle_id = vehicles.vehicle_id\nWHERE\n  vehicles.vehicle_type = 'hybrid' AND country IN ('US', 'Germany', 'Japan');\n```", "latency_sec": 1.4592041969299316, "total_duration_sec": 1.362849051, "load_duration_sec": 0.028463317, "tokens_prompt": 150, "prompt_eval_sec": 0.042273401, "tokens_completion": 66, "completion_eval_sec": 1.291439403, "tokens_total": 216, "tokens_per_sec": 148.02589003955006, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between vehicle_sales and vehicles on vehicle_id, filter where vehicle_type is 'hybrid' and country is in ('US', 'Germany', 'Japan'), and calculate the sum of quantity. The only differences are aliasing conventions and explicit table qualification in the SUM expression, which do not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the total quantity of hybrid vehicles sold in the specified countries. They share identical logic: joining vehicle_sales with vehicles on vehicle_id, filtering for 'hybrid' vehicle_type, and summing quantities where country is in ('US', 'Germany', 'Japan'). The only difference is aliasing (reference uses vs/v, generated uses full table names), which doesn't affect results. Both are equally efficient and semantically equivalent. The generated query avoids aliases but maintains clarity. Neither query has syntax errors or logical flaws.", "overall_assessment": "correct"}}
{"example_id": 2399, "sql_complexity": "set operations", "prompt": "What is the average duration of criminal trials for Indigenous defendants compared to non-Indigenous defendants in Canada and New Zealand?", "context": "CREATE TABLE canada_criminal_trials (id INT, defendant_type VARCHAR(255), days_to_completion INT); INSERT INTO canada_criminal_trials (id, defendant_type, days_to_completion) VALUES (1, 'Indigenous', 60), (2, 'Non-Indigenous', 45);CREATE TABLE nz_criminal_trials (id INT, defendant_type VARCHAR(255), days_to_completion INT); INSERT INTO nz_criminal_trials (id, defendant_type, days_to_completion) VALUES (1, 'Indigenous', 70), (2, 'Non-Indigenous', 50);", "reference_sql": "SELECT AVG(days_to_completion) AS avg_duration FROM canada_criminal_trials WHERE defendant_type = 'Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM canada_criminal_trials WHERE defendant_type = 'Non-Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM nz_criminal_trials WHERE defendant_type = 'Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM nz_criminal_trials WHERE defendant_type = 'Non-Indigenous';", "generated_sql": "SELECT\n  defendant_type,\n  AVG(days_to_completion) AS average_duration\nFROM (\n  SELECT\n    defendant_type,\n    days_to_completion\n  FROM canada_criminal_trials\n  UNION ALL\n  SELECT\n    defendant_type,\n    days_to_completion\n  FROM nz_criminal_trials\n) AS combined_trials\nGROUP BY\n  defendant_type;", "raw_model_output": "```sql\nSELECT\n  defendant_type,\n  AVG(days_to_completion) AS average_duration\nFROM (\n  SELECT\n    defendant_type,\n    days_to_completion\n  FROM canada_criminal_trials\n  UNION ALL\n  SELECT\n    defendant_type,\n    days_to_completion\n  FROM nz_criminal_trials\n) AS combined_trials\nGROUP BY\n  defendant_type;\n```", "latency_sec": 2.0632691383361816, "total_duration_sec": 2.04016084, "load_duration_sec": 0.028161024, "tokens_prompt": 243, "prompt_eval_sec": 0.079950848, "tokens_completion": 97, "completion_eval_sec": 1.931189253, "tokens_total": 340, "tokens_per_sec": 164.78703320022308, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates separate averages for each defendant_type within each country (4 total rows), while the Generated SQL combines both countries into a single dataset and groups by defendant_type (2 total rows). The Generated SQL averages data across both countries for each defendant_type, whereas the Reference SQL maintains country-specific averages. This results in different output structures and values.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly separates averages by country and defendant type, producing four distinct rows (Canada Indigenous, Canada Non-Indigenous, NZ Indigenous, NZ Non-Indigenous). The generated query merges data from both countries into a single dataset, resulting in two aggregated rows (Indigenous and Non-Indigenous) that combine data from both countries. This violates the original question's requirement to compare within each country. While the generated query is more efficient and elegant, it fails to fulfill the business intent by collapsing geographic distinctions. The reference query, though less efficient, technically answers the question as posed.", "overall_assessment": "differently_correct"}}
{"example_id": 2972, "sql_complexity": "set operations", "prompt": "How many indigenous communities are in the Arctic Research Station 13 and 14?", "context": "CREATE TABLE Arctic_Research_Station_13 (id INT, community TEXT); CREATE TABLE Arctic_Research_Station_14 (id INT, community TEXT);", "reference_sql": "SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_13; SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_14; SELECT COUNT(DISTINCT community) FROM (SELECT * FROM Arctic_Research_Station_13 UNION ALL SELECT * FROM Arctic_Research_Station_14) AS Arctic_Communities;", "generated_sql": "SELECT\n  COUNT(DISTINCT community)\nFROM Arctic_Research_Station_13\nUNION ALL\nSELECT\n  COUNT(DISTINCT community)\nFROM Arctic_Research_Station_14;", "raw_model_output": "```sql\nSELECT\n  COUNT(DISTINCT community)\nFROM Arctic_Research_Station_13\nUNION ALL\nSELECT\n  COUNT(DISTINCT community)\nFROM Arctic_Research_Station_14;\n```", "latency_sec": 1.0978620052337646, "total_duration_sec": 1.023295961, "load_duration_sec": 0.029251256, "tokens_prompt": 132, "prompt_eval_sec": 0.037621641, "tokens_completion": 49, "completion_eval_sec": 0.955681106, "tokens_total": 181, "tokens_per_sec": 164.86589310599211, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes three queries: two individual counts of distinct communities from each table and a combined count from both tables. The Generated SQL returns two separate counts using UNION ALL, but it does not include the combined count from both tables. While the first two queries in the Reference match the Generated SQL's output, the third query in the Reference (which combines both tables) is missing in the Generated SQL. Thus, the overall results differ.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly addresses the business intent by calculating the total number of distinct indigenous communities across both stations using a UNION ALL to combine tables before counting. The Generated SQL uses UNION ALL to combine two separate COUNT(DISTINCT) results, producing two rows of counts (one for each station) rather than a single combined total. This fails to answer the original question which likely seeks the total unique communities across both stations. While both queries are technically correct in their own right, their outputs differ in structure and meaning. The Reference's third query is more elegant and directly addresses the combined requirement.", "overall_assessment": "differently_correct"}}
{"example_id": 5576, "sql_complexity": "window functions", "prompt": "Who are the top 5 users with the most followers, and what is their location?", "context": "CREATE TABLE user_data (user_id INT, name VARCHAR(50), followers INT, location VARCHAR(50)); INSERT INTO user_data (user_id, name, followers, location) VALUES (1, 'Alice', 10000, 'New York'), (2, 'Bob', 15000, 'California'), (3, 'Charlie', 12000, 'Texas'), (4, 'David', 8000, 'Florida'), (5, 'Eve', 9000, 'Illinois');", "reference_sql": "SELECT name, location FROM (SELECT name, location, ROW_NUMBER() OVER (ORDER BY followers DESC) AS rank FROM user_data) AS user_ranks WHERE rank <= 5;", "generated_sql": "SELECT name, location FROM user_data ORDER BY followers DESC LIMIT 5;", "raw_model_output": "```sql\nSELECT name, location FROM user_data ORDER BY followers DESC LIMIT 5;\n```", "latency_sec": 0.893671989440918, "total_duration_sec": 0.522006407, "load_duration_sec": 0.028427098, "tokens_prompt": 220, "prompt_eval_sec": 0.070935307, "tokens_completion": 22, "completion_eval_sec": 0.421565698, "tokens_total": 242, "tokens_per_sec": 270.7928668004862, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the top 5 users by followers. The Reference SQL uses ROW_NUMBER() to assign ranks and filters where rank <= 5, while the Generated SQL directly orders by followers DESC and limits to 5 rows. Since all followers values are unique in the sample data, both approaches return the same 5 rows in the same order.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly retrieve the top 5 users by followers and their locations. The Reference SQL uses ROW_NUMBER() with a subquery to assign ranks, while the Generated SQL uses ORDER BY + LIMIT, which is simpler. In this specific case with unique follower counts, both produce identical results. However, the Generated SQL is more efficient (no subquery overhead) and directly addresses the requirement without unnecessary complexity. The Reference might behave differently in cases of tie-breaking, but the question doesn't specify such requirements.", "overall_assessment": "correct"}}
{"example_id": 1560, "sql_complexity": "basic SQL", "prompt": "What is the average media literacy score for users in the 'Young Adult' age group who have completed at least one disinformation detection course?", "context": "CREATE TABLE users (id INT, age VARCHAR(20), media_literacy_score INT, courses_completed INT);", "reference_sql": "SELECT AVG(media_literacy_score) FROM users WHERE age = 'Young Adult' AND courses_completed > 0;", "generated_sql": "SELECT AVG(media_literacy_score)\nFROM users\nWHERE age = 'Young Adult' AND courses_completed >= 1;", "raw_model_output": "```sql\nSELECT AVG(media_literacy_score)\nFROM users\nWHERE age = 'Young Adult' AND courses_completed >= 1;\n```", "latency_sec": 0.8924429416656494, "total_duration_sec": 0.744994868, "load_duration_sec": 0.028022773, "tokens_prompt": 133, "prompt_eval_sec": 0.037823323, "tokens_completion": 35, "completion_eval_sec": 0.678468672, "tokens_total": 168, "tokens_per_sec": 188.24732894009554, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The conditions 'courses_completed > 0' and 'courses_completed >= 1' are logically equivalent for integer values. Both filter rows where the numeric value is at least 1, as integers cannot be fractional. The WHERE clauses will produce identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the average media literacy score for 'Young Adult' users with at least one completed course. The conditions 'courses_completed > 0' (reference) and 'courses_completed >= 1' (generated) are logically equivalent for non-NULL integer values. Both queries exclude users with zero courses and non-Young Adult age groups. The generated query's use of >= 1 is slightly more explicit about the 'at least one' requirement, but neither query is technically superior. Both fulfill the business intent equally well.", "overall_assessment": "correct"}}
{"example_id": 1201, "sql_complexity": "basic SQL", "prompt": "What is the maximum energy efficiency rating of hydroelectric dams in Canada?", "context": "CREATE TABLE hydro_dams (id INT, name TEXT, country TEXT, energy_efficiency_rating FLOAT); INSERT INTO hydro_dams (id, name, country, energy_efficiency_rating) VALUES (1, 'Robert-Bourassa', 'Canada', 0.94), (2, 'Churchill Falls', 'Canada', 0.92);", "reference_sql": "SELECT MAX(energy_efficiency_rating) FROM hydro_dams WHERE country = 'Canada';", "generated_sql": "SELECT max(energy_efficiency_rating) FROM hydro_dams WHERE country = 'Canada';", "raw_model_output": "```sql\nSELECT max(energy_efficiency_rating) FROM hydro_dams WHERE country = 'Canada';\n```", "latency_sec": 0.6752469539642334, "total_duration_sec": 0.581422379, "load_duration_sec": 0.028504325, "tokens_prompt": 171, "prompt_eval_sec": 0.051295279, "tokens_completion": 26, "completion_eval_sec": 0.500791826, "tokens_total": 197, "tokens_per_sec": 291.7451146479881, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are semantically equivalent. The only difference is the case of the MAX function (uppercase vs lowercase), but SQL keywords are case-insensitive. Both queries select the maximum energy_efficiency_rating from hydro_dams where country is 'Canada', which will return the same result (0.94).", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the maximum energy efficiency rating for Canadian hydroelectric dams. The only difference is the case of the SQL keyword 'MAX' (uppercase vs lowercase), which has no impact on execution or results. Both queries: 1) Filter for 'Canada' as required, 2) Use the MAX aggregate function appropriately, 3) Reference the correct column. The sample data would return 0.94 from both queries. The case variation is a stylistic choice with no technical or semantic difference in this context.", "overall_assessment": "correct"}}
{"example_id": 4243, "sql_complexity": "single join", "prompt": "How many orders were placed by new and returning customers in each month of the year 2021?'", "context": "CREATE TABLE customer (id INT, first_order_date DATE, last_order_date DATE);", "reference_sql": "INSERT INTO customer (id, first_order_date, last_order_date) SELECT customer_id, MIN(order_date) AS first_order_date, MAX(order_date) AS last_order_date FROM orders GROUP BY customer_id; SELECT YEAR(order_date) AS year, MONTH(order_date) AS month, CASE WHEN DATEDIFF(last_order_date, first_order_date) > 30 THEN 'returning' ELSE 'new' END AS customer_type, COUNT(DISTINCT id) AS num_orders FROM orders JOIN customer ON orders.customer_id = customer.id WHERE YEAR(order_date) = 2021 GROUP BY year, month, customer_type;", "generated_sql": "SELECT\n  STRFTIME('%Y-%m', first_order_date) AS order_month,\n  COUNT(DISTINCT id) AS order_count\nFROM customer\nWHERE STRFTIME('%Y', first_order_date) = '2021'\nGROUP BY\n  order_month\nORDER BY\n  order_month;", "raw_model_output": "```sql\nSELECT\n  STRFTIME('%Y-%m', first_order_date) AS order_month,\n  COUNT(DISTINCT id) AS order_count\nFROM customer\nWHERE STRFTIME('%Y', first_order_date) = '2021'\nGROUP BY\n  order_month\nORDER BY\n  order_month;\n```", "latency_sec": 1.779129981994629, "total_duration_sec": 1.655966866, "load_duration_sec": 0.028307695, "tokens_prompt": 123, "prompt_eval_sec": 0.036969375, "tokens_completion": 81, "completion_eval_sec": 1.590037961, "tokens_total": 204, "tokens_per_sec": 114.66278577987332, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query analyzes order data with customer type classification (new/returning) based on order date ranges, while the generated query focuses on customer acquisition months using first_order_date. Key differences: 1) The reference query joins orders and customer tables, while the generated query only uses customer. 2) The reference calculates counts per month and customer type, while the generated query counts distinct customers per first_order_date month. 3) The reference filters orders from 2021, while the generated query filters customers with first_order_date in 2021.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL attempts to address the business intent by categorizing customers as 'new' or 'returning' based on order date differences, but it has critical flaws: 1) It counts distinct customer IDs instead of orders (the question asks for 'number of orders'), 2) The 'returning' logic (DAYS > 30) is flawed - true returning customers should have multiple orders, not just a 30-day gap. The Generated SQL fails completely by not distinguishing between new/returning customers and counting customers instead of orders. While both are incorrect, the Reference query better addresses the intent by at least attempting the classification, even with errors.", "overall_assessment": "incorrect"}}
{"example_id": 2321, "sql_complexity": "subqueries", "prompt": "What are the names and types of vessels used in research expeditions in the regions with the lowest ocean acidification levels?", "context": "CREATE TABLE ocean_acidification (id INT PRIMARY KEY, region VARCHAR(255), year INT, acidification_level INT); INSERT INTO ocean_acidification (id, region, year, acidification_level) VALUES (1, 'Arctic Ocean', 2018, 20), (2, 'Southern Ocean', 2019, 22); CREATE TABLE expedition_vessels (id INT PRIMARY KEY, name VARCHAR(255), type VARCHAR(255), region VARCHAR(255)); INSERT INTO expedition_vessels (id, name, type, region) VALUES (1, 'Sea Researcher', 'Research Vessel', 'Arctic Ocean');", "reference_sql": "SELECT v.name, v.type FROM expedition_vessels v INNER JOIN ocean_acidification oa ON v.region = oa.region WHERE oa.acidification_level = (SELECT MIN(acidification_level) FROM ocean_acidification);", "generated_sql": "SELECT\n  v.name,\n  v.type\nFROM expedition_vessels AS v\nJOIN ocean_acidification AS oa\n  ON v.region = oa.region\nWHERE\n  oa.acidification_level = (\n    SELECT\n      MIN(acidification_level)\n    FROM ocean_acidification\n  );", "raw_model_output": "```sql\nSELECT\n  v.name,\n  v.type\nFROM expedition_vessels AS v\nJOIN ocean_acidification AS oa\n  ON v.region = oa.region\nWHERE\n  oa.acidification_level = (\n    SELECT\n      MIN(acidification_level)\n    FROM ocean_acidification\n  );\n```", "latency_sec": 1.7677297592163086, "total_duration_sec": 1.669522896, "load_duration_sec": 0.039039765, "tokens_prompt": 245, "prompt_eval_sec": 0.080085789, "tokens_completion": 78, "completion_eval_sec": 1.549505347, "tokens_total": 323, "tokens_per_sec": 182.7202366854967, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between expedition_vessels and ocean_acidification on region, then filter where acidification_level equals the minimum acidification_level from ocean_acidification. The subquery and join logic are identical, with only syntactic differences (e.g., JOIN vs INNER JOIN, table aliases).", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent as they produce identical results through the same logical structure. They correctly identify regions with the minimum ocean acidification level using a subquery and join vessels with those regions. The reference and generated queries differ only in formatting (e.g., use of AS keyword, indentation) and do not affect functionality. Both fulfill the business intent by linking research vessels to regions with the lowest acidification levels. Neither query is more efficient or elegant than the other, as they execute the same operations with identical subquery logic.", "overall_assessment": "correct"}}
{"example_id": 4349, "sql_complexity": "multiple_joins", "prompt": "Show the research grants awarded to professors in the Computer Science department.", "context": "CREATE TABLE departments (id INT, name VARCHAR(50)); INSERT INTO departments (id, name) VALUES (1, 'Computer Science'), (2, 'Mathematics'); CREATE TABLE professors (id INT, name VARCHAR(50), department_id INT); INSERT INTO professors (id, name, department_id) VALUES (1, 'John Smith', 1), (2, 'Jane Doe', 2); CREATE TABLE grants (id INT, professor_id INT, year INT, amount FLOAT); INSERT INTO grants (id, professor_id, year, amount) VALUES (1, 1, 2021, 5000.0), (2, 2, 2020, 7000.0);", "reference_sql": "SELECT professors.name, grants.amount FROM professors INNER JOIN grants ON professors.id = grants.professor_id INNER JOIN departments ON professors.department_id = departments.id WHERE departments.name = 'Computer Science';", "generated_sql": "SELECT\n  g.id,\n  g.professor_id,\n  g.year,\n  g.amount\nFROM grants AS g\nJOIN professors AS p\n  ON g.professor_id = p.id\nJOIN departments AS d\n  ON p.department_id = d.id\nWHERE\n  d.name = 'Computer Science';", "raw_model_output": "```sql\nSELECT\n  g.id,\n  g.professor_id,\n  g.year,\n  g.amount\nFROM grants AS g\nJOIN professors AS p\n  ON g.professor_id = p.id\nJOIN departments AS d\n  ON p.department_id = d.id\nWHERE\n  d.name = 'Computer Science';\n```", "latency_sec": 2.0656518936157227, "total_duration_sec": 1.764313337, "load_duration_sec": 0.029069792, "tokens_prompt": 252, "prompt_eval_sec": 0.080849967, "tokens_completion": 83, "completion_eval_sec": 1.653429714, "tokens_total": 335, "tokens_per_sec": 162.17640592559624, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent because they select different columns. The Reference SQL selects professors.name and grants.amount, while the Generated SQL selects all columns from the grants table. Although both queries filter for 'Computer Science' department professors, the result sets have different structures.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent because they return different columns (reference includes professor names, generated includes grant IDs). Both are logically correct, but the reference query better fulfills the business intent by explicitly showing professor names alongside grants, directly answering 'who received grants' rather than just listing grant details. The generated query is efficient but omits the professor's name, which is critical for identifying recipients. The reference query's column selection aligns more closely with the natural language question's focus on 'professors' and their awards.", "overall_assessment": "correct"}}
{"example_id": 476, "sql_complexity": "basic SQL", "prompt": "Insert new food safety records for locations \"A123\", \"B456\", and \"C789\"", "context": "CREATE TABLE food_safety_records (id INT, location VARCHAR(255), inspection_date DATE, violation_count INT);", "reference_sql": "INSERT INTO food_safety_records (location, inspection_date, violation_count) VALUES ('A123', '2022-03-01', 0), ('B456', '2022-03-05', 2), ('C789', '2022-03-10', 1);", "generated_sql": "INSERT INTO food_safety_records (location) VALUES ('A123'), ('B456'), ('C789');", "raw_model_output": "```sql\nINSERT INTO food_safety_records (location) VALUES ('A123'), ('B456'), ('C789');\n```", "latency_sec": 1.0515902042388916, "total_duration_sec": 0.748176324, "load_duration_sec": 0.033265333, "tokens_prompt": 134, "prompt_eval_sec": 0.038143653, "tokens_completion": 35, "completion_eval_sec": 0.676089707, "tokens_total": 169, "tokens_per_sec": 160.7089903640905, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL inserts all three columns (location, inspection_date, violation_count) with specific values, while the Generated SQL only inserts the 'location' column. The other columns (inspection_date, violation_count) are missing, which would result in different data being inserted (or potential errors if those columns are non-nullable).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference SQL correctly inserts full records with all required fields (location, inspection_date, violation_count) for the specified locations. The generated SQL only inserts the 'location' field, leaving other critical columns (inspection_date, violation_count) as NULL or default values. While technically valid if the database allows NULLs, it fails to fulfill the business intent of creating complete food safety records. The original question implies inserting full records with all relevant data, not just locations. The reference query is more precise and aligns with the explicit requirements.", "overall_assessment": "incorrect"}}
{"example_id": 2908, "sql_complexity": "single join", "prompt": "List all co-owners and the properties they own in New York, NY.", "context": "CREATE TABLE properties (id INT, city VARCHAR(50), price INT); CREATE TABLE co_owners (property_id INT, owner_name VARCHAR(50)); INSERT INTO properties (id, city, price) VALUES (1, 'New York', 800000), (2, 'Los Angeles', 600000); INSERT INTO co_owners (property_id, owner_name) VALUES (1, 'David'), (1, 'Ella'), (2, 'Frank');", "reference_sql": "SELECT properties.city, co_owners.owner_name FROM properties INNER JOIN co_owners ON properties.id = co_owners.property_id WHERE properties.city = 'New York';", "generated_sql": "SELECT\n  co_owners.owner_name,\n  properties.city\nFROM co_owners\nJOIN properties\n  ON co_owners.property_id = properties.id\nWHERE\n  properties.city = 'New York';", "raw_model_output": "```sql\nSELECT\n  co_owners.owner_name,\n  properties.city\nFROM co_owners\nJOIN properties\n  ON co_owners.property_id = properties.id\nWHERE\n  properties.city = 'New York';\n```", "latency_sec": 1.408409833908081, "total_duration_sec": 1.212322294, "load_duration_sec": 0.036277552, "tokens_prompt": 205, "prompt_eval_sec": 0.069604423, "tokens_completion": 56, "completion_eval_sec": 1.105749229, "tokens_total": 261, "tokens_per_sec": 185.31537746777335, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an INNER JOIN between properties and co_owners on the same condition (properties.id = co_owners.property_id), filter for properties in 'New York', and select the same two columns (city and owner_name). The order of columns in the SELECT list differs but does not affect the semantic result, as the data returned remains identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly join the properties and co_owners tables on property_id/id, filter for New York properties, and retrieve owner names with city information. The reference query uses explicit INNER JOIN syntax while the generated query uses implicit JOIN, but both produce identical results. The column order in SELECT is different but does not affect semantic equivalence. Both correctly address the business intent of listing co-owners and their New York properties.", "overall_assessment": "correct"}}
{"example_id": 636, "sql_complexity": "set operations", "prompt": "Insert new data into the 'cosmetic_ingredients' table for a vegan eyeshadow product by brand 'Ara' with ingredients 'Mica', 'Iron Oxide', 'Titanium Dioxide' and 'Zinc Oxide'.", "context": "CREATE TABLE cosmetic_ingredients (ingredient_id INT, product_name TEXT, brand_name TEXT, ingredient_type TEXT);", "reference_sql": "INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type) VALUES (NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient'); INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type, ingredient_name) SELECT ingredient_id, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Mica' FROM cosmetic_ingredients WHERE ingredient_name = 'Mica' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Iron Oxide' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Titanium Dioxide' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Zinc Oxide';", "generated_sql": "INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type) VALUES\n(1, 'Vegan Eyeshadow', 'Ara', 'Mica'),\n(2, 'Vegan Eyeshadow', 'Ara', 'Iron Oxide'),\n(3, 'Vegan Eyeshadow', 'Ara', 'Titanium Dioxide'),\n(4, 'Vegan Eyeshadow', 'Ara', 'Zinc Oxide');", "raw_model_output": "```sql\nINSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type) VALUES\n(1, 'Vegan Eyeshadow', 'Ara', 'Mica'),\n(2, 'Vegan Eyeshadow', 'Ara', 'Iron Oxide'),\n(3, 'Vegan Eyeshadow', 'Ara', 'Titanium Dioxide'),\n(4, 'Vegan Eyeshadow', 'Ara', 'Zinc Oxide');\n```", "latency_sec": 1.9556798934936523, "total_duration_sec": 1.922672166, "load_duration_sec": 0.02837433, "tokens_prompt": 148, "prompt_eval_sec": 0.041988451, "tokens_completion": 94, "completion_eval_sec": 1.85157549, "tokens_total": 242, "tokens_per_sec": 123.74213224010194, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL attempts to insert into a non-existent 'ingredient_name' column and uses a SELECT from the same table, while the Generated SQL directly inserts values into existing columns. Additionally, the Generated SQL populates 'ingredient_type' with specific ingredient names (e.g., 'Mica'), whereas the Reference SQL sets 'ingredient_type' to 'Ingredient' for all entries. The schema mismatch and differing data semantics make them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL contains critical technical errors: it references a non-existent 'ingredient_name' column in the SELECT statements, and the initial INSERT statement incorrectly sets 'ingredient_type' to 'Ingredient' instead of the actual ingredient names. The Generated SQL correctly inserts each ingredient as a separate row with proper values for existing columns (ingredient_id, product_name, brand_name, ingredient_type). While both queries aim to add data for the vegan eyeshadow, only the Generated SQL adheres to the schema and correctly maps the ingredients. The Reference SQL would fail due to schema mismatch and incorrect data mapping.", "overall_assessment": "differently_correct"}}
{"example_id": 3404, "sql_complexity": "multiple_joins", "prompt": "What are the names of startups that have received funding from investors with over 3 million funds, and are involved in Genetic Research or Bioprocess Engineering?", "context": "CREATE TABLE public.investors ( id SERIAL PRIMARY KEY, name VARCHAR(100), type VARCHAR(50), funds INTEGER ); CREATE TABLE public.investments ( id SERIAL PRIMARY KEY, investor_id INTEGER, startup_id INTEGER ); CREATE TABLE public.startups ( id SERIAL PRIMARY KEY, name VARCHAR(100), industry VARCHAR(50), funding INTEGER );", "reference_sql": "SELECT startups.name FROM public.startups JOIN public.investments ON startups.id = investments.startup_id JOIN public.investors ON investments.investor_id = investors.id WHERE (startups.industry = 'Genetic Research' OR startups.industry = 'Bioprocess Engineering') AND investors.funds > 3000000;", "generated_sql": "SELECT\n  s.name\nFROM startups AS s\nJOIN investments AS i\n  ON s.id = i.startup_id\nJOIN investors AS inv\n  ON i.investor_id = inv.id\nWHERE\n  inv.funds > 3000000 AND s.industry IN ('Genetic Research', 'Bioprocess Engineering');", "raw_model_output": "```sql\nSELECT\n  s.name\nFROM startups AS s\nJOIN investments AS i\n  ON s.id = i.startup_id\nJOIN investors AS inv\n  ON i.investor_id = inv.id\nWHERE\n  inv.funds > 3000000 AND s.industry IN ('Genetic Research', 'Bioprocess Engineering');\n```", "latency_sec": 1.8016011714935303, "total_duration_sec": 1.724246953, "load_duration_sec": 0.028506457, "tokens_prompt": 189, "prompt_eval_sec": 0.05661671, "tokens_completion": 83, "completion_eval_sec": 1.638341735, "tokens_total": 272, "tokens_per_sec": 150.9768112409205, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve startup names where the investor has funds > 3,000,000 and the startup's industry is either 'Genetic Research' or 'Bioprocess Engineering'. The generated query uses IN instead of OR for the industry condition (logically equivalent) and uses table aliases, but the join conditions, filtering criteria, and selected columns are identical in meaning.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent as they produce identical results by joining the same tables with equivalent conditions. The reference uses explicit OR logic for industry filtering, while the generated query uses IN, which is functionally identical but more concise. Both correctly filter investors with >3M funds and startups in the specified industries. The generated query improves readability through table aliases and avoids redundant parentheses, but neither query has a structural advantage in terms of business intent fulfillment. The efficiency difference is negligible for this query structure.", "overall_assessment": "correct"}}
{"example_id": 134, "sql_complexity": "subqueries", "prompt": "Who are the top 3 authors with the most citations in the Mathematics department in the past 5 years?", "context": "CREATE TABLE authors (id INT, name VARCHAR(50), department VARCHAR(50)); INSERT INTO authors (id, name, department) VALUES (1, 'Author Name', 'Mathematics'); CREATE TABLE publications (id INT, title VARCHAR(100), author VARCHAR(50), journal VARCHAR(50), year INT, cites INT); INSERT INTO publications (id, title, author, journal, year, cites) VALUES (1, 'Publication Title', 'Author Name', 'Journal Name', 2021, 10);", "reference_sql": "SELECT author, SUM(cites) as total_cites FROM publications WHERE author IN (SELECT name FROM authors WHERE department = 'Mathematics') AND year BETWEEN YEAR(CURRENT_DATE) - 5 AND YEAR(CURRENT_DATE) GROUP BY author ORDER BY total_cites DESC LIMIT 3;", "generated_sql": "SELECT\n  a.name\nFROM authors AS a\nJOIN publications AS p\n  ON a.name = p.author\nWHERE\n  a.department = 'Mathematics' AND p.year >= strftime('%Y', 'now') - 5\nGROUP BY\n  a.name\nORDER BY\n  SUM(p.cites) DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT\n  a.name\nFROM authors AS a\nJOIN publications AS p\n  ON a.name = p.author\nWHERE\n  a.department = 'Mathematics' AND p.year >= strftime('%Y', 'now') - 5\nGROUP BY\n  a.name\nORDER BY\n  SUM(p.cites) DESC\nLIMIT 3;\n```", "latency_sec": 1.79270601272583, "total_duration_sec": 1.78264284, "load_duration_sec": 0.028397957, "tokens_prompt": 216, "prompt_eval_sec": 0.071488198, "tokens_completion": 85, "completion_eval_sec": 1.681791896, "tokens_total": 301, "tokens_per_sec": 167.90259968076197, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their year filtering logic. The Reference SQL uses BETWEEN YEAR(CURRENT_DATE) - 5 AND YEAR(CURRENT_DATE), which explicitly includes both the lower and upper bounds (5 years ago to current year). The Generated SQL uses p.year >= strftime('%Y', 'now') - 5, which only enforces a lower bound but lacks an upper bound. This means the Generated SQL could include publications from years beyond the current year (if present in the data), while the Reference SQL strictly limits to the 5-year window ending in the current year. This discrepancy in filtering makes them non-equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly identify the top 3 Mathematics department authors by total citations in the past 5 years. The Reference uses a subquery with IN and explicit BETWEEN for year filtering, while the Generated uses a JOIN and a simplified year condition. The year logic is equivalent (both capture 5-year window including current year). Both group by author, sum citations, and order by descending total. The JOIN in Generated may be more efficient but doesn't affect result accuracy. Both queries correctly filter Mathematics department authors and handle citation aggregation.", "overall_assessment": "correct"}}
{"example_id": 592, "sql_complexity": "set operations", "prompt": "How many public healthcare facilities and public parks are there in total, in the 'StateData' schema's 'StateHealthcare' and 'StateParks' tables?", "context": "CREATE SCHEMA StateData; CREATE TABLE StateHealthcare (Name varchar(255), Type varchar(255)); INSERT INTO StateHealthcare (Name, Type) VALUES ('FacilityA', 'Public'), ('FacilityB', 'Public'), ('FacilityC', 'Private'); CREATE TABLE StateParks (Name varchar(255), Type varchar(255)); INSERT INTO StateParks (Name, Type) VALUES ('ParkA', 'Public'), ('ParkB', 'Public'), ('ParkC', 'Private');", "reference_sql": "SELECT COUNT(*) FROM StateData.StateHealthcare WHERE Type = 'Public' UNION ALL SELECT COUNT(*) FROM StateData.StateParks WHERE Type = 'Public';", "generated_sql": "SELECT\n  COUNT(T1.Name)\nFROM StateHealthcare AS T1\nWHERE\n  T1.Type = 'Public'\nUNION ALL\nSELECT\n  COUNT(T2.Name)\nFROM StateParks AS T2\nWHERE\n  T2.Type = 'Public';", "raw_model_output": "```sql\nSELECT\n  COUNT(T1.Name)\nFROM StateHealthcare AS T1\nWHERE\n  T1.Type = 'Public'\nUNION ALL\nSELECT\n  COUNT(T2.Name)\nFROM StateParks AS T2\nWHERE\n  T2.Type = 'Public';\n```", "latency_sec": 1.6110031604766846, "total_duration_sec": 1.444076724, "load_duration_sec": 0.031897804, "tokens_prompt": 218, "prompt_eval_sec": 0.070773535, "tokens_completion": 68, "completion_eval_sec": 1.340458688, "tokens_total": 286, "tokens_per_sec": 177.52913651353396, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Generated SQL does not include the schema name (StateData) when referencing the tables, which may lead to different results or errors if the schema is not implicitly set. The Reference SQL explicitly qualifies the table names with the StateData schema, ensuring correct table resolution. Without the schema, the Generated SQL might not find the tables, making them semantically different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query explicitly qualifies table names with the 'StateData' schema (e.g., StateData.StateHealthcare), ensuring correct object resolution. The generated query omits the schema prefix, which could lead to errors if the default schema isn't set to 'StateData'. While both queries count public entries correctly, the reference is technically more robust. Both fulfill the business intent of counting public facilities and parks, but the reference is more precise and less error-prone.", "overall_assessment": "correct"}}
{"example_id": 1989, "sql_complexity": "single join", "prompt": "What are the names and production dates of garments made from fabrics with a sustainability score over 70, produced after 2021-01-01?", "context": "CREATE TABLE fabrics (id INT, name VARCHAR(50), type VARCHAR(50), sustainability_score INT); INSERT INTO fabrics (id, name, type, sustainability_score) VALUES (1, 'Organic Linen', 'Natural', 80); INSERT INTO fabrics (id, name, type, sustainability_score) VALUES (2, 'Recycled Nylon', 'Synthetic', 72);", "reference_sql": "SELECT garments.name, garments.production_date FROM garments JOIN fabrics ON garments.fabric_id = fabrics.id WHERE fabrics.sustainability_score > 70 AND garments.production_date > '2021-01-01';", "generated_sql": "SELECT\n  g.name,\n  g.production_date\nFROM garments AS g\nJOIN fabrics AS f\n  ON g.fabric_id = f.id\nWHERE\n  f.sustainability_score > 70 AND g.production_date > '2021-01-01';", "raw_model_output": "```sql\nSELECT\n  g.name,\n  g.production_date\nFROM garments AS g\nJOIN fabrics AS f\n  ON g.fabric_id = f.id\nWHERE\n  f.sustainability_score > 70 AND g.production_date > '2021-01-01';\n```", "latency_sec": 1.8150520324707031, "total_duration_sec": 1.594364946, "load_duration_sec": 0.028859946, "tokens_prompt": 198, "prompt_eval_sec": 0.068995379, "tokens_completion": 75, "completion_eval_sec": 1.495612994, "tokens_total": 273, "tokens_per_sec": 150.40891121362742, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform the same operation: joining the 'garments' and 'fabrics' tables on fabric_id, filtering with the same conditions (sustainability_score > 70 and production_date > '2021-01-01'), and selecting the same columns. The only difference is the use of table aliases ('g' and 'f' vs. no aliases), which does not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent as they perform the same join between garments and fabrics tables, apply identical filters (sustainability_score > 70 and production_date > '2021-01-01'), and select the same columns. The reference query uses table names directly while the generated query uses aliases (g/f), which is a stylistic choice with no impact on results. Both correctly address the business intent by filtering sustainable fabrics and post-2021 production. Neither query demonstrates superior efficiency or elegance over the other, as they are structurally identical aside from naming conventions.", "overall_assessment": "correct"}}
{"example_id": 1388, "sql_complexity": "aggregation", "prompt": "What was the total donation amount by each organization in the last 30 days?", "context": "CREATE TABLE organization_donations (id INT, organization TEXT, donation_date DATE, donation_amount DECIMAL(10,2)); INSERT INTO organization_donations (id, organization, donation_date, donation_amount) VALUES (1, 'Organization A', '2021-03-15', 100.00), (2, 'Organization B', '2021-03-25', 200.00);", "reference_sql": "SELECT organization, SUM(donation_amount) FROM organization_donations WHERE donation_date >= DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY) GROUP BY organization;", "generated_sql": "SELECT organization, SUM(donation_amount) AS total_donation_amount\nFROM organization_donations\nWHERE donation_date >= DATE('now', '-30 days')\nGROUP BY organization;", "raw_model_output": "```sql\nSELECT organization, SUM(donation_amount) AS total_donation_amount\nFROM organization_donations\nWHERE donation_date >= DATE('now', '-30 days')\nGROUP BY organization;\n```", "latency_sec": 1.0255732536315918, "total_duration_sec": 1.017583548, "load_duration_sec": 0.028785181, "tokens_prompt": 199, "prompt_eval_sec": 0.069013027, "tokens_completion": 47, "completion_eval_sec": 0.919036487, "tokens_total": 246, "tokens_per_sec": 239.86584978586868, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the total donations per organization for the last 30 days. The date calculation logic (DATE_SUB vs DATE('now', '-30 days')) is functionally equivalent in determining the 30-day window. The column alias difference (total_donation_amount vs no alias) does not affect the result set's semantic content.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "While both queries aim to calculate total donations per organization in the last 30 days, they differ technically. The reference query uses standard SQL functions (DATE_SUB/CURRENT_DATE) which are portable across most SQL dialects. The generated query uses SQLite-specific syntax (DATE('now', '-30 days')). The date calculation logic is functionally equivalent but the generated query's syntax is less standard. Both correctly fulfill the business intent, but the reference query is more technically robust across different database systems.", "overall_assessment": "differently_correct"}}
{"example_id": 1628, "sql_complexity": "window functions", "prompt": "What is the ranking of national security measures for Russia based on the publication date?", "context": "CREATE TABLE national_security (id INT, title VARCHAR(255), description TEXT, agency VARCHAR(255), date DATE); INSERT INTO national_security (id, title, description, agency, date) VALUES (1, 'National Cyber Strategy', 'Outlines the approach to protecting the American people and the American way of life in the digital age', 'White House', '2018-09-20'); INSERT INTO national_security (id, title, description, agency, date) VALUES (2, 'Cybersecurity and Infrastructure Security Agency Act of 2018', 'Establishes the Cybersecurity and Infrastructure Security Agency within the Department of Homeland Security', 'Congress', '2018-11-16'); INSERT INTO national_security (id, title, description, agency, date) VALUES (3, 'Russian Military Doctrine', 'Outlines the country\u2019s stance on military security', 'Russian Government', '2014-12-26');", "reference_sql": "SELECT title, description, agency, date, ROW_NUMBER() OVER (PARTITION BY agency ORDER BY date DESC) as ranking FROM national_security WHERE agency = 'Russian Government';", "generated_sql": "SELECT\n  title\nFROM national_security\nWHERE\n  agency = 'Russian Government'\nORDER BY\n  date;", "raw_model_output": "```sql\nSELECT\n  title\nFROM national_security\nWHERE\n  agency = 'Russian Government'\nORDER BY\n  date;\n```", "latency_sec": 1.0617709159851074, "total_duration_sec": 0.764603047, "load_duration_sec": 0.032243805, "tokens_prompt": 307, "prompt_eval_sec": 0.100797951, "tokens_completion": 32, "completion_eval_sec": 0.629919913, "tokens_total": 339, "tokens_per_sec": 319.2779109846656, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL returns multiple columns (title, description, agency, date) plus a row number ranking, while the Generated SQL only returns the 'title' column. Additionally, the Reference SQL applies an explicit DATE DESC sort within its window function, whereas the Generated SQL uses default ASC ordering. The Generated SQL also lacks the ROW_NUMBER() calculation entirely.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL and Generated SQL are not technically equivalent. The Reference SQL calculates a ranking using ROW_NUMBER() and includes additional columns (description, agency, date), while the Generated SQL only returns titles and orders by date. The original question asks for 'ranking' which implies a numerical position, which the Reference SQL provides. The Generated SQL only sorts results chronologically without explicit ranking. Although both filter for 'Russian Government', the Reference SQL better addresses the intent by explicitly creating a ranking metric. The Generated SQL fails to fulfill the intent as it does not produce a ranking value.", "overall_assessment": "differently_correct"}}
{"example_id": 2300, "sql_complexity": "aggregation", "prompt": "What is the minimum capacity for schools in each location ('community_development')?", "context": "CREATE TABLE community_development.schools (id INT, name VARCHAR(50), capacity INT, location VARCHAR(50));", "reference_sql": "SELECT location, MIN(capacity) FROM community_development.schools GROUP BY location;", "generated_sql": "SELECT location, MIN(capacity) AS min_capacity\nFROM community_development.schools\nGROUP BY location;", "raw_model_output": "```sql\nSELECT location, MIN(capacity) AS min_capacity\nFROM community_development.schools\nGROUP BY location;\n```", "latency_sec": 0.7083678245544434, "total_duration_sec": 0.623498192, "load_duration_sec": 0.028784639, "tokens_prompt": 122, "prompt_eval_sec": 0.036839294, "tokens_completion": 29, "completion_eval_sec": 0.557173322, "tokens_total": 151, "tokens_per_sec": 213.1660907876181, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries group schools by location and retrieve the minimum capacity per location. The generated query adds an explicit column alias ('min_capacity') for clarity, but this does not affect the semantic result. The core logic (grouping and aggregation) remains identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the minimum capacity per location using GROUP BY and MIN(). The generated query improves readability by explicitly aliasing the MIN(capacity) column as 'min_capacity', which makes the result clearer without altering functionality. The reference query is technically correct but less descriptive. Both satisfy the business intent of identifying minimum capacities by location.", "overall_assessment": "correct"}}
{"example_id": 4976, "sql_complexity": "set operations", "prompt": "What is the most common hashtag used in posts made by users from Brazil?", "context": "CREATE TABLE posts (id INT, user_id INT, content TEXT, hashtags TEXT, post_date DATE); INSERT INTO posts (id, user_id, content, hashtags, post_date) VALUES (1, 1, 'Hello World', '#datascience', '2022-06-01'), (2, 1, 'I love data', '#ai', '2022-06-02'), (3, 2, 'Ol\u00e1 Mundo', '#brasil', '2022-06-03'); CREATE TABLE users (id INT, name VARCHAR(100), country VARCHAR(50)); INSERT INTO users (id, name, country) VALUES (1, 'Jo\u00e3o Silva', 'Brazil'), (2, 'Maria Souza', 'Brazil');", "reference_sql": "SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(hashtags, ' ', n.n), ' ', -1) hashtag, COUNT(*) count FROM posts JOIN users ON posts.user_id = users.id CROSS JOIN (SELECT 1 n UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5) n WHERE users.country = 'Brazil' GROUP BY hashtag ORDER BY count DESC LIMIT 1;", "generated_sql": "SELECT\n  SUBSTR(hashtags, 1, INSTR(hashtags, ' ') - 1)\nFROM posts\nWHERE\n  user_id IN (\n    SELECT\n      id\n    FROM users\n    WHERE\n      country = 'Brazil'\n  );", "raw_model_output": "```sql\nSELECT\n  SUBSTR(hashtags, 1, INSTR(hashtags, ' ') - 1)\nFROM posts\nWHERE\n  user_id IN (\n    SELECT\n      id\n    FROM users\n    WHERE\n      country = 'Brazil'\n  );\n```", "latency_sec": 1.4930689334869385, "total_duration_sec": 1.395516397, "load_duration_sec": 0.039278138, "tokens_prompt": 265, "prompt_eval_sec": 0.089138175, "tokens_completion": 64, "completion_eval_sec": 1.26614729, "tokens_total": 329, "tokens_per_sec": 220.35151399985787, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL extracts and counts individual hashtags from Brazilian users, grouping by hashtag and returning the most frequent one. The Generated SQL only extracts the first hashtag from each post of Brazilian users without any aggregation or counting. The two queries have different purposes (aggregation vs. simple extraction) and produce fundamentally different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly addresses the question by splitting multi-value hashtags and counting their occurrences, while the Generated SQL only extracts the first hashtag from each post without counting or handling multiple hashtags. The Reference uses a robust method to split hashtags into individual rows (via cross join with numbers) and aggregates counts, ensuring accurate identification of the most common hashtag. The Generated SQL fails to perform any aggregation, returns only the first hashtag per post, and doesn't address the 'most common' requirement. Both queries filter Brazilian users correctly, but the Reference's approach is fundamentally more aligned with the business intent.", "overall_assessment": "incorrect"}}
{"example_id": 4637, "sql_complexity": "single join", "prompt": "What is the total value of transactions for each customer in the last 30 days?", "context": "CREATE TABLE transactions (id INT, customer_id INT, value DECIMAL(10, 2), transaction_date DATE); INSERT INTO transactions (id, customer_id, value, transaction_date) VALUES (1, 1, 100, '2022-01-01'), (2, 1, 200, '2022-01-15'), (3, 2, 50, '2022-01-05'), (4, 2, 150, '2022-01-30'), (5, 3, 300, '2022-01-20');", "reference_sql": "SELECT c.id, SUM(t.value) FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE t.transaction_date >= CURDATE() - INTERVAL 30 DAY GROUP BY c.id;", "generated_sql": "SELECT\n  customer_id,\n  SUM(value)\nFROM transactions\nWHERE\n  transaction_date >= DATE('now', '-30 days')\nGROUP BY\n  customer_id;", "raw_model_output": "```sql\nSELECT\n  customer_id,\n  SUM(value)\nFROM transactions\nWHERE\n  transaction_date >= DATE('now', '-30 days')\nGROUP BY\n  customer_id;\n```", "latency_sec": 1.1708149909973145, "total_duration_sec": 1.056787061, "load_duration_sec": 0.028666461, "tokens_prompt": 255, "prompt_eval_sec": 0.080908195, "tokens_completion": 48, "completion_eval_sec": 0.946444839, "tokens_total": 303, "tokens_per_sec": 258.79408986888774, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of transaction values for customers with transactions in the last 30 days. The Reference SQL uses an INNER JOIN between customers and transactions, while the Generated SQL directly groups transactions by customer_id. Since the WHERE clause filters transactions to the last 30 days in both cases, and the GROUP BY and aggregation are equivalent, the result sets will contain the same customer_id (or c.id) and summed values. The column name difference (c.id vs customer_id) does not affect semantic equivalence as the data content remains identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries calculate the total transaction value per customer for the last 30 days. The Reference SQL uses an unnecessary INNER JOIN with the customers table, which doesn't add value since the transactions table already contains customer_id. The Generated SQL directly filters transactions and groups by customer_id, achieving the same result with simpler logic. The date functions (CURDATE() vs DATE('now', '-30 days') ) are functionally equivalent in most SQL dialects for this purpose. The Generated SQL is more efficient as it avoids a join and directly operates on the transactions table.", "overall_assessment": "correct"}}
{"example_id": 4947, "sql_complexity": "aggregation", "prompt": "What is the total revenue for drugs approved between 2017 and 2019?", "context": "CREATE TABLE drug_sales_3 (drug_name TEXT, revenue FLOAT, year INT); INSERT INTO drug_sales_3 (drug_name, revenue, year) VALUES ('DrugG', 20000000, 2019), ('DrugG', 19000000, 2018), ('DrugH', 15000000, 2017), ('DrugH', 16000000, 2018);", "reference_sql": "SELECT drug_name, SUM(revenue) FROM drug_sales_3 WHERE year BETWEEN 2017 AND 2019 GROUP BY drug_name;", "generated_sql": "SELECT SUM(revenue) FROM drug_sales_3 WHERE year BETWEEN 2017 AND 2019;", "raw_model_output": "```sql\nSELECT SUM(revenue) FROM drug_sales_3 WHERE year BETWEEN 2017 AND 2019;\n```", "latency_sec": 0.8090569972991943, "total_duration_sec": 0.718289898, "load_duration_sec": 0.028350255, "tokens_prompt": 217, "prompt_eval_sec": 0.070317174, "tokens_completion": 32, "completion_eval_sec": 0.618904714, "tokens_total": 249, "tokens_per_sec": 307.76570851153303, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query groups results by drug_name, producing separate sums for each drug. The generated query lacks a GROUP BY clause, returning a single total sum for all drugs. The output structure and results differ.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query groups results by drug_name, returning per-drug totals, while the generated query calculates a single total revenue across all drugs in the specified period. The original question asks for 'total revenue for drugs' (plural), which implies an overall aggregate rather than per-drug breakdowns. The generated query is technically correct, more efficient (no grouping), and better aligns with the ambiguous phrasing of the question. The reference query would be correct if the intent was to analyze revenue by individual drugs, but this is not explicitly stated.", "overall_assessment": "differently_correct"}}
{"example_id": 4767, "sql_complexity": "window functions", "prompt": "List the top 2 AI algorithms with the highest explainability scores, by algorithm subtype, ordered by scores in descending order for the European region.", "context": "CREATE TABLE ai_algorithms (algorithm_id INT, algorithm_name VARCHAR(50), algorithm_subtype VARCHAR(50), region VARCHAR(50), explainability_score FLOAT); INSERT INTO ai_algorithms (algorithm_id, algorithm_name, algorithm_subtype, region, explainability_score) VALUES (1, 'AlgoA', 'Tree-based', 'Europe', 0.85), (2, 'AlgoB', 'Computer Vision', 'Europe', 0.92), (3, 'AlgoC', 'Tree-based', 'Europe', 0.78), (4, 'AlgoD', 'Transformer', 'Europe', 0.90), (5, 'AlgoE', 'Tree-based', 'Europe', 0.80);", "reference_sql": "SELECT algorithm_subtype, region, * FROM (SELECT algorithm_subtype, region, algorithm_id, algorithm_name, explainability_score, RANK() OVER (PARTITION BY algorithm_subtype ORDER BY explainability_score DESC) AS rank FROM ai_algorithms WHERE region = 'Europe') ranked WHERE rank <= 2 ORDER BY algorithm_subtype, region, explainability_score DESC;", "generated_sql": "SELECT\n  algorithm_name\nFROM ai_algorithms\nWHERE\n  region = 'Europe'\nORDER BY\n  explainability_score DESC\nLIMIT 2;", "raw_model_output": "```sql\nSELECT\n  algorithm_name\nFROM ai_algorithms\nWHERE\n  region = 'Europe'\nORDER BY\n  explainability_score DESC\nLIMIT 2;\n```", "latency_sec": 1.13535737991333, "total_duration_sec": 0.941652368, "load_duration_sec": 0.039386488, "tokens_prompt": 276, "prompt_eval_sec": 0.091538674, "tokens_completion": 41, "completion_eval_sec": 0.809493507, "tokens_total": 317, "tokens_per_sec": 279.20723959551736, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL selects top 2 algorithms per subtype in Europe using window function ranking, while the Generated SQL simply returns top 2 algorithms overall in Europe without considering subtypes. The Reference includes all columns and partitions by algorithm_subtype, whereas the Generated only selects algorithm_name and applies a global limit.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly addresses the business intent by grouping results by algorithm_subtype and selecting the top 2 algorithms within each subtype using RANK(). The Generated SQL fails to account for algorithm_subtype grouping, instead returning only the top 2 algorithms globally in Europe. While both queries are technically valid, their results differ fundamentally: the Reference returns up to 2 entries per subtype, while the Generated returns 2 entries total. The Reference properly handles the 'by algorithm subtype' requirement, whereas the Generated does not. The Generated query also omits algorithm_subtype from output, which is critical for the business question.", "overall_assessment": "differently_correct"}}
{"example_id": 4495, "sql_complexity": "basic SQL", "prompt": "Which countries are the top 3 sources of sustainable textiles?", "context": "CREATE TABLE Textile_Sources (Source_ID INT, Source_Country TEXT, Sustainable BOOLEAN, Quantity INT); INSERT INTO Textile_Sources (Source_ID, Source_Country, Sustainable, Quantity) VALUES (1, 'India', true, 1000), (2, 'Bangladesh', false, 800), (3, 'China', true, 1200), (4, 'Vietnam', false, 900), (5, 'Italy', true, 1100), (6, 'USA', false, 700);", "reference_sql": "SELECT Source_Country FROM Textile_Sources WHERE Sustainable = true ORDER BY Quantity DESC LIMIT 3;", "generated_sql": "SELECT Source_Country\nFROM Textile_Sources\nWHERE Sustainable = TRUE\nORDER BY Quantity DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT Source_Country\nFROM Textile_Sources\nWHERE Sustainable = TRUE\nORDER BY Quantity DESC\nLIMIT 3;\n```", "latency_sec": 0.7991750240325928, "total_duration_sec": 0.680113467, "load_duration_sec": 0.028973453, "tokens_prompt": 215, "prompt_eval_sec": 0.070213726, "tokens_completion": 30, "completion_eval_sec": 0.579985445, "tokens_total": 245, "tokens_per_sec": 306.5661371194305, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are semantically equivalent. The only differences are formatting (whitespace and uppercase/lowercase keywords) which do not affect SQL logic. Both select Source_Country from Textile_Sources where Sustainable is true, order by Quantity descending, and limit to 3 results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent as they produce identical results. The only difference is the case of the BOOLEAN literal ('true' vs 'TRUE'), which is irrelevant in SQL. Both correctly filter sustainable sources (Sustainable = true/TRUE), order by Quantity descending, and limit to 3 results. The business intent is fully fulfilled as the queries identify the top 3 countries by sustainable textile quantity. Neither query is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 2513, "sql_complexity": "single join", "prompt": "What is the total number of concert ticket sales for artists who released their first album between 2015 and 2017?", "context": "CREATE TABLE ConcertTicketSales (id INT, year INT, artist_id INT); CREATE TABLE ArtistAlbums (id INT, artist_id INT, year INT);", "reference_sql": "SELECT COUNT(DISTINCT cts.artist_id) FROM ConcertTicketSales cts JOIN ArtistAlbums a ON cts.artist_id = a.artist_id WHERE a.year BETWEEN 2015 AND 2017;", "generated_sql": "SELECT\n  SUM(T1.id)\nFROM ConcertTicketSales AS T1\nJOIN ArtistAlbums AS T2\n  ON T1.artist_id = T2.artist_id\nWHERE\n  T2.year BETWEEN 2015 AND 2017;", "raw_model_output": "```sql\nSELECT\n  SUM(T1.id)\nFROM ConcertTicketSales AS T1\nJOIN ArtistAlbums AS T2\n  ON T1.artist_id = T2.artist_id\nWHERE\n  T2.year BETWEEN 2015 AND 2017;\n```", "latency_sec": 1.5949580669403076, "total_duration_sec": 1.400561215, "load_duration_sec": 0.028130106, "tokens_prompt": 142, "prompt_eval_sec": 0.042451184, "tokens_completion": 68, "completion_eval_sec": 1.328653714, "tokens_total": 210, "tokens_per_sec": 131.66490351865747, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query counts distinct artist_ids from the join, while the generated query sums the id column from ConcertTicketSales. The aggregation functions (COUNT(DISTINCT) vs SUM) and the columns being aggregated (artist_id vs id) produce different results. The generated query's SUM(T1.id) would return a numeric total unrelated to artist counts.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query counts distinct artist_ids, which would return the number of artists, not the total ticket sales. The generated query sums T1.id (ticket sale IDs), which is meaningless as IDs are typically auto-incrementing integers. Neither query correctly calculates total ticket sales, but the reference query at least addresses the artist filtering. The original question requires summing actual sales quantities (which don't exist in the schema), making both queries technically flawed. The reference query is more aligned with the intent of identifying qualifying artists, while the generated query is fundamentally incorrect.", "overall_assessment": "differently_correct"}}
{"example_id": 873, "sql_complexity": "subqueries", "prompt": "Identify attorneys who have never handled cases in the 'West' region but have in the 'North' or 'South'.", "context": "CREATE TABLE attorney_regions(attorney_id INT, region VARCHAR(20)); INSERT INTO attorney_regions(attorney_id, region) VALUES (1, 'North'), (2, 'South'), (3, 'East'), (4, 'West'), (5, 'West'), (6, 'North'); CREATE TABLE handled_cases(attorney_id INT, case_id INT); INSERT INTO handled_cases(attorney_id, case_id) VALUES (1, 101), (2, 102), (3, 103), (4, 104), (5, 105), (6, 106), (1, 107), (1, 108);", "reference_sql": "SELECT h.attorney_id FROM attorney_regions h LEFT JOIN handled_cases i ON h.attorney_id = i.attorney_id WHERE h.region IN ('North', 'South') AND h.region != 'West' AND i.attorney_id IS NOT NULL AND h.attorney_id NOT IN (SELECT attorney_id FROM attorney_regions WHERE region = 'West');", "generated_sql": "SELECT DISTINCT\n  attorney_id\nFROM attorney_regions\nWHERE\n  region IN ('North', 'South')\n  AND attorney_id NOT IN (\n    SELECT\n      attorney_id\n    FROM attorney_regions\n    WHERE\n      region = 'West'\n  );", "raw_model_output": "```sql\nSELECT DISTINCT\n  attorney_id\nFROM attorney_regions\nWHERE\n  region IN ('North', 'South')\n  AND attorney_id NOT IN (\n    SELECT\n      attorney_id\n    FROM attorney_regions\n    WHERE\n      region = 'West'\n  );\n```", "latency_sec": 1.7735869884490967, "total_duration_sec": 1.469767035, "load_duration_sec": 0.028602342, "tokens_prompt": 269, "prompt_eval_sec": 0.089489877, "tokens_completion": 68, "completion_eval_sec": 1.350779766, "tokens_total": 337, "tokens_per_sec": 190.01041516136053, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a LEFT JOIN with handled_cases and checks for non-NULL attorney_id in that table, ensuring only attorneys with cases are selected. The Generated SQL omits this condition, focusing only on region constraints. This makes the Reference SQL more restrictive, as it filters out attorneys without cases, while the Generated SQL includes all North/South region attorneys regardless of case ownership.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries identify attorneys in North/South regions who are not in West. The Reference SQL includes a redundant LEFT JOIN with handled_cases and an unnecessary 'h.region != 'West'' condition (since 'IN ('North', 'South')' already excludes West). The Generated SQL directly filters attorney_regions with a NOT IN clause, achieving the same result more efficiently. While both fulfill the business intent, the Generated SQL is simpler, avoids unnecessary joins, and maintains clarity.", "overall_assessment": "correct"}}
{"example_id": 471, "sql_complexity": "set operations", "prompt": "Find the number of donations made by first-time donors in the last quarter.", "context": "CREATE TABLE Donations (DonationID INT, DonorID INT, DonationDate DATE, DonationType TEXT, DonationAmount FLOAT); INSERT INTO Donations (DonationID, DonorID, DonationDate, DonationType, DonationAmount) VALUES (1, 1, '2021-01-01', 'Individual', 100), (2, 2, '2021-02-01', 'Corporate', 5000);", "reference_sql": "SELECT COUNT(*) FROM (SELECT DonationID FROM Donations WHERE DonationType = 'Individual' AND DonationDate >= DATEADD(quarter, -1, CURRENT_DATE) EXCEPT SELECT DonationID FROM PreviousDonations) AS FirstTimeDonors;", "generated_sql": "SELECT\n  COUNT(DISTINCT T1.DonorID)\nFROM Donations AS T1\nWHERE\n  T1.DonationDate >= DATE('now', '-3 months') AND T1.DonationDate < DATE('now');", "raw_model_output": "```sql\nSELECT\n  COUNT(DISTINCT T1.DonorID)\nFROM Donations AS T1\nWHERE\n  T1.DonationDate >= DATE('now', '-3 months') AND T1.DonationDate < DATE('now');\n```", "latency_sec": 1.2735297679901123, "total_duration_sec": 1.183220759, "load_duration_sec": 0.028816327, "tokens_prompt": 195, "prompt_eval_sec": 0.056805985, "tokens_completion": 56, "completion_eval_sec": 1.096713001, "tokens_total": 251, "tokens_per_sec": 197.0900141550117, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL counts unique DonationIDs from Donations (filtered by 'Individual' type and recent quarter) excluding those in PreviousDonations, while the Generated SQL counts distinct DonorIDs from all donations in the last 3 months without type filtering or exclusion logic. Key differences include: 1) DonationType filter vs no filter, 2) EXCEPT clause vs no exclusion, 3) DonationID vs DonorID counting, and 4) slightly different date range handling (quarter vs 3 months).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL references a non-existent 'PreviousDonations' table, making it technically invalid. The Generated SQL is syntactically correct but fails to identify first-time donors by not checking for prior donations. While the Generated SQL correctly filters donations in the last quarter, it counts distinct DonorIDs without ensuring they are first-time donors. The Reference SQL's logic (EXCEPT clause) would have been appropriate if the 'PreviousDonations' table existed, but its absence renders it non-functional. The Generated SQL is more syntactically valid but semantically incomplete.", "overall_assessment": "incorrect"}}
{"example_id": 1301, "sql_complexity": "multiple_joins", "prompt": "What is the total quantity of corn sold by farmers in 'Summerfield'?", "context": "CREATE TABLE farmers (id INT, name VARCHAR(50), location VARCHAR(50), crops VARCHAR(50)); CREATE TABLE crops (id INT, name VARCHAR(50), yield INT); CREATE TABLE sales (id INT, farmer_id INT, crop_name VARCHAR(50), quantity INT, price DECIMAL(5,2)); INSERT INTO farmers VALUES (1, 'Jane Doe', 'Summerfield', 'Corn'); INSERT INTO crops VALUES (1, 'Corn', 100); INSERT INTO sales VALUES (1, 1, 'Corn', 50, 2.50);", "reference_sql": "SELECT SUM(quantity) FROM sales INNER JOIN farmers ON sales.farmer_id = farmers.id INNER JOIN crops ON sales.crop_name = crops.name WHERE farmers.location = 'Summerfield' AND crops.name = 'Corn';", "generated_sql": "SELECT\n  SUM(s.quantity)\nFROM sales AS s\nJOIN farmers AS f\n  ON s.farmer_id = f.id\nWHERE\n  f.location = 'Summerfield' AND s.crop_name = 'Corn';", "raw_model_output": "```sql\nSELECT\n  SUM(s.quantity)\nFROM sales AS s\nJOIN farmers AS f\n  ON s.farmer_id = f.id\nWHERE\n  f.location = 'Summerfield' AND s.crop_name = 'Corn';\n```", "latency_sec": 1.367438793182373, "total_duration_sec": 1.265538109, "load_duration_sec": 0.028294211, "tokens_prompt": 222, "prompt_eval_sec": 0.07105208, "tokens_completion": 59, "completion_eval_sec": 1.165003305, "tokens_total": 281, "tokens_per_sec": 205.493658217815, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes an explicit JOIN with the 'crops' table to filter by 'crops.name = 'Corn'', while the Generated SQL relies on 'sales.crop_name = 'Corn'' without verifying the existence of the crop in the 'crops' table. This means the Generated SQL might include sales records with invalid crop names not present in the 'crops' table, making them semantically different.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the total quantity of corn sold by farmers in 'Summerfield'. The reference query includes an unnecessary JOIN with the 'crops' table, which doesn't affect the result in this specific case (since sales.crop_name = 'Corn' matches crops.name = 'Corn'). The generated query is more efficient by eliminating the redundant join while maintaining semantic equivalence. Both satisfy the business intent of aggregating corn sales from Summerfield farmers.", "overall_assessment": "correct"}}
{"example_id": 4667, "sql_complexity": "aggregation", "prompt": "Find the number of unique organizations in each country in the Philanthropy Trends table?", "context": "CREATE TABLE PhilanthropyTrends (OrgID INT, Name TEXT, Country TEXT);", "reference_sql": "SELECT Country, COUNT(DISTINCT OrgID) as UniqueOrganizations FROM PhilanthropyTrends GROUP BY Country;", "generated_sql": "SELECT Country, COUNT(DISTINCT OrgID) AS NumberOfOrganizations\nFROM PhilanthropyTrends\nGROUP BY Country;", "raw_model_output": "```sql\nSELECT Country, COUNT(DISTINCT OrgID) AS NumberOfOrganizations\nFROM PhilanthropyTrends\nGROUP BY Country;\n```", "latency_sec": 0.942047119140625, "total_duration_sec": 0.637026366, "load_duration_sec": 0.028371423, "tokens_prompt": 112, "prompt_eval_sec": 0.032708171, "tokens_completion": 30, "completion_eval_sec": 0.575232501, "tokens_total": 142, "tokens_per_sec": 150.73555994687226, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries group by 'Country' and count distinct 'OrgID' values. The only difference is the column alias name ('UniqueOrganizations' vs 'NumberOfOrganizations'), which does not affect the semantic result set. The aggregation logic and grouping structure are identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are structurally identical in terms of syntax, logic, and output. The only difference is the column alias name ('UniqueOrganizations' vs 'NumberOfOrganizations'), which does not affect the computation or results. Both correctly count distinct OrgID values per Country, fulfilling the business requirement to measure unique organizations per country. Neither query demonstrates superior efficiency or elegance as they perform the same operations with identical structure.", "overall_assessment": "correct"}}
{"example_id": 1006, "sql_complexity": "subqueries", "prompt": "What is the average word count of news articles written by investigative journalists?", "context": "CREATE TABLE reporters (id INT, name VARCHAR(50), gender VARCHAR(10), age INT, position VARCHAR(20), country VARCHAR(50)); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (1, 'Anna Smith', 'Female', 35, 'News Reporter', 'USA'); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (2, 'Mike Johnson', 'Male', 40, 'Investigative Journalist', 'Canada'); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (3, 'Sofia Rodriguez', 'Female', 32, 'Investigative Journalist', 'Mexico'); CREATE TABLE news_articles (id INT, title VARCHAR(100), content TEXT, publication_date DATE, reporter_id INT); INSERT INTO news_articles (id, title, content, publication_date, reporter_id) VALUES (1, 'News Article 1', 'Content of News Article 1', '2021-01-01', 2); INSERT INTO news_articles (id, title, content, publication_date, reporter_id) VALUES (2, 'News Article 2', 'Content of News Article 2', '2021-02-01', 3);", "reference_sql": "SELECT AVG(LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1) AS avg_word_count FROM news_articles WHERE reporter_id IN (SELECT id FROM reporters WHERE position = 'Investigative Journalist');", "generated_sql": "SELECT AVG(LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1) AS average_word_count\nFROM news_articles\nWHERE reporter_id IN (SELECT id FROM reporters WHERE position = 'Investigative Journalist');", "raw_model_output": "```sql\nSELECT AVG(LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1) AS average_word_count\nFROM news_articles\nWHERE reporter_id IN (SELECT id FROM reporters WHERE position = 'Investigative Journalist');\n```", "latency_sec": 1.6309161186218262, "total_duration_sec": 1.372373814, "load_duration_sec": 0.028325293, "tokens_prompt": 381, "prompt_eval_sec": 0.132704786, "tokens_completion": 60, "completion_eval_sec": 1.210129939, "tokens_total": 441, "tokens_per_sec": 270.400172617497, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. Both calculate the average word count of news articles written by 'Investigative Journalist' reporters using the same logic (LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1). The only difference is the column alias name ('avg_word_count' vs 'average_word_count'), which does not affect the result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically identical except for the column alias name ('avg_word_count' vs 'average_word_count'). The logic for calculating word count (length difference between content and content without spaces + 1) is correct, and the filtering for investigative journalists is properly implemented via a subquery. The business intent is fully addressed by calculating the average word count for articles written by the specified reporter type. Neither query has performance advantages over the other.", "overall_assessment": "correct"}}
{"example_id": 3635, "sql_complexity": "set operations", "prompt": "Which brands have certifications related to cruelty-free, vegan, or organic products?", "context": "CREATE TABLE brands (brand_name VARCHAR(50), is_cruelty_free BOOLEAN, is_vegan BOOLEAN, is_organic BOOLEAN); INSERT INTO brands (brand_name, is_cruelty_free, is_vegan, is_organic) VALUES ('Lush', TRUE, TRUE, FALSE), ('The Body Shop', TRUE, FALSE, FALSE), ('Est\u00e9e Lauder', FALSE, FALSE, FALSE), ('Urban Decay', TRUE, TRUE, FALSE), ('Maybelline', FALSE, FALSE, FALSE), ('Kat Von D', TRUE, TRUE, FALSE), ('Tarte', TRUE, TRUE, TRUE);", "reference_sql": "SELECT brand_name, 'Cruelty-free' as certification FROM brands WHERE is_cruelty_free = TRUE UNION SELECT brand_name, 'Vegan' as certification FROM brands WHERE is_vegan = TRUE UNION SELECT brand_name, 'Organic' as certification FROM brands WHERE is_organic = TRUE;", "generated_sql": "SELECT brand_name\nFROM brands\nWHERE is_cruelty_free = TRUE OR is_vegan = TRUE OR is_organic = TRUE;", "raw_model_output": "```sql\nSELECT brand_name\nFROM brands\nWHERE is_cruelty_free = TRUE OR is_vegan = TRUE OR is_organic = TRUE;\n```", "latency_sec": 0.9235119819641113, "total_duration_sec": 0.806395991, "load_duration_sec": 0.02857619, "tokens_prompt": 227, "prompt_eval_sec": 0.071666651, "tokens_completion": 36, "completion_eval_sec": 0.705130448, "tokens_total": 263, "tokens_per_sec": 284.7824447720273, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns brand names with their corresponding certification type (Cruelty-free/Vegan/Organic) as separate rows, allowing multiple certifications per brand. The Generated SQL returns only brand names (without certification types) and collapses multiple certifications into a single row per brand. The output structures and row counts differ.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because the reference query returns brand_name and certification type (3 columns) while the generated query only returns brand_name (1 column). However, both correctly identify brands with at least one certification. The generated query is more efficient as it uses a single scan with OR conditions, whereas the reference requires three separate scans and UNION operations. The original question asks for brands with any certification, not the specific certification types, making the generated query sufficient for the business intent. The reference provides additional detail not requested.", "overall_assessment": "correct"}}
{"example_id": 4932, "sql_complexity": "basic SQL", "prompt": "Delete the workout row with the id of 2.", "context": "CREATE TABLE Workouts (id INT, user_id INT, workout_name TEXT, calories INT); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (1, 1, 'Running', 300); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (2, 1, 'Cycling', 400); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (3, 2, 'Yoga', 200);", "reference_sql": "DELETE FROM Workouts WHERE id = 2;", "generated_sql": "DELETE FROM Workouts WHERE id = 2;", "raw_model_output": "```sql\nDELETE FROM Workouts WHERE id = 2;\n```", "latency_sec": 0.4089930057525635, "total_duration_sec": 0.403005977, "load_duration_sec": 0.028747307, "tokens_prompt": 208, "prompt_eval_sec": 0.069633804, "tokens_completion": 16, "completion_eval_sec": 0.303332718, "tokens_total": 224, "tokens_per_sec": 547.6866275202703, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They both delete the record from the Workouts table where the id is 2. The SQL syntax, table name, and WHERE condition are exactly the same in both queries.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical: DELETE FROM Workouts WHERE id = 2;. They correctly delete the row with id=2 as required. The query is technically correct, semantically equivalent, and fulfills the business intent of removing the specific workout record. The simplicity and directness of the query make it both efficient and elegant for this task.", "overall_assessment": "correct"}}
{"example_id": 365, "sql_complexity": "aggregation", "prompt": "Identify the total number of military personnel and their corresponding rank for each branch and country in the 'military_personnel' table, sorted by the total number of personnel in descending order.", "context": "CREATE TABLE military_personnel (id INT, branch VARCHAR(255), rank VARCHAR(255), country VARCHAR(255), personnel INT);", "reference_sql": "SELECT branch, country, SUM(personnel) as total_personnel FROM military_personnel GROUP BY branch, country ORDER BY total_personnel DESC;", "generated_sql": "SELECT branch, country, rank, SUM(personnel) AS total_personnel\nFROM military_personnel\nGROUP BY branch, country, rank\nORDER BY total_personnel DESC;", "raw_model_output": "```sql\nSELECT branch, country, rank, SUM(personnel) AS total_personnel\nFROM military_personnel\nGROUP BY branch, country, rank\nORDER BY total_personnel DESC;\n```", "latency_sec": 1.0652809143066406, "total_duration_sec": 0.968989611, "load_duration_sec": 0.0283428, "tokens_prompt": 151, "prompt_eval_sec": 0.047075459, "tokens_completion": 46, "completion_eval_sec": 0.892546574, "tokens_total": 197, "tokens_per_sec": 184.92774755870042, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their GROUP BY clauses. The reference query groups by (branch, country), while the generated query groups by (branch, country, rank). This causes the generated query to split results by rank within each branch/country combination, producing more rows and different aggregation outcomes. The additional 'rank' column in the SELECT and GROUP BY also changes the result structure.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly groups by branch and country to calculate total personnel per combination, while the generated query adds an unnecessary 'rank' column to the GROUP BY clause. This causes the generated query to aggregate personnel by branch, country, and rank instead of providing total personnel per branch/country. The original question explicitly asked for 'total number of military personnel and their corresponding rank' but the correct interpretation is to show total personnel per branch/country (not per rank). The reference query aligns with this requirement, while the generated query incorrectly breaks down results by rank. The reference query is more efficient as it processes fewer groups.", "overall_assessment": "differently_correct"}}
{"example_id": 521, "sql_complexity": "subqueries", "prompt": "How many vessels have not had an inspection in the past year?", "context": "CREATE TABLE safety_records(id INT, vessel_name VARCHAR(50), inspection_date DATE); CREATE TABLE vessels(id INT, name VARCHAR(50), country VARCHAR(50)); INSERT INTO vessels(id, name, country) VALUES (1, 'Vessel A', 'Philippines'), (2, 'Vessel B', 'Philippines'); INSERT INTO safety_records(id, vessel_name, inspection_date) VALUES (1, 'Vessel A', '2022-01-01');", "reference_sql": "SELECT COUNT(*) FROM vessels WHERE name NOT IN (SELECT vessel_name FROM safety_records WHERE inspection_date BETWEEN DATE_SUB(NOW(), INTERVAL 1 YEAR) AND NOW());", "generated_sql": "SELECT\n  COUNT(v.id)\nFROM vessels AS v\nWHERE\n  v.id NOT IN (\n    SELECT\n      vessel_name\n    FROM safety_records\n    WHERE\n      inspection_date >= DATE('now', '-1 year')\n  );", "raw_model_output": "```sql\nSELECT\n  COUNT(v.id)\nFROM vessels AS v\nWHERE\n  v.id NOT IN (\n    SELECT\n      vessel_name\n    FROM safety_records\n    WHERE\n      inspection_date >= DATE('now', '-1 year')\n  );\n```", "latency_sec": 1.4660887718200684, "total_duration_sec": 1.378898032, "load_duration_sec": 0.028657431, "tokens_prompt": 204, "prompt_eval_sec": 0.069330718, "tokens_completion": 65, "completion_eval_sec": 1.28006662, "tokens_total": 269, "tokens_per_sec": 183.4813861005506, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the columns being compared. The Reference SQL checks 'name NOT IN (SELECT vessel_name...)', comparing vessel names, while the Generated SQL uses 'v.id NOT IN (SELECT vessel_name...)', comparing vessel IDs (integers) to vessel names (strings). This type mismatch makes them semantically different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly identifies vessels without recent inspections by comparing vessel names (strings) against a subquery of vessel_names. The generated query contains a critical technical error: it compares v.id (integer) to vessel_name (string) in the NOT IN clause, which would cause a type mismatch error. Additionally, the generated query uses DATE('now', '-1 year') which is SQLite syntax, while the reference uses standard DATE_SUB() function. The reference query properly addresses the business intent by focusing on vessel names and uses correct syntax.", "overall_assessment": "incorrect"}}
{"example_id": 5687, "sql_complexity": "multiple_joins", "prompt": "List organizations with more than 200 volunteers, and their average donation amounts, excluding donations less than $10.", "context": "CREATE TABLE organizations (org_id INT, org_name TEXT, social_impact_score INT);CREATE TABLE volunteers (vol_id INT, org_id INT, vol_country TEXT);CREATE TABLE donations (donation_id INT, donor_id INT, donation_amount INT, donation_date DATE);", "reference_sql": "SELECT o.org_name, AVG(donation_amount) AS avg_donation_amount FROM organizations o JOIN volunteers v ON o.org_id = v.org_id JOIN donations don ON o.org_id = don.org_id WHERE donation_amount >= 10 GROUP BY o.org_name HAVING COUNT(v.vol_id) > 200;", "generated_sql": "SELECT\n  o.org_name,\n  AVG(d.donation_amount) AS average_donation_amount\nFROM organizations AS o\nJOIN volunteers AS v\n  ON o.org_id = v.org_id\nJOIN donations AS d\n  ON o.org_id = d.donation_id\nWHERE\n  d.donation_amount >= 10\nGROUP BY\n  o.org_name\nHAVING\n  COUNT(v.vol_id) > 200;", "raw_model_output": "```sql\nSELECT\n  o.org_name,\n  AVG(d.donation_amount) AS average_donation_amount\nFROM organizations AS o\nJOIN volunteers AS v\n  ON o.org_id = v.org_id\nJOIN donations AS d\n  ON o.org_id = d.donation_id\nWHERE\n  d.donation_amount >= 10\nGROUP BY\n  o.org_name\nHAVING\n  COUNT(v.vol_id) > 200;\n```", "latency_sec": 2.5281407833099365, "total_duration_sec": 2.387106062, "load_duration_sec": 0.038983911, "tokens_prompt": 169, "prompt_eval_sec": 0.051455985, "tokens_completion": 116, "completion_eval_sec": 2.295804303, "tokens_total": 285, "tokens_per_sec": 112.73106382424928, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The key difference lies in the JOIN condition between 'organizations' and 'donations'. The Reference SQL uses 'o.org_id = don.org_id' (but 'donations' table lacks an 'org_id' column per schema), while the Generated SQL uses 'o.org_id = d.donation_id' (which incorrectly matches an 'org_id' to a 'donation_id' column). This discrepancy in join logic would produce different results, even if both queries have schema inconsistencies.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent due to a critical join error in the generated SQL. The reference query correctly joins donations on `o.org_id = don.org_id`, while the generated query mistakenly uses `o.org_id = d.donation_id` (a column that doesn't exist in the schema). This would cause a logical error, leading to incorrect or empty results. Both queries filter donations >= $10 and count volunteers >200, but the generated query's flawed join prevents it from fulfilling the business intent. The reference query is both technically correct and semantically aligned with the requirements.", "overall_assessment": "incorrect"}}
{"example_id": 1281, "sql_complexity": "subqueries", "prompt": "Find the top 3 contributors with the lowest recycling rate in the 'waste_contributors' table.", "context": "CREATE TABLE waste_contributors (contributor VARCHAR(20), recycling_rate FLOAT); INSERT INTO waste_contributors (contributor, recycling_rate) VALUES ('Manufacturing', 0.4), ('Commercial', 0.38), ('Residential', 0.35), ('Institutional', 0.32), ('Agricultural', 0.2), ('Industrial', 0.15);", "reference_sql": "SELECT contributor FROM waste_contributors WHERE recycling_rate IN (SELECT MIN(recycling_rate) FROM waste_contributors) LIMIT 3;", "generated_sql": "SELECT contributor FROM waste_contributors ORDER BY recycling_rate ASC LIMIT 3;", "raw_model_output": "```sql\nSELECT contributor FROM waste_contributors ORDER BY recycling_rate ASC LIMIT 3;\n```", "latency_sec": 0.8134899139404297, "total_duration_sec": 0.511816516, "load_duration_sec": 0.034450666, "tokens_prompt": 184, "prompt_eval_sec": 0.05589763, "tokens_completion": 22, "completion_eval_sec": 0.420671531, "tokens_total": 206, "tokens_per_sec": 253.2299374213077, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query selects contributors with the minimum recycling rate (only 'Industrial' in this case) and limits to 3 rows. The generated query orders all contributors by ascending recycling rate and returns the top 3 (Industrial, Agricultural, Institutional). The first query returns only the absolute minimum value(s), while the second returns the three lowest values, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query uses a subquery to find contributors with the minimum recycling rate (which would only return 1 row in this dataset) and then applies LIMIT 3. This approach would not reliably return the top 3 lowest rates if there are ties or multiple contributors with the same minimum. The generated query correctly orders all contributors by recycling_rate in ascending order and explicitly limits to 3 results, ensuring the three lowest rates are returned. While both queries aim to find low recycling rates, only the generated query properly addresses the 'top 3' requirement.", "overall_assessment": "differently_correct"}}
{"example_id": 5669, "sql_complexity": "window functions", "prompt": "What is the total number of new and returning volunteers in each program in each month?", "context": "CREATE TABLE Volunteers (VolunteerID INT, VolunteerName TEXT, ProgramID INT, VolunteerDate DATE, IsReturning BOOLEAN); INSERT INTO Volunteers (VolunteerID, VolunteerName, ProgramID, VolunteerDate, IsReturning) VALUES (6, 'David Kim', 1, '2022-03-01', FALSE), (7, 'Emily Chen', 2, '2022-03-15', TRUE), (8, 'James Lee', 2, '2022-04-01', FALSE), (9, 'Grace Park', 3, '2022-04-15', TRUE), (10, 'Daniel Kim', 1, '2022-04-01', FALSE);", "reference_sql": "SELECT ProgramID, EXTRACT(MONTH FROM VolunteerDate) AS Month, SUM(CASE WHEN IsReturning THEN 1 ELSE 0 END) OVER (PARTITION BY ProgramID, EXTRACT(MONTH FROM VolunteerDate) ORDER BY ProgramID, EXTRACT(MONTH FROM VolunteerDate)) + COUNT(DISTINCT VolunteerID) OVER (PARTITION BY ProgramID, EXTRACT(MONTH FROM VolunteerDate) ORDER BY ProgramID, EXTRACT(MONTH FROM VolunteerDate)) AS TotalVolunteers FROM Volunteers;", "generated_sql": "SELECT\n  ProgramID,\n  STRFTIME('%Y-%m', VolunteerDate) AS VolunteerMonth,\n  COUNT(VolunteerID) AS TotalVolunteers\nFROM Volunteers\nWHERE IsReturning = TRUE OR IsReturning = FALSE\nGROUP BY\n  ProgramID,\n  VolunteerMonth;", "raw_model_output": "```sql\nSELECT\n  ProgramID,\n  STRFTIME('%Y-%m', VolunteerDate) AS VolunteerMonth,\n  COUNT(VolunteerID) AS TotalVolunteers\nFROM Volunteers\nWHERE IsReturning = TRUE OR IsReturning = FALSE\nGROUP BY\n  ProgramID,\n  VolunteerMonth;\n```", "latency_sec": 1.6456661224365234, "total_duration_sec": 1.449346472, "load_duration_sec": 0.028225587, "tokens_prompt": 263, "prompt_eval_sec": 0.089185311, "tokens_completion": 67, "completion_eval_sec": 1.331183427, "tokens_total": 330, "tokens_per_sec": 200.52670192384588, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates a total by summing returning volunteers and distinct volunteer counts using window functions, while the Generated SQL simply counts all volunteers (due to the redundant WHERE condition). The Reference's 'TotalVolunteers' combines two separate aggregates (returning count + distinct count), whereas the Generated SQL's count includes all volunteers without distinguishing returning status. Additionally, the Reference uses EXTRACT(MONTH) while the Generated uses STRFTIME('%Y-%m'), leading to different month formatting but not affecting equivalence. The core logic of aggregating counts differs fundamentally.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL contains logical errors: it incorrectly adds a windowed SUM of returning volunteers to a windowed COUNT of distinct volunteers, resulting in double-counting. It also uses EXTRACT(MONTH) without year handling, risking incorrect grouping across years. The Generated SQL is syntactically correct, uses STRFTIME for proper date formatting, and avoids redundant WHERE clauses. However, neither query properly separates new and returning volunteers as required by the question. The Generated SQL is more efficient and elegant but fails to fulfill the business intent of distinguishing new vs. returning volunteers.", "overall_assessment": "incorrect"}}
{"example_id": 3576, "sql_complexity": "window functions", "prompt": "What is the difference in the number of eco-friendly hotels between the top 2 countries?", "context": "CREATE TABLE eco_hotel_count (country TEXT, num_hotels INT); INSERT INTO eco_hotel_count (country, num_hotels) VALUES ('France', 100), ('Italy', 120), ('Germany', 150), ('Spain', 110), ('UK', 160);", "reference_sql": "SELECT (MAX(num_hotels) OVER (PARTITION BY num_hotels <= 2) - MIN(num_hotels) OVER (PARTITION BY num_hotels <= 2)) AS hotel_difference FROM eco_hotel_count WHERE country IN ('France', 'Italy');", "generated_sql": "SELECT\n  ABS(num_hotels - (\n    SELECT\n      num_hotels\n    FROM eco_hotel_count\n    ORDER BY\n      num_hotels DESC\n    LIMIT 1\n  ))\nFROM eco_hotel_count\nORDER BY\n  num_hotels DESC\nLIMIT 1;", "raw_model_output": "```sql\nSELECT\n  ABS(num_hotels - (\n    SELECT\n      num_hotels\n    FROM eco_hotel_count\n    ORDER BY\n      num_hotels DESC\n    LIMIT 1\n  ))\nFROM eco_hotel_count\nORDER BY\n  num_hotels DESC\nLIMIT 1;\n```", "latency_sec": 1.7799699306488037, "total_duration_sec": 1.47358857, "load_duration_sec": 0.028309337, "tokens_prompt": 170, "prompt_eval_sec": 0.051159321, "tokens_completion": 71, "completion_eval_sec": 1.393328172, "tokens_total": 241, "tokens_per_sec": 135.39554564955762, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the difference between max and min num_hotels for countries France and Italy (120-100=20), while the Generated SQL computes the absolute difference between each hotel's count and the global maximum (160), returning 0 for the highest value (UK). The queries operate on different datasets (France/Italy vs all countries) and produce different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference SQL is fundamentally flawed: it restricts to only France and Italy (not the top 2 countries) and uses invalid window function partitioning logic (PARTITION BY num_hotels <= 2). The generated SQL attempts to find the maximum value but incorrectly calculates the difference between each row and the maximum, then returns the first result (which is 0). Neither query correctly identifies the top 2 countries or calculates their difference. However, the generated SQL at least attempts to find the maximum value, while the reference SQL completely misinterprets the question by limiting to irrelevant countries. The correct approach would require identifying the top 2 values and subtracting them.", "overall_assessment": "incorrect"}}
{"example_id": 1970, "sql_complexity": "multiple_joins", "prompt": "List all players who have played a specific VR game, 'CyberSphere', and their ages.", "context": "CREATE TABLE Players (PlayerID INT, Age INT, Gender VARCHAR(10), Country VARCHAR(50)); CREATE TABLE VRPlayers (PlayerID INT, VRGameID INT); CREATE TABLE VRGames (VRGameID INT, Title VARCHAR(50)); INSERT INTO Players (PlayerID, Age, Gender, Country) VALUES (1, 25, 'Male', 'USA'); INSERT INTO Players (PlayerID, Age, Gender, Country) VALUES (2, 28, 'Female', 'Canada'); INSERT INTO VRPlayers (PlayerID, VRGameID) VALUES (1, 1); INSERT INTO VRPlayers (PlayerID, VRGameID) VALUES (2, 1); INSERT INTO VRGames (VRGameID, Title) VALUES (1, 'CyberSphere');", "reference_sql": "SELECT Players.Age, Players.PlayerID FROM Players INNER JOIN VRPlayers ON Players.PlayerID = VRPlayers.PlayerID INNER JOIN VRGames ON VRPlayers.VRGameID = VRGames.VRGameID WHERE VRGames.Title = 'CyberSphere';", "generated_sql": "SELECT\n  P.Age\nFROM Players AS P\nJOIN VRPlayers AS VP\n  ON P.PlayerID = VP.PlayerID\nJOIN VRGames AS VG\n  ON VP.VRGameID = VG.VRGameID\nWHERE\n  VG.Title = 'CyberSphere';", "raw_model_output": "```sql\nSELECT\n  P.Age\nFROM Players AS P\nJOIN VRPlayers AS VP\n  ON P.PlayerID = VP.PlayerID\nJOIN VRGames AS VG\n  ON VP.VRGameID = VG.VRGameID\nWHERE\n  VG.Title = 'CyberSphere';\n```", "latency_sec": 1.6130919456481934, "total_duration_sec": 1.450713856, "load_duration_sec": 0.028154893, "tokens_prompt": 263, "prompt_eval_sec": 0.090512012, "tokens_completion": 67, "completion_eval_sec": 1.330914182, "tokens_total": 330, "tokens_per_sec": 204.5760633113788, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL selects both Players.Age and Players.PlayerID, while the Generated SQL only selects P.Age. The column lists differ, making the result sets non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent. The reference query selects both PlayerID and Age, while the generated query only selects Age. Although both correctly identify players who played 'CyberSphere', the original question explicitly requests 'players' (implying identifiers) and their ages. The generated query omits PlayerID, which is critical for uniquely identifying players. Both queries have the same logical structure and efficiency, but the reference query fully addresses the business intent by including both attributes.", "overall_assessment": "differently_correct"}}
{"example_id": 2414, "sql_complexity": "window functions", "prompt": "List the policy areas with the lowest citizen satisfaction scores.", "context": "CREATE TABLE Policy (Area VARCHAR(20), Score INT); INSERT INTO Policy (Area, Score) VALUES ('Transportation', 70), ('Education', 85), ('Healthcare', 75), ('PublicSafety', 80);", "reference_sql": "SELECT Area, Score FROM (SELECT Area, Score, ROW_NUMBER() OVER (ORDER BY Score) AS RN FROM Policy) X WHERE RN IN (1, 2);", "generated_sql": "SELECT Area FROM Policy ORDER BY Score ASC LIMIT 1;", "raw_model_output": "```sql\nSELECT Area FROM Policy ORDER BY Score ASC LIMIT 1;\n```", "latency_sec": 0.49697279930114746, "total_duration_sec": 0.41490957, "load_duration_sec": 0.028686896, "tokens_prompt": 142, "prompt_eval_sec": 0.04168582, "tokens_completion": 18, "completion_eval_sec": 0.343789697, "tokens_total": 160, "tokens_per_sec": 321.949209745473, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns the top 2 rows ordered by Score (Transportation and Healthcare), while the Generated SQL only returns the top 1 row (Transportation). The number of results and the specific rows returned differ, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly identifies the two lowest scores using ROW_NUMBER() and explicitly returns two rows, aligning with the plural 'policy areas' in the question. The Generated SQL only returns a single row, failing to capture multiple areas with the same lowest score. While both are technically valid, the Reference SQL better fulfills the business intent of identifying the 'lowest scores' (plural) by returning multiple results. The Generated SQL is inefficient for the task as it limits to one result, which may not represent all lowest-scoring areas.", "overall_assessment": "differently_correct"}}
{"example_id": 1898, "sql_complexity": "single join", "prompt": "What are the total sales for each drug in Q2 2020?", "context": "CREATE TABLE drugs (drug_id INT, drug_name TEXT); INSERT INTO drugs (drug_id, drug_name) VALUES (1001, 'Ibuprofen'), (1002, 'Paracetamol'), (1003, 'Aspirin'); CREATE TABLE sales (sale_id INT, drug_id INT, sale_date DATE, revenue FLOAT); INSERT INTO sales (sale_id, drug_id, sale_date, revenue) VALUES (1, 1001, '2020-04-05', 1800.0), (2, 1002, '2020-04-10', 2300.0), (3, 1003, '2020-04-15', 1400.0), (4, 1001, '2020-05-20', 1900.0), (5, 1002, '2020-06-25', 2400.0);", "reference_sql": "SELECT drug_name, SUM(revenue) as total_sales FROM sales JOIN drugs ON sales.drug_id = drugs.drug_id WHERE sale_date BETWEEN '2020-04-01' AND '2020-06-30' GROUP BY drug_name;", "generated_sql": "SELECT\n  d.drug_name,\n  SUM(s.revenue)\nFROM drugs AS d\nJOIN sales AS s\n  ON d.drug_id = s.drug_id\nWHERE\n  s.sale_date BETWEEN '2020-04-01' AND '2020-06-30'\nGROUP BY\n  d.drug_name;", "raw_model_output": "```sql\nSELECT\n  d.drug_name,\n  SUM(s.revenue)\nFROM drugs AS d\nJOIN sales AS s\n  ON d.drug_id = s.drug_id\nWHERE\n  s.sale_date BETWEEN '2020-04-01' AND '2020-06-30'\nGROUP BY\n  d.drug_name;\n```", "latency_sec": 2.286364793777466, "total_duration_sec": 2.02971937, "load_duration_sec": 0.028698859, "tokens_prompt": 342, "prompt_eval_sec": 0.120029248, "tokens_completion": 93, "completion_eval_sec": 1.880148119, "tokens_total": 435, "tokens_per_sec": 190.25835299069033, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between 'drugs' and 'sales' on drug_id, filter sales between '2020-04-01' and '2020-06-30', and group by drug_name to calculate total sales. The generated query uses table aliases (d/drugs, s/sales) but maintains identical logical structure, column references, and aggregation logic. The semantic meaning remains unchanged.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent as they perform the same operations: joining the drugs and sales tables on drug_id, filtering sales between 2020-04-01 and 2020-06-30 (Q2 2020), and aggregating revenue by drug_name. The Reference SQL uses table names directly while the Generated SQL uses aliases (d/drugs, s/sales), but this does not affect the result. Both correctly calculate total sales per drug for the specified quarter. The Generated SQL is slightly more concise with aliases but neither is significantly more efficient. Both fully address the business intent of summarizing Q2 2020 sales by drug.", "overall_assessment": "correct"}}
{"example_id": 2403, "sql_complexity": "multiple_joins", "prompt": "Who is the most frequent customer ordering vegetarian items?", "context": "CREATE TABLE customers (customer_id INT, customer_name VARCHAR(50)); INSERT INTO customers VALUES (1, 'John Doe'), (2, 'Jane Smith'), (3, 'Alice Johnson'); CREATE TABLE orders (order_id INT, customer_id INT, menu_id INT, order_date DATE); INSERT INTO orders VALUES (1, 1, 1, '2022-01-01'), (2, 2, 3, '2022-01-02'), (3, 3, 2, '2022-01-03'); CREATE TABLE menu (menu_id INT, item_name VARCHAR(50), is_vegetarian BOOLEAN, price DECIMAL(5,2)); INSERT INTO menu VALUES (1, 'Veggie Burger', true, 8.99), (2, 'Cheeseburger', false, 7.99), (3, 'Tofu Stir Fry', true, 11.99);", "reference_sql": "SELECT customers.customer_name, COUNT(orders.order_id) as order_count FROM customers INNER JOIN orders ON customers.customer_id = orders.customer_id INNER JOIN menu ON orders.menu_id = menu.menu_id WHERE menu.is_vegetarian = true GROUP BY customers.customer_name ORDER BY order_count DESC LIMIT 1;", "generated_sql": "SELECT\n  c.customer_name\nFROM customers AS c\nJOIN orders AS o\n  ON c.customer_id = o.customer_id\nJOIN menu AS m\n  ON o.menu_id = m.menu_id\nWHERE\n  m.is_vegetarian = TRUE\nGROUP BY\n  c.customer_name\nORDER BY\n  COUNT(*) DESC\nLIMIT 1;", "raw_model_output": "```sql\nSELECT\n  c.customer_name\nFROM customers AS c\nJOIN orders AS o\n  ON c.customer_id = o.customer_id\nJOIN menu AS m\n  ON o.menu_id = m.menu_id\nWHERE\n  m.is_vegetarian = TRUE\nGROUP BY\n  c.customer_name\nORDER BY\n  COUNT(*) DESC\nLIMIT 1;\n```", "latency_sec": 2.145198106765747, "total_duration_sec": 1.955117475, "load_duration_sec": 0.028507586, "tokens_prompt": 307, "prompt_eval_sec": 0.100127892, "tokens_completion": 91, "completion_eval_sec": 1.825601691, "tokens_total": 398, "tokens_per_sec": 185.53065040694682, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the customer with the highest count of vegetarian orders. The reference query includes an explicit count column, while the generated query uses COUNT(*) in the ORDER BY, which behaves identically in this context. The GROUP BY and JOIN conditions are identical, and the final result (customer name) is the same. The difference in SELECT clause does not affect the semantic equivalence of the result set.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly identify the most frequent customer ordering vegetarian items by joining customers, orders, and menu tables with a vegetarian filter. The reference query uses COUNT(orders.order_id) while the generated query uses COUNT(*), but both count the same set of rows (valid vegetarian orders). The semantic intent of counting vegetarian orders per customer and selecting the top one is fulfilled identically. Both queries are equally efficient and elegant, with no significant differences in structure or performance.", "overall_assessment": "correct"}}
{"example_id": 124, "sql_complexity": "set operations", "prompt": "Find the intersection of AI and accessibility research projects in the EU and those in Africa.", "context": "CREATE SCHEMA if not exists accessibility; CREATE TABLE if not exists accessibility.research (id INT PRIMARY KEY, project_name VARCHAR(255), region VARCHAR(255)); INSERT INTO accessibility.research (id, project_name, region) VALUES (1, 'AI for Accessibility EU', 'EU'), (2, 'Accessibility Africa', 'Africa'), (3, 'AI for Accessibility Africa', 'Africa'), (4, 'Accessibility EU', 'EU');", "reference_sql": "SELECT project_name FROM accessibility.research WHERE region = 'EU' INTERSECT SELECT project_name FROM accessibility.research WHERE region = 'Africa';", "generated_sql": "SELECT project_name\nFROM accessibility.research\nWHERE region = 'EU' AND project_name LIKE '%AI%'\nINTERSECT\nSELECT project_name\nFROM accessibility.research\nWHERE region = 'Africa' AND project_name LIKE '%AI%';", "raw_model_output": "```sql\nSELECT project_name\nFROM accessibility.research\nWHERE region = 'EU' AND project_name LIKE '%AI%'\nINTERSECT\nSELECT project_name\nFROM accessibility.research\nWHERE region = 'Africa' AND project_name LIKE '%AI%';\n```", "latency_sec": 1.3114469051361084, "total_duration_sec": 1.258088746, "load_duration_sec": 0.028072084, "tokens_prompt": 193, "prompt_eval_sec": 0.072573104, "tokens_completion": 59, "completion_eval_sec": 1.156556956, "tokens_total": 252, "tokens_per_sec": 192.15417643907298, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query finds project names present in both 'EU' and 'Africa' regions without any name restrictions. The generated query adds 'LIKE '%AI%'' filters to both SELECTs, restricting results to project names containing 'AI'. This makes the generated query more restrictive, so they are not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL fails to filter for AI-related projects, which is critical to the business intent. It simply finds projects in both regions without considering the 'AI and accessibility' requirement. The Generated SQL correctly applies the 'AI' filter to both regions, aligning with the question's focus on AI research. While neither query explicitly checks for 'accessibility' in project names (which could be debated as part of the business intent), the Generated SQL better addresses the AI component. The Reference SQL's lack of AI filtering makes it less precise for the stated question.", "overall_assessment": "differently_correct"}}
{"example_id": 1231, "sql_complexity": "basic SQL", "prompt": "What is the average ticket price for performances at the 'Downtown Theater'?", "context": "CREATE TABLE DowntownTheater (show_name TEXT, date DATE, ticket_price FLOAT); INSERT INTO DowntownTheater (show_name, date, ticket_price) VALUES ('Play 1', '2022-01-01', 30.0), ('Play 2', '2022-01-02', 40.0), ('Concert 1', '2022-01-03', 50.0);", "reference_sql": "SELECT AVG(ticket_price) FROM DowntownTheater WHERE show_name = 'Downtown Theater'", "generated_sql": "SELECT avg(ticket_price) FROM DowntownTheater;", "raw_model_output": "```sql\nSELECT avg(ticket_price) FROM DowntownTheater;\n```", "latency_sec": 0.619042158126831, "total_duration_sec": 0.422662304, "load_duration_sec": 0.030093711, "tokens_prompt": 198, "prompt_eval_sec": 0.06918933, "tokens_completion": 17, "completion_eval_sec": 0.322402217, "tokens_total": 215, "tokens_per_sec": 347.31075610516046, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters for show_name = 'Downtown Theater' which doesn't exist in the data (the actual shows are 'Play 1', 'Play 2', 'Concert 1'), resulting in no rows. The Generated SQL calculates the average of all ticket prices. The first returns NULL/empty result, the second returns 40.0.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query incorrectly filters for show_name = 'Downtown Theater', but the table contains no such entries (shows are named 'Play 1', 'Play 2', etc.). This would return NULL/0 instead of the actual average. The generated query correctly averages all ticket prices in the DowntownTheater table, which contains all performances at the theater. While both queries fail to match the exact show name, the generated query aligns with the table structure where the theater name is embedded in the table name, not the show_name column. The generated query better fulfills the business intent of calculating the average ticket price for the theater's performances.", "overall_assessment": "differently_correct"}}
{"example_id": 1485, "sql_complexity": "set operations", "prompt": "How many public schools and public libraries exist in total, in the 'CityData' schema's 'CityEducation' and 'CityLibrary' tables?", "context": "CREATE SCHEMA CityData; CREATE TABLE CityEducation (Name varchar(255), Type varchar(255)); INSERT INTO CityEducation (Name, Type) VALUES ('SchoolA', 'Public'), ('SchoolB', 'Public'), ('SchoolC', 'Private'); CREATE TABLE CityLibrary (Name varchar(255), Type varchar(255)); INSERT INTO CityLibrary (Name, Type) VALUES ('LibraryA', 'Public'), ('LibraryB', 'Public'), ('LibraryC', 'Private');", "reference_sql": "SELECT COUNT(*) FROM CityData.CityEducation WHERE Type = 'Public' UNION ALL SELECT COUNT(*) FROM CityData.CityLibrary WHERE Type = 'Public';", "generated_sql": "SELECT\n  COUNT(CASE WHEN Type = 'Public' THEN 1 ELSE NULL END)\nFROM CityEducation\nUNION ALL\nSELECT\n  COUNT(CASE WHEN Type = 'Public' THEN 1 ELSE NULL END)\nFROM CityLibrary;", "raw_model_output": "```sql\nSELECT\n  COUNT(CASE WHEN Type = 'Public' THEN 1 ELSE NULL END)\nFROM CityEducation\nUNION ALL\nSELECT\n  COUNT(CASE WHEN Type = 'Public' THEN 1 ELSE NULL END)\nFROM CityLibrary;\n```", "latency_sec": 1.5098392963409424, "total_duration_sec": 1.219412803, "load_duration_sec": 0.028876896, "tokens_prompt": 216, "prompt_eval_sec": 0.070455276, "tokens_completion": 57, "completion_eval_sec": 1.118787596, "tokens_total": 273, "tokens_per_sec": 180.81394533948657, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of 'Public' entries in CityEducation and CityLibrary tables. The Reference SQL uses COUNT(*) with a WHERE clause, while the Generated SQL uses COUNT(CASE WHEN ... THEN 1 ELSE NULL END). Both approaches effectively count non-null values matching the 'Public' condition, producing identical results. The UNION ALL structure and table references are equivalent in both queries.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly count public institutions in their respective tables. The Reference SQL uses WHERE clauses for simplicity, while the Generated SQL uses CASE expressions to achieve the same result. Both return two rows with counts for CityEducation and CityLibrary. The original question asks for separate counts of public schools and libraries, not a combined total, so both queries fulfill the intent. Neither is more efficient or elegant than the other; they are functionally identical.", "overall_assessment": "correct"}}
{"example_id": 5806, "sql_complexity": "single join", "prompt": "List the top 3 countries with the most veteran employment in the IT industry", "context": "CREATE TABLE veteran_employment (employee_id INT, industry VARCHAR(255), salary DECIMAL(10,2), state VARCHAR(2), country VARCHAR(255)); CREATE TABLE countries (country_id INT, country VARCHAR(255));", "reference_sql": "SELECT country, COUNT(*) as num_veterans FROM veteran_employment JOIN countries ON veteran_employment.country = countries.country WHERE industry = 'IT' GROUP BY country ORDER BY num_veterans DESC LIMIT 3;", "generated_sql": "SELECT country\nFROM veteran_employment\nWHERE industry = 'IT'\nGROUP BY country\nORDER BY COUNT(*) DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT country\nFROM veteran_employment\nWHERE industry = 'IT'\nGROUP BY country\nORDER BY COUNT(*) DESC\nLIMIT 3;\n```", "latency_sec": 1.1473898887634277, "total_duration_sec": 0.748219109, "load_duration_sec": 0.028649154, "tokens_prompt": 149, "prompt_eval_sec": 0.042489834, "tokens_completion": 35, "completion_eval_sec": 0.676339519, "tokens_total": 184, "tokens_per_sec": 160.36397200458308, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a JOIN with the countries table on veteran_employment.country = countries.country, which could affect the result if there are duplicate country entries in the countries table. The Generated SQL omits this join, so it directly groups by veteran_employment.country without considering the countries table. This difference could lead to different counts if the countries table has multiple entries for the same country, making the queries not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify the top 3 countries with IT veteran employment by filtering on 'IT' industry, grouping by country, and ordering by count. The reference query includes an unnecessary JOIN with the countries table, which doesn't affect the result if country names are identical between tables. The generated query is more efficient by avoiding the join while maintaining semantic equivalence. Both fulfill the business intent, but the generated version is simpler and more performant.", "overall_assessment": "correct"}}
{"example_id": 4126, "sql_complexity": "window functions", "prompt": "What is the average crime rate per capita in each neighborhood?", "context": "CREATE TABLE neighborhoods (name VARCHAR(255), population INT, crime_count INT); INSERT INTO neighborhoods (name, population, crime_count) VALUES ('Central Park', 1000, 25), ('Harlem', 2500, 75), ('Brooklyn', 5000, 120);", "reference_sql": "SELECT name, AVG(crime_count/population) OVER (PARTITION BY name) FROM neighborhoods;", "generated_sql": "SELECT\n  name,\n  CAST(crime_count AS REAL) / population AS crime_rate_per_capita\nFROM neighborhoods;", "raw_model_output": "```sql\nSELECT\n  name,\n  CAST(crime_count AS REAL) / population AS crime_rate_per_capita\nFROM neighborhoods;\n```", "latency_sec": 0.9519267082214355, "total_duration_sec": 0.775263382, "load_duration_sec": 0.029715008, "tokens_prompt": 166, "prompt_eval_sec": 0.047771089, "tokens_completion": 36, "completion_eval_sec": 0.696996573, "tokens_total": 202, "tokens_per_sec": 212.2012107186419, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates AVG(crime_count/population) over a partition by name, but since each name is unique, this reduces to crime_count/population. However, integer division (e.g., 25/1000 = 0) differs from the generated query's CAST(crime_count AS REAL)/population (e.g., 25.0/1000 = 0.025). The generated query explicitly uses floating-point division, while the reference query uses integer division by default.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries calculate the crime rate per capita (crime_count/population) for neighborhoods. The reference query uses an unnecessary window function (AVG(...) OVER (PARTITION BY name)) which, for single-row partitions, produces the same value as the raw ratio. The generated query directly computes the ratio with explicit type casting (to avoid integer division) and avoids redundant aggregation. While technically equivalent, the generated query is more efficient and elegant. Both fulfill the business intent of calculating per-capita crime rates, but the generated version is simpler and avoids potential confusion from the window function.", "overall_assessment": "differently_correct"}}
{"example_id": 4559, "sql_complexity": "basic SQL", "prompt": "List the top 3 energy efficient appliances in the US by energy star rating?", "context": "CREATE TABLE appliances (id INT, name VARCHAR(255), country VARCHAR(255), energy_star_rating INT); INSERT INTO appliances (id, name, country, energy_star_rating) VALUES (1, 'Fridge A', 'USA', 5), (2, 'TV B', 'USA', 4), (3, 'Laptop C', 'USA', 5), (4, 'Microwave D', 'USA', 3);", "reference_sql": "SELECT name, energy_star_rating FROM appliances WHERE country = 'USA' ORDER BY energy_star_rating DESC LIMIT 3;", "generated_sql": "SELECT name FROM appliances WHERE country = 'USA' ORDER BY energy_star_rating DESC LIMIT 3;", "raw_model_output": "```sql\nSELECT name FROM appliances WHERE country = 'USA' ORDER BY energy_star_rating DESC LIMIT 3;\n```", "latency_sec": 0.8315939903259277, "total_duration_sec": 0.623593168, "load_duration_sec": 0.027750317, "tokens_prompt": 194, "prompt_eval_sec": 0.05685777, "tokens_completion": 28, "completion_eval_sec": 0.538244281, "tokens_total": 222, "tokens_per_sec": 266.9571961588987, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent because the Reference SQL selects both 'name' and 'energy_star_rating' columns, while the Generated SQL only selects the 'name' column. Although both filter by country = 'USA', order by energy_star_rating DESC, and limit to 3 results, the additional column in the Reference SQL changes the output structure and content.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query is technically superior as it includes both the appliance name and energy star rating, which directly addresses the 'by energy star rating' requirement. The generated query only returns names, which technically fulfills the 'list top 3' part but omits the rating data that justifies the ranking. Both queries correctly filter US appliances, sort by rating, and limit to 3 results. The reference query better fulfills business intent by providing complete information about the ratings that define the 'top' status.", "overall_assessment": "differently_correct"}}
{"example_id": 456, "sql_complexity": "window functions", "prompt": "List the intelligence operations and their corresponding threat levels, and rank them based on their threat level and budget.", "context": "CREATE TABLE intel_ops_threat (id INT, operation VARCHAR, threat VARCHAR, budget INT); INSERT INTO intel_ops_threat (id, operation, threat, budget) VALUES (1, 'Operation Red Folder', 'High', 5000000), (2, 'Operation Black Vault', 'Medium', 7000000), (3, 'Operation Blue Sail', 'Low', 6000000);", "reference_sql": "SELECT operation, threat, budget, ROW_NUMBER() OVER (PARTITION BY threat ORDER BY budget DESC) as rank FROM intel_ops_threat;", "generated_sql": "SELECT\n  operation,\n  threat\nFROM intel_ops_threat\nORDER BY\n  threat,\n  budget;", "raw_model_output": "```sql\nSELECT\n  operation,\n  threat\nFROM intel_ops_threat\nORDER BY\n  threat,\n  budget;\n```", "latency_sec": 0.8038251399993896, "total_duration_sec": 0.705995203, "load_duration_sec": 0.028345743, "tokens_prompt": 198, "prompt_eval_sec": 0.057211629, "tokens_completion": 32, "completion_eval_sec": 0.619564138, "tokens_total": 230, "tokens_per_sec": 286.13188186696254, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL includes a ROW_NUMBER() column based on budget ordering within threat partitions, while the Generated SQL omits this and only orders by threat and budget without including the budget column in the output. The selected columns and ranking logic differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL includes the required columns (operation, threat, budget) and uses a window function to rank operations within each threat level by budget. However, it ranks within threat categories rather than globally, which may not align with the intent to 'rank them based on their threat level and budget.' The Generated SQL omits the budget column and lacks any ranking logic entirely, failing to address the ranking requirement. While the Reference is closer to fulfilling the intent, neither query fully satisfies the original question's requirements. The Reference's use of ROW_NUMBER() demonstrates more sophisticated logic but misinterprets the ranking scope.", "overall_assessment": "differently_correct"}}
{"example_id": 459, "sql_complexity": "set operations", "prompt": "What is the total installed capacity of hydroelectric power plants in Brazil and Canada?", "context": "CREATE TABLE hydroelectric_power (country TEXT, capacity INTEGER); INSERT INTO hydroelectric_power (country, capacity) VALUES ('Brazil', 104000), ('Canada', 78000), ('China', 350000), ('United States', 100000), ('Russia', 45000);", "reference_sql": "(SELECT capacity FROM hydroelectric_power WHERE country = 'Brazil') UNION (SELECT capacity FROM hydroelectric_power WHERE country = 'Canada');", "generated_sql": "SELECT SUM(capacity) FROM hydroelectric_power WHERE country IN ('Brazil', 'Canada');", "raw_model_output": "```sql\nSELECT SUM(capacity) FROM hydroelectric_power WHERE country IN ('Brazil', 'Canada');\n```", "latency_sec": 0.8385031223297119, "total_duration_sec": 0.540994301, "load_duration_sec": 0.029198784, "tokens_prompt": 172, "prompt_eval_sec": 0.051473432, "tokens_completion": 24, "completion_eval_sec": 0.459440598, "tokens_total": 196, "tokens_per_sec": 233.74987496221854, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate capacity values (Brazil and Canada) as individual rows, while the Generated SQL returns a single summed value of both countries' capacities. The output structures differ (two rows vs. one row with a sum), making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query retrieves individual capacities for Brazil and Canada using UNION, which returns two separate rows instead of summing them. The generated query correctly uses SUM() to calculate the total capacity for both countries in a single aggregation. While both queries are syntactically valid, they produce different results (individual values vs. total), making them semantically inequivalent. The generated query directly addresses the business intent of calculating total installed capacity, whereas the reference query only retrieves raw data without aggregation. The generated query is also more efficient and elegant for this specific calculation.", "overall_assessment": "differently_correct"}}
{"example_id": 2356, "sql_complexity": "window functions", "prompt": "Find the total billing amount for attorneys in the 'Criminal Law' practice area, for the year 2020, partitioned by attorney's last name and ordered by the total billing amount in descending order.", "context": "CREATE TABLE Attorneys (AttorneyID INT, FirstName VARCHAR(50), LastName VARCHAR(50), PracticeArea VARCHAR(50), TotalBilling FLOAT, BillingYear INT); INSERT INTO Attorneys (AttorneyID, FirstName, LastName, PracticeArea, TotalBilling, BillingYear) VALUES (1, 'Clara', 'Rivera', 'Personal Injury', 8000.00, 2020), (2, 'Jamal', 'Lee', 'Personal Injury', 6000.00, 2019), (3, 'Sophia', 'Gomez', 'Criminal Law', 9000.00, 2020);", "reference_sql": "SELECT LastName, SUM(TotalBilling) OVER (PARTITION BY PracticeArea, LastName, BillingYear) AS TotalBilling FROM Attorneys WHERE PracticeArea = 'Criminal Law' AND BillingYear = 2020 ORDER BY TotalBilling DESC;", "generated_sql": "SELECT\n  LastName,\n  SUM(TotalBilling) AS TotalBillingAmount\nFROM Attorneys\nWHERE\n  PracticeArea = 'Criminal Law' AND BillingYear = 2020\nGROUP BY\n  LastName\nORDER BY\n  TotalBillingAmount DESC;", "raw_model_output": "```sql\nSELECT\n  LastName,\n  SUM(TotalBilling) AS TotalBillingAmount\nFROM Attorneys\nWHERE\n  PracticeArea = 'Criminal Law' AND BillingYear = 2020\nGROUP BY\n  LastName\nORDER BY\n  TotalBillingAmount DESC;\n```", "latency_sec": 1.5245821475982666, "total_duration_sec": 1.325529785, "load_duration_sec": 0.02799582, "tokens_prompt": 267, "prompt_eval_sec": 0.089607492, "tokens_completion": 61, "completion_eval_sec": 1.207074635, "tokens_total": 328, "tokens_per_sec": 215.14091616297037, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses a window function to calculate the sum within partitions, but does not group rows, potentially returning multiple rows per LastName. The Generated SQL explicitly groups by LastName, aggregating TotalBilling. This difference in grouping leads to different result structures when there are multiple entries per LastName in the filtered data.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query uses a window function (SUM() OVER) which is unnecessary for this task. It partitions by PracticeArea, LastName, and BillingYear, but the WHERE clause already restricts to a single PracticeArea and BillingYear, making the partitioning redundant. The generated query correctly uses GROUP BY LastName with SUM(TotalBilling), which aggregates billing amounts per attorney. While both might return same results in this specific dataset (due to single-entry-per-attorney), the generated query is logically correct for aggregation. The reference query would fail to aggregate multiple entries per attorney, making it technically incorrect for general cases. Both fulfill the business intent, but the generated query is more precise.", "overall_assessment": "differently_correct"}}
