{"example_id": 2656, "sql_complexity": "multiple_joins", "prompt": "Find the drugs and their respective total sales for rare diseases indication with sales greater than the average sales for infectious diseases.", "context": "CREATE TABLE sales (id INT, drug_id INT, quarter INT, year INT, revenue FLOAT); INSERT INTO sales (id, drug_id, quarter, year, revenue) VALUES (1, 1, 1, 2022, 1500000); CREATE TABLE drugs (id INT, name VARCHAR(50), company VARCHAR(50), indication VARCHAR(50)); INSERT INTO drugs (id, name, company, indication) VALUES (1, 'DrugA', 'ABC Corp', 'Rare_Diseases');", "reference_sql": "SELECT s.drug_id, d.name, SUM(s.revenue) as total_sales FROM sales s JOIN drugs d ON s.drug_id = d.id WHERE d.indication = 'Rare_Diseases' GROUP BY s.drug_id HAVING total_sales > (SELECT AVG(s2.revenue) FROM sales s2 JOIN drugs d2 ON s2.drug_id = d2.id WHERE d2.indication = 'Infectious_Diseases')", "generated_sql": "SELECT d.name, SUM(s.revenue) AS total_sales\nFROM sales s\nJOIN drugs d ON s.drug_id = d.id\nWHERE d.indication = 'Rare_Diseases'\nGROUP BY d.id, d.name\nHAVING SUM(s.revenue) > (\n    SELECT AVG(revenue)\n    FROM sales s2\n    JOIN drugs d2 ON s2.drug_id = d2.id\n    WHERE d2.indication = 'Infectious_Diseases'\n);", "raw_model_output": "\n\n```sql\nSELECT d.name, SUM(s.revenue) AS total_sales\nFROM sales s\nJOIN drugs d ON s.drug_id = d.id\nWHERE d.indication = 'Rare_Diseases'\nGROUP BY d.id, d.name\nHAVING SUM(s.revenue) > (\n    SELECT AVG(revenue)\n    FROM sales s2\n    JOIN drugs d2 ON s2.drug_id = d2.id\n    WHERE d2.indication = 'Infectious_Diseases'\n);\n```", "latency_sec": 7.772244930267334, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 208, "prompt_eval_sec": null, "tokens_completion": 1163, "completion_eval_sec": null, "tokens_total": 1371, "tokens_per_sec": 176.39691135580864, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes 's.drug_id' in the SELECT clause, while the Generated SQL does not. This results in different columns in the output, making the queries semantically distinct. Additionally, the Generated SQL explicitly groups by both 'd.id' and 'd.name', whereas the Reference SQL only groups by 's.drug_id'. Although the grouping logic may be functionally equivalent, the differing selected columns ensure the result sets are not identical.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in two key technical aspects. 1) The Reference SQL uses an alias ('total_sales') in the HAVING clause, which is not universally supported across all SQL implementations (e.g., PostgreSQL). The Generated SQL uses the explicit aggregate function, making it more portable. 2) The Generated SQL includes both 'd.id' and 'd.name' in the GROUP BY clause, which is more rigorous and avoids potential issues with non-deterministic results if the 'name' column were not functionally dependent on 'id'. Both queries correctly identify drugs for rare diseases with sales exceeding the average for infectious diseases, but the Generated SQL is more technically robust and adheres to stricter SQL standards.", "overall_assessment": "differently_correct"}}
{"example_id": 3008, "sql_complexity": "multiple_joins", "prompt": "Who are the users who used electric vehicles and their trip details?", "context": "CREATE TABLE users (id INT, name VARCHAR(50), age INT, gender VARCHAR(10), city VARCHAR(50));CREATE TABLE vehicles (id INT, vehicle_type VARCHAR(20), is_electric BOOLEAN);CREATE TABLE trips (id INT, user_id INT, vehicle_id INT, trip_distance FLOAT, trip_duration INT, departure_time TIMESTAMP, arrival_time TIMESTAMP);INSERT INTO users (id, name, age, gender, city) VALUES (3, 'Alex', 30, 'Female', 'New York');INSERT INTO vehicles (id, vehicle_type, is_electric) VALUES (1, 'Tesla', true), (2, 'Bike', false);INSERT INTO trips (id, user_id, vehicle_id, trip_distance, trip_duration, departure_time, arrival_time) VALUES (3, 3, 1, 15.3, 25, '2022-01-03 12:00:00', '2022-01-03 12:25:00');", "reference_sql": "SELECT u.name, v.vehicle_type, t.trip_distance, t.trip_duration FROM users u JOIN trips t ON u.id = t.user_id JOIN vehicles v ON t.vehicle_id = v.id WHERE v.is_electric = true;", "generated_sql": "SELECT users.name, users.age, users.gender, users.city, trips.id AS trip_id, trips.trip_distance, trips.trip_duration, trips.departure_time, trips.arrival_time\nFROM users\nJOIN trips ON users.id = trips.user_id\nJOIN vehicles ON trips.vehicle_id = vehicles.id\nWHERE vehicles.is_electric = true;", "raw_model_output": "\n\nSELECT users.name, users.age, users.gender, users.city, trips.id AS trip_id, trips.trip_distance, trips.trip_duration, trips.departure_time, trips.arrival_time\nFROM users\nJOIN trips ON users.id = trips.user_id\nJOIN vehicles ON trips.vehicle_id = vehicles.id\nWHERE vehicles.is_electric = true;", "latency_sec": 5.8553080558776855, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 310, "prompt_eval_sec": null, "tokens_completion": 907, "completion_eval_sec": null, "tokens_total": 1217, "tokens_per_sec": 207.8455972574063, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects 4 columns (name, vehicle_type, trip_distance, trip_duration), while the Generated SQL selects 9 columns (name, age, gender, city, trip_id, trip_distance, trip_duration, departure_time, arrival_time). The Generated SQL includes additional columns from the users and trips tables that are not present in the Reference SQL, resulting in different output structures.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because they select different columns. The Reference SQL focuses on minimal user/vehicle/trip attributes (name, vehicle_type, trip_distance, trip_duration), while the Generated SQL includes comprehensive user details (age, gender, city) and additional trip metadata (trip_id, departure/arrival times). Both fulfill the business intent of identifying users who used electric vehicles with their trip details, but the Generated SQL provides more complete user information (addressing 'who are the users') and richer trip context. The Reference is more concise, but the Generated version better aligns with typical BI requirements for detailed user and trip insights.", "overall_assessment": "correct"}}
{"example_id": 2531, "sql_complexity": "basic SQL", "prompt": "Who is the top customer by sales in 2022?", "context": "CREATE TABLE customers (customer_id INT, total_sales_2022 FLOAT); INSERT INTO customers (customer_id, total_sales_2022) VALUES (1, 25000.0), (2, 30000.0), (3, 22000.0), (4, 35000.0);", "reference_sql": "SELECT customer_id, total_sales_2022 FROM customers ORDER BY total_sales_2022 DESC LIMIT 1;", "generated_sql": "SELECT customer_id, total_sales_2022 \nFROM customers \nORDER BY total_sales_2022 DESC \nLIMIT 1;", "raw_model_output": "\n\nSELECT customer_id, total_sales_2022 \nFROM customers \nORDER BY total_sales_2022 DESC \nLIMIT 1;", "latency_sec": 1.5713269710540771, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 165, "prompt_eval_sec": null, "tokens_completion": 238, "completion_eval_sec": null, "tokens_total": 403, "tokens_per_sec": 256.47112753983953, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns from the same table, apply the same ordering (descending on total_sales_2022), and limit the result to 1 row. The generated SQL is identical in logic to the reference query, with only formatting differences (line breaks/spaces) that do not affect semantic meaning.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic. They correctly retrieve the customer with the highest total_sales_2022 by ordering in descending order and limiting to 1 result. The queries directly address the business intent of identifying the top sales customer. Since the queries are exactly the same, neither is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 3792, "sql_complexity": "single join", "prompt": "What is the maximum distance traveled by an electric vehicle in a single trip, grouped by vehicle model?", "context": "CREATE TABLE Trips (trip_id INT, vehicle_id INT, distance FLOAT); CREATE TABLE ElectricVehicleModels (vehicle_id INT, vehicle_model TEXT);", "reference_sql": "SELECT evm.vehicle_model, MAX(trips.distance) AS max_distance_traveled FROM Trips trips INNER JOIN ElectricVehicleModels evm ON trips.vehicle_id = evm.vehicle_id GROUP BY 1;", "generated_sql": "SELECT e.vehicle_model, MAX(t.distance) AS max_distance\nFROM Trips t\nJOIN ElectricVehicleModels e ON t.vehicle_id = e.vehicle_id\nGROUP BY e.vehicle_model;", "raw_model_output": "\n\nSELECT e.vehicle_model, MAX(t.distance) AS max_distance\nFROM Trips t\nJOIN ElectricVehicleModels e ON t.vehicle_id = e.vehicle_id\nGROUP BY e.vehicle_model;", "latency_sec": 2.927891969680786, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 120, "prompt_eval_sec": null, "tokens_completion": 451, "completion_eval_sec": null, "tokens_total": 571, "tokens_per_sec": 195.02085661386386, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the maximum distance traveled per vehicle model by joining the Trips and ElectricVehicleModels tables. The differences are purely syntactic: the Reference SQL uses 'trips' and 'evm' aliases while the Generated SQL uses 't' and 'e' aliases. The GROUP BY clause references the same column (vehicle_model) in both cases, and the aggregate function (MAX(distance)) is applied identically. The output column aliases differ but do not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the maximum distance traveled per vehicle model by joining the Trips and ElectricVehicleModels tables. The Reference uses implicit grouping via 'GROUP BY 1' while the Generated uses explicit column naming. Both achieve the same result, with identical logic, syntax, and semantic output. The Generated query's explicit GROUP BY may improve readability, but neither query has efficiency advantages over the other. Both fully address the business requirement of identifying maximum trip distances by model.", "overall_assessment": "correct"}}
{"example_id": 2311, "sql_complexity": "subqueries", "prompt": "Determine the percentage of sales from each ingredient category", "context": "CREATE TABLE Sales_Details (sale_id INT, ingredient_id INT, quantity INT); INSERT INTO Sales_Details (sale_id, ingredient_id, quantity) VALUES (1, 1, 2), (1, 2, 8), (2, 1, 3), (2, 2, 7); CREATE TABLE Ingredient_Categories (ingredient_id INT, ingredient_category VARCHAR(255)); INSERT INTO Ingredient_Categories (ingredient_id, ingredient_category) VALUES (1, 'Legumes'), (2, 'Poultry');", "reference_sql": "SELECT ingredient_category, SUM(quantity) AS total_quantity, SUM(quantity) * 100.0 / (SELECT SUM(quantity) FROM Sales_Details) AS percentage_of_sales FROM Sales_Details, Ingredient_Categories WHERE Sales_Details.ingredient_id = Ingredient_Categories.ingredient_id GROUP BY ingredient_category;", "generated_sql": "SELECT \n    ic.ingredient_category,\n    SUM(sd.quantity) * 100.0 / (SELECT SUM(quantity) FROM Sales_Details) AS percentage\nFROM \n    Ingredient_Categories ic\nLEFT JOIN \n    Sales_Details sd ON ic.ingredient_id = sd.ingredient_id\nGROUP BY \n    ic.ingredient_category;", "raw_model_output": "\n\nTo determine the **percentage of sales from each ingredient category**, we need to:\n\n1. **Join** the `Sales_Details` table with the `Ingredient_Categories` table using the `ingredient_id`.\n2. **Group** the results by `ingredient_category`.\n3. **Sum** the `quantity` of sales for each category.\n4. **Divide** the category's total quantity by the **overall total quantity** of all sales.\n5. **Multiply** by 100 to get the percentage.\n6. Use a **LEFT JOIN** to ensure all categories are included, even those with no sales (which would show 0% in such cases).\n\n---\n\n### \u2705 Final SQL Query\n\n```sql\nSELECT \n    ic.ingredient_category,\n    SUM(sd.quantity) * 100.0 / (SELECT SUM(quantity) FROM Sales_Details) AS percentage\nFROM \n    Ingredient_Categories ic\nLEFT JOIN \n    Sales_Details sd ON ic.ingredient_id = sd.ingredient_id\nGROUP BY \n    ic.ingredient_category;\n```\n\n---\n\n### \ud83d\udd0d Explanation\n\n- `LEFT JOIN` ensures that even categories with no sales are included.\n- `SUM(sd.quantity)` computes the total quantity sold per category.\n- `(SELECT SUM(quantity) FROM Sales_Details)` computes the total quantity sold across all categories.\n- Multiplying by `100.0` ensures floating-point division for accurate percentage calculation.\n\n---\n\n### \ud83e\uddea Sample Output (based on provided data)\n\n| ingredient_category | percentage |\n|---------------------|------------|\n| Legumes             | 25.0       |\n| Poultry             | 75.0       |", "latency_sec": 11.16428804397583, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 192, "prompt_eval_sec": null, "tokens_completion": 1766, "completion_eval_sec": null, "tokens_total": 1958, "tokens_per_sec": 175.38064158569634, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses an implicit INNER JOIN (via comma-separated tables and WHERE clause), while the Generated SQL uses a LEFT JOIN. This means the Generated SQL will include ingredient categories with no sales (resulting in 0 for total_quantity), whereas the Reference SQL excludes them. Additionally, the Generated SQL calculates the percentage using SUM(sd.quantity) directly, while the Reference SQL uses SUM(quantity) from the joined tables. Though the sample data may produce similar results, the queries differ in handling categories with no sales and join types.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in handling categories with zero sales. The reference query uses an implicit inner join (via WHERE clause) which excludes categories without sales, while the generated query uses a LEFT JOIN ensuring all categories are included. Both calculate percentages correctly, but the generated query is more comprehensive. The reference might miss categories with no sales, making it less accurate for the business intent. The generated query's explicit JOIN syntax is also more modern and readable.", "overall_assessment": "differently_correct"}}
{"example_id": 3329, "sql_complexity": "set operations", "prompt": "Which causes received funding from donors in both the United States and Canada?", "context": "CREATE TABLE donor_location (donor_id INT, country VARCHAR(50), cause VARCHAR(50), donation DECIMAL(10,2)); INSERT INTO donor_location (donor_id, country, cause, donation) VALUES (1, 'United States', 'Global Health', 1000.00), (2, 'Canada', 'Education', 2000.00), (3, 'United States', 'Environment', 1500.00), (4, 'Canada', 'Animal Welfare', 2500.00);", "reference_sql": "SELECT cause FROM donor_location WHERE country = 'United States' INTERSECT SELECT cause FROM donor_location WHERE country = 'Canada';", "generated_sql": "SELECT cause FROM donor_location WHERE country = 'United States' INTERSECT SELECT cause FROM donor_location WHERE country = 'Canada';", "raw_model_output": "\n\nSELECT cause FROM donor_location WHERE country = 'United States' INTERSECT SELECT cause FROM donor_location WHERE country = 'Canada';", "latency_sec": 9.222929954528809, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 207, "prompt_eval_sec": null, "tokens_completion": 1436, "completion_eval_sec": null, "tokens_total": 1643, "tokens_per_sec": 178.14295544912218, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They select the 'cause' column from the donor_location table where country is 'United States' and intersect it with the same selection for 'Canada'. Since the queries are exactly the same, they will produce identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical and technically correct. They use INTERSECT to find causes that appear in both US and Canadian donor records, which directly answers the question about causes receiving funding from donors in both countries. The logic is sound: intersecting two sets of causes ensures only overlapping values are returned. The query is efficient and elegant, with no redundant operations. Since the reference and generated queries are identical, neither is superior to the other.", "overall_assessment": "correct"}}
{"example_id": 2912, "sql_complexity": "single join", "prompt": "Which company has manufactured the most satellites?", "context": "CREATE TABLE manufacturers (id INT, name TEXT); CREATE TABLE satellites (id INT, manufacturer_id INT, name TEXT, launch_date DATE); INSERT INTO manufacturers (id, name) VALUES (1, 'SpaceX'), (2, 'Blue Origin'), (3, 'ISRO'), (4, 'CAST'); INSERT INTO satellites (id, manufacturer_id, name, launch_date) VALUES (1, 1, 'StarDragon', '2012-05-25'), (2, 1, 'Falcon', '2015-12-21'), (3, 2, 'New Glenn', '2022-01-11'), (4, 3, 'ChinaSat 1E', '2000-12-05'), (5, 3, 'ChinaSat 2A', '2003-08-13'), (6, 4, 'Shijian 9', '2017-11-19'), (7, 1, 'StarLink', '2020-05-24'), (8, 1, 'StarLink', '2020-06-13');", "reference_sql": "SELECT m.name, COUNT(s.id) FROM manufacturers m JOIN satellites s ON m.id = s.manufacturer_id GROUP BY m.name ORDER BY COUNT(s.id) DESC;", "generated_sql": "SELECT manufacturers.name\nFROM manufacturers\nJOIN satellites ON manufacturers.id = satellites.manufacturer_id\nGROUP BY manufacturers.id\nORDER BY COUNT(*) DESC\nLIMIT 1;", "raw_model_output": "\n\n```sql\nSELECT manufacturers.name\nFROM manufacturers\nJOIN satellites ON manufacturers.id = satellites.manufacturer_id\nGROUP BY manufacturers.id\nORDER BY COUNT(*) DESC\nLIMIT 1;\n```", "latency_sec": 5.2244439125061035, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 342, "prompt_eval_sec": null, "tokens_completion": 707, "completion_eval_sec": null, "tokens_total": 1049, "tokens_per_sec": 200.7869196353966, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns all manufacturers with their satellite counts ordered by count descending, while the Generated SQL only returns the top manufacturer (due to LIMIT 1) and groups by manufacturer.id instead of name. The Generated SQL also omits the count value entirely.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify the manufacturer with the most satellites. The Reference SQL groups by manufacturer name and orders descending, while the Generated SQL groups by manufacturer ID (which is functionally equivalent in this dataset due to unique names) and uses LIMIT 1 for efficiency. The Generated SQL is more efficient as it avoids returning all rows and directly retrieves the top result. However, the Reference SQL might be more robust in cases with non-unique manufacturer names. Both fulfill the business intent of identifying the top manufacturer.", "overall_assessment": "correct"}}
{"example_id": 3170, "sql_complexity": "aggregation", "prompt": "Determine the total production quantity of silver for mining sites in Mexico, between the dates '2017-05-01' and '2017-09-30', having less than 40 employees.", "context": "CREATE TABLE silver_mine_2 (site_id INT, country VARCHAR(50), num_employees INT, extraction_date DATE, quantity INT); INSERT INTO silver_mine_2 (site_id, country, num_employees, extraction_date, quantity) VALUES (1, 'Mexico', 35, '2017-05-02', 1200), (2, 'Mexico', 30, '2017-08-31', 1800), (3, 'Mexico', 37, '2017-07-04', 2200);", "reference_sql": "SELECT country, SUM(quantity) as total_silver_prod FROM silver_mine_2 WHERE num_employees < 40 AND country = 'Mexico' AND extraction_date >= '2017-05-01' AND extraction_date <= '2017-09-30' GROUP BY country;", "generated_sql": "SELECT SUM(quantity) FROM silver_mine_2 WHERE country = 'Mexico' AND extraction_date BETWEEN '2017-05-01' AND '2017-09-30' AND num_employees < 40;", "raw_model_output": "\n\nSELECT SUM(quantity) FROM silver_mine_2 WHERE country = 'Mexico' AND extraction_date BETWEEN '2017-05-01' AND '2017-09-30' AND num_employees < 40;", "latency_sec": 3.345855951309204, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 257, "prompt_eval_sec": null, "tokens_completion": 515, "completion_eval_sec": null, "tokens_total": 772, "tokens_per_sec": 230.73318494118766, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes 'country' in the SELECT and GROUP BY, producing a two-column result (country, total_silver_prod), while the Generated SQL only returns the sum as a single column. Although both aggregate the same quantity values under identical filtering conditions, their output structures differ, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries produce the same numerical result (sum of quantities meeting criteria). The reference query includes an unnecessary GROUP BY country clause since the WHERE clause restricts results to Mexico, making the grouping redundant. The generated query is more efficient and elegant by omitting the redundant GROUP BY while maintaining semantic equivalence. Both correctly filter for Mexico, date ranges, and employee counts, but the generated query directly answers the question without extraneous output.", "overall_assessment": "correct"}}
{"example_id": 3518, "sql_complexity": "basic SQL", "prompt": "Insert new records of ticket sales for a new event, including event and salesperson information.", "context": "CREATE TABLE salesperson (salesperson_id INT, name VARCHAR(50), position VARCHAR(50)); CREATE TABLE tickets (ticket_id INT, salesperson_id INT, event_id INT, price DECIMAL(5,2), quantity INT); CREATE TABLE events (event_id INT, name VARCHAR(50), date DATE); INSERT INTO salesperson VALUES (1, 'John Doe', 'Senior Salesperson'); INSERT INTO events VALUES (2, 'New Event', '2023-04-15');", "reference_sql": "INSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity) VALUES (2, 1, 2, 75, 50), (3, 2, 2, 65, 75); INSERT INTO events (event_id, name, date) VALUES (2, 'New Event', '2023-04-15');", "generated_sql": "INSERT INTO tickets (salesperson_id, event_id, price, quantity) VALUES (1, 2, 50.00, 10);", "raw_model_output": "\n\nINSERT INTO tickets (salesperson_id, event_id, price, quantity) VALUES (1, 2, 50.00, 10);", "latency_sec": 14.647030115127563, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 195, "prompt_eval_sec": null, "tokens_completion": 2304, "completion_eval_sec": null, "tokens_total": 2499, "tokens_per_sec": 170.6147922382582, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL inserts two rows into the tickets table and one row into the events table, while the Generated SQL only inserts a single row into the tickets table. Additionally, the Generated SQL omits the ticket_id column and uses different values for price and quantity. The events table insertion in the Reference SQL is not present in the Generated SQL, making them semantically distinct.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL contains a critical error by attempting to reinsert an existing event (event_id=2) which would cause a primary key violation. The Generated SQL correctly inserts a single ticket record with required fields (salesperson_id, event_id, price, quantity) without duplicating the event. While the Generated SQL omits the ticket_id column, this may be acceptable if the column is auto-incremented. The Reference SQL's second INSERT is unnecessary and erroneous, making the Generated SQL more technically sound despite its minimal scope. Both queries address ticket sales, but the Generated SQL avoids redundant data operations.", "overall_assessment": "differently_correct"}}
{"example_id": 3925, "sql_complexity": "set operations", "prompt": "What is the total number of students and staff with accommodations in the \"disability_services\" schema, excluding the \"accessibility_parking\" type?", "context": "CREATE SCHEMA disability_services; CREATE TABLE staff (id INT, name VARCHAR(50), accommodation VARCHAR(50)); CREATE TABLE students (id INT, name VARCHAR(50), accommodation VARCHAR(50));", "reference_sql": "SELECT COUNT(*) FROM disability_services.staff WHERE accommodation != 'accessibility_parking' UNION SELECT COUNT(*) FROM disability_services.students WHERE accommodation != 'accessibility_parking';", "generated_sql": "SELECT (SELECT COUNT(*) FROM students WHERE accommodation != 'accessibility_parking') + (SELECT COUNT(*) FROM staff WHERE accommodation != 'accessibility_parking') AS total;", "raw_model_output": "\n\nSELECT (SELECT COUNT(*) FROM students WHERE accommodation != 'accessibility_parking') + (SELECT COUNT(*) FROM staff WHERE accommodation != 'accessibility_parking') AS total;", "latency_sec": 16.346982955932617, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 144, "prompt_eval_sec": null, "tokens_completion": 2574, "completion_eval_sec": null, "tokens_total": 2718, "tokens_per_sec": 166.2692135501119, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate counts (staff and students) as individual rows via UNION, while the Generated SQL calculates a single summed total. The result structures differ (two rows vs. one row with a sum), so they are not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference SQL uses UNION to return two separate counts (staff and students) instead of summing them, which does not fulfill the business intent of returning a single total. The generated SQL correctly sums the counts using subqueries with a + operator, aligning with the requirement for a total. However, the generated SQL omits the schema qualification (disability_services.) in its FROM clauses, which could cause errors if the default schema is not set to 'disability_services'. While this makes the queries technically non-equivalent, the generated SQL better addresses the business intent by providing the correct aggregated result.", "overall_assessment": "differently_correct"}}
{"example_id": 3340, "sql_complexity": "subqueries", "prompt": "Calculate the total revenue for garments manufactured in the US and sold in California.", "context": "CREATE TABLE garment_manufacturing(id INT PRIMARY KEY, garment_id INT, country VARCHAR(50), material VARCHAR(50), manufacturing_date DATE, quantity INT); CREATE TABLE garment_sales(id INT PRIMARY KEY, garment_id INT, store_id INT, sale_date DATE, units INT, revenue DECIMAL(10,2));", "reference_sql": "SELECT SUM(gs.revenue) FROM garment_manufacturing gm JOIN garment_sales gs ON gm.garment_id = gs.garment_id WHERE gm.country = 'United States' AND gs.store_id IN (SELECT id FROM stores WHERE region = 'California');", "generated_sql": "SELECT SUM(garment_sales.revenue)\nFROM garment_manufacturing\nJOIN garment_sales ON garment_manufacturing.garment_id = garment_sales.garment_id\nWHERE garment_manufacturing.country = 'US';", "raw_model_output": "\n\nThe question requires joining the `garment_manufacturing` and `garment_sales` tables on `garment_id`, filtering for garments manufactured in the US (`country = 'US'`), and ensuring sales occurred in California. However, the provided schema does not include a table or column that explicitly links `store_id` to a state (e.g., a `store` table with a `state` column). Without this information, the query cannot accurately filter sales by location. \n\nAssuming the problem expects a query based on the given schema (even if incomplete), here is the SQL:\n\n```sql\nSELECT SUM(garment_sales.revenue)\nFROM garment_manufacturing\nJOIN garment_sales ON garment_manufacturing.garment_id = garment_sales.garment_id\nWHERE garment_manufacturing.country = 'US';\n```\n\n**Note:** This query calculates total revenue for US-manufactured garments but does not account for the \"sold in California\" condition due to missing schema details. A `store` table with a `state` column would be required for an accurate solution.", "latency_sec": 9.530303955078125, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 152, "prompt_eval_sec": null, "tokens_completion": 1510, "completion_eval_sec": null, "tokens_total": 1662, "tokens_per_sec": 174.39108005725467, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a condition filtering sales by store_id from California stores (via a subquery on the 'stores' table), while the Generated SQL lacks this filter. Additionally, the country condition uses 'United States' vs. 'US' which may not be equivalent. The Generated SQL would aggregate revenue from all sales of US-manufactured garments, regardless of store location, making the results different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL attempts to filter sales in California by joining with a non-existent 'stores' table (not in the provided schema), making it technically invalid. The Generated SQL correctly joins the two tables and filters by US manufacturing but completely omits the California sales requirement. While the Reference has a schema inconsistency, it at least addresses the California condition through a subquery. The Generated SQL fails to fulfill the business intent by ignoring the regional sales filter. Neither query is fully correct, but the Reference better reflects the intent despite its technical flaw.", "overall_assessment": "incorrect"}}
{"example_id": 596, "sql_complexity": "basic SQL", "prompt": "What is the minimum energy production cost of wind farms in Spain?", "context": "CREATE TABLE wind_farm_costs (id INT, name TEXT, country TEXT, energy_production_cost FLOAT); INSERT INTO wind_farm_costs (id, name, country, energy_production_cost) VALUES (1, 'Las Tiesas', 'Spain', 0.045), (2, 'Eolo', 'Spain', 0.050);", "reference_sql": "SELECT MIN(energy_production_cost) FROM wind_farm_costs WHERE country = 'Spain';", "generated_sql": "SELECT MIN(energy_production_cost) FROM wind_farm_costs WHERE country = 'Spain';", "raw_model_output": "\n\nSELECT MIN(energy_production_cost) FROM wind_farm_costs WHERE country = 'Spain';", "latency_sec": 1.9025890827178955, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 158, "prompt_eval_sec": null, "tokens_completion": 277, "completion_eval_sec": null, "tokens_total": 435, "tokens_per_sec": 228.63581208959306, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They select the minimum energy_production_cost from the wind_farm_costs table where country equals 'Spain'. The sample data shows two Spanish entries with costs 0.045 and 0.050, so both would return 0.045 as the minimum. No differences in syntax, conditions, or aggregate functions exist between the queries.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic. They correctly filter for wind farms in Spain and calculate the minimum energy production cost. The queries are syntactically and semantically equivalent, producing identical results. Neither query demonstrates any technical advantage over the other.", "overall_assessment": "correct"}}
{"example_id": 2604, "sql_complexity": "subqueries", "prompt": "What is the maximum number of virtual tours taken by a single user in the UK?", "context": "CREATE TABLE virtual_tour_data (user_id INT, hotel_id INT, tour_date DATE); INSERT INTO virtual_tour_data (user_id, hotel_id, tour_date) VALUES (1, 10, '2022-01-01'), (2, 11, '2022-01-03'), (3, 12, '2022-01-05'), (4, 10, '2022-01-07'), (5, 10, '2022-01-09'); CREATE TABLE hotels (hotel_id INT, hotel_name TEXT, country TEXT); INSERT INTO hotels (hotel_id, hotel_name, country) VALUES (10, 'Royal Park Hotel', 'UK'), (11, 'The Ritz London', 'UK'), (12, 'Hotel de Crillon', 'France');", "reference_sql": "SELECT MAX(vt.user_tours) FROM (SELECT user_id, COUNT(DISTINCT hotel_id) as user_tours FROM virtual_tour_data WHERE country = 'UK' GROUP BY user_id) as vt;", "generated_sql": "SELECT MAX(tour_count) AS max_tours_by_user\nFROM (\n    SELECT COUNT(*) AS tour_count\n    FROM virtual_tour_data vtd\n    JOIN hotels h ON vtd.hotel_id = h.hotel_id\n    WHERE h.country = 'UK'\n    GROUP BY vtd.user_id\n) AS counts;", "raw_model_output": "\n\nTo determine the **maximum number of virtual tours taken by a single user in the UK**, we need to:\n\n1. **Join** the `virtual_tour_data` table with the `hotels` table on `hotel_id` to filter only those tours that occurred at hotels located in the UK.\n2. **Group** the resulting data by `user_id` to count how many virtual tours each user took.\n3. **Select the maximum** of these counts.\n\n---\n\n### \u2705 SQL Query\n\n```sql\nSELECT MAX(tour_count) AS max_tours_by_user\nFROM (\n    SELECT COUNT(*) AS tour_count\n    FROM virtual_tour_data vtd\n    JOIN hotels h ON vtd.hotel_id = h.hotel_id\n    WHERE h.country = 'UK'\n    GROUP BY vtd.user_id\n) AS counts;\n```\n\n---\n\n### \ud83d\udd0d Explanation\n\n- **`JOIN hotels h ON vtd.hotel_id = h.hotel_id`**: Links each virtual tour to its corresponding hotel.\n- **`WHERE h.country = 'UK'`**: Filters only tours at hotels located in the UK.\n- **`GROUP BY vtd.user_id`**: Groups the tours by user to count how many each user took.\n- **`COUNT(*)`**: Counts the number of tours per user.\n- **`MAX(tour_count)`**: Finds the highest number of tours taken by any single user.\n\nThis query is efficient, uses standard ANSI SQL, and adheres strictly to the schema provided.", "latency_sec": 7.9612109661102295, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 284, "prompt_eval_sec": null, "tokens_completion": 1244, "completion_eval_sec": null, "tokens_total": 1528, "tokens_per_sec": 191.93060032003723, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references a 'country' column in virtual_tour_data, which doesn't exist. The Generated SQL correctly joins with hotels to filter by country. Additionally, the Reference uses COUNT(DISTINCT hotel_id) while the Generated uses COUNT(*), leading to different results even if both were valid.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is technically incorrect because it references a non-existent 'country' column in the virtual_tour_data table. It also incorrectly uses COUNT(DISTINCT hotel_id) which measures unique hotel visits rather than total tours. The Generated SQL correctly joins the tables to filter UK hotels, counts all tours per user (COUNT(*)), and retrieves the maximum value. While both queries aim to find the maximum tours, the Generated SQL properly addresses the business intent by counting actual tour records rather than distinct hotels.", "overall_assessment": "differently_correct"}}
{"example_id": 5812, "sql_complexity": "single join", "prompt": "Calculate the percentage of Shariah-compliant investments held by each investor in the top 5 countries with the highest percentage?", "context": "CREATE TABLE investors (investor_id INT, investor_name TEXT, country TEXT); INSERT INTO investors (investor_id, investor_name, country) VALUES (1, 'Al Thani', 'Qatar'), (2, 'Saudi Investment Group', 'Saudi Arabia'), (3, 'Temasek Holdings', 'Singapore'); CREATE TABLE investments (investment_id INT, investor_id INT, investment_type TEXT, investment_value DECIMAL, is_shariah_compliant BOOLEAN); INSERT INTO investments (investment_id, investor_id, investment_type, investment_value, is_shariah_compliant) VALUES (1, 1, 'Real Estate', 15000000, true), (2, 2, 'Stocks', 20000000, false);", "reference_sql": "SELECT investor_name, ROUND((SUM(CASE WHEN is_shariah_compliant THEN investment_value ELSE 0 END) / SUM(investment_value)) * 100, 2) AS percentage FROM investments JOIN investors ON investments.investor_id = investors.investor_id GROUP BY investor_name ORDER BY percentage DESC LIMIT 5;", "generated_sql": "WITH country_shariah_percent AS (\n    SELECT \n        i.country,\n        SUM(CASE WHEN inv.is_shariah_compliant THEN inv.investment_value ELSE 0 END) * 100.0 / SUM(inv.investment_value) AS shariah_percent\n    FROM investors i\n    JOIN investments inv ON i.investor_id = inv.investor_id\n    GROUP BY i.country\n    ORDER BY shariah_percent DESC\n    LIMIT 5\n)\nSELECT \n    i.investor_id,\n    i.investor_name,\n    i.country,\n    SUM(CASE WHEN inv.is_shariah_compliant THEN inv.investment_value ELSE 0 END) * 100.0 / SUM(inv.investment_value) AS investor_shariah_percent\nFROM investors i\nJOIN investments inv ON i.investor_id = inv.investor_id\nWHERE i.country IN (SELECT country FROM country_shariah_percent)\nGROUP BY i.investor_id, i.investor_name, i.country\nORDER BY investor_shariah_percent DESC;", "raw_model_output": "\n\n```sql\nWITH country_shariah_percent AS (\n    SELECT \n        i.country,\n        SUM(CASE WHEN inv.is_shariah_compliant THEN inv.investment_value ELSE 0 END) * 100.0 / SUM(inv.investment_value) AS shariah_percent\n    FROM investors i\n    JOIN investments inv ON i.investor_id = inv.investor_id\n    GROUP BY i.country\n    ORDER BY shariah_percent DESC\n    LIMIT 5\n)\nSELECT \n    i.investor_id,\n    i.investor_name,\n    i.country,\n    SUM(CASE WHEN inv.is_shariah_compliant THEN inv.investment_value ELSE 0 END) * 100.0 / SUM(inv.investment_value) AS investor_shariah_percent\nFROM investors i\nJOIN investments inv ON i.investor_id = inv.investor_id\nWHERE i.country IN (SELECT country FROM country_shariah_percent)\nGROUP BY i.investor_id, i.investor_name, i.country\nORDER BY investor_shariah_percent DESC;\n```", "latency_sec": 19.248536825180054, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 257, "prompt_eval_sec": null, "tokens_completion": 3002, "completion_eval_sec": null, "tokens_total": 3259, "tokens_per_sec": 169.31157051567294, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL calculates shariah compliance percentages per investor across all countries, while the Generated SQL first filters investors to those from countries in the top 5 shariah compliance percentages (via a CTE). Additionally, the Generated SQL does not round the percentage values, and the final output includes investor details (ID, name, country) rather than just investor names. The filtering and output structure differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL calculates Shariah compliance percentages per investor without considering country-level aggregation, directly contradicting the requirement to focus on the top 5 countries. It groups by investor_name (which may not be unique) and lacks country filtering. The Generated SQL correctly first identifies the top 5 countries with the highest Shariah compliance percentages via a CTE, then calculates individual investor percentages within those countries. This two-step approach aligns with the business intent of analyzing investors in context of their country's compliance trends. The Generated SQL also uses proper grouping by investor_id (unique identifier) and handles edge cases like division by zero implicitly.", "overall_assessment": "differently_correct"}}
{"example_id": 4706, "sql_complexity": "multiple_joins", "prompt": "Who are the top 3 customers by total spend on makeup products from Italy and Spain?", "context": "CREATE TABLE customers (customer_id INT, customer_name TEXT, country TEXT); INSERT INTO customers (customer_id, customer_name, country) VALUES (1, 'Alessandro Martini', 'IT'), (2, 'Laura Rossi', 'ES'), (3, 'Daniela Gonzalez', 'MX'), (4, 'Jose Hernandez', 'ES'), (5, 'Sophia Rodriguez', 'IT'); CREATE TABLE sales (sale_id INT, customer_id INT, product_id INT, sale_quantity INT, sale_country TEXT); INSERT INTO sales (sale_id, customer_id, product_id, sale_quantity, sale_country) VALUES (1, 1, 1, 100, 'IT'), (2, 2, 2, 150, 'ES'), (3, 3, 3, 200, 'MX'), (4, 4, 4, 250, 'ES'), (5, 5, 5, 300, 'IT'); CREATE TABLE products (product_id INT, product_name TEXT, category TEXT); INSERT INTO products (product_id, product_name, category) VALUES (1, 'Eyeshadow Palette', 'makeup'), (2, 'Liquid Lipstick', 'makeup'), (3, 'BB Cream', 'makeup'), (4, 'Volumizing Mascara', 'makeup'), (5, 'Nourishing Lip Balm', 'makeup');", "reference_sql": "SELECT c.customer_name, SUM(s.sale_quantity) as total_spent_on_makeup FROM sales s JOIN customers c ON s.customer_id = c.customer_id JOIN products p ON s.product_id = p.product_id WHERE c.country IN ('IT', 'ES') AND p.category = 'makeup' GROUP BY c.customer_name ORDER BY total_spent_on_makeup DESC LIMIT 3;", "generated_sql": "SELECT c.customer_name, SUM(s.sale_quantity) AS total_spend\nFROM customers c\nJOIN sales s ON c.customer_id = s.customer_id\nJOIN products p ON s.product_id = p.product_id\nWHERE p.category = 'makeup' AND s.sale_country IN ('IT', 'ES')\nGROUP BY c.customer_id, c.customer_name\nORDER BY total_spend DESC\nLIMIT 3;", "raw_model_output": "\n\nTo determine the **top 3 customers by total spend on makeup products from Italy and Spain**, we must:\n\n1. **Join** the `customers`, `sales`, and `products` tables.\n2. **Filter** for:\n   - `products.category = 'makeup'`\n   - `sales.sale_country IN ('IT', 'ES')`\n3. **Group** by `customer_id` and sum `sale_quantity` (assuming \"total spend\" refers to total quantity sold, as no price data is available).\n4. **Order** by total quantity in descending order.\n5. **Limit** the result to the top 3 customers.\n\n---\n\n### \u2705 Final SQL Query\n\n```sql\nSELECT c.customer_name, SUM(s.sale_quantity) AS total_spend\nFROM customers c\nJOIN sales s ON c.customer_id = s.customer_id\nJOIN products p ON s.product_id = p.product_id\nWHERE p.category = 'makeup' AND s.sale_country IN ('IT', 'ES')\nGROUP BY c.customer_id, c.customer_name\nORDER BY total_spend DESC\nLIMIT 3;\n```\n\n---\n\n### \ud83d\udccc Explanation\n\n- **`JOIN`** ensures we link customer data with their sales and the product details.\n- **`WHERE`** filters only makeup products and sales from Italy or Spain.\n- **`SUM(s.sale_quantity)`** aggregates the total quantity sold per customer.\n- **`ORDER BY`** and **`LIMIT`** return the top 3 customers based on this total.\n\n---\n\n### \ud83e\uddfe Expected Result (Based on Sample Data)\n\n| customer_name         | total_spend |\n|-----------------------|-------------|\n| Sophia Rodriguez      | 300         |\n| Jose Hernandez        | 250         |\n| Laura Rossi           | 150         |", "latency_sec": 14.576780080795288, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 393, "prompt_eval_sec": null, "tokens_completion": 2268, "completion_eval_sec": null, "tokens_total": 2661, "tokens_per_sec": 182.55060344265135, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their filtering conditions and grouping. The Reference SQL filters customers by country ('IT', 'ES'), while the Generated SQL filters sales by sale_country ('IT', 'ES'). Additionally, the Reference groups by customer_name (which may not be unique) whereas the Generated groups by customer_id (unique) and customer_name. These differences could lead to different results if customer_country and sale_country diverge, or if customer_names are non-unique.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The Reference SQL correctly filters customers from Italy (IT) and Spain (ES) using the customers.country column, which aligns with the business requirement to identify customers from those countries. The Generated SQL incorrectly uses sales.sale_country, which would include customers whose sales occurred in IT/ES but who may not be originally from those countries. Both queries calculate total spend on makeup products correctly, but the Reference's WHERE clause better matches the business intent. The Generated SQL's grouping by customer_id and name is technically superior but cannot compensate for the flawed filter condition.", "overall_assessment": "differently_correct"}}
{"example_id": 1515, "sql_complexity": "multiple_joins", "prompt": "What is the average age of clients who lost cases in the 'personal injury' category?", "context": "CREATE TABLE Cases (CaseID int, ClientID int, Category varchar(50)); INSERT INTO Cases (CaseID, ClientID, Category) VALUES (701, 7, 'Personal Injury'); CREATE TABLE Clients (ClientID int, Age int, Gender varchar(10)); INSERT INTO Clients (ClientID, Age, Gender) VALUES (7, 45, 'Male'); CREATE TABLE CaseOutcomes (CaseID int, Outcome varchar(50)); INSERT INTO CaseOutcomes (CaseID, Outcome) VALUES (701, 'Lost');", "reference_sql": "SELECT AVG(C.Age) as AvgAge FROM Clients C INNER JOIN Cases CA ON C.ClientID = CA.ClientID INNER JOIN CaseOutcomes CO ON CA.CaseID = CO.CaseID WHERE CA.Category = 'Personal Injury' AND CO.Outcome = 'Lost';", "generated_sql": "SELECT AVG(Clients.Age)\nFROM Clients\nJOIN Cases ON Clients.ClientID = Cases.ClientID\nJOIN CaseOutcomes ON Cases.CaseID = CaseOutcomes.CaseID\nWHERE Cases.Category = 'Personal Injury' AND CaseOutcomes.Outcome = 'Lost';", "raw_model_output": "\n\nTo determine the **average age of clients who lost cases in the 'personal injury' category**, we need to:\n\n1. **Join** the `Clients`, `Cases`, and `CaseOutcomes` tables using their respective foreign keys (`ClientID` and `CaseID`).\n2. **Filter** the results to include only those cases where:\n   - The `Category` is `'Personal Injury'`\n   - The `Outcome` is `'Lost'`\n3. **Calculate** the average of the `Age` column from the filtered results.\n\n---\n\n### \u2705 SQL Query\n\n```sql\nSELECT AVG(Clients.Age)\nFROM Clients\nJOIN Cases ON Clients.ClientID = Cases.ClientID\nJOIN CaseOutcomes ON Cases.CaseID = CaseOutcomes.CaseID\nWHERE Cases.Category = 'Personal Injury' AND CaseOutcomes.Outcome = 'Lost';\n```\n\n---\n\n### \ud83d\udccc Notes\n\n- This query assumes that a client may have multiple cases in the 'Personal Injury' category, and if any of those cases were lost, the client's age will be included in the average.\n- If you want to ensure that each client is only counted **once**, even if they have multiple lost cases in the same category, you would need to use `DISTINCT` or a subquery with `GROUP BY`. However, based on the phrasing of the question, the above query is the most direct and accurate interpretation.", "latency_sec": 7.893178939819336, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 206, "prompt_eval_sec": null, "tokens_completion": 1229, "completion_eval_sec": null, "tokens_total": 1435, "tokens_per_sec": 181.80254254223777, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average age of clients with 'Personal Injury' cases that resulted in a 'Lost' outcome. They use identical table joins (Clients \u2192 Cases \u2192 CaseOutcomes), same filtering conditions, and reference the same column (Age). The only difference is the use of an alias (C) in the reference query, which does not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are structurally identical in logic, joining the same tables on correct keys (Clients.ClientID = Cases.ClientID and Cases.CaseID = CaseOutcomes.CaseID), filtering for 'Personal Injury' cases with 'Lost' outcomes, and calculating the average client age. The only difference is the use of table aliases in the reference query, which does not affect functionality. Both correctly address the business question by focusing on the specific subset of clients who lost cases in the specified category. The generated query is slightly more concise but neither is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 4388, "sql_complexity": "subqueries", "prompt": "Insert a new drug with a price 10% higher than the average price", "context": "CREATE TABLE drugs (drug_id INT, drug_name VARCHAR(50), price DECIMAL(10, 2)); INSERT INTO drugs (drug_id, drug_name, price) VALUES (1, 'DrugA', 50), (2, 'DrugB', 75), (3, 'DrugC', 100)", "reference_sql": "INSERT INTO drugs (drug_id, drug_name, price) VALUES ((SELECT MAX(drug_id) FROM drugs) + 1, 'DrugD', (SELECT AVG(price) * 1.1 FROM drugs))", "generated_sql": "INSERT INTO drugs (drug_id, drug_name, price) SELECT 4, 'NewDrug', AVG(price) * 1.1 FROM drugs;", "raw_model_output": "\n\nINSERT INTO drugs (drug_id, drug_name, price) SELECT 4, 'NewDrug', AVG(price) * 1.1 FROM drugs;", "latency_sec": 12.571096897125244, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 159, "prompt_eval_sec": null, "tokens_completion": 1967, "completion_eval_sec": null, "tokens_total": 2126, "tokens_per_sec": 169.11809823740785, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Reference SQL uses a subquery to dynamically calculate drug_id as (MAX(drug_id) + 1), while the Generated SQL hardcodes drug_id as 4. Second, the drug_name values differ ('DrugD' vs 'NewDrug'). Although both calculate the price as AVG(price) * 1.1, the inserted rows would have different drug_id and drug_name, making the results non-equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries correctly insert a new drug with a price 10% above the average. The reference query dynamically calculates the next drug_id using (SELECT MAX(drug_id) + 1), ensuring compatibility with any existing data. The generated query hardcodes drug_id=4, which works in the given context but would fail if the max drug_id wasn't 3. While both produce identical results in this specific scenario, the reference query is more robust and generalizable. The business intent of creating a new drug with a price 10% above average is fulfilled by both, but the reference better handles edge cases.", "overall_assessment": "correct"}}
{"example_id": 5431, "sql_complexity": "basic SQL", "prompt": "What is the average CO2 emission of ride-hailing vehicles in San Francisco?", "context": "CREATE TABLE SFRideHailing (id INT, company VARCHAR(20), co2_emission DECIMAL(5,2));", "reference_sql": "SELECT AVG(co2_emission) FROM SFRideHailing WHERE company = 'Uber';", "generated_sql": "SELECT AVG(co2_emission) FROM SFRideHailing;", "raw_model_output": "\n\nSELECT AVG(co2_emission) FROM SFRideHailing;", "latency_sec": 2.3033437728881836, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 114, "prompt_eval_sec": null, "tokens_completion": 325, "completion_eval_sec": null, "tokens_total": 439, "tokens_per_sec": 190.59247914588707, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query filters results to only include rows where company = 'Uber' before calculating the average, while the generated query calculates the average for all rows in the table without any filtering. Unless all rows in SFRideHailing are guaranteed to have company = 'Uber' (which is not stated in the context), the two queries would produce different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query is technically correct but semantically limited - it only calculates the average CO2 emission for Uber vehicles, not all ride-hailing vehicles in San Francisco. The generated query correctly averages all entries in the SFRideHailing table, which presumably contains all relevant ride-hailing vehicles in the city. However, neither query explicitly filters for 'ride-hailing' vehicles (though the table name implies this). The generated query better fulfills the business intent by not making unwarranted assumptions about the company, but both queries could be improved by adding a filter for active vehicles or specific vehicle types if such columns existed.", "overall_assessment": "differently_correct"}}
{"example_id": 3531, "sql_complexity": "single join", "prompt": "What is the total number of workouts and total workout time per user for users with a membership type of 'Basic'?", "context": "CREATE TABLE Members (id INT, user_name VARCHAR, membership_type VARCHAR, signup_date DATE); CREATE TABLE Workouts (id INT, user_id INT, workout_date DATE, workout_duration INT); INSERT INTO Members (id, user_name, membership_type, signup_date) VALUES (1, 'John Doe', 'Premium', '2020-01-01'), (2, 'Jane Smith', 'Basic', '2019-06-15'), (3, 'Alice Johnson', 'Premium', '2020-03-20'); INSERT INTO Workouts (id, user_id, workout_date, workout_duration) VALUES (1, 1, '2020-01-01', 60), (2, 1, '2020-01-02', 70), (3, 2, '2019-06-15', 90), (4, 3, '2020-03-20', 65), (5, 3, '2020-03-21', 70);", "reference_sql": "SELECT Members.user_name, SUM(Workouts.workout_duration) AS total_workout_time, COUNT(Workouts.id) AS total_workouts FROM Members JOIN Workouts ON Members.id = Workouts.user_id WHERE Members.membership_type = 'Basic' GROUP BY Members.user_name;", "generated_sql": "SELECT m.id, COUNT(w.id) AS total_workouts, SUM(w.workout_duration) AS total_time\nFROM Members m\nJOIN Workouts w ON m.id = w.user_id\nWHERE m.membership_type = 'Basic'\nGROUP BY m.id;", "raw_model_output": "\n\nSELECT m.id, COUNT(w.id) AS total_workouts, SUM(w.workout_duration) AS total_time\nFROM Members m\nJOIN Workouts w ON m.id = w.user_id\nWHERE m.membership_type = 'Basic'\nGROUP BY m.id;", "latency_sec": 9.583615064620972, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 342, "prompt_eval_sec": null, "tokens_completion": 1501, "completion_eval_sec": null, "tokens_total": 1843, "tokens_per_sec": 192.3073900164927, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL groups by Members.user_name, while the Generated SQL groups by Members.id. Although both filter for 'Basic' membership, grouping by user_name (which may not be unique) vs. id (a unique primary key) can produce different results if multiple users share the same name. Additionally, the column aliases differ (total_workout_time vs. total_time), but the core discrepancy lies in the grouping strategy.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "While both queries calculate total workouts and workout time for Basic members, they differ in key aspects. The Reference SQL groups by user_name (which may not be unique) and returns user names, while the Generated SQL groups by user ID (unique identifier) and returns IDs. The original question asks for 'per user' data, making user ID the more accurate identifier. The Generated query also uses clearer column aliases (total_workouts/total_time vs. total_workout_time/total_workouts). Both would produce same results with the sample data, but the Generated query better handles edge cases with non-unique user names.", "overall_assessment": "differently_correct"}}
{"example_id": 5678, "sql_complexity": "set operations", "prompt": "How many public works projects are there in 'Sydney' and 'Melbourne' combined?", "context": "CREATE TABLE PublicWorksC(id INT, city VARCHAR(20), project VARCHAR(30)); INSERT INTO PublicWorksC(id, city, project) VALUES (1, 'Sydney', 'Park Renovation'), (2, 'Melbourne', 'Sidewalk Repair');", "reference_sql": "SELECT COUNT(*) FROM (SELECT city FROM PublicWorksC WHERE city = 'Sydney' UNION ALL SELECT city FROM PublicWorksC WHERE city = 'Melbourne') AS Total;", "generated_sql": "SELECT COUNT(*) FROM PublicWorksC WHERE city IN ('Sydney', 'Melbourne');", "raw_model_output": "\n\nSELECT COUNT(*) FROM PublicWorksC WHERE city IN ('Sydney', 'Melbourne');", "latency_sec": 1.3992571830749512, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 146, "prompt_eval_sec": null, "tokens_completion": 183, "completion_eval_sec": null, "tokens_total": 329, "tokens_per_sec": 235.12475331875936, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of rows in PublicWorksC where the city is either 'Sydney' or 'Melbourne'. The reference query uses UNION ALL to combine results from two separate SELECTs, while the generated query uses IN to achieve the same filtering. Since UNION ALL preserves duplicates and the IN clause includes all matching rows, the final COUNT(*) will be identical in both cases.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count projects in Sydney and Melbourne. The reference query uses an unnecessary subquery with UNION ALL, which combines results from two separate SELECTs. The generated query simplifies this with a single WHERE clause using IN, achieving the same result. While both are technically correct and semantically equivalent, the generated query is more efficient (single table scan vs. two scans and union operation) and elegant.", "overall_assessment": "correct"}}
{"example_id": 5792, "sql_complexity": "multiple_joins", "prompt": "How many cases were handled by attorneys in the 'Los Angeles' office?", "context": "CREATE TABLE offices (office_id INT, office_name VARCHAR(20), city VARCHAR(20), state VARCHAR(20)); INSERT INTO offices (office_id, office_name, city, state) VALUES (1, 'Boston', 'Boston', 'MA'), (2, 'New York', 'New York', 'NY'), (3, 'Los Angeles', 'Los Angeles', 'CA'); CREATE TABLE attorneys (attorney_id INT, office_id INT); INSERT INTO attorneys (attorney_id, office_id) VALUES (1, 1), (2, 2), (3, 3); CREATE TABLE cases (case_id INT, attorney_id INT); INSERT INTO cases (case_id, attorney_id) VALUES (1, 1), (2, 2), (3, 3);", "reference_sql": "SELECT COUNT(*) FROM cases JOIN attorneys ON cases.attorney_id = attorneys.attorney_id JOIN offices ON attorneys.office_id = offices.office_id WHERE offices.city = 'Los Angeles';", "generated_sql": "SELECT COUNT(*) AS case_count\nFROM cases\nJOIN attorneys ON cases.attorney_id = attorneys.attorney_id\nJOIN offices ON attorneys.office_id = offices.office_id\nWHERE offices.office_name = 'Los Angeles';", "raw_model_output": "\n\nTo determine how many cases were handled by attorneys in the 'Los Angeles' office, we need to trace the relationships between the three tables: `cases`, `attorneys`, and `offices`.\n\n---\n\n### **Step-by-Step Breakdown**\n\n1. **Identify the relevant office**:  \n   The `offices` table contains the `office_name` column. We are interested in the office where `office_name = 'Los Angeles'`.\n\n2. **Link attorneys to their office**:  \n   The `attorneys` table contains an `office_id` that references the `offices.office_id`.\n\n3. **Link cases to attorneys**:  \n   The `cases` table contains an `attorney_id` that references the `attorneys.attorney_id`.\n\n4. **Combine the data**:  \n   We need to join the `cases` table with the `attorneys` table on `attorney_id`, and then join the result with the `offices` table on `office_id`. This allows us to filter only those cases where the attorney is associated with the 'Los Angeles' office.\n\n5. **Count the cases**:  \n   Finally, we count the number of rows in the resulting dataset.\n\n---\n\n### **Final SQL Query**\n\n```sql\nSELECT COUNT(*) AS case_count\nFROM cases\nJOIN attorneys ON cases.attorney_id = attorneys.attorney_id\nJOIN offices ON attorneys.office_id = offices.office_id\nWHERE offices.office_name = 'Los Angeles';\n```\n\nThis query will return the number of cases handled by attorneys located in the 'Los Angeles' office.", "latency_sec": 6.654904127120972, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 251, "prompt_eval_sec": null, "tokens_completion": 1035, "completion_eval_sec": null, "tokens_total": 1286, "tokens_per_sec": 193.24095064857775, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters on 'offices.city = 'Los Angeles'', while the Generated SQL filters on 'offices.office_name = 'Los Angeles''. These are different columns: 'city' vs 'office_name'. Although in the sample data they happen to have matching values, the schema allows them to differ, so the conditions are not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries produce the same results in this specific dataset because the 'Los Angeles' office has matching values in both office_name and city columns. However, the generated query better aligns with business intent by explicitly filtering on offices.office_name = 'Los Angeles', which directly identifies the office by its name rather than its city. This is more precise for the question's phrasing ('Los Angeles office') and avoids potential ambiguity if office_name and city values diverged in other scenarios. The generated query also includes an explicit alias (case_count) for clarity without affecting functionality.", "overall_assessment": "differently_correct"}}
{"example_id": 5148, "sql_complexity": "window functions", "prompt": "List the unique types of smart city technologies that have been implemented in the top 3 most populous countries in the world.", "context": "CREATE TABLE smart_city_tech (tech_type VARCHAR(255), country VARCHAR(255)); CREATE TABLE country_populations (country VARCHAR(255), population INT);", "reference_sql": "SELECT DISTINCT tech_type FROM smart_city_tech SCT WHERE country IN (SELECT country FROM (SELECT country, ROW_NUMBER() OVER (ORDER BY population DESC) as rank FROM country_populations) CP WHERE rank <= 3);", "generated_sql": "SELECT DISTINCT tech_type\nFROM smart_city_tech\nWHERE country IN (\n    SELECT country\n    FROM country_populations\n    ORDER BY population DESC\n    LIMIT 3\n);", "raw_model_output": "\n\n```sql\nSELECT DISTINCT tech_type\nFROM smart_city_tech\nWHERE country IN (\n    SELECT country\n    FROM country_populations\n    ORDER BY population DESC\n    LIMIT 3\n);\n```", "latency_sec": 3.8940720558166504, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 132, "prompt_eval_sec": null, "tokens_completion": 587, "completion_eval_sec": null, "tokens_total": 719, "tokens_per_sec": 184.63962394481527, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries aim to retrieve distinct tech_types from smart_city_tech where the country is among the top 3 most populous countries. The reference query uses a window function (ROW_NUMBER) to rank countries by population and filters for rank <= 3, while the generated query uses ORDER BY population DESC with LIMIT 3. Both approaches effectively identify the top 3 countries by population, assuming consistent ordering. The result sets would be identical in all cases where the population data is unique or ties are handled consistently.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify unique smart city technologies in the top 3 most populous countries. The reference query uses a window function with ROW_NUMBER() to rank countries by population, while the generated query uses ORDER BY and LIMIT 3. Both approaches yield the same result when the top 3 countries are unambiguously defined. However, the generated query is more efficient and elegant, as LIMIT 3 directly achieves the goal without the overhead of a window function. The reference query could potentially include more than 3 countries if there are population ties (e.g., multiple countries with the same population as the 3rd-ranked country), but this edge case is not explicitly addressed in the original question. The generated query's simplicity makes it the superior choice.", "overall_assessment": "correct"}}
{"example_id": 5547, "sql_complexity": "multiple_joins", "prompt": "Which species have a population growth rate higher than the average for protected areas?", "context": "CREATE TABLE species (id INT, name VARCHAR(50), population DECIMAL(5,2), protected_area_id INT, growth_rate DECIMAL(5,2)); INSERT INTO species (id, name, population, protected_area_id, growth_rate) VALUES (1, 'Species 1', 500.00, 1, 0.05), (2, 'Species 2', 800.00, 1, 0.03), (3, 'Species 3', 1200.00, 2, 0.07), (4, 'Species 4', 700.00, 2, 0.02); CREATE TABLE protected_areas (id INT, name VARCHAR(50)); INSERT INTO protected_areas (id, name) VALUES (1, 'Area 1'), (2, 'Area 2');", "reference_sql": "SELECT s.name, s.growth_rate FROM species s INNER JOIN protected_areas pa ON s.protected_area_id = pa.id GROUP BY s.name, s.growth_rate HAVING s.growth_rate > (SELECT AVG(s.growth_rate) FROM species s INNER JOIN protected_areas pa ON s.protected_area_id = pa.id);", "generated_sql": "SELECT s.id, s.name, s.growth_rate\nFROM species s\nJOIN (\n    SELECT protected_area_id, AVG(growth_rate) AS avg_growth\n    FROM species\n    GROUP BY protected_area_id\n) AS avg_growth_per_area\nON s.protected_area_id = avg_growth_per_area.protected_area_id\nWHERE s.growth_rate > avg_growth_per_area.avg_growth;", "raw_model_output": "\n\nTo determine which species have a population growth rate higher than the average for their respective protected areas, we need to:\n\n1. Calculate the average growth rate of species within each protected area.\n2. Compare each species' growth rate to the average for its protected area.\n3. Return the species that exceed this average.\n\nThis can be achieved using a subquery to compute the average growth rate per protected area, then joining this result with the original `species` table to filter the desired records.\n\n---\n\n### \u2705 SQL Query\n\n```sql\nSELECT s.id, s.name, s.growth_rate\nFROM species s\nJOIN (\n    SELECT protected_area_id, AVG(growth_rate) AS avg_growth\n    FROM species\n    GROUP BY protected_area_id\n) AS avg_growth_per_area\nON s.protected_area_id = avg_growth_per_area.protected_area_id\nWHERE s.growth_rate > avg_growth_per_area.avg_growth;\n```\n\n---\n\n### \ud83e\udde0 Explanation\n\n- **Subquery**: `avg_growth_per_area` computes the average `growth_rate` for each `protected_area_id`.\n- **Join**: The `species` table is joined with the subquery on `protected_area_id` to associate each species with the average growth rate of its area.\n- **Filter**: The `WHERE` clause selects only those species whose `growth_rate` is greater than the average for their protected area.\n\nThis query will return the species that are growing faster than the average for their respective protected areas.", "latency_sec": 8.310424089431763, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 279, "prompt_eval_sec": null, "tokens_completion": 1282, "completion_eval_sec": null, "tokens_total": 1561, "tokens_per_sec": 187.83638274069546, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL compares species growth rates to the overall average growth rate across all protected areas, while the Generated SQL compares them to the average growth rate within their specific protected area. The HAVING clause in the Reference uses a scalar subquery for the global average, whereas the Generated SQL uses a per-area average from a derived table. This results in different filtering conditions and potentially different output.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL calculates the overall average growth rate across all protected areas, while the original question requires comparing each species to the average growth rate *within its own protected area*. The Generated SQL correctly computes per-protected-area averages using a subquery and joins back to compare species against their specific area's average. This aligns with the business intent of identifying species exceeding their local protected area's average growth rate. The Reference SQL's approach would incorrectly flag species that outperform the global average but not necessarily their specific area's average.", "overall_assessment": "differently_correct"}}
{"example_id": 5498, "sql_complexity": "aggregation", "prompt": "Identify the destinations with the highest number of repeat visitors from the US.", "context": "CREATE TABLE RepeatTravelers (Visitor VARCHAR(20), Destination VARCHAR(20), VisitCount INT); INSERT INTO RepeatTravelers (Visitor, Destination, VisitCount) VALUES ('David', 'Paris', 3), ('Ella', 'London', 4), ('Fiona', 'Paris', 2);", "reference_sql": "SELECT Destination, AVG(VisitCount) AS AvgVisitCount FROM RepeatTravelers WHERE Visitor LIKE '%USA%' GROUP BY Destination ORDER BY AvgVisitCount DESC;", "generated_sql": "SELECT Destination, SUM(VisitCount) AS TotalVisits\nFROM RepeatTravelers\nGROUP BY Destination\nORDER BY TotalVisits DESC\nLIMIT 1;", "raw_model_output": "\n\nThe provided schema does not include a column to identify the country of origin for visitors. Therefore, it is not possible to filter visitors \"from the US\" based on the given data. Assuming the question intends to find destinations with the highest total visit counts (regardless of visitor origin), the SQL query would be:\n\n```sql\nSELECT Destination, SUM(VisitCount) AS TotalVisits\nFROM RepeatTravelers\nGROUP BY Destination\nORDER BY TotalVisits DESC\nLIMIT 1;\n```\n\n**Note:** The condition \"from the US\" cannot be enforced with the current schema. If the intent was to exclude non-US visitors, the schema would need a `Country` column.", "latency_sec": 6.6510169506073, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 150, "prompt_eval_sec": null, "tokens_completion": 1036, "completion_eval_sec": null, "tokens_total": 1186, "tokens_per_sec": 178.3185953077006, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query filters for visitors with 'USA' in their name, calculates average visit counts, and returns all destinations. The generated query removes the filter, calculates total visits instead of average, and returns only the top destination. Additionally, the sample data contains no 'USA' visitors, making the reference query return empty results while the generated query returns a single row.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query incorrectly filters for 'USA' in the Visitor column (which contains names, not countries) and calculates average VisitCount, while the generated query sums VisitCount without filtering for US visitors. Neither query correctly addresses the business intent of identifying US repeat visitors. However, the generated query better aligns with the 'repeat visitors' aspect by aggregating total visits (sum) rather than averaging, which is more relevant for measuring visit frequency. The reference query's WHERE clause is fundamentally flawed given the schema, making it less effective despite its intent to filter US visitors.", "overall_assessment": "incorrect"}}
{"example_id": 3546, "sql_complexity": "window functions", "prompt": "What are the cryptocurrency exchanges with their corresponding blockchain companies, ranked by exchange ID in ascending order, for the Bitcoin platform?", "context": "CREATE TABLE cryptocurrency_exchanges (exchange_id INT, exchange_name VARCHAR(50), company_id INT); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (1, 'Binance', 1); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (2, 'Coinbase', 2); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (3, 'Kraken', 3); CREATE TABLE blockchain_companies (company_id INT, company_name VARCHAR(50), platform VARCHAR(50)); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (1, 'Binance', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (2, 'Blockstream', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (3, 'Blockchair', 'Bitcoin');", "reference_sql": "SELECT ce.exchange_name, bc.company_name, ce.exchange_id, ROW_NUMBER() OVER (PARTITION BY bc.platform ORDER BY ce.exchange_id ASC) as rank FROM cryptocurrency_exchanges ce JOIN blockchain_companies bc ON ce.company_id = bc.company_id WHERE bc.platform = 'Bitcoin';", "generated_sql": "SELECT ce.exchange_id, ce.exchange_name, bc.company_name\nFROM cryptocurrency_exchanges ce\nJOIN blockchain_companies bc ON ce.company_id = bc.company_id\nWHERE bc.platform = 'Bitcoin'\nORDER BY ce.exchange_id ASC;", "raw_model_output": "\n\nSELECT ce.exchange_id, ce.exchange_name, bc.company_name\nFROM cryptocurrency_exchanges ce\nJOIN blockchain_companies bc ON ce.company_id = bc.company_id\nWHERE bc.platform = 'Bitcoin'\nORDER BY ce.exchange_id ASC;", "latency_sec": 3.720668315887451, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 291, "prompt_eval_sec": null, "tokens_completion": 570, "completion_eval_sec": null, "tokens_total": 861, "tokens_per_sec": 231.41003897699892, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a 'rank' column generated by ROW_NUMBER() and does not have an ORDER BY clause, while the Generated SQL omits the 'rank' column and adds an ORDER BY ce.exchange_id ASC. The presence of the additional column in the Reference SQL and the differing ordering behavior make the queries semantically distinct.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query adds a redundant 'rank' column using ROW_NUMBER() which was not requested in the original question. The generated query directly addresses the requirements by joining tables, filtering for 'Bitcoin', and ordering by exchange_id as specified. While both retrieve the correct data, the generated query avoids unnecessary complexity. The reference query's ranking logic is redundant since the question only requires ordering, not actual ranking. The generated query is more efficient and precisely matches the business intent.", "overall_assessment": "differently_correct"}}
{"example_id": 486, "sql_complexity": "single join", "prompt": "What is the average price of paintings from African artists in our collection?", "context": "CREATE TABLE Artworks (id INT, title VARCHAR(50), price DECIMAL(10,2), medium VARCHAR(50), artist_nationality VARCHAR(50)); CREATE TABLE Collections (id INT, name VARCHAR(50), continent VARCHAR(50));", "reference_sql": "SELECT AVG(Artworks.price) FROM Artworks INNER JOIN Collections ON Artworks.artist_nationality = Collections.continent WHERE Artworks.medium = 'Painting' AND Collections.continent = 'Africa';", "generated_sql": "SELECT AVG(price) AS average_price\nFROM Artworks\nWHERE medium = 'painting'\n  AND artist_nationality = 'African';", "raw_model_output": "\n\nTo determine the **average price of paintings from African artists in our collection**, we need to consider the following:\n\n- The `Artworks` table contains the `price`, `medium`, and `artist_nationality` columns.\n- We are interested in **paintings**, which we assume are records where `medium = 'painting'`.\n- We are interested in **African artists**, which we assume corresponds to records where `artist_nationality = 'African'`.\n- The phrase \"in our collection\" is interpreted as referring to the entire dataset in the `Artworks` table, as there is no explicit relationship defined between `Artworks` and `Collections` in the schema.\n\n---\n\n### \u2705 Final SQL Query\n\n```sql\nSELECT AVG(price) AS average_price\nFROM Artworks\nWHERE medium = 'painting'\n  AND artist_nationality = 'African';\n```\n\n---\n\n### \ud83d\udccc Notes\n\n- This query assumes that `artist_nationality = 'African'` is the correct way to identify African artists, based on the schema provided.\n- If the actual data uses different values (e.g., country names like `'Nigeria'`, `'Kenya'`, etc.), the query would need to be adjusted accordingly.\n- The `Collections` table is not used in this query because there is no defined relationship between `Artworks` and `Collections` in the schema.", "latency_sec": 10.479100704193115, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 141, "prompt_eval_sec": null, "tokens_completion": 1652, "completion_eval_sec": null, "tokens_total": 1793, "tokens_per_sec": 171.10246867677753, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Reference SQL joins Artworks with Collections on artist_nationality = continent and filters Collections.continent = 'Africa', which implies Artworks.artist_nationality = 'Africa'. The Generated SQL directly filters artist_nationality = 'African' (note the spelling difference). Second, the Generated SQL omits the join with Collections entirely. These differences in filtering conditions and table usage make the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in their approach to identifying African artists. The reference query incorrectly joins Artworks.artist_nationality with Collections.continent (which would only match if an artist's nationality was explicitly named 'Africa'), and then filters Collections.continent = 'Africa' (redundant due to the join). The generated query directly filters Artworks.artist_nationality = 'African', which more accurately captures the business intent of identifying African artists. While both queries calculate the correct average price, the generated query avoids an unnecessary join and uses a more direct filter. The reference query's logic is flawed because artist nationality and continent are distinct concepts, and the join condition would rarely produce meaningful results.", "overall_assessment": "differently_correct"}}
{"example_id": 794, "sql_complexity": "multiple_joins", "prompt": "Which suppliers have provided raw materials for the production of chemicals with high environmental impact?", "context": "CREATE TABLE suppliers (id INT, name TEXT); INSERT INTO suppliers (id, name) VALUES (1, 'Supplier1'), (2, 'Supplier2'), (3, 'Supplier3'); CREATE TABLE chemicals (id INT, name TEXT, environmental_impact INT); INSERT INTO chemicals (id, name, environmental_impact) VALUES (1, 'ChemA', 10), (2, 'ChemB', 20), (3, 'ChemC', 15); CREATE TABLE raw_materials (chemical_id INT, supplier_id INT); INSERT INTO raw_materials (chemical_id, supplier_id) VALUES (1, 1), (1, 2), (2, 3), (3, 1);", "reference_sql": "SELECT s.name FROM suppliers s INNER JOIN raw_materials rm ON s.id = rm.supplier_id INNER JOIN chemicals c ON rm.chemical_id = c.id WHERE c.environmental_impact > 10;", "generated_sql": "SELECT DISTINCT s.name\nFROM suppliers s\nJOIN raw_materials rm ON s.id = rm.supplier_id\nJOIN chemicals c ON rm.chemical_id = c.id\nWHERE c.environmental_impact = (SELECT MAX(environmental_impact) FROM chemicals);", "raw_model_output": "\n\nSELECT DISTINCT s.name\nFROM suppliers s\nJOIN raw_materials rm ON s.id = rm.supplier_id\nJOIN chemicals c ON rm.chemical_id = c.id\nWHERE c.environmental_impact = (SELECT MAX(environmental_impact) FROM chemicals);", "latency_sec": 9.591023921966553, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 238, "prompt_eval_sec": null, "tokens_completion": 1513, "completion_eval_sec": null, "tokens_total": 1751, "tokens_per_sec": 182.56653452710535, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL selects suppliers of chemicals with environmental impact > 10 (ChemB [20] and ChemC [15]), returning Supplier1 (ChemC) and Supplier3 (ChemB). The Generated SQL selects suppliers of the chemical with maximum environmental impact (ChemB [20]), returning only Supplier3. The conditions and result sets differ.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent. The reference query uses a simple threshold (environmental_impact > 10) to define 'high environmental impact,' while the generated query selects only chemicals with the maximum environmental impact value. The original question lacks a defined threshold for 'high,' but the reference query aligns better with common interpretations of 'high' as any value above a reasonable cutoff (e.g., 10). The generated query is overly restrictive, capturing only the single chemical with the highest impact (ChemB, 20). Both queries correctly join the necessary tables, but the reference's approach is more inclusive and practical for business analysis. The reference also avoids the subquery, making it more efficient and readable.", "overall_assessment": "differently_correct"}}
{"example_id": 3164, "sql_complexity": "set operations", "prompt": "What is the average age of patients who received therapy in 'clinic_a' and 'clinic_b'?", "context": "CREATE TABLE clinic_a (patient_id INT, age INT, therapy_received BOOLEAN); INSERT INTO clinic_a (patient_id, age, therapy_received) VALUES (1, 35, true), (2, 42, true), (3, 28, false); CREATE TABLE clinic_b (patient_id INT, age INT, therapy_received BOOLEAN); INSERT INTO clinic_b (patient_id, age, therapy_received) VALUES (4, 50, true), (5, 32, false), (6, 45, true);", "reference_sql": "SELECT AVG(age) FROM (SELECT age FROM clinic_a WHERE therapy_received = true UNION ALL SELECT age FROM clinic_b WHERE therapy_received = true) AS combined_clinics;", "generated_sql": "SELECT AVG(age) AS average_age\nFROM (\n    SELECT age\n    FROM clinic_a\n    WHERE therapy_received = TRUE\n    UNION ALL\n    SELECT age\n    FROM clinic_b\n    WHERE therapy_received = TRUE\n) AS combined_patients;", "raw_model_output": "\n\nTo calculate the **average age of patients who received therapy** in both `clinic_a` and `clinic_b`, we need to:\n\n1. **Filter** patients who received therapy (`therapy_received = TRUE`) in each clinic.\n2. **Combine** the results from both clinics using `UNION ALL` (to include all matching rows).\n3. **Compute the average** of the `age` values from the combined result set.\n\n---\n\n### \u2705 SQL Query\n\n```sql\nSELECT AVG(age) AS average_age\nFROM (\n    SELECT age\n    FROM clinic_a\n    WHERE therapy_received = TRUE\n    UNION ALL\n    SELECT age\n    FROM clinic_b\n    WHERE therapy_received = TRUE\n) AS combined_patients;\n```\n\n---\n\n### \ud83e\udde0 Explanation\n\n- The subquery selects the `age` of patients who received therapy from both clinics.\n- `UNION ALL` is used to combine the results from both tables, preserving all rows (including duplicates if any).\n- The outer query calculates the **average** of the combined `age` values.\n\n---\n\n### \ud83d\udccc Result (Based on Sample Data)\n\nFrom the sample data:\n\n- `clinic_a` (therapy = true): ages 35, 42\n- `clinic_b` (therapy = true): ages 50, 45\n\nAverage = (35 + 42 + 50 + 45) / 4 = **43**.", "latency_sec": 7.165217161178589, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 205, "prompt_eval_sec": null, "tokens_completion": 1099, "completion_eval_sec": null, "tokens_total": 1304, "tokens_per_sec": 181.9902971071303, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average age of patients who received therapy from both clinics. The only difference is the alias name of the subquery ('combined_clinics' vs 'combined_patients'), which does not affect the result. The UNION ALL operator combines all matching rows, and the AVG(age) function computes the same value in both cases.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the average age of patients who received therapy in clinic_a and clinic_b. They use identical logic: filtering therapy_received=true in both clinics, combining results with UNION ALL, and averaging the ages. The only difference is the subquery alias name ('combined_clinics' vs 'combined_patients'), which has no impact on results. Both queries are equally efficient and semantically equivalent. The business intent is fully addressed by including patients from both clinics and applying the therapy filter.", "overall_assessment": "correct"}}
{"example_id": 3704, "sql_complexity": "aggregation", "prompt": "What is the total sales revenue for each category of garments in the South America region in Q1 2022?", "context": "CREATE TABLE sales_category (sale_id INT, garment_category VARCHAR(50), sale_date DATE, total_sales DECIMAL(10, 2), region VARCHAR(50));", "reference_sql": "SELECT garment_category, SUM(total_sales) FROM sales_category WHERE sale_date BETWEEN '2022-01-01' AND '2022-03-31' AND region = 'South America' GROUP BY garment_category;", "generated_sql": "SELECT garment_category, SUM(total_sales) AS total_revenue\nFROM sales_category\nWHERE region = 'South America'\n  AND sale_date BETWEEN '2022-01-01' AND '2022-03-31'\nGROUP BY garment_category;", "raw_model_output": "\n\nSELECT garment_category, SUM(total_sales) AS total_revenue\nFROM sales_category\nWHERE region = 'South America'\n  AND sale_date BETWEEN '2022-01-01' AND '2022-03-31'\nGROUP BY garment_category;", "latency_sec": 3.8199501037597656, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 132, "prompt_eval_sec": null, "tokens_completion": 592, "completion_eval_sec": null, "tokens_total": 724, "tokens_per_sec": 189.5312714392282, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (garment_category and SUM(total_sales)), apply identical WHERE conditions (region = 'South America' and sale_date between '2022-01-01' and '2022-03-31'), and group by the same column (garment_category). The generated query adds an alias (total_revenue) for the aggregated column, which does not affect the semantic result content.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically equivalent as they produce identical results through the same logic: filtering sales data for South America in Q1 2022 and aggregating total sales by garment category. The generated query improves upon the reference by adding an explicit alias ('total_revenue') for the aggregated column, enhancing readability and aligning more closely with the business terminology ('revenue' vs. 'total_sales'). This makes the generated query more semantically clear while maintaining full functionality. Both queries fulfill the business intent, but the generated version is slightly more elegant and user-friendly.", "overall_assessment": "correct"}}
{"example_id": 2851, "sql_complexity": "single join", "prompt": "How many cases were handled by attorneys who joined the firm in 2015 or later?", "context": "CREATE TABLE attorneys (attorney_id INT, join_year INT); CREATE TABLE cases (case_id INT, attorney_id INT, billing_amount INT);", "reference_sql": "SELECT COUNT(DISTINCT cases.case_id) FROM cases INNER JOIN attorneys ON cases.attorney_id = attorneys.attorney_id WHERE attorneys.join_year >= 2015;", "generated_sql": "SELECT COUNT(*) \nFROM cases c \nJOIN attorneys a ON c.attorney_id = a.attorney_id \nWHERE a.join_year >= 2015;", "raw_model_output": "\n\nTo determine how many cases were handled by attorneys who joined the firm in 2015 or later, we need to:\n\n1. **Join** the `cases` table with the `attorneys` table using the `attorney_id` field.\n2. **Filter** the joined result to include only those attorneys who joined in 2015 or later (`join_year >= 2015`).\n3. **Count** the number of cases in the filtered result.\n\nThis approach ensures that we are only counting cases associated with attorneys who meet the specified join year condition.\n\n---\n\n### \u2705 Final SQL Statement\n\n```sql\nSELECT COUNT(*) \nFROM cases c \nJOIN attorneys a ON c.attorney_id = a.attorney_id \nWHERE a.join_year >= 2015;\n```\n\nThis query is efficient, uses standard ANSI SQL, and adheres strictly to the schema provided.", "latency_sec": 4.913515090942383, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 119, "prompt_eval_sec": null, "tokens_completion": 755, "completion_eval_sec": null, "tokens_total": 874, "tokens_per_sec": 177.87673057342172, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query uses COUNT(DISTINCT cases.case_id) to count unique case IDs, while the generated query uses COUNT(*) which counts all rows in the joined result. If multiple entries in 'cases' share the same case_id (e.g., multiple attorneys per case), the generated query would overcount. The semantic difference lies in handling duplicates.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries differ in their aggregation approach. The reference query uses COUNT(DISTINCT cases.case_id) which ensures each case is counted only once, even if multiple attorneys handled it. The generated query uses COUNT(*), which would overcount cases involving multiple attorneys from 2015 or later. While both correctly filter attorneys joining in 2015 or later, the reference query better addresses the business intent of counting unique cases. The generated query might produce higher numbers if cases have multiple attorneys, making it less accurate for the original question.", "overall_assessment": "differently_correct"}}
{"example_id": 3246, "sql_complexity": "single join", "prompt": "What is the average eco-friendliness score of accommodations in Oceania by year?", "context": "CREATE TABLE Accommodations (Accommodation_ID INT, Accommodation_Name VARCHAR(50), City VARCHAR(30), Country VARCHAR(50), Eco_Friendliness_Score INT, Visit_Year INT); INSERT INTO Accommodations (Accommodation_ID, Accommodation_Name, City, Country, Eco_Friendliness_Score, Visit_Year) VALUES (1, 'EcoLodge', 'Sydney', 'Australia', 85, 2019), (2, 'GreenHotel', 'Melbourne', 'Australia', 90, 2019), (3, 'SustainableResort', 'Auckland', 'New Zealand', 80, 2019), (4, 'EcoVilla', 'Wellington', 'New Zealand', 88, 2019); CREATE TABLE Countries (Country VARCHAR(50), Continent VARCHAR(30)); INSERT INTO Countries (Country, Continent) VALUES ('Australia', 'Oceania'), ('New Zealand', 'Oceania');", "reference_sql": "SELECT C.Continent, V.Visit_Year, AVG(A.Eco_Friendliness_Score) AS Avg_Eco_Score  FROM Accommodations A  JOIN Countries C  ON A.Country = C.Country  WHERE C.Continent = 'Oceania'  GROUP BY C.Continent, V.Visit_Year  ORDER BY V.Visit_Year;", "generated_sql": "SELECT a.Visit_Year, AVG(a.Eco_Friendliness_Score) AS Average_Eco_Score\nFROM Accommodations a\nJOIN Countries c ON a.Country = c.Country\nWHERE c.Continent = 'Oceania'\nGROUP BY a.Visit_Year;", "raw_model_output": "\n\nSELECT a.Visit_Year, AVG(a.Eco_Friendliness_Score) AS Average_Eco_Score\nFROM Accommodations a\nJOIN Countries c ON a.Country = c.Country\nWHERE c.Continent = 'Oceania'\nGROUP BY a.Visit_Year;", "latency_sec": 2.3681800365448, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 310, "prompt_eval_sec": null, "tokens_completion": 362, "completion_eval_sec": null, "tokens_total": 672, "tokens_per_sec": 283.76220964198956, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL includes 'Continent' in both the SELECT and GROUP BY clauses, while the Generated SQL omits 'Continent'. Although the WHERE clause restricts to 'Oceania', the GROUP BY in the Reference ensures explicit grouping by Continent and Visit_Year, whereas the Generated SQL only groups by Visit_Year. This difference in column selection and grouping logic makes the result sets structurally different (different columns), even if the numerical results for Visit_Year and Avg_Eco_Score might overlap.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because the reference query includes 'Continent' in both SELECT and GROUP BY clauses, while the generated query omits it. Since the WHERE clause explicitly filters for 'Oceania', the Continent column is redundant in the output. Both queries correctly calculate the average eco-friendliness score by year, but the generated query is more efficient by avoiding unnecessary columns and grouping. The generated query better fulfills the business intent by focusing only on the required 'Visit_Year' and average score, while the reference query includes extraneous data.", "overall_assessment": "differently_correct"}}
{"example_id": 3056, "sql_complexity": "multiple_joins", "prompt": "Identify all suppliers who provide non-GMO ingredients to restaurants with Michelin stars.", "context": "CREATE TABLE Suppliers (id INT, name VARCHAR(50), isNonGMO BOOLEAN); CREATE TABLE Restaurants (id INT, name VARCHAR(50), numStars INT); CREATE TABLE Ingredients (supplierId INT, restaurantId INT, isNonGMO BOOLEAN);", "reference_sql": "SELECT Suppliers.name FROM Suppliers INNER JOIN Ingredients ON Suppliers.id = Ingredients.supplierId INNER JOIN Restaurants ON Ingredients.restaurantId = Restaurants.id WHERE Restaurants.numStars > 2 AND Ingredients.isNonGMO = TRUE;", "generated_sql": "SELECT DISTINCT s.name\nFROM Suppliers s\nJOIN Ingredients i ON s.id = i.supplierId\nJOIN Restaurants r ON i.restaurantId = r.id\nWHERE i.isNonGMO = TRUE AND r.numStars > 0;", "raw_model_output": "\n\nSELECT DISTINCT s.name\nFROM Suppliers s\nJOIN Ingredients i ON s.id = i.supplierId\nJOIN Restaurants r ON i.restaurantId = r.id\nWHERE i.isNonGMO = TRUE AND r.numStars > 0;", "latency_sec": 4.417702913284302, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 141, "prompt_eval_sec": null, "tokens_completion": 689, "completion_eval_sec": null, "tokens_total": 830, "tokens_per_sec": 187.88044743890302, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Reference SQL uses 'Restaurants.numStars > 2' while the Generated SQL uses 'r.numStars > 0' (different threshold). Second, the Generated SQL includes 'DISTINCT' which the Reference SQL lacks, potentially eliminating duplicates. These differences in filtering conditions and result deduplication make the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries differ in two critical aspects. 1) The Reference query filters for restaurants with more than 2 stars (numStars > 2), while the Generated query filters for restaurants with any stars (numStars > 0).  The original question refers to 'Michelin stars' which typically implies any star rating (1, 2, or 3), making the Generated query's condition more appropriate. 2) The Generated query uses DISTINCT to avoid duplicate supplier names, which is more likely to be the desired outcome when 'identifying all suppliers'.  While both queries correctly join the tables and filter for non-GMO ingredients, the Reference query's stricter star rating condition and lack of DISTINCT clause make it less suitable for the original question.", "overall_assessment": "differently_correct"}}
{"example_id": 264, "sql_complexity": "set operations", "prompt": "List the number of community health centers and infectious disease tracking facilities in 'southwest' regions.", "context": "CREATE TABLE centers (id INT, name TEXT, region TEXT); INSERT INTO centers (id, name, region) VALUES (1, 'Center A', 'southwest'); INSERT INTO centers (id, name, region) VALUES (2, 'Center B', 'northeast'); INSERT INTO centers (id, name, region) VALUES (3, 'Center C', 'northwest'); CREATE TABLE diseases (id INT, name TEXT, region TEXT); INSERT INTO diseases (id, name, region) VALUES (1, 'Disease A', 'southwest'); INSERT INTO diseases (id, name, region) VALUES (2, 'Disease B', 'southeast');", "reference_sql": "SELECT COUNT(*) FROM ( (SELECT * FROM centers WHERE region = 'southwest') UNION (SELECT * FROM diseases WHERE region = 'southwest') );", "generated_sql": "SELECT \n    (SELECT COUNT(*) FROM centers WHERE region = 'southwest') AS community_health_centers,\n    (SELECT COUNT(*) FROM diseases WHERE region = 'southwest') AS infectious_disease_facilities;", "raw_model_output": "\n\nSELECT \n    (SELECT COUNT(*) FROM centers WHERE region = 'southwest') AS community_health_centers,\n    (SELECT COUNT(*) FROM diseases WHERE region = 'southwest') AS infectious_disease_facilities;", "latency_sec": 3.0948421955108643, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 228, "prompt_eval_sec": null, "tokens_completion": 478, "completion_eval_sec": null, "tokens_total": 706, "tokens_per_sec": 228.12148581406456, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns a single count of all unique rows from both tables where region = 'southwest', while the Generated SQL returns two separate counts (one for centers and one for diseases). The output structure and values differ: the first produces a single number (e.g., 2 in the sample data), while the second produces two numbers (e.g., 1 and 1).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL combines centers and diseases into a single count using UNION, which would merge rows from both tables and count them as one total. This violates the original question's requirement for separate counts of community health centers and infectious disease facilities. The Generated SQL correctly uses two independent subqueries to produce separate counts for each facility type, aligning with the business intent. While both queries are technically valid, the Generated SQL directly addresses the dual-count requirement, making it more appropriate for the task.", "overall_assessment": "differently_correct"}}
{"example_id": 2838, "sql_complexity": "basic SQL", "prompt": "What is the minimum safety rating of electric vehicles in the 'green_cars' table?", "context": "CREATE TABLE green_cars (id INT, make VARCHAR(50), model VARCHAR(50), type VARCHAR(50), safety_rating INT);", "reference_sql": "SELECT MIN(safety_rating) FROM green_cars WHERE type = 'Electric';", "generated_sql": "SELECT MIN(safety_rating) FROM green_cars WHERE type = 'electric';", "raw_model_output": "\n\nSELECT MIN(safety_rating) FROM green_cars WHERE type = 'electric';", "latency_sec": 2.1727890968322754, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 119, "prompt_eval_sec": null, "tokens_completion": 326, "completion_eval_sec": null, "tokens_total": 445, "tokens_per_sec": 204.80588780971362, "match_exact": true, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the case of the string literal in the WHERE clause ('Electric' vs. 'electric'). While the intent is similar, SQL string comparisons are case-sensitive by default in many databases (e.g., PostgreSQL), so the two queries may not return the same result if the data contains mixed casing. Without explicit case-insensitive collation settings, the queries are not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in the case of the string literal ('Electric' vs 'electric'). While both would return the same result in case-insensitive databases, they are not technically equivalent in case-sensitive systems. The original question implies the data might use standardized casing (e.g., 'Electric' as a category), making the reference query more likely to match actual data. The generated query risks returning incorrect results if the database enforces case sensitivity, failing to fulfill the business intent. Both queries are equally efficient, but the reference better aligns with potential data conventions.", "overall_assessment": "differently_correct"}}
{"example_id": 1187, "sql_complexity": "multiple_joins", "prompt": "Who are the top 3 authors with the highest number of articles published in The Guardian?", "context": "CREATE TABLE authors (id INT, name VARCHAR(100), publisher VARCHAR(50)); CREATE TABLE articles_authors (article_id INT, author_id INT); INSERT INTO authors (id, name, publisher) VALUES (1, 'Author1', 'The Guardian'), (2, 'Author2', 'The Guardian'), (3, 'Author3', 'The Guardian'); INSERT INTO articles_authors (article_id, author_id) VALUES (1, 1), (2, 2), (3, 1), (3, 2), (3, 3); INSERT INTO articles (id, title, publication_date, publisher) VALUES (1, 'Article1', '2021-01-01', 'The Guardian'), (2, 'Article2', '2021-01-02', 'The Guardian'), (3, 'Article3', '2021-01-03', 'The Guardian');", "reference_sql": "SELECT a.name, COUNT(aa.article_id) AS articles_count FROM authors a JOIN articles_authors aa ON a.id = aa.author_id JOIN articles ar ON aa.article_id = ar.id WHERE ar.publisher = 'The Guardian' GROUP BY a.name ORDER BY articles_count DESC LIMIT 3;", "generated_sql": "SELECT authors.name, COUNT(*) AS num_articles\nFROM authors\nJOIN articles_authors ON authors.id = articles_authors.author_id\nJOIN articles ON articles_authors.article_id = articles.id\nWHERE articles.publisher = 'The Guardian'\nGROUP BY authors.id\nORDER BY num_articles DESC\nLIMIT 3;", "raw_model_output": "\n\n```sql\nSELECT authors.name, COUNT(*) AS num_articles\nFROM authors\nJOIN articles_authors ON authors.id = articles_authors.author_id\nJOIN articles ON articles_authors.article_id = articles.id\nWHERE articles.publisher = 'The Guardian'\nGROUP BY authors.id\nORDER BY num_articles DESC\nLIMIT 3;\n```", "latency_sec": 10.28513479232788, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 292, "prompt_eval_sec": null, "tokens_completion": 977, "completion_eval_sec": null, "tokens_total": 1269, "tokens_per_sec": 123.3819512940755, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same data by joining authors with their articles via articles_authors, filtering by 'The Guardian'. The Reference SQL groups by a.name (which is unique in the sample data) while the Generated SQL groups by authors.id (the primary key). Since the sample data ensures unique names, both grouping strategies yield identical results. Additionally, COUNT(*) and COUNT(aa.article_id) are equivalent in this context due to the one-to-many relationship between authors and articles_authors. The ORDER BY and LIMIT clauses also match.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify the top 3 authors by article count in The Guardian. The Reference SQL groups by a.name, which works in this context due to unique author names in the sample data. The Generated SQL groups by authors.id, which is more technically robust as it uses the primary key for aggregation. While both produce identical results here, the Generated SQL is superior because grouping by ID ensures correctness in cases of duplicate names and aligns with proper relational database practices.", "overall_assessment": "correct"}}
{"example_id": 360, "sql_complexity": "window functions", "prompt": "What is the change in crime rate for each category, between this year and last year, for the same time period?", "context": "CREATE TABLE CrimeStatistics (ID INT, CrimeType VARCHAR(50), Date TIMESTAMP, Count INT); INSERT INTO CrimeStatistics (ID, CrimeType, Date, Count) VALUES (1, 'Theft', '2022-01-01 00:00:00', 100), (2, 'Vandalism', '2022-01-01 00:00:00', 50), (3, 'Theft', '2022-01-02 00:00:00', 120), (4, 'Vandalism', '2022-01-02 00:00:00', 60), (5, 'Theft', '2021-01-01 00:00:00', 80), (6, 'Vandalism', '2021-01-01 00:00:00', 40), (7, 'Theft', '2021-01-02 00:00:00', 90), (8, 'Vandalism', '2021-01-02 00:00:00', 45);", "reference_sql": "SELECT CrimeType, (SUM(Count) OVER (PARTITION BY CrimeType ORDER BY EXTRACT(YEAR FROM Date) ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)) - SUM(Count) OVER (PARTITION BY CrimeType ORDER BY EXTRACT(YEAR FROM Date)) AS CrimeRateChange FROM CrimeStatistics WHERE Date BETWEEN DATE_TRUNC('year', CURRENT_DATE - INTERVAL '1 year') AND CURRENT_DATE;", "generated_sql": "SELECT \n    CrimeType,\n    SUM(CASE WHEN EXTRACT(YEAR FROM Date) = 2022 THEN Count ELSE 0 END) - SUM(CASE WHEN EXTRACT(YEAR FROM Date) = 2021 THEN Count ELSE 0 END) AS Change\nFROM CrimeStatistics\nGROUP BY CrimeType;", "raw_model_output": "\n\nSELECT \n    CrimeType,\n    SUM(CASE WHEN EXTRACT(YEAR FROM Date) = 2022 THEN Count ELSE 0 END) - SUM(CASE WHEN EXTRACT(YEAR FROM Date) = 2021 THEN Count ELSE 0 END) AS Change\nFROM CrimeStatistics\nGROUP BY CrimeType;", "latency_sec": 15.769647121429443, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 392, "prompt_eval_sec": null, "tokens_completion": 1996, "completion_eval_sec": null, "tokens_total": 2388, "tokens_per_sec": 151.4301481581624, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in logic and data scope. The Reference SQL uses window functions to calculate a year-over-year change based on ordered rows, while the Generated SQL directly computes the difference between sums of specific years (2021 and 2022). Additionally, the Reference SQL's WHERE clause filters dates to a dynamic range (e.g., last year's data), whereas the Generated SQL explicitly targets fixed years. The window function approach in the Reference SQL may also produce different results due to cumulative sums and row ordering, leading to non-equivalent outputs.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL has multiple issues: 1) The WHERE clause filters dates between the start of last year and now, which may include partial years and not strictly compare 'same time period' 2) The window function logic is flawed - EXTRACT(YEAR FROM Date) ordering doesn't ensure proper year comparison, and the ROWS BETWEEN 1 PRECEDING clause doesn't correctly capture previous year's data. The Generated SQL directly compares total counts for 2022 vs 2021 for each crime type, which aligns with the business intent of measuring year-over-year change. While both queries could produce similar results for the sample data, the Generated SQL is more precise, efficient, and semantically clearer for the stated question.", "overall_assessment": "differently_correct"}}
{"example_id": 335, "sql_complexity": "single join", "prompt": "List the policy numbers, claim amounts, and claim dates for policies that have more than two claims and the total claim amount exceeds $5000", "context": "CREATE TABLE policies (policy_number INT);CREATE TABLE claims (claim_id INT, policy_number INT, claim_amount DECIMAL(10,2), claim_date DATE);", "reference_sql": "SELECT p.policy_number, c.claim_amount, c.claim_date FROM policies p INNER JOIN claims c ON p.policy_number = c.policy_number GROUP BY p.policy_number, c.claim_amount, c.claim_date HAVING COUNT(c.claim_id) > 2 AND SUM(c.claim_amount) > 5000;", "generated_sql": "SELECT c.policy_number, c.claim_amount, c.claim_date\nFROM claims c\nWHERE c.policy_number IN (\n    SELECT policy_number\n    FROM claims\n    GROUP BY policy_number\n    HAVING COUNT(*) > 2 AND SUM(claim_amount) > 5000\n);", "raw_model_output": "\n\n```sql\nSELECT c.policy_number, c.claim_amount, c.claim_date\nFROM claims c\nWHERE c.policy_number IN (\n    SELECT policy_number\n    FROM claims\n    GROUP BY policy_number\n    HAVING COUNT(*) > 2 AND SUM(claim_amount) > 5000\n);\n```", "latency_sec": 4.4953389167785645, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 135, "prompt_eval_sec": null, "tokens_completion": 675, "completion_eval_sec": null, "tokens_total": 810, "tokens_per_sec": 180.18663664639988, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query groups by policy_number, claim_amount, and claim_date, returning unique combinations where the policy has >2 claims and total claim_amount >5000. The generated query returns all claims for policies that meet the HAVING conditions, resulting in potentially more rows. Additionally, the reference query uses an INNER JOIN with policies (which could filter out policies with no claims, though the generated query's subquery also implicitly requires claims). The grouping logic and output structure differ.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL is technically incorrect because it groups by claim_amount and claim_date, which would incorrectly aggregate claims with identical values. This leads to flawed HAVING clause calculations (e.g., counting per-claim groups instead of per-policy totals). The Generated SQL correctly identifies policies meeting the criteria via a subquery (GROUP BY policy_number HAVING COUNT(*) > 2 AND SUM(...) > 5000) and then retrieves all claims for those policies. While both queries aim to answer the question, only the Generated SQL properly addresses the business intent by first filtering policies and then returning their claims.", "overall_assessment": "differently_correct"}}
{"example_id": 2866, "sql_complexity": "basic SQL", "prompt": "What is the number of hospitals in 'rural_healthcare' table?", "context": "CREATE TABLE rural_healthcare (name VARCHAR(255), type VARCHAR(255), location VARCHAR(255)); INSERT INTO rural_healthcare (name, type, location) VALUES ('Rural General Hospital', 'Hospital', 'Bushland'), ('Rural Community Hospital', 'Hospital', 'Forest Region');", "reference_sql": "SELECT COUNT(*) FROM rural_healthcare WHERE type = 'Hospital';", "generated_sql": "SELECT COUNT(*) FROM rural_healthcare WHERE type = 'Hospital';", "raw_model_output": "\n\nSELECT COUNT(*) FROM rural_healthcare WHERE type = 'Hospital';", "latency_sec": 1.5531299114227295, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 151, "prompt_eval_sec": null, "tokens_completion": 228, "completion_eval_sec": null, "tokens_total": 379, "tokens_per_sec": 244.023373197945, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They both count all rows in the 'rural_healthcare' table where the 'type' column equals 'Hospital'. Since the SQL statements are exactly the same, they will produce identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure, logic, and implementation. They both count rows in the 'rural_healthcare' table where the 'type' column equals 'Hospital', which directly answers the question about the number of hospitals. The queries are syntactically correct, semantically equivalent, and equally efficient. Since they are identical, neither is superior to the other.", "overall_assessment": "correct"}}
{"example_id": 4440, "sql_complexity": "multiple_joins", "prompt": "What is the average session length for each game genre in the last month, sorted by average session length.", "context": "CREATE TABLE game_sessions(id INT, user_id INT, game_name VARCHAR(50), start_time DATETIME, end_time DATETIME); CREATE TABLE games(id INT, name VARCHAR(50), genre VARCHAR(50));", "reference_sql": "SELECT genres.genre, AVG(TIMESTAMPDIFF(SECOND, start_time, end_time)) as avg_session_length FROM game_sessions JOIN games ON game_sessions.game_name = games.name JOIN (SELECT DISTINCT game_name, genre FROM game_sessions JOIN games ON game_sessions.game_name = games.name) genres ON games.name = genres.game_name WHERE start_time >= DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH) GROUP BY genres.genre ORDER BY avg_session_length DESC;", "generated_sql": "SELECT g.genre, AVG(EXTRACT(EPOCH FROM (gs.end_time - gs.start_time))) AS avg_session_length\nFROM game_sessions gs\nJOIN games g ON gs.game_name = g.name\nWHERE gs.start_time >= CURRENT_DATE - INTERVAL '1 month'\nGROUP BY g.genre\nORDER BY avg_session_length;", "raw_model_output": "\n\nSELECT g.genre, AVG(EXTRACT(EPOCH FROM (gs.end_time - gs.start_time))) AS avg_session_length\nFROM game_sessions gs\nJOIN games g ON gs.game_name = g.name\nWHERE gs.start_time >= CURRENT_DATE - INTERVAL '1 month'\nGROUP BY g.genre\nORDER BY avg_session_length;", "latency_sec": 7.983104944229126, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 137, "prompt_eval_sec": null, "tokens_completion": 1243, "completion_eval_sec": null, "tokens_total": 1380, "tokens_per_sec": 172.86507062613308, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the ORDER BY clause (DESC vs. no DESC) and the method of calculating session length (TIMESTAMPDIFF vs. EXTRACT(EPOCH)). The Reference query also includes an unnecessary subquery that could affect results if duplicates exist, but the primary discrepancy is the sorting order, which makes the results not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "While both queries aim to calculate average session lengths per genre, they differ in implementation. The Reference query uses a redundant subquery with DISTINCT that's unnecessary given the schema's one-to-one game-to-genre relationship. The Generated query simplifies the logic by directly joining tables without intermediate steps. The date calculation syntax differs (DATE_SUB vs. INTERVAL '1 month') but achieves the same result. The Generated query is more efficient due to simpler structure and avoids potential performance issues from the subquery. Both correctly address the business intent, but the Generated version is technically superior due to its elegance and efficiency.", "overall_assessment": "differently_correct"}}
{"example_id": 451, "sql_complexity": "single join", "prompt": "Which customers have made a transaction over 500 in the \"risk_management\" category?", "context": "CREATE TABLE customers (id INT, name VARCHAR(50), category VARCHAR(50)); INSERT INTO customers (id, name, category) VALUES (1, 'John Doe', 'risk_management'); INSERT INTO customers (id, name, category) VALUES (2, 'Jane Smith', 'compliance'); INSERT INTO customers (id, name, category) VALUES (3, 'Jim Brown', 'risk_management'); CREATE TABLE transactions (id INT, customer_id INT, amount DECIMAL(10, 2)); INSERT INTO transactions (id, customer_id, amount) VALUES (1, 1, 500.00); INSERT INTO transactions (id, customer_id, amount) VALUES (2, 1, 200.00); INSERT INTO transactions (id, customer_id, amount) VALUES (3, 2, 100.00); INSERT INTO transactions (id, customer_id, amount) VALUES (4, 3, 750.00);", "reference_sql": "SELECT c.name FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE c.category = 'risk_management' AND t.amount > 500;", "generated_sql": "SELECT DISTINCT customers.name\nFROM customers\nJOIN transactions ON customers.id = transactions.customer_id\nWHERE customers.category = 'risk_management'\n  AND transactions.amount > 500;", "raw_model_output": "\n\nSELECT DISTINCT customers.name\nFROM customers\nJOIN transactions ON customers.id = transactions.customer_id\nWHERE customers.category = 'risk_management'\n  AND transactions.amount > 500;", "latency_sec": 8.744418144226074, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 299, "prompt_eval_sec": null, "tokens_completion": 908, "completion_eval_sec": null, "tokens_total": 1207, "tokens_per_sec": 138.0309107012432, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Generated SQL includes DISTINCT which ensures unique names, while the Reference SQL may return duplicate names if a customer has multiple qualifying transactions. Though the sample data shows identical results, semantically they differ in handling duplicates.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query may return duplicate customer names if a customer has multiple transactions over 500, while the generated query uses DISTINCT to ensure unique customer names. Both correctly filter for 'risk_management' category and transactions > 500, but the generated query better fulfills the business intent of identifying customers (not transactions) by avoiding duplicates. The generated query is more elegant due to explicit DISTINCT usage, though both are efficient.", "overall_assessment": "differently_correct"}}
{"example_id": 2879, "sql_complexity": "basic SQL", "prompt": "Update the FoodSafetyRecords.OrganicFarms table to include a new record for a certified organic farm in Kenya.", "context": "CREATE TABLE FoodSafetyRecords.OrganicFarms (farmName TEXT, country TEXT, certified BOOLEAN);", "reference_sql": "INSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('Ngong Organic Farm', 'Kenya', TRUE);", "generated_sql": "INSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('New Organic Farm', 'Kenya', TRUE);", "raw_model_output": "\n\nINSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('New Organic Farm', 'Kenya', TRUE);", "latency_sec": 4.342813968658447, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 115, "prompt_eval_sec": null, "tokens_completion": 681, "completion_eval_sec": null, "tokens_total": 796, "tokens_per_sec": 183.29129586130878, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The two queries differ in the farmName value being inserted ('Ngong Organic Farm' vs 'New Organic Farm'). While the structure and other values are identical, the distinct farm names result in different data being inserted, making them semantically non-equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly insert a new certified organic farm record into the OrganicFarms table with identical structure and values (Kenya, TRUE). The only difference is the farmName value ('Ngong Organic Farm' vs 'New Organic Farm'). Since the original question did not specify particular farm details beyond being certified in Kenya, both queries technically fulfill the requirement. The difference in farm names does not affect technical correctness or business intent fulfillment. Neither query is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 5688, "sql_complexity": "single join", "prompt": "What is the total amount donated to a specific cause?", "context": "CREATE TABLE causes (id INT, name TEXT); CREATE TABLE donations (id INT, donor_id INT, cause_id INT, donation_amount DECIMAL(10,2)); INSERT INTO causes (id, name) VALUES (1, 'Cause A'), (2, 'Cause B'); INSERT INTO donations (id, donor_id, cause_id, donation_amount) VALUES (1, 1, 1, 50.00), (2, 2, 1, 100.00);", "reference_sql": "SELECT SUM(donation_amount) FROM donations JOIN causes ON donations.cause_id = causes.id WHERE causes.name = 'Cause A';", "generated_sql": "SELECT SUM(donation_amount) FROM donations WHERE cause_id = 1;", "raw_model_output": "\n\nSELECT SUM(donation_amount) FROM donations WHERE cause_id = 1;", "latency_sec": 9.70983624458313, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 188, "prompt_eval_sec": null, "tokens_completion": 1387, "completion_eval_sec": null, "tokens_total": 1575, "tokens_per_sec": 162.2066490440199, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the total donations for 'Cause A'. The Reference SQL uses a JOIN to filter by cause name, while the Generated SQL directly uses the known cause_id (1) corresponding to 'Cause A'. Since the data shows cause_id 1 maps to 'Cause A', both queries sum the same donations (50 + 100 = 150).", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the total donations for a specific cause. The reference query uses a JOIN with the causes table to filter by name ('Cause A'), while the generated query directly filters by cause_id = 1. They produce identical results when 'Cause A' corresponds to cause_id 1. The generated query is more efficient as it avoids a JOIN operation, directly accessing the donations table. However, the reference query is more readable if the cause name is the primary identifier. The generated query better fulfills the business intent by directly using the cause_id, which is more stable and avoids potential issues with name spelling/case sensitivity.", "overall_assessment": "correct"}}
{"example_id": 3273, "sql_complexity": "multiple_joins", "prompt": "List all departments, the number of chemicals they handle, and the number of machines used in their manufacturing processes.", "context": "CREATE TABLE Departments (DepartmentID INT, DepartmentName VARCHAR(20)); INSERT INTO Departments (DepartmentID, DepartmentName) VALUES (1, 'Manufacturing'), (2, 'Engineering'), (3, 'Chemical Safety'), (4, 'Product Development'); CREATE TABLE Chemicals (ChemicalID INT, ChemicalName VARCHAR(20), DepartmentID INT); INSERT INTO Chemicals (ChemicalID, ChemicalName, DepartmentID) VALUES (1, 'Hydrochloric Acid', 1), (2, 'Nitric Acid', 2), (3, 'Sodium Hydroxide', 3), (4, 'New Chemical', 4); CREATE TABLE Machinery (MachineID INT, MachineName VARCHAR(20), DepartmentID INT); INSERT INTO Machinery (MachineID, MachineName, DepartmentID) VALUES (1, 'Mixer 1', 1), (2, 'Cutter 2', 2), (3, 'Dispenser 3', 3), (4, 'Innovator 4', 4);", "reference_sql": "SELECT D.DepartmentName, COUNT(C.ChemicalID) AS ChemicalCount, COUNT(M.MachineID) AS MachineCount FROM Departments D LEFT JOIN Chemicals C ON D.DepartmentID = C.DepartmentID LEFT JOIN Machinery M ON D.DepartmentID = M.DepartmentID GROUP BY D.DepartmentName;", "generated_sql": "SELECT \n    d.DepartmentID,\n    d.DepartmentName,\n    (SELECT COUNT(*) FROM Chemicals WHERE DepartmentID = d.DepartmentID) AS ChemicalCount,\n    (SELECT COUNT(*) FROM Machinery WHERE DepartmentID = d.DepartmentID) AS MachineCount\nFROM Departments d;", "raw_model_output": "\n\nSELECT \n    d.DepartmentID,\n    d.DepartmentName,\n    (SELECT COUNT(*) FROM Chemicals WHERE DepartmentID = d.DepartmentID) AS ChemicalCount,\n    (SELECT COUNT(*) FROM Machinery WHERE DepartmentID = d.DepartmentID) AS MachineCount\nFROM Departments d;", "latency_sec": 17.64849066734314, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 312, "prompt_eval_sec": null, "tokens_completion": 2740, "completion_eval_sec": null, "tokens_total": 3052, "tokens_per_sec": 172.93263529030486, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their output columns. The Reference SQL returns only DepartmentName, ChemicalCount, and MachineCount, while the Generated SQL includes DepartmentID as an additional column. Additionally, the Reference SQL groups by DepartmentName (though the data has unique names), whereas the Generated SQL uses correlated subqueries. The presence of an extra column in the Generated SQL makes the result sets structurally different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The Reference SQL groups by DepartmentName, which could fail if multiple departments share the same name (not enforced as unique in schema). The Generated SQL uses DepartmentID in subqueries, ensuring accurate counts regardless of name uniqueness. Both fulfill the business intent, but the Generated SQL is more robust. The Reference might produce incorrect results in edge cases, while the Generated SQL explicitly correlates counts to departments via DepartmentID, making it more reliable. Efficiency-wise, the Generated SQL avoids potential Cartesian products from multiple joins.", "overall_assessment": "differently_correct"}}
{"example_id": 1895, "sql_complexity": "window functions", "prompt": "What is the average safety score of chemical production sites in the United States, partitioned by state and ranked in descending order?", "context": "CREATE TABLE production_sites (site_id INT, site_name TEXT, country TEXT, state TEXT, safety_score FLOAT); INSERT INTO production_sites (site_id, site_name, country, state, safety_score) VALUES (1, 'Site A', 'USA', 'NY', 92.5), (2, 'Site B', 'USA', 'CA', 87.4), (3, 'Site C', 'USA', 'TX', 95.3), (4, 'Site D', 'USA', 'FL', 89.2);", "reference_sql": "SELECT state, AVG(safety_score) as avg_safety_score, ROW_NUMBER() OVER (ORDER BY AVG(safety_score) DESC) as rank FROM production_sites WHERE country = 'USA' GROUP BY state ORDER BY rank;", "generated_sql": "SELECT state, AVG(safety_score) AS average_safety_score\nFROM production_sites\nWHERE country = 'USA'\nGROUP BY state\nORDER BY average_safety_score DESC;", "raw_model_output": "\n\nSELECT state, AVG(safety_score) AS average_safety_score\nFROM production_sites\nWHERE country = 'USA'\nGROUP BY state\nORDER BY average_safety_score DESC;", "latency_sec": 12.202217817306519, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 213, "prompt_eval_sec": null, "tokens_completion": 1149, "completion_eval_sec": null, "tokens_total": 1362, "tokens_per_sec": 111.61905322393629, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL includes an additional 'rank' column generated by the ROW_NUMBER() window function and orders by this rank, while the Generated SQL only selects state and average safety score, ordering by the average safety score directly. The presence of the extra column and different ordering mechanism make their result sets structurally and logically distinct.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query technically addresses the ranking requirement using ROW_NUMBER() while the generated query only sorts results. However, neither is fully equivalent because the reference includes a 'rank' column not mentioned in the original question. The generated query correctly calculates averages and sorts them descending, fulfilling the core intent. The reference query's ranking is technically correct but adds an explicit rank column that wasn't explicitly requested. Both queries correctly group by state and filter USA sites.", "overall_assessment": "differently_correct"}}
{"example_id": 4669, "sql_complexity": "set operations", "prompt": "Identify the number of IoT devices in each country and the total number of devices.", "context": "CREATE TABLE device_country (device_id INT, country TEXT); INSERT INTO device_country (device_id, country) VALUES (1, 'USA'), (2, 'Canada'), (3, 'Mexico'), (4, 'Brazil'); CREATE TABLE device_info (device_id INT, device_type TEXT); INSERT INTO device_info (device_id, device_type) VALUES (1, 'Soil Sensor'), (2, 'Temperature Sensor'), (3, 'Humidity Sensor'), (4, 'Precision Sprayer');", "reference_sql": "SELECT country, COUNT(*) AS device_count FROM device_country GROUP BY country UNION SELECT 'Total' AS country, COUNT(*) FROM device_country;", "generated_sql": "SELECT country, COUNT(*) AS num_devices\nFROM device_country\nJOIN device_info ON device_country.device_id = device_info.device_id\nGROUP BY country\nUNION\nSELECT 'Total' AS country, COUNT(*) AS num_devices\nFROM device_info;", "raw_model_output": "\n\n```sql\nSELECT country, COUNT(*) AS num_devices\nFROM device_country\nJOIN device_info ON device_country.device_id = device_info.device_id\nGROUP BY country\nUNION\nSELECT 'Total' AS country, COUNT(*) AS num_devices\nFROM device_info;\n```", "latency_sec": 22.592560052871704, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 190, "prompt_eval_sec": null, "tokens_completion": 3029, "completion_eval_sec": null, "tokens_total": 3219, "tokens_per_sec": 142.48053308110332, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL counts devices from device_country for both groupings and the total, while the Generated SQL joins device_country with device_info and counts from device_info for the total. If device_info has different row counts than device_country (e.g., missing entries), the 'Total' result would differ. The group-by counts may match if all device_ids are present in both tables, but the total count source difference makes them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The Reference SQL correctly counts devices directly from the device_country table, ensuring accuracy for both per-country counts and total devices. The Generated SQL introduces an unnecessary JOIN with device_info, which could lead to discrepancies if there are devices in device_country without corresponding entries in device_info. Additionally, the Generated SQL's total count uses device_info instead of device_country, which might not align with the business requirement to count all IoT devices (assuming device_country contains the complete device list). While both queries fulfill the intent of showing country-specific counts and totals, the Reference is more technically precise and avoids potential data integrity issues.", "overall_assessment": "differently_correct"}}
{"example_id": 5302, "sql_complexity": "multiple_joins", "prompt": "Find the supplier with the lowest average delivery time for orders in the last month.", "context": "CREATE TABLE Suppliers (SupplierID int, SupplierName varchar(50)); CREATE TABLE Products (ProductID int, ProductName varchar(50), SupplierID int); CREATE TABLE Orders (OrderID int, ProductID int, OrderDate date, DeliveryTime int); INSERT INTO Suppliers VALUES (1, 'SupplierA'), (2, 'SupplierB'); INSERT INTO Products VALUES (1, 'Organic Apples', 1), (2, 'Bananas', 2); INSERT INTO Orders VALUES (1, 1, '2022-01-01', 2), (2, 2, '2022-01-03', 3);", "reference_sql": "SELECT SupplierName, AVG(DeliveryTime) as AvgDeliveryTime FROM Orders o JOIN Products p ON o.ProductID = p.ProductID JOIN Suppliers sp ON p.SupplierID = sp.SupplierID WHERE OrderDate >= DATEADD(month, -1, GETDATE()) GROUP BY SupplierName ORDER BY AvgDeliveryTime ASC;", "generated_sql": "SELECT s.SupplierName, AVG(o.DeliveryTime) AS AvgDeliveryTime\nFROM Suppliers s\nJOIN Products p ON s.SupplierID = p.SupplierID\nJOIN Orders o ON p.ProductID = o.ProductID\nWHERE o.OrderDate >= CURRENT_DATE - INTERVAL '1 month'\nGROUP BY s.SupplierID, s.SupplierName\nORDER BY AvgDeliveryTime ASC\nLIMIT 1;", "raw_model_output": "\n\nTo determine the supplier with the **lowest average delivery time** for orders placed in the **last month**, we need to:\n\n1. **Join** the `Suppliers`, `Products`, and `Orders` tables using their respective foreign key relationships.\n2. **Filter** the orders to include only those placed in the last month using a date condition.\n3. **Group** the results by supplier to calculate the average delivery time per supplier.\n4. **Order** the results by the average delivery time in ascending order.\n5. **Limit** the result to the top supplier with the lowest average delivery time.\n\n---\n\n### \u2705 Final SQL Query\n\n```sql\nSELECT s.SupplierName, AVG(o.DeliveryTime) AS AvgDeliveryTime\nFROM Suppliers s\nJOIN Products p ON s.SupplierID = p.SupplierID\nJOIN Orders o ON p.ProductID = o.ProductID\nWHERE o.OrderDate >= CURRENT_DATE - INTERVAL '1 month'\nGROUP BY s.SupplierID, s.SupplierName\nORDER BY AvgDeliveryTime ASC\nLIMIT 1;\n```\n\n---\n\n### \ud83d\udccc Notes\n\n- This query assumes the use of **ANSI SQL** and uses `CURRENT_DATE - INTERVAL '1 month'` to filter orders from the last month.\n- The `LIMIT 1` ensures that only the supplier with the **lowest average delivery time** is returned.\n- If multiple suppliers have the same lowest average, this query will return **one** of them (the first in the sorted order). If you need to handle ties, additional logic would be required.", "latency_sec": 8.13211703300476, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 230, "prompt_eval_sec": null, "tokens_completion": 1277, "completion_eval_sec": null, "tokens_total": 1507, "tokens_per_sec": 185.31459814015662, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Generated SQL includes a LIMIT 1 clause which restricts the result to a single row, while the Reference SQL returns all suppliers. Second, the GROUP BY clause in the Generated SQL uses both SupplierID and SupplierName (though SupplierID is redundant given the primary key), whereas the Reference SQL only groups by SupplierName. Additionally, the date functions (DATEADD vs CURRENT_DATE - INTERVAL) may behave differently across SQL dialects, though this is less critical than the LIMIT difference.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in several key aspects.  The Reference query returns all suppliers ordered by average delivery time, requiring additional processing to identify the supplier with the lowest average. The Generated query directly retrieves the supplier with the lowest average delivery time using LIMIT 1.  Both correctly join the necessary tables and filter for the last month, but the Generated query is more efficient and directly answers the question.  The Reference query's use of GROUP BY SupplierName could be problematic if multiple suppliers have the same name, while the Generated query's GROUP BY on SupplierID ensures uniqueness.  The date filtering is slightly different (GETDATE() vs CURRENT_DATE - INTERVAL '1 month'), but both should effectively capture the last month's data.", "overall_assessment": "differently_correct"}}
{"example_id": 267, "sql_complexity": "subqueries", "prompt": "What is the total number of disability support programs offered in urban and rural areas, and the percentage of total programs for each area type?", "context": "CREATE TABLE programs (program_id INT, program_name VARCHAR(255), area_type VARCHAR(255));", "reference_sql": "SELECT area_type, COUNT(*) as total_programs, ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM programs) , 2) as percentage_of_total FROM programs WHERE area_type IN ('urban', 'rural') GROUP BY area_type;", "generated_sql": "SELECT \n    area_type, \n    COUNT(*) AS total_programs,\n    (COUNT(*) * 100.0 / SUM(COUNT(*)) OVER()) AS percentage\nFROM programs\nWHERE area_type IN ('urban', 'rural')\nGROUP BY area_type;", "raw_model_output": "\n\nSELECT \n    area_type, \n    COUNT(*) AS total_programs,\n    (COUNT(*) * 100.0 / SUM(COUNT(*)) OVER()) AS percentage\nFROM programs\nWHERE area_type IN ('urban', 'rural')\nGROUP BY area_type;", "latency_sec": 7.525243043899536, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 121, "prompt_eval_sec": null, "tokens_completion": 1168, "completion_eval_sec": null, "tokens_total": 1289, "tokens_per_sec": 171.29014870090467, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the percentage based on the total number of programs in the entire table (including all area_types), while the Generated SQL calculates the percentage based on the sum of the filtered groups (only 'urban' and 'rural'). If there are programs with area_types other than 'urban' or 'rural', the two queries will produce different percentages. The Reference SQL's subquery counts all programs, whereas the Generated SQL's window function sums only the grouped rows.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the total programs per area type and their percentage of the total. The Reference SQL uses a correlated subquery for the total, while the Generated SQL uses a window function. Both handle the WHERE clause filtering for 'urban'/'rural' correctly. The Generated version is more efficient as it avoids a correlated subquery and uses a single aggregation pass. The percentage calculation is mathematically equivalent (COUNT(*) / SUM(COUNT(*)) OVER() vs COUNT(*) / (SELECT COUNT(*)...)). The Reference includes explicit rounding which isn't required by the question, making the Generated version slightly more elegant.", "overall_assessment": "correct"}}
{"example_id": 3028, "sql_complexity": "basic SQL", "prompt": "What is the number of startups founded by non-binary individuals in the technology industry?", "context": "CREATE TABLE company (id INT, name TEXT, founder_gender TEXT, industry TEXT); INSERT INTO company (id, name, founder_gender, industry) VALUES (1, 'CodeForAll', 'Non-binary', 'Technology'); INSERT INTO company (id, name, founder_gender, industry) VALUES (2, 'TechVillage', 'Male', 'Technology');", "reference_sql": "SELECT COUNT(*) FROM company WHERE founder_gender = 'Non-binary' AND industry = 'Technology';", "generated_sql": "SELECT COUNT(*) FROM company WHERE founder_gender = 'Non-binary' AND industry = 'Technology';", "raw_model_output": "\n\nSELECT COUNT(*) FROM company WHERE founder_gender = 'Non-binary' AND industry = 'Technology';", "latency_sec": 2.194802761077881, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 160, "prompt_eval_sec": null, "tokens_completion": 322, "completion_eval_sec": null, "tokens_total": 482, "tokens_per_sec": 219.6097109716077, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure and conditions. Both queries count companies where founder_gender is 'Non-binary' and industry is 'Technology', producing the same result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic. They correctly count companies where founder_gender is 'Non-binary' and industry is 'Technology', matching the business requirement. The WHERE clause accurately filters for non-binary founders in the technology sector. The sample data confirms the query would return 1 (from the 'CodeForAll' entry). Both queries are equally efficient, using direct column comparisons without unnecessary complexity.", "overall_assessment": "correct"}}
{"example_id": 3282, "sql_complexity": "aggregation", "prompt": "Which marine species have been observed in both the Arctic and Antarctic oceans?", "context": "CREATE TABLE marine_species (id INT, species_name VARCHAR(50), common_name VARCHAR(50), region VARCHAR(20));INSERT INTO marine_species (id, species_name, common_name, region) VALUES (1, 'Orcinus_orca', 'Killer Whale', 'Arctic');INSERT INTO marine_species (id, species_name, common_name, region) VALUES (2, 'Balaenoptera_bonaerensis', 'Antarctic Minke Whale', 'Antarctic');", "reference_sql": "SELECT species_name FROM marine_species WHERE region IN ('Arctic', 'Antarctic') GROUP BY species_name HAVING COUNT(DISTINCT region) = 2;", "generated_sql": "SELECT species_name, common_name\nFROM marine_species\nWHERE region = 'Arctic'\nINTERSECT\nSELECT species_name, common_name\nFROM marine_species\nWHERE region = 'Antarctic';", "raw_model_output": "\n\nSELECT species_name, common_name\nFROM marine_species\nWHERE region = 'Arctic'\nINTERSECT\nSELECT species_name, common_name\nFROM marine_species\nWHERE region = 'Antarctic';", "latency_sec": 10.980729103088379, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 190, "prompt_eval_sec": null, "tokens_completion": 1723, "completion_eval_sec": null, "tokens_total": 1913, "tokens_per_sec": 174.21429688689435, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL returns only 'species_name' for species present in both 'Arctic' and 'Antarctic' regions, while the Generated SQL returns both 'species_name' and 'common_name' for species present in both regions. The output columns differ, making the result sets structurally incompatible. Additionally, the Reference SQL uses aggregation to enforce presence in both regions, whereas the Generated SQL uses INTERSECT, which inherently requires exact row matches (including both columns) between the two subqueries.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query correctly identifies species present in both regions by grouping and counting distinct regions, while the generated query uses INTERSECT to find overlapping species. Though both fulfill the business intent, they differ technically: the reference returns only species names, whereas the generated query includes common names (extra columns). The reference is more concise and directly addresses the question without unnecessary data. The generated query's inclusion of common_name is not required by the original question, making it less elegant. Both are logically correct, but the reference better aligns with the explicit request for species names.", "overall_assessment": "differently_correct"}}
{"example_id": 3474, "sql_complexity": "subqueries", "prompt": "What is the total transaction volume for the top 3 digital assets by market capitalization in the 'developed_markets' schema?", "context": "CREATE SCHEMA developed_markets; CREATE TABLE developed_markets.digital_assets (asset_name VARCHAR(10), market_cap BIGINT, daily_transaction_volume BIGINT); INSERT INTO developed_markets.digital_assets (asset_name, market_cap, daily_transaction_volume) VALUES ('AssetG', 30000000, 15000000), ('AssetH', 25000000, 12000000), ('AssetI', 20000000, 10000000), ('AssetJ', 15000000, 8000000), ('AssetK', 10000000, 6000000);", "reference_sql": "SELECT SUM(daily_transaction_volume) FROM (SELECT daily_transaction_volume FROM developed_markets.digital_assets ORDER BY market_cap DESC FETCH NEXT 3 ROWS ONLY) t;", "generated_sql": "SELECT SUM(daily_transaction_volume) FROM developed_markets.digital_assets ORDER BY market_cap DESC LIMIT 3;", "raw_model_output": "\n\nSELECT SUM(daily_transaction_volume) FROM developed_markets.digital_assets ORDER BY market_cap DESC LIMIT 3;", "latency_sec": 5.811784982681274, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 267, "prompt_eval_sec": null, "tokens_completion": 897, "completion_eval_sec": null, "tokens_total": 1164, "tokens_per_sec": 200.28270203881272, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL correctly sums the daily_transaction_volume of the top 3 rows ordered by market_cap DESC using a subquery. The Generated SQL applies ORDER BY and LIMIT after the SUM aggregation, which has no effect because SUM returns a single value. The Generated SQL effectively ignores the ORDER BY and LIMIT, making it semantically different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly uses a subquery to first select the top 3 assets by market capitalization (ORDER BY market_cap DESC FETCH NEXT 3 ROWS ONLY) and then sums their daily_transaction_volume. The generated query incorrectly applies SUM(daily_transaction_volume) to the entire table before ordering and limiting, which has no effect on the aggregate result. The SUM function aggregates all rows first, making the ORDER BY and LIMIT clauses irrelevant. This results in the total transaction volume of all assets, not the top 3. The reference query properly addresses the business intent of summing only the top 3 assets.", "overall_assessment": "incorrect"}}
{"example_id": 1626, "sql_complexity": "aggregation", "prompt": "Find the total value of social impact bonds issued by each organization.", "context": "CREATE TABLE social_impact_bonds (id INT, organization_name VARCHAR(255), issue_year INT, value FLOAT); INSERT INTO social_impact_bonds (id, organization_name, issue_year, value) VALUES (1, 'Acme Corp', 2018, 2000000), (2, 'XYZ Foundation', 2019, 3000000), (3, 'Global Giving', 2018, 1500000), (4, 'Acme Corp', 2019, 2500000), (5, 'XYZ Foundation', 2018, 1000000);", "reference_sql": "SELECT organization_name, SUM(value) as total_value FROM social_impact_bonds GROUP BY organization_name;", "generated_sql": "SELECT organization_name, SUM(value) AS total_value FROM social_impact_bonds GROUP BY organization_name;", "raw_model_output": "\n\n```sql\nSELECT organization_name, SUM(value) AS total_value FROM social_impact_bonds GROUP BY organization_name;\n```", "latency_sec": 2.8571791648864746, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 240, "prompt_eval_sec": null, "tokens_completion": 427, "completion_eval_sec": null, "tokens_total": 667, "tokens_per_sec": 233.44703342273678, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. The only differences are whitespace and case formatting (e.g., 'as' vs 'AS'), which do not affect SQL semantics. Both group by organization_name and calculate the same SUM(value) aggregate.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "The reference and generated SQL queries are identical in structure, syntax, and logic. Both correctly aggregate bond values by organization using SUM() and GROUP BY, producing the same results. The queries directly address the business intent of calculating total social impact bond values per organization. Since they are functionally identical, neither is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 1315, "sql_complexity": "single join", "prompt": "List all the transactions made by clients living in New York with a transaction amount greater than $1000.", "context": "CREATE TABLE transactions (id INT, client_id INT, transaction_amount DECIMAL(10,2), transaction_date DATE); INSERT INTO transactions (id, client_id, transaction_amount, transaction_date) VALUES (1, 3, 1500.00, '2022-01-01'), (2, 4, 800.00, '2022-01-02'), (3, 3, 1200.00, '2022-01-03'); CREATE TABLE clients (id INT, name VARCHAR(255), state VARCHAR(255)); INSERT INTO clients (id, name, state) VALUES (3, 'Mike Johnson', 'New York'), (4, 'Sara Lee', 'California');", "reference_sql": "SELECT transactions.id, transactions.client_id, transactions.transaction_amount, transactions.transaction_date FROM transactions INNER JOIN clients ON transactions.client_id = clients.id WHERE clients.state = 'New York' AND transactions.transaction_amount > 1000.00;", "generated_sql": "SELECT transactions.* \nFROM transactions \nJOIN clients ON transactions.client_id = clients.id \nWHERE clients.state = 'New York' AND transactions.transaction_amount > 1000;", "raw_model_output": "\n\nSELECT transactions.* \nFROM transactions \nJOIN clients ON transactions.client_id = clients.id \nWHERE clients.state = 'New York' AND transactions.transaction_amount > 1000;", "latency_sec": 2.973842144012451, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 268, "prompt_eval_sec": null, "tokens_completion": 457, "completion_eval_sec": null, "tokens_total": 725, "tokens_per_sec": 243.79236183054257, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same set of rows from the transactions table by joining with clients on client_id, filtering for 'New York' state and transaction_amount > 1000. The Reference SQL explicitly lists the same 4 columns as transactions.*, and the WHERE conditions are equivalent (1000.00 vs 1000 is functionally identical in this context). The semantic result set is identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly join the transactions and clients tables on client_id, filter for New York clients and transactions over $1000. The reference explicitly lists columns while the generated uses SELECT *, but since the transactions table only contains the four columns in question, both return identical data. The generated query is more concise but both achieve the same result. The business intent of identifying high-value transactions from New York clients is fully addressed by both.", "overall_assessment": "correct"}}
{"example_id": 520, "sql_complexity": "multiple_joins", "prompt": "What is the total number of electric vehicles sold in 'California' in the 'sales' schema?", "context": "CREATE TABLE sales_regions (id INT, name VARCHAR(50));   CREATE TABLE sales (id INT, region_id INT, vehicle_count INT);   CREATE TABLE vehicles (id INT, type VARCHAR(50));   INSERT INTO sales_regions VALUES (1, 'California');   INSERT INTO sales VALUES (1, 1, 5000);   INSERT INTO vehicles VALUES (1, 'electric');", "reference_sql": "SELECT SUM(sales.vehicle_count) FROM sales INNER JOIN sales_regions ON sales.region_id = sales_regions.id INNER JOIN vehicles ON sales.id = vehicles.id WHERE vehicles.type = 'electric' AND sales_regions.name = 'California';", "generated_sql": "SELECT vehicle_count\nFROM sales\nWHERE region_id = (SELECT id FROM sales_regions WHERE name = 'California');", "raw_model_output": "\n\nTo determine the total number of **electric vehicles sold in California**, we need to consider the following:\n\n- The `sales_regions` table contains region information, including the name `'California'`.\n- The `sales` table contains sales data, including `region_id` and `vehicle_count`.\n- The `vehicles` table contains vehicle types, including `'electric'`.\n\nHowever, based on the provided schema, there is **no direct relationship** between the `sales` and `vehicles` tables. The `sales` table does not have a `vehicle_id` or any other column that links to the `vehicles` table.\n\nGiven this, the only way to answer the question is to **assume** that the `vehicle_count` in the `sales` table corresponds to the only electric vehicle in the `vehicles` table (since there is only one vehicle in the data, with `id = 1` and `type = 'electric'`).\n\n---\n\n### \u2705 Final SQL Query\n\n```sql\nSELECT vehicle_count\nFROM sales\nWHERE region_id = (SELECT id FROM sales_regions WHERE name = 'California');\n```\n\n---\n\n### \ud83d\udccc Explanation\n\n- The subquery `(SELECT id FROM sales_regions WHERE name = 'California')` retrieves the `id` of the California region.\n- The main query selects the `vehicle_count` from the `sales` table where the `region_id` matches the California region.\n- This assumes that the `vehicle_count` in the `sales` table refers to the only electric vehicle in the `vehicles` table (as no explicit join is possible due to schema limitations).", "latency_sec": 14.629737138748169, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 174, "prompt_eval_sec": null, "tokens_completion": 2184, "completion_eval_sec": null, "tokens_total": 2358, "tokens_per_sec": 161.1785623785834, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query calculates the sum of vehicle_count for electric vehicles in California by joining sales with both sales_regions and vehicles tables. The generated query retrieves vehicle_count from sales where region_id matches California's ID, but it ignores the vehicles table entirely. This means the generated query includes all sales in California (regardless of vehicle type) while the reference query only includes electric vehicles. The semantic difference lies in the filtering condition on vehicle type.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly joins sales, sales_regions, and vehicles tables to filter electric vehicles in California and calculates the sum. The generated query only filters by region_id (without verifying vehicle type) and returns individual vehicle_count values instead of a total. It lacks the critical WHERE clause for vehicle.type = 'electric' and doesn't use SUM(), failing to meet the business requirement for a total count.", "overall_assessment": "incorrect"}}
{"example_id": 3999, "sql_complexity": "single join", "prompt": "What is the total number of tickets sold for performances with a rating of 5?", "context": "CREATE TABLE performance (id INT PRIMARY KEY, name VARCHAR(255), date DATE, artist_id INT, rating INT); INSERT INTO performance (id, name, date, artist_id, rating) VALUES (1, 'Dance Recital', '2022-03-01', 1, 5);", "reference_sql": "SELECT SUM(t.quantity) as total_tickets_sold FROM performance p INNER JOIN ticket t ON p.id = t.performance_id WHERE p.rating = 5;", "generated_sql": "The provided database schema does not include a column or table that tracks the number of tickets sold for performances. Therefore, it is not possible to calculate the total number of tickets sold using the given schema. \n\n**Answer:**  \nThe schema lacks a `tickets_sold` column or related data, making this query unexecutable.", "raw_model_output": "\n\nThe provided database schema does not include a column or table that tracks the number of tickets sold for performances. Therefore, it is not possible to calculate the total number of tickets sold using the given schema. \n\n**Answer:**  \nThe schema lacks a `tickets_sold` column or related data, making this query unexecutable.", "latency_sec": 3.9310379028320312, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 156, "prompt_eval_sec": null, "tokens_completion": 429, "completion_eval_sec": null, "tokens_total": 585, "tokens_per_sec": 148.81566000128095, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL attempts to calculate total tickets sold by joining with a 'ticket' table, but the provided schema only includes a 'performance' table without any ticket-related columns or tables. The Generated SQL explanation states the schema lacks necessary data, making the query unexecutable. Since the Generated SQL is not a valid query (only an explanation), the two cannot be semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference SQL assumes the existence of a 'ticket' table with a 'quantity' column, but the provided schema only includes a 'performance' table. The generated SQL correctly identifies that the necessary data structure (tickets sold tracking) is missing from the schema. While both queries fail to execute due to schema limitations, the generated response accurately addresses the technical constraint rather than assuming non-existent data relationships. The reference query's logic is invalid in this context, making the generated response more technically accurate.", "overall_assessment": "incorrect"}}
{"example_id": 2261, "sql_complexity": "multiple_joins", "prompt": "What is the total number of animals that have been released into 'protected' habitats, and the average weight of those animals?", "context": "CREATE TABLE habitats (habitat_id INT, habitat_name VARCHAR(50), habitat_status VARCHAR(50)); INSERT INTO habitats (habitat_id, habitat_name, habitat_status) VALUES (1, 'Habitat A', 'protected'), (2, 'Habitat B', 'unprotected'); CREATE TABLE animal_habitats (animal_id INT, habitat_id INT, animal_weight FLOAT); INSERT INTO animal_habitats (animal_id, habitat_id, animal_weight) VALUES (101, 1, 25.5), (102, 2, 15.2); CREATE TABLE animals (animal_id INT, animal_name VARCHAR(50)); INSERT INTO animals (animal_id, animal_name) VALUES (101, 'Dog'), (102, 'Cat');", "reference_sql": "SELECT COUNT(*), AVG(animal_habitats.animal_weight) FROM animal_habitats INNER JOIN animals ON animal_habitats.animal_id = animals.animal_id INNER JOIN habitats ON animal_habitats.habitat_id = habitats.habitat_id WHERE habitats.habitat_status = 'protected';", "generated_sql": "SELECT COUNT(DISTINCT ah.animal_id) AS total_animals, AVG(ah.animal_weight) AS average_weight\nFROM animal_habitats ah\nJOIN habitats h ON ah.habitat_id = h.habitat_id\nWHERE h.habitat_status = 'protected';", "raw_model_output": "\n\nSELECT COUNT(DISTINCT ah.animal_id) AS total_animals, AVG(ah.animal_weight) AS average_weight\nFROM animal_habitats ah\nJOIN habitats h ON ah.habitat_id = h.habitat_id\nWHERE h.habitat_status = 'protected';", "latency_sec": 15.001289129257202, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 264, "prompt_eval_sec": null, "tokens_completion": 2257, "completion_eval_sec": null, "tokens_total": 2521, "tokens_per_sec": 168.05222393075954, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their aggregation methods. The Reference SQL uses COUNT(*) which counts all rows, while the Generated SQL uses COUNT(DISTINCT ah.animal_id) which counts unique animal IDs. Additionally, the Reference SQL includes an unnecessary join with the animals table that could affect results if there are orphaned animal_habitats entries. These differences mean they may produce different results in general cases.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in their handling of animal count. The reference query uses COUNT(*), which counts all rows (including potential duplicates for animals released multiple times), while the generated query uses COUNT(DISTINCT ah.animal_id) to ensure each animal is counted once. For the average weight, both queries calculate the same value since AVG(ah.animal_weight) operates on the same dataset. The generated query better fulfills the business intent by accurately counting unique animals, which aligns with the question's focus on 'total number of animals' rather than 'number of releases'. The reference query might overcount if animals were released multiple times, making the generated query more precise.", "overall_assessment": "differently_correct"}}
{"example_id": 3439, "sql_complexity": "multiple_joins", "prompt": "How many menu items contain ingredients sourced from local suppliers for each restaurant?", "context": "CREATE TABLE restaurants (id INT, name VARCHAR(50), location VARCHAR(50)); INSERT INTO restaurants VALUES (1, 'Restaurant A', 'City A'); INSERT INTO restaurants VALUES (2, 'Restaurant B', 'City B'); CREATE TABLE menu_items (id INT, name VARCHAR(50), restaurant_id INT, price DECIMAL(5,2)); INSERT INTO menu_items VALUES (1, 'Item A', 1, 10.99); INSERT INTO menu_items VALUES (2, 'Item B', 1, 12.99); INSERT INTO menu_items VALUES (3, 'Item C', 2, 11.99); CREATE TABLE ingredients (id INT, name VARCHAR(50), local_source BOOLEAN, menu_item_id INT); INSERT INTO ingredients VALUES (1, 'Ingredient A', TRUE, 1); INSERT INTO ingredients VALUES (2, 'Ingredient B', FALSE, 1); INSERT INTO ingredients VALUES (3, 'Ingredient C', TRUE, 2); INSERT INTO ingredients VALUES (4, 'Ingredient D', FALSE, 2); INSERT INTO ingredients VALUES (5, 'Ingredient E', TRUE, 3);", "reference_sql": "SELECT r.name, COUNT(DISTINCT mi.id) as num_local_items FROM restaurants r JOIN menu_items mi ON r.id = mi.restaurant_id JOIN ingredients i ON mi.id = i.menu_item_id WHERE i.local_source = TRUE GROUP BY r.name;", "generated_sql": "SELECT r.name, COUNT(DISTINCT m.id) AS local_menu_item_count\nFROM restaurants r\nJOIN menu_items m ON r.id = m.restaurant_id\nJOIN ingredients i ON m.id = i.menu_item_id\nWHERE i.local_source = TRUE\nGROUP BY r.id, r.name;", "raw_model_output": "\n\nTo determine how many menu items contain ingredients sourced from local suppliers for each restaurant, we need to:\n\n1. **Identify** which menu items have at least one ingredient with `local_source = TRUE`.\n2. **Group** the results by restaurant.\n3. **Count** the number of such menu items per restaurant, ensuring that each menu item is only counted once, even if it has multiple local ingredients.\n\nWe can achieve this by joining the `menu_items` table with the `ingredients` table on `menu_item_id`, filtering for `local_source = TRUE`, and then grouping by restaurant.\n\n---\n\n### \u2705 Final SQL Query\n\n```sql\nSELECT r.name, COUNT(DISTINCT m.id) AS local_menu_item_count\nFROM restaurants r\nJOIN menu_items m ON r.id = m.restaurant_id\nJOIN ingredients i ON m.id = i.menu_item_id\nWHERE i.local_source = TRUE\nGROUP BY r.id, r.name;\n```\n\n---\n\n### \ud83d\udccc Explanation\n\n- `JOIN restaurants r` and `menu_items m` to associate each menu item with its restaurant.\n- `JOIN ingredients i` to access the `local_source` flag.\n- `WHERE i.local_source = TRUE` ensures only menu items with at least one local ingredient are considered.\n- `COUNT(DISTINCT m.id)` ensures that each menu item is counted only once, even if it has multiple local ingredients.\n- `GROUP BY r.id, r.name` groups the results by restaurant, allowing us to count the number of qualifying menu items per restaurant.\n\n---\n\n### \ud83e\uddfe Sample Output (based on provided data)\n\n| name           | local_menu_item_count |\n|----------------|------------------------|\n| Restaurant A   | 2                      |\n| Restaurant B   | 1                      |", "latency_sec": 15.386106014251709, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 327, "prompt_eval_sec": null, "tokens_completion": 2293, "completion_eval_sec": null, "tokens_total": 2620, "tokens_per_sec": 170.28350107383696, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their GROUP BY clauses. The Reference SQL groups by 'r.name' alone, while the Generated SQL groups by 'r.id' and 'r.name'. Although the sample data has unique restaurant names, semantically, if two restaurants had the same name but different IDs, the Reference SQL would aggregate them into a single group while the Generated SQL would treat them as separate groups. This makes them non-equivalent in general cases.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count menu items with local ingredients per restaurant. The reference query groups by r.name, which works if restaurant names are unique. The generated query groups by r.id and r.name, which is more robust for databases where names might not be unique. The generated version uses COUNT(DISTINCT m.id) which is functionally identical to COUNT(DISTINCT mi.id). The generated query's GROUP BY clause is technically superior as it uses the primary key (r.id) for grouping, ensuring accuracy even if names were duplicated. Both satisfy the business intent of counting local ingredient menu items per restaurant.", "overall_assessment": "correct"}}
{"example_id": 2265, "sql_complexity": "aggregation", "prompt": "Hourly revenue for a specific movie?", "context": "CREATE TABLE Movie_Revenue (id INT, movie_title VARCHAR(100), revenue_time TIME, revenue DECIMAL(10,2));", "reference_sql": "SELECT revenue_time, SUM(revenue) FROM Movie_Revenue WHERE movie_title = 'Spider-Man: No Way Home' GROUP BY revenue_time;", "generated_sql": "SELECT \n    HOUR(revenue_time) AS hour, \n    SUM(revenue) AS total_revenue\nFROM \n    Movie_Revenue\nWHERE \n    movie_title = 'Specific Movie Title'\nGROUP BY \n    HOUR(revenue_time)\nORDER BY \n    hour;", "raw_model_output": "\n\nTo retrieve the **hourly revenue for a specific movie**, we need to:\n\n1. **Group the revenue by the hour** extracted from the `revenue_time` column.\n2. **Sum the revenue** for each hour.\n3. **Filter the data** to only include the specified movie using the `WHERE` clause.\n\nSince the question refers to a \"specific movie,\" we assume that the movie title will be provided at runtime (e.g., as a parameter or placeholder). The SQL query below reflects this structure.\n\n---\n\n### \u2705 SQL Statement\n\n```sql\nSELECT \n    HOUR(revenue_time) AS hour, \n    SUM(revenue) AS total_revenue\nFROM \n    Movie_Revenue\nWHERE \n    movie_title = 'Specific Movie Title'\nGROUP BY \n    HOUR(revenue_time)\nORDER BY \n    hour;\n```\n\n---\n\n### \ud83d\udd0d Explanation\n\n- `HOUR(revenue_time)`: Extracts the hour part from the `revenue_time` column.\n- `SUM(revenue)`: Aggregates the revenue for each hour.\n- `WHERE movie_title = 'Specific Movie Title'`: Filters the data to only include the specified movie.\n- `GROUP BY HOUR(revenue_time)`: Groups the results by the hour of the day.\n- `ORDER BY hour`: Sorts the results chronologically by hour.\n\nThis query is ready to be executed once the movie title is provided.", "latency_sec": 7.459527969360352, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 108, "prompt_eval_sec": null, "tokens_completion": 1120, "completion_eval_sec": null, "tokens_total": 1228, "tokens_per_sec": 164.62167647121242, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The reference query groups by the full 'revenue_time' column, while the generated query groups by the hour part of 'revenue_time' using the HOUR() function. Additionally, the WHERE clause in the generated query uses a different movie title ('Specific Movie Title' vs. 'Spider-Man: No Way Home'), and the output columns differ (revenue_time vs. hour). These differences in grouping logic, filter conditions, and result columns ensure the queries produce different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in grouping logic. The reference query groups by the full 'revenue_time' (including minutes/seconds), which would create sub-hourly buckets. The generated query groups by the extracted 'HOUR(revenue_time)', which aligns with the 'hourly' requirement. While both answer the general question, the generated query explicitly aggregates by hour (e.g., 10:00-11:00) rather than exact timestamps. The generated query also includes an 'ORDER BY hour' which improves readability. The reference query's approach would only match the business intent if the data had exactly hourly timestamps, which is unlikely. The generated query better fulfills the intent of calculating true hourly revenue.", "overall_assessment": "differently_correct"}}
{"example_id": 1763, "sql_complexity": "multiple_joins", "prompt": "What is the total food and beverage revenue last month for hotels in 'Bangkok'?", "context": "CREATE TABLE revenue (hotel_id INT, revenue_source VARCHAR(50), revenue INT, revenue_date DATE); INSERT INTO revenue (hotel_id, revenue_source, revenue, revenue_date) VALUES (5, 'Room revenue', 12000, '2022-03-01'), (5, 'Food and beverage', 4000, '2022-03-02'), (5, 'Other revenue', 1000, '2022-03-03'); CREATE TABLE hotels (hotel_id INT, city VARCHAR(50)); INSERT INTO hotels (hotel_id, city) VALUES (5, 'Bangkok'); CREATE TABLE dates (date DATE); INSERT INTO dates (date) VALUES ('2022-03-01'), ('2022-03-02'), ('2022-03-03');", "reference_sql": "SELECT SUM(revenue) FROM revenue JOIN hotels ON revenue.hotel_id = hotels.hotel_id JOIN dates ON revenue.revenue_date = dates.date WHERE hotels.city = 'Bangkok' AND revenue_source = 'Food and beverage' AND dates.date >= DATEADD(month, -1, GETDATE());", "generated_sql": "SELECT SUM(r.revenue)\nFROM revenue r\nJOIN hotels h ON r.hotel_id = h.hotel_id\nWHERE h.city = 'Bangkok'\n  AND r.revenue_source = 'Food and beverage'\n  AND r.revenue_date >= DATE '2022-03-01'\n  AND r.revenue_date < DATE '2022-04-01';", "raw_model_output": "\n\nSELECT SUM(r.revenue)\nFROM revenue r\nJOIN hotels h ON r.hotel_id = h.hotel_id\nWHERE h.city = 'Bangkok'\n  AND r.revenue_source = 'Food and beverage'\n  AND r.revenue_date >= DATE '2022-03-01'\n  AND r.revenue_date < DATE '2022-04-01';", "latency_sec": 17.125503301620483, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 284, "prompt_eval_sec": null, "tokens_completion": 2649, "completion_eval_sec": null, "tokens_total": 2933, "tokens_per_sec": 171.26503953448585, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their date filtering logic. The Reference SQL uses DATEADD(month, -1, GETDATE()) which depends on the current date, while the Generated SQL uses fixed date literals ('2022-03-01' to '2022-04-01'). Additionally, the Reference SQL joins with the dates table, which is unnecessary here but doesn't affect the result. However, the dynamic date calculation in the Reference SQL may not align with the fixed range in the Generated SQL, leading to different results depending on the current date.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in date filtering logic. The Reference SQL uses DATEADD(month, -1, GETDATE()) which dynamically calculates 'last month' based on current date, but this would exclude data if the current date is not in the same month as the data. The Generated SQL uses explicit date ranges (2022-03-01 to 2022-04-01) which precisely captures the March 2022 data in the example. While the Reference SQL is more dynamic, the Generated SQL better aligns with the specific business context of the example data. Both correctly filter for 'Bangkok' hotels and 'Food and beverage' revenue sources, but the Generated SQL's static dates ensure accurate results for the given dataset.", "overall_assessment": "differently_correct"}}
{"example_id": 5499, "sql_complexity": "set operations", "prompt": "How many legal aid clinics and community mediation centers are there in total, and what is the sum of cases handled by each type of center, for centers located in the state of California?", "context": "CREATE TABLE LegalAidClinics (ClinicName text, State text, NumCases int); INSERT INTO LegalAidClinics VALUES ('Clinic1', 'CA', 30, '2022-01-01'), ('Clinic2', 'CA', 25, '2022-01-01'); CREATE TABLE CommunityMediationCenters (CenterName text, State text, NumCases int); INSERT INTO CommunityMediationCenters VALUES ('CM1', 'CA', 22, '2022-01-01'), ('CM2', 'CA', 28, '2022-01-01');", "reference_sql": "SELECT State, 'Legal Aid Clinics' AS CenterType, COUNT(*) AS NumCenters, SUM(NumCases) AS TotalCases FROM LegalAidClinics WHERE State = 'CA' UNION ALL SELECT State, 'Community Mediation Centers', COUNT(*), SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA';", "generated_sql": "SELECT \n    (SELECT COUNT(*) FROM LegalAidClinics WHERE State = 'CA') + \n    (SELECT COUNT(*) FROM CommunityMediationCenters WHERE State = 'CA') AS TotalCenters,\n    (SELECT SUM(NumCases) FROM LegalAidClinics WHERE State = 'CA') AS SumClinics,\n    (SELECT SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA') AS SumCenters;", "raw_model_output": "\n\nSELECT \n    (SELECT COUNT(*) FROM LegalAidClinics WHERE State = 'CA') + \n    (SELECT COUNT(*) FROM CommunityMediationCenters WHERE State = 'CA') AS TotalCenters,\n    (SELECT SUM(NumCases) FROM LegalAidClinics WHERE State = 'CA') AS SumClinics,\n    (SELECT SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA') AS SumCenters;", "latency_sec": 11.533633947372437, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 256, "prompt_eval_sec": null, "tokens_completion": 1799, "completion_eval_sec": null, "tokens_total": 2055, "tokens_per_sec": 178.174546667329, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two rows (one for each center type) with State, CenterType, NumCenters, and TotalCases, while the Generated SQL returns a single row with combined totals for centers and separate sums for cases. The structure and aggregation levels differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL returns two rows (one per center type) with counts and sums, but does not calculate the total number of centers across both types. The Generated SQL correctly computes the total centers (sum of both types) and separate case sums for each type. While both queries correctly aggregate data per type, the Generated SQL explicitly addresses the 'total' requirement in the question. The Reference SQL fails to fulfill the business intent as it doesn't combine the counts into a single total. The Generated SQL is more efficient as it avoids union operations and directly computes the required aggregates in a single row.", "overall_assessment": "differently_correct"}}
{"example_id": 2408, "sql_complexity": "aggregation", "prompt": "What is the average number of victories for players from Japan and South Korea, partitioned by game mode?", "context": "CREATE TABLE PlayerVictories (PlayerID INT, GameMode VARCHAR(255), Victories INT, Country VARCHAR(255)); INSERT INTO PlayerVictories (PlayerID, GameMode, Victories, Country) VALUES (1, 'Battle Royale', 25, 'Japan'), (2, 'Team Deathmatch', 18, 'South Korea');", "reference_sql": "SELECT GameMode, AVG(Victories) as AvgVictories FROM PlayerVictories WHERE Country IN ('Japan', 'South Korea') GROUP BY GameMode, Country WITH ROLLUP;", "generated_sql": "SELECT GameMode, AVG(Victories) AS AverageVictories\nFROM PlayerVictories\nWHERE Country IN ('Japan', 'South Korea')\nGROUP BY GameMode;", "raw_model_output": "\n\nSELECT GameMode, AVG(Victories) AS AverageVictories\nFROM PlayerVictories\nWHERE Country IN ('Japan', 'South Korea')\nGROUP BY GameMode;", "latency_sec": 3.4397711753845215, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 168, "prompt_eval_sec": null, "tokens_completion": 538, "completion_eval_sec": null, "tokens_total": 706, "tokens_per_sec": 205.24621086781403, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes 'Country' in the GROUP BY clause and uses WITH ROLLUP, which adds summary rows for each GameMode/Country combination and a final total row. The Generated SQL only groups by 'GameMode', eliminating the Country-level aggregation and the ROLLUP summaries. This results in different output structures and potentially different average calculations.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query groups by both GameMode and Country, which introduces unnecessary granularity not required by the original question. The generated query correctly groups only by GameMode, calculating the average victories across all players from Japan and South Korea within each game mode. The reference query's use of WITH ROLLUP adds a total row that isn't requested. While both queries filter for the correct countries, the generated query's structure directly addresses the 'partitioned by game mode' requirement without country-level segmentation. The generated query is more efficient and semantically aligned with the business intent.", "overall_assessment": "differently_correct"}}
{"example_id": 2729, "sql_complexity": "subqueries", "prompt": "Find the total number of trips made by shared autonomous vehicles in Seattle", "context": "CREATE TABLE shared_vehicles (id INT, vehicle_type VARCHAR(20), is_autonomous BOOLEAN, trip_count INT); INSERT INTO shared_vehicles (id, vehicle_type, is_autonomous, trip_count) VALUES (1, 'ebike', false, 1200), (2, 'escooter', false, 800), (3, 'car', true, 1500); CREATE TABLE city_data (city VARCHAR(20), has_autonomous_vehicles BOOLEAN); INSERT INTO city_data (city, has_autonomous_vehicles) VALUES ('Seattle', true), ('Denver', false), ('Portland', true);", "reference_sql": "SELECT SUM(trip_count) FROM shared_vehicles WHERE is_autonomous = true AND vehicle_type != 'ebike' AND vehicle_type != 'escooter' AND city IN (SELECT city FROM city_data WHERE has_autonomous_vehicles = true AND city = 'Seattle');", "generated_sql": "SELECT SUM(trip_count) AS total_trips\nFROM shared_vehicles\nWHERE is_autonomous = TRUE;", "raw_model_output": "\n\nTo determine the **total number of trips made by shared autonomous vehicles in Seattle**, we need to consider the following:\n\n- The `shared_vehicles` table contains information about vehicles, including their `is_autonomous` status and `trip_count`.\n- The `city_data` table contains information about cities, including whether they have autonomous vehicles (`has_autonomous_vehicles`).\n- However, **there is no direct link** between the `shared_vehicles` and `city_data` tables (e.g., no `city` column in `shared_vehicles`), which makes it **impossible to directly associate vehicles with cities**.\n\n---\n\n### Key Observations:\n\n- The question asks for **trips made by autonomous vehicles in Seattle**, but the schema does **not provide a way to associate vehicles with cities**.\n- The `city_data` table only tells us whether a city has autonomous vehicles, not which vehicles are located in which city.\n- Therefore, **we cannot filter vehicles by city** based on the provided schema.\n\n---\n\n### Conclusion:\n\nGiven the schema constraints, the only valid interpretation is to **sum the trip counts of all autonomous vehicles**, regardless of city. This is the **only feasible query** that can be constructed with the given schema.\n\n---\n\n### Final SQL Query:\n\n```sql\nSELECT SUM(trip_count) AS total_trips\nFROM shared_vehicles\nWHERE is_autonomous = TRUE;\n```\n\nThis query returns the **total number of trips made by all autonomous vehicles** in the dataset. While it does not explicitly filter by city, it is the only valid interpretation based on the provided schema.", "latency_sec": 18.862788200378418, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 218, "prompt_eval_sec": null, "tokens_completion": 2970, "completion_eval_sec": null, "tokens_total": 3188, "tokens_per_sec": 169.01000881386366, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL contains a reference to a 'city' column in the shared_vehicles table, which does not exist in the provided schema. The Generated SQL omits this invalid condition and simply sums trip_count for all autonomous vehicles. Since the Reference SQL is syntactically invalid and the Generated SQL is valid, they cannot be semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL contains a critical technical error: it references a 'city' column in the shared_vehicles table, which does not exist in the provided schema. This makes the query invalid. The Generated SQL is syntactically correct but fails to address the 'Seattle' constraint entirely. While the original question requires trips in Seattle, the schema lacks a city field in shared_vehicles, making it impossible to filter by location. The Generated SQL at least correctly sums autonomous vehicles (though without city filtering), whereas the Reference SQL is fundamentally flawed. Neither query fully meets the business intent, but the Generated SQL is technically superior.", "overall_assessment": "differently_correct"}}
{"example_id": 2952, "sql_complexity": "aggregation", "prompt": "Show the total budget allocated for each program category in 2023.", "context": "CREATE TABLE Budget (id INT, category TEXT, year INT, allocated_amount INT); INSERT INTO Budget (id, category, year, allocated_amount) VALUES (1, 'Education', 2023, 30000); INSERT INTO Budget (id, category, year, allocated_amount) VALUES (2, 'Healthcare', 2023, 50000);", "reference_sql": "SELECT category, SUM(allocated_amount) FROM Budget WHERE year = 2023 GROUP BY category;", "generated_sql": "SELECT category, SUM(allocated_amount) AS total_budget\nFROM Budget\nWHERE year = 2023\nGROUP BY category;", "raw_model_output": "\n\nSELECT category, SUM(allocated_amount) AS total_budget\nFROM Budget\nWHERE year = 2023\nGROUP BY category;", "latency_sec": 2.12160587310791, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 170, "prompt_eval_sec": null, "tokens_completion": 291, "completion_eval_sec": null, "tokens_total": 461, "tokens_per_sec": 217.28823710536193, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns and apply identical filtering (year = 2023) and grouping (category). The only difference is the alias 'total_budget' in the generated query, which does not affect the semantic result set. The SUM(allocated_amount) expression remains equivalent in both queries.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the total allocated budget per category for 2023 using SUM and GROUP BY. The generated query improves upon the reference by adding an explicit alias (total_budget) for the aggregated column, which enhances readability and clarifies the meaning of the calculated field. The semantic equivalence is maintained as the alias doesn't affect the computation logic. The generated query better fulfills the business intent by producing a more human-readable output while maintaining technical accuracy.", "overall_assessment": "correct"}}
{"example_id": 4328, "sql_complexity": "aggregation", "prompt": "What is the average cargo handling time in hours for each port?", "context": "CREATE TABLE cargo_handling (id INT, port_id INT, time_in_hours DECIMAL(5,2)); INSERT INTO cargo_handling (id, port_id, time_in_hours) VALUES (1, 1, 20.5), (2, 1, 22.3), (3, 2, 18.7);", "reference_sql": "SELECT port_id, AVG(time_in_hours) FROM cargo_handling GROUP BY port_id;", "generated_sql": "SELECT port_id, AVG(time_in_hours) AS average_time_in_hours\nFROM cargo_handling\nGROUP BY port_id;", "raw_model_output": "\n\nSELECT port_id, AVG(time_in_hours) AS average_time_in_hours\nFROM cargo_handling\nGROUP BY port_id;", "latency_sec": 3.0585219860076904, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 156, "prompt_eval_sec": null, "tokens_completion": 417, "completion_eval_sec": null, "tokens_total": 573, "tokens_per_sec": 187.34539186620032, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average time_in_hours per port_id. The generated query adds an alias for the average column, but this does not affect the semantic result set structure or values. The GROUP BY clause and aggregate function remain identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries calculate the average cargo handling time per port using AVG(time_in_hours) and GROUP BY port_id, producing identical results. The generated query adds an explicit alias (average_time_in_hours) which improves readability without altering functionality. While the reference query is technically correct, the generated version is more elegant and explicitly names the calculated column, making the output more interpretable for end-users. Both fulfill the business intent of determining average handling times per port.", "overall_assessment": "correct"}}
{"example_id": 4915, "sql_complexity": "window functions", "prompt": "Calculate the percentage of total Europium production for each country.", "context": "CREATE TABLE europium_production (country VARCHAR(50), quantity INT);", "reference_sql": "SELECT country, quantity * 100.0 / SUM(quantity) OVER (PARTITION BY NULL) AS percentage FROM europium_production;", "generated_sql": "SELECT country, (SUM(quantity) * 100.0 / (SELECT SUM(quantity) FROM europium_production)) AS percentage\nFROM europium_production\nGROUP BY country;", "raw_model_output": "\n\nTo calculate the **percentage of total Europium production for each country**, we need to:\n\n1. **Aggregate the production quantity per country** using `GROUP BY country`.\n2. **Compute the total production** across all countries using a scalar subquery.\n3. **Divide each country's total production by the overall total** and multiply by 100 to get the percentage.\n\nThis approach ensures that even if multiple rows exist for the same country, they are properly summed before calculating the percentage.\n\n---\n\n### \u2705 Final SQL Statement\n\n```sql\nSELECT country, (SUM(quantity) * 100.0 / (SELECT SUM(quantity) FROM europium_production)) AS percentage\nFROM europium_production\nGROUP BY country;\n```\n\n---\n\n### \ud83d\udd0d Explanation\n\n- `SUM(quantity)`: Aggregates the production quantity for each country.\n- `(SELECT SUM(quantity) FROM europium_production)`: Computes the total production across all countries.\n- `* 100.0 / ...`: Converts the ratio into a percentage.\n- `GROUP BY country`: Ensures the calculation is done per country.\n\nThis query adheres to **ANSI SQL standards** and handles multiple entries per country correctly.", "latency_sec": 9.079855918884277, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 97, "prompt_eval_sec": null, "tokens_completion": 1408, "completion_eval_sec": null, "tokens_total": 1505, "tokens_per_sec": 165.75152881775384, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query calculates the percentage of each individual row's quantity relative to the total sum (no grouping), while the generated query groups by country first, summing quantities per country before calculating the percentage. This leads to different results when multiple entries exist per country.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The Reference SQL calculates percentages per row without aggregating country data, which would produce incorrect results if multiple entries exist per country. The Generated SQL properly groups by country, aggregates quantities, and calculates the correct percentage. While both use 100.0 to avoid integer division, the Generated SQL ensures each country's total is calculated first. The Reference SQL's window function would incorrectly distribute per-row quantities rather than country totals. The Generated SQL better fulfills the business intent of calculating country-level percentages.", "overall_assessment": "differently_correct"}}
{"example_id": 5030, "sql_complexity": "subqueries", "prompt": "What is the success rate of diverse-led startups (at least 1 female or underrepresented racial or ethnic group executive) in the past 3 years?", "context": "CREATE TABLE DiverseStartups(id INT, name TEXT, country TEXT, year INT, success BOOLEAN);   INSERT INTO DiverseStartups VALUES (1, 'FemTech', 'USA', 2020, true), (2, 'GreenCity', 'Canada', 2019, false), (3, 'AI-Health', 'UK', 2021, true), (4, 'SolarEnergy', 'USA', 2020, false), (5, 'DataAnalytics', 'Germany', 2019, true), (6, 'SmartGrid', 'USA', 2021, true), (7, 'CloudServices', 'India', 2020, false), (8, 'RenewableEnergy', 'USA', 2019, true);", "reference_sql": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3) AS success_rate FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3 AND success = true;", "generated_sql": "SELECT (SUM(CASE WHEN success THEN 1 ELSE 0 END) * 1.0 / COUNT(*)) AS success_rate FROM DiverseStartups WHERE year >= EXTRACT(YEAR FROM CURRENT_DATE) - 2;", "raw_model_output": "\n\nSELECT (SUM(CASE WHEN success THEN 1 ELSE 0 END) * 1.0 / COUNT(*)) AS success_rate FROM DiverseStartups WHERE year >= EXTRACT(YEAR FROM CURRENT_DATE) - 2;", "latency_sec": 14.38063907623291, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 278, "prompt_eval_sec": null, "tokens_completion": 2256, "completion_eval_sec": null, "tokens_total": 2534, "tokens_per_sec": 176.20913692131933, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Reference SQL uses `YEAR(CURRENT_DATE) - 3` (3-year window) while the Generated SQL uses `EXTRACT(YEAR FROM CURRENT_DATE) - 2` (2-year window), leading to different time ranges. Second, the Reference SQL multiplies by 100.0 to calculate a percentage, whereas the Generated SQL returns a decimal ratio without this scaling. These differences in time frame and output format make the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries differ in their time frame calculations. The Reference SQL uses `YEAR(CURRENT_DATE) - 3`, which includes 4 years (e.g., 2020-2023 for 2023), while the Generated SQL uses `EXTRACT(YEAR FROM CURRENT_DATE) - 2`, which correctly captures 3 years (e.g., 2021-2023). The Generated SQL also uses a more robust method to calculate the success rate (SUM(CASE...) / COUNT(*)) that avoids potential issues with COUNT(*) in the numerator. The Reference SQL's time frame is incorrect for the 'past 3 years' requirement, making it less accurate for the business intent.", "overall_assessment": "differently_correct"}}
{"example_id": 4626, "sql_complexity": "aggregation", "prompt": "What was the maximum number of training hours for farmers in each country in 2020?", "context": "CREATE TABLE training (id INT, country_id INT, farmer_id INT, hours INT, date DATE);", "reference_sql": "SELECT country_id, MAX(hours) FROM training WHERE YEAR(date) = 2020 GROUP BY country_id;", "generated_sql": "SELECT country_id, MAX(hours) AS max_hours\nFROM training\nWHERE EXTRACT(YEAR FROM date) = 2020\nGROUP BY country_id;", "raw_model_output": "\n\nSELECT country_id, MAX(hours) AS max_hours\nFROM training\nWHERE EXTRACT(YEAR FROM date) = 2020\nGROUP BY country_id;", "latency_sec": 4.396898984909058, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 111, "prompt_eval_sec": null, "tokens_completion": 653, "completion_eval_sec": null, "tokens_total": 764, "tokens_per_sec": 173.75882471309538, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter records where the date is in 2020 using equivalent conditions (YEAR(date) = 2020 vs EXTRACT(YEAR FROM date) = 2020), select the same grouping column (country_id), and calculate the same aggregate (MAX(hours)). The generated query adds an alias (max_hours) which does not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the maximum training hours per country for 2020. The reference query uses YEAR(date) = 2020, while the generated query uses EXTRACT(YEAR FROM date) = 2020. These are logically equivalent for filtering dates in 2020. Both group by country_id and select MAX(hours), producing identical results. The generated query adds an alias (max_hours) which improves readability but doesn't affect functionality. Neither query has performance advantages over the other in this context. Both fully address the business intent of identifying maximum training hours per country in 2020.", "overall_assessment": "correct"}}
{"example_id": 2703, "sql_complexity": "set operations", "prompt": "Identify the species unique to 'MarineResearchAreaA' and 'MarineResearchAreaB'", "context": "CREATE TABLE ResearchAreaSpecies (area VARCHAR(255), species VARCHAR(255)); INSERT INTO ResearchAreaSpecies (area, species) VALUES ('MarineResearchAreaA', 'Coral'), ('MarineResearchAreaA', 'Starfish'), ('MarineResearchAreaB', 'Jellyfish');", "reference_sql": "(SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB') UNION (SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA');", "generated_sql": "SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA' AND species NOT IN (SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB')\nUNION\nSELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB' AND species NOT IN (SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA');", "raw_model_output": "\n\nSELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA' AND species NOT IN (SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB')\nUNION\nSELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB' AND species NOT IN (SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA');", "latency_sec": 6.367802858352661, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 156, "prompt_eval_sec": null, "tokens_completion": 1001, "completion_eval_sec": null, "tokens_total": 1157, "tokens_per_sec": 181.6953234477667, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries compute the symmetric difference between species in 'MarineResearchAreaA' and 'MarineResearchAreaB'. The Reference SQL uses EXCEPT and UNION to explicitly find elements in one set but not the other. The Generated SQL achieves the same result by using NOT IN conditions combined with UNION. Both approaches ensure that only species present in one area but not the other are returned, producing identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly identify species unique to each area by computing the symmetric difference between the two sets. The reference uses EXCEPT with UNION to explicitly show (A-B) \u222a (B-A), while the generated query uses NOT IN with UNION to achieve the same result. Both handle duplicates properly through UNION and produce identical results. The business intent of finding species exclusive to each area is fully satisfied by both approaches. Neither query is more efficient or elegant than the other in this specific case.", "overall_assessment": "correct"}}
{"example_id": 200, "sql_complexity": "window functions", "prompt": "List the top three categories of workforce development programs with the highest budget increases.", "context": "CREATE TABLE programs (program_id INT, program_name VARCHAR(50), budget DECIMAL(10, 2), category VARCHAR(50), budget_date DATE);", "reference_sql": "SELECT category, SUM(budget - LAG(budget) OVER (PARTITION BY category ORDER BY budget_date)) as total_budget_increase FROM programs GROUP BY category ORDER BY total_budget_increase DESC LIMIT 3;", "generated_sql": "WITH yearly_budgets AS (\n    SELECT \n        category,\n        EXTRACT(YEAR FROM budget_date) AS year,\n        SUM(budget) AS total_budget\n    FROM programs\n    WHERE category = 'workforce development'\n    GROUP BY category, EXTRACT(YEAR FROM budget_date)\n),\nranked_years AS (\n    SELECT \n        *,\n        ROW_NUMBER() OVER (PARTITION BY category ORDER BY year DESC) AS rn\n    FROM yearly_budgets\n),\nlatest_two AS (\n    SELECT \n        category,\n        year,\n        total_budget\n    FROM ranked_years\n    WHERE rn <= 2\n),\npivot AS (\n    SELECT \n        category,\n        MAX(CASE WHEN rn = 1 THEN total_budget END) AS latest,\n        MAX(CASE WHEN rn = 2 THEN total_budget END) AS previous\n    FROM latest_two\n    GROUP BY category\n)\nSELECT \n    category,\n    (latest - previous) AS budget_increase\nFROM pivot\nWHERE previous IS NOT NULL\nORDER BY budget_increase DESC\nLIMIT 3;", "raw_model_output": "\n\nTo determine the **top three categories of workforce development programs with the highest budget increases**, we must interpret the question in the context of the provided schema. Since the schema contains a `category` column, and the question refers to \"workforce development programs,\" we assume that the `category` field contains the type of program, and \"workforce development\" is one of those categories.\n\n---\n\n### Assumptions:\n- The `category` column contains the type of program (e.g., \"workforce development\", \"education\", etc.).\n- A \"budget increase\" is interpreted as the **difference in total budget** between the **most recent year** and the **previous year** for each category.\n- We are to **filter only those programs where the category is 'workforce development'**.\n- We are to **group by year** and **sum the budgets** for each category per year.\n- We then calculate the **increase** between the latest and previous year's total budget for each category.\n- Finally, we **rank the categories** by this increase and return the **top 3**.\n\n---\n\n### SQL Query:\n\n```sql\nWITH yearly_budgets AS (\n    SELECT \n        category,\n        EXTRACT(YEAR FROM budget_date) AS year,\n        SUM(budget) AS total_budget\n    FROM programs\n    WHERE category = 'workforce development'\n    GROUP BY category, EXTRACT(YEAR FROM budget_date)\n),\nranked_years AS (\n    SELECT \n        *,\n        ROW_NUMBER() OVER (PARTITION BY category ORDER BY year DESC) AS rn\n    FROM yearly_budgets\n),\nlatest_two AS (\n    SELECT \n        category,\n        year,\n        total_budget\n    FROM ranked_years\n    WHERE rn <= 2\n),\npivot AS (\n    SELECT \n        category,\n        MAX(CASE WHEN rn = 1 THEN total_budget END) AS latest,\n        MAX(CASE WHEN rn = 2 THEN total_budget END) AS previous\n    FROM latest_two\n    GROUP BY category\n)\nSELECT \n    category,\n    (latest - previous) AS budget_increase\nFROM pivot\nWHERE previous IS NOT NULL\nORDER BY budget_increase DESC\nLIMIT 3;\n```\n\n---\n\n### Explanation:\n\n- **yearly_budgets**: Aggregates the total budget per category per year.\n- **ranked_years**: Assigns a row number to each year within a category, ordered by year descending.\n- **latest_two**: Filters to only the most recent two years for each category.\n- **pivot**: Transposes the latest and previous year's budgets into separate columns.\n- **Final Select**: Calculates the budget increase and returns the top 3 categories with the highest increases.\n\nThis query ensures that only **workforce development** programs are considered and that we are analyzing **budget increases over time**.", "latency_sec": 28.309269189834595, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 120, "prompt_eval_sec": null, "tokens_completion": 4327, "completion_eval_sec": null, "tokens_total": 4447, "tokens_per_sec": 157.08635818818124, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates the total budget increase across all entries per category by subtracting the previous row's budget (using LAG) and sums these differences. The generated query specifically filters for 'workforce development', aggregates yearly budgets, and computes the difference between the two most recent years. Key differences include: 1) The generated query restricts to a single category, 2) It uses yearly aggregation and compares only the latest two years, while the reference query processes all entries and uses window functions for consecutive differences.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL is technically more aligned with the original question's intent. It groups by category and calculates total budget increases across all programs, which would identify categories with the highest increases. However, it fails to filter for 'workforce development' programs, which is critical to the question. The Generated SQL incorrectly filters to only 'workforce development' category programs, which would return a single category (not the top 3 categories). Neither query fully addresses the ambiguity in the question, but the Reference SQL's approach is more general and closer to the intended analysis. The Generated SQL's filtering is a major flaw that prevents it from fulfilling the intent.", "overall_assessment": "differently_correct"}}
{"example_id": 5131, "sql_complexity": "basic SQL", "prompt": "How many wells were drilled in the Eagle Ford Shale and Bakken Formation?", "context": "CREATE TABLE wells (id INT, region VARCHAR(255), well_type VARCHAR(255), num_drilled INT); INSERT INTO wells (id, region, well_type, num_drilled) VALUES (1, 'Eagle Ford Shale', 'Oil', 2000), (2, 'Eagle Ford Shale', 'Gas', 1500), (3, 'Bakken Formation', 'Oil', 1000), (4, 'Bakken Formation', 'Gas', 1200);", "reference_sql": "SELECT SUM(num_drilled) as total_wells FROM wells WHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "generated_sql": "SELECT SUM(num_drilled) FROM wells WHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "raw_model_output": "\n\nSELECT SUM(num_drilled) FROM wells WHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "latency_sec": 4.115760087966919, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 203, "prompt_eval_sec": null, "tokens_completion": 624, "completion_eval_sec": null, "tokens_total": 827, "tokens_per_sec": 200.93493846200278, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of num_drilled for wells in the specified regions. The only difference is the alias name (total_wells) in the reference query, which doesn't affect the result set's content or structure.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly sum the 'num_drilled' values for wells in 'Eagle Ford Shale' and 'Bakken Formation'. The reference query uses an explicit alias ('total_wells') while the generated query omits it, but this does not affect the result. The WHERE clause correctly filters the two regions, and both queries address the business intent of calculating total wells drilled in those formations. The generated query is slightly more concise, but neither is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 1160, "sql_complexity": "subqueries", "prompt": "What is the total revenue generated from ads on Instagram in March 2021, for users in the 'brand' category who have posted more than 10 times?", "context": "CREATE TABLE ads (ad_id INT, user_id INT, platform VARCHAR(255), ad_revenue DECIMAL(10,2), post_count INT); INSERT INTO ads (ad_id, user_id, platform, ad_revenue, post_count) VALUES (1, 1, 'Instagram', 150.50, 12), (2, 2, 'Twitter', 80.00, 15), (3, 3, 'Instagram', 120.75, 8);", "reference_sql": "SELECT SUM(ad_revenue) FROM ads WHERE platform = 'Instagram' AND MONTH(ad_date) = 3 AND YEAR(ad_date) = 2021 AND user_id IN (SELECT user_id FROM users WHERE category = 'brand' AND post_count > 10);", "generated_sql": "SELECT SUM(ad_revenue) AS total_revenue\nFROM ads\nWHERE platform = 'Instagram' AND post_count > 10;", "raw_model_output": "\n\nThe provided schema does not include a `category` column or any reference to user categories like 'brand'. Therefore, it is not possible to filter users by their category. However, based on the available data, the query can be written to sum ad revenue for Instagram ads where `post_count` exceeds 10. Here's the SQL:\n\n```sql\nSELECT SUM(ad_revenue) AS total_revenue\nFROM ads\nWHERE platform = 'Instagram' AND post_count > 10;\n``` \n\n**Note:** The condition for \"users in the 'brand' category\" cannot be fulfilled with the given schema.", "latency_sec": 8.492986917495728, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 221, "prompt_eval_sec": null, "tokens_completion": 1109, "completion_eval_sec": null, "tokens_total": 1330, "tokens_per_sec": 156.59979379694707, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL includes additional conditions: filtering by ad_date (MONTH and YEAR) and a subquery on a non-existent 'users' table (which isn't part of the provided schema). The Generated SQL omits these conditions and incorrectly assumes post_count is from the ads table (while the Reference's subquery references post_count from users).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL contains a critical error by referencing 'ad_date' which does not exist in the provided schema (ads table only has ad_id, user_id, platform, ad_revenue, post_count). The Generated SQL is syntactically valid but fails to address three key requirements: 1) filtering by date (March 2021), 2) filtering by user category ('brand'), and 3) ensuring the post_count condition applies to users rather than ads. While the Generated SQL is technically correct in its structure, it fundamentally misses the business requirements. The Reference SQL attempts to address the category filter but is invalidated by the non-existent ad_date column.", "overall_assessment": "incorrect"}}
{"example_id": 4708, "sql_complexity": "subqueries", "prompt": "What is the maximum number of high-level threats reported by a single agency in a month?", "context": "CREATE TABLE Threat_Intelligence (Threat_ID INT, Threat_Type VARCHAR(50), Threat_Level VARCHAR(50), Reported_Date DATE, Reporting_Agency VARCHAR(50)); CREATE VIEW High_Level_Threats AS SELECT Threat_Type, Threat_Level, Reported_Date FROM Threat_Intelligence WHERE Threat_Level = 'High';", "reference_sql": "SELECT Reporting_Agency, MAX(Number_of_High_Level_Threats) as Max_High_Level_Threats_in_a_Month FROM (SELECT Reporting_Agency, TO_CHAR(Reported_Date, 'YYYY-MM') as Month, COUNT(*) as Number_of_High_Level_Threats FROM High_Level_Threats GROUP BY Reporting_Agency, Month) GROUP BY Reporting_Agency;", "generated_sql": "SELECT MAX(cnt) AS max_high_threats\nFROM (\n    SELECT COUNT(*) AS cnt\n    FROM Threat_Intelligence\n    WHERE Threat_Level = 'High'\n    GROUP BY Reporting_Agency, EXTRACT(YEAR FROM Reported_Date), EXTRACT(MONTH FROM Reported_Date)\n) AS sub;", "raw_model_output": "\n\nSELECT MAX(cnt) AS max_high_threats\nFROM (\n    SELECT COUNT(*) AS cnt\n    FROM Threat_Intelligence\n    WHERE Threat_Level = 'High'\n    GROUP BY Reporting_Agency, EXTRACT(YEAR FROM Reported_Date), EXTRACT(MONTH FROM Reported_Date)\n) AS sub;", "latency_sec": 7.365931034088135, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 154, "prompt_eval_sec": null, "tokens_completion": 1065, "completion_eval_sec": null, "tokens_total": 1219, "tokens_per_sec": 165.4916390553616, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the maximum number of high-level threats per month for each Reporting_Agency, returning multiple rows (one per agency). The Generated SQL calculates the absolute maximum count across all agencies and months, returning a single value. The grouping strategies and output structures differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL incorrectly groups by Reporting_Agency in the outer query, which returns per-agency maximums rather than the global maximum across all agencies. The Generated SQL correctly groups by agency and month, then selects the overall maximum count. The Reference SQL's structure would require an additional step (e.g., subquery with MAX) to get the global maximum, while the Generated SQL directly answers the question. The Generated SQL is also more efficient as it avoids the view and unnecessary nesting.", "overall_assessment": "differently_correct"}}
{"example_id": 5608, "sql_complexity": "set operations", "prompt": "List the suppliers that provide materials for both product A and product C.", "context": "CREATE TABLE products (product_id INT, product_name TEXT); CREATE TABLE materials (material_id INT, material_name TEXT, product_id INT, supplier_id INT); INSERT INTO products (product_id, product_name) VALUES (1, 'Product A'), (2, 'Product B'), (3, 'Product C'); INSERT INTO materials (material_id, material_name, product_id, supplier_id) VALUES (1, 'Material 1', 1, 101), (2, 'Material 2', 1, 102), (3, 'Material 3', 2, 103), (4, 'Material 4', 3, 101), (5, 'Material 5', 3, 102);", "reference_sql": "SELECT supplier_id FROM materials WHERE product_id = 1 INTERSECT SELECT supplier_id FROM materials WHERE product_id = 3;", "generated_sql": "SELECT supplier_id\nFROM materials\nWHERE product_id = 1\nINTERSECT\nSELECT supplier_id\nFROM materials\nWHERE product_id = 3;", "raw_model_output": "\n\nTo find the suppliers that provide materials for **both Product A and Product C**, we need to identify the `supplier_id` values that appear in the `materials` table for **both** `product_id = 1` (Product A) and `product_id = 3` (Product C).\n\nWe can achieve this by using the `INTERSECT` operator, which returns the common rows between two result sets. This is a clean and efficient way to find the intersection of suppliers for the two products.\n\n---\n\n### \u2705 SQL Statement\n\n```sql\nSELECT supplier_id\nFROM materials\nWHERE product_id = 1\nINTERSECT\nSELECT supplier_id\nFROM materials\nWHERE product_id = 3;\n```\n\n---\n\n### \ud83d\udccc Explanation\n\n- The first `SELECT` retrieves all `supplier_id`s that supply materials for **Product A** (i.e., `product_id = 1`).\n- The second `SELECT` retrieves all `supplier_id`s that supply materials for **Product C** (i.e., `product_id = 3`).\n- The `INTERSECT` operator returns only those `supplier_id`s that appear in **both** result sets, which are the suppliers that provide materials for **both** products.\n\nThis query is concise, uses standard ANSI SQL, and adheres to the schema provided.", "latency_sec": 9.729550838470459, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 245, "prompt_eval_sec": null, "tokens_completion": 1523, "completion_eval_sec": null, "tokens_total": 1768, "tokens_per_sec": 181.71445212140335, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select supplier_id from materials where product_id is 1 and intersect with supplier_id from materials where product_id is 3. The formatting differences (line breaks, spacing) do not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic. They use INTERSECT to find suppliers present in both product_id=1 (Product A) and product_id=3 (Product C) material records. The queries correctly address the business intent by identifying suppliers that provide materials for both products. The syntax is valid, the logic is sound, and the approach is efficient. Since the reference and generated queries are exactly the same, neither is superior to the other.", "overall_assessment": "correct"}}
{"example_id": 1506, "sql_complexity": "basic SQL", "prompt": "How many habitats are in the 'animal_habitats' table?", "context": "CREATE TABLE animal_habitats (id INT PRIMARY KEY, habitat_name VARCHAR, num_animals INT);", "reference_sql": "SELECT COUNT(*) FROM animal_habitats;", "generated_sql": "SELECT COUNT(*) FROM animal_habitats;", "raw_model_output": "\n\nSELECT COUNT(*) FROM animal_habitats;", "latency_sec": 1.4891510009765625, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 105, "prompt_eval_sec": null, "tokens_completion": 222, "completion_eval_sec": null, "tokens_total": 327, "tokens_per_sec": 219.58820817066797, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical: they select the count of all rows from the 'animal_habitats' table using the same syntax. The result will always be the same.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in syntax, logic, and result. They correctly count all rows in the 'animal_habitats' table using COUNT(*), which directly answers the question about the number of habitats. The queries are equally efficient and semantically equivalent, with no differences in structure or performance. Since they are identical, neither is superior to the other.", "overall_assessment": "correct"}}
{"example_id": 3117, "sql_complexity": "aggregation", "prompt": "What is the percentage of the population that has access to clean water in each continent?", "context": "CREATE TABLE water_data (id INT, country VARCHAR(50), continent CHAR(2), access_to_clean_water BOOLEAN); INSERT INTO water_data VALUES (1, 'Canada', 'NA', true), (2, 'Mexico', 'NA', false), (3, 'Brazil', 'SA', true), (4, 'Russia', 'EU', true);", "reference_sql": "SELECT continent, COUNT(*) FILTER (WHERE access_to_clean_water) * 100.0 / COUNT(*) AS percentage FROM water_data GROUP BY continent;", "generated_sql": "SELECT \n    continent,\n    (SUM(CASE WHEN access_to_clean_water THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    water_data\nGROUP BY \n    continent;", "raw_model_output": "\n\nTo calculate the **percentage of countries** (not population) that have access to clean water in each continent, we can use the following SQL query. This assumes that each row in the `water_data` table represents a **country**, and the `access_to_clean_water` column indicates whether that country has access (true) or not (false).\n\n---\n\n### \u2705 Assumptions:\n- Each row represents a **country**.\n- The `access_to_clean_water` column is a `BOOLEAN` indicating whether the country has access.\n- The question is interpreted as asking for the **percentage of countries** per continent that have access to clean water (since population data is not available in the schema).\n\n---\n\n### \ud83e\udde0 SQL Logic:\n- Use `GROUP BY continent` to group data by continent.\n- Use `SUM(CASE WHEN access_to_clean_water THEN 1 ELSE 0 END)` to count the number of countries with access.\n- Use `COUNT(*)` to count the total number of countries per continent.\n- Multiply by `100.0` to ensure floating-point division and express the result as a percentage.\n\n---\n\n### \u2705 Final SQL Query:\n\n```sql\nSELECT \n    continent,\n    (SUM(CASE WHEN access_to_clean_water THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    water_data\nGROUP BY \n    continent;\n```\n\n---\n\n### \ud83d\udccc Example Output (based on sample data):\n\n| continent | percentage |\n|-----------|------------|\n| NA        | 50.0       |\n| SA        | 100.0      |\n| EU        | 100.0      |\n\nThis query adheres to the provided schema and calculates the required percentage based on the available data.", "latency_sec": 7.744574069976807, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 161, "prompt_eval_sec": null, "tokens_completion": 1186, "completion_eval_sec": null, "tokens_total": 1347, "tokens_per_sec": 173.92822224037866, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the percentage of countries with access to clean water per continent. The Reference SQL uses COUNT(*) FILTER (WHERE access_to_clean_water) to count qualifying rows, while the Generated SQL uses SUM(CASE WHEN access_to_clean_water THEN 1 ELSE 0 END) for the same purpose. Both methods effectively count the same values, and the division by COUNT(*) and multiplication by 100.0 are identical. The GROUP BY clauses are also the same.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries correctly calculate the percentage of populations with access to clean water per continent. The reference query uses PostgreSQL's COUNT(*) FILTER syntax which is more concise and directly expresses the intent. The generated query achieves the same result using a standard SQL CASE statement. Both handle division correctly with 100.0 to ensure floating-point precision. The reference version is more elegant and efficient in PostgreSQL, though the generated version is more portable across SQL dialects. Both fulfill the business requirement of showing continent-level water access percentages.", "overall_assessment": "correct"}}
{"example_id": 3542, "sql_complexity": "window functions", "prompt": "What is the average yield of crops for each country, ranked by average yield?", "context": "CREATE TABLE farming (id INT, name TEXT, country TEXT, crop TEXT, yield INT); INSERT INTO farming VALUES (1, 'Smith Farm', 'USA', 'Corn', 120), (2, 'Brown Farm', 'Canada', 'Soybeans', 45), (3, 'Jones Farm', 'Mexico', 'Wheat', 80);", "reference_sql": "SELECT country, AVG(yield) as avg_yield, ROW_NUMBER() OVER (ORDER BY AVG(yield) DESC) as rank FROM farming GROUP BY country;", "generated_sql": "SELECT country, avg_yield, RANK() OVER (ORDER BY avg_yield DESC) AS rank\nFROM (\n    SELECT country, AVG(yield) AS avg_yield\n    FROM farming\n    GROUP BY country\n) AS sub;", "raw_model_output": "\n\nSELECT country, avg_yield, RANK() OVER (ORDER BY avg_yield DESC) AS rank\nFROM (\n    SELECT country, AVG(yield) AS avg_yield\n    FROM farming\n    GROUP BY country\n) AS sub;", "latency_sec": 8.246001720428467, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 164, "prompt_eval_sec": null, "tokens_completion": 1218, "completion_eval_sec": null, "tokens_total": 1382, "tokens_per_sec": 167.5963754138279, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their ranking functions: ROW_NUMBER() vs RANK(). ROW_NUMBER() assigns unique ranks even with ties, while RANK() assigns same ranks to ties and skips subsequent numbers. Additionally, the Reference SQL may have syntax issues using AVG(yield) directly in the window function's ORDER BY clause, whereas the Generated SQL correctly computes averages in a subquery.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent due to differences in ranking functions. The reference uses ROW_NUMBER() which assigns unique sequential ranks, while the generated query uses RANK() which may produce non-sequential ranks for tied values. Both correctly calculate average yields per country, but the reference better fulfills the business intent of 'ranked by average yield' by ensuring unique rankings. The generated query is syntactically correct but may produce different ranking results in cases of tied averages. The reference query is more elegant by avoiding a subquery and directly applying the window function.", "overall_assessment": "differently_correct"}}
{"example_id": 2274, "sql_complexity": "subqueries", "prompt": "Add a new crop 'amaranth' to farm 'Nourishing Harvest' with yield 50 in 2023", "context": "CREATE TABLE farms (id INT, name TEXT, location TEXT, size FLOAT); INSERT INTO farms (id, name, location, size) VALUES (1, 'Nourishing Harvest', 'Mexico', 120.0); CREATE TABLE crops (id INT, farm_id INT, crop TEXT, yield INT, year INT);", "reference_sql": "INSERT INTO crops (id, farm_id, crop, yield, year) VALUES (5, (SELECT id FROM farms WHERE name = 'Nourishing Harvest'), 'amaranth', 50, 2023);", "generated_sql": "INSERT INTO crops (farm_id, crop, yield, year) VALUES ((SELECT id FROM farms WHERE name = 'Nourishing Harvest'), 'amaranth', 50, 2023);", "raw_model_output": "\n\nINSERT INTO crops (farm_id, crop, yield, year) VALUES ((SELECT id FROM farms WHERE name = 'Nourishing Harvest'), 'amaranth', 50, 2023);", "latency_sec": 12.08240270614624, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 166, "prompt_eval_sec": null, "tokens_completion": 1821, "completion_eval_sec": null, "tokens_total": 1987, "tokens_per_sec": 164.45404513700126, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL explicitly specifies an 'id' value (5) in the INSERT, while the Generated SQL omits the 'id' column entirely. If the 'id' column is not auto-generated, the Generated SQL would fail or insert a different value, leading to different results. Even if 'id' is auto-incremented, the explicit value 5 in the Reference SQL would produce a distinct row compared to the Generated SQL's auto-assigned ID.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query is technically more robust as it explicitly includes all columns in the INSERT statement, ensuring compatibility with databases where the 'id' column is required (e.g., non-auto-incrementing primary keys). The generated query omits the 'id' column, which could fail if the database enforces non-nullable columns or lacks auto-increment functionality. Both queries correctly map the farm_id via subquery and insert the required crop data, fulfilling the business intent. However, the reference query is more universally correct and avoids potential technical issues.", "overall_assessment": "correct"}}
{"example_id": 3705, "sql_complexity": "subqueries", "prompt": "What is the percentage of unions with collective bargaining agreements in the Midwest region?", "context": "CREATE TABLE collective_bargaining (bargaining_id INT, union_name VARCHAR(50), contract_start_date DATE, contract_end_date DATE, region VARCHAR(50));CREATE VIEW union_region AS SELECT DISTINCT union_name, region FROM collective_bargaining;", "reference_sql": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM union_region) as percentage FROM union_region ur WHERE ur.region = 'Midwest' AND EXISTS (SELECT 1 FROM collective_bargaining cb WHERE cb.union_name = ur.union_name);", "generated_sql": "SELECT (COUNT(DISTINCT CASE WHEN region = 'Midwest' THEN union_name END) * 100.0 / COUNT(DISTINCT union_name)) AS percentage FROM union_region;", "raw_model_output": "\n\nSELECT (COUNT(DISTINCT CASE WHEN region = 'Midwest' THEN union_name END) * 100.0 / COUNT(DISTINCT union_name)) AS percentage FROM union_region;", "latency_sec": 22.46491003036499, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 138, "prompt_eval_sec": null, "tokens_completion": 3299, "completion_eval_sec": null, "tokens_total": 3437, "tokens_per_sec": 152.99415823852996, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their calculation logic. The reference query counts rows in union_region where region is 'Midwest' (including possible duplicates per union) and divides by total rows. The generated query counts distinct union_names in the Midwest and divides by total distinct union_names. Since union_region contains distinct (union_name, region) pairs, the denominators (total rows vs. distinct unions) and numerators (row count vs. distinct count) differ, leading to different results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries calculate the percentage of unions with collective bargaining agreements (CBAs) located in the Midwest. The reference query uses a correlated subquery with EXISTS, which is logically equivalent to the generated query's CASE statement. However, the generated query is more efficient as it avoids a correlated subquery and uses a single pass through the data. Both correctly address the business intent by dividing Midwest unions by total unions with CBAs. The generated query is more elegant and performant.", "overall_assessment": "correct"}}
{"example_id": 240, "sql_complexity": "aggregation", "prompt": "What is the average capacity of renewable energy projects for each country?", "context": "CREATE TABLE projects (name TEXT, type TEXT, capacity INTEGER, country TEXT); INSERT INTO projects (name, type, capacity, country) VALUES ('Project 1', 'Wind', 100, 'USA'), ('Project 2', 'Solar', 200, 'Germany'), ('Project 3', 'Wind', 300, 'France');", "reference_sql": "SELECT country, AVG(capacity) FROM projects GROUP BY country", "generated_sql": "SELECT country, AVG(capacity) AS average_capacity\nFROM projects\nGROUP BY country;", "raw_model_output": "\n\nSELECT country, AVG(capacity) AS average_capacity\nFROM projects\nGROUP BY country;", "latency_sec": 3.3724279403686523, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 160, "prompt_eval_sec": null, "tokens_completion": 484, "completion_eval_sec": null, "tokens_total": 644, "tokens_per_sec": 190.96034411623395, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average capacity per country. The generated query adds an explicit alias (average_capacity) for the computed column, but this does not affect the semantic result. The GROUP BY clause and aggregate function remain identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the average capacity of projects per country using GROUP BY and AVG. The reference query omits the column alias, while the generated query adds 'AS average_capacity'. This alias improves readability but does not alter the result set. Since the original question did not specify formatting requirements, both queries technically and semantically fulfill the business intent equally well. The generated query is slightly more elegant but not strictly superior in this context.", "overall_assessment": "correct"}}
{"example_id": 2132, "sql_complexity": "set operations", "prompt": "What is the average caseload per attorney in community legal clinics in California, and how does it compare to the state average?", "context": "CREATE TABLE cali_community_legal_clinics(id INT, attorney_count INT, cases_handled INT, state VARCHAR(255));", "reference_sql": "SELECT state, AVG(cases_handled/attorney_count) AS avg_caseload FROM cali_community_legal_clinics WHERE state = 'California' GROUP BY state UNION ALL SELECT 'California', AVG(cases_handled/attorney_count) FROM cali_community_legal_clinics WHERE state = 'California';", "generated_sql": "SELECT \n    (SELECT SUM(cases_handled) / SUM(attorney_count) FROM cali_community_legal_clinics WHERE state = 'California') AS california_avg,\n    (SELECT SUM(cases_handled) / SUM(attorney_count) FROM cali_community_legal_clinics) AS state_avg;", "raw_model_output": "\n\nSELECT \n    (SELECT SUM(cases_handled) / SUM(attorney_count) FROM cali_community_legal_clinics WHERE state = 'California') AS california_avg,\n    (SELECT SUM(cases_handled) / SUM(attorney_count) FROM cali_community_legal_clinics) AS state_avg;", "latency_sec": 10.945970058441162, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 123, "prompt_eval_sec": null, "tokens_completion": 1673, "completion_eval_sec": null, "tokens_total": 1796, "tokens_per_sec": 164.07865090175224, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL calculates the average caseload per attorney for California clinics and returns two rows with the same value using UNION ALL, while the Generated SQL computes two separate sums (California-specific and overall) as columns. Additionally, the Reference SQL uses AVG(cases_handled/attorney_count) (average of ratios) whereas the Generated SQL uses SUM(cases_handled)/SUM(attorney_count) (total ratio), which are mathematically different. The output structures also differ (rows vs. columns).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query is technically flawed. The first part calculates the average caseload for California clinics (correct), but the second UNION ALL subquery incorrectly repeats the same California average instead of calculating the state-wide average. The generated query correctly computes both the California-specific average (using SUM(cases_handled)/SUM(attorney_count) for California) and the overall state average (using the same formula without the state filter). The reference query fails to compute the state average, while the generated query addresses both parts of the question. The generated query also avoids redundant calculations and explicitly separates the two metrics.", "overall_assessment": "incorrect"}}
{"example_id": 3276, "sql_complexity": "basic SQL", "prompt": "What is the total energy consumption of the Chemical Plant B in the last quarter?", "context": "CREATE TABLE EnergyConsumption (EnergyID INT, Plant VARCHAR(255), EnergyQuantity DECIMAL(5,2), Timestamp DATETIME);", "reference_sql": "SELECT SUM(EnergyQuantity) FROM EnergyConsumption WHERE Plant = 'Chemical Plant B' AND Timestamp BETWEEN DATE_SUB(CURRENT_DATE(), INTERVAL 3 MONTH) AND CURRENT_DATE();", "generated_sql": "SELECT SUM(EnergyQuantity) \nFROM EnergyConsumption \nWHERE Plant = 'Chemical Plant B' \n  AND Timestamp >= CURRENT_DATE - INTERVAL '3' MONTH;", "raw_model_output": "\n\nSELECT SUM(EnergyQuantity) \nFROM EnergyConsumption \nWHERE Plant = 'Chemical Plant B' \n  AND Timestamp >= CURRENT_DATE - INTERVAL '3' MONTH;", "latency_sec": 4.569657802581787, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 116, "prompt_eval_sec": null, "tokens_completion": 609, "completion_eval_sec": null, "tokens_total": 725, "tokens_per_sec": 158.65520599603454, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The original query uses BETWEEN with CURRENT_DATE() (a DATE type), which truncates the time component, effectively limiting the upper bound to the start of the current day (00:00:00). The generated query uses a >= condition with CURRENT_DATE - INTERVAL '3' MONTH (a DATE type), which includes all timestamps from three months ago up to the current moment (including the entire current day). The original query excludes records from the current day after midnight, while the generated query includes them, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent. The reference query uses DATE_SUB(CURRENT_DATE(), INTERVAL 3 MONTH) which is valid MySQL syntax. The generated query contains a syntax error: INTERVAL '3' MONTH incorrectly uses quotes around the numeric value (valid syntax requires INTERVAL 3 MONTH without quotes). Both queries target the same business intent but the generated query would fail execution. The reference query is both syntactically correct and semantically equivalent.", "overall_assessment": "incorrect"}}
{"example_id": 3074, "sql_complexity": "multiple_joins", "prompt": "Find the top 5 players with the highest scores in the 'historical_tournaments' view, including their scores and the names of the tournaments they participated in.", "context": "CREATE VIEW historical_tournaments AS SELECT tournaments.tournament_name, players.player_name, players.score FROM tournaments JOIN players_scores ON tournaments.tournament_id = players_scores.tournament_id JOIN players ON players_scores.player_id = players.player_id;  CREATE TABLE tournaments (tournament_id INT, tournament_name TEXT);  CREATE TABLE players_scores (player_id INT, tournament_id INT, score INT);  CREATE TABLE players (player_id INT, player_name TEXT);", "reference_sql": "SELECT players.player_name, MAX(players_scores.score) as high_score, tournaments.tournament_name FROM historical_tournaments JOIN players ON historical_tournaments.player_id = players.player_id JOIN players_scores ON historical_tournaments.player_id = players_scores.player_id JOIN tournaments ON players_scores.tournament_id = tournaments.tournament_id GROUP BY players.player_id, tournaments.tournament_name ORDER BY high_score DESC LIMIT 5;", "generated_sql": "SELECT player_name, score, tournament_name\nFROM historical_tournaments\nORDER BY score DESC\nLIMIT 5;", "raw_model_output": "\n\nTo retrieve the **top 5 players with the highest scores** from the `historical_tournaments` view, including their **scores** and the **names of the tournaments** they participated in, we can directly query the view.\n\nThe `historical_tournaments` view already contains the necessary columns: `tournament_name`, `player_name`, and `score`. Since the question asks for the **top 5 players**, and the view includes all player-tournament-score combinations, we can assume that the goal is to find the **top 5 highest individual scores** (i.e., the top 5 rows in the view sorted by `score` in descending order).\n\nThis approach is valid under the assumption that the user is looking for the **top 5 highest scores**, regardless of whether they belong to the same player or not. If the intention were to find the top 5 **unique players** based on their **highest score**, a more complex query would be required (e.g., grouping by player and selecting max score). However, the question does not specify this, so we proceed with the simpler interpretation.\n\n---\n\n### \u2705 Final SQL Query\n\n```sql\nSELECT player_name, score, tournament_name\nFROM historical_tournaments\nORDER BY score DESC\nLIMIT 5;\n```\n\n---\n\n### \ud83d\udccc Notes:\n- This query returns the **top 5 highest scores** from the `historical_tournaments` view.\n- It includes the **player name**, **score**, and **tournament name** for each of those top 5 entries.\n- If the goal were to find the **top 5 unique players** based on their **maximum score**, a more complex query involving `GROUP BY` and `MAX(score)` would be needed. However, that is not explicitly requested in the question.", "latency_sec": 13.512758016586304, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 192, "prompt_eval_sec": null, "tokens_completion": 2090, "completion_eval_sec": null, "tokens_total": 2282, "tokens_per_sec": 168.8774413927155, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL groups by player_id and tournament_name to find the maximum score per player-tournament pair, while the Generated SQL simply selects all entries from the view and orders them by score. Additionally, the Reference SQL includes redundant joins and returns a column named 'high_score' instead of 'score', leading to different output structures and results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries are not technically equivalent. The Reference SQL contains redundant joins and incorrect grouping logic that would produce incorrect results. It groups by player_id and tournament_name but uses MAX(score) which is unnecessary since the view already contains the score. The Generated SQL is simpler, directly selects from the view, and orders by score, which aligns with the requirement to find top scores. However, neither query fully addresses the business intent of identifying top players (not just top scores) or handling multiple tournament entries per player. The Generated SQL is more efficient and elegant but lacks proper aggregation to ensure each player is represented once with their highest score.", "overall_assessment": "differently_correct"}}
{"example_id": 2219, "sql_complexity": "window functions", "prompt": "What is the average population of cities with a UNESCO World Heritage designation, ordered by designation date?", "context": "CREATE TABLE cities (name VARCHAR(255), population INT, designation_date DATE); INSERT INTO cities (name, population, designation_date) VALUES ('Paris', 2141000, '1991-09-16'); INSERT INTO cities (name, population, designation_date) VALUES ('Rio de Janeiro', 6727000, '2012-07-01');", "reference_sql": "SELECT AVG(population) FROM (SELECT population, ROW_NUMBER() OVER (ORDER BY designation_date) rn FROM cities WHERE name IN (SELECT name FROM heritagesites)) t WHERE rn % 2 = 1;", "generated_sql": "SELECT AVG(population) FROM cities ORDER BY designation_date;", "raw_model_output": "\n\nThe provided schema does not include a column indicating whether a city has a UNESCO World Heritage designation. Therefore, it is not possible to accurately determine which cities qualify for this query based on the given table structure. However, if we assume all cities in the table have the designation (despite the lack of explicit data), the SQL would be:\n\n```sql\nSELECT AVG(population) FROM cities ORDER BY designation_date;\n```\n\n**Note:** This query assumes all cities in the table have the UNESCO designation, which is not explicitly stated in the schema. The `ORDER BY` clause is included as per the question's request, though the result of an aggregate function like `AVG` is a single value and does not require ordering.", "latency_sec": 7.129862308502197, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 181, "prompt_eval_sec": null, "tokens_completion": 1083, "completion_eval_sec": null, "tokens_total": 1264, "tokens_per_sec": 177.2825259882942, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the average population of cities in the 'heritagesites' table, ordered by designation_date, and only considers odd-numbered rows (using ROW_NUMBER()). The Generated SQL calculates the average population of all cities, ordered by designation_date, but this ordering has no effect on the average value. The two queries differ in both the dataset considered (heritagesites vs. all cities) and the aggregation logic (subset selection via row numbers vs. full dataset average).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query is technically incorrect because it references a non-existent 'heritagesites' table, which is not part of the provided schema. The generated query is also incorrect as it lacks a WHERE clause to filter cities with UNESCO designations. However, the generated query's structure is simpler and avoids the invalid table reference. Neither query correctly addresses the business intent of filtering for UNESCO-designated cities, but the generated query's error is less severe (missing filter vs. invalid schema reference).", "overall_assessment": "incorrect"}}
{"example_id": 3786, "sql_complexity": "aggregation", "prompt": "Display the names and average co-owner percentages for all properties in the 'property_coownership' table where the co-owner percentage is greater than 60.", "context": "CREATE TABLE property_coownership (property_id INT, owner VARCHAR(255), percentage INT); INSERT INTO property_coownership (property_id, owner, percentage) VALUES (1, 'Mohammed', 70), (1, 'Fatima', 30), (2, 'Jamal', 65), (2, 'Aisha', 35), (3, 'Ali', 75), (3, 'Khadija', 25);", "reference_sql": "SELECT owner, AVG(percentage) FROM property_coownership WHERE percentage > 60 GROUP BY owner;", "generated_sql": "SELECT p.owner, a.avg_percentage\nFROM property_coownership p\nJOIN (\n    SELECT property_id, AVG(percentage) AS avg_percentage\n    FROM property_coownership\n    GROUP BY property_id\n) a ON p.property_id = a.property_id\nWHERE p.property_id IN (\n    SELECT DISTINCT property_id\n    FROM property_coownership\n    WHERE percentage > 60\n);", "raw_model_output": "\n\nTo retrieve the **names of co-owners** and the **average co-owner percentage** for all **properties** where **at least one co-owner has a percentage greater than 60**, we need to:\n\n1. **Identify properties** that have at least one co-owner with a percentage > 60.\n2. **Calculate the average percentage** of co-owners per property.\n3. **Join** the original table with the average percentages.\n4. **Filter** only those properties that meet the condition.\n\n---\n\n### \u2705 Final SQL Query\n\n```sql\nSELECT p.owner, a.avg_percentage\nFROM property_coownership p\nJOIN (\n    SELECT property_id, AVG(percentage) AS avg_percentage\n    FROM property_coownership\n    GROUP BY property_id\n) a ON p.property_id = a.property_id\nWHERE p.property_id IN (\n    SELECT DISTINCT property_id\n    FROM property_coownership\n    WHERE percentage > 60\n);\n```\n\n---\n\n### \ud83d\udccc Explanation\n\n- **Subquery `a`** computes the average percentage of co-owners per property.\n- **Subquery in `WHERE`** identifies all `property_id`s that have at least one co-owner with a percentage > 60.\n- The **main query** joins the original table with the average percentages and filters only those properties that meet the condition.\n- The result includes **each co-owner's name** and the **average percentage** of their property.\n\n---\n\n### \ud83e\uddfe Sample Output (based on provided data)\n\n| owner    | avg_percentage |\n|----------|----------------|\n| Mohammed | 50             |\n| Fatima   | 50             |\n| Jamal    | 50             |\n| Aisha    | 50             |\n| Ali      | 50             |\n| Khadija  | 50             |\n\nThis output reflects all co-owners of properties where **at least one co-owner has a percentage > 60**, along with the average percentage of their respective properties.", "latency_sec": 17.326905012130737, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 201, "prompt_eval_sec": null, "tokens_completion": 2675, "completion_eval_sec": null, "tokens_total": 2876, "tokens_per_sec": 165.9846347623239, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the average percentage per owner where their individual percentage exceeds 60, while the Generated SQL computes property-level averages and includes all owners from properties with at least one owner exceeding 60. The grouping and filtering logic differ, leading to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL groups by 'owner' and calculates the average percentage for owners with individual percentages >60, which misaligns with the question's focus on properties. The Generated SQL correctly identifies properties with at least one co-owner >60% and calculates the average percentage per property, aligning better with the business intent. While both are syntactically correct, the Generated query addresses the property-level requirement more accurately.", "overall_assessment": "differently_correct"}}
{"example_id": 2357, "sql_complexity": "basic SQL", "prompt": "What is the total amount of climate finance invested in renewable energy projects by public and private sectors in Africa?", "context": "CREATE TABLE renewable_energy_projects (project_id INT, sector TEXT, investor_type TEXT, region TEXT, amount FLOAT); INSERT INTO renewable_energy_projects (project_id, sector, investor_type, region, amount) VALUES (1, 'Renewable Energy', 'Public', 'Africa', 5000000); INSERT INTO renewable_energy_projects (project_id, sector, investor_type, region, amount) VALUES (2, 'Renewable Energy', 'Private', 'Africa', 7000000);", "reference_sql": "SELECT SUM(amount) FROM renewable_energy_projects WHERE sector = 'Renewable Energy' AND region = 'Africa';", "generated_sql": "SELECT SUM(amount) FROM renewable_energy_projects WHERE region = 'Africa' AND investor_type IN ('Public', 'Private') AND sector = 'Renewable Energy';", "raw_model_output": "\n\nSELECT SUM(amount) FROM renewable_energy_projects WHERE region = 'Africa' AND investor_type IN ('Public', 'Private') AND sector = 'Renewable Energy';", "latency_sec": 5.112208127975464, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 200, "prompt_eval_sec": null, "tokens_completion": 643, "completion_eval_sec": null, "tokens_total": 843, "tokens_per_sec": 164.89938963690918, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL sums amounts for all 'Renewable Energy' projects in Africa regardless of investor_type. The Generated SQL adds an explicit filter for investor_type IN ('Public', 'Private'). While the sample data matches, the Generated SQL would exclude projects with other investor_types (e.g., 'Government', 'NGO') that might exist in the full dataset, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The Reference SQL omits the investor_type filter, which is critical to the business question. While both filter for 'Renewable Energy' and 'Africa', the Reference SQL would include all investor types (e.g., public, private, NGOs, etc.) whereas the Generated SQL explicitly restricts to 'Public' and 'Private' sectors as required. The Generated SQL directly addresses the business intent by incorporating the investor_type condition, ensuring only the specified sectors are included. The Reference SQL would overcount if other investor types exist in the dataset. Both queries are efficient, but the Generated SQL is more precise in fulfilling the original question's requirements.", "overall_assessment": "differently_correct"}}
{"example_id": 1009, "sql_complexity": "multiple_joins", "prompt": "Find the number of IoT sensors installed in each farm that use Sprinkler irrigation.", "context": "CREATE TABLE IoT_Sensors (id INT, sensor_type VARCHAR(50), Farm_id INT); INSERT INTO IoT_Sensors (id, sensor_type, Farm_id) VALUES (1, 'Soil Moisture', 1), (2, 'Temperature', 1), (3, 'Humidity', 2); CREATE TABLE Irrigation (id INT, Farm_id INT, irrigation_type VARCHAR(50), duration INT); INSERT INTO Irrigation (id, Farm_id, irrigation_type, duration) VALUES (1, 1, 'Sprinkler', 30), (2, 2, 'Drip', 45);", "reference_sql": "SELECT f.id, COUNT(s.id) FROM Farmers f JOIN Irrigation i ON f.id = i.Farm_id JOIN IoT_Sensors s ON f.id = s.Farm_id WHERE i.irrigation_type = 'Sprinkler' GROUP BY f.id;", "generated_sql": "SELECT s.Farm_id, COUNT(*) AS num_sensors\nFROM IoT_Sensors s\nWHERE s.Farm_id IN (\n    SELECT i.Farm_id\n    FROM Irrigation i\n    WHERE i.irrigation_type = 'Sprinkler'\n)\nGROUP BY s.Farm_id;", "raw_model_output": "\n\nTo determine the number of IoT sensors installed in each farm that uses **Sprinkler** irrigation, we need to:\n\n1. Identify all farms that have at least one **Sprinkler** irrigation entry.\n2. Count the number of IoT sensors in each of those farms.\n\nThis can be achieved by using a **subquery** to filter the farms with **Sprinkler** irrigation and then **grouping** the IoT sensors by `Farm_id`.\n\n---\n\n### \u2705 SQL Query\n\n```sql\nSELECT s.Farm_id, COUNT(*) AS num_sensors\nFROM IoT_Sensors s\nWHERE s.Farm_id IN (\n    SELECT i.Farm_id\n    FROM Irrigation i\n    WHERE i.irrigation_type = 'Sprinkler'\n)\nGROUP BY s.Farm_id;\n```\n\n---\n\n### \ud83d\udccc Explanation\n\n- **Subquery**: `SELECT i.Farm_id FROM Irrigation WHERE irrigation_type = 'Sprinkler'` retrieves all farm IDs that use **Sprinkler** irrigation.\n- **Main Query**: Filters `IoT_Sensors` to only include sensors from those farms and counts them per `Farm_id`.\n- **GROUP BY**: Ensures the count is grouped by each farm.\n\nThis approach avoids overcounting in cases where a farm might have multiple **Sprinkler** irrigation entries.", "latency_sec": 10.88008975982666, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 220, "prompt_eval_sec": null, "tokens_completion": 1477, "completion_eval_sec": null, "tokens_total": 1697, "tokens_per_sec": 155.97297793129937, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL joins Farmers, Irrigation, and IoT_Sensors, leading to a count of sensors multiplied by the number of Sprinkler irrigation entries per farmer (due to Cartesian product in joins). The Generated SQL counts sensors directly per Farm_id where the Farm has at least one Sprinkler irrigation, without multiplying by irrigation entries. This results in different aggregation outcomes.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count IoT sensors per farm using Sprinkler irrigation. The reference query redundantly joins the Farmers table (which isn't needed since Farm_id exists directly in IoT_Sensors and Irrigation). The generated query uses a subquery to filter farms with Sprinkler irrigation first, then counts sensors in those farms. While both produce identical results, the generated query is more efficient by avoiding unnecessary joins and directly targeting the required data.", "overall_assessment": "differently_correct"}}
{"example_id": 4217, "sql_complexity": "subqueries", "prompt": "Show consumer preference data for foundations, excluding products from the USA.", "context": "CREATE TABLE cosmetics (product_id INT, product_name VARCHAR(100), product_type VARCHAR(50), is_cruelty_free BOOLEAN, consumer_preference_score INT); INSERT INTO cosmetics (product_id, product_name, product_type, is_cruelty_free, consumer_preference_score) VALUES (1, 'Lipstick A', 'Lipstick', TRUE, 80), (2, 'Foundation B', 'Foundation', FALSE, 90), (3, 'Mascara C', 'Mascara', TRUE, 85), (4, 'Eyeshadow D', 'Eyeshadow', TRUE, 70), (5, 'Blush E', 'Blush', FALSE, 95); CREATE TABLE ingredient_sourcing (ingredient_id INT, ingredient_name VARCHAR(100), sourcing_country VARCHAR(50), is_organic BOOLEAN); INSERT INTO ingredient_sourcing (ingredient_id, ingredient_name, sourcing_country, is_organic) VALUES (1, 'Rosehip Oil', 'Chile', TRUE), (2, 'Shea Butter', 'Ghana', TRUE), (3, 'Jojoba Oil', 'India', TRUE), (4, 'Coconut Oil', 'Philippines', FALSE), (5, 'Aloe Vera', 'USA', TRUE);", "reference_sql": "SELECT * FROM cosmetics WHERE product_type = 'Foundation' AND product_id NOT IN (SELECT cosmetics.product_id FROM cosmetics INNER JOIN ingredient_sourcing ON cosmetics.product_id = ingredient_sourcing.ingredient_id WHERE ingredient_sourcing.sourcing_country = 'USA');", "generated_sql": "SELECT product_id, product_name, product_type, is_cruelty_free, consumer_preference_score\nFROM cosmetics\nWHERE product_type = 'Foundation';", "raw_model_output": "\n\nThe question asks for consumer preference data for foundations while excluding products from the USA. However, based on the provided schema, the `cosmetics` table does not contain a `sourcing_country` field, and there is no explicit relationship (e.g., foreign key) between the `cosmetics` and `ingredient_sourcing` tables. This makes it impossible to directly link product data with sourcing country information.\n\nIf we strictly adhere to the schema, the only actionable part of the query is filtering `cosmetics` by `product_type = 'Foundation'`. The exclusion of \"products from the USA\" cannot be fulfilled with the current schema.\n\n### Final SQL:\n```sql\nSELECT product_id, product_name, product_type, is_cruelty_free, consumer_preference_score\nFROM cosmetics\nWHERE product_type = 'Foundation';\n```\n\n**Note:** The exclusion of \"products from the USA\" cannot be implemented due to missing schema elements.", "latency_sec": 7.041399002075195, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 357, "prompt_eval_sec": null, "tokens_completion": 1077, "completion_eval_sec": null, "tokens_total": 1434, "tokens_per_sec": 203.6527115673151, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes an additional filter using NOT IN with a subquery that excludes products linked to ingredients sourced from the USA. The Generated SQL lacks this filter, so they are not semantically equivalent. While in the provided data the Foundation product (product_id 2) isn't excluded, the logic differs in general cases where such exclusions might apply.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent. The reference query attempts to exclude products with USA-sourced ingredients but contains a critical logical error: it joins cosmetics.product_id (product identifier) with ingredient_sourcing.ingredient_id (ingredient identifier), which are unrelated columns. This makes the subquery invalid and the exclusion logic incorrect. The generated query fails to address the exclusion requirement entirely, returning all foundations without filtering. While neither query fully meets the business intent, the reference query demonstrates a closer attempt to address the exclusion criterion, albeit with a flawed implementation. The generated query completely ignores the 'exclude USA' requirement, making it less aligned with the original question.", "overall_assessment": "differently_correct"}}
{"example_id": 5620, "sql_complexity": "basic SQL", "prompt": "What is the recycling rate of plastic in the residential sector in the state of New York?", "context": "CREATE TABLE recycling_rates_city (sector VARCHAR(20), city VARCHAR(20), material VARCHAR(20), recycling_rate DECIMAL(5,2)); INSERT INTO recycling_rates_city (sector, city, material, recycling_rate) VALUES ('residential', 'New York City', 'plastic', 0.25), ('commercial', 'New York City', 'plastic', 0.30), ('residential', 'New York City', 'paper', 0.45), ('commercial', 'New York City', 'paper', 0.50), ('residential', 'Los Angeles', 'plastic', 0.20), ('commercial', 'Los Angeles', 'plastic', 0.35), ('residential', 'Los Angeles', 'paper', 0.40), ('commercial', 'Los Angeles', 'paper', 0.50);", "reference_sql": "SELECT recycling_rate FROM recycling_rates_city WHERE sector = 'residential' AND material = 'plastic' AND city = 'New York City';", "generated_sql": "SELECT recycling_rate FROM recycling_rates_city WHERE sector = 'residential' AND city = 'New York City' AND material = 'plastic';", "raw_model_output": "\n\nSELECT recycling_rate FROM recycling_rates_city WHERE sector = 'residential' AND city = 'New York City' AND material = 'plastic';", "latency_sec": 2.4326488971710205, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 277, "prompt_eval_sec": null, "tokens_completion": 344, "completion_eval_sec": null, "tokens_total": 621, "tokens_per_sec": 255.27728260423203, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The two queries are semantically equivalent because the order of conditions in the WHERE clause does not affect the result. Both queries filter for 'residential' sector, 'plastic' material, and 'New York City' city, producing the same output.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are syntactically and semantically equivalent. The order of conditions in the WHERE clause does not affect the result. Both correctly filter for 'residential' sector, 'plastic' material, and 'New York City' to retrieve the recycling rate. The business intent is fully addressed by both queries as they directly answer the specific question about New York's residential plastic recycling rate.", "overall_assessment": "correct"}}
{"example_id": 3151, "sql_complexity": "basic SQL", "prompt": "List all biotech startups that received funding in 2022 and their respective funding amounts.", "context": "CREATE TABLE biotech_startups (name TEXT, funding FLOAT, date DATE); INSERT INTO biotech_startups (name, funding, date) VALUES ('StartupA', 3500000, '2022-02-28'); INSERT INTO biotech_startups (name, funding, date) VALUES ('StartupB', 4500000, '2022-07-12');", "reference_sql": "SELECT name, funding FROM biotech_startups WHERE date BETWEEN '2022-01-01' AND '2022-12-31';", "generated_sql": "SELECT name, funding FROM biotech_startups WHERE EXTRACT(YEAR FROM date) = 2022;", "raw_model_output": "\n\nSELECT name, funding FROM biotech_startups WHERE EXTRACT(YEAR FROM date) = 2022;", "latency_sec": 2.4709601402282715, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 184, "prompt_eval_sec": null, "tokens_completion": 373, "completion_eval_sec": null, "tokens_total": 557, "tokens_per_sec": 225.41844804851584, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select records where the date falls in the year 2022. The BETWEEN clause explicitly checks for dates between '2022-01-01' and '2022-12-31' (inclusive), while EXTRACT(YEAR FROM date) = 2022 achieves the same by checking the year component. Since all dates in 2022 will satisfy both conditions, the results are identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically correct and produce identical results. The reference query uses a date range filter (BETWEEN '2022-01-01' AND '2022-12-31') which explicitly captures all dates in 2022. The generated query uses EXTRACT(YEAR FROM date) = 2022, which achieves the same outcome by isolating the year component. Both satisfy the business intent of identifying 2022 funding events. However, the reference query may be more efficient in databases with indexed date columns, as it allows for range scans. The generated query is more explicit about the year condition but may require additional computation. Neither query has a clear advantage in terms of correctness or business alignment, making them functionally equivalent.", "overall_assessment": "correct"}}
{"example_id": 2136, "sql_complexity": "window functions", "prompt": "What is the total military equipment sales revenue for each sales representative by fiscal year?", "context": "CREATE TABLE SalesReps (SalesRepID INT, SalesRepName VARCHAR(50), FiscalYear INT, Revenue DECIMAL(10,2)); INSERT INTO SalesReps (SalesRepID, SalesRepName, FiscalYear, Revenue) VALUES (1, 'John Doe', 2020, 150000.00), (2, 'Jane Smith', 2020, 200000.00), (1, 'John Doe', 2021, 180000.00), (2, 'Jane Smith', 2021, 250000.00);", "reference_sql": "SELECT SalesRepName, FiscalYear, SUM(Revenue) OVER (PARTITION BY SalesRepName ORDER BY FiscalYear) AS TotalRevenue FROM SalesReps;", "generated_sql": "SELECT SalesRepName, FiscalYear, SUM(Revenue) AS TotalRevenue\nFROM SalesReps\nGROUP BY SalesRepName, FiscalYear;", "raw_model_output": "\n\nThe provided schema does not include a column or table that explicitly tracks \"military equipment\" sales. Assuming the `Revenue` column in the `SalesReps` table represents military equipment sales revenue (as no other context is provided), the SQL query to calculate the total revenue per sales representative by fiscal year is:\n\n```sql\nSELECT SalesRepName, FiscalYear, SUM(Revenue) AS TotalRevenue\nFROM SalesReps\nGROUP BY SalesRepName, FiscalYear;\n```", "latency_sec": 5.2704010009765625, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 234, "prompt_eval_sec": null, "tokens_completion": 609, "completion_eval_sec": null, "tokens_total": 843, "tokens_per_sec": 159.94987854696424, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates a running total (cumulative sum) of Revenue for each SalesRep over FiscalYears, while the Generated SQL aggregates Revenue per SalesRep and FiscalYear. The Reference retains individual rows with cumulative values, whereas the Generated SQL collapses rows into per-year totals. For example, John Doe's 2021 row in Reference would show 150000+180000=330000, while Generated would show 180000 alone.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL uses a window function that calculates a running total (cumulative sum) across fiscal years for each sales representative, which does not align with the requirement for 'total revenue for each sales representative by fiscal year.' The Generated SQL correctly groups by SalesRepName and FiscalYear, aggregating revenues to produce the exact total per sales rep per year. While both queries might return identical results for the sample data (where each sales rep has one entry per year), the Generated SQL is technically correct for all scenarios. The Reference SQL would incorrectly show cumulative totals if multiple entries exist per sales rep/year.", "overall_assessment": "differently_correct"}}
{"example_id": 5452, "sql_complexity": "basic SQL", "prompt": "What is the name of the farms with a size greater than 150 acres located in 'Texas'?", "context": "CREATE TABLE farms (id INT PRIMARY KEY, name VARCHAR(50), size INT, location VARCHAR(50)); INSERT INTO farms (id, name, size, location) VALUES (1, 'Smith Farms', 200, 'Texas'), (2, 'Johnson Farms', 100, 'California');", "reference_sql": "SELECT name FROM farms WHERE size > 150 AND location = 'Texas'", "generated_sql": "SELECT name FROM farms WHERE size > 150 AND location = 'Texas';", "raw_model_output": "\n\nSELECT name FROM farms WHERE size > 150 AND location = 'Texas';", "latency_sec": 2.498065948486328, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 160, "prompt_eval_sec": null, "tokens_completion": 247, "completion_eval_sec": null, "tokens_total": 407, "tokens_per_sec": 162.92604294398896, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. The only difference is the presence of a trailing semicolon in the Generated SQL, which does not affect query execution or results. Both select the 'name' column from the 'farms' table where size > 150 and location is 'Texas'.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "The reference and generated queries are identical in structure, logic, and conditions. Both correctly filter farms with size > 150 acres located in 'Texas' using the same WHERE clause. The queries are syntactically identical, produce identical results, and address the business question directly. No differences exist in efficiency, elegance, or semantic meaning.", "overall_assessment": "correct"}}
{"example_id": 5152, "sql_complexity": "aggregation", "prompt": "How many international tourists visited Portugal in 2020, broken down by continent?", "context": "CREATE TABLE international_tourists(tourist_id INT, country TEXT, arrival_year INT, continent TEXT);INSERT INTO international_tourists (tourist_id, country, arrival_year, continent) VALUES (1, 'Spain', 2020, 'Europe'), (2, 'France', 2020, 'Europe'), (3, 'Brazil', 2020, 'South America'), (4, 'United States', 2020, 'North America'), (5, 'China', 2020, 'Asia');", "reference_sql": "SELECT continent, COUNT(*) FROM international_tourists WHERE arrival_year = 2020 GROUP BY continent;", "generated_sql": "SELECT continent, COUNT(*) AS num_tourists\nFROM international_tourists\nWHERE country = 'Portugal' AND arrival_year = 2020\nGROUP BY continent;", "raw_model_output": "\n\nSELECT continent, COUNT(*) AS num_tourists\nFROM international_tourists\nWHERE country = 'Portugal' AND arrival_year = 2020\nGROUP BY continent;", "latency_sec": 2.9655709266662598, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 207, "prompt_eval_sec": null, "tokens_completion": 457, "completion_eval_sec": null, "tokens_total": 664, "tokens_per_sec": 223.90292338967396, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL counts all tourists from 2020 grouped by continent, while the Generated SQL filters for 'Portugal' (which doesn't exist in the data) and arrival_year=2020. Since there are no tourists from Portugal, the Generated SQL returns an empty result set, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is incorrect because it does not filter for tourists from Portugal (country = 'Portugal'). It counts all international tourists in 2020 regardless of their origin. The Generated SQL correctly filters for tourists from Portugal (country = 'Portugal') and groups by continent, which aligns with the business question. However, the Generated SQL's logic depends on the 'country' column representing the tourist's origin. If 'country' instead represented the destination, neither query would be correct. Assuming 'country' is the origin, the Generated SQL technically fulfills the intent but would fail if the schema's 'country' column actually refers to the destination. The Reference SQL fails to address the 'Portugal' filter entirely.", "overall_assessment": "differently_correct"}}
{"example_id": 2477, "sql_complexity": "set operations", "prompt": "What is the carbon price in Europe and Australia for the last quarter of 2020?", "context": "CREATE TABLE CarbonPrices (Country TEXT, Year INT, Quarter INT, CarbonPrice NUMBER); INSERT INTO CarbonPrices (Country, Year, Quarter, CarbonPrice) VALUES ('Europe', 2020, 4, 25), ('Australia', 2020, 4, 15); CREATE TABLE CarbonTaxes (Country TEXT, Year INT, Quarter INT, CarbonPrice NUMBER); INSERT INTO CarbonTaxes (Country, Year, Quarter, CarbonPrice) VALUES ('Europe', 2019, 4, 20), ('Australia', 2019, 4, 10);", "reference_sql": "SELECT Context.Country, Context.CarbonPrice FROM ( SELECT * FROM CarbonPrices WHERE CarbonPrices.Country IN ('Europe', 'Australia') AND CarbonPrices.Year = 2020 AND CarbonPrices.Quarter = 4 UNION SELECT * FROM CarbonTaxes WHERE CarbonTaxes.Country IN ('Europe', 'Australia') AND CarbonTaxes.Year = 2020 AND CarbonTaxes.Quarter = 4 ) AS Context;", "generated_sql": "SELECT Country, CarbonPrice FROM CarbonPrices WHERE Year = 2020 AND Quarter = 4 AND Country IN ('Europe', 'Australia');", "raw_model_output": "\n\nSELECT Country, CarbonPrice FROM CarbonPrices WHERE Year = 2020 AND Quarter = 4 AND Country IN ('Europe', 'Australia');", "latency_sec": 3.271665096282959, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 222, "prompt_eval_sec": null, "tokens_completion": 455, "completion_eval_sec": null, "tokens_total": 677, "tokens_per_sec": 206.92827049112114, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL combines data from both CarbonPrices and CarbonTaxes tables using UNION, while the Generated SQL only queries the CarbonPrices table. Although in the provided sample data CarbonTaxes has no matching rows for 2020 Q4, the queries would differ if CarbonTaxes contained relevant data. The Generated SQL excludes CarbonTaxes entirely, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query incorrectly combines CarbonPrices and CarbonTaxes tables, implying carbon taxes are equivalent to carbon prices (a potential business logic error). The generated query directly targets the CarbonPrices table, which contains the relevant 2020 Q4 data for both countries. While the reference query would return same results in this specific dataset (since CarbonTaxes has no 2020 Q4 entries), it's less precise semantically. The generated query is more efficient, directly addressing the business intent without unnecessary complexity.", "overall_assessment": "differently_correct"}}
{"example_id": 4573, "sql_complexity": "subqueries", "prompt": "Find the names of all the indigenous communities in the 'Arctic_Communities' table that have a population size greater than the average population size in the 'Antarctic_Communities' table.", "context": "CREATE TABLE Arctic_Communities (name TEXT, population INTEGER); CREATE TABLE Antarctic_Communities (name TEXT, population INTEGER);", "reference_sql": "SELECT name FROM Arctic_Communities WHERE Arctic_Communities.population > (SELECT AVG(population) FROM Antarctic_Communities)", "generated_sql": "SELECT name FROM Arctic_Communities WHERE population > (SELECT AVG(population) FROM Antarctic_Communities);", "raw_model_output": "\n\nSELECT name FROM Arctic_Communities WHERE population > (SELECT AVG(population) FROM Antarctic_Communities);", "latency_sec": 1.9980649948120117, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 133, "prompt_eval_sec": null, "tokens_completion": 277, "completion_eval_sec": null, "tokens_total": 410, "tokens_per_sec": 205.19853011016536, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select names from Arctic_Communities where population exceeds the average population of Antarctic_Communities. The generated query omits the table alias in the WHERE clause, but since the column 'population' is unambiguous (only exists in Arctic_Communities), the semantic meaning remains identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically correct and semantically equivalent. The reference query explicitly qualifies the population column with the table name, while the generated query relies on column uniqueness in the context. Both correctly calculate the average population from Antarctic_Communities and compare it to Arctic_Communities' population. The generated query is more concise and elegant without sacrificing clarity or correctness. Both fulfill the business intent of identifying Arctic communities exceeding the Antarctic average.", "overall_assessment": "correct"}}
{"example_id": 3596, "sql_complexity": "window functions", "prompt": "What is the total revenue for each game in the \"Gaming\" category?", "context": "CREATE TABLE Games (GameID int, GameName varchar(50), Category varchar(50), Revenue decimal(10,2));", "reference_sql": "SELECT Category, SUM(Revenue) OVER(PARTITION BY Category) as TotalRevenue FROM Games;", "generated_sql": "SELECT GameName, SUM(Revenue) AS TotalRevenue\nFROM Games\nWHERE Category = 'Gaming'\nGROUP BY GameID, GameName;", "raw_model_output": "\n\nSELECT GameName, SUM(Revenue) AS TotalRevenue\nFROM Games\nWHERE Category = 'Gaming'\nGROUP BY GameID, GameName;", "latency_sec": 7.475664854049683, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 115, "prompt_eval_sec": null, "tokens_completion": 1142, "completion_eval_sec": null, "tokens_total": 1257, "tokens_per_sec": 168.14557962949124, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates the total revenue per category using a window function, returning Category and TotalRevenue for all games. The generated query filters for 'Gaming' category, groups by GameID/Name, and sums revenue per game (not per category), resulting in different columns, filtering, and aggregation logic.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL calculates total revenue per category (not per game) using a window function, which would return the same category total for every row in the 'Gaming' category. It also lacks the WHERE clause to filter only 'Gaming' category games. The Generated SQL correctly groups by GameID/GameName, filters for 'Gaming', and sums revenue per game. While both queries fail to explicitly filter the category in the Reference SQL, the Generated SQL better addresses the business intent of aggregating revenue at the game level within the specified category.", "overall_assessment": "differently_correct"}}
{"example_id": 5039, "sql_complexity": "subqueries", "prompt": "What is the total number of community policing events in 'City Park' in 2021?", "context": "CREATE TABLE locations (id INT, name VARCHAR(255)); CREATE TABLE community_policing (id INT, location_id INT, year INT, events INT); INSERT INTO locations (id, name) VALUES (1, 'City Park'); INSERT INTO community_policing (id, location_id, year, events) VALUES (1, 1, 2021, 5);", "reference_sql": "SELECT SUM(events) FROM community_policing WHERE location_id = (SELECT id FROM locations WHERE name = 'City Park') AND year = 2021;", "generated_sql": "SELECT SUM(events) FROM community_policing WHERE location_id = (SELECT id FROM locations WHERE name = 'City Park') AND year = 2021;", "raw_model_output": "\n\nSELECT SUM(events) FROM community_policing WHERE location_id = (SELECT id FROM locations WHERE name = 'City Park') AND year = 2021;", "latency_sec": 5.579330921173096, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 173, "prompt_eval_sec": null, "tokens_completion": 795, "completion_eval_sec": null, "tokens_total": 968, "tokens_per_sec": 173.49750600498004, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure and logic. Both queries select the sum of 'events' from 'community_policing' where the location_id matches the id of the 'City Park' location (via a subquery) and the year is 2021. Since the queries are exactly the same, they will produce identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "The reference and generated queries are identical in structure and logic. Both correctly calculate the total community policing events for 'City Park' in 2021 by: 1) using a subquery to map 'City Park' to its location_id, 2) filtering by year = 2021, and 3) summing the events column. The queries are semantically equivalent, technically correct, and fully address the business intent. Neither query demonstrates superior efficiency or elegance as they are identical.", "overall_assessment": "correct"}}
{"example_id": 2724, "sql_complexity": "basic SQL", "prompt": "What is the earliest installation date for solar panels in Italy?", "context": "CREATE TABLE solar_panels_italy (id INT, installation_date DATE); INSERT INTO solar_panels_italy (id, installation_date) VALUES (1, '2018-01-01'), (2, '2019-01-01'), (3, '2020-01-01');", "reference_sql": "SELECT MIN(installation_date) as earliest_date FROM solar_panels_italy;", "generated_sql": "SELECT MIN(installation_date) FROM solar_panels_italy;", "raw_model_output": "\n\nSELECT MIN(installation_date) FROM solar_panels_italy;", "latency_sec": 1.4570081233978271, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 158, "prompt_eval_sec": null, "tokens_completion": 210, "completion_eval_sec": null, "tokens_total": 368, "tokens_per_sec": 252.57237354435796, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the minimum installation_date from the solar_panels_italy table. The only difference is the column alias ('earliest_date' vs. no alias), which does not affect the semantic result. The actual value returned by the MIN() function remains identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly retrieve the earliest installation date using the MIN() aggregate function. The reference query adds an explicit alias ('earliest_date'), while the generated query omits it. However, this difference does not affect the result's correctness or semantic meaning. The business intent of identifying the earliest date is fully satisfied by both. Efficiency is identical since both queries perform a simple aggregation on a single column. The choice between them is stylistic, with no functional or performance advantage to either.", "overall_assessment": "correct"}}
{"example_id": 2200, "sql_complexity": "single join", "prompt": "Which diversity programs are currently being participated in by employees in the HR department?", "context": "CREATE TABLE Employees (Employee_ID INT, First_Name VARCHAR(20), Last_Name VARCHAR(20), Department VARCHAR(20), Salary DECIMAL(10,2), Date_Hired DATE); CREATE TABLE Diversity_Programs (Program_ID INT, Program_Name VARCHAR(50), Participant_ID INT, Date_Started DATE, Date_Ended DATE);", "reference_sql": "SELECT dp.Program_Name FROM Diversity_Programs dp JOIN Employees e ON dp.Participant_ID = e.Employee_ID WHERE e.Department = 'HR' AND dp.Date_Ended IS NULL;", "generated_sql": "SELECT DISTINCT DP.Program_Name\nFROM Diversity_Programs DP\nJOIN Employees E ON DP.Participant_ID = E.Employee_ID\nWHERE E.Department = 'HR'\nAND (DP.Date_Ended IS NULL OR DP.Date_Ended >= CURRENT_DATE);", "raw_model_output": "\n\nSELECT DISTINCT DP.Program_Name\nFROM Diversity_Programs DP\nJOIN Employees E ON DP.Participant_ID = E.Employee_ID\nWHERE E.Department = 'HR'\nAND (DP.Date_Ended IS NULL OR DP.Date_Ended >= CURRENT_DATE);", "latency_sec": 10.681068658828735, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 158, "prompt_eval_sec": null, "tokens_completion": 1556, "completion_eval_sec": null, "tokens_total": 1714, "tokens_per_sec": 160.47083440318917, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their Date_Ended condition. The Reference query checks for NULL only, while the Generated query includes NULL OR Date_Ended >= CURRENT_DATE. This makes the Generated query broader, potentially returning more rows. Additionally, the Generated query uses DISTINCT which could further alter results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in their handling of the Date_Ended condition. The reference query only checks for NULL (assuming 'not ended yet'), while the generated query includes both NULL and future dates (Date_Ended >= CURRENT_DATE), which better captures 'currently being participated in' by accounting for potential future end dates. The generated query also uses DISTINCT to avoid duplicate program names, which aligns with the business intent of listing unique programs. Although the reference query is simpler, the generated query's logic is more comprehensive for real-world data scenarios where Date_Ended might store future dates. Both queries correctly join on Employee_ID, but the generated query's condition is more robust for the stated intent.", "overall_assessment": "differently_correct"}}
{"example_id": 4359, "sql_complexity": "window functions", "prompt": "Which destinations have the least hotel awards?", "context": "CREATE TABLE Destinations (destination_id INT, destination_name TEXT, country TEXT, awards INT); INSERT INTO Destinations (destination_id, destination_name, country, awards) VALUES (1, 'City A', 'Germany', 3), (2, 'City B', 'Switzerland', 5), (3, 'City C', 'Norway', 2);", "reference_sql": "SELECT destination_name, country, awards, RANK() OVER (PARTITION BY country ORDER BY awards ASC) AS rank FROM Destinations;", "generated_sql": "SELECT destination_name FROM Destinations WHERE awards = (SELECT MIN(awards) FROM Destinations);", "raw_model_output": "\n\nSELECT destination_name FROM Destinations WHERE awards = (SELECT MIN(awards) FROM Destinations);", "latency_sec": 2.35882306098938, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 154, "prompt_eval_sec": null, "tokens_completion": 357, "completion_eval_sec": null, "tokens_total": 511, "tokens_per_sec": 216.63345947858727, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates rankings within each country based on awards, while the Generated SQL retrieves destinations with the globally minimum awards. The first returns ranked rows with multiple columns, the second returns a subset of destinations. They perform different operations and produce different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query ranks destinations within each country by awards, which doesn't directly answer 'which destinations have the least hotel awards' as it focuses on relative ranking rather than absolute minimum values. The generated query correctly identifies destinations with the minimum awards using a subquery. While both queries are technically valid, they differ in output structure and logic: the reference includes ranking information while the generated query focuses on absolute minimums. The generated query better fulfills the business intent of finding destinations with the least awards.", "overall_assessment": "correct"}}
{"example_id": 1373, "sql_complexity": "subqueries", "prompt": "What is the total value of military equipment sales to Africa in the last 12 months?", "context": "CREATE TABLE Military_Equipment_Sales(sale_id INT, sale_date DATE, equipment_type VARCHAR(50), country VARCHAR(50), sale_value DECIMAL(10,2));", "reference_sql": "SELECT SUM(sale_value) FROM Military_Equipment_Sales WHERE country IN (SELECT country FROM World_Countries WHERE continent = 'Africa') AND sale_date >= DATE_SUB(CURRENT_DATE, INTERVAL 12 MONTH);", "generated_sql": "SELECT SUM(sale_value) FROM Military_Equipment_Sales WHERE country = 'Africa' AND sale_date >= CURRENT_DATE - INTERVAL '12' MONTH AND sale_date <= CURRENT_DATE;", "raw_model_output": "\n\nSELECT SUM(sale_value) FROM Military_Equipment_Sales WHERE country = 'Africa' AND sale_date >= CURRENT_DATE - INTERVAL '12' MONTH AND sale_date <= CURRENT_DATE;", "latency_sec": 7.590638875961304, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 128, "prompt_eval_sec": null, "tokens_completion": 1115, "completion_eval_sec": null, "tokens_total": 1243, "tokens_per_sec": 163.75433218624596, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their country filtering logic. The reference query uses a subquery to select countries in Africa from World_Countries, while the generated query directly checks for country = 'Africa'. This assumes 'Africa' is a valid country name (unlikely) and excludes other African countries. Additionally, the generated query adds an explicit sale_date <= CURRENT_DATE condition, which the reference query lacks. These differences in filtering criteria make the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ fundamentally in how they identify African countries. The reference query correctly uses a subquery to find all countries in Africa from the World_Countries table, ensuring it captures all relevant sales. The generated query incorrectly filters WHERE country = 'Africa', which would only match sales explicitly labeled as 'Africa' (a continent, not a country). Additionally, the generated query's date condition is technically correct but redundant (sale_date <= CURRENT_DATE is implied by the >= condition). While both calculate sums correctly, the generated query's logic fails to address the business intent of aggregating sales to African countries.", "overall_assessment": "incorrect"}}
{"example_id": 904, "sql_complexity": "basic SQL", "prompt": "What is the minimum Shariah-compliant loan amount issued in the last quarter of 2021?", "context": "CREATE TABLE loans (id INT, amount DECIMAL, date DATE, loan_type VARCHAR); INSERT INTO loans (id, amount, date, loan_type) VALUES (1, 5000, '2021-09-05', 'Shariah-compliant'), (2, 7000, '2021-10-07', 'socially responsible'), (3, 9000, '2021-11-03', 'Shariah-compliant'), (4, 11000, '2021-12-31', 'Shariah-compliant');", "reference_sql": "SELECT MIN(amount) FROM loans WHERE EXTRACT(YEAR FROM date) = 2021 AND EXTRACT(QUARTER FROM date) = 4 AND loan_type = 'Shariah-compliant';", "generated_sql": "SELECT MIN(amount) FROM loans WHERE loan_type = 'Shariah-compliant' AND date >= '2021-10-01' AND date <= '2021-12-31';", "raw_model_output": "\n\nSELECT MIN(amount) FROM loans WHERE loan_type = 'Shariah-compliant' AND date >= '2021-10-01' AND date <= '2021-12-31';", "latency_sec": 4.68209981918335, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 235, "prompt_eval_sec": null, "tokens_completion": 716, "completion_eval_sec": null, "tokens_total": 951, "tokens_per_sec": 203.11399515738498, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter loans with 'Shariah-compliant' type and dates in Q4 of 2021. The reference query uses EXTRACT(YEAR) = 2021 and EXTRACT(QUARTER) = 4, which corresponds to October-December 2021. The generated query uses date >= '2021-10-01' and <= '2021-12-31', which covers the same period. Both will return the same MIN(amount) value of 9000.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify the minimum Shariah-compliant loan amount in Q4 2021. The reference query uses EXTRACT() to explicitly target the 4th quarter, while the generated query uses a date range (2021-10-01 to 2021-12-31) which also captures Q4. Both would return the same result (5000 in the sample data). However, the generated query is more efficient as date ranges can leverage indexes on the 'date' column, and its logic is more explicit about the time period. The reference query's use of EXTRACT() might be less efficient in some databases. Both fulfill the business intent, but the generated query is more elegant and performant.", "overall_assessment": "correct"}}
{"example_id": 3299, "sql_complexity": "set operations", "prompt": "How many schools and hospitals are there in Colombia and which ones need repairs?", "context": "CREATE TABLE schools (id INT, country VARCHAR(20), name VARCHAR(50), needs_repair BOOLEAN); CREATE TABLE hospitals (id INT, country VARCHAR(20), name VARCHAR(50), needs_repair BOOLEAN);", "reference_sql": "SELECT 'Schools' as facility_type, COUNT(*) as total, SUM(needs_repair) as repairs_needed FROM schools WHERE country = 'Colombia' UNION ALL SELECT 'Hospitals' as facility_type, COUNT(*) as total, SUM(needs_repair) as repairs_needed FROM hospitals WHERE country = 'Colombia';", "generated_sql": "SELECT \n    (SELECT COUNT(*) FROM schools WHERE country = 'Colombia') AS total_schools,\n    (SELECT COUNT(*) FROM hospitals WHERE country = 'Colombia') AS total_hospitals,\n    (SELECT STRING_AGG(name, ', ') FROM schools WHERE country = 'Colombia' AND needs_repair) AS schools_needs_repair,\n    (SELECT STRING_AGG(name, ', ') FROM hospitals WHERE country = 'Colombia' AND needs_repair) AS hospitals_needs_repair;", "raw_model_output": "\n\nSELECT \n    (SELECT COUNT(*) FROM schools WHERE country = 'Colombia') AS total_schools,\n    (SELECT COUNT(*) FROM hospitals WHERE country = 'Colombia') AS total_hospitals,\n    (SELECT STRING_AGG(name, ', ') FROM schools WHERE country = 'Colombia' AND needs_repair) AS schools_needs_repair,\n    (SELECT STRING_AGG(name, ', ') FROM hospitals WHERE country = 'Colombia' AND needs_repair) AS hospitals_needs_repair;", "latency_sec": 13.49811315536499, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 133, "prompt_eval_sec": null, "tokens_completion": 2012, "completion_eval_sec": null, "tokens_total": 2145, "tokens_per_sec": 158.91109930038212, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL returns two rows (Schools/Hospitals) with aggregated counts and repair sums, while the Generated SQL returns a single row with separate counts and comma-separated names of facilities needing repair. The structure, columns, and data types differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries are not technically equivalent as they produce different output structures. The reference query returns aggregated counts and repair needs per facility type (schools/hospitals) with facility_type column, while the generated query returns separate counts and concatenated lists of facilities needing repairs. The original question requires both (1) total numbers of schools/hospitals and (2) specific facilities needing repairs. The reference query addresses (1) but not (2), while the generated query addresses both (1) and (2). The generated query better fulfills the business intent by providing explicit lists of facilities needing repairs through STRING_AGG, though it could be more efficient with UNION ALL instead of multiple subqueries.", "overall_assessment": "differently_correct"}}
{"example_id": 907, "sql_complexity": "set operations", "prompt": "What is the total quantity of items with type 'E' or type 'F' in warehouse O and warehouse P?", "context": "CREATE TABLE warehouse_o(item_id INT, item_type VARCHAR(10), quantity INT);CREATE TABLE warehouse_p(item_id INT, item_type VARCHAR(10), quantity INT);INSERT INTO warehouse_o(item_id, item_type, quantity) VALUES (1, 'E', 200), (2, 'F', 300), (3, 'E', 50), (4, 'F', 400);INSERT INTO warehouse_p(item_id, item_type, quantity) VALUES (1, 'E', 150), (2, 'F', 250), (3, 'E', 40), (4, 'F', 350);", "reference_sql": "SELECT quantity FROM warehouse_o WHERE item_type IN ('E', 'F') UNION ALL SELECT quantity FROM warehouse_p WHERE item_type IN ('E', 'F');", "generated_sql": "SELECT SUM(quantity) FROM (\n    SELECT quantity FROM warehouse_o WHERE item_type IN ('E', 'F')\n    UNION ALL\n    SELECT quantity FROM warehouse_p WHERE item_type IN ('E', 'F')\n) AS combined;", "raw_model_output": "\n\nSELECT SUM(quantity) FROM (\n    SELECT quantity FROM warehouse_o WHERE item_type IN ('E', 'F')\n    UNION ALL\n    SELECT quantity FROM warehouse_p WHERE item_type IN ('E', 'F')\n) AS combined;", "latency_sec": 9.027141809463501, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 242, "prompt_eval_sec": null, "tokens_completion": 1119, "completion_eval_sec": null, "tokens_total": 1361, "tokens_per_sec": 150.7675440052588, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns individual quantity values from both tables combined with UNION ALL, producing multiple rows. The Generated SQL aggregates all combined quantities into a single sum value. The output structures differ (multiple rows vs. single value) and the semantic purpose (row-level data vs. aggregate total) is distinct.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL returns individual quantities from both warehouses without aggregation, while the Generated SQL properly sums all qualifying quantities. The original question explicitly asks for a 'total quantity,' which requires aggregation. The Reference query technically fails to fulfill the business intent by returning a list of values instead of a single total. The Generated query correctly addresses the requirement with a nested SUM() over the combined results. Both queries are syntactically valid, but only the Generated query aligns with the business objective of calculating a total.", "overall_assessment": "correct"}}
{"example_id": 1400, "sql_complexity": "single join", "prompt": "What is the maximum co-ownership duration for properties in the neighborhood of 'Chinatown' in San Francisco?'", "context": "CREATE TABLE sf_neighborhoods (neighborhood_id INT, name VARCHAR(255), city VARCHAR(255)); INSERT INTO sf_neighborhoods (neighborhood_id, name, city) VALUES (1, 'Chinatown', 'San Francisco'); CREATE TABLE co_ownership (co_ownership_id INT, property_id INT, co_owner_id INT, start_date DATE, end_date DATE); INSERT INTO co_ownership (co_ownership_id, property_id, co_owner_id, start_date, end_date) VALUES (1, 1, 2, '2010-01-01', '2020-01-01'), (2, 2, 3, '2015-01-01', '2022-01-01'); CREATE TABLE properties (property_id INT, city VARCHAR(255)); INSERT INTO properties (property_id, city) VALUES (1, 'San Francisco'), (2, 'San Francisco');", "reference_sql": "SELECT MAX(DATEDIFF(end_date, start_date)) as max_duration FROM co_ownership JOIN properties ON co_ownership.property_id = properties.property_id WHERE properties.city = 'San Francisco' AND name = 'Chinatown';", "generated_sql": "SELECT MAX(DATEDIFF(end_date, start_date)) AS max_co_ownership_duration\nFROM co_ownership\nJOIN properties ON co_ownership.property_id = properties.property_id\nJOIN sf_neighborhoods ON properties.neighborhood_id = sf_neighborhoods.neighborhood_id\nWHERE sf_neighborhoods.name = 'Chinatown' AND sf_neighborhoods.city = 'San Francisco';", "raw_model_output": "\n\nThe question asks for the maximum co-ownership duration for properties in the neighborhood of 'Chinatown' in San Francisco. However, based on the provided schema, there is **no direct relationship** between the `properties` table and the `sf_neighborhoods` table. The `properties` table contains a `city` column, and the `sf_neighborhoods` table also contains a `city` column, but there is no column (e.g., `neighborhood_id`) in `properties` that links it to `sf_neighborhoods`.\n\n### Key Issue:\nWithout a foreign key or a column that explicitly connects properties to neighborhoods, it is **not possible to determine which properties are located in 'Chinatown'**. The schema as provided does not support this query.\n\n---\n\n### Assumption (for the sake of providing an SQL query):\nIf we assume that the `properties` table should have a `neighborhood_id` column (which is not present in the schema), the SQL query would look like this:\n\n```sql\nSELECT MAX(DATEDIFF(end_date, start_date)) AS max_co_ownership_duration\nFROM co_ownership\nJOIN properties ON co_ownership.property_id = properties.property_id\nJOIN sf_neighborhoods ON properties.neighborhood_id = sf_neighborhoods.neighborhood_id\nWHERE sf_neighborhoods.name = 'Chinatown' AND sf_neighborhoods.city = 'San Francisco';\n```\n\n---\n\n### Final Note:\nGiven the **current schema**, the query **cannot be executed** as it stands. The schema is missing a critical link between `properties` and `sf_neighborhoods`. If the schema is incomplete, the above query is a hypothetical solution based on a common design pattern.", "latency_sec": 16.11441993713379, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 306, "prompt_eval_sec": null, "tokens_completion": 2503, "completion_eval_sec": null, "tokens_total": 2809, "tokens_per_sec": 174.3159239338792, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references a 'name' column that doesn't exist in the joined tables (co_ownership and properties). The Generated SQL correctly joins with sf_neighborhoods to access the 'name' and 'city' columns. The Reference SQL would fail due to an invalid column reference, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL is technically incorrect because it references a 'name' column in the WHERE clause that doesn't exist in the properties table - this column belongs to sf_neighborhoods. The Generated SQL correctly joins with sf_neighborhoods and filters on that table's name and city columns. While both queries aim to calculate co-ownership duration, only the Generated SQL properly filters properties in Chinatown by joining the neighborhoods table. The Reference SQL would fail with an 'unknown column' error. Both queries use DATEDIFF correctly, but the Generated version better fulfills the business intent by accurately filtering the neighborhood context.", "overall_assessment": "{'reference': 'incorrect', 'generated': 'correct'}"}}
{"example_id": 5248, "sql_complexity": "window functions", "prompt": "Find the top 5 games by rating", "context": "CREATE TABLE games (game_id INT PRIMARY KEY, name VARCHAR(50), genre VARCHAR(50), rating DECIMAL(3,2));", "reference_sql": "SELECT * FROM (SELECT name, rating, ROW_NUMBER() OVER (ORDER BY rating DESC) as rn FROM games) t WHERE rn <= 5;", "generated_sql": "SELECT * FROM games ORDER BY rating DESC LIMIT 5;", "raw_model_output": "\n\nSELECT * FROM games ORDER BY rating DESC LIMIT 5;", "latency_sec": 2.7380478382110596, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 109, "prompt_eval_sec": null, "tokens_completion": 238, "completion_eval_sec": null, "tokens_total": 347, "tokens_per_sec": 126.73262868435386, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query returns three columns (name, rating, rn) from a subquery, while the generated query returns all columns from the games table. Additionally, the reference query explicitly calculates row numbers, whereas the generated query uses LIMIT. The column structure and implementation differ, leading to different result sets.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly retrieve the top 5 games by rating. The reference query uses ROW_NUMBER() with a subquery to assign ranks, while the generated query uses ORDER BY and LIMIT. Technically, they produce the same results when ratings are unique. However, the generated query is more efficient and elegant, as it avoids unnecessary subquery complexity. Both fulfill the business intent of identifying top-rated games, but the generated query is simpler and performs better.", "overall_assessment": "correct"}}
{"example_id": 778, "sql_complexity": "single join", "prompt": "What is the maximum property price in wheelchair-accessible neighborhoods in Singapore?", "context": "CREATE TABLE Singapore_Neighborhoods (Neighborhood_Name TEXT, Wheelchair_Accessibility BOOLEAN); INSERT INTO Singapore_Neighborhoods (Neighborhood_Name, Wheelchair_Accessibility) VALUES ('Orchard', true), ('Marina Bay', true), ('Chinatown', false), ('Little India', false), ('Bugis', true); CREATE TABLE Singapore_Properties (Neighborhood_Name TEXT, Property_Price INTEGER); INSERT INTO Singapore_Properties (Neighborhood_Name, Property_Price) VALUES ('Orchard', 2000000), ('Marina Bay', 3000000), ('Chinatown', 1500000), ('Little India', 1200000), ('Bugis', 1800000);", "reference_sql": "SELECT MAX(Singapore_Properties.Property_Price) FROM Singapore_Properties INNER JOIN Singapore_Neighborhoods ON Singapore_Properties.Neighborhood_Name = Singapore_Neighborhoods.Neighborhood_Name WHERE Singapore_Neighborhoods.Wheelchair_Accessibility = true;", "generated_sql": "SELECT MAX(p.Property_Price)\nFROM Singapore_Properties p\nJOIN Singapore_Neighborhoods n ON p.Neighborhood_Name = n.Neighborhood_Name\nWHERE n.Wheelchair_Accessibility = TRUE;", "raw_model_output": "\n\nTo determine the **maximum property price in wheelchair-accessible neighborhoods in Singapore**, we need to:\n\n1. **Identify** which neighborhoods are wheelchair-accessible by querying the `Singapore_Neighborhoods` table.\n2. **Retrieve** the corresponding property prices from the `Singapore_Properties` table for those neighborhoods.\n3. **Compute** the maximum property price using the `MAX()` aggregate function.\n\nThis can be efficiently achieved using a `JOIN` between the two tables on the `Neighborhood_Name` column, followed by a filter on `Wheelchair_Accessibility = TRUE`.\n\n---\n\n### \u2705 Final SQL Query\n\n```sql\nSELECT MAX(p.Property_Price)\nFROM Singapore_Properties p\nJOIN Singapore_Neighborhoods n ON p.Neighborhood_Name = n.Neighborhood_Name\nWHERE n.Wheelchair_Accessibility = TRUE;\n```\n\n---\n\n### \ud83d\udccc Explanation\n\n- `JOIN` ensures we only consider neighborhoods that exist in both tables.\n- `WHERE n.Wheelchair_Accessibility = TRUE` filters to only include wheelchair-accessible neighborhoods.\n- `MAX(p.Property_Price)` returns the highest property price among those neighborhoods.\n\nThis query will return the correct value of **3000000**, which corresponds to the property price in **Marina Bay**, a wheelchair-accessible neighborhood.", "latency_sec": 9.07947587966919, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 253, "prompt_eval_sec": null, "tokens_completion": 1313, "completion_eval_sec": null, "tokens_total": 1566, "tokens_per_sec": 172.47691615180074, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between Singapore_Properties and Singapore_Neighborhoods on Neighborhood_Name, filter for wheelchair-accessible neighborhoods, and select the maximum property price. The generated query uses table aliases (p and n) but maintains identical logic, conditions, and column references as the reference query.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly compute the maximum property price in wheelchair-accessible neighborhoods by joining the two tables on Neighborhood_Name and filtering where Wheelchair_Accessibility is true. The reference query uses full table names while the generated query uses aliases, but this is a stylistic difference with no impact on results. Both achieve the same logical outcome with identical syntax structure. The business intent of identifying accessible neighborhoods and finding the highest property price within them is fully addressed by both queries.", "overall_assessment": "correct"}}
{"example_id": 3859, "sql_complexity": "aggregation", "prompt": "What is the total number of mental health parity violations by month and year?", "context": "CREATE TABLE mental_health_parity_reports (report_id INT, violation_date DATE); INSERT INTO mental_health_parity_reports (report_id, violation_date) VALUES (1, '2022-01-01'), (2, '2022-02-15'), (3, '2022-03-05'), (4, '2022-04-20'), (5, '2021-06-12'), (6, '2021-07-28');", "reference_sql": "SELECT EXTRACT(MONTH FROM violation_date) AS month, EXTRACT(YEAR FROM violation_date) AS year, COUNT(*) FROM mental_health_parity_reports GROUP BY month, year;", "generated_sql": "SELECT \n    EXTRACT(YEAR FROM violation_date) AS year,\n    EXTRACT(MONTH FROM violation_date) AS month,\n    COUNT(*) AS total_violations\nFROM mental_health_parity_reports\nGROUP BY \n    EXTRACT(YEAR FROM violation_date),\n    EXTRACT(MONTH FROM violation_date)\nORDER BY \n    year, month;", "raw_model_output": "\n\nSELECT \n    EXTRACT(YEAR FROM violation_date) AS year,\n    EXTRACT(MONTH FROM violation_date) AS month,\n    COUNT(*) AS total_violations\nFROM mental_health_parity_reports\nGROUP BY \n    EXTRACT(YEAR FROM violation_date),\n    EXTRACT(MONTH FROM violation_date)\nORDER BY \n    year, month;", "latency_sec": 6.061020851135254, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 206, "prompt_eval_sec": null, "tokens_completion": 928, "completion_eval_sec": null, "tokens_total": 1134, "tokens_per_sec": 187.0971949861544, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries group by year and month, count violations, and return the same data. The differences (column order, alias name, and ORDER BY) do not affect the semantic result. The GROUP BY clauses are functionally equivalent, and the ORDER BY in the generated query only affects presentation, not the underlying data.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent due to differences in GROUP BY syntax. The Reference SQL uses column aliases (month, year) in the GROUP BY clause, which is invalid in standard SQL (aliases cannot be used in GROUP BY). The Generated SQL correctly uses the EXTRACT expressions in GROUP BY, making it syntactically valid. Both queries count violations by month/year, so they are semantically equivalent if the Reference SQL were valid. However, the Generated SQL is more robust and follows standard SQL practices. The ORDER BY clause in the Generated SQL is an enhancement that doesn't affect correctness but improves result readability.", "overall_assessment": "differently_correct"}}
{"example_id": 3551, "sql_complexity": "multiple_joins", "prompt": "List all artists who have performed in New York and Chicago, along with their highest-earning performance.", "context": "CREATE TABLE artist_events (artist_id INT, event_id INT, earnings DECIMAL(5,2)); CREATE TABLE artists (id INT, name VARCHAR(50)); CREATE TABLE events (id INT, city VARCHAR(20));", "reference_sql": "SELECT artists.name, MAX(artist_events.earnings) FROM artists INNER JOIN artist_events ON artists.id = artist_events.artist_id INNER JOIN events ON artist_events.event_id = events.id WHERE city IN ('New York', 'Chicago') GROUP BY artists.name;", "generated_sql": "SELECT a.id, a.name, MAX(ae.earnings) AS highest_earning\nFROM artists a\nJOIN artist_events ae ON a.id = ae.artist_id\nWHERE a.id IN (\n    SELECT ae2.artist_id\n    FROM artist_events ae2\n    JOIN events e2 ON ae2.event_id = e2.id\n    WHERE e2.city IN ('New York', 'Chicago')\n    GROUP BY ae2.artist_id\n    HAVING COUNT(DISTINCT e2.city) = 2\n)\nGROUP BY a.id, a.name;", "raw_model_output": "\n\n```sql\nSELECT a.id, a.name, MAX(ae.earnings) AS highest_earning\nFROM artists a\nJOIN artist_events ae ON a.id = ae.artist_id\nWHERE a.id IN (\n    SELECT ae2.artist_id\n    FROM artist_events ae2\n    JOIN events e2 ON ae2.event_id = e2.id\n    WHERE e2.city IN ('New York', 'Chicago')\n    GROUP BY ae2.artist_id\n    HAVING COUNT(DISTINCT e2.city) = 2\n)\nGROUP BY a.id, a.name;\n```", "latency_sec": 15.33575701713562, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 137, "prompt_eval_sec": null, "tokens_completion": 1843, "completion_eval_sec": null, "tokens_total": 1980, "tokens_per_sec": 129.11002683386414, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns artists with any event in 'New York' or 'Chicago', grouping by name and showing their maximum earnings. The Generated SQL restricts to artists with events in *both* cities (due to HAVING COUNT(DISTINCT city) = 2) and groups by id/name. The filtering criteria and grouping logic differ, leading to different result sets.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ fundamentally in their logic. The Reference SQL incorrectly includes artists who performed in either New York OR Chicago (not both), as it only filters cities in the WHERE clause. It also lacks proper aggregation for multi-city verification. The Generated SQL correctly identifies artists with performances in both cities using a HAVING COUNT(DISTINCT city) = 2 subquery, then retrieves their maximum earnings. While both return artists and earnings, only the Generated SQL meets the business requirement of 'performed in New York AND Chicago'. The Reference SQL is technically incorrect for the question, while the Generated SQL is both semantically and technically correct.", "overall_assessment": "differently_correct"}}
{"example_id": 5168, "sql_complexity": "aggregation", "prompt": "Get the number of renewable energy projects in Australia for each project type.", "context": "CREATE TABLE renewable_projects (id INT PRIMARY KEY, project_name VARCHAR(255), project_location VARCHAR(255), project_type VARCHAR(255), capacity_mw FLOAT);", "reference_sql": "SELECT project_type, COUNT(*) FROM renewable_projects WHERE project_location = 'Australia' GROUP BY project_type;", "generated_sql": "SELECT project_type, COUNT(*) FROM renewable_projects WHERE project_location = 'Australia' GROUP BY project_type;", "raw_model_output": "\n\nSELECT project_type, COUNT(*) FROM renewable_projects WHERE project_location = 'Australia' GROUP BY project_type;", "latency_sec": 2.2816977500915527, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 123, "prompt_eval_sec": null, "tokens_completion": 336, "completion_eval_sec": null, "tokens_total": 459, "tokens_per_sec": 201.16599579483423, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select project_type and count the number of entries, filter for 'Australia' location, and group by project_type. No differences exist in syntax, conditions, or aggregation.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic. They correctly filter projects in Australia, group by project type, and count the number of projects per type. The queries are syntactically correct, semantically equivalent, and fulfill the business intent of counting renewable energy projects by type in Australia. Since they are identical, neither is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 4916, "sql_complexity": "aggregation", "prompt": "What is the maximum revenue generated from selling Yttrium in India in the past 3 years?", "context": "CREATE TABLE Yttrium_Sales (id INT PRIMARY KEY, year INT, country VARCHAR(20), quantity INT, price PER_KG); INSERT INTO Yttrium_Sales (id, year, country, quantity, price) VALUES (1, 2019, 'India', 120, 40), (2, 2020, 'India', 130, 45), (3, 2021, 'India', 140, 50), (4, 2019, 'China', 150, 35), (5, 2020, 'China', 160, 40), (6, 2021, 'China', 170, 45);", "reference_sql": "SELECT MAX(quantity * price) FROM Yttrium_Sales WHERE country = 'India' GROUP BY year ORDER BY year DESC LIMIT 3;", "generated_sql": "SELECT MAX(quantity * price) FROM Yttrium_Sales WHERE country = 'India';", "raw_model_output": "\n\nSELECT MAX(quantity * price) FROM Yttrium_Sales WHERE country = 'India';", "latency_sec": 9.525115251541138, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 268, "prompt_eval_sec": null, "tokens_completion": 1338, "completion_eval_sec": null, "tokens_total": 1606, "tokens_per_sec": 168.60688375819427, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL groups results by year, orders them descending, and limits to 3 rows, while the Generated SQL calculates a single maximum value across all India records without grouping. The Reference query returns multiple rows (one per year) with ordered/limited results, whereas the Generated query returns a single value.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is incorrect because it groups by year and returns multiple rows (max revenue per year) instead of a single maximum value across all sales. It also lacks a year filter to ensure only the past 3 years are considered. The Generated SQL correctly calculates the maximum revenue across all India sales but fails to filter by the past 3 years. However, in the provided context (data only includes 2019-2021), the Generated SQL technically returns the correct value (7000). The Reference SQL's structure is fundamentally flawed for the question's intent, while the Generated SQL, though incomplete, is simpler and closer to the correct answer in this specific dataset.", "overall_assessment": "differently_correct"}}
{"example_id": 812, "sql_complexity": "multiple_joins", "prompt": "What is the average salary of 'engineer' workers in each factory?", "context": "CREATE TABLE factories (factory_id INT, factory_name VARCHAR(20)); INSERT INTO factories VALUES (1, 'Factory X'), (2, 'Factory Y'), (3, 'Factory Z'); CREATE TABLE roles (role_id INT, role_name VARCHAR(20)); INSERT INTO roles VALUES (1, 'engineer'), (2, 'manager'), (3, 'assistant'); CREATE TABLE workers (worker_id INT, factory_id INT, role_id INT, salary DECIMAL(5,2)); INSERT INTO workers VALUES (1, 1, 1, 50000.00), (2, 1, 2, 70000.00), (3, 2, 1, 55000.00), (4, 2, 3, 40000.00), (5, 3, 1, 60000.00);", "reference_sql": "SELECT f.factory_name, AVG(salary) FROM workers w INNER JOIN factories f ON w.factory_id = f.factory_id INNER JOIN roles r ON w.role_id = r.role_id WHERE r.role_name = 'engineer' GROUP BY f.factory_name;", "generated_sql": "SELECT f.factory_name, AVG(w.salary) AS average_salary\nFROM workers w\nJOIN roles r ON w.role_id = r.role_id\nJOIN factories f ON w.factory_id = f.factory_id\nWHERE r.role_name = 'engineer'\nGROUP BY f.factory_id, f.factory_name;", "raw_model_output": "\n\nTo compute the **average salary of 'engineer' workers in each factory**, we need to:\n\n1. **Filter** workers who have the role of `'engineer'` by joining the `workers` table with the `roles` table.\n2. **Link** each worker to their respective factory using the `factory_id` field.\n3. **Group** the results by factory to calculate the average salary per factory.\n4. **Select** the factory name and the computed average salary.\n\nThis ensures that we are only considering engineers and that the results are grouped by the actual factory names.\n\n---\n\n### \u2705 SQL Query\n\n```sql\nSELECT f.factory_name, AVG(w.salary) AS average_salary\nFROM workers w\nJOIN roles r ON w.role_id = r.role_id\nJOIN factories f ON w.factory_id = f.factory_id\nWHERE r.role_name = 'engineer'\nGROUP BY f.factory_id, f.factory_name;\n```\n\n---\n\n### \ud83d\udccc Explanation\n\n- `JOIN roles r ON w.role_id = r.role_id`: Links each worker to their role.\n- `WHERE r.role_name = 'engineer'`: Filters only engineers.\n- `JOIN factories f ON w.factory_id = f.factory_id`: Links each worker to their factory.\n- `GROUP BY f.factory_id, f.factory_name`: Ensures the average is calculated per factory.\n- `AVG(w.salary)`: Computes the average salary for each group.\n\nThis query adheres to **ANSI SQL standards** and is compatible with most SQL databases.", "latency_sec": 10.692981958389282, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 286, "prompt_eval_sec": null, "tokens_completion": 1427, "completion_eval_sec": null, "tokens_total": 1713, "tokens_per_sec": 160.1985308369523, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL groups by 'factory_name' alone, while the Generated SQL groups by both 'factory_id' and 'factory_name'. Although factory_id is a primary key and factory_name is functionally dependent on it, grouping by only factory_name could potentially combine multiple factories with the same name (if they existed), whereas grouping by factory_id ensures unique grouping. Since the schema does not enforce uniqueness on factory_name, the queries may produce different results in general cases.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the average salary of 'engineer' workers per factory. The Reference SQL groups by factory_name, which works here because factory_name is unique. The Generated SQL groups by both factory_id and factory_name, which is more robust as factory_id is the primary key. While both produce identical results given the data, the Generated SQL's approach is technically superior due to using the primary key for grouping, ensuring consistency even if factory_name uniqueness is not guaranteed. The Generated SQL also explicitly aliases the average_salary column, improving readability.", "overall_assessment": "correct"}}
{"example_id": 5784, "sql_complexity": "set operations", "prompt": "List the number of users who have completed a workout of a specific type (e.g. Running) and have a membership status of 'Active'.", "context": "CREATE TABLE workouts (id INT, user_id INT, workout_type VARCHAR(20)); CREATE TABLE members (id INT, name VARCHAR(50), membership_status VARCHAR(20), state VARCHAR(20)); INSERT INTO workouts (id, user_id, workout_type) VALUES (1, 1, 'Running'), (2, 1, 'Cycling'), (3, 2, 'Running'), (4, 3, 'Cycling'), (5, 3, 'Swimming'), (6, 4, 'Running'), (7, 4, 'Swimming'); INSERT INTO members (id, name, membership_status, state) VALUES (1, 'John Doe', 'Active', 'Texas'), (2, 'Jane Doe', 'Inactive', 'California'), (3, 'Bob Smith', 'Active', 'Texas'), (4, 'Alice Johnson', 'Active', 'California');", "reference_sql": "SELECT COUNT(*) FROM (SELECT user_id FROM workouts WHERE workout_type = 'Running' INTERSECT SELECT id FROM members WHERE membership_status = 'Active') AS user_set;", "generated_sql": "SELECT COUNT(DISTINCT m.id)\nFROM members m\nJOIN workouts w ON m.id = w.user_id\nWHERE w.workout_type = 'Running' AND m.membership_status = 'Active';", "raw_model_output": "\n\n```sql\nSELECT COUNT(DISTINCT m.id)\nFROM members m\nJOIN workouts w ON m.id = w.user_id\nWHERE w.workout_type = 'Running' AND m.membership_status = 'Active';\n```", "latency_sec": 6.03416109085083, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 289, "prompt_eval_sec": null, "tokens_completion": 646, "completion_eval_sec": null, "tokens_total": 935, "tokens_per_sec": 154.9511168035726, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of active members who have at least one 'Running' workout. The Reference SQL uses INTERSECT to find common user_ids between 'Running' workouts and active members, while the Generated SQL joins the tables and counts distinct member IDs. Both approaches yield the same result by ensuring only active members with 'Running' workouts are counted.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly count users with 'Running' workouts and active memberships. The Reference SQL uses INTERSECT to find overlapping user_ids between workouts and members, while the Generated SQL uses a JOIN with COUNT(DISTINCT) to achieve the same result. Both handle duplicates appropriately (INTERSECT inherently removes duplicates, COUNT(DISTINCT) explicitly does so). The business intent is fulfilled equally well by both approaches. While the Generated SQL may be more readable and efficient in practice, they are technically equivalent in terms of output and correctness.", "overall_assessment": "correct"}}
{"example_id": 3038, "sql_complexity": "subqueries", "prompt": "What is the total assets of clients who have invested in mutual funds but not in stocks?", "context": "CREATE TABLE clients (client_id INT, name TEXT, age INT, gender TEXT, total_assets DECIMAL(10,2)); INSERT INTO clients VALUES (1, 'John Doe', 35, 'Male', 250000.00), (2, 'Jane Smith', 45, 'Female', 500000.00); CREATE TABLE investments (client_id INT, investment_type TEXT); INSERT INTO investments VALUES (1, 'Stocks'), (1, 'Bonds'), (2, 'Stocks'), (3, 'Mutual Funds');", "reference_sql": "SELECT c.total_assets FROM clients c INNER JOIN investments i ON c.client_id = i.client_id WHERE i.investment_type = 'Mutual Funds' AND c.client_id NOT IN (SELECT client_id FROM investments WHERE investment_type = 'Stocks');", "generated_sql": "SELECT SUM(c.total_assets) FROM clients c WHERE c.client_id IN (SELECT client_id FROM investments WHERE investment_type = 'Mutual Funds') AND c.client_id NOT IN (SELECT client_id FROM investments WHERE investment_type = 'Stocks');", "raw_model_output": "\n\nSELECT SUM(c.total_assets) FROM clients c WHERE c.client_id IN (SELECT client_id FROM investments WHERE investment_type = 'Mutual Funds') AND c.client_id NOT IN (SELECT client_id FROM investments WHERE investment_type = 'Stocks');", "latency_sec": 10.290836095809937, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 214, "prompt_eval_sec": null, "tokens_completion": 1404, "completion_eval_sec": null, "tokens_total": 1618, "tokens_per_sec": 157.2272636485574, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns individual client total_assets values, while the Generated SQL aggregates them with SUM. The Reference query uses a JOIN and NOT IN, whereas the Generated uses IN/NOT IN subqueries. The output structure differs (rows vs. single sum) and the Generated query's logic may handle duplicates differently due to aggregation.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query retrieves individual client assets rather than aggregating them, while the generated query correctly uses SUM() to calculate total assets. Both queries correctly identify clients with mutual fund investments and no stock investments through their WHERE clauses. However, the generated query directly addresses the 'total assets' requirement by aggregating results, whereas the reference query would return multiple rows of individual asset values. The generated query is more efficient as it avoids unnecessary JOIN operations and directly computes the aggregate value.", "overall_assessment": "differently_correct"}}
{"example_id": 1078, "sql_complexity": "basic SQL", "prompt": "What is the maximum and minimum temperature difference between any two Arctic research stations?", "context": "CREATE TABLE arctic_stations (id INT, name TEXT, location TEXT, temperature DECIMAL(5,2)); INSERT INTO arctic_stations (id, name, location, temperature) VALUES (1, 'Station A', 'Greenland', 2.3), (2, 'Station B', 'Canada', -5.2);", "reference_sql": "SELECT a.name as station1, b.name as station2, MAX(ABS(a.temperature - b.temperature)) as temp_diff FROM arctic_stations a, arctic_stations b ORDER BY temp_diff DESC LIMIT 1", "generated_sql": "SELECT \n    (SELECT MAX(temperature) - MIN(temperature) FROM arctic_stations) AS max_diff,\n    (SELECT MIN(ABS(t1.temperature - t2.temperature)) FROM arctic_stations t1, arctic_stations t2 WHERE t1.id < t2.id) AS min_diff;", "raw_model_output": "\n\nSELECT \n    (SELECT MAX(temperature) - MIN(temperature) FROM arctic_stations) AS max_diff,\n    (SELECT MIN(ABS(t1.temperature - t2.temperature)) FROM arctic_stations t1, arctic_stations t2 WHERE t1.id < t2.id) AS min_diff;", "latency_sec": 8.822641849517822, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 156, "prompt_eval_sec": null, "tokens_completion": 1045, "completion_eval_sec": null, "tokens_total": 1201, "tokens_per_sec": 136.12702640373388, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL finds the maximum absolute temperature difference between any two stations and returns their names, while the Generated SQL calculates two separate values: the overall temperature range (max - min) and the minimum absolute difference between any two stations. The output structures and computed values differ, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference SQL only calculates the maximum temperature difference between any two stations but fails to address the minimum difference requirement. It also returns station names instead of just the numerical difference, which is unnecessary for the question. The generated SQL correctly computes both maximum and minimum differences using efficient subqueries. The first subquery (MAX(temperature) - MIN(temperature)) accurately captures the maximum possible difference, while the second subquery (MIN(ABS(t1.temperature - t2.temperature))) properly identifies the minimum difference between any two stations. The generated query is more aligned with the business intent and avoids redundant data.", "overall_assessment": "differently_correct"}}
{"example_id": 5015, "sql_complexity": "basic SQL", "prompt": "Calculate the average recycling rate", "context": "CREATE TABLE recycling_rates (id INT PRIMARY KEY, location VARCHAR(50), rate FLOAT);", "reference_sql": "SELECT AVG(rate) FROM recycling_rates;", "generated_sql": "SELECT AVG(rate) FROM recycling_rates;", "raw_model_output": "\n\nSELECT AVG(rate) FROM recycling_rates;", "latency_sec": 2.0934557914733887, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 95, "prompt_eval_sec": null, "tokens_completion": 185, "completion_eval_sec": null, "tokens_total": 280, "tokens_per_sec": 133.75013751923277, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic, both calculating the average of the 'rate' column from the 'recycling_rates' table. No differences in syntax, semantics, or execution plan exist between them.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic. They correctly calculate the average recycling rate using the AVG() function on the 'rate' column from the recycling_rates table. The queries have the same syntax, same semantic meaning, and would produce identical results. Neither query is more efficient or elegant than the other since they are exactly the same. Both fully address the business intent of calculating the average recycling rate without any unnecessary complexity.", "overall_assessment": "correct"}}
{"example_id": 1533, "sql_complexity": "subqueries", "prompt": "Which programs had the highest volunteer participation rate in the last quarter?", "context": "CREATE TABLE Programs (ProgramID INT, ProgramName TEXT, Budget DECIMAL(10,2), NumVolunteers INT); CREATE TABLE VolunteerEvents (EventID INT, ProgramID INT, EventDate DATE, NumVolunteers INT);", "reference_sql": "SELECT p.ProgramName, COUNT(v.EventID) / (SELECT COUNT(*) FROM VolunteerEvents WHERE EventDate >= DATEADD(quarter, -1, GETDATE())) * 100.0 AS VolunteerParticipationRate FROM Programs p INNER JOIN VolunteerEvents v ON p.ProgramID = v.ProgramID WHERE v.EventDate >= DATEADD(quarter, -1, GETDATE()) GROUP BY p.ProgramName ORDER BY VolunteerParticipationRate DESC;", "generated_sql": "SELECT \n    p.ProgramID,\n    p.ProgramName,\n    SUM(ve.NumVolunteers) * 1.0 / p.NumVolunteers AS ParticipationRate\nFROM \n    Programs p\nJOIN \n    VolunteerEvents ve ON p.ProgramID = ve.ProgramID\nWHERE \n    ve.EventDate >= CURRENT_DATE - INTERVAL '3 months'\nGROUP BY \n    p.ProgramID, p.ProgramName, p.NumVolunteers\nORDER BY \n    ParticipationRate DESC;", "raw_model_output": "\n\nTo determine which programs had the **highest volunteer participation rate** in the **last quarter**, we need to interpret \"participation rate\" as the **proportion of volunteers who participated in events** relative to the **total number of volunteers** in the program.\n\nThis implies the following steps:\n\n1. **Join** the `Programs` and `VolunteerEvents` tables on `ProgramID`.\n2. **Filter** events to only include those that occurred in the **last quarter**.\n3. **Sum** the number of volunteers per program from the `VolunteerEvents` table.\n4. **Divide** that sum by the `NumVolunteers` from the `Programs` table to get the **participation rate**.\n5. **Order** the results in descending order of participation rate to find the highest.\n\n---\n\n### \u2705 Final SQL Query\n\n```sql\nSELECT \n    p.ProgramID,\n    p.ProgramName,\n    SUM(ve.NumVolunteers) * 1.0 / p.NumVolunteers AS ParticipationRate\nFROM \n    Programs p\nJOIN \n    VolunteerEvents ve ON p.ProgramID = ve.ProgramID\nWHERE \n    ve.EventDate >= CURRENT_DATE - INTERVAL '3 months'\nGROUP BY \n    p.ProgramID, p.ProgramName, p.NumVolunteers\nORDER BY \n    ParticipationRate DESC;\n```\n\n---\n\n### \ud83d\udd0d Notes\n\n- **`CURRENT_DATE - INTERVAL '3 months'`** is used to filter events from the last quarter. This assumes the current date is known and that the SQL dialect supports this syntax (e.g., PostgreSQL).\n- If your SQL dialect does not support `CURRENT_DATE` or `INTERVAL`, you may need to substitute with a specific date range (e.g., `'2023-07-01'` to `'2023-09-30'`).\n- The `* 1.0` ensures the division is a floating-point result, not integer division.\n- The `GROUP BY` includes `p.NumVolunteers` to ensure the denominator is consistent per group.", "latency_sec": 26.275703191757202, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 131, "prompt_eval_sec": null, "tokens_completion": 3179, "completion_eval_sec": null, "tokens_total": 3310, "tokens_per_sec": 125.97189029895728, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL calculates the percentage of program events in the last quarter relative to total events in that period, while the Generated SQL calculates the ratio of volunteer hours (summed from events) to program-specific volunteer counts. Key differences include: 1) numerator metric (event count vs volunteer hours), 2) denominator (total events vs program's NumVolunteers), 3) percentage calculation (Reference uses *100.0 vs Generated uses *1.0), and 4) grouping fields (ProgramName vs ProgramID+ProgramName).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries differ fundamentally in their approach to calculating 'volunteer participation rate'. The Reference SQL calculates the ratio of program-specific events to total events in the quarter (COUNT(v.EventID) / total_events), which measures event frequency rather than volunteer participation. The Generated SQL correctly calculates the ratio of volunteers in events (SUM(ve.NumVolunteers) / p.NumVolunteers), which aligns with the business intent of measuring actual volunteer participation. The Reference SQL also has a logical flaw: it uses COUNT(v.EventID) without considering the number of volunteers per event, while the Generated SQL properly aggregates volunteer counts. The Generated SQL is more efficient as it avoids a correlated subquery and directly uses the Programs.NumVolunteers column.", "overall_assessment": "differently_correct"}}
{"example_id": 4021, "sql_complexity": "subqueries", "prompt": "What is the percentage of energy efficiency improvement, per sector, compared to 2015 levels?", "context": "CREATE TABLE energy_efficiency (id INT, sector VARCHAR(50), year INT, efficiency FLOAT); INSERT INTO energy_efficiency (id, sector, year, efficiency) VALUES (1, 'Industry', 2015, 100.0), (2, 'Industry', 2020, 105.0), (3, 'Residential', 2015, 100.0), (4, 'Residential', 2020, 103.0);", "reference_sql": "SELECT sector, (SUM(efficiency) / (SELECT SUM(efficiency) FROM energy_efficiency WHERE year = 2015 AND sector = e.sector) * 100.0) - 100.0 AS improvement FROM energy_efficiency e WHERE year = 2020 GROUP BY sector;", "generated_sql": "SELECT \n    sector,\n    ((efficiency_2020 - efficiency_2015) / efficiency_2015) * 100 AS percentage_improvement\nFROM (\n    SELECT \n        sector,\n        MAX(CASE WHEN year = 2015 THEN efficiency END) AS efficiency_2015,\n        MAX(CASE WHEN year = 2020 THEN efficiency END) AS efficiency_2020\n    FROM energy_efficiency\n    GROUP BY sector\n) AS subquery;", "raw_model_output": "\n\nSELECT \n    sector,\n    ((efficiency_2020 - efficiency_2015) / efficiency_2015) * 100 AS percentage_improvement\nFROM (\n    SELECT \n        sector,\n        MAX(CASE WHEN year = 2015 THEN efficiency END) AS efficiency_2015,\n        MAX(CASE WHEN year = 2020 THEN efficiency END) AS efficiency_2020\n    FROM energy_efficiency\n    GROUP BY sector\n) AS subquery;", "latency_sec": 13.677642107009888, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 205, "prompt_eval_sec": null, "tokens_completion": 1588, "completion_eval_sec": null, "tokens_total": 1793, "tokens_per_sec": 131.0898461863595, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the percentage improvement in efficiency from 2015 to 2020 per sector. The Reference SQL computes (SUM(2020 efficiency) / SUM(2015 efficiency) * 100) - 100, while the Generated SQL calculates ((2020 efficiency - 2015 efficiency) / 2015 efficiency) * 100. In the provided data, each sector has exactly one entry per year, making SUM(efficiency) equal to the single value. Thus, both approaches yield identical results for the given dataset.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the percentage improvement in energy efficiency per sector compared to 2015 levels. The reference query uses a SUM-based approach with a correlated subquery, while the generated query uses a pivoted subquery with direct arithmetic. They produce identical results for the given data structure. However, the generated query is more efficient and elegant: it avoids correlated subqueries, uses explicit year-based pivoting, and directly computes the percentage change without unnecessary aggregation. The reference query's SUM approach could be misleading if multiple entries exist per sector/year, but the generated query's structure is more robust for the intended business question.", "overall_assessment": "correct"}}
{"example_id": 1551, "sql_complexity": "single join", "prompt": "How many unique donors made donations in the healthcare industry in Q3 2022?", "context": "CREATE TABLE donations (id INT, donor_id INT, amount FLOAT, donation_date DATE); INSERT INTO donations (id, donor_id, amount, donation_date) VALUES (1, 7, 100, '2022-07-01'); INSERT INTO donations (id, donor_id, amount, donation_date) VALUES (2, 8, 200, '2022-09-15'); INSERT INTO donors (id, name, industry, first_donation_date DATE) VALUES (7, 'Charlie Davis', 'Healthcare', '2022-07-01'); INSERT INTO donors (id, name, industry, first_donation_date DATE) VALUES (8, 'Dana Wilson', 'Healthcare', '2022-09-15');", "reference_sql": "SELECT COUNT(DISTINCT donor_id) FROM donations d JOIN donors don ON d.donor_id = don.id WHERE industry = 'Healthcare' AND donation_date BETWEEN '2022-07-01' AND '2022-09-30';", "generated_sql": "SELECT COUNT(DISTINCT d.donor_id)\nFROM donations d\nJOIN donors dg ON d.donor_id = dg.id\nWHERE dg.industry = 'Healthcare'\nAND d.donation_date BETWEEN '2022-07-01' AND '2022-09-30';", "raw_model_output": "\n\nSELECT COUNT(DISTINCT d.donor_id)\nFROM donations d\nJOIN donors dg ON d.donor_id = dg.id\nWHERE dg.industry = 'Healthcare'\nAND d.donation_date BETWEEN '2022-07-01' AND '2022-09-30';", "latency_sec": 10.930387258529663, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 264, "prompt_eval_sec": null, "tokens_completion": 860, "completion_eval_sec": null, "tokens_total": 1124, "tokens_per_sec": 102.83258711834502, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count distinct donor_ids from donations joined with donors where industry is 'Healthcare' and donation_date is between '2022-07-01' and '2022-09-30'. The differences are only in table aliases (don vs dg) and column references (donor_id vs d.donor_id), which are semantically equivalent. The logical conditions and join structure are identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly count unique healthcare donors who made donations in Q3 2022. They use identical logic: joining donations with donors on donor_id, filtering by industry and date range, and counting distinct donor_ids. The only difference is table alias names ('don' vs 'dg'), which has no impact on results. Both queries accurately address the business question by focusing on the healthcare industry and Q3 timeframe.", "overall_assessment": "correct"}}
{"example_id": 2592, "sql_complexity": "window functions", "prompt": "What is the third highest account balance for Shariah-compliant finance customers?", "context": "CREATE TABLE shariah_compliant_finance(customer_id INT, account_balance DECIMAL(10, 2)); INSERT INTO shariah_compliant_finance VALUES (1, 5000), (2, 7000), (3, 6000), (4, 8000), (5, 9000);", "reference_sql": "SELECT account_balance FROM (SELECT account_balance, RANK() OVER (ORDER BY account_balance DESC) as rn FROM shariah_compliant_finance) t WHERE rn = 3;", "generated_sql": "SELECT account_balance\nFROM (\n    SELECT account_balance, ROW_NUMBER() OVER (ORDER BY account_balance DESC) AS rn\n    FROM shariah_compliant_finance\n) AS sub\nWHERE rn = 3;", "raw_model_output": "\n\nTo determine the **third highest account balance** for customers in the `shariah_compliant_finance` table, we can use a **window function** to assign a row number to each account balance in descending order. This approach is both **standard ANSI SQL**-compliant and efficient.\n\n---\n\n### \u2705 Key Concepts Used:\n- **`ROW_NUMBER()`**: Assigns a unique sequential number to each row based on the specified ordering.\n- **`ORDER BY account_balance DESC`**: Sorts the balances from highest to lowest.\n- **Subquery**: Used to apply the row numbering and filter for the third row.\n\n---\n\n### \ud83e\udde0 Why This Works:\n- The `ROW_NUMBER()` function ensures that each row is uniquely numbered based on the descending order of `account_balance`.\n- By filtering for `rn = 3`, we retrieve the third row, which corresponds to the **third highest** balance.\n\n---\n\n### \ud83d\udccc Final SQL Statement:\n\n```sql\nSELECT account_balance\nFROM (\n    SELECT account_balance, ROW_NUMBER() OVER (ORDER BY account_balance DESC) AS rn\n    FROM shariah_compliant_finance\n) AS sub\nWHERE rn = 3;\n```\n\n---\n\n### \ud83e\uddea Example with Sample Data:\nGiven the sample data:\n```\n(1, 5000), (2, 7000), (3, 6000), (4, 8000), (5, 9000)\n```\n\nSorted descending:\n```\n9000 (1), 8000 (2), 7000 (3), 6000 (4), 5000 (5)\n```\n\nThe query will return:\n```\n7000\n```\n\nThis is the **third highest account balance**.", "latency_sec": 21.195741891860962, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 164, "prompt_eval_sec": null, "tokens_completion": 2159, "completion_eval_sec": null, "tokens_total": 2323, "tokens_per_sec": 109.59748480858875, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the third highest account balance. Since all account_balance values are unique in the data, RANK() and ROW_NUMBER() produce identical results. The third highest value (7000) is correctly selected by both queries.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries produce the same result in this specific case because the data has unique account balances. However, the Generated SQL uses ROW_NUMBER() which is more appropriate for retrieving the nth highest value without gaps, whereas RANK() could behave differently with duplicate values. The business intent is fulfilled by both, but the Generated SQL is more precise for this use case.", "overall_assessment": "correct"}}
{"example_id": 3795, "sql_complexity": "single join", "prompt": "What is the total quantity of unsold garments for each manufacturer based in 'Italy' or 'Spain'?", "context": "CREATE TABLE manufacturers (id INT PRIMARY KEY, name VARCHAR(255), country VARCHAR(255)); CREATE TABLE garments (id INT PRIMARY KEY, manufacturer_id INT, quantity_manufactured INT, quantity_sold INT);", "reference_sql": "SELECT m.name, SUM(g.quantity_manufactured - g.quantity_sold) as total_unsold_quantity FROM manufacturers m JOIN garments g ON m.id = g.manufacturer_id WHERE m.country IN ('Italy', 'Spain') GROUP BY m.name;", "generated_sql": "SELECT m.name, SUM(g.quantity_manufactured - g.quantity_sold) AS total_unsold\nFROM manufacturers m\nJOIN garments g ON m.id = g.manufacturer_id\nWHERE m.country IN ('Italy', 'Spain')\nGROUP BY m.id, m.name;", "raw_model_output": "\n\nSELECT m.name, SUM(g.quantity_manufactured - g.quantity_sold) AS total_unsold\nFROM manufacturers m\nJOIN garments g ON m.id = g.manufacturer_id\nWHERE m.country IN ('Italy', 'Spain')\nGROUP BY m.id, m.name;", "latency_sec": 6.808166027069092, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 138, "prompt_eval_sec": null, "tokens_completion": 733, "completion_eval_sec": null, "tokens_total": 871, "tokens_per_sec": 127.93460038091412, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their GROUP BY clauses. The Reference SQL groups by 'm.name' alone, which could combine multiple manufacturers with the same name. The Generated SQL groups by both 'm.id' and 'm.name', ensuring each manufacturer is uniquely grouped. Since 'm.name' is not guaranteed to be unique (only 'm.id' is unique), the aggregation results may differ when multiple manufacturers share the same name.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent due to differences in the GROUP BY clause. The Reference SQL groups by 'm.name' alone, which could incorrectly aggregate manufacturers with identical names (though unlikely in practice). The Generated SQL groups by both 'm.id' and 'm.name', ensuring accurate aggregation by unique manufacturer identifiers. Both calculate the same unsold quantity metric, but the Generated version is more robust. Both fulfill the business intent of calculating unsold quantities for Italian/Spanish manufacturers, but the Generated query is more precise and efficient due to grouping by the primary key (m.id).", "overall_assessment": "differently_correct"}}
{"example_id": 4138, "sql_complexity": "window functions", "prompt": "How many lifelong learning courses has a student with ID '2' completed, in chronological order?", "context": "CREATE TABLE lifelong_learning (student_id INT, course_id INT, completion_date DATE); INSERT INTO lifelong_learning VALUES (2, 1001, '2015-01-01'), (2, 1002, '2016-01-01');", "reference_sql": "SELECT student_id, course_id, COUNT(course_id) OVER (PARTITION BY student_id ORDER BY completion_date) as completed_courses FROM lifelong_learning WHERE student_id = 2;", "generated_sql": "SELECT COUNT(*) FROM lifelong_learning WHERE student_id = 2;", "raw_model_output": "\n\nSELECT COUNT(*) FROM lifelong_learning WHERE student_id = 2;", "latency_sec": 8.67437195777893, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 153, "prompt_eval_sec": null, "tokens_completion": 945, "completion_eval_sec": null, "tokens_total": 1098, "tokens_per_sec": 126.5797691572754, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns multiple rows with student course details and a cumulative count per row, while the Generated SQL returns a single aggregate count. The first query provides per-row analytics while the second only returns the total count of courses for the student.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query uses a window function to show cumulative counts per course, returning multiple rows with student_id, course_id, and incremental counts. The generated query correctly counts total courses for student 2. The original question asks for a simple count of completed courses, not per-course cumulative data. While the reference query includes 'chronological order' via ORDER BY, it doesn't answer the actual question about total quantity. The generated query is technically correct, efficient, and directly addresses the business intent of counting completed courses.", "overall_assessment": "incorrect"}}
{"example_id": 312, "sql_complexity": "aggregation", "prompt": "List the top 3 most represented ethnicities in movies produced in the USA.", "context": "CREATE TABLE movies (title VARCHAR(255), production_country VARCHAR(64), lead_actor_ethnicity VARCHAR(64));", "reference_sql": "SELECT lead_actor_ethnicity, COUNT(*) AS count FROM movies WHERE production_country = 'USA' GROUP BY lead_actor_ethnicity ORDER BY count DESC LIMIT 3;", "generated_sql": "SELECT lead_actor_ethnicity, COUNT(*) AS count\nFROM movies\nWHERE production_country = 'USA'\nGROUP BY lead_actor_ethnicity\nORDER BY count DESC\nLIMIT 3;", "raw_model_output": "\n\n```sql\nSELECT lead_actor_ethnicity, COUNT(*) AS count\nFROM movies\nWHERE production_country = 'USA'\nGROUP BY lead_actor_ethnicity\nORDER BY count DESC\nLIMIT 3;\n```", "latency_sec": 3.1347951889038086, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 114, "prompt_eval_sec": null, "tokens_completion": 338, "completion_eval_sec": null, "tokens_total": 452, "tokens_per_sec": 144.18804826546187, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select the lead_actor_ethnicity and count of movies from the USA, group by ethnicity, order by count descending, and limit to 3 results. The generated SQL is a formatted version of the reference query with no semantic differences.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "The reference and generated queries are identical in structure, logic, and syntax. Both correctly filter movies produced in the USA, group by lead actor ethnicity, count occurrences, order by count descending, and limit to the top 3 results. They perfectly address the business intent of identifying the most represented ethnicities in US-produced movies. Since the queries are identical, neither is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 4298, "sql_complexity": "single join", "prompt": "How many users joined the gym in Q1 2023?", "context": "CREATE TABLE memberships (id INT, user_id INT, join_date DATE); INSERT INTO memberships (id, user_id, join_date) VALUES (1, 5, '2023-01-15'), (2, 6, '2023-02-03'), (3, 7, '2023-03-20'), (4, 8, '2022-12-31');", "reference_sql": "SELECT COUNT(*) FROM memberships WHERE join_date BETWEEN '2023-01-01' AND '2023-03-31';", "generated_sql": "SELECT COUNT(*) FROM memberships WHERE join_date BETWEEN '2023-01-01' AND '2023-03-31';", "raw_model_output": "\n\nSELECT COUNT(*) FROM memberships WHERE join_date BETWEEN '2023-01-01' AND '2023-03-31';", "latency_sec": 6.647960901260376, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 185, "prompt_eval_sec": null, "tokens_completion": 722, "completion_eval_sec": null, "tokens_total": 907, "tokens_per_sec": 136.43281202632275, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They both count the number of records in the 'memberships' table where 'join_date' falls between '2023-01-01' and '2023-03-31', inclusive. The result will be the same for both queries.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "The reference and generated SQL queries are identical in structure, logic, and implementation. Both correctly count membership records where join_date falls within the Q1 2023 date range (2023-01-01 to 2023-03-31). The queries accurately reflect the business intent of counting users who joined during the first quarter of 2023. Since the queries are identical, neither is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 5211, "sql_complexity": "multiple_joins", "prompt": "What is the average transaction value in the last week, split by product category and customer demographics?", "context": "CREATE TABLE transactions (transaction_id INT, customer_id INT, product_id INT, category_id INT, transaction_date DATE, amount DECIMAL(10,2)); CREATE TABLE customers (customer_id INT, age INT, gender VARCHAR(10), location VARCHAR(255)); CREATE TABLE products (product_id INT, name VARCHAR(255), category_id INT);", "reference_sql": "SELECT c.age, c.gender, p.category_id, AVG(t.amount) as avg_transaction_value FROM transactions t INNER JOIN customers c ON t.customer_id = c.customer_id INNER JOIN products p ON t.product_id = p.product_id WHERE t.transaction_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 WEEK) GROUP BY c.age, c.gender, p.category_id;", "generated_sql": "SELECT \n    p.category_id AS product_category_id,\n    c.age,\n    c.gender,\n    c.location,\n    AVG(t.amount) AS average_transaction_value\nFROM \n    transactions t\nJOIN \n    customers c ON t.customer_id = c.customer_id\nJOIN \n    products p ON t.product_id = p.product_id\nWHERE \n    t.transaction_date >= CURRENT_DATE - INTERVAL '7 days'\nGROUP BY \n    p.category_id, c.age, c.gender, c.location\nORDER BY \n    p.category_id, c.age, c.gender, c.location;", "raw_model_output": "\n\nSELECT \n    p.category_id AS product_category_id,\n    c.age,\n    c.gender,\n    c.location,\n    AVG(t.amount) AS average_transaction_value\nFROM \n    transactions t\nJOIN \n    customers c ON t.customer_id = c.customer_id\nJOIN \n    products p ON t.product_id = p.product_id\nWHERE \n    t.transaction_date >= CURRENT_DATE - INTERVAL '7 days'\nGROUP BY \n    p.category_id, c.age, c.gender, c.location\nORDER BY \n    p.category_id, c.age, c.gender, c.location;", "latency_sec": 17.826333045959473, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 165, "prompt_eval_sec": null, "tokens_completion": 2082, "completion_eval_sec": null, "tokens_total": 2247, "tokens_per_sec": 126.04947939695911, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The generated query includes an additional column 'c.location' in both the SELECT and GROUP BY clauses, which changes the aggregation structure. Additionally, the alias for 'p.category_id' is different, and the ORDER BY clause is present in the generated query but not the reference. These differences alter the result set structure and grouping logic.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in two key aspects. 1) The generated query includes 'location' in the GROUP BY clause, which is not explicitly requested in the original question. 2) The date filter uses a different syntax (CURRENT_DATE - INTERVAL '7 days' vs DATE_SUB(CURRENT_DATE, INTERVAL 1 WEEK)), but both achieve the same result. While both queries correctly calculate the average transaction value for the last week, the reference query more accurately fulfills the business intent by only grouping by the explicitly requested dimensions (product category and customer demographics). The generated query's inclusion of 'location' in the grouping introduces an additional dimension not specified in the original question, potentially leading to results that are more granular than intended.", "overall_assessment": "differently_correct"}}
{"example_id": 382, "sql_complexity": "window functions", "prompt": "What is the average annual precipitation in the past 10 years for each weather station?", "context": "CREATE TABLE WeatherStation (ID INT, Name VARCHAR(100), Location VARCHAR(100), Elevation FLOAT, AnnualPrecipitation FLOAT); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (1, 'Station A', 'Arctic Circle', 100, 450); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (2, 'Station B', 'North Pole', 200, 300);", "reference_sql": "SELECT Name, AVG(AnnualPrecipitation) OVER (PARTITION BY Name ORDER BY Name ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS AvgAnnualPrecipitation FROM WeatherStation WHERE YEAR(CurrentDate) - YEAR(DateInstalled) BETWEEN 1 AND 10;", "generated_sql": "SELECT Name, AnnualPrecipitation AS AverageAnnualPrecipitation\nFROM WeatherStation;", "raw_model_output": "\n\nSELECT Name, AnnualPrecipitation AS AverageAnnualPrecipitation\nFROM WeatherStation;", "latency_sec": 4.341675043106079, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 203, "prompt_eval_sec": null, "tokens_completion": 339, "completion_eval_sec": null, "tokens_total": 542, "tokens_per_sec": 124.8366113582392, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL uses a window function to calculate an average (which would return the same value as AnnualPrecipitation for unique Name partitions) and includes a WHERE clause referencing a non-existent 'DateInstalled' column. The Generated SQL simply selects raw data without filtering or calculations. Additionally, column aliases differ (AvgAnnualPrecipitation vs. AnnualPrecipitation).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query attempts to calculate a moving average using a window function but contains a critical error: it references a non-existent 'DateInstalled' column in the WHERE clause. The generated query simply returns the AnnualPrecipitation value as-is without any averaging. Neither query correctly addresses the business intent, but the reference query's structure aligns more closely with the requirement for an average calculation, albeit with technical flaws. The schema's design (storing only a single AnnualPrecipitation value per station) makes it impossible to calculate a 10-year average as the question implies.", "overall_assessment": "incorrect"}}
{"example_id": 2190, "sql_complexity": "single join", "prompt": "What is the total number of humanitarian assistance events by each country in the last 3 years?", "context": "CREATE TABLE Humanitarian_Assistance (id INT, country VARCHAR(50), year INT, events INT); CREATE TABLE Countries (id INT, name VARCHAR(50), region VARCHAR(50));", "reference_sql": "SELECT co.name, SUM(ha.events) FROM Humanitarian_Assistance ha INNER JOIN Countries co ON ha.country = co.name WHERE ha.year BETWEEN (YEAR(CURRENT_DATE) - 3) AND YEAR(CURRENT_DATE) GROUP BY co.name;", "generated_sql": "SELECT C.name, SUM(HA.events) AS total_events\nFROM Humanitarian_Assistance HA\nJOIN Countries C ON HA.country = C.id\nWHERE HA.year >= (SELECT MAX(year) - 2 FROM Humanitarian_Assistance)\nGROUP BY C.name;", "raw_model_output": "\n\nSELECT C.name, SUM(HA.events) AS total_events\nFROM Humanitarian_Assistance HA\nJOIN Countries C ON HA.country = C.id\nWHERE HA.year >= (SELECT MAX(year) - 2 FROM Humanitarian_Assistance)\nGROUP BY C.name;", "latency_sec": 12.787675857543945, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 130, "prompt_eval_sec": null, "tokens_completion": 1621, "completion_eval_sec": null, "tokens_total": 1751, "tokens_per_sec": 136.92871320061005, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two critical aspects. First, the join condition: the reference uses 'ha.country = co.name' (matching country names), while the generated query uses 'ha.country = c.id' (matching country names to numeric IDs, which is incorrect). Second, the year filtering logic: the reference uses a fixed 4-year window (current year -3 to current year), whereas the generated query uses a dynamic range based on the maximum year in the table minus 2, which may not align with the current year. These differences in join logic and filtering criteria make the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly joins Humanitarian_Assistance.country with Countries.name (both VARCHAR) and filters for the last 3 calendar years using YEAR(CURRENT_DATE) - 3. The Generated SQL incorrectly joins on HA.country = C.id (mismatched data types between VARCHAR and INT) and uses a subquery that may not reliably capture exactly 3 years. The Generated query's WHERE clause (HA.year >= MAX(year)-2) could include more or fewer than 3 years depending on data gaps, while the Reference uses a precise year range. The join error in Generated SQL would produce incorrect country associations.", "overall_assessment": "incorrect"}}
{"example_id": 1852, "sql_complexity": "set operations", "prompt": "Compare coal production and employment rates in China and India between 2018 and 2020.", "context": "CREATE TABLE china_coal_production (year INT, production FLOAT); INSERT INTO china_coal_production (year, production) VALUES (2018, 3500.0), (2019, 3600.0), (2020, 3700.0); CREATE TABLE china_employment (year INT, employment FLOAT); INSERT INTO china_employment (year, employment) VALUES (2018, 8000000.0), (2019, 8100000.0), (2020, 8200000.0); CREATE TABLE india_coal_production (year INT, production FLOAT); INSERT INTO india_coal_production (year, production) VALUES (2018, 700.0), (2019, 750.0), (2020, 800.0); CREATE TABLE india_employment (year INT, employment FLOAT); INSERT INTO india_employment (year, employment) VALUES (2018, 1000000.0), (2019, 1050000.0), (2020, 1100000.0);", "reference_sql": "SELECT 'China' AS country, china_coal_production.production, china_employment.employment FROM china_coal_production INNER JOIN china_employment ON china_coal_production.year = china_employment.year WHERE china_coal_production.year BETWEEN 2018 AND 2020 UNION ALL SELECT 'India', india_coal_production.production, india_employment.employment FROM india_coal_production INNER JOIN india_employment ON india_coal_production.year = india_employment.year WHERE india_coal_production.year BETWEEN 2018 AND 2020;", "generated_sql": "SELECT \n    c.year,\n    c.production AS china_coal_production,\n    ce.employment AS china_employment,\n    i.production AS india_coal_production,\n    ie.employment AS india_employment\nFROM \n    china_coal_production c\nJOIN \n    china_employment ce ON c.year = ce.year\nJOIN \n    india_coal_production i ON c.year = i.year\nJOIN \n    india_employment ie ON c.year = ie.year\nWHERE \n    c.year BETWEEN 2018 AND 2020;", "raw_model_output": "\n\nSELECT \n    c.year,\n    c.production AS china_coal_production,\n    ce.employment AS china_employment,\n    i.production AS india_coal_production,\n    ie.employment AS india_employment\nFROM \n    china_coal_production c\nJOIN \n    china_employment ce ON c.year = ce.year\nJOIN \n    india_coal_production i ON c.year = i.year\nJOIN \n    india_employment ie ON c.year = ie.year\nWHERE \n    c.year BETWEEN 2018 AND 2020;", "latency_sec": 13.319071054458618, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 372, "prompt_eval_sec": null, "tokens_completion": 1364, "completion_eval_sec": null, "tokens_total": 1736, "tokens_per_sec": 130.33942028703768, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two rows per year (China and India) with country-specific production and employment values, while the Generated SQL returns one row per year with all four columns (China and India production/employment) combined. The structure and number of rows differ, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The Reference SQL returns separate rows for China and India per year (2 rows/year), while the Generated SQL returns a single row per year with both countries' data side-by-side. Both are technically correct, but the Generated SQL better fulfills the business intent by structuring data for direct comparison. The Generated SQL is more efficient as it avoids UNION ALL and provides a consolidated view, making it easier to compare metrics across countries in the same result set.", "overall_assessment": "differently_correct"}}
{"example_id": 2535, "sql_complexity": "subqueries", "prompt": "What is the maximum safety rating for vehicles in the vehiclesafety schema?", "context": "CREATE TABLE VehicleSafety (id INT, vehicle_id INT, safetyrating INT, PRIMARY KEY (id)); CREATE TABLE Vehicles (id INT, make VARCHAR(50), model VARCHAR(50), PRIMARY KEY (id)); CREATE TABLE LuxuryVehicles (id INT, vehicle_id INT, PRIMARY KEY (id), FOREIGN KEY (vehicle_id) REFERENCES Vehicles(id));", "reference_sql": "SELECT MAX(safetyrating) FROM vehicleSafety JOIN Vehicles ON vehicleSafety.vehicle_id = Vehicles.id WHERE EXISTS (SELECT * FROM LuxuryVehicles WHERE Vehicles.id = LuxuryVehicles.vehicle_id);", "generated_sql": "SELECT MAX(safetyrating) FROM VehicleSafety;", "raw_model_output": "\n\nSELECT MAX(safetyrating) FROM VehicleSafety;", "latency_sec": 2.745576858520508, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 157, "prompt_eval_sec": null, "tokens_completion": 296, "completion_eval_sec": null, "tokens_total": 453, "tokens_per_sec": 164.99264939321543, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters vehicles using an EXISTS clause to only include luxury vehicles (via LuxuryVehicles table), while the Generated SQL selects from VehicleSafety without any filters. The MAX(safetyrating) could differ if non-luxury vehicles have higher safety ratings than luxury ones.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query incorrectly filters results to only luxury vehicles via the EXISTS clause, while the original question makes no mention of luxury vehicles. The generated query directly retrieves the maximum safety rating from the VehicleSafety table, which aligns with the explicit requirement. The reference query introduces unnecessary complexity and changes the semantic intent by restricting the dataset. The generated query is technically correct, more efficient, and directly addresses the business question without additional constraints.", "overall_assessment": "correct"}}
{"example_id": 2140, "sql_complexity": "aggregation", "prompt": "What was the total amount of minerals extracted in the 'north' region for each month in 2020?", "context": "CREATE TABLE extraction(id INT, location TEXT, month INT, year INT, minerals_extracted FLOAT);INSERT INTO extraction(id, location, month, year, minerals_extracted) VALUES (1, 'north', 1, 2020, 1500), (2, 'north', 2, 2020, 1800), (3, 'south', 1, 2020, 1200);", "reference_sql": "SELECT month, SUM(minerals_extracted) FROM extraction WHERE location = 'north' AND year = 2020 GROUP BY month;", "generated_sql": "SELECT month, SUM(minerals_extracted) AS total_minerals\nFROM extraction\nWHERE location = 'north' AND year = 2020\nGROUP BY month;", "raw_model_output": "\n\n```sql\nSELECT month, SUM(minerals_extracted) AS total_minerals\nFROM extraction\nWHERE location = 'north' AND year = 2020\nGROUP BY month;\n```", "latency_sec": 2.37080979347229, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 193, "prompt_eval_sec": null, "tokens_completion": 356, "completion_eval_sec": null, "tokens_total": 549, "tokens_per_sec": 231.56644683668787, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same data by selecting 'month' and summing 'minerals_extracted' for 'north' locations in 2020, grouped by 'month'. The generated query adds an alias ('total_minerals') to the sum, but this does not affect the semantic result set structure or values.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically equivalent as they produce identical results by filtering 'north' region entries from 2020, grouping by month, and summing minerals_extracted. The generated query improves upon the reference by adding an explicit column alias ('total_minerals'), enhancing readability and clarity without altering functionality. While both fulfill the business intent of calculating monthly totals, the generated query's explicit alias makes the output more interpretable for end-users. Neither query has performance advantages over the other.", "overall_assessment": "correct"}}
{"example_id": 4779, "sql_complexity": "window functions", "prompt": "What is the average CO2 emission for the top 3 highest emitting countries since 2015?", "context": "CREATE TABLE emissions (country VARCHAR(50), year INT, co2_emission INT); INSERT INTO emissions (country, year, co2_emission) VALUES ('USA', 2015, 5373978000); INSERT INTO emissions (country, year, co2_emission) VALUES ('China', 2015, 10498600000); INSERT INTO emissions (country, year, co2_emission) VALUES ('India', 2015, 2633830000); INSERT INTO emissions (country, year, co2_emission) VALUES ('USA', 2016, 5518004000); INSERT INTO emissions (country, year, co2_emission) VALUES ('China', 2016, 10813000000); INSERT INTO emissions (country, year, co2_emission) VALUES ('India', 2016, 2799280000);", "reference_sql": "SELECT AVG(co2_emission) as avg_emission FROM (SELECT country, year, co2_emission, ROW_NUMBER() OVER (ORDER BY co2_emission DESC) as rn FROM emissions WHERE year >= 2015) t WHERE rn <= 3 GROUP BY country;", "generated_sql": "WITH country_totals AS (\n    SELECT country, SUM(co2_emission) AS total\n    FROM emissions\n    WHERE year >= 2015\n    GROUP BY country\n),\nranked_countries AS (\n    SELECT country, total,\n           ROW_NUMBER() OVER (ORDER BY total DESC) AS rn\n    FROM country_totals\n)\nSELECT AVG(total) AS average_emission\nFROM ranked_countries\nWHERE rn <= 3;", "raw_model_output": "\n\nTo determine the **average CO\u2082 emission for the top 3 highest emitting countries since 2015**, we need to:\n\n1. **Filter** the data to include only records from the year 2015 and later.\n2. **Group** the data by country and **sum** the CO\u2082 emissions for each country.\n3. **Rank** the countries by their total emissions in descending order.\n4. **Select** the top 3 countries.\n5. **Calculate** the average of their total emissions.\n\nThis approach ensures we are considering the **cumulative emissions** of each country since 2015, and then computing the **average of the top 3**.\n\n---\n\n### \u2705 Final SQL Query (Standard ANSI SQL)\n\n```sql\nWITH country_totals AS (\n    SELECT country, SUM(co2_emission) AS total\n    FROM emissions\n    WHERE year >= 2015\n    GROUP BY country\n),\nranked_countries AS (\n    SELECT country, total,\n           ROW_NUMBER() OVER (ORDER BY total DESC) AS rn\n    FROM country_totals\n)\nSELECT AVG(total) AS average_emission\nFROM ranked_countries\nWHERE rn <= 3;\n```\n\n---\n\n### \ud83d\udd0d Explanation\n\n- **`country_totals` CTE**: Aggregates emissions per country from 2015 onward.\n- **`ranked_countries` CTE**: Assigns a rank to each country based on total emissions.\n- **Final `SELECT`**: Computes the average of the top 3 countries' total emissions.\n\nThis query is fully compliant with **ANSI SQL** and avoids non-standard syntax like `LIMIT`.", "latency_sec": 19.163996934890747, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 323, "prompt_eval_sec": null, "tokens_completion": 2673, "completion_eval_sec": null, "tokens_total": 2996, "tokens_per_sec": 156.33481941052503, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the average CO2 emission per country from the top 3 individual emission records (sorted by co2_emission DESC), while the Generated SQL calculates the average total CO2 emission per country (summed across all years >=2015) for the top 3 countries by total emissions. The Reference SQL groups by country after filtering top 3 rows, producing multiple averages, whereas the Generated SQL computes a single average of the top 3 countries' totals. The data aggregation and ranking logic differ fundamentally.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is technically incorrect and fails to fulfill the business intent. It ranks individual emission records (not per-country totals) and groups by country, which would return separate averages for each of the top 3 countries rather than a single average of their emissions. The Generated SQL correctly aggregates emissions per country first, ranks them by total emissions, and calculates the average of the top 3 countries' totals. This aligns with the business requirement to find the average CO2 emission for the top 3 countries since 2015.", "overall_assessment": "incorrect"}}
{"example_id": 1015, "sql_complexity": "subqueries", "prompt": "List the top 3 most expensive eco-friendly products in Europe and their suppliers.", "context": "CREATE TABLE Suppliers (supplierID INT, supplierName VARCHAR(50), country VARCHAR(50)); CREATE TABLE Products (productID INT, productName VARCHAR(50), price DECIMAL(10,2), ecoFriendly BOOLEAN, supplierID INT);", "reference_sql": "SELECT P.productName, P.price, S.supplierName FROM (SELECT * FROM Products WHERE ecoFriendly = TRUE ORDER BY price DESC LIMIT 3) P JOIN Suppliers S ON P.supplierID = S.supplierID;", "generated_sql": "SELECT p.productName, p.price, s.supplierName\nFROM Products p\nJOIN Suppliers s ON p.supplierID = s.supplierID\nWHERE p.ecoFriendly = TRUE AND s.country = 'Europe'\nORDER BY p.price DESC\nLIMIT 3;", "raw_model_output": "\n\n```sql\nSELECT p.productName, p.price, s.supplierName\nFROM Products p\nJOIN Suppliers s ON p.supplierID = s.supplierID\nWHERE p.ecoFriendly = TRUE AND s.country = 'Europe'\nORDER BY p.price DESC\nLIMIT 3;\n```", "latency_sec": 4.268428087234497, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 138, "prompt_eval_sec": null, "tokens_completion": 504, "completion_eval_sec": null, "tokens_total": 642, "tokens_per_sec": 150.40665717668213, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in filtering conditions. The Reference SQL only filters by ecoFriendly = TRUE, while the Generated SQL adds an additional condition WHERE s.country = 'Europe'. This extra filter in the Generated SQL will exclude suppliers not in Europe, making the results potentially different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries are not technically equivalent. The Reference SQL incorrectly filters only on ecoFriendly products but does not enforce the European supplier requirement, potentially returning products from non-European suppliers. The Generated SQL properly filters both eco-friendly products and European suppliers in the WHERE clause. While both retrieve top 3 most expensive items, the Reference SQL fails to address the 'Europe' constraint, making it incomplete. The Generated SQL correctly fulfills the business intent by ensuring suppliers are located in Europe.", "overall_assessment": "differently_correct"}}
{"example_id": 3715, "sql_complexity": "aggregation", "prompt": "What is the average age of engines still in service for each engine type?", "context": "CREATE TABLE Engine (id INT, aircraft_id INT, engine_type VARCHAR(255), hours_since_last_service INT, manufacture_year INT); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (1, 1, 'GE90-115B', 500, 2000); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (2, 2, 'CFM56-5B', 1000, 1995); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (3, 1, 'GE90-115B', 700, 2002);", "reference_sql": "SELECT engine_type, AVG(YEAR(CURRENT_DATE) - manufacture_year) as avg_age FROM Engine GROUP BY engine_type;", "generated_sql": "SELECT \n    engine_type, \n    AVG(EXTRACT(YEAR FROM CURRENT_DATE) - manufacture_year) AS average_age\nFROM \n    Engine\nGROUP BY \n    engine_type;", "raw_model_output": "\n\nTo determine the **average age of engines still in service for each engine type**, we need to:\n\n1. **Calculate the age** of each engine. Since the age is typically defined as the difference between the **current year** and the **manufacture year**, we use the `EXTRACT(YEAR FROM CURRENT_DATE)` function to get the current year.\n2. **Group the results** by `engine_type` to compute the average age per type.\n3. **Assume all engines in the `Engine` table are still in service**, as there is no column indicating whether an engine is out of service.\n\n---\n\n### \u2705 Final SQL Query\n\n```sql\nSELECT \n    engine_type, \n    AVG(EXTRACT(YEAR FROM CURRENT_DATE) - manufacture_year) AS average_age\nFROM \n    Engine\nGROUP BY \n    engine_type;\n```\n\n---\n\n### \ud83d\udccc Notes\n\n- This query uses **standard ANSI SQL** and assumes that all engines in the `Engine` table are still in service.\n- The `EXTRACT(YEAR FROM CURRENT_DATE)` function is used to dynamically calculate the current year, ensuring the age is always up-to-date.\n- If your SQL dialect does not support `CURRENT_DATE`, you may need to substitute it with a function like `GETDATE()` (for SQL Server) or `NOW()` (for MySQL), but this query adheres to ANSI standards.", "latency_sec": 15.23884129524231, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 258, "prompt_eval_sec": null, "tokens_completion": 1670, "completion_eval_sec": null, "tokens_total": 1928, "tokens_per_sec": 126.51880563924091, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average age of engines by subtracting the manufacture_year from the current year. The difference between YEAR(CURRENT_DATE) and EXTRACT(YEAR FROM CURRENT_DATE) is negligible here, as both return the same numeric value for the current year. The column alias difference (avg_age vs average_age) does not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries calculate the average age of engines by subtracting the manufacture year from the current year, grouped by engine type. The reference uses `YEAR(CURRENT_DATE)` while the generated uses `EXTRACT(YEAR FROM CURRENT_DATE)`, which are functionally equivalent in most SQL dialects. Neither query explicitly filters for 'engines still in service' since the context lacks a status column, but the question assumes all records in the Engine table represent active engines. Both queries correctly address the business intent by computing the average age of engines by type. The choice between `YEAR()` and `EXTRACT()` is stylistic, with no significant efficiency difference.", "overall_assessment": "correct"}}
{"example_id": 1957, "sql_complexity": "set operations", "prompt": "What is the average temperature recorded for the 'polar_bear' species in the 'Arctic_Animals' table compared to the 'penguin' species in the 'Antarctic_Animals' table?", "context": "CREATE TABLE Arctic_Animals (species TEXT, avg_temp FLOAT); CREATE TABLE Antarctic_Animals (species TEXT, avg_temp FLOAT);", "reference_sql": "SELECT AVG(Arctic_Animals.avg_temp) FROM Arctic_Animals WHERE Arctic_Animals.species = 'polar_bear' INTERSECT SELECT AVG(Antarctic_Animals.avg_temp) FROM Antarctic_Animals WHERE Antarctic_Animals.species = 'penguin'", "generated_sql": "SELECT \n    (SELECT AVG(avg_temp) FROM Arctic_Animals WHERE species = 'polar_bear') AS avg_arctic,\n    (SELECT AVG(avg_temp) FROM Antarctic_Animals WHERE species = 'penguin') AS avg_antarctic;", "raw_model_output": "\n\nSELECT \n    (SELECT AVG(avg_temp) FROM Arctic_Animals WHERE species = 'polar_bear') AS avg_arctic,\n    (SELECT AVG(avg_temp) FROM Antarctic_Animals WHERE species = 'penguin') AS avg_antarctic;", "latency_sec": 4.638430833816528, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 139, "prompt_eval_sec": null, "tokens_completion": 498, "completion_eval_sec": null, "tokens_total": 637, "tokens_per_sec": 137.3309256561389, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses INTERSECT to find common values between two aggregated results, requiring the average temperatures to be identical to return a row. The Generated SQL returns both averages as separate columns in a single row. The first query enforces equality between the two averages, while the second retrieves them independently, leading to different result structures and semantics.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL is technically incorrect because it uses INTERSECT, which returns only common rows between two result sets. Since each subquery returns a single value (average temperature), INTERSECT would only return a result if the two averages were exactly equal (which is unlikely). This fundamentally misrepresents the comparison intent. The Generated SQL correctly uses two independent subqueries to calculate and return both averages as separate columns, directly answering the comparison question. While both queries are syntactically valid, only the Generated SQL fulfills the business intent of comparing the two averages.", "overall_assessment": "differently_correct"}}
{"example_id": 1311, "sql_complexity": "basic SQL", "prompt": "What is the total number of veteran job applications in Texas in the last year?", "context": "CREATE TABLE veteran_jobs (id INT, state VARCHAR(50), application_date DATE); INSERT INTO veteran_jobs (id, state, application_date) VALUES (1, 'Texas', '2021-02-15'), (2, 'California', '2021-04-10'), (3, 'Texas', '2022-01-05');", "reference_sql": "SELECT COUNT(*) FROM veteran_jobs WHERE state = 'Texas' AND application_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR);", "generated_sql": "SELECT COUNT(*) \nFROM veteran_jobs \nWHERE state = 'Texas' \n  AND application_date >= CURRENT_DATE - INTERVAL '1 YEAR';", "raw_model_output": "\n\nTo determine the total number of veteran job applications in Texas within the last year, we need to filter the `veteran_jobs` table based on two conditions:\n\n1. The `state` must be `'Texas'`.\n2. The `application_date` must fall within the last 365 days from the current date.\n\nIn standard ANSI SQL, we can use the `CURRENT_DATE` function to get today's date and subtract an interval of one year using the `INTERVAL '1 YEAR'` syntax.\n\n---\n\n### \u2705 SQL Query\n\n```sql\nSELECT COUNT(*) \nFROM veteran_jobs \nWHERE state = 'Texas' \n  AND application_date >= CURRENT_DATE - INTERVAL '1 YEAR';\n```\n\n---\n\n### \ud83d\udccc Notes\n\n- This query assumes that `application_date` is stored as a `DATE` type, which it is in the provided schema.\n- The `CURRENT_DATE` function returns the current date without a time component, which is appropriate for comparison with a `DATE` field.\n- The `INTERVAL '1 YEAR'` syntax is standard SQL and should work across most SQL databases that support it (e.g., PostgreSQL, Oracle, etc.). For databases like MySQL, you might use `DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR)` instead, but the question specifies ANSI SQL.", "latency_sec": 9.125329732894897, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 171, "prompt_eval_sec": null, "tokens_completion": 1278, "completion_eval_sec": null, "tokens_total": 1449, "tokens_per_sec": 158.78878269753469, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count records where state is 'Texas' and application_date is within the last year. The date calculation syntax differs (DATE_SUB vs. CURRENT_DATE - INTERVAL), but both expressions evaluate to the same date value. The semantic logic for filtering records remains identical.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent. The reference query uses DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR) which is valid MySQL syntax. The generated query uses CURRENT_DATE - INTERVAL '1 YEAR' which has two issues: 1) The '1 YEAR' literal with quotes is invalid syntax (should be 1 YEAR without quotes) and 2) The subtraction operator (-) with INTERVAL is not standard SQL for date calculations. While both aim to calculate the date one year ago, the generated query contains syntax errors that would prevent execution in most SQL databases. The reference query correctly fulfills the business intent by accurately filtering Texas applications within the last year, whereas the generated query would fail due to syntax issues.", "overall_assessment": "incorrect"}}
{"example_id": 2997, "sql_complexity": "window functions", "prompt": "What is the earliest capture time for each satellite image in the 'satellite_images' table?", "context": "CREATE TABLE satellite_images (image_id INT, image_url TEXT, capture_time TIMESTAMP); INSERT INTO satellite_images (image_id, image_url, capture_time) VALUES (1, 'image1.jpg', '2022-01-01 10:00:00'), (2, 'image2.jpg', '2021-05-01 10:00:00');", "reference_sql": "SELECT image_id, MIN(capture_time) OVER (PARTITION BY image_id) FROM satellite_images;", "generated_sql": "SELECT image_id, capture_time FROM satellite_images;", "raw_model_output": "\n\nSELECT image_id, capture_time FROM satellite_images;", "latency_sec": 5.076493978500366, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 179, "prompt_eval_sec": null, "tokens_completion": 730, "completion_eval_sec": null, "tokens_total": 909, "tokens_per_sec": 179.0605886365151, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "In the given schema, image_id is unique per row. The Reference SQL uses a window function MIN(capture_time) OVER (PARTITION BY image_id), which for each unique image_id (single-row partition) returns the same capture_time as the raw column. Thus, both queries return identical results for the provided data.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries return the same results because the 'image_id' is unique, making the MIN(capture_time) OVER (PARTITION BY image_id) equivalent to the raw capture_time. However, the generated query is technically simpler and more efficient, as it avoids unnecessary window function computation. The reference query's approach is unnecessarily complex for this specific schema where each image_id corresponds to a single capture time. Both fulfill the business intent of retrieving capture times, but the generated query does so more directly.", "overall_assessment": "differently_correct"}}
{"example_id": 3743, "sql_complexity": "aggregation", "prompt": "What is the maximum budget spent on peacekeeping operations by each department?", "context": "CREATE TABLE DepartmentPeacekeeping (id INT, department VARCHAR(50), budget INT);", "reference_sql": "SELECT department, MAX(budget) FROM DepartmentPeacekeeping GROUP BY department;", "generated_sql": "SELECT department, MAX(budget) \nFROM DepartmentPeacekeeping \nGROUP BY department;", "raw_model_output": "\n\nSELECT department, MAX(budget) \nFROM DepartmentPeacekeeping \nGROUP BY department;", "latency_sec": 2.810966968536377, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 102, "prompt_eval_sec": null, "tokens_completion": 293, "completion_eval_sec": null, "tokens_total": 395, "tokens_per_sec": 140.52103935097816, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. The generated SQL merely adds line breaks for formatting, but the SELECT clause, FROM clause, and GROUP BY clause are exactly the same. Both queries select the department and maximum budget per department from the DepartmentPeacekeeping table.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are syntactically identical except for formatting (line breaks). They both correctly calculate the maximum budget per department using GROUP BY and MAX() aggregation. The business intent of identifying the highest budget per department is fully satisfied. Neither query is more efficient or elegant than the other as they execute the same logic with identical structure.", "overall_assessment": "correct"}}
{"example_id": 4664, "sql_complexity": "multiple_joins", "prompt": "Calculate the total number of volunteer hours contributed by volunteers from 'California' in 'Health' projects in 2021.", "context": "CREATE TABLE volunteers (volunteer_id INT, name VARCHAR(255), state VARCHAR(255));", "reference_sql": "SELECT SUM(vh.hours) as total_hours FROM volunteer_projects vp JOIN volunteer_hours vh ON vp.project_id = vh.project_id JOIN volunteers vol ON vh.volunteer_id = vol.volunteer_id WHERE vp.cause = 'Health' AND vol.state = 'California' AND vh.volunteer_date BETWEEN '2021-01-01' AND '2021-12-31';", "generated_sql": "The provided database schema only includes a `volunteers` table with columns `volunteer_id`, `name`, and `state`. There is no information about projects, volunteer hours, or timestamps (e.g., year) in the schema. Therefore, it is **not possible** to calculate the total volunteer hours contributed by California volunteers in Health projects in 2021 with the given tables. \n\nA valid SQL query would require additional tables (e.g., `projects`, `volunteer_hours`) and columns (e.g., `project_type`, `hours`, `year`) not present in the provided schema.", "raw_model_output": "\n\nThe provided database schema only includes a `volunteers` table with columns `volunteer_id`, `name`, and `state`. There is no information about projects, volunteer hours, or timestamps (e.g., year) in the schema. Therefore, it is **not possible** to calculate the total volunteer hours contributed by California volunteers in Health projects in 2021 with the given tables. \n\nA valid SQL query would require additional tables (e.g., `projects`, `volunteer_hours`) and columns (e.g., `project_type`, `hours`, `year`) not present in the provided schema.", "latency_sec": 3.759861707687378, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 119, "prompt_eval_sec": null, "tokens_completion": 408, "completion_eval_sec": null, "tokens_total": 527, "tokens_per_sec": 140.1647297086754, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL relies on tables (volunteer_projects, volunteer_hours) and columns (hours, volunteer_date, cause) not present in the provided schema. The Generated SQL explanation states these elements are missing, making it impossible to execute. Since one query is valid and the other is not a valid query, they cannot be semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL assumes the existence of tables (volunteer_projects, volunteer_hours) and columns (cause, hours, volunteer_date) not present in the provided schema. The Generated SQL correctly identifies that the required data structure is missing. While both queries fail to execute against the given schema, the Generated SQL accurately explains the limitations rather than attempting invalid joins. The Reference SQL would produce an error due to missing tables, while the Generated SQL properly acknowledges the schema constraints.", "overall_assessment": "incorrect"}}
{"example_id": 251, "sql_complexity": "set operations", "prompt": "Compare the number of economic diversification projects in two regions, one in Europe and one in Oceania, by showing the project type and the number of projects in each region.", "context": "CREATE TABLE economic_diversification (region VARCHAR(50), project_type VARCHAR(50), project_start_date DATE);", "reference_sql": "SELECT 'Europe' as region, project_type, COUNT(*) as project_count FROM economic_diversification WHERE region = 'Europe' UNION ALL SELECT 'Oceania' as region, project_type, COUNT(*) as project_count FROM economic_diversification WHERE region = 'Oceania';", "generated_sql": "SELECT region, project_type, COUNT(*) AS num_projects\nFROM economic_diversification\nWHERE region IN ('Europe', 'Oceania')\nGROUP BY region, project_type\nORDER BY region, project_type;", "raw_model_output": "\n\nSELECT region, project_type, COUNT(*) AS num_projects\nFROM economic_diversification\nWHERE region IN ('Europe', 'Oceania')\nGROUP BY region, project_type\nORDER BY region, project_type;", "latency_sec": 7.3349769115448, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 131, "prompt_eval_sec": null, "tokens_completion": 1086, "completion_eval_sec": null, "tokens_total": 1217, "tokens_per_sec": 165.9173593422656, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries produce the same result by counting project types per region for 'Europe' and 'Oceania'. The reference query uses two separate SELECTs with UNION ALL, while the generated query uses GROUP BY and WHERE IN. The generated query's ORDER BY does not affect the data content, only the ordering of results, which is not considered in semantic equivalence unless explicitly required.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries produce the same semantic results by grouping project counts by region and project type. The reference query uses two separate SELECTs with UNION ALL, which achieves the same output as the generated query's single GROUP BY. However, the generated query is more efficient as it scans the table once and uses a single aggregation, while the reference query requires two table scans. The generated query also aligns better with standard SQL practices for this type of comparison. Both fulfill the business intent of comparing project counts between Europe and Oceania by type, but the generated version is more elegant and efficient.", "overall_assessment": "correct"}}
{"example_id": 610, "sql_complexity": "subqueries", "prompt": "What is the percentage of community development projects completed in 'Caribbean' in 2020?", "context": "CREATE TABLE community_projects (project_id INT, project_name TEXT, location TEXT, completion_year INT); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (1, 'Community Center', 'Southern Region, Caribbean', 2020); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (2, 'Park Renovation', 'Northern Region, Caribbean', 2019); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (3, 'Library Construction', 'Caribbean', 2020);", "reference_sql": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM community_projects WHERE location = 'Caribbean')) FROM community_projects WHERE completion_year = 2020 AND location = 'Caribbean';", "generated_sql": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM community_projects)) AS percentage\nFROM community_projects\nWHERE location LIKE '%Caribbean%' AND completion_year = 2020;", "raw_model_output": "\n\nSELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM community_projects)) AS percentage\nFROM community_projects\nWHERE location LIKE '%Caribbean%' AND completion_year = 2020;", "latency_sec": 18.46984624862671, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 218, "prompt_eval_sec": null, "tokens_completion": 2711, "completion_eval_sec": null, "tokens_total": 2929, "tokens_per_sec": 158.5828035908951, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. 1) The Reference SQL uses an exact match for 'Caribbean' in the location, while the Generated SQL uses a LIKE '%Caribbean%' pattern match, which would include locations with 'Caribbean' as part of a longer string. 2) The denominator in the Reference SQL is the count of all projects in the 'Caribbean' location, while the Generated SQL uses the total count of all projects. These differences in both numerator and denominator conditions will result in different calculated percentages.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries differ in both logic and intent. The reference query calculates the percentage of Caribbean projects completed in 2020 relative to all Caribbean projects (denominator = total Caribbean projects), while the generated query calculates the percentage of all projects that are both in the Caribbean (using LIKE) and completed in 2020 (denominator = total projects). The original question asks for the percentage of projects completed in the Caribbean in 2020, which aligns with the generated query's approach. The reference query's exact match on 'Caribbean' excludes projects like 'Southern Region, Caribbean', which likely should be included. The generated query's use of LIKE '%Caribbean%' better captures all relevant projects, and its denominator (total projects) aligns with the phrasing of the question. The reference query's denominator is incorrect for the stated intent.", "overall_assessment": "differently_correct"}}
{"example_id": 421, "sql_complexity": "set operations", "prompt": "What is the combined landfill capacity for 'City A' and 'City B'?", "context": "CREATE TABLE landfill_capacity (city VARCHAR(255), capacity INT); INSERT INTO landfill_capacity (city, capacity) VALUES ('City A', 500000), ('City B', 600000);", "reference_sql": "SELECT SUM(capacity) FROM (SELECT capacity FROM landfill_capacity WHERE city = 'City A' UNION ALL SELECT capacity FROM landfill_capacity WHERE city = 'City B') AS combined_capacity;", "generated_sql": "SELECT SUM(capacity) FROM landfill_capacity WHERE city IN ('City A', 'City B');", "raw_model_output": "\n\nSELECT SUM(capacity) FROM landfill_capacity WHERE city IN ('City A', 'City B');", "latency_sec": 1.8634800910949707, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 136, "prompt_eval_sec": null, "tokens_completion": 214, "completion_eval_sec": null, "tokens_total": 350, "tokens_per_sec": 187.82062747680976, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of capacities for 'City A' and 'City B'. The Reference SQL uses a UNION ALL to combine rows from two subqueries, while the Generated SQL uses a single WHERE clause with IN. Since both approaches aggregate the same set of rows (capacity values for the specified cities), they produce identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the combined landfill capacity for 'City A' and 'City B'. The Reference SQL uses a subquery with UNION ALL to combine individual city capacities before summing, while the Generated SQL directly filters and sums the capacities in a single query. Technically, they produce identical results. However, the Generated SQL is more efficient and elegant as it avoids unnecessary subquery complexity and directly leverages the IN clause for filtering. Both fulfill the business intent of combining capacities, but the Generated SQL achieves it with simpler, more optimized logic.", "overall_assessment": "correct"}}
{"example_id": 880, "sql_complexity": "aggregation", "prompt": "Show veteran employment statistics for each state in the 'veteran_employment' table", "context": "CREATE TABLE veteran_employment (employee_id INT, state VARCHAR(2), job_title VARCHAR(50), employment_date DATE);", "reference_sql": "SELECT state, COUNT(*) as veteran_employees FROM veteran_employment WHERE state IN ('CA', 'NY', 'TX', 'FL', 'PA') GROUP BY state;", "generated_sql": "SELECT state, COUNT(*) AS total_employees\nFROM veteran_employment\nGROUP BY state;", "raw_model_output": "\n\nSELECT state, COUNT(*) AS total_employees\nFROM veteran_employment\nGROUP BY state;", "latency_sec": 2.6004810333251953, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 114, "prompt_eval_sec": null, "tokens_completion": 401, "completion_eval_sec": null, "tokens_total": 515, "tokens_per_sec": 198.04028308619402, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters results to only include records where the state is in ('CA', 'NY', 'TX', 'FL', 'PA'), while the Generated SQL includes all states without any restriction. This means the Generated SQL may return additional states not present in the Reference SQL's filter, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in their filtering logic. The Reference SQL explicitly filters for specific states ('CA', 'NY', 'TX', 'FL', 'PA'), while the Generated SQL includes all states present in the table. The original question asks for statistics 'for each state' in the table without specifying particular states, making the Generated SQL more aligned with the explicit requirement to show data for all states. The Reference SQL could be incorrect if the business intent was to include all states, though it might be valid if the question implicitly required only those five states. However, since the question doesn't mention any state restrictions, the Generated SQL better fulfills the intent.", "overall_assessment": "differently_correct"}}
{"example_id": 454, "sql_complexity": "single join", "prompt": "Which excavation sites have more than 10 artifacts?", "context": "CREATE TABLE ExcavationSite (SiteID INT, SiteName VARCHAR(50)); INSERT INTO ExcavationSite (SiteID, SiteName) VALUES (1, 'Site A'), (2, 'Site B'), (3, 'Site C'); CREATE TABLE Artifact (ArtifactID INT, SiteID INT, ObjectType VARCHAR(50)); INSERT INTO Artifact (ArtifactID, SiteID, ObjectType) VALUES (1, 1, 'Pottery'), (2, 1, 'Tool'), (3, 2, 'Statue'), (4, 2, 'Bead'), (5, 3, 'Bead'), (6, 3, 'Bead'), (7, 3, 'Bead'), (8, 3, 'Bead'), (9, 3, 'Bead'), (10, 3, 'Bead'), (11, 3, 'Bead');", "reference_sql": "SELECT e.SiteName FROM ExcavationSite e JOIN Artifact a ON e.SiteID = a.SiteID GROUP BY e.SiteName HAVING COUNT(a.ArtifactID) > 10;", "generated_sql": "SELECT e.SiteID, e.SiteName\nFROM ExcavationSite e\nINNER JOIN (\n    SELECT SiteID\n    FROM Artifact\n    GROUP BY SiteID\n    HAVING COUNT(*) > 10\n) AS a ON e.SiteID = a.SiteID;", "raw_model_output": "\n\nSELECT e.SiteID, e.SiteName\nFROM ExcavationSite e\nINNER JOIN (\n    SELECT SiteID\n    FROM Artifact\n    GROUP BY SiteID\n    HAVING COUNT(*) > 10\n) AS a ON e.SiteID = a.SiteID;", "latency_sec": 12.108548164367676, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 276, "prompt_eval_sec": null, "tokens_completion": 1517, "completion_eval_sec": null, "tokens_total": 1793, "tokens_per_sec": 148.07720757772884, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects only 'SiteName' and groups by it, while the Generated SQL selects both 'SiteID' and 'SiteName' after filtering via a subquery. The output columns differ, and the Reference SQL's GROUP BY clause uses 'SiteName' (which is not unique in a general case) instead of 'SiteID' (which is unique). Although both aim to find sites with >10 artifacts, their result structures and grouping logic differ.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "While both queries return sites with more than 10 artifacts, they differ in implementation. The Reference SQL groups by SiteName (which could be non-unique) and counts artifacts after joining, while the Generated SQL first filters sites with >10 artifacts via a subquery grouping by SiteID (the true primary key). The Generated SQL is more efficient (filters first) and avoids potential grouping issues with non-unique SiteNames. Both correctly answer the business question in this specific dataset, but the Generated SQL is technically superior.", "overall_assessment": "differently_correct"}}
{"example_id": 1086, "sql_complexity": "aggregation", "prompt": "What is the total CO2 emission for each equipment type, excluding equipment that is older than 8 years?", "context": "CREATE TABLE EmissionData (EquipmentID INT, EquipmentType VARCHAR(50), CO2Emission INT, Age INT); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (1, 'Excavator', 50, 8); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (2, 'Haul Truck', 70, 7); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (3, 'Shovel', 30, 6); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (4, 'Drilling Rig', 40, 3);", "reference_sql": "SELECT EquipmentType, SUM(CO2Emission) as TotalCO2Emission FROM EmissionData WHERE Age <= 8 GROUP BY EquipmentType;", "generated_sql": "SELECT EquipmentType, SUM(CO2Emission) AS TotalCO2Emission\nFROM EmissionData\nWHERE Age <= 8\nGROUP BY EquipmentType;", "raw_model_output": "\n\nSELECT EquipmentType, SUM(CO2Emission) AS TotalCO2Emission\nFROM EmissionData\nWHERE Age <= 8\nGROUP BY EquipmentType;", "latency_sec": 3.3695120811462402, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 257, "prompt_eval_sec": null, "tokens_completion": 437, "completion_eval_sec": null, "tokens_total": 694, "tokens_per_sec": 205.96453827342123, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. They both select EquipmentType and sum CO2Emission where Age <= 8, grouping by EquipmentType. The differences are purely stylistic (whitespace and keyword casing) and do not affect semantic meaning.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure, logic, and syntax. They correctly filter equipment with Age <= 8, group by EquipmentType, and calculate total CO2 emissions. The minor formatting difference (e.g., 'as' vs 'AS') has no technical impact. Both fully address the business requirement to exclude equipment older than 8 years.", "overall_assessment": "correct"}}
{"example_id": 3455, "sql_complexity": "basic SQL", "prompt": "What are the names of all innovation projects in the 'rural_infrastructure' table, excluding those with a budget over 50000?", "context": "CREATE TABLE rural_infrastructure (name VARCHAR(255), budget INT); INSERT INTO rural_infrastructure (name, budget) VALUES ('Dam Construction', 40000), ('Well Digging', 30000), ('Irrigation System', 70000);", "reference_sql": "SELECT name FROM rural_infrastructure WHERE budget <= 50000;", "generated_sql": "SELECT name FROM rural_infrastructure WHERE budget <= 50000;", "raw_model_output": "\n\nSELECT name FROM rural_infrastructure WHERE budget <= 50000;", "latency_sec": 3.215068817138672, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 164, "prompt_eval_sec": null, "tokens_completion": 406, "completion_eval_sec": null, "tokens_total": 570, "tokens_per_sec": 177.29013978222875, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure and conditions. Both select the 'name' column from the 'rural_infrastructure' table where budget is less than or equal to 50000, producing the same result set.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic. They select the 'name' column from the 'rural_infrastructure' table where the 'budget' is less than or equal to 50000. This correctly excludes projects with budgets over 50000 as required by the question. The queries are semantically identical, produce the same results, and efficiently address the business intent with optimal simplicity.", "overall_assessment": "correct"}}
{"example_id": 3936, "sql_complexity": "window functions", "prompt": "What is the total investment per client for each investment type?", "context": "CREATE TABLE clients (client_id INT, name TEXT, investment_type TEXT, investment FLOAT); INSERT INTO clients (client_id, name, investment_type, investment) VALUES (1, 'John Doe', 'Stocks', 3000.00), (1, 'John Doe', 'Bonds', 2000.00), (2, 'Jane Smith', 'Stocks', 5000.00);", "reference_sql": "SELECT client_id, name, investment_type, SUM(investment) OVER (PARTITION BY client_id, investment_type ORDER BY client_id) as total_investment FROM clients;", "generated_sql": "SELECT client_id, name, investment_type, SUM(investment) AS total_investment\nFROM clients\nGROUP BY client_id, name, investment_type;", "raw_model_output": "\n\nTo compute the **total investment per client for each investment type**, we need to aggregate the `investment` values by both the `client_id` and `investment_type`. This ensures that for each unique combination of client and investment type, we sum up their respective investments.\n\nSince the `client_id` is the primary key and uniquely identifies each client, and the `name` is functionally dependent on `client_id`, it is safe to include `client_id` and `investment_type` in the `GROUP BY` clause. However, to strictly adhere to **ANSI SQL standards**, all non-aggregated columns in the `SELECT` clause must be included in the `GROUP BY`.\n\n---\n\n### \u2705 Final SQL Query:\n\n```sql\nSELECT client_id, name, investment_type, SUM(investment) AS total_investment\nFROM clients\nGROUP BY client_id, name, investment_type;\n```\n\n---\n\n### \ud83d\udccc Explanation:\n\n- `client_id`: Unique identifier for each client.\n- `name`: Name of the client (functionally dependent on `client_id`).\n- `investment_type`: Type of investment (e.g., Stocks, Bonds).\n- `SUM(investment)`: Aggregates the investment amounts for each group.\n\nThis query will return one row per client-investment type combination, with the total investment for that combination.", "latency_sec": 10.900330066680908, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 175, "prompt_eval_sec": null, "tokens_completion": 1323, "completion_eval_sec": null, "tokens_total": 1498, "tokens_per_sec": 137.42703118494953, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query uses a window function to calculate a running total within partitions, retaining all original rows. The generated query aggregates rows using GROUP BY, reducing the result set to one row per client_id/investment_type combination. For example, with multiple entries per client/investment_type, the window function would show cumulative sums per row while the GROUP BY version would show total sums per group.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query uses a window function to calculate a running total per client/investment type, but does not aggregate rows. This would return duplicate entries for clients with multiple investments in the same type (e.g., 2 rows for John Doe's Stocks would both show $3000). The generated query properly groups by client_id, name, and investment_type, ensuring one row per client/investment type with accurate aggregation. While both queries calculate sums, only the generated query meets the requirement for 'total investment per client for each investment type' by eliminating duplicates and providing consolidated results. The reference query's ORDER BY clause is unnecessary for this calculation and reduces efficiency.", "overall_assessment": "differently_correct"}}
{"example_id": 1838, "sql_complexity": "window functions", "prompt": "What are the top 3 species with the most sightings across all arctic research stations?", "context": "CREATE TABLE research_station (id INT, name TEXT); INSERT INTO research_station (id, name) VALUES (1, 'Station A'); INSERT INTO research_station (id, name) VALUES (2, 'Station B'); CREATE TABLE species_observations (station_id INT, species_name TEXT, sightings INT); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (1, 'Species 1', 10); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (1, 'Species 2', 5); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (2, 'Species 1', 8); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (2, 'Species 3', 15);", "reference_sql": "SELECT species_name, SUM(sightings) as total_sightings, RANK() OVER (ORDER BY SUM(sightings) DESC) as rank FROM species_observations GROUP BY species_name HAVING rank <= 3;", "generated_sql": "SELECT species_name, SUM(sightings) AS total_sightings\nFROM species_observations\nGROUP BY species_name\nORDER BY total_sightings DESC\nLIMIT 3;", "raw_model_output": "\n\nSELECT species_name, SUM(sightings) AS total_sightings\nFROM species_observations\nGROUP BY species_name\nORDER BY total_sightings DESC\nLIMIT 3;", "latency_sec": 8.801856994628906, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 256, "prompt_eval_sec": null, "tokens_completion": 691, "completion_eval_sec": null, "tokens_total": 947, "tokens_per_sec": 107.59093229734145, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a 'rank' column generated by the RANK() window function, while the Generated SQL does not. Additionally, the Reference SQL uses a HAVING clause with 'rank <= 3', which is invalid in most SQL dialects because window functions cannot be directly referenced in HAVING. Even if the Reference SQL were valid, the output columns differ, making the queries semantically distinct.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL contains a critical technical error: the HAVING clause references 'rank' which is an alias from the SELECT list, but HAVING cannot use column aliases. This would cause a syntax error. The Generated SQL correctly uses GROUP BY, ORDER BY, and LIMIT to achieve the goal. While both queries aim to find top species, only the Generated SQL would execute successfully and return the correct results. The Reference's use of RANK() is unnecessary for this simple top-3 requirement and introduces logical flaws.", "overall_assessment": "differently_correct"}}
{"example_id": 3091, "sql_complexity": "single join", "prompt": "Find the number of hybrid vehicles sold in the US, Germany, and Japan.", "context": "CREATE TABLE vehicle_sales (sale_id INT, vehicle_id INT, country VARCHAR(20), quantity INT); CREATE TABLE vehicles (vehicle_id INT, model VARCHAR(20), manufacture VARCHAR(20), vehicle_type VARCHAR(20));", "reference_sql": "SELECT SUM(vs.quantity) FROM vehicle_sales vs JOIN vehicles v ON vs.vehicle_id = v.vehicle_id WHERE v.vehicle_type = 'hybrid' AND vs.country IN ('US', 'Germany', 'Japan');", "generated_sql": "SELECT SUM(vs.quantity) \nFROM vehicle_sales vs \nJOIN vehicles v ON vs.vehicle_id = v.vehicle_id \nWHERE v.vehicle_type = 'hybrid' \nAND vs.country IN ('US', 'Germany', 'Japan');", "raw_model_output": "\n\nSELECT SUM(vs.quantity) \nFROM vehicle_sales vs \nJOIN vehicles v ON vs.vehicle_id = v.vehicle_id \nWHERE v.vehicle_type = 'hybrid' \nAND vs.country IN ('US', 'Germany', 'Japan');", "latency_sec": 4.154120922088623, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 135, "prompt_eval_sec": null, "tokens_completion": 447, "completion_eval_sec": null, "tokens_total": 582, "tokens_per_sec": 140.101843666934, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both perform a JOIN between vehicle_sales and vehicles on vehicle_id, filter for hybrid vehicle_type and countries in ('US', 'Germany', 'Japan'), and calculate the sum of quantity. No semantic differences exist between them.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are syntactically identical except for formatting differences (whitespace/line breaks). They correctly join the vehicle_sales and vehicles tables on vehicle_id, filter for hybrid vehicles and the specified countries, and aggregate total quantities. The business intent is fully addressed by counting hybrid vehicle sales in the three target countries. Neither query demonstrates superior efficiency or elegance over the other as they are functionally identical.", "overall_assessment": "correct"}}
{"example_id": 2399, "sql_complexity": "set operations", "prompt": "What is the average duration of criminal trials for Indigenous defendants compared to non-Indigenous defendants in Canada and New Zealand?", "context": "CREATE TABLE canada_criminal_trials (id INT, defendant_type VARCHAR(255), days_to_completion INT); INSERT INTO canada_criminal_trials (id, defendant_type, days_to_completion) VALUES (1, 'Indigenous', 60), (2, 'Non-Indigenous', 45);CREATE TABLE nz_criminal_trials (id INT, defendant_type VARCHAR(255), days_to_completion INT); INSERT INTO nz_criminal_trials (id, defendant_type, days_to_completion) VALUES (1, 'Indigenous', 70), (2, 'Non-Indigenous', 50);", "reference_sql": "SELECT AVG(days_to_completion) AS avg_duration FROM canada_criminal_trials WHERE defendant_type = 'Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM canada_criminal_trials WHERE defendant_type = 'Non-Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM nz_criminal_trials WHERE defendant_type = 'Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM nz_criminal_trials WHERE defendant_type = 'Non-Indigenous';", "generated_sql": "SELECT 'Canada' AS country, defendant_type, AVG(days_to_completion) AS average_duration\nFROM canada_criminal_trials\nGROUP BY defendant_type\nUNION ALL\nSELECT 'New Zealand' AS country, defendant_type, AVG(days_to_completion) AS average_duration\nFROM nz_criminal_trials\nGROUP BY defendant_type;", "raw_model_output": "\n\nSELECT 'Canada' AS country, defendant_type, AVG(days_to_completion) AS average_duration\nFROM canada_criminal_trials\nGROUP BY defendant_type\nUNION ALL\nSELECT 'New Zealand' AS country, defendant_type, AVG(days_to_completion) AS average_duration\nFROM nz_criminal_trials\nGROUP BY defendant_type;", "latency_sec": 5.678577184677124, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 222, "prompt_eval_sec": null, "tokens_completion": 537, "completion_eval_sec": null, "tokens_total": 759, "tokens_per_sec": 133.66024187327406, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL returns four rows with only the average duration values, while the Generated SQL includes an additional 'country' column to distinguish between Canada and New Zealand results. The output structures differ, making the results non-equivalent despite calculating the same averages.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the average trial durations for Indigenous and non-Indigenous defendants in Canada and New Zealand. The reference query uses four separate SELECT statements with UNION ALL, while the generated query uses GROUP BY to consolidate calculations. The generated query is more efficient and elegant by reducing redundancy. However, the key difference lies in the output structure: the generated query explicitly includes 'country' labels ('Canada' and 'New Zealand'), which directly addresses the business question's requirement to compare the two countries. The reference query lacks country identifiers, making it less clear which averages correspond to which country. Both fulfill the intent, but the generated query does so more effectively by providing explicit contextual information.", "overall_assessment": "differently_correct"}}
{"example_id": 2972, "sql_complexity": "set operations", "prompt": "How many indigenous communities are in the Arctic Research Station 13 and 14?", "context": "CREATE TABLE Arctic_Research_Station_13 (id INT, community TEXT); CREATE TABLE Arctic_Research_Station_14 (id INT, community TEXT);", "reference_sql": "SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_13; SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_14; SELECT COUNT(DISTINCT community) FROM (SELECT * FROM Arctic_Research_Station_13 UNION ALL SELECT * FROM Arctic_Research_Station_14) AS Arctic_Communities;", "generated_sql": "SELECT (SELECT COUNT(*) FROM Arctic_Research_Station_13) + (SELECT COUNT(*) FROM Arctic_Research_Station_14) AS total_indigenous_communities;", "raw_model_output": "\n\nSELECT (SELECT COUNT(*) FROM Arctic_Research_Station_13) + (SELECT COUNT(*) FROM Arctic_Research_Station_14) AS total_indigenous_communities;", "latency_sec": 15.950968980789185, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 122, "prompt_eval_sec": null, "tokens_completion": 1547, "completion_eval_sec": null, "tokens_total": 1669, "tokens_per_sec": 104.63314184925618, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL counts distinct communities in each table separately and then combines them, while the Generated SQL sums total rows from both tables. The first two Reference queries focus on distinct community values, whereas the Generated SQL counts all rows (not distinct). The third Reference query combines tables before counting distinct communities, which is not equivalent to summing row counts. The generated query lacks distinctness checks and combines counts differently.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference SQL correctly addresses the ambiguity in the question by providing three options: individual counts for each station and a combined distinct count. The generated SQL incorrectly sums raw counts without considering duplicates, which would overstate the true number of unique communities if there are overlaps between the two stations. The original question likely seeks the total unique communities across both stations, which the reference's third query handles properly. The generated query fails to account for potential duplicate community names across stations, making it technically and semantically inferior.", "overall_assessment": "incorrect"}}
{"example_id": 5576, "sql_complexity": "window functions", "prompt": "Who are the top 5 users with the most followers, and what is their location?", "context": "CREATE TABLE user_data (user_id INT, name VARCHAR(50), followers INT, location VARCHAR(50)); INSERT INTO user_data (user_id, name, followers, location) VALUES (1, 'Alice', 10000, 'New York'), (2, 'Bob', 15000, 'California'), (3, 'Charlie', 12000, 'Texas'), (4, 'David', 8000, 'Florida'), (5, 'Eve', 9000, 'Illinois');", "reference_sql": "SELECT name, location FROM (SELECT name, location, ROW_NUMBER() OVER (ORDER BY followers DESC) AS rank FROM user_data) AS user_ranks WHERE rank <= 5;", "generated_sql": "SELECT name, location FROM user_data ORDER BY followers DESC LIMIT 5;", "raw_model_output": "\n\nSELECT name, location FROM user_data ORDER BY followers DESC LIMIT 5;", "latency_sec": 3.3713669776916504, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 208, "prompt_eval_sec": null, "tokens_completion": 419, "completion_eval_sec": null, "tokens_total": 627, "tokens_per_sec": 185.97797396393264, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the top 5 users by followers in descending order. The Reference SQL uses ROW_NUMBER() to assign ranks and filters for rank <= 5, while the Generated SQL directly orders by followers and limits to 5 rows. Since the data has unique follower counts, both approaches yield the same result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly retrieve the top 5 users by followers and their locations. The Reference SQL uses a window function with ROW_NUMBER() and a subquery, which is functionally equivalent to the Generated SQL's ORDER BY + LIMIT approach. However, the Generated SQL is more efficient (no subquery overhead) and elegant. Both handle the business intent of identifying top followers, but the Generated version achieves it with simpler syntax and better performance.", "overall_assessment": "correct"}}
{"example_id": 1560, "sql_complexity": "basic SQL", "prompt": "What is the average media literacy score for users in the 'Young Adult' age group who have completed at least one disinformation detection course?", "context": "CREATE TABLE users (id INT, age VARCHAR(20), media_literacy_score INT, courses_completed INT);", "reference_sql": "SELECT AVG(media_literacy_score) FROM users WHERE age = 'Young Adult' AND courses_completed > 0;", "generated_sql": "SELECT AVG(media_literacy_score) FROM users WHERE age = 'Young Adult' AND courses_completed >= 1;", "raw_model_output": "\n\nSELECT AVG(media_literacy_score) FROM users WHERE age = 'Young Adult' AND courses_completed >= 1;", "latency_sec": 3.23771595954895, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 122, "prompt_eval_sec": null, "tokens_completion": 417, "completion_eval_sec": null, "tokens_total": 539, "tokens_per_sec": 166.47538163758153, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The conditions 'courses_completed > 0' and 'courses_completed >= 1' are equivalent for integer values. Since courses_completed is an INT column, any value greater than 0 (i.e., 1, 2, 3, ...) is exactly the same as values greater than or equal to 1. Thus, both queries filter the same set of rows.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent because 'courses_completed > 0' and 'courses_completed >= 1' evaluate to the same logical condition. They both correctly filter users who have completed at least one course, aligning with the business intent. The reference query uses a comparative operator while the generated query uses a direct threshold, but both achieve identical results. Neither query is more efficient or elegant than the other, as they share the same structure and filtering logic.", "overall_assessment": "correct"}}
{"example_id": 1201, "sql_complexity": "basic SQL", "prompt": "What is the maximum energy efficiency rating of hydroelectric dams in Canada?", "context": "CREATE TABLE hydro_dams (id INT, name TEXT, country TEXT, energy_efficiency_rating FLOAT); INSERT INTO hydro_dams (id, name, country, energy_efficiency_rating) VALUES (1, 'Robert-Bourassa', 'Canada', 0.94), (2, 'Churchill Falls', 'Canada', 0.92);", "reference_sql": "SELECT MAX(energy_efficiency_rating) FROM hydro_dams WHERE country = 'Canada';", "generated_sql": "SELECT MAX(energy_efficiency_rating) FROM hydro_dams WHERE country = 'Canada';", "raw_model_output": "\n\n```sql\nSELECT MAX(energy_efficiency_rating) FROM hydro_dams WHERE country = 'Canada';\n```", "latency_sec": 2.2553389072418213, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 158, "prompt_eval_sec": null, "tokens_completion": 302, "completion_eval_sec": null, "tokens_total": 460, "tokens_per_sec": 203.96047730252633, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They both select the maximum energy_efficiency_rating from the hydro_dams table where the country is 'Canada'. There are no differences in syntax, conditions, or aggregate functions.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure, syntax, and logic. They correctly filter for Canadian hydroelectric dams and calculate the maximum energy efficiency rating. The queries are semantically equivalent, fulfill the business intent of identifying the highest rating for Canadian dams, and are equally efficient and elegant. Since they are identical, neither is superior to the other.", "overall_assessment": "correct"}}
{"example_id": 4243, "sql_complexity": "single join", "prompt": "How many orders were placed by new and returning customers in each month of the year 2021?'", "context": "CREATE TABLE customer (id INT, first_order_date DATE, last_order_date DATE);", "reference_sql": "INSERT INTO customer (id, first_order_date, last_order_date) SELECT customer_id, MIN(order_date) AS first_order_date, MAX(order_date) AS last_order_date FROM orders GROUP BY customer_id; SELECT YEAR(order_date) AS year, MONTH(order_date) AS month, CASE WHEN DATEDIFF(last_order_date, first_order_date) > 30 THEN 'returning' ELSE 'new' END AS customer_type, COUNT(DISTINCT id) AS num_orders FROM orders JOIN customer ON orders.customer_id = customer.id WHERE YEAR(order_date) = 2021 GROUP BY year, month, customer_type;", "generated_sql": "SELECT \n    DATE_TRUNC('month', first_order_date) AS order_month,\n    COUNT(*) AS new_customers,\n    (SELECT COUNT(*) FROM customer WHERE first_order_date < DATE_TRUNC('month', first_order_date)) AS returning_customers\nFROM customer\nWHERE first_order_date >= '2021-01-01' AND first_order_date < '2022-01-01'\nGROUP BY order_month\nORDER BY order_month;", "raw_model_output": "\n\nThe provided schema does not include an `orders` table or any column tracking individual orders, making it impossible to directly count the number of orders placed by customers. However, if the question intends to ask about **customer counts** (new vs. returning) per month, the following SQL can be used:\n\n```sql\nSELECT \n    DATE_TRUNC('month', first_order_date) AS order_month,\n    COUNT(*) AS new_customers,\n    (SELECT COUNT(*) FROM customer WHERE first_order_date < DATE_TRUNC('month', first_order_date)) AS returning_customers\nFROM customer\nWHERE first_order_date >= '2021-01-01' AND first_order_date < '2022-01-01'\nGROUP BY order_month\nORDER BY order_month;\n```\n\n### Notes:\n1. **Assumption**: This query assumes the question refers to **customer counts** (not actual orders) due to the lack of an `orders` table.\n2. **New Customers**: Customers whose `first_order_date` falls in the given month.\n3. **Returning Customers**: Total customers with `first_order_date` before the current month (calculated via a subquery).\n4. **Limitation**: This approach does not account for multiple orders per customer or orders placed in 2021 after the first order.", "latency_sec": 16.546793937683105, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 109, "prompt_eval_sec": null, "tokens_completion": 1843, "completion_eval_sec": null, "tokens_total": 1952, "tokens_per_sec": 117.96847216152138, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL calculates order statistics (count of distinct orders) grouped by year/month/customer_type, where customer_type is determined by the difference between first/last order dates. The Generated SQL calculates customer counts (new vs returning) based on first_order_date relative to monthly truncation, using a subquery for returning customers. Key differences include: 1) Different tables (orders vs customer), 2) Different metrics (orders vs customers), 3) Different logic for determining 'new'/'returning' (order date differences vs first_order_date timing), and 4) Different grouping/aggregate fields.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL attempts to address the question by joining orders with customer data and classifying customers as 'new' or 'returning' based on their first/last order dates. However, it incorrectly counts distinct customers (not orders) and uses a flawed '30-day' threshold for returning status. The Generated SQL completely ignores the orders table, instead counting customers based on their first_order_date without relating to order dates. Neither query correctly counts orders by month, but the Reference SQL is more aligned with the data structure and intent, even though it contains critical errors.", "overall_assessment": "incorrect"}}
{"example_id": 2321, "sql_complexity": "subqueries", "prompt": "What are the names and types of vessels used in research expeditions in the regions with the lowest ocean acidification levels?", "context": "CREATE TABLE ocean_acidification (id INT PRIMARY KEY, region VARCHAR(255), year INT, acidification_level INT); INSERT INTO ocean_acidification (id, region, year, acidification_level) VALUES (1, 'Arctic Ocean', 2018, 20), (2, 'Southern Ocean', 2019, 22); CREATE TABLE expedition_vessels (id INT PRIMARY KEY, name VARCHAR(255), type VARCHAR(255), region VARCHAR(255)); INSERT INTO expedition_vessels (id, name, type, region) VALUES (1, 'Sea Researcher', 'Research Vessel', 'Arctic Ocean');", "reference_sql": "SELECT v.name, v.type FROM expedition_vessels v INNER JOIN ocean_acidification oa ON v.region = oa.region WHERE oa.acidification_level = (SELECT MIN(acidification_level) FROM ocean_acidification);", "generated_sql": "SELECT name, type\nFROM expedition_vessels\nWHERE region IN (\n    SELECT region\n    FROM ocean_acidification\n    WHERE acidification_level = (SELECT MIN(acidification_level) FROM ocean_acidification)\n);", "raw_model_output": "\n\nSELECT name, type\nFROM expedition_vessels\nWHERE region IN (\n    SELECT region\n    FROM ocean_acidification\n    WHERE acidification_level = (SELECT MIN(acidification_level) FROM ocean_acidification)\n);", "latency_sec": 5.008998155593872, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 241, "prompt_eval_sec": null, "tokens_completion": 512, "completion_eval_sec": null, "tokens_total": 753, "tokens_per_sec": 150.3294624213579, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses an INNER JOIN which may return duplicate rows if multiple ocean_acidification entries exist for the same region with the minimum acidification_level. The Generated SQL uses a WHERE IN clause, which ensures each region is considered once, leading to potentially different results when there are multiple matching ocean_acidification entries for the same region.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly identify regions with the lowest ocean acidification levels by finding the minimum acidification_level and selecting vessels from those regions. The reference query uses an INNER JOIN to link vessels and acidification data, while the generated query uses a subquery with IN. Both approaches ensure only vessels in regions with the minimum acidification level are retrieved. The JOIN version may be slightly more efficient in some databases due to join optimization, but the IN version is equally valid. Neither query handles ties (multiple regions with the same minimum) differently, as both would include all such regions. Both fulfill the business intent of identifying research vessels in low-acidification regions.", "overall_assessment": "correct"}}
{"example_id": 4349, "sql_complexity": "multiple_joins", "prompt": "Show the research grants awarded to professors in the Computer Science department.", "context": "CREATE TABLE departments (id INT, name VARCHAR(50)); INSERT INTO departments (id, name) VALUES (1, 'Computer Science'), (2, 'Mathematics'); CREATE TABLE professors (id INT, name VARCHAR(50), department_id INT); INSERT INTO professors (id, name, department_id) VALUES (1, 'John Smith', 1), (2, 'Jane Doe', 2); CREATE TABLE grants (id INT, professor_id INT, year INT, amount FLOAT); INSERT INTO grants (id, professor_id, year, amount) VALUES (1, 1, 2021, 5000.0), (2, 2, 2020, 7000.0);", "reference_sql": "SELECT professors.name, grants.amount FROM professors INNER JOIN grants ON professors.id = grants.professor_id INNER JOIN departments ON professors.department_id = departments.id WHERE departments.name = 'Computer Science';", "generated_sql": "SELECT grants.id, grants.professor_id, grants.year, grants.amount\nFROM grants\nINNER JOIN professors ON grants.professor_id = professors.id\nINNER JOIN departments ON professors.department_id = departments.id\nWHERE departments.name = 'Computer Science';", "raw_model_output": "\n\nSELECT grants.id, grants.professor_id, grants.year, grants.amount\nFROM grants\nINNER JOIN professors ON grants.professor_id = professors.id\nINNER JOIN departments ON professors.department_id = departments.id\nWHERE departments.name = 'Computer Science';", "latency_sec": 11.841575860977173, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 239, "prompt_eval_sec": null, "tokens_completion": 1141, "completion_eval_sec": null, "tokens_total": 1380, "tokens_per_sec": 116.5385431974188, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects professors.name and grants.amount, while the Generated SQL selects all columns from the grants table (id, professor_id, year, amount). The selected columns differ, resulting in different output structures.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because they select different columns (Reference focuses on professor names and grant amounts, while Generated includes grant identifiers and details). Both fulfill the business intent of identifying grants for Computer Science professors, but the Generated query provides more comprehensive grant metadata (id, year) which better aligns with the phrase 'research grants awarded' in the question. The Reference query is also correct but more limited in scope. The Generated query is more elegant in its explicit column selection and maintains the same efficient join structure.", "overall_assessment": "differently_correct"}}
{"example_id": 476, "sql_complexity": "basic SQL", "prompt": "Insert new food safety records for locations \"A123\", \"B456\", and \"C789\"", "context": "CREATE TABLE food_safety_records (id INT, location VARCHAR(255), inspection_date DATE, violation_count INT);", "reference_sql": "INSERT INTO food_safety_records (location, inspection_date, violation_count) VALUES ('A123', '2022-03-01', 0), ('B456', '2022-03-05', 2), ('C789', '2022-03-10', 1);", "generated_sql": "INSERT INTO food_safety_records (location, inspection_date, violation_count) VALUES\n('A123', '2023-01-01', 0),\n('B456', '2023-01-01', 0),\n('C789', '2023-01-01', 0);", "raw_model_output": "\n\nINSERT INTO food_safety_records (location, inspection_date, violation_count) VALUES\n('A123', '2023-01-01', 0),\n('B456', '2023-01-01', 0),\n('C789', '2023-01-01', 0);", "latency_sec": 5.746746301651001, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 121, "prompt_eval_sec": null, "tokens_completion": 803, "completion_eval_sec": null, "tokens_total": 924, "tokens_per_sec": 160.7866349928378, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The two queries insert different data. The Reference SQL inserts records with specific inspection dates (2022-03-01, 2022-03-05, 2022-03-10) and varying violation counts (0, 2, 1), while the Generated SQL inserts all records with the same inspection date (2023-01-01) and zero violations. The data content differs in both inspection dates and violation counts, so they are not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent because they insert different data. The reference SQL uses specific inspection dates and violation counts for each location, while the generated SQL uses a uniform date (2023-01-01) and zero violations for all locations. Both fulfill the business intent of inserting records for the specified locations, but the reference query provides more detailed, contextually relevant data. The generated query might be intended as a template or default insertion, but without explicit requirements for dates/violations, the reference better reflects actual data insertion. The reference is more elegant as it avoids redundant values.", "overall_assessment": "differently_correct"}}
{"example_id": 2908, "sql_complexity": "single join", "prompt": "List all co-owners and the properties they own in New York, NY.", "context": "CREATE TABLE properties (id INT, city VARCHAR(50), price INT); CREATE TABLE co_owners (property_id INT, owner_name VARCHAR(50)); INSERT INTO properties (id, city, price) VALUES (1, 'New York', 800000), (2, 'Los Angeles', 600000); INSERT INTO co_owners (property_id, owner_name) VALUES (1, 'David'), (1, 'Ella'), (2, 'Frank');", "reference_sql": "SELECT properties.city, co_owners.owner_name FROM properties INNER JOIN co_owners ON properties.id = co_owners.property_id WHERE properties.city = 'New York';", "generated_sql": "SELECT co.owner_name, p.id, p.city, p.price\nFROM co_owners co\nJOIN properties p ON co.property_id = p.id\nWHERE p.city = 'New York';", "raw_model_output": "\n\n```sql\nSELECT co.owner_name, p.id, p.city, p.price\nFROM co_owners co\nJOIN properties p ON co.property_id = p.id\nWHERE p.city = 'New York';\n```", "latency_sec": 5.122338056564331, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 192, "prompt_eval_sec": null, "tokens_completion": 564, "completion_eval_sec": null, "tokens_total": 756, "tokens_per_sec": 147.5888533032641, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects only 'city' and 'owner_name', while the Generated SQL selects 'owner_name', 'id', 'city', and 'price'. The additional columns in the Generated SQL change the result set structure, even though both queries filter for 'New York' and join the same tables.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because they return different columns. The reference query only returns 'city' and 'owner_name', while the generated query includes 'owner_name', 'property id', 'city', and 'price'. Both correctly identify co-owners in New York, NY, but the generated query provides more comprehensive property details (id, price) which better fulfills the 'properties they own' requirement. The generated query uses table aliases for elegance and explicitly includes property identifiers, making it more informative. The reference query is correct but less detailed.", "overall_assessment": "differently_correct"}}
{"example_id": 636, "sql_complexity": "set operations", "prompt": "Insert new data into the 'cosmetic_ingredients' table for a vegan eyeshadow product by brand 'Ara' with ingredients 'Mica', 'Iron Oxide', 'Titanium Dioxide' and 'Zinc Oxide'.", "context": "CREATE TABLE cosmetic_ingredients (ingredient_id INT, product_name TEXT, brand_name TEXT, ingredient_type TEXT);", "reference_sql": "INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type) VALUES (NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient'); INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type, ingredient_name) SELECT ingredient_id, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Mica' FROM cosmetic_ingredients WHERE ingredient_name = 'Mica' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Iron Oxide' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Titanium Dioxide' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Zinc Oxide';", "generated_sql": "INSERT INTO cosmetic_ingredients (product_name, brand_name, ingredient_type) VALUES ('vegan eyeshadow', 'Ara', 'Mica'), ('vegan eyeshadow', 'Ara', 'Iron Oxide'), ('vegan eyeshadow', 'Ara', 'Titanium Dioxide'), ('vegan eyeshadow', 'Ara', 'Zinc Oxide');", "raw_model_output": "\n\nINSERT INTO cosmetic_ingredients (product_name, brand_name, ingredient_type) VALUES ('vegan eyeshadow', 'Ara', 'Mica'), ('vegan eyeshadow', 'Ara', 'Iron Oxide'), ('vegan eyeshadow', 'Ara', 'Titanium Dioxide'), ('vegan eyeshadow', 'Ara', 'Zinc Oxide');", "latency_sec": 8.594795942306519, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 141, "prompt_eval_sec": null, "tokens_completion": 1302, "completion_eval_sec": null, "tokens_total": 1443, "tokens_per_sec": 167.89229316045325, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL attempts to insert rows with an invalid 'ingredient_name' column (not present in the schema) and includes a base insert with 'ingredient_type' as 'Ingredient'. The Generated SQL omits 'ingredient_id' (which is part of the schema) and directly uses ingredient names as 'ingredient_type' values. Additionally, the Reference SQL's SELECT clause references a non-existent column, making it invalid. The Generated SQL inserts four rows with lowercase product names, while the Reference SQL includes a mix of data and potential schema violations.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL contains critical errors: it references a non-existent 'ingredient_name' column in the schema and attempts to insert a generic 'Ingredient' type instead of the specific ingredient names. The Generated SQL correctly inserts each ingredient as a separate row with proper column mapping (product_name, brand_name, ingredient_type) using multiple VALUES clauses. While both queries aim to insert ingredients, the Generated SQL directly addresses the business intent with valid syntax and avoids schema inconsistencies. The Reference SQL's approach is logically flawed due to incorrect column usage and incomplete data modeling.", "overall_assessment": "correct"}}
{"example_id": 3404, "sql_complexity": "multiple_joins", "prompt": "What are the names of startups that have received funding from investors with over 3 million funds, and are involved in Genetic Research or Bioprocess Engineering?", "context": "CREATE TABLE public.investors ( id SERIAL PRIMARY KEY, name VARCHAR(100), type VARCHAR(50), funds INTEGER ); CREATE TABLE public.investments ( id SERIAL PRIMARY KEY, investor_id INTEGER, startup_id INTEGER ); CREATE TABLE public.startups ( id SERIAL PRIMARY KEY, name VARCHAR(100), industry VARCHAR(50), funding INTEGER );", "reference_sql": "SELECT startups.name FROM public.startups JOIN public.investments ON startups.id = investments.startup_id JOIN public.investors ON investments.investor_id = investors.id WHERE (startups.industry = 'Genetic Research' OR startups.industry = 'Bioprocess Engineering') AND investors.funds > 3000000;", "generated_sql": "SELECT DISTINCT s.name  \nFROM public.startups s  \nJOIN public.investments i ON s.id = i.startup_id  \nJOIN public.investors inv ON i.investor_id = inv.id  \nWHERE inv.funds > 3000000  \n  AND s.industry IN ('Genetic Research', 'Bioprocess Engineering');", "raw_model_output": "\n\nSELECT DISTINCT s.name  \nFROM public.startups s  \nJOIN public.investments i ON s.id = i.startup_id  \nJOIN public.investors inv ON i.investor_id = inv.id  \nWHERE inv.funds > 3000000  \n  AND s.industry IN ('Genetic Research', 'Bioprocess Engineering');", "latency_sec": 5.633533239364624, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 176, "prompt_eval_sec": null, "tokens_completion": 591, "completion_eval_sec": null, "tokens_total": 767, "tokens_per_sec": 136.1490147320948, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their use of DISTINCT. The generated query uses SELECT DISTINCT to eliminate duplicates, while the reference query does not. If multiple investments from the same investor to the same startup exist, the reference query could return duplicate startup names, whereas the generated query would not. This makes them semantically different in cases where duplicates are possible.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify startups in the specified industries funded by investors with >3M, but the generated query has key improvements. The reference query lacks DISTINCT which could return duplicate startup names if multiple investments exist. The generated query uses IN instead of OR for cleaner syntax and includes DISTINCT to ensure unique results. Both are logically correct but the generated version better handles edge cases and is more efficient/elegant.", "overall_assessment": "differently_correct"}}
{"example_id": 134, "sql_complexity": "subqueries", "prompt": "Who are the top 3 authors with the most citations in the Mathematics department in the past 5 years?", "context": "CREATE TABLE authors (id INT, name VARCHAR(50), department VARCHAR(50)); INSERT INTO authors (id, name, department) VALUES (1, 'Author Name', 'Mathematics'); CREATE TABLE publications (id INT, title VARCHAR(100), author VARCHAR(50), journal VARCHAR(50), year INT, cites INT); INSERT INTO publications (id, title, author, journal, year, cites) VALUES (1, 'Publication Title', 'Author Name', 'Journal Name', 2021, 10);", "reference_sql": "SELECT author, SUM(cites) as total_cites FROM publications WHERE author IN (SELECT name FROM authors WHERE department = 'Mathematics') AND year BETWEEN YEAR(CURRENT_DATE) - 5 AND YEAR(CURRENT_DATE) GROUP BY author ORDER BY total_cites DESC LIMIT 3;", "generated_sql": "SELECT a.name, SUM(p.cites) AS total_cites\nFROM authors a\nJOIN publications p ON a.name = p.author\nWHERE a.department = 'Mathematics'\n  AND p.year >= EXTRACT(YEAR FROM CURRENT_DATE) - 5\nGROUP BY a.name\nORDER BY total_cites DESC\nFETCH FIRST 3 ROWS ONLY;", "raw_model_output": "\n\nSELECT a.name, SUM(p.cites) AS total_cites\nFROM authors a\nJOIN publications p ON a.name = p.author\nWHERE a.department = 'Mathematics'\n  AND p.year >= EXTRACT(YEAR FROM CURRENT_DATE) - 5\nGROUP BY a.name\nORDER BY total_cites DESC\nFETCH FIRST 3 ROWS ONLY;", "latency_sec": 17.62775230407715, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 207, "prompt_eval_sec": null, "tokens_completion": 1927, "completion_eval_sec": null, "tokens_total": 2134, "tokens_per_sec": 121.05910970319364, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the top 3 authors (from Mathematics department) with the highest total citations from publications. They use equivalent filtering conditions: the Reference uses a subquery with IN and BETWEEN, while the Generated uses a JOIN and >=. The year range calculations (CURRENT_DATE -5) are functionally equivalent. The grouping, aggregation, and ordering logic are identical. The only difference is syntax for limiting results (LIMIT vs FETCH FIRST).", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify the top 3 Mathematics authors by citations in the past 5 years. The Reference uses a subquery with IN and BETWEEN, while the Generated uses a JOIN with EXTRACT. They produce identical results when: 1) author names match exactly between tables, 2) the current year's data is included, and 3) the database supports both LIMIT and FETCH FIRST syntax. The Generated query is more efficient due to JOIN optimization, uses modern syntax (EXTRACT instead of YEAR), and avoids potential subquery performance issues. Both handle the business intent, but the Generated version is more elegant and database-agnostic.", "overall_assessment": "correct"}}
{"example_id": 592, "sql_complexity": "set operations", "prompt": "How many public healthcare facilities and public parks are there in total, in the 'StateData' schema's 'StateHealthcare' and 'StateParks' tables?", "context": "CREATE SCHEMA StateData; CREATE TABLE StateHealthcare (Name varchar(255), Type varchar(255)); INSERT INTO StateHealthcare (Name, Type) VALUES ('FacilityA', 'Public'), ('FacilityB', 'Public'), ('FacilityC', 'Private'); CREATE TABLE StateParks (Name varchar(255), Type varchar(255)); INSERT INTO StateParks (Name, Type) VALUES ('ParkA', 'Public'), ('ParkB', 'Public'), ('ParkC', 'Private');", "reference_sql": "SELECT COUNT(*) FROM StateData.StateHealthcare WHERE Type = 'Public' UNION ALL SELECT COUNT(*) FROM StateData.StateParks WHERE Type = 'Public';", "generated_sql": "SELECT \n    (SELECT COUNT(*) FROM StateData.StateHealthcare WHERE Type = 'Public') + \n    (SELECT COUNT(*) FROM StateData.StateParks WHERE Type = 'Public') AS Total;", "raw_model_output": "\n\nSELECT \n    (SELECT COUNT(*) FROM StateData.StateHealthcare WHERE Type = 'Public') + \n    (SELECT COUNT(*) FROM StateData.StateParks WHERE Type = 'Public') AS Total;", "latency_sec": 4.07771110534668, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 217, "prompt_eval_sec": null, "tokens_completion": 484, "completion_eval_sec": null, "tokens_total": 701, "tokens_per_sec": 171.9101677116977, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query returns two separate counts (one for StateHealthcare and one for StateParks) as two rows, while the generated query returns a single row with the summed total of both counts. The output structure and results differ.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL returns two separate counts (healthcare and parks) as individual rows, while the Generated SQL calculates a single total sum. The original question explicitly asks for a 'total' count, making the Generated SQL's approach semantically aligned with the business intent. Both queries are technically correct, but the Generated SQL directly addresses the requirement for a combined total. The Reference SQL would require additional processing (e.g., summing rows) to answer the question as posed.", "overall_assessment": "correct"}}
{"example_id": 1989, "sql_complexity": "single join", "prompt": "What are the names and production dates of garments made from fabrics with a sustainability score over 70, produced after 2021-01-01?", "context": "CREATE TABLE fabrics (id INT, name VARCHAR(50), type VARCHAR(50), sustainability_score INT); INSERT INTO fabrics (id, name, type, sustainability_score) VALUES (1, 'Organic Linen', 'Natural', 80); INSERT INTO fabrics (id, name, type, sustainability_score) VALUES (2, 'Recycled Nylon', 'Synthetic', 72);", "reference_sql": "SELECT garments.name, garments.production_date FROM garments JOIN fabrics ON garments.fabric_id = fabrics.id WHERE fabrics.sustainability_score > 70 AND garments.production_date > '2021-01-01';", "generated_sql": "The question refers to \"garments\" and their \"production dates,\" but the provided database schema only includes a `fabrics` table. There is no `garments` table or related data structure defined in the schema to answer this query. \n\n**Answer:**  \nThe necessary table for garments or production dates is not present in the provided schema.", "raw_model_output": "\n\nThe question refers to \"garments\" and their \"production dates,\" but the provided database schema only includes a `fabrics` table. There is no `garments` table or related data structure defined in the schema to answer this query. \n\n**Answer:**  \nThe necessary table for garments or production dates is not present in the provided schema.", "latency_sec": 4.090881109237671, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 188, "prompt_eval_sec": null, "tokens_completion": 487, "completion_eval_sec": null, "tokens_total": 675, "tokens_per_sec": 165.0011286018002, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference SQL query references a 'garments' table, which is not present in the provided database schema. The generated SQL explanation highlights this missing table, making the queries non-equivalent as the reference query cannot execute against the given schema.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference SQL assumes the existence of a 'garments' table, which is not present in the provided schema. The generated response correctly identifies this critical missing component. While the reference query would technically fail due to invalid table references, the generated answer addresses the root issue: the schema lacks necessary data structures to answer the question. Neither query technically fulfills the intent, but the generated response accurately highlights the fundamental problem.", "overall_assessment": "incorrect"}}
{"example_id": 1388, "sql_complexity": "aggregation", "prompt": "What was the total donation amount by each organization in the last 30 days?", "context": "CREATE TABLE organization_donations (id INT, organization TEXT, donation_date DATE, donation_amount DECIMAL(10,2)); INSERT INTO organization_donations (id, organization, donation_date, donation_amount) VALUES (1, 'Organization A', '2021-03-15', 100.00), (2, 'Organization B', '2021-03-25', 200.00);", "reference_sql": "SELECT organization, SUM(donation_amount) FROM organization_donations WHERE donation_date >= DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY) GROUP BY organization;", "generated_sql": "SELECT organization, SUM(donation_amount) AS total_donation_amount\nFROM organization_donations\nWHERE donation_date >= CURRENT_DATE - INTERVAL '30 days'\nGROUP BY organization;", "raw_model_output": "\n\nSELECT organization, SUM(donation_amount) AS total_donation_amount\nFROM organization_donations\nWHERE donation_date >= CURRENT_DATE - INTERVAL '30 days'\nGROUP BY organization;", "latency_sec": 3.175654888153076, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 184, "prompt_eval_sec": null, "tokens_completion": 491, "completion_eval_sec": null, "tokens_total": 675, "tokens_per_sec": 212.55458284151655, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the total donation amount per organization for donations within the last 30 days. The date calculation syntax differs (DATE_SUB vs. CURRENT_DATE - INTERVAL), but both evaluate to the same date range. The generated query adds an alias for the sum column, which doesn't affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the total donation amount per organization for the last 30 days. The reference uses MySQL's DATE_SUB function, while the generated query uses PostgreSQL's INTERVAL syntax. Both date calculation methods are valid and equivalent in their respective dialects. The generated query adds an explicit alias (total_donation_amount) which improves readability but isn't required for functionality. The core logic (filtering, grouping, aggregation) is identical. Neither query has syntax errors or logical flaws.", "overall_assessment": "correct"}}
{"example_id": 1628, "sql_complexity": "window functions", "prompt": "What is the ranking of national security measures for Russia based on the publication date?", "context": "CREATE TABLE national_security (id INT, title VARCHAR(255), description TEXT, agency VARCHAR(255), date DATE); INSERT INTO national_security (id, title, description, agency, date) VALUES (1, 'National Cyber Strategy', 'Outlines the approach to protecting the American people and the American way of life in the digital age', 'White House', '2018-09-20'); INSERT INTO national_security (id, title, description, agency, date) VALUES (2, 'Cybersecurity and Infrastructure Security Agency Act of 2018', 'Establishes the Cybersecurity and Infrastructure Security Agency within the Department of Homeland Security', 'Congress', '2018-11-16'); INSERT INTO national_security (id, title, description, agency, date) VALUES (3, 'Russian Military Doctrine', 'Outlines the country\u2019s stance on military security', 'Russian Government', '2014-12-26');", "reference_sql": "SELECT title, description, agency, date, ROW_NUMBER() OVER (PARTITION BY agency ORDER BY date DESC) as ranking FROM national_security WHERE agency = 'Russian Government';", "generated_sql": "SELECT title, date FROM national_security WHERE agency = 'Russian Government' ORDER BY date;", "raw_model_output": "\n\nSELECT title, date FROM national_security WHERE agency = 'Russian Government' ORDER BY date;", "latency_sec": 3.8454761505126953, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 293, "prompt_eval_sec": null, "tokens_completion": 557, "completion_eval_sec": null, "tokens_total": 850, "tokens_per_sec": 221.03894725408045, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL includes additional columns (description, agency) and adds a ROW_NUMBER() ranking based on date descending, while the Generated SQL only selects title and date, orders by date (ascending by default), and omits the ranking. The column set and ordering differ, leading to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly addresses the ranking requirement by using ROW_NUMBER() to assign sequential ranks within the Russian Government agency partition, ordered by date descending. The Generated SQL only returns titles and dates in order without actual ranking values. While both are technically correct, they produce different result structures: the Reference includes a 'ranking' column while the Generated query does not. The original question explicitly asks for 'ranking', making the Reference the only query that fulfills the business intent.", "overall_assessment": "differently_correct"}}
{"example_id": 2300, "sql_complexity": "aggregation", "prompt": "What is the minimum capacity for schools in each location ('community_development')?", "context": "CREATE TABLE community_development.schools (id INT, name VARCHAR(50), capacity INT, location VARCHAR(50));", "reference_sql": "SELECT location, MIN(capacity) FROM community_development.schools GROUP BY location;", "generated_sql": "SELECT location, MIN(capacity) AS min_capacity\nFROM community_development.schools\nGROUP BY location;", "raw_model_output": "\n\nTo determine the **minimum capacity for schools in each location**, we need to group the records by the `location` column and calculate the minimum `capacity` for each group. This is a standard use case for the `GROUP BY` clause in SQL.\n\n---\n\n### \u2705 Assumptions:\n- The `location` column contains the different locations where schools are situated.\n- The goal is to find the **minimum capacity** of schools **within each distinct location**.\n\n---\n\n### \ud83e\udde0 SQL Logic:\n- Use `SELECT location, MIN(capacity)` to get the minimum capacity per location.\n- Use `FROM community_development.schools` to specify the table.\n- Use `GROUP BY location` to group the results by location.\n\n---\n\n### \u2705 Final SQL Statement:\n\n```sql\nSELECT location, MIN(capacity) AS min_capacity\nFROM community_development.schools\nGROUP BY location;\n```\n\nThis query will return a list of locations along with the smallest school capacity found in each.", "latency_sec": 8.103870153427124, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 112, "prompt_eval_sec": null, "tokens_completion": 978, "completion_eval_sec": null, "tokens_total": 1090, "tokens_per_sec": 134.5036358386171, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (location and MIN(capacity)) and apply the same GROUP BY clause. The generated query adds an explicit alias (min_capacity) for the MIN(capacity) column, but this does not affect the semantic result. The output data values remain identical between the two queries.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the minimum capacity per location using GROUP BY and MIN(). The reference query omits an explicit alias for the aggregated column, while the generated query adds 'AS min_capacity'. This makes the generated query more readable and semantically explicit without altering the result set. The business intent of identifying minimum capacities by location is fully satisfied by both, but the generated version improves clarity through column aliasing.", "overall_assessment": "correct"}}
{"example_id": 4976, "sql_complexity": "set operations", "prompt": "What is the most common hashtag used in posts made by users from Brazil?", "context": "CREATE TABLE posts (id INT, user_id INT, content TEXT, hashtags TEXT, post_date DATE); INSERT INTO posts (id, user_id, content, hashtags, post_date) VALUES (1, 1, 'Hello World', '#datascience', '2022-06-01'), (2, 1, 'I love data', '#ai', '2022-06-02'), (3, 2, 'Ol\u00e1 Mundo', '#brasil', '2022-06-03'); CREATE TABLE users (id INT, name VARCHAR(100), country VARCHAR(50)); INSERT INTO users (id, name, country) VALUES (1, 'Jo\u00e3o Silva', 'Brazil'), (2, 'Maria Souza', 'Brazil');", "reference_sql": "SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(hashtags, ' ', n.n), ' ', -1) hashtag, COUNT(*) count FROM posts JOIN users ON posts.user_id = users.id CROSS JOIN (SELECT 1 n UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5) n WHERE users.country = 'Brazil' GROUP BY hashtag ORDER BY count DESC LIMIT 1;", "generated_sql": "SELECT hashtags, COUNT(*) AS count\nFROM posts\nJOIN users ON posts.user_id = users.id\nWHERE users.country = 'Brazil'\nGROUP BY hashtags\nORDER BY count DESC\nLIMIT 1;", "raw_model_output": "\n\nSELECT hashtags, COUNT(*) AS count\nFROM posts\nJOIN users ON posts.user_id = users.id\nWHERE users.country = 'Brazil'\nGROUP BY hashtags\nORDER BY count DESC\nLIMIT 1;", "latency_sec": 7.327070951461792, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 256, "prompt_eval_sec": null, "tokens_completion": 1001, "completion_eval_sec": null, "tokens_total": 1257, "tokens_per_sec": 171.55559272279484, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL splits multi-value hashtags into individual rows using SUBSTRING_INDEX and a numbers table, while the Generated SQL treats the entire hashtags column as a single value. This causes the Reference to count individual hashtags across all posts, whereas the Generated query counts entire hashtag strings (including multiple hashtags in one field as a single group).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly handles multiple hashtags in a single post by splitting them into individual rows using the CROSS JOIN and SUBSTRING_INDEX technique. The Generated SQL fails when posts contain multiple hashtags (e.g., '#a #b') because it treats the entire string as a single hashtag. While both queries return the same result with the sample data (which only has single-tag posts), the Reference SQL is technically superior for handling real-world scenarios where posts may contain multiple hashtags. The Generated SQL does not fulfill the business intent as thoroughly because it would miscount multi-tag posts.", "overall_assessment": "differently_correct"}}
{"example_id": 4637, "sql_complexity": "single join", "prompt": "What is the total value of transactions for each customer in the last 30 days?", "context": "CREATE TABLE transactions (id INT, customer_id INT, value DECIMAL(10, 2), transaction_date DATE); INSERT INTO transactions (id, customer_id, value, transaction_date) VALUES (1, 1, 100, '2022-01-01'), (2, 1, 200, '2022-01-15'), (3, 2, 50, '2022-01-05'), (4, 2, 150, '2022-01-30'), (5, 3, 300, '2022-01-20');", "reference_sql": "SELECT c.id, SUM(t.value) FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE t.transaction_date >= CURDATE() - INTERVAL 30 DAY GROUP BY c.id;", "generated_sql": "SELECT customer_id, SUM(value) AS total_value\nFROM transactions\nWHERE transaction_date >= CURRENT_DATE - INTERVAL '30 days'\nGROUP BY customer_id;", "raw_model_output": "\n\nSELECT customer_id, SUM(value) AS total_value\nFROM transactions\nWHERE transaction_date >= CURRENT_DATE - INTERVAL '30 days'\nGROUP BY customer_id;", "latency_sec": 6.0292277336120605, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 242, "prompt_eval_sec": null, "tokens_completion": 908, "completion_eval_sec": null, "tokens_total": 1150, "tokens_per_sec": 190.73752905184168, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of transaction values for customers with transactions in the last 30 days. The Reference SQL uses an INNER JOIN with customers (which doesn't affect the result since it's filtered by transactions) and groups by customer.id, while the Generated SQL directly groups by customer_id from transactions. The date conditions (CURDATE() - INTERVAL 30 DAY vs CURRENT_DATE - INTERVAL '30 days') are functionally equivalent in most SQL dialects. Both return the same customer IDs and summed values for qualifying transactions.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries differ in technical implementation. The Reference SQL uses MySQL-specific syntax (CURDATE() - INTERVAL 30 DAY) which is valid for MySQL, while the Generated SQL uses CURRENT_DATE with PostgreSQL-style INTERVAL '30 days' syntax, which would fail in MySQL. The Reference correctly joins customers (though unnecessary for customer_id) and uses proper MySQL date functions. The Generated SQL is more efficient but has syntax issues in MySQL. Both fulfill the business intent of calculating 30-day transaction totals per customer, but the Reference is technically correct for MySQL.", "overall_assessment": "differently_correct"}}
{"example_id": 4947, "sql_complexity": "aggregation", "prompt": "What is the total revenue for drugs approved between 2017 and 2019?", "context": "CREATE TABLE drug_sales_3 (drug_name TEXT, revenue FLOAT, year INT); INSERT INTO drug_sales_3 (drug_name, revenue, year) VALUES ('DrugG', 20000000, 2019), ('DrugG', 19000000, 2018), ('DrugH', 15000000, 2017), ('DrugH', 16000000, 2018);", "reference_sql": "SELECT drug_name, SUM(revenue) FROM drug_sales_3 WHERE year BETWEEN 2017 AND 2019 GROUP BY drug_name;", "generated_sql": "SELECT SUM(revenue) FROM drug_sales_3 WHERE year BETWEEN 2017 AND 2019;", "raw_model_output": "\n\nThe provided schema does not include a column indicating the approval year of drugs. The `year` column in the `drug_sales_3` table likely represents the year of sales/revenue reporting, not drug approval. Since the database lacks explicit approval year data, the question cannot be accurately answered with the given schema. However, if the `year` column is mistakenly assumed to represent approval years, the SQL would be:\n\n```sql\nSELECT SUM(revenue) FROM drug_sales_3 WHERE year BETWEEN 2017 AND 2019;\n``` \n\n**Note:** This assumes the `year` column refers to approval years, which is not explicitly stated in the schema.", "latency_sec": 7.717925071716309, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 203, "prompt_eval_sec": null, "tokens_completion": 1124, "completion_eval_sec": null, "tokens_total": 1327, "tokens_per_sec": 171.93740385780947, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query groups results by drug_name and calculates per-drug revenue sums, while the generated query calculates a single total revenue across all drugs. The reference returns multiple rows (one per drug) with drug names, whereas the generated query returns a single row without drug names. The GROUP BY clause in the reference is critical for separating drug-specific totals, which the generated query lacks.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query groups results by drug_name, producing separate totals for each drug, while the generated query calculates a single total revenue across all drugs in the specified period. The original question asks for 'total revenue for drugs' (singular), which implies a single aggregate value rather than per-drug breakdowns. The generated query is technically correct for this interpretation, while the reference query provides more granular data than required. Both queries are logically valid, but the generated version better aligns with the ambiguous phrasing of the question by returning a single total.", "overall_assessment": "differently_correct"}}
{"example_id": 4767, "sql_complexity": "window functions", "prompt": "List the top 2 AI algorithms with the highest explainability scores, by algorithm subtype, ordered by scores in descending order for the European region.", "context": "CREATE TABLE ai_algorithms (algorithm_id INT, algorithm_name VARCHAR(50), algorithm_subtype VARCHAR(50), region VARCHAR(50), explainability_score FLOAT); INSERT INTO ai_algorithms (algorithm_id, algorithm_name, algorithm_subtype, region, explainability_score) VALUES (1, 'AlgoA', 'Tree-based', 'Europe', 0.85), (2, 'AlgoB', 'Computer Vision', 'Europe', 0.92), (3, 'AlgoC', 'Tree-based', 'Europe', 0.78), (4, 'AlgoD', 'Transformer', 'Europe', 0.90), (5, 'AlgoE', 'Tree-based', 'Europe', 0.80);", "reference_sql": "SELECT algorithm_subtype, region, * FROM (SELECT algorithm_subtype, region, algorithm_id, algorithm_name, explainability_score, RANK() OVER (PARTITION BY algorithm_subtype ORDER BY explainability_score DESC) AS rank FROM ai_algorithms WHERE region = 'Europe') ranked WHERE rank <= 2 ORDER BY algorithm_subtype, region, explainability_score DESC;", "generated_sql": "SELECT algorithm_id, algorithm_name, algorithm_subtype, region, explainability_score\nFROM (\n    SELECT *, ROW_NUMBER() OVER (PARTITION BY algorithm_subtype ORDER BY explainability_score DESC) AS rn\n    FROM ai_algorithms\n    WHERE region = 'Europe'\n) sub\nWHERE rn <= 2;", "raw_model_output": "\n\nSELECT algorithm_id, algorithm_name, algorithm_subtype, region, explainability_score\nFROM (\n    SELECT *, ROW_NUMBER() OVER (PARTITION BY algorithm_subtype ORDER BY explainability_score DESC) AS rn\n    FROM ai_algorithms\n    WHERE region = 'Europe'\n) sub\nWHERE rn <= 2;", "latency_sec": 5.450844049453735, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 260, "prompt_eval_sec": null, "tokens_completion": 855, "completion_eval_sec": null, "tokens_total": 1115, "tokens_per_sec": 204.55547615818168, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Reference SQL includes the 'rank' column in the output (via 'SELECT algorithm_subtype, region, *'), while the Generated SQL does not. Second, the Reference SQL uses RANK() while the Generated SQL uses ROW_NUMBER(). Although the data rows might appear similar for this specific dataset (due to unique explainability_scores), the result sets differ in column structure and ranking logic. RANK() and ROW_NUMBER() can produce different results when there are ties, and the presence/absence of the 'rank' column makes the outputs non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in three key aspects: 1) The Reference uses RANK() which handles ties correctly (e.g., if multiple algorithms have the same score), while Generated uses ROW_NUMBER() which would strictly pick 2 unique rows per subtype. 2) The Reference explicitly orders results by algorithm_subtype, region, and explainability_score DESC as required, while Generated lacks an ORDER BY clause entirely. 3) The Reference includes all columns (including region) in the output, while Generated only selects specific columns. Although both correctly filter European algorithms and select top 2 per subtype, the Generated query fails to meet the explicit ordering requirement from the original question.", "overall_assessment": "differently_correct"}}
{"example_id": 4495, "sql_complexity": "basic SQL", "prompt": "Which countries are the top 3 sources of sustainable textiles?", "context": "CREATE TABLE Textile_Sources (Source_ID INT, Source_Country TEXT, Sustainable BOOLEAN, Quantity INT); INSERT INTO Textile_Sources (Source_ID, Source_Country, Sustainable, Quantity) VALUES (1, 'India', true, 1000), (2, 'Bangladesh', false, 800), (3, 'China', true, 1200), (4, 'Vietnam', false, 900), (5, 'Italy', true, 1100), (6, 'USA', false, 700);", "reference_sql": "SELECT Source_Country FROM Textile_Sources WHERE Sustainable = true ORDER BY Quantity DESC LIMIT 3;", "generated_sql": "SELECT Source_Country FROM Textile_Sources WHERE Sustainable = TRUE ORDER BY Quantity DESC LIMIT 3;", "raw_model_output": "\n\nSELECT Source_Country FROM Textile_Sources WHERE Sustainable = TRUE ORDER BY Quantity DESC LIMIT 3;", "latency_sec": 3.7380270957946777, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 206, "prompt_eval_sec": null, "tokens_completion": 566, "completion_eval_sec": null, "tokens_total": 772, "tokens_per_sec": 206.52605778821365, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The only difference between the queries is the case of the boolean literal ('true' vs 'TRUE'). SQL is case-insensitive for boolean values, so both queries filter the same rows and produce identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are functionally identical. The only difference is the case of the boolean literal ('true' vs 'TRUE'), which is irrelevant in SQL as boolean values are case-insensitive. Both correctly filter sustainable sources (Sustainable = true), order by Quantity descending, and limit to 3 results. The business intent to identify top 3 sustainable textile sources is fully met by both queries. The queries are equally efficient and elegant, with no performance differences.", "overall_assessment": "correct"}}
{"example_id": 2513, "sql_complexity": "single join", "prompt": "What is the total number of concert ticket sales for artists who released their first album between 2015 and 2017?", "context": "CREATE TABLE ConcertTicketSales (id INT, year INT, artist_id INT); CREATE TABLE ArtistAlbums (id INT, artist_id INT, year INT);", "reference_sql": "SELECT COUNT(DISTINCT cts.artist_id) FROM ConcertTicketSales cts JOIN ArtistAlbums a ON cts.artist_id = a.artist_id WHERE a.year BETWEEN 2015 AND 2017;", "generated_sql": "SELECT COUNT(*) AS total_sales\nFROM ConcertTicketSales\nWHERE artist_id IN (\n    SELECT artist_id\n    FROM ArtistAlbums\n    GROUP BY artist_id\n    HAVING MIN(year) BETWEEN 2015 AND 2017\n);", "raw_model_output": "\n\nTo determine the **total number of concert ticket sales** for artists who released their **first album between 2015 and 2017**, we need to:\n\n1. Identify the **artists** whose **first album** (i.e., the earliest `year` in the `ArtistAlbums` table) falls within the range 2015\u20132017.\n2. For those artists, **count the number of ticket sales** from the `ConcertTicketSales` table.\n\n---\n\n### Key Assumptions:\n- Each row in `ConcertTicketSales` represents a **single ticket sale**.\n- Therefore, the **total number of ticket sales** is the **count of rows** in `ConcertTicketSales` for the qualifying artists.\n\n---\n\n### SQL Query:\n\n```sql\nSELECT COUNT(*) AS total_sales\nFROM ConcertTicketSales\nWHERE artist_id IN (\n    SELECT artist_id\n    FROM ArtistAlbums\n    GROUP BY artist_id\n    HAVING MIN(year) BETWEEN 2015 AND 2017\n);\n```\n\n---\n\n### Explanation:\n\n- The subquery:\n  - Groups `ArtistAlbums` by `artist_id`.\n  - Uses `MIN(year)` to find the **first album year** for each artist.\n  - Filters artists whose **first album year** is between 2015 and 2017.\n- The outer query:\n  - Counts the number of rows in `ConcertTicketSales` where the `artist_id` matches one of the qualifying artists.\n\nThis query adheres to **ANSI SQL** and uses only the columns and tables provided in the schema.", "latency_sec": 24.992713928222656, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 131, "prompt_eval_sec": null, "tokens_completion": 3078, "completion_eval_sec": null, "tokens_total": 3209, "tokens_per_sec": 128.3974205128753, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query counts distinct artist_ids from ConcertTicketSales who have at least one matching album in ArtistAlbums between 2015-2017. The generated query counts all records in ConcertTicketSales where the artist_id has their *minimum* album year between 2015-2017. This makes the generated query more restrictive - it excludes artists who have later albums in the range but also earlier albums outside the range. The HAVING clause in the subquery changes the logic from 'any album in range' to 'minimum album year in range', making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL is incorrect because it counts distinct artists who have *any* album between 2015-2017, not just those whose *first* album falls in that range. The Generated SQL correctly identifies artists whose earliest album (MIN(year)) is between 2015-2017 using a subquery with GROUP BY and HAVING. While both queries filter artists by album year, only the Generated SQL addresses the 'first album' requirement. Additionally, the Generated SQL counts ticket sales records (COUNT(*)), which aligns with the 'total number of concert ticket sales' phrasing, whereas the Reference SQL counts artists. The Generated SQL is more precise in fulfilling the business intent.", "overall_assessment": "differently_correct"}}
{"example_id": 873, "sql_complexity": "subqueries", "prompt": "Identify attorneys who have never handled cases in the 'West' region but have in the 'North' or 'South'.", "context": "CREATE TABLE attorney_regions(attorney_id INT, region VARCHAR(20)); INSERT INTO attorney_regions(attorney_id, region) VALUES (1, 'North'), (2, 'South'), (3, 'East'), (4, 'West'), (5, 'West'), (6, 'North'); CREATE TABLE handled_cases(attorney_id INT, case_id INT); INSERT INTO handled_cases(attorney_id, case_id) VALUES (1, 101), (2, 102), (3, 103), (4, 104), (5, 105), (6, 106), (1, 107), (1, 108);", "reference_sql": "SELECT h.attorney_id FROM attorney_regions h LEFT JOIN handled_cases i ON h.attorney_id = i.attorney_id WHERE h.region IN ('North', 'South') AND h.region != 'West' AND i.attorney_id IS NOT NULL AND h.attorney_id NOT IN (SELECT attorney_id FROM attorney_regions WHERE region = 'West');", "generated_sql": "SELECT h.attorney_id\nFROM handled_cases h\nJOIN attorney_regions r ON h.attorney_id = r.attorney_id\nGROUP BY h.attorney_id\nHAVING \n    SUM(CASE WHEN r.region IN ('North', 'South') THEN 1 ELSE 0 END) > 0\n    AND SUM(CASE WHEN r.region = 'West' THEN 1 ELSE 0 END) = 0;", "raw_model_output": "\n\n```sql\nSELECT h.attorney_id\nFROM handled_cases h\nJOIN attorney_regions r ON h.attorney_id = r.attorney_id\nGROUP BY h.attorney_id\nHAVING \n    SUM(CASE WHEN r.region IN ('North', 'South') THEN 1 ELSE 0 END) > 0\n    AND SUM(CASE WHEN r.region = 'West' THEN 1 ELSE 0 END) = 0;\n```", "latency_sec": 17.22480583190918, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 246, "prompt_eval_sec": null, "tokens_completion": 2091, "completion_eval_sec": null, "tokens_total": 2337, "tokens_per_sec": 135.67642055335548, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select attorneys with handled cases who are in 'North' or 'South' regions and not in 'West'. The Reference SQL filters attorney_regions directly with explicit region conditions and a subquery to exclude 'West' regions. The Generated SQL uses a JOIN with handled_cases, groups by attorney_id, and uses HAVING clauses to ensure at least one 'North/South' region and no 'West' regions. Both approaches effectively enforce the same constraints, though they differ in implementation (explicit filtering vs. aggregate checks).", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly identify attorneys who have handled cases in 'North' or 'South' regions (via their assigned regions) and never in 'West'. The Reference SQL uses a LEFT JOIN with a subquery to exclude West-region attorneys, while the Generated SQL uses GROUP BY and HAVING to enforce region constraints. Both achieve the same result with equivalent logic, though the Generated SQL's approach is more explicit about case-level region validation. The sample data confirms identical output (attorney_ids 1, 2, 6).", "overall_assessment": "correct"}}
{"example_id": 471, "sql_complexity": "set operations", "prompt": "Find the number of donations made by first-time donors in the last quarter.", "context": "CREATE TABLE Donations (DonationID INT, DonorID INT, DonationDate DATE, DonationType TEXT, DonationAmount FLOAT); INSERT INTO Donations (DonationID, DonorID, DonationDate, DonationType, DonationAmount) VALUES (1, 1, '2021-01-01', 'Individual', 100), (2, 2, '2021-02-01', 'Corporate', 5000);", "reference_sql": "SELECT COUNT(*) FROM (SELECT DonationID FROM Donations WHERE DonationType = 'Individual' AND DonationDate >= DATEADD(quarter, -1, CURRENT_DATE) EXCEPT SELECT DonationID FROM PreviousDonations) AS FirstTimeDonors;", "generated_sql": "SELECT COUNT(*) AS FirstTimeDonations\nFROM Donations d1\nWHERE d1.DonationDate BETWEEN '2021-01-01' AND '2021-03-31'\n  AND NOT EXISTS (\n    SELECT 1\n    FROM Donations d2\n    WHERE d2.DonorID = d1.DonorID\n      AND d2.DonationDate < d1.DonationDate\n  );", "raw_model_output": "\n\nTo determine the number of **donations made by first-time donors in the last quarter**, we need to:\n\n1. Identify all donations that occurred in the **last quarter**.\n2. For each such donation, verify that it is the **first time** the donor has donated (i.e., no prior donations exist for that donor).\n\n---\n\n### Assumptions\n\n- The **last quarter** is defined as the **most recent quarter prior to the current date**.\n- Since the current date is not explicitly provided, we assume the **last quarter** refers to **Q1 2021** (January 1, 2021, to March 31, 2021), based on the sample data provided.\n\n---\n\n### SQL Query\n\n```sql\nSELECT COUNT(*) AS FirstTimeDonations\nFROM Donations d1\nWHERE d1.DonationDate BETWEEN '2021-01-01' AND '2021-03-31'\n  AND NOT EXISTS (\n    SELECT 1\n    FROM Donations d2\n    WHERE d2.DonorID = d1.DonorID\n      AND d2.DonationDate < d1.DonationDate\n  );\n```\n\n---\n\n### Explanation\n\n- `d1.DonationDate BETWEEN '2021-01-01' AND '2021-03-31'`: Filters donations that occurred in the last quarter.\n- `NOT EXISTS (...)`: Ensures that the current donation is the **first** one for the donor by checking that no earlier donation exists for the same `DonorID`.\n- `COUNT(*)`: Returns the number of such donations.\n\nThis query will return the number of donations made by **first-time donors** in the specified quarter.", "latency_sec": 31.521817922592163, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 188, "prompt_eval_sec": null, "tokens_completion": 3052, "completion_eval_sec": null, "tokens_total": 3240, "tokens_per_sec": 102.78594997142734, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in logic and assumptions. The Reference SQL uses EXCEPT to exclude donations present in a 'PreviousDonations' table, while the Generated SQL checks for first-time donations by verifying no prior donations exist for the same donor. Additionally, the date ranges differ: Reference uses a dynamic quarter-based range, while Generated uses fixed dates ('2021-01-01' to '2021-03-31'). These differences in logic and date handling make them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL references a 'PreviousDonations' table that doesn't exist in the provided schema, making it technically invalid. It also uses non-standard DATEADD syntax. The Generated SQL correctly identifies first-time donors by checking for no prior donations via NOT EXISTS, which is standard SQL. While the Generated SQL uses hardcoded dates ('2021-01-01' to '2021-03-31') instead of dynamic quarter calculations, it properly addresses the business intent of identifying first-time donors in the specified period. The Reference SQL fails due to schema inconsistencies, making the Generated SQL the better solution despite its static date range.", "overall_assessment": "differently_correct"}}
{"example_id": 1301, "sql_complexity": "multiple_joins", "prompt": "What is the total quantity of corn sold by farmers in 'Summerfield'?", "context": "CREATE TABLE farmers (id INT, name VARCHAR(50), location VARCHAR(50), crops VARCHAR(50)); CREATE TABLE crops (id INT, name VARCHAR(50), yield INT); CREATE TABLE sales (id INT, farmer_id INT, crop_name VARCHAR(50), quantity INT, price DECIMAL(5,2)); INSERT INTO farmers VALUES (1, 'Jane Doe', 'Summerfield', 'Corn'); INSERT INTO crops VALUES (1, 'Corn', 100); INSERT INTO sales VALUES (1, 1, 'Corn', 50, 2.50);", "reference_sql": "SELECT SUM(quantity) FROM sales INNER JOIN farmers ON sales.farmer_id = farmers.id INNER JOIN crops ON sales.crop_name = crops.name WHERE farmers.location = 'Summerfield' AND crops.name = 'Corn';", "generated_sql": "SELECT SUM(s.quantity) \nFROM sales s \nJOIN farmers f ON s.farmer_id = f.id \nWHERE f.location = 'Summerfield' AND s.crop_name = 'Corn';", "raw_model_output": "\n\nSELECT SUM(s.quantity) \nFROM sales s \nJOIN farmers f ON s.farmer_id = f.id \nWHERE f.location = 'Summerfield' AND s.crop_name = 'Corn';", "latency_sec": 4.993039846420288, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 212, "prompt_eval_sec": null, "tokens_completion": 542, "completion_eval_sec": null, "tokens_total": 754, "tokens_per_sec": 151.01021085192681, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes an unnecessary INNER JOIN with the 'crops' table and filters on crops.name = 'Corn', while the Generated SQL skips this join and directly filters on sales.crop_name = 'Corn'. Although both queries filter for 'Corn' in the sales table, the Reference SQL's join with crops could exclude sales entries where the crop_name doesn't exist in the crops table (due to INNER JOIN), whereas the Generated SQL would include them. This difference in behavior makes them non-equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the total quantity of corn sold by farmers in 'Summerfield'. The reference query includes an unnecessary join with the 'crops' table, which doesn't affect the result in this specific case but adds computational overhead. The generated query is more efficient by directly filtering on the 'sales.crop_name' column without the extra join. While the reference query's join with 'crops' might seem more rigorous, the business question only requires verifying the crop name in sales data (which is already validated by the schema's foreign key relationship). Both produce identical results, but the generated query is technically superior due to its simplicity and efficiency.", "overall_assessment": "correct"}}
{"example_id": 4667, "sql_complexity": "aggregation", "prompt": "Find the number of unique organizations in each country in the Philanthropy Trends table?", "context": "CREATE TABLE PhilanthropyTrends (OrgID INT, Name TEXT, Country TEXT);", "reference_sql": "SELECT Country, COUNT(DISTINCT OrgID) as UniqueOrganizations FROM PhilanthropyTrends GROUP BY Country;", "generated_sql": "SELECT Country, COUNT(DISTINCT OrgID) AS UniqueOrganizations\nFROM PhilanthropyTrends\nGROUP BY Country;", "raw_model_output": "\n\nSELECT Country, COUNT(DISTINCT OrgID) AS UniqueOrganizations\nFROM PhilanthropyTrends\nGROUP BY Country;", "latency_sec": 3.60245418548584, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 105, "prompt_eval_sec": null, "tokens_completion": 342, "completion_eval_sec": null, "tokens_total": 447, "tokens_per_sec": 124.08207765721134, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select the 'Country' column, count distinct 'OrgID' values, and group results by 'Country'. The differences are purely stylistic (e.g., line breaks, capitalization of keywords) and do not affect semantic meaning.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are functionally identical, containing the same SELECT and GROUP BY clauses with COUNT(DISTINCT OrgID) to calculate unique organizations per country. The differences are purely stylistic (formatting, capitalization). They correctly address the business intent by counting distinct organizations per country. Neither query is more efficient or elegant than the other as they execute the same logic.", "overall_assessment": "correct"}}
{"example_id": 1006, "sql_complexity": "subqueries", "prompt": "What is the average word count of news articles written by investigative journalists?", "context": "CREATE TABLE reporters (id INT, name VARCHAR(50), gender VARCHAR(10), age INT, position VARCHAR(20), country VARCHAR(50)); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (1, 'Anna Smith', 'Female', 35, 'News Reporter', 'USA'); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (2, 'Mike Johnson', 'Male', 40, 'Investigative Journalist', 'Canada'); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (3, 'Sofia Rodriguez', 'Female', 32, 'Investigative Journalist', 'Mexico'); CREATE TABLE news_articles (id INT, title VARCHAR(100), content TEXT, publication_date DATE, reporter_id INT); INSERT INTO news_articles (id, title, content, publication_date, reporter_id) VALUES (1, 'News Article 1', 'Content of News Article 1', '2021-01-01', 2); INSERT INTO news_articles (id, title, content, publication_date, reporter_id) VALUES (2, 'News Article 2', 'Content of News Article 2', '2021-02-01', 3);", "reference_sql": "SELECT AVG(LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1) AS avg_word_count FROM news_articles WHERE reporter_id IN (SELECT id FROM reporters WHERE position = 'Investigative Journalist');", "generated_sql": "SELECT \n    AVG(LENGTH(content) / 5) AS average_word_count\nFROM \n    news_articles\nJOIN \n    reporters ON news_articles.reporter_id = reporters.id\nWHERE \n    reporters.position = 'Investigative Journalist';", "raw_model_output": "\n\nTo calculate the **average word count** of news articles written by **investigative journalists**, we need to:\n\n1. **Join** the `reporters` and `news_articles` tables using the `reporter_id`.\n2. **Filter** the results to include only those reporters whose `position` is `'Investigative Journalist'`.\n3. **Calculate** the average word count of the `content` field.\n\nHowever, the `content` field is stored as `TEXT`, and there is **no direct column** for word count. In standard SQL, we can approximate the word count by using the `LENGTH()` function to get the number of characters and then dividing by an estimated average word length (e.g., 5 characters per word). This is a **proxy** for word count, as there is no built-in word-count function in standard SQL.\n\n---\n\n### \u2705 Final SQL Query:\n\n```sql\nSELECT \n    AVG(LENGTH(content) / 5) AS average_word_count\nFROM \n    news_articles\nJOIN \n    reporters ON news_articles.reporter_id = reporters.id\nWHERE \n    reporters.position = 'Investigative Journalist';\n```\n\n---\n\n### \ud83d\udd0d Explanation:\n\n- `LENGTH(content)`: Returns the number of characters in the article content.\n- `LENGTH(content) / 5`: Approximates the number of words (assuming an average of 5 characters per word).\n- `AVG(...)`: Computes the average word count across all matching articles.\n\nThis query provides a **reasonable approximation** of the average word count based on the available data.", "latency_sec": 15.752088785171509, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 366, "prompt_eval_sec": null, "tokens_completion": 1533, "completion_eval_sec": null, "tokens_total": 1899, "tokens_per_sec": 120.5554403545297, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their word count calculation method. The Reference SQL accurately counts words by measuring spaces, while the Generated SQL approximates word count by dividing content length by 5 (assuming 5-character words). Additionally, the Generated SQL uses a JOIN instead of a subquery, but this doesn't affect the result's semantic equivalence. The fundamental difference in calculation logic makes them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly calculates word count by analyzing space characters (LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1), which is a standard method for estimating words. The Generated SQL uses LENGTH(content)/5, which is an inaccurate and unreliable approximation of word count. While both queries filter investigative journalists via JOIN/WHERE, the Generated SQL's word count method fundamentally misrepresents the requirement. The Reference query also avoids potential NULL values by using a subquery instead of a JOIN, making it more robust. The Generated SQL's approach would produce significantly different results due to its flawed calculation method.", "overall_assessment": "incorrect"}}
{"example_id": 3635, "sql_complexity": "set operations", "prompt": "Which brands have certifications related to cruelty-free, vegan, or organic products?", "context": "CREATE TABLE brands (brand_name VARCHAR(50), is_cruelty_free BOOLEAN, is_vegan BOOLEAN, is_organic BOOLEAN); INSERT INTO brands (brand_name, is_cruelty_free, is_vegan, is_organic) VALUES ('Lush', TRUE, TRUE, FALSE), ('The Body Shop', TRUE, FALSE, FALSE), ('Est\u00e9e Lauder', FALSE, FALSE, FALSE), ('Urban Decay', TRUE, TRUE, FALSE), ('Maybelline', FALSE, FALSE, FALSE), ('Kat Von D', TRUE, TRUE, FALSE), ('Tarte', TRUE, TRUE, TRUE);", "reference_sql": "SELECT brand_name, 'Cruelty-free' as certification FROM brands WHERE is_cruelty_free = TRUE UNION SELECT brand_name, 'Vegan' as certification FROM brands WHERE is_vegan = TRUE UNION SELECT brand_name, 'Organic' as certification FROM brands WHERE is_organic = TRUE;", "generated_sql": "SELECT brand_name FROM brands WHERE is_cruelty_free OR is_vegan OR is_organic;", "raw_model_output": "\n\nSELECT brand_name FROM brands WHERE is_cruelty_free OR is_vegan OR is_organic;", "latency_sec": 6.444612979888916, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 212, "prompt_eval_sec": null, "tokens_completion": 692, "completion_eval_sec": null, "tokens_total": 904, "tokens_per_sec": 140.27219366330078, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns each brand multiple times (once per certification type they meet) with explicit certification labels, while the Generated SQL returns each qualifying brand only once without indicating which certification they meet. For example, a brand that is both cruelty-free and vegan would appear twice in the Reference SQL result but only once in the Generated SQL result.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query returns each brand multiple times (once per certification type) with explicit certification labels, while the generated query returns each brand once if they meet any certification criteria. Both fulfill the business intent of identifying brands with at least one certification, but the generated query is more efficient and concise. The reference query provides more detailed certification type information, but the original question does not explicitly require distinguishing between certification types\u2014only identifying brands with any certification.", "overall_assessment": "differently_correct"}}
{"example_id": 4932, "sql_complexity": "basic SQL", "prompt": "Delete the workout row with the id of 2.", "context": "CREATE TABLE Workouts (id INT, user_id INT, workout_name TEXT, calories INT); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (1, 1, 'Running', 300); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (2, 1, 'Cycling', 400); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (3, 2, 'Yoga', 200);", "reference_sql": "DELETE FROM Workouts WHERE id = 2;", "generated_sql": "DELETE FROM Workouts WHERE id = 2;", "raw_model_output": "\n\nDELETE FROM Workouts WHERE id = 2;", "latency_sec": 2.01149582862854, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 192, "prompt_eval_sec": null, "tokens_completion": 220, "completion_eval_sec": null, "tokens_total": 412, "tokens_per_sec": 204.82269668980925, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They both delete the record with id = 2 from the Workouts table, resulting in the same database state change.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical: DELETE FROM Workouts WHERE id = 2;. They correctly target the specific workout row with id=2 for deletion. The syntax is valid, the logic is sound, and the query directly addresses the business requirement. Since the reference and generated queries are exactly the same, neither is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 365, "sql_complexity": "aggregation", "prompt": "Identify the total number of military personnel and their corresponding rank for each branch and country in the 'military_personnel' table, sorted by the total number of personnel in descending order.", "context": "CREATE TABLE military_personnel (id INT, branch VARCHAR(255), rank VARCHAR(255), country VARCHAR(255), personnel INT);", "reference_sql": "SELECT branch, country, SUM(personnel) as total_personnel FROM military_personnel GROUP BY branch, country ORDER BY total_personnel DESC;", "generated_sql": "SELECT branch, country, rank, SUM(personnel) AS total_personnel\nFROM military_personnel\nGROUP BY branch, country, rank\nORDER BY total_personnel DESC;", "raw_model_output": "\n\nSELECT branch, country, rank, SUM(personnel) AS total_personnel\nFROM military_personnel\nGROUP BY branch, country, rank\nORDER BY total_personnel DESC;", "latency_sec": 17.268012046813965, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 141, "prompt_eval_sec": null, "tokens_completion": 2366, "completion_eval_sec": null, "tokens_total": 2507, "tokens_per_sec": 145.18173795590755, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their GROUP BY clauses. The reference query groups by (branch, country), aggregating all ranks within each combination. The generated query groups by (branch, country, rank), resulting in separate totals for each rank. This changes the aggregation scope and adds an extra column (rank) to the output, making the results structurally and numerically different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query groups by branch and country only, aggregating all ranks within each combination, which aligns with the requirement to 'identify the total number of military personnel for each branch and country'. The generated query adds 'rank' to the GROUP BY clause, which changes the aggregation to per-rank totals within branches and countries. This violates the original intent of aggregating across all ranks. While both queries are syntactically correct, the generated query's inclusion of 'rank' in the GROUP BY clause produces results that are not semantically equivalent to the reference. The reference better fulfills the business intent of summarizing personnel by branch and country without rank segmentation.", "overall_assessment": "incorrect"}}
{"example_id": 521, "sql_complexity": "subqueries", "prompt": "How many vessels have not had an inspection in the past year?", "context": "CREATE TABLE safety_records(id INT, vessel_name VARCHAR(50), inspection_date DATE); CREATE TABLE vessels(id INT, name VARCHAR(50), country VARCHAR(50)); INSERT INTO vessels(id, name, country) VALUES (1, 'Vessel A', 'Philippines'), (2, 'Vessel B', 'Philippines'); INSERT INTO safety_records(id, vessel_name, inspection_date) VALUES (1, 'Vessel A', '2022-01-01');", "reference_sql": "SELECT COUNT(*) FROM vessels WHERE name NOT IN (SELECT vessel_name FROM safety_records WHERE inspection_date BETWEEN DATE_SUB(NOW(), INTERVAL 1 YEAR) AND NOW());", "generated_sql": "SELECT COUNT(*) AS vessels_without_recent_inspection\nFROM vessels v\nLEFT JOIN safety_records sr\n  ON v.name = sr.vessel_name\n  AND sr.inspection_date >= CURRENT_DATE - INTERVAL '1 year'\nWHERE sr.id IS NULL;", "raw_model_output": "\n\nTo determine how many vessels have **not had an inspection in the past year**, we need to:\n\n1. Identify all vessels from the `vessels` table.\n2. Check if each vessel has **no corresponding record** in the `safety_records` table where the `inspection_date` is within the last 365 days.\n3. Count the number of such vessels.\n\nThis can be efficiently achieved using a `LEFT JOIN` with a condition on the `inspection_date`, and then filtering for rows where the join did not find a matching record.\n\n---\n\n### \u2705 SQL Query\n\n```sql\nSELECT COUNT(*) AS vessels_without_recent_inspection\nFROM vessels v\nLEFT JOIN safety_records sr\n  ON v.name = sr.vessel_name\n  AND sr.inspection_date >= CURRENT_DATE - INTERVAL '1 year'\nWHERE sr.id IS NULL;\n```\n\n---\n\n### \ud83d\udd0d Explanation\n\n- **`LEFT JOIN`** ensures all vessels are included, even if they have no matching safety records.\n- The **`ON`** clause includes a condition on `inspection_date` to only consider records from the last year.\n- **`WHERE sr.id IS NULL`** filters out vessels that have at least one inspection in the last year.\n- **`COUNT(*)`** gives the number of vessels that have **no inspection in the past year**.\n\nThis query adheres to **ANSI SQL** standards and uses only the columns and tables provided in the schema.", "latency_sec": 19.327036142349243, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 186, "prompt_eval_sec": null, "tokens_completion": 2335, "completion_eval_sec": null, "tokens_total": 2521, "tokens_per_sec": 130.4390379069042, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count vessels without recent inspections (within the last year). The Reference SQL uses NOT IN with a subquery filtering by inspection_date, while the Generated SQL uses a LEFT JOIN with a date condition and checks for NULL. Both approaches exclude vessels with at least one matching inspection in the specified period. The date conditions (BETWEEN vs. >=) are functionally equivalent when considering DATE types and the context of the data provided.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in date handling. The Reference SQL uses DATE_SUB(NOW(), INTERVAL 1 YEAR) which includes time components, potentially excluding inspections exactly on the anniversary date. The Generated SQL uses CURRENT_DATE - INTERVAL '1 year' which correctly compares dates without time, ensuring accurate filtering. Both correctly identify vessels without recent inspections, but the Generated query's date logic is more precise. The LEFT JOIN approach is also more efficient and avoids potential NULL issues in NOT IN subqueries.", "overall_assessment": "differently_correct"}}
{"example_id": 5687, "sql_complexity": "multiple_joins", "prompt": "List organizations with more than 200 volunteers, and their average donation amounts, excluding donations less than $10.", "context": "CREATE TABLE organizations (org_id INT, org_name TEXT, social_impact_score INT);CREATE TABLE volunteers (vol_id INT, org_id INT, vol_country TEXT);CREATE TABLE donations (donation_id INT, donor_id INT, donation_amount INT, donation_date DATE);", "reference_sql": "SELECT o.org_name, AVG(donation_amount) AS avg_donation_amount FROM organizations o JOIN volunteers v ON o.org_id = v.org_id JOIN donations don ON o.org_id = don.org_id WHERE donation_amount >= 10 GROUP BY o.org_name HAVING COUNT(v.vol_id) > 200;", "generated_sql": "SELECT o.org_id, o.org_name, AVG(d.donation_amount) AS avg_donation\nFROM organizations o\nJOIN volunteers v ON o.org_id = v.org_id\nJOIN donations d ON v.vol_id = d.donor_id\nWHERE d.donation_amount >= 10\n  AND o.org_id IN (\n    SELECT org_id\n    FROM volunteers\n    GROUP BY org_id\n    HAVING COUNT(vol_id) > 200\n  )\nGROUP BY o.org_id, o.org_name;", "raw_model_output": "\n\n```sql\nSELECT o.org_id, o.org_name, AVG(d.donation_amount) AS avg_donation\nFROM organizations o\nJOIN volunteers v ON o.org_id = v.org_id\nJOIN donations d ON v.vol_id = d.donor_id\nWHERE d.donation_amount >= 10\n  AND o.org_id IN (\n    SELECT org_id\n    FROM volunteers\n    GROUP BY org_id\n    HAVING COUNT(vol_id) > 200\n  )\nGROUP BY o.org_id, o.org_name;\n```", "latency_sec": 18.972142934799194, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 150, "prompt_eval_sec": null, "tokens_completion": 1904, "completion_eval_sec": null, "tokens_total": 2054, "tokens_per_sec": 108.26399564134108, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their join conditions between volunteers and donations. The Reference SQL joins donations on organizations.org_id, while the Generated SQL joins donations on volunteers.vol_id = donations.donor_id. This changes the relationship between data entities, leading to different datasets being aggregated. Additionally, the Generated SQL includes org_id in the output and groups by both org_id and org_name, which may affect results if org_name is not unique.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in several key aspects. The Reference SQL uses COUNT(v.vol_id) in the HAVING clause but groups by org_name (which may not be unique), while the Generated SQL uses a subquery to filter organizations with >200 volunteers first and groups by org_id (more reliable). The Generated SQL also correctly joins volunteers and donations via donor_id (assuming vol_id = donor_id, which is plausible given context). Both exclude donations < $10, but the Generated SQL's structure is more efficient and avoids potential grouping issues. The Reference SQL might produce incorrect results if org_name is not unique, making the Generated SQL technically superior.", "overall_assessment": "differently_correct"}}
{"example_id": 1281, "sql_complexity": "subqueries", "prompt": "Find the top 3 contributors with the lowest recycling rate in the 'waste_contributors' table.", "context": "CREATE TABLE waste_contributors (contributor VARCHAR(20), recycling_rate FLOAT); INSERT INTO waste_contributors (contributor, recycling_rate) VALUES ('Manufacturing', 0.4), ('Commercial', 0.38), ('Residential', 0.35), ('Institutional', 0.32), ('Agricultural', 0.2), ('Industrial', 0.15);", "reference_sql": "SELECT contributor FROM waste_contributors WHERE recycling_rate IN (SELECT MIN(recycling_rate) FROM waste_contributors) LIMIT 3;", "generated_sql": "SELECT contributor, recycling_rate FROM waste_contributors ORDER BY recycling_rate ASC LIMIT 3;", "raw_model_output": "\n\nSELECT contributor, recycling_rate FROM waste_contributors ORDER BY recycling_rate ASC LIMIT 3;", "latency_sec": 2.6944379806518555, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 179, "prompt_eval_sec": null, "tokens_completion": 377, "completion_eval_sec": null, "tokens_total": 556, "tokens_per_sec": 206.35101048623469, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL selects contributors with the minimum recycling rate (only 'Industrial' in the data) and limits to 3 rows. The Generated SQL returns the top 3 contributors with the lowest recycling rates (Industrial, Agricultural, Institutional) and includes the recycling_rate column. The results differ in both data (1 vs 3 rows) and columns returned.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query selects contributors with the absolute minimum recycling rate (which may be a single value) and limits to 3, but this approach would only return contributors with the lowest rate (e.g., 'Industrial' in the sample data) rather than the top 3 lowest rates. The generated query correctly orders all contributors by recycling_rate in ascending order and explicitly retrieves the top 3, which aligns with the business intent of finding the three contributors with the lowest rates. While both queries are technically valid, the generated query better addresses the requirement for 'top 3' contributors.", "overall_assessment": "differently_correct"}}
{"example_id": 5669, "sql_complexity": "window functions", "prompt": "What is the total number of new and returning volunteers in each program in each month?", "context": "CREATE TABLE Volunteers (VolunteerID INT, VolunteerName TEXT, ProgramID INT, VolunteerDate DATE, IsReturning BOOLEAN); INSERT INTO Volunteers (VolunteerID, VolunteerName, ProgramID, VolunteerDate, IsReturning) VALUES (6, 'David Kim', 1, '2022-03-01', FALSE), (7, 'Emily Chen', 2, '2022-03-15', TRUE), (8, 'James Lee', 2, '2022-04-01', FALSE), (9, 'Grace Park', 3, '2022-04-15', TRUE), (10, 'Daniel Kim', 1, '2022-04-01', FALSE);", "reference_sql": "SELECT ProgramID, EXTRACT(MONTH FROM VolunteerDate) AS Month, SUM(CASE WHEN IsReturning THEN 1 ELSE 0 END) OVER (PARTITION BY ProgramID, EXTRACT(MONTH FROM VolunteerDate) ORDER BY ProgramID, EXTRACT(MONTH FROM VolunteerDate)) + COUNT(DISTINCT VolunteerID) OVER (PARTITION BY ProgramID, EXTRACT(MONTH FROM VolunteerDate) ORDER BY ProgramID, EXTRACT(MONTH FROM VolunteerDate)) AS TotalVolunteers FROM Volunteers;", "generated_sql": "SELECT \n    ProgramID,\n    EXTRACT(YEAR FROM VolunteerDate) AS Year,\n    EXTRACT(MONTH FROM VolunteerDate) AS Month,\n    SUM(CASE WHEN IsReturning THEN 1 ELSE 0 END) AS ReturningCount,\n    SUM(CASE WHEN NOT IsReturning THEN 1 ELSE 0 END) AS NewCount\nFROM Volunteers\nGROUP BY ProgramID, EXTRACT(YEAR FROM VolunteerDate), EXTRACT(MONTH FROM VolunteerDate)\nORDER BY Year, Month;", "raw_model_output": "\n\n```sql\nSELECT \n    ProgramID,\n    EXTRACT(YEAR FROM VolunteerDate) AS Year,\n    EXTRACT(MONTH FROM VolunteerDate) AS Month,\n    SUM(CASE WHEN IsReturning THEN 1 ELSE 0 END) AS ReturningCount,\n    SUM(CASE WHEN NOT IsReturning THEN 1 ELSE 0 END) AS NewCount\nFROM Volunteers\nGROUP BY ProgramID, EXTRACT(YEAR FROM VolunteerDate), EXTRACT(MONTH FROM VolunteerDate)\nORDER BY Year, Month;\n```", "latency_sec": 9.294027090072632, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 254, "prompt_eval_sec": null, "tokens_completion": 1464, "completion_eval_sec": null, "tokens_total": 1718, "tokens_per_sec": 184.8499023458919, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL returns individual rows with aggregated values (TotalVolunteers) calculated using window functions, while the Generated SQL groups data into summary rows with separate counts for returning and new volunteers. The Reference SQL includes cumulative window function results, whereas the Generated SQL provides distinct counts per group. Additionally, the column structures and aggregation logic differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL is technically incorrect because it incorrectly calculates 'TotalVolunteers' by summing returning volunteers and counting distinct volunteers, leading to double-counting. It also fails to separate new and returning counts, which is critical for the business question. The Generated SQL correctly groups by ProgramID, year, and month, and uses separate SUM(CASE WHEN) expressions to accurately count new and returning volunteers. While the Generated SQL includes 'Year' (not explicitly requested), this is necessary for accurate monthly aggregation. The Reference SQL's window functions are unnecessary and logically flawed, making the Generated SQL both technically superior and more aligned with the business intent.", "overall_assessment": "differently_correct"}}
{"example_id": 3576, "sql_complexity": "window functions", "prompt": "What is the difference in the number of eco-friendly hotels between the top 2 countries?", "context": "CREATE TABLE eco_hotel_count (country TEXT, num_hotels INT); INSERT INTO eco_hotel_count (country, num_hotels) VALUES ('France', 100), ('Italy', 120), ('Germany', 150), ('Spain', 110), ('UK', 160);", "reference_sql": "SELECT (MAX(num_hotels) OVER (PARTITION BY num_hotels <= 2) - MIN(num_hotels) OVER (PARTITION BY num_hotels <= 2)) AS hotel_difference FROM eco_hotel_count WHERE country IN ('France', 'Italy');", "generated_sql": "SELECT MAX(num_hotels) - MIN(num_hotels) AS difference FROM (SELECT num_hotels FROM eco_hotel_count ORDER BY num_hotels DESC LIMIT 2) AS top2;", "raw_model_output": "\n\nSELECT MAX(num_hotels) - MIN(num_hotels) AS difference FROM (SELECT num_hotels FROM eco_hotel_count ORDER BY num_hotels DESC LIMIT 2) AS top2;", "latency_sec": 7.421811819076538, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 157, "prompt_eval_sec": null, "tokens_completion": 879, "completion_eval_sec": null, "tokens_total": 1036, "tokens_per_sec": 139.58855671025418, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the difference between the maximum and minimum num_hotels for France and Italy (120-100=20) using window functions partitioned by a boolean condition. The Generated SQL selects the top 2 num_hotels from all countries (160 and 150) and computes their difference (10). The WHERE clause in the Reference SQL restricts data to specific countries, while the Generated SQL operates on the entire table, leading to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is incorrect because it filters for France and Italy (which are not the top 2 countries) and uses flawed window function logic (PARTITION BY num_hotels <= 2, which doesn't identify top countries). The Generated SQL correctly identifies the top 2 countries by sorting and limiting to 2 rows, then calculates their difference. While both queries technically compute a difference, only the Generated SQL addresses the actual business question of comparing the top 2 countries.", "overall_assessment": "differently_correct"}}
{"example_id": 1970, "sql_complexity": "multiple_joins", "prompt": "List all players who have played a specific VR game, 'CyberSphere', and their ages.", "context": "CREATE TABLE Players (PlayerID INT, Age INT, Gender VARCHAR(10), Country VARCHAR(50)); CREATE TABLE VRPlayers (PlayerID INT, VRGameID INT); CREATE TABLE VRGames (VRGameID INT, Title VARCHAR(50)); INSERT INTO Players (PlayerID, Age, Gender, Country) VALUES (1, 25, 'Male', 'USA'); INSERT INTO Players (PlayerID, Age, Gender, Country) VALUES (2, 28, 'Female', 'Canada'); INSERT INTO VRPlayers (PlayerID, VRGameID) VALUES (1, 1); INSERT INTO VRPlayers (PlayerID, VRGameID) VALUES (2, 1); INSERT INTO VRGames (VRGameID, Title) VALUES (1, 'CyberSphere');", "reference_sql": "SELECT Players.Age, Players.PlayerID FROM Players INNER JOIN VRPlayers ON Players.PlayerID = VRPlayers.PlayerID INNER JOIN VRGames ON VRPlayers.VRGameID = VRGames.VRGameID WHERE VRGames.Title = 'CyberSphere';", "generated_sql": "SELECT Players.PlayerID, Players.Age\nFROM Players\nJOIN VRPlayers ON Players.PlayerID = VRPlayers.PlayerID\nJOIN VRGames ON VRPlayers.VRGameID = VRGames.VRGameID\nWHERE VRGames.Title = 'CyberSphere';", "raw_model_output": "\n\nSELECT Players.PlayerID, Players.Age\nFROM Players\nJOIN VRPlayers ON Players.PlayerID = VRPlayers.PlayerID\nJOIN VRGames ON VRPlayers.VRGameID = VRGames.VRGameID\nWHERE VRGames.Title = 'CyberSphere';", "latency_sec": 9.028192043304443, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 255, "prompt_eval_sec": null, "tokens_completion": 995, "completion_eval_sec": null, "tokens_total": 1250, "tokens_per_sec": 138.45518504749072, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (PlayerID and Age) from the Players table, join with VRPlayers and VRGames on identical conditions, and apply the same WHERE clause filtering by VRGames.Title. The differences are purely syntactic (column order in SELECT, use of JOIN vs INNER JOIN) and do not affect the semantic result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent as they produce identical results by joining the same tables with identical conditions and selecting the same columns (PlayerID and Age). The only difference is the order of columns in the SELECT clause, which does not affect result correctness. Both fulfill the business intent of listing players who played 'CyberSphere' with their ages. Neither query is more efficient or elegant than the other, as they use identical join logic and filtering. The superiority is 'equal' since both are equally valid solutions.", "overall_assessment": "correct"}}
{"example_id": 2414, "sql_complexity": "window functions", "prompt": "List the policy areas with the lowest citizen satisfaction scores.", "context": "CREATE TABLE Policy (Area VARCHAR(20), Score INT); INSERT INTO Policy (Area, Score) VALUES ('Transportation', 70), ('Education', 85), ('Healthcare', 75), ('PublicSafety', 80);", "reference_sql": "SELECT Area, Score FROM (SELECT Area, Score, ROW_NUMBER() OVER (ORDER BY Score) AS RN FROM Policy) X WHERE RN IN (1, 2);", "generated_sql": "SELECT Area FROM Policy WHERE Score = (SELECT MIN(Score) FROM Policy);", "raw_model_output": "\n\nSELECT Area FROM Policy WHERE Score = (SELECT MIN(Score) FROM Policy);", "latency_sec": 4.49516487121582, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 134, "prompt_eval_sec": null, "tokens_completion": 357, "completion_eval_sec": null, "tokens_total": 491, "tokens_per_sec": 109.22847416432977, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns the top 2 rows ordered by Score (lowest first), which would be 'Transportation' (70) and 'Healthcare' (75). The Generated SQL only returns the single row with the minimum Score ('Transportation' 70). The first query returns two rows, while the second returns only one, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL returns the two lowest scores using ROW_NUMBER(), but this approach fails if multiple policies share the same minimum score (e.g., two policies with 70 would only show one in the first row). The Generated SQL correctly identifies all policies with the absolute minimum score, which aligns with the business intent of finding 'lowest citizen satisfaction scores' (plural). While the Reference SQL could be adjusted to use RANK() or DENSE_RANK() for ties, the Generated SQL is more direct, accurate, and efficient for the stated question.", "overall_assessment": "correct"}}
{"example_id": 1898, "sql_complexity": "single join", "prompt": "What are the total sales for each drug in Q2 2020?", "context": "CREATE TABLE drugs (drug_id INT, drug_name TEXT); INSERT INTO drugs (drug_id, drug_name) VALUES (1001, 'Ibuprofen'), (1002, 'Paracetamol'), (1003, 'Aspirin'); CREATE TABLE sales (sale_id INT, drug_id INT, sale_date DATE, revenue FLOAT); INSERT INTO sales (sale_id, drug_id, sale_date, revenue) VALUES (1, 1001, '2020-04-05', 1800.0), (2, 1002, '2020-04-10', 2300.0), (3, 1003, '2020-04-15', 1400.0), (4, 1001, '2020-05-20', 1900.0), (5, 1002, '2020-06-25', 2400.0);", "reference_sql": "SELECT drug_name, SUM(revenue) as total_sales FROM sales JOIN drugs ON sales.drug_id = drugs.drug_id WHERE sale_date BETWEEN '2020-04-01' AND '2020-06-30' GROUP BY drug_name;", "generated_sql": "SELECT d.drug_name, SUM(s.revenue) AS total_sales\nFROM sales s\nJOIN drugs d ON s.drug_id = d.drug_id\nWHERE s.sale_date >= '2020-04-01' AND s.sale_date <= '2020-06-30'\nGROUP BY d.drug_id, d.drug_name;", "raw_model_output": "\n\n```sql\nSELECT d.drug_name, SUM(s.revenue) AS total_sales\nFROM sales s\nJOIN drugs d ON s.drug_id = d.drug_id\nWHERE s.sale_date >= '2020-04-01' AND s.sale_date <= '2020-06-30'\nGROUP BY d.drug_id, d.drug_name;\n```", "latency_sec": 10.842714071273804, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 325, "prompt_eval_sec": null, "tokens_completion": 875, "completion_eval_sec": null, "tokens_total": 1200, "tokens_per_sec": 110.6733970952186, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate total sales per drug within the same date range. The Reference SQL groups by drug_name, while the Generated SQL groups by drug_id and drug_name. Since drug_id is a primary key (unique) and drug_name is functionally dependent on drug_id, grouping by either produces identical results. The date conditions (BETWEEN vs. >=/<=) are equivalent. Column aliases and table references differ but do not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate total sales per drug for Q2 2020. The reference query groups by drug_name, which works in this specific case due to unique drug names but is less robust in general scenarios where drug names might not be unique. The generated query groups by both drug_id and drug_name, ensuring correctness even if drug names were duplicated. The date filters are equivalent (BETWEEN vs. >=/<=). The generated query is more precise due to grouping on the primary key (drug_id) and explicitly aliases tables, improving readability and reliability.", "overall_assessment": "correct"}}
{"example_id": 2403, "sql_complexity": "multiple_joins", "prompt": "Who is the most frequent customer ordering vegetarian items?", "context": "CREATE TABLE customers (customer_id INT, customer_name VARCHAR(50)); INSERT INTO customers VALUES (1, 'John Doe'), (2, 'Jane Smith'), (3, 'Alice Johnson'); CREATE TABLE orders (order_id INT, customer_id INT, menu_id INT, order_date DATE); INSERT INTO orders VALUES (1, 1, 1, '2022-01-01'), (2, 2, 3, '2022-01-02'), (3, 3, 2, '2022-01-03'); CREATE TABLE menu (menu_id INT, item_name VARCHAR(50), is_vegetarian BOOLEAN, price DECIMAL(5,2)); INSERT INTO menu VALUES (1, 'Veggie Burger', true, 8.99), (2, 'Cheeseburger', false, 7.99), (3, 'Tofu Stir Fry', true, 11.99);", "reference_sql": "SELECT customers.customer_name, COUNT(orders.order_id) as order_count FROM customers INNER JOIN orders ON customers.customer_id = orders.customer_id INNER JOIN menu ON orders.menu_id = menu.menu_id WHERE menu.is_vegetarian = true GROUP BY customers.customer_name ORDER BY order_count DESC LIMIT 1;", "generated_sql": "SELECT c.customer_name, COUNT(*) AS vegetarian_order_count\nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nJOIN menu m ON o.menu_id = m.menu_id\nWHERE m.is_vegetarian = TRUE\nGROUP BY c.customer_id\nORDER BY vegetarian_order_count DESC\nLIMIT 1;", "raw_model_output": "\n\nTo determine the **most frequent customer ordering vegetarian items**, we need to:\n\n1. **Filter** orders where the associated menu item is vegetarian (`is_vegetarian = TRUE`).\n2. **Join** the `customers`, `orders`, and `menu` tables to get customer names and their order history.\n3. **Group** the results by `customer_id` to count how many vegetarian orders each customer has.\n4. **Sort** the results in descending order of the count and **select the top result**.\n\n---\n\n### \u2705 Final SQL Query\n\n```sql\nSELECT c.customer_name, COUNT(*) AS vegetarian_order_count\nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nJOIN menu m ON o.menu_id = m.menu_id\nWHERE m.is_vegetarian = TRUE\nGROUP BY c.customer_id\nORDER BY vegetarian_order_count DESC\nLIMIT 1;\n```\n\n---\n\n### \ud83d\udccc Explanation\n\n- `JOIN` operations ensure we only consider valid customer-order-menu relationships.\n- `WHERE m.is_vegetarian = TRUE` ensures we only count vegetarian items.\n- `GROUP BY c.customer_id` aggregates the vegetarian orders per customer.\n- `ORDER BY vegetarian_order_count DESC` sorts from most to least vegetarian orders.\n- `LIMIT 1` returns the customer with the highest count of vegetarian orders.\n\nThis query will return the **name of the most frequent customer** who orders vegetarian items.", "latency_sec": 8.622431755065918, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 292, "prompt_eval_sec": null, "tokens_completion": 1013, "completion_eval_sec": null, "tokens_total": 1305, "tokens_per_sec": 151.34941476727565, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their GROUP BY clause: the Reference query groups by customer_name (which may not be unique) while the Generated query groups by customer_id (unique). This could lead to different results if multiple customers share the same name. Additionally, the Reference uses COUNT(orders.order_id) while the Generated uses COUNT(*), which behave identically here but are not semantically equivalent in all contexts.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent due to differences in grouping columns. The Reference SQL groups by customer_name (risking incorrect aggregation if names are duplicated) while the Generated SQL groups by customer_id (the unique identifier). Both correctly filter vegetarian items and count orders, but the Generated version is more robust. Both fulfill the business intent, but the Generated query better ensures accurate results by using the primary key for grouping. The Generated query is more efficient and elegant due to proper grouping and aliasing.", "overall_assessment": "differently_correct"}}
{"example_id": 124, "sql_complexity": "set operations", "prompt": "Find the intersection of AI and accessibility research projects in the EU and those in Africa.", "context": "CREATE SCHEMA if not exists accessibility; CREATE TABLE if not exists accessibility.research (id INT PRIMARY KEY, project_name VARCHAR(255), region VARCHAR(255)); INSERT INTO accessibility.research (id, project_name, region) VALUES (1, 'AI for Accessibility EU', 'EU'), (2, 'Accessibility Africa', 'Africa'), (3, 'AI for Accessibility Africa', 'Africa'), (4, 'Accessibility EU', 'EU');", "reference_sql": "SELECT project_name FROM accessibility.research WHERE region = 'EU' INTERSECT SELECT project_name FROM accessibility.research WHERE region = 'Africa';", "generated_sql": "SELECT project_name\nFROM accessibility.research\nWHERE region = 'EU'\n  AND project_name LIKE '%AI%'\n  AND project_name LIKE '%Accessibility%'\nINTERSECT\nSELECT project_name\nFROM accessibility.research\nWHERE region = 'Africa'\n  AND project_name LIKE '%AI%'\n  AND project_name LIKE '%Accessibility%';", "raw_model_output": "\n\nTo find the **intersection of AI and accessibility research projects in the EU and those in Africa**, we interpret this as identifying projects that:\n\n- Contain both **\"AI\"** and **\"Accessibility\"** in their names (i.e., AI and accessibility research projects), and\n- Are located in **both the EU and Africa** (i.e., the intersection of regions).\n\nHowever, based on the provided data, **no project exists in both the EU and Africa**. Therefore, the result of this intersection will be **empty**.\n\n---\n\n### \u2705 SQL Query\n\n```sql\nSELECT project_name\nFROM accessibility.research\nWHERE region = 'EU'\n  AND project_name LIKE '%AI%'\n  AND project_name LIKE '%Accessibility%'\nINTERSECT\nSELECT project_name\nFROM accessibility.research\nWHERE region = 'Africa'\n  AND project_name LIKE '%AI%'\n  AND project_name LIKE '%Accessibility%';\n```\n\n---\n\n### \ud83d\udccc Explanation\n\n- The first `SELECT` retrieves AI and accessibility projects in the **EU**.\n- The second `SELECT` retrieves AI and accessibility projects in **Africa**.\n- The `INTERSECT` operator returns only the project names that appear in **both** result sets.\n- Since no project is in both regions, the query will return **no rows**.", "latency_sec": 29.742738246917725, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 182, "prompt_eval_sec": null, "tokens_completion": 2290, "completion_eval_sec": null, "tokens_total": 2472, "tokens_per_sec": 83.11272417078735, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL retrieves project_names present in both 'EU' and 'Africa' regions without any additional filters. The Generated SQL adds constraints that project_name must contain both 'AI' and 'Accessibility' in both regions. This makes the Generated SQL's result a subset of the Reference SQL's result, as it filters out projects that don't meet the keyword criteria.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL fails to incorporate the AI/accessibility criteria, returning all projects in EU and Africa without filtering for the required keywords. The Generated SQL correctly applies both region and keyword filters in each subquery, ensuring only projects explicitly related to AI and accessibility are considered. While both use INTERSECT, the Generated SQL's additional constraints align with the business intent of identifying projects that meet specific thematic criteria in each region. The Reference SQL would incorrectly include projects like 'Accessibility EU' (missing 'AI') or 'AI for Accessibility Africa' (missing 'Accessibility' in the EU subquery), whereas the Generated SQL enforces both keywords in both regions.", "overall_assessment": "differently_correct"}}
{"example_id": 1231, "sql_complexity": "basic SQL", "prompt": "What is the average ticket price for performances at the 'Downtown Theater'?", "context": "CREATE TABLE DowntownTheater (show_name TEXT, date DATE, ticket_price FLOAT); INSERT INTO DowntownTheater (show_name, date, ticket_price) VALUES ('Play 1', '2022-01-01', 30.0), ('Play 2', '2022-01-02', 40.0), ('Concert 1', '2022-01-03', 50.0);", "reference_sql": "SELECT AVG(ticket_price) FROM DowntownTheater WHERE show_name = 'Downtown Theater'", "generated_sql": "SELECT AVG(ticket_price) FROM DowntownTheater;", "raw_model_output": "\n\nSELECT AVG(ticket_price) FROM DowntownTheater;", "latency_sec": 3.129760980606079, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 188, "prompt_eval_sec": null, "tokens_completion": 398, "completion_eval_sec": null, "tokens_total": 586, "tokens_per_sec": 187.23474528285573, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters for show_name = 'Downtown Theater' which doesn't exist in the data (the actual shows are 'Play 1', 'Play 2', 'Concert 1'), resulting in NULL. The Generated SQL calculates the average of all tickets. The first returns NULL, the second returns 40.0.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query incorrectly filters for show_name = 'Downtown Theater', but the table contains show_names like 'Play 1', 'Play 2', and 'Concert 1' (not 'Downtown Theater'). This would return no rows, producing NULL. The generated query correctly averages all ticket prices in the DowntownTheater table, which contains all performances at the theater. While both queries compute AVG(ticket_price), the generated query aligns with the business intent by not applying an invalid filter. The reference query is technically incorrect due to the mismatch between table structure and filter condition.", "overall_assessment": "differently_correct"}}
{"example_id": 1485, "sql_complexity": "set operations", "prompt": "How many public schools and public libraries exist in total, in the 'CityData' schema's 'CityEducation' and 'CityLibrary' tables?", "context": "CREATE SCHEMA CityData; CREATE TABLE CityEducation (Name varchar(255), Type varchar(255)); INSERT INTO CityEducation (Name, Type) VALUES ('SchoolA', 'Public'), ('SchoolB', 'Public'), ('SchoolC', 'Private'); CREATE TABLE CityLibrary (Name varchar(255), Type varchar(255)); INSERT INTO CityLibrary (Name, Type) VALUES ('LibraryA', 'Public'), ('LibraryB', 'Public'), ('LibraryC', 'Private');", "reference_sql": "SELECT COUNT(*) FROM CityData.CityEducation WHERE Type = 'Public' UNION ALL SELECT COUNT(*) FROM CityData.CityLibrary WHERE Type = 'Public';", "generated_sql": "SELECT \n  (SELECT COUNT(*) FROM CityData.CityEducation WHERE Type = 'Public') + \n  (SELECT COUNT(*) FROM CityData.CityLibrary WHERE Type = 'Public') AS TotalPublic;", "raw_model_output": "\n\nSELECT \n  (SELECT COUNT(*) FROM CityData.CityEducation WHERE Type = 'Public') + \n  (SELECT COUNT(*) FROM CityData.CityLibrary WHERE Type = 'Public') AS TotalPublic;", "latency_sec": 6.931095838546753, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 206, "prompt_eval_sec": null, "tokens_completion": 643, "completion_eval_sec": null, "tokens_total": 849, "tokens_per_sec": 122.49145297895785, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate rows with individual counts from CityEducation and CityLibrary, while the Generated SQL returns a single row with the summed total. The result structures differ (two rows vs. one row with aggregation), so they are not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL returns two separate counts (schools and libraries) in individual rows, while the Generated SQL calculates a single total sum. The original question explicitly asks for a 'total' count, making the Generated SQL more semantically aligned with the business intent. Both queries are technically correct, but the Generated version directly addresses the requirement for a combined total. The Generated SQL is also more efficient as it avoids the overhead of UNION ALL and returns a single scalar value.", "overall_assessment": "differently_correct"}}
{"example_id": 5806, "sql_complexity": "single join", "prompt": "List the top 3 countries with the most veteran employment in the IT industry", "context": "CREATE TABLE veteran_employment (employee_id INT, industry VARCHAR(255), salary DECIMAL(10,2), state VARCHAR(2), country VARCHAR(255)); CREATE TABLE countries (country_id INT, country VARCHAR(255));", "reference_sql": "SELECT country, COUNT(*) as num_veterans FROM veteran_employment JOIN countries ON veteran_employment.country = countries.country WHERE industry = 'IT' GROUP BY country ORDER BY num_veterans DESC LIMIT 3;", "generated_sql": "SELECT country, COUNT(*) AS num_veterans\nFROM veteran_employment\nWHERE industry = 'IT'\nGROUP BY country\nORDER BY num_veterans DESC\nLIMIT 3;", "raw_model_output": "\n\nSELECT country, COUNT(*) AS num_veterans\nFROM veteran_employment\nWHERE industry = 'IT'\nGROUP BY country\nORDER BY num_veterans DESC\nLIMIT 3;", "latency_sec": 11.551810026168823, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 139, "prompt_eval_sec": null, "tokens_completion": 1300, "completion_eval_sec": null, "tokens_total": 1439, "tokens_per_sec": 124.5692230689537, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a JOIN with the countries table on veteran_employment.country = countries.country, while the Generated SQL omits this JOIN. The JOIN could potentially filter or alter the result set if there are countries in veteran_employment that do not exist in the countries table. Additionally, if the countries table has multiple entries per country, the JOIN could multiply rows, affecting the COUNT(*) result. Since the Generated SQL does not include this JOIN, the two queries are not guaranteed to produce the same result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count IT industry veteran employment per country and return the top 3. The reference query includes an unnecessary JOIN with the countries table, which doesn't affect results since the country column exists directly in veteran_employment. The generated query is more efficient by avoiding the redundant join while maintaining identical output. Both fulfill the business intent, but the generated version is technically superior due to simplicity and performance.", "overall_assessment": "correct"}}
{"example_id": 4126, "sql_complexity": "window functions", "prompt": "What is the average crime rate per capita in each neighborhood?", "context": "CREATE TABLE neighborhoods (name VARCHAR(255), population INT, crime_count INT); INSERT INTO neighborhoods (name, population, crime_count) VALUES ('Central Park', 1000, 25), ('Harlem', 2500, 75), ('Brooklyn', 5000, 120);", "reference_sql": "SELECT name, AVG(crime_count/population) OVER (PARTITION BY name) FROM neighborhoods;", "generated_sql": "SELECT name, crime_count / population AS crime_rate_per_capita FROM neighborhoods;", "raw_model_output": "\n\nSELECT name, crime_count / population AS crime_rate_per_capita FROM neighborhoods;", "latency_sec": 9.088013648986816, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 155, "prompt_eval_sec": null, "tokens_completion": 918, "completion_eval_sec": null, "tokens_total": 1073, "tokens_per_sec": 118.06760436804848, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses a window function to calculate the average of crime_count/population within each name partition. If there are multiple rows with the same name, this would return the average value for each row in the partition. The Generated SQL directly computes crime_count/population for each row. They would only be equivalent if every name was unique (which isn't guaranteed by the schema), but since the queries behave differently when names are duplicated, they are not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries calculate the crime rate per capita (crime_count/population) for each neighborhood. The Reference SQL uses an unnecessary window function (AVG with PARTITION BY name) which, for single-row partitions, returns the same value as the direct calculation. The Generated SQL is simpler, more efficient, and directly addresses the question without overcomplicating the logic. While both produce identical results, the Generated SQL better fulfills the business intent with cleaner execution.", "overall_assessment": "correct"}}
{"example_id": 4559, "sql_complexity": "basic SQL", "prompt": "List the top 3 energy efficient appliances in the US by energy star rating?", "context": "CREATE TABLE appliances (id INT, name VARCHAR(255), country VARCHAR(255), energy_star_rating INT); INSERT INTO appliances (id, name, country, energy_star_rating) VALUES (1, 'Fridge A', 'USA', 5), (2, 'TV B', 'USA', 4), (3, 'Laptop C', 'USA', 5), (4, 'Microwave D', 'USA', 3);", "reference_sql": "SELECT name, energy_star_rating FROM appliances WHERE country = 'USA' ORDER BY energy_star_rating DESC LIMIT 3;", "generated_sql": "SELECT name, energy_star_rating FROM appliances WHERE country = 'USA' ORDER BY energy_star_rating DESC LIMIT 3;", "raw_model_output": "\n\nSELECT name, energy_star_rating FROM appliances WHERE country = 'USA' ORDER BY energy_star_rating DESC LIMIT 3;", "latency_sec": 3.0110318660736084, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 182, "prompt_eval_sec": null, "tokens_completion": 326, "completion_eval_sec": null, "tokens_total": 508, "tokens_per_sec": 168.71292719410275, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure and logic. Both select the same columns, apply the same WHERE condition, use the same ORDER BY clause, and enforce the same LIMIT. The result sets will be exactly the same.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure, syntax, and logic. They correctly filter US appliances, order by energy_star_rating descending, and limit to 3 results. The business intent of identifying top energy-efficient appliances by Energy Star rating is fully addressed. Since the queries are identical, neither is superior to the other.", "overall_assessment": "correct"}}
{"example_id": 456, "sql_complexity": "window functions", "prompt": "List the intelligence operations and their corresponding threat levels, and rank them based on their threat level and budget.", "context": "CREATE TABLE intel_ops_threat (id INT, operation VARCHAR, threat VARCHAR, budget INT); INSERT INTO intel_ops_threat (id, operation, threat, budget) VALUES (1, 'Operation Red Folder', 'High', 5000000), (2, 'Operation Black Vault', 'Medium', 7000000), (3, 'Operation Blue Sail', 'Low', 6000000);", "reference_sql": "SELECT operation, threat, budget, ROW_NUMBER() OVER (PARTITION BY threat ORDER BY budget DESC) as rank FROM intel_ops_threat;", "generated_sql": "SELECT operation, threat, budget\nFROM intel_ops_threat\nORDER BY \n    CASE WHEN threat = 'High' THEN 1\n         WHEN threat = 'Medium' THEN 2\n         WHEN threat = 'Low' THEN 3\n    END,\n    budget DESC;", "raw_model_output": "\n\nSELECT operation, threat, budget\nFROM intel_ops_threat\nORDER BY \n    CASE WHEN threat = 'High' THEN 1\n         WHEN threat = 'Medium' THEN 2\n         WHEN threat = 'Low' THEN 3\n    END,\n    budget DESC;", "latency_sec": 16.174675941467285, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 186, "prompt_eval_sec": null, "tokens_completion": 1430, "completion_eval_sec": null, "tokens_total": 1616, "tokens_per_sec": 99.90926593200139, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a ROW_NUMBER() column, while the Generated SQL does not. Although both order results by threat priority and budget, the Reference SQL's output has an additional 'rank' column, making the result sets structurally different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent. The Reference SQL includes a rank column using ROW_NUMBER() partitioned by threat and ordered by budget, while the Generated SQL only sorts without a ranking column. The original question explicitly asks for 'ranked' operations, which the Generated SQL fails to provide. The Reference SQL addresses the ranking requirement but may not fully align with the 'based on threat level and budget' criteria since it ranks within threat groups rather than across all operations. The Generated SQL correctly orders by threat level and budget but lacks the required ranking output. The Reference better fulfills the intent by including a rank, even if the ranking logic could be debated.", "overall_assessment": "differently_correct"}}
{"example_id": 459, "sql_complexity": "set operations", "prompt": "What is the total installed capacity of hydroelectric power plants in Brazil and Canada?", "context": "CREATE TABLE hydroelectric_power (country TEXT, capacity INTEGER); INSERT INTO hydroelectric_power (country, capacity) VALUES ('Brazil', 104000), ('Canada', 78000), ('China', 350000), ('United States', 100000), ('Russia', 45000);", "reference_sql": "(SELECT capacity FROM hydroelectric_power WHERE country = 'Brazil') UNION (SELECT capacity FROM hydroelectric_power WHERE country = 'Canada');", "generated_sql": "SELECT SUM(capacity) FROM hydroelectric_power WHERE country IN ('Brazil', 'Canada');", "raw_model_output": "\n\nSELECT SUM(capacity) FROM hydroelectric_power WHERE country IN ('Brazil', 'Canada');", "latency_sec": 1.658097267150879, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 163, "prompt_eval_sec": null, "tokens_completion": 202, "completion_eval_sec": null, "tokens_total": 365, "tokens_per_sec": 220.13183860267876, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate capacity values (Brazil and Canada) as individual rows, while the Generated SQL returns a single summed value of both countries' capacities. The output structures and results differ.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query uses UNION to combine separate capacity values for Brazil and Canada, returning two rows instead of a single total. It fails to aggregate the values, directly contradicting the request for 'total installed capacity'. The generated query correctly uses SUM() with a WHERE clause to calculate the combined capacity, aligning with both technical requirements and business intent. While both queries are syntactically valid, only the generated query addresses the core requirement of summing capacities. The generated query is also more efficient as it performs a single aggregation rather than combining separate results.", "overall_assessment": "differently_correct"}}
{"example_id": 2356, "sql_complexity": "window functions", "prompt": "Find the total billing amount for attorneys in the 'Criminal Law' practice area, for the year 2020, partitioned by attorney's last name and ordered by the total billing amount in descending order.", "context": "CREATE TABLE Attorneys (AttorneyID INT, FirstName VARCHAR(50), LastName VARCHAR(50), PracticeArea VARCHAR(50), TotalBilling FLOAT, BillingYear INT); INSERT INTO Attorneys (AttorneyID, FirstName, LastName, PracticeArea, TotalBilling, BillingYear) VALUES (1, 'Clara', 'Rivera', 'Personal Injury', 8000.00, 2020), (2, 'Jamal', 'Lee', 'Personal Injury', 6000.00, 2019), (3, 'Sophia', 'Gomez', 'Criminal Law', 9000.00, 2020);", "reference_sql": "SELECT LastName, SUM(TotalBilling) OVER (PARTITION BY PracticeArea, LastName, BillingYear) AS TotalBilling FROM Attorneys WHERE PracticeArea = 'Criminal Law' AND BillingYear = 2020 ORDER BY TotalBilling DESC;", "generated_sql": "SELECT LastName, SUM(TotalBilling) AS TotalBillingAmount\nFROM Attorneys\nWHERE PracticeArea = 'Criminal Law' AND BillingYear = 2020\nGROUP BY LastName\nORDER BY TotalBillingAmount DESC;", "raw_model_output": "\n\nSELECT LastName, SUM(TotalBilling) AS TotalBillingAmount\nFROM Attorneys\nWHERE PracticeArea = 'Criminal Law' AND BillingYear = 2020\nGROUP BY LastName\nORDER BY TotalBillingAmount DESC;", "latency_sec": 8.678359985351562, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 264, "prompt_eval_sec": null, "tokens_completion": 1270, "completion_eval_sec": null, "tokens_total": 1534, "tokens_per_sec": 176.76150823303942, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses a window function to calculate the sum per (PracticeArea, LastName, BillingYear) without grouping, which would return multiple rows for the same LastName if there are multiple entries. The Generated SQL groups by LastName, aggregating values into a single row per LastName. While both filter to 'Criminal Law' and 2020, the Reference SQL may return duplicate LastName entries with the same sum, whereas the Generated SQL consolidates them. Thus, they are not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL uses a window function (SUM(...) OVER) which calculates running totals per partition, but the question explicitly asks for 'partitioned by attorney's last name' - a grouping operation. The Generated SQL correctly uses GROUP BY to aggregate billing amounts by LastName, which aligns with standard SQL practices for this type of requirement. While both queries filter for 'Criminal Law' and 2020, the Reference SQL's window function would produce duplicate rows for attorneys with multiple entries (not shown in sample data) and doesn't actually 'partition' in the traditional grouping sense. The Generated SQL is more efficient and directly addresses the business requirement for aggregation.", "overall_assessment": "correct"}}
