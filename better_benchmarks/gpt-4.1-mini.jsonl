{"example_id": 2656, "sql_complexity": "multiple_joins", "prompt": "Find the drugs and their respective total sales for rare diseases indication with sales greater than the average sales for infectious diseases.", "context": "CREATE TABLE sales (id INT, drug_id INT, quarter INT, year INT, revenue FLOAT); INSERT INTO sales (id, drug_id, quarter, year, revenue) VALUES (1, 1, 1, 2022, 1500000); CREATE TABLE drugs (id INT, name VARCHAR(50), company VARCHAR(50), indication VARCHAR(50)); INSERT INTO drugs (id, name, company, indication) VALUES (1, 'DrugA', 'ABC Corp', 'Rare_Diseases');", "reference_sql": "SELECT s.drug_id, d.name, SUM(s.revenue) as total_sales FROM sales s JOIN drugs d ON s.drug_id = d.id WHERE d.indication = 'Rare_Diseases' GROUP BY s.drug_id HAVING total_sales > (SELECT AVG(s2.revenue) FROM sales s2 JOIN drugs d2 ON s2.drug_id = d2.id WHERE d2.indication = 'Infectious_Diseases')", "generated_sql": "WITH total_sales AS (\n    SELECT d.id, d.name, d.indication, SUM(s.revenue) AS total_revenue\n    FROM drugs d\n    JOIN sales s ON d.id = s.drug_id\n    GROUP BY d.id, d.name, d.indication\n),\navg_infectious_sales AS (\n    SELECT AVG(total_revenue) AS avg_revenue\n    FROM (\n        SELECT d.id, SUM(s.revenue) AS total_revenue\n        FROM drugs d\n        JOIN sales s ON d.id = s.drug_id\n        WHERE d.indication = 'Infectious_Diseases'\n        GROUP BY d.id\n    ) sub\n)\nSELECT ts.name, ts.total_revenue\nFROM total_sales ts, avg_infectious_sales ais\nWHERE ts.indication = 'Rare_Diseases'\n  AND ts.total_revenue > ais.avg_revenue;", "raw_model_output": "```sql\nWITH total_sales AS (\n    SELECT d.id, d.name, d.indication, SUM(s.revenue) AS total_revenue\n    FROM drugs d\n    JOIN sales s ON d.id = s.drug_id\n    GROUP BY d.id, d.name, d.indication\n),\navg_infectious_sales AS (\n    SELECT AVG(total_revenue) AS avg_revenue\n    FROM (\n        SELECT d.id, SUM(s.revenue) AS total_revenue\n        FROM drugs d\n        JOIN sales s ON d.id = s.drug_id\n        WHERE d.indication = 'Infectious_Diseases'\n        GROUP BY d.id\n    ) sub\n)\nSELECT ts.name, ts.total_revenue\nFROM total_sales ts, avg_infectious_sales ais\nWHERE ts.indication = 'Rare_Diseases'\n  AND ts.total_revenue > ais.avg_revenue;\n```", "latency_sec": 2.2436840534210205, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 196, "prompt_eval_sec": null, "tokens_completion": 188, "completion_eval_sec": null, "tokens_total": 384, "tokens_per_sec": 171.14709150537584, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in how they calculate the average revenue threshold. The Reference SQL computes the average of individual sales revenues for 'Infectious_Diseases' drugs, while the Generated SQL calculates the average of total sales per drug for 'Infectious_Diseases'. This leads to different threshold values, making the HAVING/WHERE conditions semantically distinct.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in how they calculate the average sales for infectious diseases. The Reference SQL computes the average of individual sales (revenue) values for infectious diseases, while the Generated SQL calculates the average of total sales per drug for infectious diseases. The original question implies comparing each rare disease drug's total sales to the average of all infectious disease drugs' total sales (not individual sales), making the Generated SQL's approach technically correct. The Reference SQL's subquery incorrectly averages raw revenue values without grouping by drug, leading to a different metric. Both queries correctly filter rare disease drugs and use JOINs, but the Generated SQL's structure better aligns with the business intent of comparing aggregated drug-level sales.", "overall_assessment": "differently_correct"}}
{"example_id": 3008, "sql_complexity": "multiple_joins", "prompt": "Who are the users who used electric vehicles and their trip details?", "context": "CREATE TABLE users (id INT, name VARCHAR(50), age INT, gender VARCHAR(10), city VARCHAR(50));CREATE TABLE vehicles (id INT, vehicle_type VARCHAR(20), is_electric BOOLEAN);CREATE TABLE trips (id INT, user_id INT, vehicle_id INT, trip_distance FLOAT, trip_duration INT, departure_time TIMESTAMP, arrival_time TIMESTAMP);INSERT INTO users (id, name, age, gender, city) VALUES (3, 'Alex', 30, 'Female', 'New York');INSERT INTO vehicles (id, vehicle_type, is_electric) VALUES (1, 'Tesla', true), (2, 'Bike', false);INSERT INTO trips (id, user_id, vehicle_id, trip_distance, trip_duration, departure_time, arrival_time) VALUES (3, 3, 1, 15.3, 25, '2022-01-03 12:00:00', '2022-01-03 12:25:00');", "reference_sql": "SELECT u.name, v.vehicle_type, t.trip_distance, t.trip_duration FROM users u JOIN trips t ON u.id = t.user_id JOIN vehicles v ON t.vehicle_id = v.id WHERE v.is_electric = true;", "generated_sql": "SELECT \n    u.id AS user_id,\n    u.name,\n    u.age,\n    u.gender,\n    u.city,\n    t.id AS trip_id,\n    t.vehicle_id,\n    t.trip_distance,\n    t.trip_duration,\n    t.departure_time,\n    t.arrival_time\nFROM \n    users u\nJOIN \n    trips t ON u.id = t.user_id\nJOIN \n    vehicles v ON t.vehicle_id = v.id\nWHERE \n    v.is_electric = TRUE;", "raw_model_output": "```sql\nSELECT \n    u.id AS user_id,\n    u.name,\n    u.age,\n    u.gender,\n    u.city,\n    t.id AS trip_id,\n    t.vehicle_id,\n    t.trip_distance,\n    t.trip_duration,\n    t.departure_time,\n    t.arrival_time\nFROM \n    users u\nJOIN \n    trips t ON u.id = t.user_id\nJOIN \n    vehicles v ON t.vehicle_id = v.id\nWHERE \n    v.is_electric = TRUE;\n```", "latency_sec": 1.3356568813323975, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 287, "prompt_eval_sec": null, "tokens_completion": 106, "completion_eval_sec": null, "tokens_total": 393, "tokens_per_sec": 294.23724422993956, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects only 4 specific columns (name, vehicle_type, trip_distance, trip_duration), while the Generated SQL selects all columns from users, trips, and vehicles (11 columns total). Although both filter electric vehicles and join the same tables, the result sets differ in column composition.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because they select different columns. The Reference SQL focuses on minimal user identification (name) and core trip details (vehicle type, distance, duration), while the Generated SQL includes comprehensive user attributes (id, age, gender, city) and trip metadata (vehicle_id, timestamps). Both fulfill the business intent of identifying users who used electric vehicles and their trip details, but the Generated SQL provides more detailed information that could be valuable for analysis. The Reference is more efficient, but the Generated SQL's broader dataset better addresses potential follow-up questions about user demographics and trip specifics.", "overall_assessment": "correct"}}
{"example_id": 2531, "sql_complexity": "basic SQL", "prompt": "Who is the top customer by sales in 2022?", "context": "CREATE TABLE customers (customer_id INT, total_sales_2022 FLOAT); INSERT INTO customers (customer_id, total_sales_2022) VALUES (1, 25000.0), (2, 30000.0), (3, 22000.0), (4, 35000.0);", "reference_sql": "SELECT customer_id, total_sales_2022 FROM customers ORDER BY total_sales_2022 DESC LIMIT 1;", "generated_sql": "SELECT customer_id\nFROM customers\nORDER BY total_sales_2022 DESC\nLIMIT 1;", "raw_model_output": "```sql\nSELECT customer_id\nFROM customers\nORDER BY total_sales_2022 DESC\nLIMIT 1;\n```", "latency_sec": 0.7745201587677002, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 144, "prompt_eval_sec": null, "tokens_completion": 25, "completion_eval_sec": null, "tokens_total": 169, "tokens_per_sec": 218.19961441531404, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query selects both 'customer_id' and 'total_sales_2022' columns, while the generated query only selects 'customer_id'. The additional column in the reference query makes the result sets structurally different, even though both would return the same customer_id value for the top sales record.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because the reference query returns both customer_id and total_sales_2022 while the generated query only returns customer_id. Both correctly identify the top customer by sales (customer_id 4), but the generated query is more efficient by selecting only the necessary column. The original question asks for 'who' the top customer is, which requires only the customer_id. The reference query includes redundant data, making the generated query more elegant and efficient while fully fulfilling the business intent.", "overall_assessment": "differently_correct"}}
{"example_id": 3792, "sql_complexity": "single join", "prompt": "What is the maximum distance traveled by an electric vehicle in a single trip, grouped by vehicle model?", "context": "CREATE TABLE Trips (trip_id INT, vehicle_id INT, distance FLOAT); CREATE TABLE ElectricVehicleModels (vehicle_id INT, vehicle_model TEXT);", "reference_sql": "SELECT evm.vehicle_model, MAX(trips.distance) AS max_distance_traveled FROM Trips trips INNER JOIN ElectricVehicleModels evm ON trips.vehicle_id = evm.vehicle_id GROUP BY 1;", "generated_sql": "SELECT evm.vehicle_model, MAX(t.distance) AS max_distance\nFROM Trips t\nJOIN ElectricVehicleModels evm ON t.vehicle_id = evm.vehicle_id\nGROUP BY evm.vehicle_model;", "raw_model_output": "```sql\nSELECT evm.vehicle_model, MAX(t.distance) AS max_distance\nFROM Trips t\nJOIN ElectricVehicleModels evm ON t.vehicle_id = evm.vehicle_id\nGROUP BY evm.vehicle_model;\n```", "latency_sec": 0.6779341697692871, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 116, "prompt_eval_sec": null, "tokens_completion": 46, "completion_eval_sec": null, "tokens_total": 162, "tokens_per_sec": 238.96125497720737, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the maximum distance traveled per vehicle model by joining the Trips and ElectricVehicleModels tables. The reference query uses GROUP BY 1 (first column) while the generated query explicitly groups by evm.vehicle_model. Since the first column in both queries is vehicle_model, the grouping logic is equivalent. Table aliases (trips vs t) and column alias names (max_distance_traveled vs max_distance) do not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the maximum distance per vehicle model by joining the Trips and ElectricVehicleModels tables. The Reference uses implicit column positioning (GROUP BY 1) while the Generated explicitly names the column in GROUP BY. Both achieve identical results, maintain semantic equivalence, and fulfill the business intent. The Generated query is slightly more explicit in grouping, but neither query has efficiency advantages over the other. The difference in column alias names (max_distance_traveled vs max_distance) does not affect result accuracy.", "overall_assessment": "correct"}}
{"example_id": 2311, "sql_complexity": "subqueries", "prompt": "Determine the percentage of sales from each ingredient category", "context": "CREATE TABLE Sales_Details (sale_id INT, ingredient_id INT, quantity INT); INSERT INTO Sales_Details (sale_id, ingredient_id, quantity) VALUES (1, 1, 2), (1, 2, 8), (2, 1, 3), (2, 2, 7); CREATE TABLE Ingredient_Categories (ingredient_id INT, ingredient_category VARCHAR(255)); INSERT INTO Ingredient_Categories (ingredient_id, ingredient_category) VALUES (1, 'Legumes'), (2, 'Poultry');", "reference_sql": "SELECT ingredient_category, SUM(quantity) AS total_quantity, SUM(quantity) * 100.0 / (SELECT SUM(quantity) FROM Sales_Details) AS percentage_of_sales FROM Sales_Details, Ingredient_Categories WHERE Sales_Details.ingredient_id = Ingredient_Categories.ingredient_id GROUP BY ingredient_category;", "generated_sql": "SELECT SUM(quantity) AS total_quantity\n    FROM Sales_Details\n),\nCategorySales AS (\n    SELECT ic.ingredient_category, SUM(sd.quantity) AS category_quantity\n    FROM Sales_Details sd\n    JOIN Ingredient_Categories ic ON sd.ingredient_id = ic.ingredient_id\n    GROUP BY ic.ingredient_category\n)\nSELECT \n    ingredient_category,\n    (category_quantity * 100.0 / total_quantity) AS percentage_of_sales\nFROM CategorySales, TotalSales;", "raw_model_output": "WITH TotalSales AS (\n    SELECT SUM(quantity) AS total_quantity\n    FROM Sales_Details\n),\nCategorySales AS (\n    SELECT ic.ingredient_category, SUM(sd.quantity) AS category_quantity\n    FROM Sales_Details sd\n    JOIN Ingredient_Categories ic ON sd.ingredient_id = ic.ingredient_id\n    GROUP BY ic.ingredient_category\n)\nSELECT \n    ingredient_category,\n    (category_quantity * 100.0 / total_quantity) AS percentage_of_sales\nFROM CategorySales, TotalSales;", "latency_sec": 1.022939920425415, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 189, "prompt_eval_sec": null, "tokens_completion": 105, "completion_eval_sec": null, "tokens_total": 294, "tokens_per_sec": 287.4069083917781, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the total quantity sold per ingredient category and the percentage of total sales. The Reference SQL uses a subquery for the total and implicit join, while the Generated SQL uses CTEs and a cross join. The final calculations (SUM(quantity) and percentage) are mathematically equivalent, and the grouping/relationships between tables are preserved.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query is technically correct and produces the desired result. It uses an explicit JOIN, groups by ingredient_category, and calculates percentages correctly using a scalar subquery. The generated query has syntax errors: it lacks the WITH keyword for CTEs, and the final SELECT uses an implicit cross join between CategorySales and TotalSales (which would produce incorrect results due to Cartesian product). While both aim to calculate percentages, the generated query's syntax errors prevent it from fulfilling the business intent. The reference query is more efficient and elegant.", "overall_assessment": "incorrect"}}
{"example_id": 3329, "sql_complexity": "set operations", "prompt": "Which causes received funding from donors in both the United States and Canada?", "context": "CREATE TABLE donor_location (donor_id INT, country VARCHAR(50), cause VARCHAR(50), donation DECIMAL(10,2)); INSERT INTO donor_location (donor_id, country, cause, donation) VALUES (1, 'United States', 'Global Health', 1000.00), (2, 'Canada', 'Education', 2000.00), (3, 'United States', 'Environment', 1500.00), (4, 'Canada', 'Animal Welfare', 2500.00);", "reference_sql": "SELECT cause FROM donor_location WHERE country = 'United States' INTERSECT SELECT cause FROM donor_location WHERE country = 'Canada';", "generated_sql": "SELECT cause\nFROM donor_location\nWHERE country IN ('United States', 'Canada')\nGROUP BY cause\nHAVING COUNT(DISTINCT country) = 2;", "raw_model_output": "SELECT cause\nFROM donor_location\nWHERE country IN ('United States', 'Canada')\nGROUP BY cause\nHAVING COUNT(DISTINCT country) = 2;", "latency_sec": 0.9119949340820312, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 189, "prompt_eval_sec": null, "tokens_completion": 34, "completion_eval_sec": null, "tokens_total": 223, "tokens_per_sec": 244.5189020972586, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve causes that exist in both 'United States' and 'Canada'. The reference query uses INTERSECT to find common causes between the two countries, while the generated query groups by cause and ensures each cause appears in both countries via COUNT(DISTINCT country) = 2. Both approaches yield the same result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify causes with donations from both the United States and Canada. The Reference SQL uses INTERSECT to find common causes between two country-specific subqueries, while the Generated SQL uses a GROUP BY/HAVING clause to count distinct countries per cause. They produce identical results in all scenarios. However, the Generated SQL is more efficient as it avoids the INTERSECT operation, which can be computationally expensive. It also uses a single table scan and is more concise, making it more elegant. Both fulfill the business intent, but the Generated SQL is technically superior.", "overall_assessment": "correct"}}
{"example_id": 2912, "sql_complexity": "single join", "prompt": "Which company has manufactured the most satellites?", "context": "CREATE TABLE manufacturers (id INT, name TEXT); CREATE TABLE satellites (id INT, manufacturer_id INT, name TEXT, launch_date DATE); INSERT INTO manufacturers (id, name) VALUES (1, 'SpaceX'), (2, 'Blue Origin'), (3, 'ISRO'), (4, 'CAST'); INSERT INTO satellites (id, manufacturer_id, name, launch_date) VALUES (1, 1, 'StarDragon', '2012-05-25'), (2, 1, 'Falcon', '2015-12-21'), (3, 2, 'New Glenn', '2022-01-11'), (4, 3, 'ChinaSat 1E', '2000-12-05'), (5, 3, 'ChinaSat 2A', '2003-08-13'), (6, 4, 'Shijian 9', '2017-11-19'), (7, 1, 'StarLink', '2020-05-24'), (8, 1, 'StarLink', '2020-06-13');", "reference_sql": "SELECT m.name, COUNT(s.id) FROM manufacturers m JOIN satellites s ON m.id = s.manufacturer_id GROUP BY m.name ORDER BY COUNT(s.id) DESC;", "generated_sql": "SELECT m.name\nFROM manufacturers m\nJOIN satellites s ON m.id = s.manufacturer_id\nGROUP BY m.id, m.name\nORDER BY COUNT(s.id) DESC\nLIMIT 1;", "raw_model_output": "SELECT m.name\nFROM manufacturers m\nJOIN satellites s ON m.id = s.manufacturer_id\nGROUP BY m.id, m.name\nORDER BY COUNT(s.id) DESC\nLIMIT 1;", "latency_sec": 0.8197581768035889, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 307, "prompt_eval_sec": null, "tokens_completion": 41, "completion_eval_sec": null, "tokens_total": 348, "tokens_per_sec": 424.515436194764, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns all manufacturers with their satellite counts sorted descending, while the Generated SQL only returns the top manufacturer (due to LIMIT 1). The Generated query's LIMIT 1 clause makes it produce a different result set than the Reference query.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count satellites per manufacturer and identify the top manufacturer. The reference query groups by m.name, which may not be strictly compliant with SQL standards (as m.id is the primary key). The generated query groups by both m.id and m.name, ensuring technical correctness. The generated query also uses LIMIT 1 to directly answer the question of 'which company' (singular), while the reference query returns all manufacturers ordered by count. Though both produce the same results, the generated query is more efficient and precisely addresses the business intent.", "overall_assessment": "differently_correct"}}
{"example_id": 3170, "sql_complexity": "aggregation", "prompt": "Determine the total production quantity of silver for mining sites in Mexico, between the dates '2017-05-01' and '2017-09-30', having less than 40 employees.", "context": "CREATE TABLE silver_mine_2 (site_id INT, country VARCHAR(50), num_employees INT, extraction_date DATE, quantity INT); INSERT INTO silver_mine_2 (site_id, country, num_employees, extraction_date, quantity) VALUES (1, 'Mexico', 35, '2017-05-02', 1200), (2, 'Mexico', 30, '2017-08-31', 1800), (3, 'Mexico', 37, '2017-07-04', 2200);", "reference_sql": "SELECT country, SUM(quantity) as total_silver_prod FROM silver_mine_2 WHERE num_employees < 40 AND country = 'Mexico' AND extraction_date >= '2017-05-01' AND extraction_date <= '2017-09-30' GROUP BY country;", "generated_sql": "SELECT SUM(quantity) AS total_quantity\nFROM silver_mine_2\nWHERE country = 'Mexico'\n  AND extraction_date BETWEEN '2017-05-01' AND '2017-09-30'\n  AND num_employees < 40;", "raw_model_output": "```sql\nSELECT SUM(quantity) AS total_quantity\nFROM silver_mine_2\nWHERE country = 'Mexico'\n  AND extraction_date BETWEEN '2017-05-01' AND '2017-09-30'\n  AND num_employees < 40;\n```", "latency_sec": 0.785944938659668, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 222, "prompt_eval_sec": null, "tokens_completion": 57, "completion_eval_sec": null, "tokens_total": 279, "tokens_per_sec": 354.98669980087925, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a GROUP BY country, which returns a row with both country and total_silver_prod, while the Generated SQL returns only the sum. Although the sum value is the same, the result sets differ in structure (columns). Additionally, the Generated SQL lacks the GROUP BY clause, which could affect behavior if there were multiple countries, but in this case, the country is fixed to Mexico.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly filter for Mexico, dates between '2017-05-01' and '2017-09-30', and sites with <40 employees. The reference query includes an unnecessary GROUP BY country (since country is already filtered to Mexico) and returns an extra column, while the generated query directly computes the sum without redundancy. The generated query is more efficient and elegant, achieving the same result with simpler syntax. Both fulfill the business intent of calculating total silver production, but the generated query does so more directly.", "overall_assessment": "correct"}}
{"example_id": 3518, "sql_complexity": "basic SQL", "prompt": "Insert new records of ticket sales for a new event, including event and salesperson information.", "context": "CREATE TABLE salesperson (salesperson_id INT, name VARCHAR(50), position VARCHAR(50)); CREATE TABLE tickets (ticket_id INT, salesperson_id INT, event_id INT, price DECIMAL(5,2), quantity INT); CREATE TABLE events (event_id INT, name VARCHAR(50), date DATE); INSERT INTO salesperson VALUES (1, 'John Doe', 'Senior Salesperson'); INSERT INTO events VALUES (2, 'New Event', '2023-04-15');", "reference_sql": "INSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity) VALUES (2, 1, 2, 75, 50), (3, 2, 2, 65, 75); INSERT INTO events (event_id, name, date) VALUES (2, 'New Event', '2023-04-15');", "generated_sql": "Insert new ticket sales records for the new event and existing salespersons\nINSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity)\nVALUES \n  (1, 1, 2, 50.00, 10);", "raw_model_output": "-- Insert new ticket sales records for the new event and existing salespersons\nINSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity)\nVALUES \n  (1, 1, 2, 50.00, 10);", "latency_sec": 0.9143610000610352, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 181, "prompt_eval_sec": null, "tokens_completion": 53, "completion_eval_sec": null, "tokens_total": 234, "tokens_per_sec": 255.9164268646411, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL inserts two ticket records and an event record, while the Generated SQL only inserts a single ticket record. The data values (ticket IDs, prices, quantities) differ between the two queries. Additionally, the Generated SQL does not include the event insertion present in the Reference SQL.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference SQL is technically flawed as it attempts to reinsert an existing event (event_id=2) which would cause a primary key violation if event_id is a primary key. The generated SQL correctly inserts only ticket records without duplicating the event. However, neither query fully fulfills the 'new event' requirement since the context already contains an event with ID 2. The generated SQL is more efficient and avoids redundant operations, but both fail to address the 'new event' aspect properly.", "overall_assessment": "differently_correct"}}
{"example_id": 3925, "sql_complexity": "set operations", "prompt": "What is the total number of students and staff with accommodations in the \"disability_services\" schema, excluding the \"accessibility_parking\" type?", "context": "CREATE SCHEMA disability_services; CREATE TABLE staff (id INT, name VARCHAR(50), accommodation VARCHAR(50)); CREATE TABLE students (id INT, name VARCHAR(50), accommodation VARCHAR(50));", "reference_sql": "SELECT COUNT(*) FROM disability_services.staff WHERE accommodation != 'accessibility_parking' UNION SELECT COUNT(*) FROM disability_services.students WHERE accommodation != 'accessibility_parking';", "generated_sql": "SELECT \n    (SELECT COUNT(*) FROM disability_services.students WHERE accommodation <> 'accessibility_parking') +\n    (SELECT COUNT(*) FROM disability_services.staff WHERE accommodation <> 'accessibility_parking') AS total_with_accommodations_excluding_parking;", "raw_model_output": "```sql\nSELECT \n    (SELECT COUNT(*) FROM disability_services.students WHERE accommodation <> 'accessibility_parking') +\n    (SELECT COUNT(*) FROM disability_services.staff WHERE accommodation <> 'accessibility_parking') AS total_with_accommodations_excluding_parking;\n```", "latency_sec": 0.731874942779541, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 137, "prompt_eval_sec": null, "tokens_completion": 55, "completion_eval_sec": null, "tokens_total": 192, "tokens_per_sec": 262.33990095468425, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate counts (staff and students) as individual rows using UNION, while the Generated SQL returns a single summed total. The structure and output format differ: the first produces two rows, the second a single row with a combined count. The semantic intent also differs (separate counts vs. total).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query uses UNION to combine two separate counts, resulting in two rows of output (e.g., 10 and 20) rather than a single total. The generated query correctly sums the counts using arithmetic addition, producing a single numeric result. Both queries exclude 'accessibility_parking' using equivalent operators (<> vs !=), but the generated query's approach directly addresses the business requirement for a total. The generated query is more efficient and semantically aligned with the question's intent.", "overall_assessment": "differently_correct"}}
{"example_id": 3340, "sql_complexity": "subqueries", "prompt": "Calculate the total revenue for garments manufactured in the US and sold in California.", "context": "CREATE TABLE garment_manufacturing(id INT PRIMARY KEY, garment_id INT, country VARCHAR(50), material VARCHAR(50), manufacturing_date DATE, quantity INT); CREATE TABLE garment_sales(id INT PRIMARY KEY, garment_id INT, store_id INT, sale_date DATE, units INT, revenue DECIMAL(10,2));", "reference_sql": "SELECT SUM(gs.revenue) FROM garment_manufacturing gm JOIN garment_sales gs ON gm.garment_id = gs.garment_id WHERE gm.country = 'United States' AND gs.store_id IN (SELECT id FROM stores WHERE region = 'California');", "generated_sql": "SELECT SUM(gs.revenue) AS total_revenue\nFROM garment_manufacturing gm\nJOIN garment_sales gs ON gm.garment_id = gs.garment_id\nJOIN (\n    SELECT DISTINCT store_id\n    FROM garment_sales\n    WHERE sale_date IS NOT NULL -- placeholder to ensure store_id is valid\n) stores ON gs.store_id = stores.store_id\nWHERE gm.country = 'US'\n  AND gs.store_id IN (\n      SELECT store_id\n      FROM garment_sales\n      WHERE sale_date IS NOT NULL -- no store location info in schema, so cannot filter by California\n  );", "raw_model_output": "```sql\nSELECT SUM(gs.revenue) AS total_revenue\nFROM garment_manufacturing gm\nJOIN garment_sales gs ON gm.garment_id = gs.garment_id\nJOIN (\n    SELECT DISTINCT store_id\n    FROM garment_sales\n    WHERE sale_date IS NOT NULL -- placeholder to ensure store_id is valid\n) stores ON gs.store_id = stores.store_id\nWHERE gm.country = 'US'\n  AND gs.store_id IN (\n      SELECT store_id\n      FROM garment_sales\n      WHERE sale_date IS NOT NULL -- no store location info in schema, so cannot filter by California\n  );\n```\n\nWait, the schema does not have any table or column indicating the location of stores, such as California. The garment_sales table has store_id but no location info. The garment_manufacturing table has country but no info about sales location.\n\nTherefore, it is impossible to filter sales by California because the schema does not provide any information about store locations or states.\n\nHence, the question cannot be answered with the given schema.\n\nThe best we can do is to calculate total revenue for garments manufactured in the US, but we cannot filter sales by California.\n\nSo the SQL is:\n\n```sql\nSELECT SUM(gs.revenue) AS total_revenue\nFROM garment_manufacturing gm\nJOIN garment_sales gs ON gm.garment_id = gs.garment_id\nWHERE gm.country = 'US';\n```\n\nThis calculates total revenue for garments manufactured in the US, regardless of where they were sold.\n\nIf the question requires filtering sales in California, but no such data exists, we cannot do it.\n\nTherefore, the final answer is:\n\n```sql\nSELECT SUM(gs.revenue) AS total_revenue\nFROM garment_manufacturing gm\nJOIN garment_sales gs ON gm.garment_id = gs.garment_id\nWHERE gm.country = 'US';\n```", "latency_sec": 2.7584969997406006, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 146, "prompt_eval_sec": null, "tokens_completion": 380, "completion_eval_sec": null, "tokens_total": 526, "tokens_per_sec": 190.6835497915942, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL references a non-existent 'stores' table in its subquery, while the Generated SQL uses a subquery from 'garment_sales' (which exists). Additionally, the country filter in the Reference SQL uses 'United States' whereas the Generated SQL uses 'US'. The Generated SQL also includes an unnecessary JOIN with a subquery that doesn't contribute meaningful filtering, and the subqueries for store_id differ in logic.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "equal", "explanation": "The reference query references a 'stores' table that does not exist in the provided schema, making it technically invalid. The generated query attempts to work around this by using a subquery on 'garment_sales' but incorrectly assumes store location data exists in the schema (no 'region' column is present). Both queries fail to address the missing schema elements (store location data) required to answer the question. The reference query's logic is simpler but contains a critical schema mismatch, while the generated query introduces unnecessary complexity without solving the core problem. Neither query can produce accurate results due to the absence of store location information in the database schema.", "overall_assessment": "incorrect"}}
{"example_id": 596, "sql_complexity": "basic SQL", "prompt": "What is the minimum energy production cost of wind farms in Spain?", "context": "CREATE TABLE wind_farm_costs (id INT, name TEXT, country TEXT, energy_production_cost FLOAT); INSERT INTO wind_farm_costs (id, name, country, energy_production_cost) VALUES (1, 'Las Tiesas', 'Spain', 0.045), (2, 'Eolo', 'Spain', 0.050);", "reference_sql": "SELECT MIN(energy_production_cost) FROM wind_farm_costs WHERE country = 'Spain';", "generated_sql": "SELECT MIN(energy_production_cost) AS min_energy_production_cost\nFROM wind_farm_costs\nWHERE country = 'Spain';", "raw_model_output": "```sql\nSELECT MIN(energy_production_cost) AS min_energy_production_cost\nFROM wind_farm_costs\nWHERE country = 'Spain';\n```", "latency_sec": 0.9627070426940918, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 155, "prompt_eval_sec": null, "tokens_completion": 33, "completion_eval_sec": null, "tokens_total": 188, "tokens_per_sec": 195.2826682080673, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the minimum energy_production_cost for Spain. The generated query adds an alias (AS min_energy_production_cost) which doesn't affect the result value, only the column name in the output. The WHERE clause and aggregate function are identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly retrieve the minimum energy production cost for Spanish wind farms by filtering on 'Spain' and using MIN(). The generated query adds an alias (AS min_energy_production_cost) which improves readability and explicitly names the output column, making the result more self-documenting without altering the semantic or technical correctness. The reference query is functionally identical but produces a column with an implicit name (energy_production_cost).", "overall_assessment": "correct"}}
{"example_id": 2604, "sql_complexity": "subqueries", "prompt": "What is the maximum number of virtual tours taken by a single user in the UK?", "context": "CREATE TABLE virtual_tour_data (user_id INT, hotel_id INT, tour_date DATE); INSERT INTO virtual_tour_data (user_id, hotel_id, tour_date) VALUES (1, 10, '2022-01-01'), (2, 11, '2022-01-03'), (3, 12, '2022-01-05'), (4, 10, '2022-01-07'), (5, 10, '2022-01-09'); CREATE TABLE hotels (hotel_id INT, hotel_name TEXT, country TEXT); INSERT INTO hotels (hotel_id, hotel_name, country) VALUES (10, 'Royal Park Hotel', 'UK'), (11, 'The Ritz London', 'UK'), (12, 'Hotel de Crillon', 'France');", "reference_sql": "SELECT MAX(vt.user_tours) FROM (SELECT user_id, COUNT(DISTINCT hotel_id) as user_tours FROM virtual_tour_data WHERE country = 'UK' GROUP BY user_id) as vt;", "generated_sql": "SELECT MAX(tour_count) AS max_virtual_tours\nFROM (\n    SELECT v.user_id, COUNT(*) AS tour_count\n    FROM virtual_tour_data v\n    JOIN hotels h ON v.hotel_id = h.hotel_id\n    WHERE h.country = 'UK'\n    GROUP BY v.user_id\n) AS user_tours;", "raw_model_output": "SELECT MAX(tour_count) AS max_virtual_tours\nFROM (\n    SELECT v.user_id, COUNT(*) AS tour_count\n    FROM virtual_tour_data v\n    JOIN hotels h ON v.hotel_id = h.hotel_id\n    WHERE h.country = 'UK'\n    GROUP BY v.user_id\n) AS user_tours;", "latency_sec": 0.9568400382995605, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 252, "prompt_eval_sec": null, "tokens_completion": 69, "completion_eval_sec": null, "tokens_total": 321, "tokens_per_sec": 335.4792725547545, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references a 'country' column in the virtual_tour_data table, which does not exist in the schema. The Generated SQL correctly joins with the hotels table to filter by country. The Reference SQL would fail due to invalid column reference, making the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL is technically incorrect because it references a 'country' column that doesn't exist in the virtual_tour_data table. It also incorrectly uses COUNT(DISTINCT hotel_id) which counts unique hotels rather than actual tour instances. The Generated SQL properly joins the virtual_tour_data with hotels, filters by UK country, and counts all tours per user (COUNT(*)), which aligns with the business intent of measuring the number of tours taken. While both queries aim to find a maximum value, only the Generated SQL correctly addresses the question's requirements.", "overall_assessment": "incorrect"}}
{"example_id": 5812, "sql_complexity": "single join", "prompt": "Calculate the percentage of Shariah-compliant investments held by each investor in the top 5 countries with the highest percentage?", "context": "CREATE TABLE investors (investor_id INT, investor_name TEXT, country TEXT); INSERT INTO investors (investor_id, investor_name, country) VALUES (1, 'Al Thani', 'Qatar'), (2, 'Saudi Investment Group', 'Saudi Arabia'), (3, 'Temasek Holdings', 'Singapore'); CREATE TABLE investments (investment_id INT, investor_id INT, investment_type TEXT, investment_value DECIMAL, is_shariah_compliant BOOLEAN); INSERT INTO investments (investment_id, investor_id, investment_type, investment_value, is_shariah_compliant) VALUES (1, 1, 'Real Estate', 15000000, true), (2, 2, 'Stocks', 20000000, false);", "reference_sql": "SELECT investor_name, ROUND((SUM(CASE WHEN is_shariah_compliant THEN investment_value ELSE 0 END) / SUM(investment_value)) * 100, 2) AS percentage FROM investments JOIN investors ON investments.investor_id = investors.investor_id GROUP BY investor_name ORDER BY percentage DESC LIMIT 5;", "generated_sql": "SELECT \n        i.country,\n        SUM(CASE WHEN inv.is_shariah_compliant THEN inv.investment_value ELSE 0 END) AS shariah_value,\n        SUM(inv.investment_value) AS total_value,\n        CASE \n            WHEN SUM(inv.investment_value) = 0 THEN 0\n            ELSE SUM(CASE WHEN inv.is_shariah_compliant THEN inv.investment_value ELSE 0 END) * 100.0 / SUM(inv.investment_value)\n        END AS shariah_percentage\n    FROM investors i\n    JOIN investments inv ON i.investor_id = inv.investor_id\n    GROUP BY i.country\n),\ntop_countries AS (\n    SELECT country\n    FROM country_shariah\n    ORDER BY shariah_percentage DESC\n    LIMIT 5\n)\nSELECT \n    i.investor_name,\n    i.country,\n    CASE \n        WHEN SUM(inv.investment_value) = 0 THEN 0\n        ELSE SUM(CASE WHEN inv.is_shariah_compliant THEN inv.investment_value ELSE 0 END) * 100.0 / SUM(inv.investment_value)\n    END AS shariah_compliant_percentage\nFROM investors i\nJOIN investments inv ON i.investor_id = inv.investor_id\nWHERE i.country IN (SELECT country FROM top_countries)\nGROUP BY i.investor_name, i.country\nORDER BY i.country, shariah_compliant_percentage DESC;", "raw_model_output": "WITH country_shariah AS (\n    SELECT \n        i.country,\n        SUM(CASE WHEN inv.is_shariah_compliant THEN inv.investment_value ELSE 0 END) AS shariah_value,\n        SUM(inv.investment_value) AS total_value,\n        CASE \n            WHEN SUM(inv.investment_value) = 0 THEN 0\n            ELSE SUM(CASE WHEN inv.is_shariah_compliant THEN inv.investment_value ELSE 0 END) * 100.0 / SUM(inv.investment_value)\n        END AS shariah_percentage\n    FROM investors i\n    JOIN investments inv ON i.investor_id = inv.investor_id\n    GROUP BY i.country\n),\ntop_countries AS (\n    SELECT country\n    FROM country_shariah\n    ORDER BY shariah_percentage DESC\n    LIMIT 5\n)\nSELECT \n    i.investor_name,\n    i.country,\n    CASE \n        WHEN SUM(inv.investment_value) = 0 THEN 0\n        ELSE SUM(CASE WHEN inv.is_shariah_compliant THEN inv.investment_value ELSE 0 END) * 100.0 / SUM(inv.investment_value)\n    END AS shariah_compliant_percentage\nFROM investors i\nJOIN investments inv ON i.investor_id = inv.investor_id\nWHERE i.country IN (SELECT country FROM top_countries)\nGROUP BY i.investor_name, i.country\nORDER BY i.country, shariah_compliant_percentage DESC;", "latency_sec": 2.6914281845092773, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 244, "prompt_eval_sec": null, "tokens_completion": 315, "completion_eval_sec": null, "tokens_total": 559, "tokens_per_sec": 207.69642051657468, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL calculates the shariah compliance percentage per investor and returns top 5 investors. The Generated SQL first calculates country-level shariah percentages, filters top 5 countries, then returns investor-level percentages only for those countries. Key differences: 1) Grouping/Filtering logic (investor vs country) 2) The Generated SQL includes additional CTEs and country-based filtering not present in the Reference SQL. 3) The final output structure and filtering criteria differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference SQL groups by investor_name and calculates individual investor percentages, which does not address the requirement to focus on the top 5 countries. The generated SQL attempts to first identify the top 5 countries by Shariah percentage (via a CTE) and then calculate investor percentages within those countries. However, the generated SQL contains a critical syntax error: it lacks the 'WITH' keyword before the CTEs, making it non-executable. Despite this, its logical approach better aligns with the business intent of focusing on top countries, whereas the reference SQL fundamentally misinterprets the question by grouping at the investor level instead of the country level.", "overall_assessment": "differently_correct"}}
{"example_id": 4706, "sql_complexity": "multiple_joins", "prompt": "Who are the top 3 customers by total spend on makeup products from Italy and Spain?", "context": "CREATE TABLE customers (customer_id INT, customer_name TEXT, country TEXT); INSERT INTO customers (customer_id, customer_name, country) VALUES (1, 'Alessandro Martini', 'IT'), (2, 'Laura Rossi', 'ES'), (3, 'Daniela Gonzalez', 'MX'), (4, 'Jose Hernandez', 'ES'), (5, 'Sophia Rodriguez', 'IT'); CREATE TABLE sales (sale_id INT, customer_id INT, product_id INT, sale_quantity INT, sale_country TEXT); INSERT INTO sales (sale_id, customer_id, product_id, sale_quantity, sale_country) VALUES (1, 1, 1, 100, 'IT'), (2, 2, 2, 150, 'ES'), (3, 3, 3, 200, 'MX'), (4, 4, 4, 250, 'ES'), (5, 5, 5, 300, 'IT'); CREATE TABLE products (product_id INT, product_name TEXT, category TEXT); INSERT INTO products (product_id, product_name, category) VALUES (1, 'Eyeshadow Palette', 'makeup'), (2, 'Liquid Lipstick', 'makeup'), (3, 'BB Cream', 'makeup'), (4, 'Volumizing Mascara', 'makeup'), (5, 'Nourishing Lip Balm', 'makeup');", "reference_sql": "SELECT c.customer_name, SUM(s.sale_quantity) as total_spent_on_makeup FROM sales s JOIN customers c ON s.customer_id = c.customer_id JOIN products p ON s.product_id = p.product_id WHERE c.country IN ('IT', 'ES') AND p.category = 'makeup' GROUP BY c.customer_name ORDER BY total_spent_on_makeup DESC LIMIT 3;", "generated_sql": "SELECT c.customer_name, SUM(s.sale_quantity) AS total_spend\nFROM customers c\nJOIN sales s ON c.customer_id = s.customer_id\nJOIN products p ON s.product_id = p.product_id\nWHERE p.category = 'makeup'\n  AND s.sale_country IN ('IT', 'ES')\nGROUP BY c.customer_name\nORDER BY total_spend DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT c.customer_name, SUM(s.sale_quantity) AS total_spend\nFROM customers c\nJOIN sales s ON c.customer_id = s.customer_id\nJOIN products p ON s.product_id = p.product_id\nWHERE p.category = 'makeup'\n  AND s.sale_country IN ('IT', 'ES')\nGROUP BY c.customer_name\nORDER BY total_spend DESC\nLIMIT 3;\n```", "latency_sec": 1.2018609046936035, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 377, "prompt_eval_sec": null, "tokens_completion": 85, "completion_eval_sec": null, "tokens_total": 462, "tokens_per_sec": 384.4038841730857, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their filtering conditions. The Reference SQL filters customers by their country ('IT', 'ES'), while the Generated SQL filters sales by sale_country ('IT', 'ES'). This leads to different data being aggregated: the Reference includes customers from IT/ES regardless of sale country, while the Generated includes sales in IT/ES regardless of customer country. For example, a customer from MX with a sale in IT would be excluded in the Reference but included in the Generated query.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in their filtering logic. The reference query correctly filters customers by their country ('c.country IN ('IT', 'ES')'), aligning with the business question about customers from Italy and Spain. The generated query incorrectly filters by 's.sale_country', which refers to the sale's location rather than the customer's origin. This discrepancy would produce different results: the reference focuses on customer nationality, while the generated query prioritizes sale geography. Both queries aggregate makeup purchases correctly but differ in their geographic criteria. The reference better fulfills the business intent of identifying top customers by their country of residence.", "overall_assessment": "differently_correct"}}
{"example_id": 1515, "sql_complexity": "multiple_joins", "prompt": "What is the average age of clients who lost cases in the 'personal injury' category?", "context": "CREATE TABLE Cases (CaseID int, ClientID int, Category varchar(50)); INSERT INTO Cases (CaseID, ClientID, Category) VALUES (701, 7, 'Personal Injury'); CREATE TABLE Clients (ClientID int, Age int, Gender varchar(10)); INSERT INTO Clients (ClientID, Age, Gender) VALUES (7, 45, 'Male'); CREATE TABLE CaseOutcomes (CaseID int, Outcome varchar(50)); INSERT INTO CaseOutcomes (CaseID, Outcome) VALUES (701, 'Lost');", "reference_sql": "SELECT AVG(C.Age) as AvgAge FROM Clients C INNER JOIN Cases CA ON C.ClientID = CA.ClientID INNER JOIN CaseOutcomes CO ON CA.CaseID = CO.CaseID WHERE CA.Category = 'Personal Injury' AND CO.Outcome = 'Lost';", "generated_sql": "SELECT AVG(c.Age) AS AverageAge\nFROM Clients c\nJOIN Cases ca ON c.ClientID = ca.ClientID\nJOIN CaseOutcomes co ON ca.CaseID = co.CaseID\nWHERE LOWER(ca.Category) = 'personal injury'\n  AND LOWER(co.Outcome) = 'lost';", "raw_model_output": "```sql\nSELECT AVG(c.Age) AS AverageAge\nFROM Clients c\nJOIN Cases ca ON c.ClientID = ca.ClientID\nJOIN CaseOutcomes co ON ca.CaseID = co.CaseID\nWHERE LOWER(ca.Category) = 'personal injury'\n  AND LOWER(co.Outcome) = 'lost';\n```", "latency_sec": 1.450141191482544, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 195, "prompt_eval_sec": null, "tokens_completion": 69, "completion_eval_sec": null, "tokens_total": 264, "tokens_per_sec": 182.0512385625713, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average age of clients with 'Personal Injury' cases that resulted in 'Lost'. The Generated SQL uses LOWER() to make the comparisons case-insensitive, but since the stored data exactly matches the lowercase values in the WHERE clause ('personal injury' and 'lost'), the result remains the same. The join conditions and table aliases are identical, ensuring equivalent row selection.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent due to the use of LOWER() in the generated query, which could affect matching if case variations exist in the data. However, in the provided context where Category is 'Personal Injury' and Outcome is 'Lost' (exact case matches), both queries would produce the same results. The reference query directly matches the exact string values as specified in the question, making it more precise for the given data. The generated query's case-insensitive approach is more flexible but unnecessary here. Both fulfill the business intent of calculating the average age of clients who lost personal injury cases, but the reference query is more efficient and directly aligns with the context's data formatting.", "overall_assessment": "correct"}}
{"example_id": 4388, "sql_complexity": "subqueries", "prompt": "Insert a new drug with a price 10% higher than the average price", "context": "CREATE TABLE drugs (drug_id INT, drug_name VARCHAR(50), price DECIMAL(10, 2)); INSERT INTO drugs (drug_id, drug_name, price) VALUES (1, 'DrugA', 50), (2, 'DrugB', 75), (3, 'DrugC', 100)", "reference_sql": "INSERT INTO drugs (drug_id, drug_name, price) VALUES ((SELECT MAX(drug_id) FROM drugs) + 1, 'DrugD', (SELECT AVG(price) * 1.1 FROM drugs))", "generated_sql": "INSERT INTO drugs (drug_name, price)\nVALUES ('NewDrug', (SELECT AVG(price) * 1.10 FROM drugs));", "raw_model_output": "INSERT INTO drugs (drug_name, price)\nVALUES ('NewDrug', (SELECT AVG(price) * 1.10 FROM drugs));", "latency_sec": 0.5980038642883301, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 149, "prompt_eval_sec": null, "tokens_completion": 28, "completion_eval_sec": null, "tokens_total": 177, "tokens_per_sec": 295.9847094142835, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL explicitly sets drug_id as (MAX(drug_id)+1) and uses 'DrugD' as the drug_name, while the Generated SQL omits drug_id (assuming auto-increment or default) and uses 'NewDrug' as the drug_name. Additionally, the price calculation is identical, but the combination of drug_id and drug_name differs between the two queries.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query correctly calculates the next drug_id by using (SELECT MAX(drug_id) FROM drugs) + 1, ensuring proper sequence. It also explicitly includes all required columns (drug_id, drug_name, price) in the INSERT. The generated query omits drug_id entirely, which would cause a syntax error since the column is non-nullable. Both calculate the price as 10% above average, but the generated query fails to address the full technical requirements of the schema. The reference query better fulfills the business intent by handling both the sequence and data integrity aspects.", "overall_assessment": "differently_correct"}}
{"example_id": 5431, "sql_complexity": "basic SQL", "prompt": "What is the average CO2 emission of ride-hailing vehicles in San Francisco?", "context": "CREATE TABLE SFRideHailing (id INT, company VARCHAR(20), co2_emission DECIMAL(5,2));", "reference_sql": "SELECT AVG(co2_emission) FROM SFRideHailing WHERE company = 'Uber';", "generated_sql": "SELECT AVG(co2_emission) AS average_co2_emission\nFROM SFRideHailing;", "raw_model_output": "SELECT AVG(co2_emission) AS average_co2_emission\nFROM SFRideHailing;", "latency_sec": 0.7782649993896484, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 110, "prompt_eval_sec": null, "tokens_completion": 22, "completion_eval_sec": null, "tokens_total": 132, "tokens_per_sec": 169.60803852610684, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the average co2_emission specifically for rides from 'Uber', while the Generated SQL calculates the average for all companies in the table. The WHERE clause in the Reference SQL restricts the data, making the results different unless all entries are from Uber.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL incorrectly filters for only 'Uber' vehicles, while the original question asks about all ride-hailing vehicles in San Francisco. The Generated SQL correctly calculates the average CO2 emission for the entire dataset, which represents all ride-hailing vehicles in the city. Although both queries are syntactically valid, they differ in semantic meaning. The Generated SQL better fulfills the business intent by considering all companies in the SFRideHailing table.", "overall_assessment": "differently_correct"}}
{"example_id": 3531, "sql_complexity": "single join", "prompt": "What is the total number of workouts and total workout time per user for users with a membership type of 'Basic'?", "context": "CREATE TABLE Members (id INT, user_name VARCHAR, membership_type VARCHAR, signup_date DATE); CREATE TABLE Workouts (id INT, user_id INT, workout_date DATE, workout_duration INT); INSERT INTO Members (id, user_name, membership_type, signup_date) VALUES (1, 'John Doe', 'Premium', '2020-01-01'), (2, 'Jane Smith', 'Basic', '2019-06-15'), (3, 'Alice Johnson', 'Premium', '2020-03-20'); INSERT INTO Workouts (id, user_id, workout_date, workout_duration) VALUES (1, 1, '2020-01-01', 60), (2, 1, '2020-01-02', 70), (3, 2, '2019-06-15', 90), (4, 3, '2020-03-20', 65), (5, 3, '2020-03-21', 70);", "reference_sql": "SELECT Members.user_name, SUM(Workouts.workout_duration) AS total_workout_time, COUNT(Workouts.id) AS total_workouts FROM Members JOIN Workouts ON Members.id = Workouts.user_id WHERE Members.membership_type = 'Basic' GROUP BY Members.user_name;", "generated_sql": "SELECT \n    m.user_name,\n    COUNT(w.id) AS total_workouts,\n    COALESCE(SUM(w.workout_duration), 0) AS total_workout_time\nFROM \n    Members m\nLEFT JOIN \n    Workouts w ON m.id = w.user_id\nWHERE \n    m.membership_type = 'Basic'\nGROUP BY \n    m.user_name;", "raw_model_output": "SELECT \n    m.user_name,\n    COUNT(w.id) AS total_workouts,\n    COALESCE(SUM(w.workout_duration), 0) AS total_workout_time\nFROM \n    Members m\nLEFT JOIN \n    Workouts w ON m.id = w.user_id\nWHERE \n    m.membership_type = 'Basic'\nGROUP BY \n    m.user_name;", "latency_sec": 0.8227810859680176, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 302, "prompt_eval_sec": null, "tokens_completion": 78, "completion_eval_sec": null, "tokens_total": 380, "tokens_per_sec": 461.8482443029458, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their JOIN type (INNER vs. LEFT) and handling of NULLs. The Reference SQL only includes 'Basic' members with at least one workout (INNER JOIN), while the Generated SQL includes 'Basic' members even without workouts (LEFT JOIN) and uses COALESCE to default SUM to 0. This leads to different result sets when there are 'Basic' members with no workout records.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in their JOIN type (INNER vs LEFT) and handling of null values. The Reference query uses an INNER JOIN which excludes Basic members with no workouts, while the Generated query uses a LEFT JOIN and COALESCE to include all Basic members (even those with zero workouts). Both calculate correct aggregates, but the Generated query is more comprehensive for the business intent. The Reference query would miss users like a hypothetical 'Basic' member with no workout records, whereas the Generated query explicitly handles this edge case.", "overall_assessment": "differently_correct"}}
{"example_id": 5678, "sql_complexity": "set operations", "prompt": "How many public works projects are there in 'Sydney' and 'Melbourne' combined?", "context": "CREATE TABLE PublicWorksC(id INT, city VARCHAR(20), project VARCHAR(30)); INSERT INTO PublicWorksC(id, city, project) VALUES (1, 'Sydney', 'Park Renovation'), (2, 'Melbourne', 'Sidewalk Repair');", "reference_sql": "SELECT COUNT(*) FROM (SELECT city FROM PublicWorksC WHERE city = 'Sydney' UNION ALL SELECT city FROM PublicWorksC WHERE city = 'Melbourne') AS Total;", "generated_sql": "SELECT COUNT(*) \nFROM PublicWorksC \nWHERE city IN ('Sydney', 'Melbourne');", "raw_model_output": "SELECT COUNT(*) \nFROM PublicWorksC \nWHERE city IN ('Sydney', 'Melbourne');", "latency_sec": 0.5276029109954834, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 138, "prompt_eval_sec": null, "tokens_completion": 20, "completion_eval_sec": null, "tokens_total": 158, "tokens_per_sec": 299.46764262897057, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of rows where the city is either 'Sydney' or 'Melbourne'. The Reference SQL uses a UNION ALL to combine results from two separate selects, while the Generated SQL uses IN to achieve the same filtering. Since COUNT(*) counts all rows in the combined result, both approaches yield identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count projects in Sydney and Melbourne. The reference query uses a UNION ALL subquery to combine results, while the generated query uses a simpler IN clause. Technically, they produce identical results. However, the generated query is more efficient (single table scan vs subquery) and elegant. Both fulfill the business intent of counting combined projects, but the generated version is superior in performance and readability.", "overall_assessment": "correct"}}
{"example_id": 5792, "sql_complexity": "multiple_joins", "prompt": "How many cases were handled by attorneys in the 'Los Angeles' office?", "context": "CREATE TABLE offices (office_id INT, office_name VARCHAR(20), city VARCHAR(20), state VARCHAR(20)); INSERT INTO offices (office_id, office_name, city, state) VALUES (1, 'Boston', 'Boston', 'MA'), (2, 'New York', 'New York', 'NY'), (3, 'Los Angeles', 'Los Angeles', 'CA'); CREATE TABLE attorneys (attorney_id INT, office_id INT); INSERT INTO attorneys (attorney_id, office_id) VALUES (1, 1), (2, 2), (3, 3); CREATE TABLE cases (case_id INT, attorney_id INT); INSERT INTO cases (case_id, attorney_id) VALUES (1, 1), (2, 2), (3, 3);", "reference_sql": "SELECT COUNT(*) FROM cases JOIN attorneys ON cases.attorney_id = attorneys.attorney_id JOIN offices ON attorneys.office_id = offices.office_id WHERE offices.city = 'Los Angeles';", "generated_sql": "SELECT COUNT(*) AS case_count\nFROM cases c\nJOIN attorneys a ON c.attorney_id = a.attorney_id\nJOIN offices o ON a.office_id = o.office_id\nWHERE o.city = 'Los Angeles';", "raw_model_output": "SELECT COUNT(*) AS case_count\nFROM cases c\nJOIN attorneys a ON c.attorney_id = a.attorney_id\nJOIN offices o ON a.office_id = o.office_id\nWHERE o.city = 'Los Angeles';", "latency_sec": 0.7093613147735596, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 245, "prompt_eval_sec": null, "tokens_completion": 46, "completion_eval_sec": null, "tokens_total": 291, "tokens_per_sec": 410.2281784183456, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform the same three-table join (cases \u2192 attorneys \u2192 offices) with identical join conditions and filter on offices.city = 'Los Angeles'. The Generated SQL uses table aliases (c, a, o) and adds an alias (case_count) for the COUNT(*), which does not affect the semantic result. The logical structure and output remain identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly count cases linked to attorneys in the 'Los Angeles' office via three-table joins. The reference query uses bare table names while the generated query uses aliases (c/a/o), but aliases don't affect logic. Both have identical WHERE conditions filtering on offices.city = 'Los Angeles'. The generated query adds an explicit COUNT(*) alias (case_count) which is optional but improves readability. Neither query has syntax errors or logical flaws. The business intent is fully satisfied by both as they accurately measure cases handled by LA office attorneys.", "overall_assessment": "correct"}}
{"example_id": 5148, "sql_complexity": "window functions", "prompt": "List the unique types of smart city technologies that have been implemented in the top 3 most populous countries in the world.", "context": "CREATE TABLE smart_city_tech (tech_type VARCHAR(255), country VARCHAR(255)); CREATE TABLE country_populations (country VARCHAR(255), population INT);", "reference_sql": "SELECT DISTINCT tech_type FROM smart_city_tech SCT WHERE country IN (SELECT country FROM (SELECT country, ROW_NUMBER() OVER (ORDER BY population DESC) as rank FROM country_populations) CP WHERE rank <= 3);", "generated_sql": "SELECT DISTINCT sct.tech_type\nFROM smart_city_tech sct\nJOIN (\n    SELECT country\n    FROM country_populations\n    ORDER BY population DESC\n    LIMIT 3\n) top_countries ON sct.country = top_countries.country;", "raw_model_output": "```sql\nSELECT DISTINCT sct.tech_type\nFROM smart_city_tech sct\nJOIN (\n    SELECT country\n    FROM country_populations\n    ORDER BY population DESC\n    LIMIT 3\n) top_countries ON sct.country = top_countries.country;\n```", "latency_sec": 0.7773480415344238, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 123, "prompt_eval_sec": null, "tokens_completion": 57, "completion_eval_sec": null, "tokens_total": 180, "tokens_per_sec": 231.55651057497252, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve distinct tech_types from smart_city_tech where the country is among the top 3 most populous countries. The reference query uses ROW_NUMBER() to rank countries by population and filters rank <= 3, while the generated query uses ORDER BY population DESC with LIMIT 3. Both approaches effectively identify the same top 3 countries (assuming unique population values or consistent tie-breaking), leading to equivalent results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify unique smart city technologies in the top 3 most populous countries. The reference query uses a window function with ROW_NUMBER() to rank countries by population, while the generated query uses ORDER BY + LIMIT 3. Both approaches correctly retrieve the top 3 countries. The generated query is more efficient (avoids window function overhead) and elegant (simpler syntax). Both produce identical result sets assuming no population ties, and both address the business intent of identifying technologies in the most populous countries.", "overall_assessment": "correct"}}
{"example_id": 5547, "sql_complexity": "multiple_joins", "prompt": "Which species have a population growth rate higher than the average for protected areas?", "context": "CREATE TABLE species (id INT, name VARCHAR(50), population DECIMAL(5,2), protected_area_id INT, growth_rate DECIMAL(5,2)); INSERT INTO species (id, name, population, protected_area_id, growth_rate) VALUES (1, 'Species 1', 500.00, 1, 0.05), (2, 'Species 2', 800.00, 1, 0.03), (3, 'Species 3', 1200.00, 2, 0.07), (4, 'Species 4', 700.00, 2, 0.02); CREATE TABLE protected_areas (id INT, name VARCHAR(50)); INSERT INTO protected_areas (id, name) VALUES (1, 'Area 1'), (2, 'Area 2');", "reference_sql": "SELECT s.name, s.growth_rate FROM species s INNER JOIN protected_areas pa ON s.protected_area_id = pa.id GROUP BY s.name, s.growth_rate HAVING s.growth_rate > (SELECT AVG(s.growth_rate) FROM species s INNER JOIN protected_areas pa ON s.protected_area_id = pa.id);", "generated_sql": "SELECT name\nFROM species\nWHERE growth_rate > (SELECT AVG(growth_rate) FROM species);", "raw_model_output": "SELECT name\nFROM species\nWHERE growth_rate > (SELECT AVG(growth_rate) FROM species);", "latency_sec": 1.2949888706207275, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 260, "prompt_eval_sec": null, "tokens_completion": 21, "completion_eval_sec": null, "tokens_total": 281, "tokens_per_sec": 216.99028182791113, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects both 'name' and 'growth_rate' columns, while the Generated SQL only selects 'name'. Additionally, the Reference SQL includes an unnecessary INNER JOIN with protected_areas and GROUP BY clause, which doesn't affect the result but changes the query structure. The subquery in the HAVING clause of the Reference SQL (which joins species with protected_areas) technically computes the same average as the Generated SQL's subquery (directly from species), but the differing output columns make the results non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query correctly calculates the average growth rate specifically for species in protected areas by joining with the protected_areas table, ensuring the comparison is contextually accurate. The generated query incorrectly uses the overall average growth rate of all species (including potential non-protected species) without considering the protected area context. While both queries return species with growth rates above averages, the reference query aligns with the business intent of comparing against protected area-specific averages. The generated query risks including species not in protected areas, making it less precise.", "overall_assessment": "differently_correct"}}
{"example_id": 5498, "sql_complexity": "aggregation", "prompt": "Identify the destinations with the highest number of repeat visitors from the US.", "context": "CREATE TABLE RepeatTravelers (Visitor VARCHAR(20), Destination VARCHAR(20), VisitCount INT); INSERT INTO RepeatTravelers (Visitor, Destination, VisitCount) VALUES ('David', 'Paris', 3), ('Ella', 'London', 4), ('Fiona', 'Paris', 2);", "reference_sql": "SELECT Destination, AVG(VisitCount) AS AvgVisitCount FROM RepeatTravelers WHERE Visitor LIKE '%USA%' GROUP BY Destination ORDER BY AvgVisitCount DESC;", "generated_sql": "SELECT Destination\nFROM RepeatTravelers\nGROUP BY Destination\nORDER BY COUNT(DISTINCT Visitor) DESC\nLIMIT 1;", "raw_model_output": "```sql\nSELECT Destination\nFROM RepeatTravelers\nGROUP BY Destination\nORDER BY COUNT(DISTINCT Visitor) DESC\nLIMIT 1;\n```", "latency_sec": 0.8939950466156006, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 143, "prompt_eval_sec": null, "tokens_completion": 31, "completion_eval_sec": null, "tokens_total": 174, "tokens_per_sec": 194.6319508801668, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries perform different operations. The reference query calculates the average VisitCount for destinations where the visitor contains 'USA', while the generated query finds the destination with the highest count of distinct visitors. The sample data has no 'USA' visitors, making the reference query return no results, whereas the generated query returns 'Paris' as it has 2 distinct visitors.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL filters for US visitors (via WHERE Visitor LIKE '%USA%') and calculates average VisitCount per destination, but it misinterprets the business intent by using an average instead of counting actual repeat visitors. The Generated SQL correctly counts distinct visitors per destination but completely ignores the 'from the US' condition and fails to account for VisitCount as a measure of 'repeat' status. While neither query fully meets the intent, the Reference SQL addresses the US filter, which is critical to the question, even though its metric (average VisitCount) is flawed.", "overall_assessment": "differently_correct"}}
{"example_id": 3546, "sql_complexity": "window functions", "prompt": "What are the cryptocurrency exchanges with their corresponding blockchain companies, ranked by exchange ID in ascending order, for the Bitcoin platform?", "context": "CREATE TABLE cryptocurrency_exchanges (exchange_id INT, exchange_name VARCHAR(50), company_id INT); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (1, 'Binance', 1); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (2, 'Coinbase', 2); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (3, 'Kraken', 3); CREATE TABLE blockchain_companies (company_id INT, company_name VARCHAR(50), platform VARCHAR(50)); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (1, 'Binance', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (2, 'Blockstream', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (3, 'Blockchair', 'Bitcoin');", "reference_sql": "SELECT ce.exchange_name, bc.company_name, ce.exchange_id, ROW_NUMBER() OVER (PARTITION BY bc.platform ORDER BY ce.exchange_id ASC) as rank FROM cryptocurrency_exchanges ce JOIN blockchain_companies bc ON ce.company_id = bc.company_id WHERE bc.platform = 'Bitcoin';", "generated_sql": "SELECT ce.exchange_name, bc.company_name\nFROM cryptocurrency_exchanges ce\nJOIN blockchain_companies bc ON ce.company_id = bc.company_id\nWHERE bc.platform = 'Bitcoin'\nORDER BY ce.exchange_id ASC;", "raw_model_output": "SELECT ce.exchange_name, bc.company_name\nFROM cryptocurrency_exchanges ce\nJOIN blockchain_companies bc ON ce.company_id = bc.company_id\nWHERE bc.platform = 'Bitcoin'\nORDER BY ce.exchange_id ASC;", "latency_sec": 1.4739961624145508, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 285, "prompt_eval_sec": null, "tokens_completion": 44, "completion_eval_sec": null, "tokens_total": 329, "tokens_per_sec": 223.20275207573513, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL includes a ROW_NUMBER() window function to generate a 'rank' column based on exchange_id partitioned by platform, while the Generated SQL omits this column and does not include the window function. Additionally, the Generated SQL adds an ORDER BY clause not present in the Reference SQL, which would affect the output ordering but not the semantic equivalence. The presence of the rank column in the Reference SQL makes the result sets structurally different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query includes a ranking column (ROW_NUMBER()) as required by the original question, while the generated query omits this critical element. Both queries correctly join the tables and filter for 'Bitcoin', but the reference query explicitly addresses the 'ranked by exchange ID' requirement. The generated query only orders results without providing a rank. The reference query also includes exchange_id in the output, which is implied by the question's request for 'corresponding blockchain companies' with exchange details. While the generated query is more efficient, it fails to fulfill the business intent of providing a ranking.", "overall_assessment": "differently_correct"}}
{"example_id": 486, "sql_complexity": "single join", "prompt": "What is the average price of paintings from African artists in our collection?", "context": "CREATE TABLE Artworks (id INT, title VARCHAR(50), price DECIMAL(10,2), medium VARCHAR(50), artist_nationality VARCHAR(50)); CREATE TABLE Collections (id INT, name VARCHAR(50), continent VARCHAR(50));", "reference_sql": "SELECT AVG(Artworks.price) FROM Artworks INNER JOIN Collections ON Artworks.artist_nationality = Collections.continent WHERE Artworks.medium = 'Painting' AND Collections.continent = 'Africa';", "generated_sql": "SELECT AVG(price) AS average_price\nFROM Artworks\nWHERE medium = 'painting' AND artist_nationality = 'African';", "raw_model_output": "```sql\nSELECT AVG(price) AS average_price\nFROM Artworks\nWHERE medium = 'painting' AND artist_nationality = 'African';\n```", "latency_sec": 0.5722501277923584, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 132, "prompt_eval_sec": null, "tokens_completion": 32, "completion_eval_sec": null, "tokens_total": 164, "tokens_per_sec": 286.5879657077291, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their conditions for artist nationality. The Reference SQL uses a join with Collections where Collections.continent = 'Africa' (implying Artworks.artist_nationality = 'Africa') and filters by Artworks.medium = 'Painting'. The Generated SQL directly checks Artworks.artist_nationality = 'African' (a different value) and omits the join. Additionally, the medium filter in the Generated SQL uses lowercase 'painting' vs. 'Painting' in the Reference SQL, which may or may not matter depending on collation, but the primary discrepancy is the nationality value.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in their approach to filtering African artists. The Reference SQL incorrectly joins Artworks.artist_nationality with Collections.continent (e.g., 'Kenyan' vs. 'Africa'), which would fail to capture valid African artists whose nationalities don't match continent names. It also redundantly filters Collections.continent = 'Africa' after the join, which is unnecessary. The Generated SQL directly filters Artworks.artist_nationality = 'African', which is semantically clearer and avoids flawed joins. While both aim for the same business intent, the Generated query is technically correct, more efficient, and directly addresses the question without unnecessary complexity.", "overall_assessment": "differently_correct"}}
{"example_id": 794, "sql_complexity": "multiple_joins", "prompt": "Which suppliers have provided raw materials for the production of chemicals with high environmental impact?", "context": "CREATE TABLE suppliers (id INT, name TEXT); INSERT INTO suppliers (id, name) VALUES (1, 'Supplier1'), (2, 'Supplier2'), (3, 'Supplier3'); CREATE TABLE chemicals (id INT, name TEXT, environmental_impact INT); INSERT INTO chemicals (id, name, environmental_impact) VALUES (1, 'ChemA', 10), (2, 'ChemB', 20), (3, 'ChemC', 15); CREATE TABLE raw_materials (chemical_id INT, supplier_id INT); INSERT INTO raw_materials (chemical_id, supplier_id) VALUES (1, 1), (1, 2), (2, 3), (3, 1);", "reference_sql": "SELECT s.name FROM suppliers s INNER JOIN raw_materials rm ON s.id = rm.supplier_id INNER JOIN chemicals c ON rm.chemical_id = c.id WHERE c.environmental_impact > 10;", "generated_sql": "SELECT DISTINCT s.id, s.name\nFROM suppliers s\nJOIN raw_materials rm ON s.id = rm.supplier_id\nJOIN chemicals c ON rm.chemical_id = c.id\nWHERE c.environmental_impact > 15;", "raw_model_output": "SELECT DISTINCT s.id, s.name\nFROM suppliers s\nJOIN raw_materials rm ON s.id = rm.supplier_id\nJOIN chemicals c ON rm.chemical_id = c.id\nWHERE c.environmental_impact > 15;", "latency_sec": 1.2839701175689697, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 232, "prompt_eval_sec": null, "tokens_completion": 49, "completion_eval_sec": null, "tokens_total": 281, "tokens_per_sec": 218.85244536067313, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Reference SQL filters chemicals with environmental_impact > 10, while the Generated SQL uses > 15. Second, the Generated SQL includes DISTINCT and selects both id and name, whereas the Reference only selects name. These differences in filtering conditions and output columns make the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in two key aspects: 1) The reference uses `environmental_impact > 10` while the generated uses `> 15`, altering the threshold for 'high environmental impact'. 2) The generated query adds `DISTINCT` and includes `s.id` alongside `s.name`. The reference query better aligns with the original question's ambiguity about 'high impact' by using a lower threshold (10) that captures more chemicals (ChemB and ChemC). The generated query's stricter threshold (15) excludes ChemC (impact=15), potentially missing relevant suppliers. While the generated query avoids duplicates, the reference's approach is more inclusive for the unqualified term 'high impact'.", "overall_assessment": "differently_correct"}}
{"example_id": 3164, "sql_complexity": "set operations", "prompt": "What is the average age of patients who received therapy in 'clinic_a' and 'clinic_b'?", "context": "CREATE TABLE clinic_a (patient_id INT, age INT, therapy_received BOOLEAN); INSERT INTO clinic_a (patient_id, age, therapy_received) VALUES (1, 35, true), (2, 42, true), (3, 28, false); CREATE TABLE clinic_b (patient_id INT, age INT, therapy_received BOOLEAN); INSERT INTO clinic_b (patient_id, age, therapy_received) VALUES (4, 50, true), (5, 32, false), (6, 45, true);", "reference_sql": "SELECT AVG(age) FROM (SELECT age FROM clinic_a WHERE therapy_received = true UNION ALL SELECT age FROM clinic_b WHERE therapy_received = true) AS combined_clinics;", "generated_sql": "SELECT AVG(age) AS average_age\nFROM (\n    SELECT age FROM clinic_a WHERE therapy_received = TRUE\n    UNION ALL\n    SELECT age FROM clinic_b WHERE therapy_received = TRUE\n) AS combined;", "raw_model_output": "SELECT AVG(age) AS average_age\nFROM (\n    SELECT age FROM clinic_a WHERE therapy_received = TRUE\n    UNION ALL\n    SELECT age FROM clinic_b WHERE therapy_received = TRUE\n) AS combined;", "latency_sec": 0.6656980514526367, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 196, "prompt_eval_sec": null, "tokens_completion": 43, "completion_eval_sec": null, "tokens_total": 239, "tokens_per_sec": 359.02163072052264, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average age of patients who received therapy (therapy_received = true) from both clinics. The only difference is the alias name of the subquery ('combined_clinics' vs 'combined'), which does not affect the result. The structure, filtering, and aggregation are identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the average age of patients who received therapy in clinic_a and clinic_b. They use identical logic: filtering therapy_received=true in both tables, combining results with UNION ALL, and computing AVG(age). The differences are purely syntactic (alias names and column alias formatting) and do not affect results. Both queries accurately address the business intent of calculating the average age for therapy recipients across both clinics.", "overall_assessment": "correct"}}
{"example_id": 3704, "sql_complexity": "aggregation", "prompt": "What is the total sales revenue for each category of garments in the South America region in Q1 2022?", "context": "CREATE TABLE sales_category (sale_id INT, garment_category VARCHAR(50), sale_date DATE, total_sales DECIMAL(10, 2), region VARCHAR(50));", "reference_sql": "SELECT garment_category, SUM(total_sales) FROM sales_category WHERE sale_date BETWEEN '2022-01-01' AND '2022-03-31' AND region = 'South America' GROUP BY garment_category;", "generated_sql": "SELECT \n    garment_category, \n    SUM(total_sales) AS total_sales_revenue\nFROM \n    sales_category\nWHERE \n    region = 'South America'\n    AND sale_date >= '2022-01-01' \n    AND sale_date < '2022-04-01'\nGROUP BY \n    garment_category;", "raw_model_output": "```sql\nSELECT \n    garment_category, \n    SUM(total_sales) AS total_sales_revenue\nFROM \n    sales_category\nWHERE \n    region = 'South America'\n    AND sale_date >= '2022-01-01' \n    AND sale_date < '2022-04-01'\nGROUP BY \n    garment_category;\n```", "latency_sec": 0.7951128482818604, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 124, "prompt_eval_sec": null, "tokens_completion": 72, "completion_eval_sec": null, "tokens_total": 196, "tokens_per_sec": 246.50588960237724, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries aggregate total_sales by garment_category for 'South America' region. The date filters are equivalent: BETWEEN '2022-01-01' AND '2022-03-31' includes the same dates as >= '2022-01-01' and < '2022-04-01'. The column alias difference (SUM(total_sales) vs SUM(total_sales) AS total_sales_revenue) doesn't affect result semantics.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate total sales revenue per garment category in South America for Q1 2022. The Reference uses BETWEEN '2022-01-01' AND '2022-03-31' while the Generated uses >= '2022-01-01' and < '2022-04-01' - both capture the full Q1 2022 period. The Generated query is more precise with its date range (avoids potential edge cases with BETWEEN) and includes an explicit alias (total_sales_revenue) that improves readability. Both satisfy the business intent, but the Generated version demonstrates better date filtering practices and clarity.", "overall_assessment": "correct"}}
{"example_id": 2851, "sql_complexity": "single join", "prompt": "How many cases were handled by attorneys who joined the firm in 2015 or later?", "context": "CREATE TABLE attorneys (attorney_id INT, join_year INT); CREATE TABLE cases (case_id INT, attorney_id INT, billing_amount INT);", "reference_sql": "SELECT COUNT(DISTINCT cases.case_id) FROM cases INNER JOIN attorneys ON cases.attorney_id = attorneys.attorney_id WHERE attorneys.join_year >= 2015;", "generated_sql": "SELECT COUNT(*)\nFROM cases c\nJOIN attorneys a ON c.attorney_id = a.attorney_id\nWHERE a.join_year >= 2015;", "raw_model_output": "```sql\nSELECT COUNT(*)\nFROM cases c\nJOIN attorneys a ON c.attorney_id = a.attorney_id\nWHERE a.join_year >= 2015;\n```", "latency_sec": 0.5482230186462402, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 114, "prompt_eval_sec": null, "tokens_completion": 36, "completion_eval_sec": null, "tokens_total": 150, "tokens_per_sec": 273.61127661221514, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of cases associated with attorneys who joined in 2015 or later. Since case_id is likely a primary key (unique per case), COUNT(DISTINCT cases.case_id) and COUNT(*) will yield the same result when joining on attorney_id. The semantic meaning remains equivalent under this assumption.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "While both queries correctly join the tables and filter by join_year >= 2015, they differ in their aggregation approach. The reference query uses COUNT(DISTINCT cases.case_id) which ensures each case is counted only once even if multiple attorneys from 2015+ are associated with it. The generated query uses COUNT(*), which would overcount such cases. The original question asks for 'how many cases' handled by qualifying attorneys, implying unique case identification. The reference query better addresses this by preventing duplicate counts, making it more semantically accurate for the business intent.", "overall_assessment": "differently_correct"}}
{"example_id": 3246, "sql_complexity": "single join", "prompt": "What is the average eco-friendliness score of accommodations in Oceania by year?", "context": "CREATE TABLE Accommodations (Accommodation_ID INT, Accommodation_Name VARCHAR(50), City VARCHAR(30), Country VARCHAR(50), Eco_Friendliness_Score INT, Visit_Year INT); INSERT INTO Accommodations (Accommodation_ID, Accommodation_Name, City, Country, Eco_Friendliness_Score, Visit_Year) VALUES (1, 'EcoLodge', 'Sydney', 'Australia', 85, 2019), (2, 'GreenHotel', 'Melbourne', 'Australia', 90, 2019), (3, 'SustainableResort', 'Auckland', 'New Zealand', 80, 2019), (4, 'EcoVilla', 'Wellington', 'New Zealand', 88, 2019); CREATE TABLE Countries (Country VARCHAR(50), Continent VARCHAR(30)); INSERT INTO Countries (Country, Continent) VALUES ('Australia', 'Oceania'), ('New Zealand', 'Oceania');", "reference_sql": "SELECT C.Continent, V.Visit_Year, AVG(A.Eco_Friendliness_Score) AS Avg_Eco_Score  FROM Accommodations A  JOIN Countries C  ON A.Country = C.Country  WHERE C.Continent = 'Oceania'  GROUP BY C.Continent, V.Visit_Year  ORDER BY V.Visit_Year;", "generated_sql": "SELECT \n    A.Visit_Year,\n    AVG(A.Eco_Friendliness_Score) AS Average_Eco_Friendliness_Score\nFROM \n    Accommodations A\nJOIN \n    Countries C ON A.Country = C.Country\nWHERE \n    C.Continent = 'Oceania'\nGROUP BY \n    A.Visit_Year\nORDER BY \n    A.Visit_Year;", "raw_model_output": "```sql\nSELECT \n    A.Visit_Year,\n    AVG(A.Eco_Friendliness_Score) AS Average_Eco_Friendliness_Score\nFROM \n    Accommodations A\nJOIN \n    Countries C ON A.Country = C.Country\nWHERE \n    C.Continent = 'Oceania'\nGROUP BY \n    A.Visit_Year\nORDER BY \n    A.Visit_Year;\n```", "latency_sec": 1.1424427032470703, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 281, "prompt_eval_sec": null, "tokens_completion": 85, "completion_eval_sec": null, "tokens_total": 366, "tokens_per_sec": 320.3661758788852, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes 'Continent' in both the SELECT and GROUP BY clauses, while the Generated SQL omits it. Although the WHERE clause filters for 'Oceania', the presence of 'Continent' in the Reference's output adds an extra column. Additionally, the Reference groups by both 'Continent' and 'Visit_Year', but since 'Continent' is fixed, the grouping effectively reduces to 'Visit_Year'. However, the difference in output columns (Continent vs. no Continent) makes the results structurally different, so they are not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because the reference query includes 'Continent' in the SELECT and GROUP BY clauses, while the generated query does not. However, since the WHERE clause filters for 'Oceania', the Continent column would have identical values across all results. The generated query is more efficient by omitting redundant grouping and selection. Both fulfill the business intent of calculating average eco-friendliness by year for Oceania, but the generated query is cleaner and avoids unnecessary data exposure.", "overall_assessment": "differently_correct"}}
{"example_id": 3056, "sql_complexity": "multiple_joins", "prompt": "Identify all suppliers who provide non-GMO ingredients to restaurants with Michelin stars.", "context": "CREATE TABLE Suppliers (id INT, name VARCHAR(50), isNonGMO BOOLEAN); CREATE TABLE Restaurants (id INT, name VARCHAR(50), numStars INT); CREATE TABLE Ingredients (supplierId INT, restaurantId INT, isNonGMO BOOLEAN);", "reference_sql": "SELECT Suppliers.name FROM Suppliers INNER JOIN Ingredients ON Suppliers.id = Ingredients.supplierId INNER JOIN Restaurants ON Ingredients.restaurantId = Restaurants.id WHERE Restaurants.numStars > 2 AND Ingredients.isNonGMO = TRUE;", "generated_sql": "SELECT DISTINCT s.id, s.name\nFROM Suppliers s\nJOIN Ingredients i ON s.id = i.supplierId\nJOIN Restaurants r ON i.restaurantId = r.id\nWHERE s.isNonGMO = TRUE\n  AND i.isNonGMO = TRUE\n  AND r.numStars > 0;", "raw_model_output": "```sql\nSELECT DISTINCT s.id, s.name\nFROM Suppliers s\nJOIN Ingredients i ON s.id = i.supplierId\nJOIN Restaurants r ON i.restaurantId = r.id\nWHERE s.isNonGMO = TRUE\n  AND i.isNonGMO = TRUE\n  AND r.numStars > 0;\n```", "latency_sec": 1.1626949310302734, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 134, "prompt_eval_sec": null, "tokens_completion": 68, "completion_eval_sec": null, "tokens_total": 202, "tokens_per_sec": 173.73430863847162, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in three key aspects: 1) The reference query selects only 'Suppliers.name' while the generated query selects 's.id' and 's.name' (different output columns). 2) The reference query filters 'Restaurants.numStars > 2' while the generated query uses 'r.numStars > 0' (different numeric thresholds). 3) The generated query adds a condition 's.isNonGMO = TRUE' (Supplier table) that the reference query does not include, instead checking 'Ingredients.isNonGMO = TRUE'. These differences in columns, filters, and joined conditions make them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent. The reference query correctly focuses on ingredients' non-GMO status (Ingredients.isNonGMO = TRUE) and filters for restaurants with >2 stars (implying Michelin 3-star). The generated query incorrectly adds a redundant condition (s.isNonGMO = TRUE) that isn't required by the question, and uses r.numStars > 0 (which would include all restaurants with any stars, not just Michelin-starred ones). While the generated query avoids duplicates with DISTINCT, its business intent is compromised by the incorrect star filter and unnecessary supplier-level non-GMO check. The reference query better aligns with the question's requirement to identify suppliers of non-GMO ingredients to Michelin-starred restaurants.", "overall_assessment": "differently_correct"}}
{"example_id": 264, "sql_complexity": "set operations", "prompt": "List the number of community health centers and infectious disease tracking facilities in 'southwest' regions.", "context": "CREATE TABLE centers (id INT, name TEXT, region TEXT); INSERT INTO centers (id, name, region) VALUES (1, 'Center A', 'southwest'); INSERT INTO centers (id, name, region) VALUES (2, 'Center B', 'northeast'); INSERT INTO centers (id, name, region) VALUES (3, 'Center C', 'northwest'); CREATE TABLE diseases (id INT, name TEXT, region TEXT); INSERT INTO diseases (id, name, region) VALUES (1, 'Disease A', 'southwest'); INSERT INTO diseases (id, name, region) VALUES (2, 'Disease B', 'southeast');", "reference_sql": "SELECT COUNT(*) FROM ( (SELECT * FROM centers WHERE region = 'southwest') UNION (SELECT * FROM diseases WHERE region = 'southwest') );", "generated_sql": "SELECT\n    (SELECT COUNT(*) FROM centers WHERE region = 'southwest') AS community_health_centers,\n    (SELECT COUNT(*) FROM diseases WHERE region = 'southwest') AS infectious_disease_tracking_facilities;", "raw_model_output": "SELECT\n    (SELECT COUNT(*) FROM centers WHERE region = 'southwest') AS community_health_centers,\n    (SELECT COUNT(*) FROM diseases WHERE region = 'southwest') AS infectious_disease_tracking_facilities;", "latency_sec": 0.6789708137512207, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 224, "prompt_eval_sec": null, "tokens_completion": 45, "completion_eval_sec": null, "tokens_total": 269, "tokens_per_sec": 396.1878692749867, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns a single count of combined rows from centers and diseases (using UNION which removes duplicates), while the Generated SQL returns two separate counts as columns. The structure and output format differ: the first produces one value, the second produces two values. Additionally, UNION removes duplicates, which could affect the count if any rows were identical (though in this specific data, duplicates aren't present).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL combines centers and diseases into a single count using UNION, which would merge both tables' rows and count them as one metric. This violates the original question's requirement to separate community health centers (centers table) and infectious disease tracking facilities (diseases table). The Generated SQL correctly uses two independent subqueries to count each category separately, aligning with the business intent. While both queries are technically valid, the Generated SQL explicitly addresses the dual-count requirement, making it more accurate and efficient.", "overall_assessment": "differently_correct"}}
{"example_id": 2838, "sql_complexity": "basic SQL", "prompt": "What is the minimum safety rating of electric vehicles in the 'green_cars' table?", "context": "CREATE TABLE green_cars (id INT, make VARCHAR(50), model VARCHAR(50), type VARCHAR(50), safety_rating INT);", "reference_sql": "SELECT MIN(safety_rating) FROM green_cars WHERE type = 'Electric';", "generated_sql": "SELECT MIN(safety_rating) AS min_safety_rating\nFROM green_cars\nWHERE type = 'electric';", "raw_model_output": "```sql\nSELECT MIN(safety_rating) AS min_safety_rating\nFROM green_cars\nWHERE type = 'electric';\n```", "latency_sec": 0.6033992767333984, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 113, "prompt_eval_sec": null, "tokens_completion": 28, "completion_eval_sec": null, "tokens_total": 141, "tokens_per_sec": 233.6761170204359, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the case of the string literal in the WHERE clause ('Electric' vs 'electric'). While the rest of the query structure is identical, SQL string comparisons are typically case-sensitive in many database systems (e.g., PostgreSQL), which would cause these queries to filter different rows. The alias change (AS min_safety_rating) does not affect the result's semantic equivalence.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries differ in two key aspects: 1) The reference uses 'Electric' (capitalized) while the generated query uses 'electric' (lowercase) in the WHERE clause. This could lead to different results if the database is case-sensitive. 2) The generated query adds an alias (min_safety_rating) which doesn't affect the result's correctness but changes the output column name. While both queries correctly use MIN(safety_rating), the reference query better aligns with the original question's phrasing ('Electric') and avoids potential case sensitivity issues. The generated query's lowercase 'electric' might fail to retrieve records if the actual data uses capitalized values. Both fulfill the business intent, but the reference is more technically precise.", "overall_assessment": "differently_correct"}}
{"example_id": 1187, "sql_complexity": "multiple_joins", "prompt": "Who are the top 3 authors with the highest number of articles published in The Guardian?", "context": "CREATE TABLE authors (id INT, name VARCHAR(100), publisher VARCHAR(50)); CREATE TABLE articles_authors (article_id INT, author_id INT); INSERT INTO authors (id, name, publisher) VALUES (1, 'Author1', 'The Guardian'), (2, 'Author2', 'The Guardian'), (3, 'Author3', 'The Guardian'); INSERT INTO articles_authors (article_id, author_id) VALUES (1, 1), (2, 2), (3, 1), (3, 2), (3, 3); INSERT INTO articles (id, title, publication_date, publisher) VALUES (1, 'Article1', '2021-01-01', 'The Guardian'), (2, 'Article2', '2021-01-02', 'The Guardian'), (3, 'Article3', '2021-01-03', 'The Guardian');", "reference_sql": "SELECT a.name, COUNT(aa.article_id) AS articles_count FROM authors a JOIN articles_authors aa ON a.id = aa.author_id JOIN articles ar ON aa.article_id = ar.id WHERE ar.publisher = 'The Guardian' GROUP BY a.name ORDER BY articles_count DESC LIMIT 3;", "generated_sql": "SELECT a.name, COUNT(aa.article_id) AS article_count\nFROM authors a\nJOIN articles_authors aa ON a.id = aa.author_id\nJOIN articles ar ON aa.article_id = ar.id\nWHERE ar.publisher = 'The Guardian'\nGROUP BY a.name\nORDER BY article_count DESC\nLIMIT 3;", "raw_model_output": "SELECT a.name, COUNT(aa.article_id) AS article_count\nFROM authors a\nJOIN articles_authors aa ON a.id = aa.author_id\nJOIN articles ar ON aa.article_id = ar.id\nWHERE ar.publisher = 'The Guardian'\nGROUP BY a.name\nORDER BY article_count DESC\nLIMIT 3;", "latency_sec": 1.0813419818878174, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 274, "prompt_eval_sec": null, "tokens_completion": 66, "completion_eval_sec": null, "tokens_total": 340, "tokens_per_sec": 314.4241190066668, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. The only difference is the column alias name ('articles_count' vs 'article_count'), which does not affect the query's logic or result. Both queries perform identical joins, filtering, grouping, and ordering operations.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are structurally identical except for the column alias name ('articles_count' vs 'article_count'). The logic correctly joins authors, articles_authors, and articles tables, filters for The Guardian publications, groups by author, counts articles, and orders by the count. The difference in alias name does not affect result accuracy or business intent. Both queries would produce the same output and correctly answer the question.", "overall_assessment": "correct"}}
{"example_id": 360, "sql_complexity": "window functions", "prompt": "What is the change in crime rate for each category, between this year and last year, for the same time period?", "context": "CREATE TABLE CrimeStatistics (ID INT, CrimeType VARCHAR(50), Date TIMESTAMP, Count INT); INSERT INTO CrimeStatistics (ID, CrimeType, Date, Count) VALUES (1, 'Theft', '2022-01-01 00:00:00', 100), (2, 'Vandalism', '2022-01-01 00:00:00', 50), (3, 'Theft', '2022-01-02 00:00:00', 120), (4, 'Vandalism', '2022-01-02 00:00:00', 60), (5, 'Theft', '2021-01-01 00:00:00', 80), (6, 'Vandalism', '2021-01-01 00:00:00', 40), (7, 'Theft', '2021-01-02 00:00:00', 90), (8, 'Vandalism', '2021-01-02 00:00:00', 45);", "reference_sql": "SELECT CrimeType, (SUM(Count) OVER (PARTITION BY CrimeType ORDER BY EXTRACT(YEAR FROM Date) ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)) - SUM(Count) OVER (PARTITION BY CrimeType ORDER BY EXTRACT(YEAR FROM Date)) AS CrimeRateChange FROM CrimeStatistics WHERE Date BETWEEN DATE_TRUNC('year', CURRENT_DATE - INTERVAL '1 year') AND CURRENT_DATE;", "generated_sql": "SELECT\n        CrimeType,\n        EXTRACT(YEAR FROM Date) AS Year,\n        SUM(Count) AS TotalCount\n    FROM CrimeStatistics\n    WHERE Date >= '2021-01-01' AND Date < '2023-01-01'\n    GROUP BY CrimeType, EXTRACT(YEAR FROM Date)\n)\nSELECT\n    c1.CrimeType,\n    c2.TotalCount AS ThisYearCount,\n    c1.TotalCount AS LastYearCount,\n    (c2.TotalCount - c1.TotalCount) AS ChangeInCount\nFROM\n    YearlyCounts c1\nJOIN\n    YearlyCounts c2 ON c1.CrimeType = c2.CrimeType AND c1.Year = 2021 AND c2.Year = 2022;", "raw_model_output": "WITH YearlyCounts AS (\n    SELECT\n        CrimeType,\n        EXTRACT(YEAR FROM Date) AS Year,\n        SUM(Count) AS TotalCount\n    FROM CrimeStatistics\n    WHERE Date >= '2021-01-01' AND Date < '2023-01-01'\n    GROUP BY CrimeType, EXTRACT(YEAR FROM Date)\n)\nSELECT\n    c1.CrimeType,\n    c2.TotalCount AS ThisYearCount,\n    c1.TotalCount AS LastYearCount,\n    (c2.TotalCount - c1.TotalCount) AS ChangeInCount\nFROM\n    YearlyCounts c1\nJOIN\n    YearlyCounts c2 ON c1.CrimeType = c2.CrimeType AND c1.Year = 2021 AND c2.Year = 2022;", "latency_sec": 1.4523789882659912, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 323, "prompt_eval_sec": null, "tokens_completion": 171, "completion_eval_sec": null, "tokens_total": 494, "tokens_per_sec": 340.13160751505444, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL calculates a year-over-year change using window functions, but the Generated SQL explicitly compares 2021 and 2022 counts via a self-join. Key differences: 1) The Reference SQL's calculation is (previous year sum - current year sum) while the Generated SQL uses (current year - previous year), resulting in opposite signs. 2) The Reference SQL's window function behavior depends on ordering and framing, which may not align with the explicit year-based grouping in the Generated SQL. 3) The output structures differ (single change value vs. separate year counts). 4) The WHERE clauses filter different date ranges (Reference uses dynamic date logic, Generated uses hardcoded 2021-2023 range).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference SQL uses window functions to calculate differences between years but has flawed logic: 1) It filters dates between the start of last year and current date (not same time period), 2) The window function structure (ROWS BETWEEN 1 PRECEDING) would only work with ordered rows, not true year comparisons. The generated SQL has syntax errors (missing semicolons, improper CTE structure) but better addresses the intent by: 1) Aggregating yearly totals correctly, 2) Explicitly comparing 2021 and 2022 (though hardcoded). Neither fully meets the 'same time period' requirement, but the generated approach better captures annual comparisons. The reference SQL fails to properly isolate year-specific data.", "overall_assessment": "differently_correct"}}
{"example_id": 335, "sql_complexity": "single join", "prompt": "List the policy numbers, claim amounts, and claim dates for policies that have more than two claims and the total claim amount exceeds $5000", "context": "CREATE TABLE policies (policy_number INT);CREATE TABLE claims (claim_id INT, policy_number INT, claim_amount DECIMAL(10,2), claim_date DATE);", "reference_sql": "SELECT p.policy_number, c.claim_amount, c.claim_date FROM policies p INNER JOIN claims c ON p.policy_number = c.policy_number GROUP BY p.policy_number, c.claim_amount, c.claim_date HAVING COUNT(c.claim_id) > 2 AND SUM(c.claim_amount) > 5000;", "generated_sql": "SELECT c.policy_number, c.claim_amount, c.claim_date\nFROM claims c\nJOIN (\n    SELECT policy_number\n    FROM claims\n    GROUP BY policy_number\n    HAVING COUNT(*) > 2 AND SUM(claim_amount) > 5000\n) p ON c.policy_number = p.policy_number;", "raw_model_output": "```sql\nSELECT c.policy_number, c.claim_amount, c.claim_date\nFROM claims c\nJOIN (\n    SELECT policy_number\n    FROM claims\n    GROUP BY policy_number\n    HAVING COUNT(*) > 2 AND SUM(claim_amount) > 5000\n) p ON c.policy_number = p.policy_number;\n```", "latency_sec": 1.1321430206298828, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 129, "prompt_eval_sec": null, "tokens_completion": 69, "completion_eval_sec": null, "tokens_total": 198, "tokens_per_sec": 174.889564650445, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their grouping and filtering logic. The reference query groups by policy_number, claim_amount, and claim_date, requiring each unique (policy, amount, date) combination to have >2 claims and total claim_amount >5000. The generated query first filters policies with >2 claims and total claim_amount >5000, then returns all claims for those policies. This results in different output structures: the reference returns aggregated (policy, amount, date) rows, while the generated query returns all individual claims for qualifying policies.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL is technically incorrect due to flawed grouping. It groups by policy_number, claim_amount, and claim_date, which would cause each claim to form its own group (since claim_amount and claim_date are unique per claim). This makes COUNT(c.claim_id) = 1 for all groups, rendering the HAVING clause impossible to satisfy. The Generated SQL correctly first identifies qualifying policies via a subquery (grouping by policy_number with HAVING COUNT(*) > 2 and SUM(...) > 5000), then joins back to retrieve all claims for those policies. This approach properly fulfills the business intent of listing all claims for policies meeting the criteria. The Generated SQL is both logically correct and efficient.", "overall_assessment": "differently_correct"}}
{"example_id": 2866, "sql_complexity": "basic SQL", "prompt": "What is the number of hospitals in 'rural_healthcare' table?", "context": "CREATE TABLE rural_healthcare (name VARCHAR(255), type VARCHAR(255), location VARCHAR(255)); INSERT INTO rural_healthcare (name, type, location) VALUES ('Rural General Hospital', 'Hospital', 'Bushland'), ('Rural Community Hospital', 'Hospital', 'Forest Region');", "reference_sql": "SELECT COUNT(*) FROM rural_healthcare WHERE type = 'Hospital';", "generated_sql": "SELECT COUNT(*) AS number_of_hospitals\nFROM rural_healthcare\nWHERE type = 'Hospital';", "raw_model_output": "```sql\nSELECT COUNT(*) AS number_of_hospitals\nFROM rural_healthcare\nWHERE type = 'Hospital';\n```", "latency_sec": 0.7192800045013428, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 142, "prompt_eval_sec": null, "tokens_completion": 26, "completion_eval_sec": null, "tokens_total": 168, "tokens_per_sec": 233.5668987718765, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries count the number of rows where type = 'Hospital'. The generated query adds an alias (number_of_hospitals) to the COUNT(*) result, but this does not affect the actual value returned. The semantic result (the count value) remains identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly count rows where type = 'Hospital' in the rural_healthcare table. The reference query uses minimal syntax, while the generated query adds an explicit column alias ('number_of_hospitals'). The alias improves readability and documentation but doesn't alter the result. Both produce identical counts and address the business question about hospital numbers. The difference is purely stylistic, with no impact on technical correctness or business intent fulfillment.", "overall_assessment": "correct"}}
{"example_id": 4440, "sql_complexity": "multiple_joins", "prompt": "What is the average session length for each game genre in the last month, sorted by average session length.", "context": "CREATE TABLE game_sessions(id INT, user_id INT, game_name VARCHAR(50), start_time DATETIME, end_time DATETIME); CREATE TABLE games(id INT, name VARCHAR(50), genre VARCHAR(50));", "reference_sql": "SELECT genres.genre, AVG(TIMESTAMPDIFF(SECOND, start_time, end_time)) as avg_session_length FROM game_sessions JOIN games ON game_sessions.game_name = games.name JOIN (SELECT DISTINCT game_name, genre FROM game_sessions JOIN games ON game_sessions.game_name = games.name) genres ON games.name = genres.game_name WHERE start_time >= DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH) GROUP BY genres.genre ORDER BY avg_session_length DESC;", "generated_sql": "SELECT \n    g.genre,\n    AVG(TIMESTAMPDIFF(SECOND, gs.start_time, gs.end_time)) AS avg_session_length_seconds\nFROM \n    game_sessions gs\nJOIN \n    games g ON gs.game_name = g.name\nWHERE \n    gs.start_time >= DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH)\nGROUP BY \n    g.genre\nORDER BY \n    avg_session_length_seconds;", "raw_model_output": "```sql\nSELECT \n    g.genre,\n    AVG(TIMESTAMPDIFF(SECOND, gs.start_time, gs.end_time)) AS avg_session_length_seconds\nFROM \n    game_sessions gs\nJOIN \n    games g ON gs.game_name = g.name\nWHERE \n    gs.start_time >= DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH)\nGROUP BY \n    g.genre\nORDER BY \n    avg_session_length_seconds;\n```", "latency_sec": 0.8849630355834961, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 131, "prompt_eval_sec": null, "tokens_completion": 90, "completion_eval_sec": null, "tokens_total": 221, "tokens_per_sec": 249.72794468673453, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average session length per genre for game sessions in the last month. The Reference SQL includes a redundant subquery that selects distinct (game_name, genre) pairs, but since the games table ensures each game_name has a single genre, this subquery doesn't affect the result. The Generated SQL simplifies the logic by directly joining game_sessions with games and grouping by genre, producing the same aggregated results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate average session length per genre for the last month. The reference query includes an unnecessary subquery with DISTINCT that doesn't affect the result since game_sessions.game_name is joined to games.name (implying 1:1 mapping). The generated query is more efficient with simpler logic, avoids redundant joins, and maintains clarity while achieving the same result. Both handle the date filter and ordering correctly.", "overall_assessment": "correct"}}
{"example_id": 451, "sql_complexity": "single join", "prompt": "Which customers have made a transaction over 500 in the \"risk_management\" category?", "context": "CREATE TABLE customers (id INT, name VARCHAR(50), category VARCHAR(50)); INSERT INTO customers (id, name, category) VALUES (1, 'John Doe', 'risk_management'); INSERT INTO customers (id, name, category) VALUES (2, 'Jane Smith', 'compliance'); INSERT INTO customers (id, name, category) VALUES (3, 'Jim Brown', 'risk_management'); CREATE TABLE transactions (id INT, customer_id INT, amount DECIMAL(10, 2)); INSERT INTO transactions (id, customer_id, amount) VALUES (1, 1, 500.00); INSERT INTO transactions (id, customer_id, amount) VALUES (2, 1, 200.00); INSERT INTO transactions (id, customer_id, amount) VALUES (3, 2, 100.00); INSERT INTO transactions (id, customer_id, amount) VALUES (4, 3, 750.00);", "reference_sql": "SELECT c.name FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE c.category = 'risk_management' AND t.amount > 500;", "generated_sql": "SELECT DISTINCT c.id, c.name\nFROM customers c\nJOIN transactions t ON c.id = t.customer_id\nWHERE c.category = 'risk_management' AND t.amount > 500;", "raw_model_output": "```sql\nSELECT DISTINCT c.id, c.name\nFROM customers c\nJOIN transactions t ON c.id = t.customer_id\nWHERE c.category = 'risk_management' AND t.amount > 500;\n```", "latency_sec": 2.103487968444824, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 279, "prompt_eval_sec": null, "tokens_completion": 43, "completion_eval_sec": null, "tokens_total": 322, "tokens_per_sec": 153.07907857351088, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL selects only 'c.name', while the Generated SQL selects 'c.id' and 'c.name' with DISTINCT. Although both filter for 'risk_management' customers with transactions > 500, the column sets differ, and the Generated SQL introduces DISTINCT which could affect results if duplicates existed. The sample data shows Jim Brown (id 3) as the only matching record, but the output structures remain different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query returns only customer names, while the generated query includes both customer IDs and names with DISTINCT to eliminate duplicates. The original question asks for 'customers' (which could imply unique identifiers), and the generated query better handles scenarios where a customer might have multiple qualifying transactions. Both fulfill the business intent of identifying risk_management customers with transactions over 500, but the generated query is more robust and precise.", "overall_assessment": "differently_correct"}}
{"example_id": 2879, "sql_complexity": "basic SQL", "prompt": "Update the FoodSafetyRecords.OrganicFarms table to include a new record for a certified organic farm in Kenya.", "context": "CREATE TABLE FoodSafetyRecords.OrganicFarms (farmName TEXT, country TEXT, certified BOOLEAN);", "reference_sql": "INSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('Ngong Organic Farm', 'Kenya', TRUE);", "generated_sql": "INSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified)\nVALUES ('New Organic Farm', 'Kenya', TRUE);", "raw_model_output": "INSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified)\nVALUES ('New Organic Farm', 'Kenya', TRUE);", "latency_sec": 0.5422909259796143, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 110, "prompt_eval_sec": null, "tokens_completion": 30, "completion_eval_sec": null, "tokens_total": 140, "tokens_per_sec": 258.16400993082976, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The two queries differ in the farmName value inserted. The reference query uses 'Ngong Organic Farm' while the generated query uses 'New Organic Farm'. Although all other columns (country and certified) are identical, the distinct farmName values result in different inserted rows, making the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly insert a new certified organic farm record into the Kenya table. The technical difference lies in the farmName value ('Ngong Organic Farm' vs 'New Organic Farm'), which affects result data but not structure/logic. Both satisfy the business intent of adding a certified Kenyan organic farm. The queries are equally efficient and elegant, with no clear superiority in this context.", "overall_assessment": "correct"}}
{"example_id": 5688, "sql_complexity": "single join", "prompt": "What is the total amount donated to a specific cause?", "context": "CREATE TABLE causes (id INT, name TEXT); CREATE TABLE donations (id INT, donor_id INT, cause_id INT, donation_amount DECIMAL(10,2)); INSERT INTO causes (id, name) VALUES (1, 'Cause A'), (2, 'Cause B'); INSERT INTO donations (id, donor_id, cause_id, donation_amount) VALUES (1, 1, 1, 50.00), (2, 2, 1, 100.00);", "reference_sql": "SELECT SUM(donation_amount) FROM donations JOIN causes ON donations.cause_id = causes.id WHERE causes.name = 'Cause A';", "generated_sql": "SELECT SUM(donation_amount) AS total_donated\nFROM donations\nWHERE cause_id = ?;", "raw_model_output": "SELECT SUM(donation_amount) AS total_donated\nFROM donations\nWHERE cause_id = ?;", "latency_sec": 0.6133701801300049, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 179, "prompt_eval_sec": null, "tokens_completion": 22, "completion_eval_sec": null, "tokens_total": 201, "tokens_per_sec": 327.6977044391002, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses a JOIN with the causes table to filter by cause name ('Cause A'), while the Generated SQL directly filters by cause_id with a placeholder. Without knowing the placeholder value, the Generated SQL could reference any cause_id, making them non-equivalent. The Reference SQL explicitly links to the cause name, whereas the Generated SQL relies on an unspecified parameter.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query is technically correct and directly addresses the business intent by explicitly joining the causes table and filtering by cause name ('Cause A'). The generated query is syntactically valid but relies on an unspecified parameter (?) that would need to be replaced with the actual cause_id value. While semantically equivalent if the parameter is correctly resolved, the generated query is incomplete without this context. The reference query is more self-contained and explicitly answers the question as posed, whereas the generated query requires external input to function. Both fulfill the business intent if properly implemented, but the reference is more directly aligned with the original question.", "overall_assessment": "differently_correct"}}
{"example_id": 3273, "sql_complexity": "multiple_joins", "prompt": "List all departments, the number of chemicals they handle, and the number of machines used in their manufacturing processes.", "context": "CREATE TABLE Departments (DepartmentID INT, DepartmentName VARCHAR(20)); INSERT INTO Departments (DepartmentID, DepartmentName) VALUES (1, 'Manufacturing'), (2, 'Engineering'), (3, 'Chemical Safety'), (4, 'Product Development'); CREATE TABLE Chemicals (ChemicalID INT, ChemicalName VARCHAR(20), DepartmentID INT); INSERT INTO Chemicals (ChemicalID, ChemicalName, DepartmentID) VALUES (1, 'Hydrochloric Acid', 1), (2, 'Nitric Acid', 2), (3, 'Sodium Hydroxide', 3), (4, 'New Chemical', 4); CREATE TABLE Machinery (MachineID INT, MachineName VARCHAR(20), DepartmentID INT); INSERT INTO Machinery (MachineID, MachineName, DepartmentID) VALUES (1, 'Mixer 1', 1), (2, 'Cutter 2', 2), (3, 'Dispenser 3', 3), (4, 'Innovator 4', 4);", "reference_sql": "SELECT D.DepartmentName, COUNT(C.ChemicalID) AS ChemicalCount, COUNT(M.MachineID) AS MachineCount FROM Departments D LEFT JOIN Chemicals C ON D.DepartmentID = C.DepartmentID LEFT JOIN Machinery M ON D.DepartmentID = M.DepartmentID GROUP BY D.DepartmentName;", "generated_sql": "SELECT \n    d.DepartmentName,\n    COUNT(DISTINCT c.ChemicalID) AS NumberOfChemicals,\n    COUNT(DISTINCT m.MachineID) AS NumberOfMachines\nFROM \n    Departments d\nLEFT JOIN \n    Chemicals c ON d.DepartmentID = c.DepartmentID\nLEFT JOIN \n    Machinery m ON d.DepartmentID = m.DepartmentID\nGROUP BY \n    d.DepartmentName;", "raw_model_output": "SELECT \n    d.DepartmentName,\n    COUNT(DISTINCT c.ChemicalID) AS NumberOfChemicals,\n    COUNT(DISTINCT m.MachineID) AS NumberOfMachines\nFROM \n    Departments d\nLEFT JOIN \n    Chemicals c ON d.DepartmentID = c.DepartmentID\nLEFT JOIN \n    Machinery m ON d.DepartmentID = m.DepartmentID\nGROUP BY \n    d.DepartmentName;", "latency_sec": 1.978097915649414, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 299, "prompt_eval_sec": null, "tokens_completion": 84, "completion_eval_sec": null, "tokens_total": 383, "tokens_per_sec": 193.62034455926326, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries produce the same result because the COUNT and COUNT(DISTINCT) functions yield identical results when the joined tables (Chemicals and Machinery) contain unique ChemicalID and MachineID values, as shown in the sample data. The GROUP BY clause and LEFT JOINs are equivalent in both queries.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in their handling of duplicate counts. The reference query uses COUNT(C.ChemicalID) and COUNT(M.MachineID), which would produce incorrect results if a department has multiple chemicals/machines (due to Cartesian product from multiple joins). The generated query uses COUNT(DISTINCT) to ensure accurate counts of unique chemicals and machines. While both queries would return the same results for the sample data provided, the generated query is technically correct for all scenarios. Both fulfill the business intent, but the generated query better addresses the requirement for accurate counts.", "overall_assessment": "differently_correct"}}
{"example_id": 1895, "sql_complexity": "window functions", "prompt": "What is the average safety score of chemical production sites in the United States, partitioned by state and ranked in descending order?", "context": "CREATE TABLE production_sites (site_id INT, site_name TEXT, country TEXT, state TEXT, safety_score FLOAT); INSERT INTO production_sites (site_id, site_name, country, state, safety_score) VALUES (1, 'Site A', 'USA', 'NY', 92.5), (2, 'Site B', 'USA', 'CA', 87.4), (3, 'Site C', 'USA', 'TX', 95.3), (4, 'Site D', 'USA', 'FL', 89.2);", "reference_sql": "SELECT state, AVG(safety_score) as avg_safety_score, ROW_NUMBER() OVER (ORDER BY AVG(safety_score) DESC) as rank FROM production_sites WHERE country = 'USA' GROUP BY state ORDER BY rank;", "generated_sql": "SELECT \n    state, \n    AVG(safety_score) AS avg_safety_score,\n    RANK() OVER (ORDER BY AVG(safety_score) DESC) AS rank\nFROM \n    production_sites\nWHERE \n    country = 'USA'\nGROUP BY \n    state\nORDER BY \n    avg_safety_score DESC;", "raw_model_output": "SELECT \n    state, \n    AVG(safety_score) AS avg_safety_score,\n    RANK() OVER (ORDER BY AVG(safety_score) DESC) AS rank\nFROM \n    production_sites\nWHERE \n    country = 'USA'\nGROUP BY \n    state\nORDER BY \n    avg_safety_score DESC;", "latency_sec": 1.1881420612335205, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 206, "prompt_eval_sec": null, "tokens_completion": 67, "completion_eval_sec": null, "tokens_total": 273, "tokens_per_sec": 229.77050380370625, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their ranking functions: ROW_NUMBER() (unique ranks) vs RANK() (non-unique ranks for ties). While the sample data has no ties, the functions behave differently when averages are equal. Additionally, the Reference SQL orders by 'rank' while the Generated SQL orders by 'avg_safety_score DESC', which would produce the same row order in this case but not guaranteed in all scenarios.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in two key technical aspects. 1) The Reference SQL uses ROW_NUMBER() which assigns unique ranks, while the Generated SQL uses RANK() which handles ties appropriately. 2) The Reference SQL attempts to order by the 'rank' alias in the ORDER BY clause, which is not valid SQL syntax in most databases. The Generated SQL correctly orders by the calculated average safety score. While both queries calculate the average safety score by state, only the Generated SQL properly addresses the ranking requirement. The Reference SQL would fail to execute due to the invalid ORDER BY clause.", "overall_assessment": "differently_correct"}}
{"example_id": 4669, "sql_complexity": "set operations", "prompt": "Identify the number of IoT devices in each country and the total number of devices.", "context": "CREATE TABLE device_country (device_id INT, country TEXT); INSERT INTO device_country (device_id, country) VALUES (1, 'USA'), (2, 'Canada'), (3, 'Mexico'), (4, 'Brazil'); CREATE TABLE device_info (device_id INT, device_type TEXT); INSERT INTO device_info (device_id, device_type) VALUES (1, 'Soil Sensor'), (2, 'Temperature Sensor'), (3, 'Humidity Sensor'), (4, 'Precision Sprayer');", "reference_sql": "SELECT country, COUNT(*) AS device_count FROM device_country GROUP BY country UNION SELECT 'Total' AS country, COUNT(*) FROM device_country;", "generated_sql": "SELECT \n    country,\n    COUNT(device_id) AS device_count\nFROM \n    device_country\nGROUP BY \n    country\n\nUNION ALL\n\nSELECT \n    'Total' AS country,\n    COUNT(device_id) AS device_count\nFROM \n    device_country;", "raw_model_output": "```sql\nSELECT \n    country,\n    COUNT(device_id) AS device_count\nFROM \n    device_country\nGROUP BY \n    country\n\nUNION ALL\n\nSELECT \n    'Total' AS country,\n    COUNT(device_id) AS device_count\nFROM \n    device_country;\n```", "latency_sec": 1.058481216430664, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 186, "prompt_eval_sec": null, "tokens_completion": 59, "completion_eval_sec": null, "tokens_total": 245, "tokens_per_sec": 231.4637200895938, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries produce the same result. The Reference SQL uses UNION (which implicitly removes duplicates) while the Generated SQL uses UNION ALL. However, since the two parts of the union (country groups and 'Total') cannot produce duplicate rows, the output is identical. Additionally, COUNT(*) and COUNT(device_id) are equivalent here because device_id is a non-nullable column. The column aliases and grouping logic are also identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries produce the same results by grouping devices by country and adding a total row. The reference uses UNION (which implicitly removes duplicates, though unnecessary here), while the generated query uses UNION ALL (more efficient for this scenario). The generated query is more efficient due to UNION ALL and avoids potential overhead from duplicate checking. Both fulfill the business intent of counting devices per country and providing a total, but the generated query is technically superior in execution.", "overall_assessment": "correct"}}
{"example_id": 5302, "sql_complexity": "multiple_joins", "prompt": "Find the supplier with the lowest average delivery time for orders in the last month.", "context": "CREATE TABLE Suppliers (SupplierID int, SupplierName varchar(50)); CREATE TABLE Products (ProductID int, ProductName varchar(50), SupplierID int); CREATE TABLE Orders (OrderID int, ProductID int, OrderDate date, DeliveryTime int); INSERT INTO Suppliers VALUES (1, 'SupplierA'), (2, 'SupplierB'); INSERT INTO Products VALUES (1, 'Organic Apples', 1), (2, 'Bananas', 2); INSERT INTO Orders VALUES (1, 1, '2022-01-01', 2), (2, 2, '2022-01-03', 3);", "reference_sql": "SELECT SupplierName, AVG(DeliveryTime) as AvgDeliveryTime FROM Orders o JOIN Products p ON o.ProductID = p.ProductID JOIN Suppliers sp ON p.SupplierID = sp.SupplierID WHERE OrderDate >= DATEADD(month, -1, GETDATE()) GROUP BY SupplierName ORDER BY AvgDeliveryTime ASC;", "generated_sql": "WITH LastMonthOrders AS (\n    SELECT o.OrderID, o.ProductID, o.DeliveryTime\n    FROM Orders o\n    WHERE o.OrderDate >= DATEADD(MONTH, -1, CURRENT_DATE)\n)\nSELECT s.SupplierID, s.SupplierName\nFROM Suppliers s\nJOIN Products p ON s.SupplierID = p.SupplierID\nJOIN LastMonthOrders lmo ON p.ProductID = lmo.ProductID\nGROUP BY s.SupplierID, s.SupplierName\nORDER BY AVG(lmo.DeliveryTime)\nLIMIT 1;", "raw_model_output": "```sql\nWITH LastMonthOrders AS (\n    SELECT o.OrderID, o.ProductID, o.DeliveryTime\n    FROM Orders o\n    WHERE o.OrderDate >= DATEADD(MONTH, -1, CURRENT_DATE)\n)\nSELECT s.SupplierID, s.SupplierName\nFROM Suppliers s\nJOIN Products p ON s.SupplierID = p.SupplierID\nJOIN LastMonthOrders lmo ON p.ProductID = lmo.ProductID\nGROUP BY s.SupplierID, s.SupplierName\nORDER BY AVG(lmo.DeliveryTime)\nLIMIT 1;\n```", "latency_sec": 1.1760990619659424, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 215, "prompt_eval_sec": null, "tokens_completion": 114, "completion_eval_sec": null, "tokens_total": 329, "tokens_per_sec": 279.73834062077265, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL returns all suppliers with their average delivery times for last month's orders, sorted by the average. The Generated SQL only returns the supplier with the lowest average delivery time (LIMIT 1) and groups by SupplierID/Name instead of just SupplierName. Additionally, the Generated SQL uses a CTE and different date function syntax (CURRENT_DATE vs GETDATE()).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries differ in technical implementation and semantic clarity. The Reference SQL explicitly calculates and aliases the average delivery time, uses standard JOIN syntax, and is more portable across SQL dialects. The Generated SQL omits the explicit average calculation in SELECT, relies on dialect-specific behavior (ORDER BY aggregate without GROUP BY), and uses LIMIT 1 which may not be universally supported. Both address the business intent but the Reference is more robust and standard.", "overall_assessment": "differently_correct"}}
{"example_id": 267, "sql_complexity": "subqueries", "prompt": "What is the total number of disability support programs offered in urban and rural areas, and the percentage of total programs for each area type?", "context": "CREATE TABLE programs (program_id INT, program_name VARCHAR(255), area_type VARCHAR(255));", "reference_sql": "SELECT area_type, COUNT(*) as total_programs, ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM programs) , 2) as percentage_of_total FROM programs WHERE area_type IN ('urban', 'rural') GROUP BY area_type;", "generated_sql": "SELECT \n    area_type,\n    COUNT(*) AS total_programs,\n    ROUND(100.0 * COUNT(*) / (SELECT COUNT(*) FROM programs), 2) AS percentage_of_total\nFROM programs\nWHERE program_name LIKE '%disability support%'\n  AND area_type IN ('urban', 'rural')\nGROUP BY area_type;", "raw_model_output": "```sql\nSELECT \n    area_type,\n    COUNT(*) AS total_programs,\n    ROUND(100.0 * COUNT(*) / (SELECT COUNT(*) FROM programs), 2) AS percentage_of_total\nFROM programs\nWHERE program_name LIKE '%disability support%'\n  AND area_type IN ('urban', 'rural')\nGROUP BY area_type;\n```", "latency_sec": 0.818436861038208, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 114, "prompt_eval_sec": null, "tokens_completion": 73, "completion_eval_sec": null, "tokens_total": 187, "tokens_per_sec": 228.4843326372003, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their WHERE clauses. The Reference SQL filters by area_type only, while the Generated SQL adds an additional condition (program_name LIKE '%disability support%'). This makes the Generated SQL more restrictive, filtering for programs with 'disability support' in their name, whereas the Reference SQL counts all programs in urban/rural areas regardless of program name.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries differ in critical aspects. The Reference SQL counts all programs in urban/rural areas without filtering for 'disability support', while the Generated SQL includes the necessary filter. However, both calculate percentages using the total program count (SELECT COUNT(*) FROM programs), which may not align with the question's intent. The original question asks for the percentage of 'total programs'\u2014if this refers to all programs, the Generated SQL is correct. If it refers to total disability programs, both are flawed. Despite this ambiguity, the Generated SQL better fulfills the business intent by filtering for disability support programs, making it more accurate for the stated requirement.", "overall_assessment": "differently_correct"}}
{"example_id": 3028, "sql_complexity": "basic SQL", "prompt": "What is the number of startups founded by non-binary individuals in the technology industry?", "context": "CREATE TABLE company (id INT, name TEXT, founder_gender TEXT, industry TEXT); INSERT INTO company (id, name, founder_gender, industry) VALUES (1, 'CodeForAll', 'Non-binary', 'Technology'); INSERT INTO company (id, name, founder_gender, industry) VALUES (2, 'TechVillage', 'Male', 'Technology');", "reference_sql": "SELECT COUNT(*) FROM company WHERE founder_gender = 'Non-binary' AND industry = 'Technology';", "generated_sql": "SELECT COUNT(*) \nFROM company \nWHERE founder_gender = 'Non-binary' \n  AND industry = 'Technology';", "raw_model_output": "SELECT COUNT(*) \nFROM company \nWHERE founder_gender = 'Non-binary' \n  AND industry = 'Technology';", "latency_sec": 0.5284419059753418, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 158, "prompt_eval_sec": null, "tokens_completion": 25, "completion_eval_sec": null, "tokens_total": 183, "tokens_per_sec": 346.30107478368524, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries have identical structure, conditions, and logic. The only difference is formatting (line breaks/indentation), which does not affect semantic meaning in SQL.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are syntactically identical except for formatting differences (line breaks and spaces). They both correctly count companies where founder_gender is 'Non-binary' and industry is 'Technology', which directly addresses the business question. The logic, conditions, and table/column references are exactly the same. Neither query has performance advantages over the other as they execute the same operation with the same constraints.", "overall_assessment": "correct"}}
{"example_id": 3282, "sql_complexity": "aggregation", "prompt": "Which marine species have been observed in both the Arctic and Antarctic oceans?", "context": "CREATE TABLE marine_species (id INT, species_name VARCHAR(50), common_name VARCHAR(50), region VARCHAR(20));INSERT INTO marine_species (id, species_name, common_name, region) VALUES (1, 'Orcinus_orca', 'Killer Whale', 'Arctic');INSERT INTO marine_species (id, species_name, common_name, region) VALUES (2, 'Balaenoptera_bonaerensis', 'Antarctic Minke Whale', 'Antarctic');", "reference_sql": "SELECT species_name FROM marine_species WHERE region IN ('Arctic', 'Antarctic') GROUP BY species_name HAVING COUNT(DISTINCT region) = 2;", "generated_sql": "SELECT species_name, common_name\nFROM marine_species\nWHERE region IN ('Arctic', 'Antarctic')\nGROUP BY species_name, common_name\nHAVING COUNT(DISTINCT region) = 2;", "raw_model_output": "```sql\nSELECT species_name, common_name\nFROM marine_species\nWHERE region IN ('Arctic', 'Antarctic')\nGROUP BY species_name, common_name\nHAVING COUNT(DISTINCT region) = 2;\n```", "latency_sec": 0.6788229942321777, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 184, "prompt_eval_sec": null, "tokens_completion": 48, "completion_eval_sec": null, "tokens_total": 232, "tokens_per_sec": 341.76803374555266, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query selects only 'species_name' and groups by it, while the generated query includes 'common_name' in both the SELECT and GROUP BY clauses. This changes the result structure and grouping logic. If a species_name had multiple distinct common_names (which the schema doesn't prohibit), the generated query would produce different grouping results. Additionally, the generated query returns an extra column not present in the reference query.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries correctly identify species present in both regions by grouping on species_name and checking for two distinct regions. The reference query is technically equivalent as it returns the same core result set (species_name) while being more concise. The generated query includes additional columns (common_name) which don't affect the semantic equivalence but add unnecessary data. Both fulfill the business intent, but the reference query is more elegant and efficient by focusing only on the required output.", "overall_assessment": "correct"}}
{"example_id": 3474, "sql_complexity": "subqueries", "prompt": "What is the total transaction volume for the top 3 digital assets by market capitalization in the 'developed_markets' schema?", "context": "CREATE SCHEMA developed_markets; CREATE TABLE developed_markets.digital_assets (asset_name VARCHAR(10), market_cap BIGINT, daily_transaction_volume BIGINT); INSERT INTO developed_markets.digital_assets (asset_name, market_cap, daily_transaction_volume) VALUES ('AssetG', 30000000, 15000000), ('AssetH', 25000000, 12000000), ('AssetI', 20000000, 10000000), ('AssetJ', 15000000, 8000000), ('AssetK', 10000000, 6000000);", "reference_sql": "SELECT SUM(daily_transaction_volume) FROM (SELECT daily_transaction_volume FROM developed_markets.digital_assets ORDER BY market_cap DESC FETCH NEXT 3 ROWS ONLY) t;", "generated_sql": "SELECT SUM(daily_transaction_volume) AS total_transaction_volume\nFROM (\n    SELECT daily_transaction_volume\n    FROM developed_markets.digital_assets\n    ORDER BY market_cap DESC\n    LIMIT 3\n) AS top_assets;", "raw_model_output": "SELECT SUM(daily_transaction_volume) AS total_transaction_volume\nFROM (\n    SELECT daily_transaction_volume\n    FROM developed_markets.digital_assets\n    ORDER BY market_cap DESC\n    LIMIT 3\n) AS top_assets;", "latency_sec": 0.6376252174377441, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 214, "prompt_eval_sec": null, "tokens_completion": 46, "completion_eval_sec": null, "tokens_total": 260, "tokens_per_sec": 407.76304463740195, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of daily_transaction_volume for the top 3 assets by market_cap descending. The reference uses FETCH NEXT 3 ROWS ONLY while the generated uses LIMIT 3, which are equivalent syntax for limiting results in different SQL dialects. The subquery structure, ordering, and aggregation logic are identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the total transaction volume for the top 3 digital assets by market capitalization. The reference query uses FETCH NEXT 3 ROWS ONLY while the generated query uses LIMIT 3, which are functionally equivalent in most SQL dialects. Both order by market_cap DESC, select the top 3 rows, and sum their daily_transaction_volume. The structural differences (e.g., alias naming) do not affect the result. The generated query is slightly more concise with explicit aliasing, but both are equally valid and efficient.", "overall_assessment": "correct"}}
{"example_id": 1626, "sql_complexity": "aggregation", "prompt": "Find the total value of social impact bonds issued by each organization.", "context": "CREATE TABLE social_impact_bonds (id INT, organization_name VARCHAR(255), issue_year INT, value FLOAT); INSERT INTO social_impact_bonds (id, organization_name, issue_year, value) VALUES (1, 'Acme Corp', 2018, 2000000), (2, 'XYZ Foundation', 2019, 3000000), (3, 'Global Giving', 2018, 1500000), (4, 'Acme Corp', 2019, 2500000), (5, 'XYZ Foundation', 2018, 1000000);", "reference_sql": "SELECT organization_name, SUM(value) as total_value FROM social_impact_bonds GROUP BY organization_name;", "generated_sql": "SELECT organization_name, SUM(value) AS total_value\nFROM social_impact_bonds\nGROUP BY organization_name;", "raw_model_output": "```sql\nSELECT organization_name, SUM(value) AS total_value\nFROM social_impact_bonds\nGROUP BY organization_name;\n```", "latency_sec": 0.5817909240722656, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 205, "prompt_eval_sec": null, "tokens_completion": 28, "completion_eval_sec": null, "tokens_total": 233, "tokens_per_sec": 400.48751253991463, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries have identical structure and logic. Both select organization_name and SUM(value) as total_value, grouping by organization_name. The generated SQL is merely formatted with line breaks and indentation but contains the same semantic meaning as the reference query.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic. They correctly aggregate the total value of social impact bonds by organization using SUM(value) with GROUP BY organization_name. The queries are syntactically identical, produce the same results, and directly address the business requirement to calculate organization-specific totals. Neither query has any technical deficiencies or semantic differences.", "overall_assessment": "correct"}}
{"example_id": 1315, "sql_complexity": "single join", "prompt": "List all the transactions made by clients living in New York with a transaction amount greater than $1000.", "context": "CREATE TABLE transactions (id INT, client_id INT, transaction_amount DECIMAL(10,2), transaction_date DATE); INSERT INTO transactions (id, client_id, transaction_amount, transaction_date) VALUES (1, 3, 1500.00, '2022-01-01'), (2, 4, 800.00, '2022-01-02'), (3, 3, 1200.00, '2022-01-03'); CREATE TABLE clients (id INT, name VARCHAR(255), state VARCHAR(255)); INSERT INTO clients (id, name, state) VALUES (3, 'Mike Johnson', 'New York'), (4, 'Sara Lee', 'California');", "reference_sql": "SELECT transactions.id, transactions.client_id, transactions.transaction_amount, transactions.transaction_date FROM transactions INNER JOIN clients ON transactions.client_id = clients.id WHERE clients.state = 'New York' AND transactions.transaction_amount > 1000.00;", "generated_sql": "SELECT t.*\nFROM transactions t\nJOIN clients c ON t.client_id = c.id\nWHERE c.state = 'New York' AND t.transaction_amount > 1000;", "raw_model_output": "```sql\nSELECT t.*\nFROM transactions t\nJOIN clients c ON t.client_id = c.id\nWHERE c.state = 'New York' AND t.transaction_amount > 1000;\n```", "latency_sec": 0.6103982925415039, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 236, "prompt_eval_sec": null, "tokens_completion": 40, "completion_eval_sec": null, "tokens_total": 276, "tokens_per_sec": 452.1637812105011, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same data by joining transactions with clients on client_id, filtering for New York clients with transaction amounts over 1000. The generated query uses table aliases and selects all transaction columns (t.*), which corresponds to the explicitly listed columns in the reference query. The WHERE conditions are logically identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly join the transactions and clients tables on client_id, filter for New York residents, and select transactions over $1000. The reference query explicitly lists columns while the generated query uses SELECT *, but both would return identical result sets. The generated query is more concise and uses table aliases for elegance without sacrificing clarity. Both fulfill the business intent of identifying high-value transactions from New York clients.", "overall_assessment": "correct"}}
{"example_id": 520, "sql_complexity": "multiple_joins", "prompt": "What is the total number of electric vehicles sold in 'California' in the 'sales' schema?", "context": "CREATE TABLE sales_regions (id INT, name VARCHAR(50));   CREATE TABLE sales (id INT, region_id INT, vehicle_count INT);   CREATE TABLE vehicles (id INT, type VARCHAR(50));   INSERT INTO sales_regions VALUES (1, 'California');   INSERT INTO sales VALUES (1, 1, 5000);   INSERT INTO vehicles VALUES (1, 'electric');", "reference_sql": "SELECT SUM(sales.vehicle_count) FROM sales INNER JOIN sales_regions ON sales.region_id = sales_regions.id INNER JOIN vehicles ON sales.id = vehicles.id WHERE vehicles.type = 'electric' AND sales_regions.name = 'California';", "generated_sql": "SELECT SUM(s.vehicle_count) AS total_electric_vehicles_sold\nFROM sales s\nJOIN sales_regions sr ON s.region_id = sr.id\nJOIN vehicles v ON s.id = v.id\nWHERE sr.name = 'California' AND v.type = 'electric';", "raw_model_output": "```sql\nSELECT SUM(s.vehicle_count) AS total_electric_vehicles_sold\nFROM sales s\nJOIN sales_regions sr ON s.region_id = sr.id\nJOIN vehicles v ON s.id = v.id\nWHERE sr.name = 'California' AND v.type = 'electric';\n```", "latency_sec": 0.8176829814910889, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 167, "prompt_eval_sec": null, "tokens_completion": 60, "completion_eval_sec": null, "tokens_total": 227, "tokens_per_sec": 277.61370254527407, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform the same operations: joining the sales, sales_regions, and vehicles tables on identical conditions, filtering for 'electric' vehicles in the 'California' region, and summing the vehicle_count. The differences are purely syntactic (table aliases and order of WHERE conditions) and do not affect the result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent, using identical JOIN logic, filtering conditions, and aggregation. The reference query uses full table names while the generated query uses aliases (s, sr, v), which is a stylistic choice with no impact on results. Both correctly sum vehicle_count from the sales table where region is California and vehicle type is electric. The business intent is fully addressed by both queries, as they directly answer the question about total electric vehicle sales in California. Neither query demonstrates superior efficiency or elegance over the other.", "overall_assessment": "correct"}}
{"example_id": 3999, "sql_complexity": "single join", "prompt": "What is the total number of tickets sold for performances with a rating of 5?", "context": "CREATE TABLE performance (id INT PRIMARY KEY, name VARCHAR(255), date DATE, artist_id INT, rating INT); INSERT INTO performance (id, name, date, artist_id, rating) VALUES (1, 'Dance Recital', '2022-03-01', 1, 5);", "reference_sql": "SELECT SUM(t.quantity) as total_tickets_sold FROM performance p INNER JOIN ticket t ON p.id = t.performance_id WHERE p.rating = 5;", "generated_sql": "SELECT SUM(tickets_sold) AS total_tickets_sold\nFROM performance\nWHERE rating = 5;", "raw_model_output": "```sql\nSELECT SUM(tickets_sold) AS total_tickets_sold\nFROM performance\nWHERE rating = 5;\n```", "latency_sec": 0.6246662139892578, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 146, "prompt_eval_sec": null, "tokens_completion": 28, "completion_eval_sec": null, "tokens_total": 174, "tokens_per_sec": 278.548761087617, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL correctly joins the 'performance' and 'ticket' tables to sum 't.quantity' where rating = 5. The Generated SQL attempts to sum a non-existent 'tickets_sold' column directly from the 'performance' table, which lacks this column. This would result in an error and does not match the logic of the Reference SQL.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly joins the performance table with the ticket table to sum ticket quantities for 5-star performances. The Generated SQL references a non-existent 'tickets_sold' column in the performance table (which only contains rating, not ticket quantities). The Generated query would fail with an 'unknown column' error and doesn't address the business intent of aggregating ticket sales data.", "overall_assessment": "incorrect"}}
{"example_id": 2261, "sql_complexity": "multiple_joins", "prompt": "What is the total number of animals that have been released into 'protected' habitats, and the average weight of those animals?", "context": "CREATE TABLE habitats (habitat_id INT, habitat_name VARCHAR(50), habitat_status VARCHAR(50)); INSERT INTO habitats (habitat_id, habitat_name, habitat_status) VALUES (1, 'Habitat A', 'protected'), (2, 'Habitat B', 'unprotected'); CREATE TABLE animal_habitats (animal_id INT, habitat_id INT, animal_weight FLOAT); INSERT INTO animal_habitats (animal_id, habitat_id, animal_weight) VALUES (101, 1, 25.5), (102, 2, 15.2); CREATE TABLE animals (animal_id INT, animal_name VARCHAR(50)); INSERT INTO animals (animal_id, animal_name) VALUES (101, 'Dog'), (102, 'Cat');", "reference_sql": "SELECT COUNT(*), AVG(animal_habitats.animal_weight) FROM animal_habitats INNER JOIN animals ON animal_habitats.animal_id = animals.animal_id INNER JOIN habitats ON animal_habitats.habitat_id = habitats.habitat_id WHERE habitats.habitat_status = 'protected';", "generated_sql": "SELECT \n    COUNT(DISTINCT ah.animal_id) AS total_animals,\n    AVG(ah.animal_weight) AS average_weight\nFROM animal_habitats ah\nJOIN habitats h ON ah.habitat_id = h.habitat_id\nWHERE h.habitat_status = 'protected';", "raw_model_output": "```sql\nSELECT \n    COUNT(DISTINCT ah.animal_id) AS total_animals,\n    AVG(ah.animal_weight) AS average_weight\nFROM animal_habitats ah\nJOIN habitats h ON ah.habitat_id = h.habitat_id\nWHERE h.habitat_status = 'protected';\n```", "latency_sec": 0.7470660209655762, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 246, "prompt_eval_sec": null, "tokens_completion": 67, "completion_eval_sec": null, "tokens_total": 313, "tokens_per_sec": 418.9723414209768, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their aggregation logic. The Reference SQL uses COUNT(*) which counts all rows in the joined result, while the Generated SQL uses COUNT(DISTINCT ah.animal_id) which counts unique animal IDs. This would produce different results if there are multiple entries for the same animal in the 'protected' habitat. Additionally, the Reference SQL includes an unnecessary join with the animals table that doesn't affect the output but changes the query's execution plan.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in two key aspects. 1) The reference query uses COUNT(*), which counts all rows, potentially overcounting animals that have multiple entries in the animal_habitats table. The generated query uses COUNT(DISTINCT ah.animal_id), which accurately counts the number of unique animals. 2) The reference query joins with the animals table, which is unnecessary since the required data (animal_weight) is already in the animal_habitats table. The generated query is more efficient and technically accurate for the business question, which asks for the total number of animals (not releases) and their average weight. Both queries correctly filter for 'protected' habitats and calculate the average weight, but the generated query better fulfills the business intent by accurately counting unique animals.", "overall_assessment": "differently_correct"}}
{"example_id": 3439, "sql_complexity": "multiple_joins", "prompt": "How many menu items contain ingredients sourced from local suppliers for each restaurant?", "context": "CREATE TABLE restaurants (id INT, name VARCHAR(50), location VARCHAR(50)); INSERT INTO restaurants VALUES (1, 'Restaurant A', 'City A'); INSERT INTO restaurants VALUES (2, 'Restaurant B', 'City B'); CREATE TABLE menu_items (id INT, name VARCHAR(50), restaurant_id INT, price DECIMAL(5,2)); INSERT INTO menu_items VALUES (1, 'Item A', 1, 10.99); INSERT INTO menu_items VALUES (2, 'Item B', 1, 12.99); INSERT INTO menu_items VALUES (3, 'Item C', 2, 11.99); CREATE TABLE ingredients (id INT, name VARCHAR(50), local_source BOOLEAN, menu_item_id INT); INSERT INTO ingredients VALUES (1, 'Ingredient A', TRUE, 1); INSERT INTO ingredients VALUES (2, 'Ingredient B', FALSE, 1); INSERT INTO ingredients VALUES (3, 'Ingredient C', TRUE, 2); INSERT INTO ingredients VALUES (4, 'Ingredient D', FALSE, 2); INSERT INTO ingredients VALUES (5, 'Ingredient E', TRUE, 3);", "reference_sql": "SELECT r.name, COUNT(DISTINCT mi.id) as num_local_items FROM restaurants r JOIN menu_items mi ON r.id = mi.restaurant_id JOIN ingredients i ON mi.id = i.menu_item_id WHERE i.local_source = TRUE GROUP BY r.name;", "generated_sql": "SELECT \n    r.name AS restaurant_name,\n    COUNT(DISTINCT mi.id) AS menu_items_with_local_ingredients\nFROM \n    restaurants r\nJOIN \n    menu_items mi ON r.id = mi.restaurant_id\nJOIN \n    ingredients i ON mi.id = i.menu_item_id\nWHERE \n    i.local_source = TRUE\nGROUP BY \n    r.name;", "raw_model_output": "SELECT \n    r.name AS restaurant_name,\n    COUNT(DISTINCT mi.id) AS menu_items_with_local_ingredients\nFROM \n    restaurants r\nJOIN \n    menu_items mi ON r.id = mi.restaurant_id\nJOIN \n    ingredients i ON mi.id = i.menu_item_id\nWHERE \n    i.local_source = TRUE\nGROUP BY \n    r.name;", "latency_sec": 2.9547998905181885, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 314, "prompt_eval_sec": null, "tokens_completion": 76, "completion_eval_sec": null, "tokens_total": 390, "tokens_per_sec": 131.98863356245928, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same data by joining the same tables with identical conditions, filtering on i.local_source = TRUE, and grouping by restaurant name. The only differences are in column aliases (e.g., 'name' vs 'restaurant_name', 'num_local_items' vs 'menu_items_with_local_ingredients'), which do not affect the semantic meaning of the result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are structurally identical except for column alias names. The reference uses 'name' and 'num_local_items' while the generated version uses 'restaurant_name' and 'menu_items_with_local_ingredients'. The logic remains the same: joining restaurants, menu items, and ingredients tables; filtering for local ingredients; and counting distinct menu items per restaurant. The semantic meaning and results would be identical. Both queries correctly address the business intent by ensuring each menu item is counted once per restaurant, even if it has multiple local ingredients. The generated query has slightly more explicit formatting but no functional difference.", "overall_assessment": "correct"}}
{"example_id": 2265, "sql_complexity": "aggregation", "prompt": "Hourly revenue for a specific movie?", "context": "CREATE TABLE Movie_Revenue (id INT, movie_title VARCHAR(100), revenue_time TIME, revenue DECIMAL(10,2));", "reference_sql": "SELECT revenue_time, SUM(revenue) FROM Movie_Revenue WHERE movie_title = 'Spider-Man: No Way Home' GROUP BY revenue_time;", "generated_sql": "SELECT revenue_time, revenue\nFROM Movie_Revenue\nWHERE movie_title = 'specific movie'\nORDER BY revenue_time;", "raw_model_output": "```sql\nSELECT revenue_time, revenue\nFROM Movie_Revenue\nWHERE movie_title = 'specific movie'\nORDER BY revenue_time;\n```", "latency_sec": 0.5216670036315918, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 101, "prompt_eval_sec": null, "tokens_completion": 29, "completion_eval_sec": null, "tokens_total": 130, "tokens_per_sec": 249.20111698651297, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL aggregates revenue using SUM() and groups by revenue_time, while the Generated SQL retrieves individual revenue records without aggregation. Additionally, the movie title in the Generated SQL ('specific movie') differs from the Reference SQL's 'Spider-Man: No Way Home'.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly calculates hourly revenue by aggregating revenue values with SUM() and grouping by revenue_time, which matches the 'hourly revenue' requirement. The Generated SQL fails to aggregate and instead returns raw revenue entries, which would not produce hourly totals. Additionally, the Generated SQL uses a placeholder 'specific movie' instead of the actual movie title. While both queries filter by movie_title, only the Reference properly addresses the business intent of summarizing revenue per hour.", "overall_assessment": "differently_correct"}}
{"example_id": 1763, "sql_complexity": "multiple_joins", "prompt": "What is the total food and beverage revenue last month for hotels in 'Bangkok'?", "context": "CREATE TABLE revenue (hotel_id INT, revenue_source VARCHAR(50), revenue INT, revenue_date DATE); INSERT INTO revenue (hotel_id, revenue_source, revenue, revenue_date) VALUES (5, 'Room revenue', 12000, '2022-03-01'), (5, 'Food and beverage', 4000, '2022-03-02'), (5, 'Other revenue', 1000, '2022-03-03'); CREATE TABLE hotels (hotel_id INT, city VARCHAR(50)); INSERT INTO hotels (hotel_id, city) VALUES (5, 'Bangkok'); CREATE TABLE dates (date DATE); INSERT INTO dates (date) VALUES ('2022-03-01'), ('2022-03-02'), ('2022-03-03');", "reference_sql": "SELECT SUM(revenue) FROM revenue JOIN hotels ON revenue.hotel_id = hotels.hotel_id JOIN dates ON revenue.revenue_date = dates.date WHERE hotels.city = 'Bangkok' AND revenue_source = 'Food and beverage' AND dates.date >= DATEADD(month, -1, GETDATE());", "generated_sql": "SELECT SUM(r.revenue) AS total_food_and_beverage_revenue\nFROM revenue r\nJOIN hotels h ON r.hotel_id = h.hotel_id\nWHERE h.city = 'Bangkok'\n  AND r.revenue_source = 'Food and beverage'\n  AND r.revenue_date >= DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1' MONTH)\n  AND r.revenue_date < DATE_TRUNC('month', CURRENT_DATE);", "raw_model_output": "```sql\nSELECT SUM(r.revenue) AS total_food_and_beverage_revenue\nFROM revenue r\nJOIN hotels h ON r.hotel_id = h.hotel_id\nWHERE h.city = 'Bangkok'\n  AND r.revenue_source = 'Food and beverage'\n  AND r.revenue_date >= DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1' MONTH)\n  AND r.revenue_date < DATE_TRUNC('month', CURRENT_DATE);\n```", "latency_sec": 1.1065573692321777, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 248, "prompt_eval_sec": null, "tokens_completion": 95, "completion_eval_sec": null, "tokens_total": 343, "tokens_per_sec": 309.97037256007985, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Reference SQL joins with the 'dates' table and filters on dates.date >= DATEADD(month, -1, GETDATE()), while the Generated SQL omits the 'dates' table join and uses DATE_TRUNC for date filtering. Second, the date range logic differs: DATEADD(month, -1, GETDATE()) (e.g., March 1, 2022 if current date is April 1, 2022) vs. DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1' MONTH) (e.g., March 1, 2022) and DATE_TRUNC('month', CURRENT_DATE) (e.g., April 1, 2022). This causes the Generated SQL to exclude dates at the start of the month (e.g., March 1, 2022) when the current date is mid-month, leading to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in date filtering logic. The reference query uses DATEADD(month, -1, GETDATE()) which calculates a date 1 month prior to current date, but this may not capture the full previous calendar month. The generated query uses DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1' MONTH) and DATE_TRUNC('month', CURRENT_DATE) to explicitly capture the entire previous month's dates (e.g., 2022-03-01 to 2022-04-01). The generated query also avoids the unnecessary JOIN with the dates table. Both correctly filter for 'Bangkok' hotels and 'Food and beverage' revenue sources, but the generated version more precisely defines the last month's timeframe and is more efficient.", "overall_assessment": "differently_correct"}}
{"example_id": 5499, "sql_complexity": "set operations", "prompt": "How many legal aid clinics and community mediation centers are there in total, and what is the sum of cases handled by each type of center, for centers located in the state of California?", "context": "CREATE TABLE LegalAidClinics (ClinicName text, State text, NumCases int); INSERT INTO LegalAidClinics VALUES ('Clinic1', 'CA', 30, '2022-01-01'), ('Clinic2', 'CA', 25, '2022-01-01'); CREATE TABLE CommunityMediationCenters (CenterName text, State text, NumCases int); INSERT INTO CommunityMediationCenters VALUES ('CM1', 'CA', 22, '2022-01-01'), ('CM2', 'CA', 28, '2022-01-01');", "reference_sql": "SELECT State, 'Legal Aid Clinics' AS CenterType, COUNT(*) AS NumCenters, SUM(NumCases) AS TotalCases FROM LegalAidClinics WHERE State = 'CA' UNION ALL SELECT State, 'Community Mediation Centers', COUNT(*), SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA';", "generated_sql": "SELECT \n    'LegalAidClinics' AS CenterType,\n    COUNT(*) AS TotalCenters,\n    SUM(NumCases) AS TotalCases\nFROM LegalAidClinics\nWHERE State = 'CA'\nUNION ALL\nSELECT \n    'CommunityMediationCenters' AS CenterType,\n    COUNT(*) AS TotalCenters,\n    SUM(NumCases) AS TotalCases\nFROM CommunityMediationCenters\nWHERE State = 'CA';", "raw_model_output": "```sql\nSELECT \n    'LegalAidClinics' AS CenterType,\n    COUNT(*) AS TotalCenters,\n    SUM(NumCases) AS TotalCases\nFROM LegalAidClinics\nWHERE State = 'CA'\nUNION ALL\nSELECT \n    'CommunityMediationCenters' AS CenterType,\n    COUNT(*) AS TotalCenters,\n    SUM(NumCases) AS TotalCases\nFROM CommunityMediationCenters\nWHERE State = 'CA';\n```", "latency_sec": 1.5062410831451416, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 226, "prompt_eval_sec": null, "tokens_completion": 93, "completion_eval_sec": null, "tokens_total": 319, "tokens_per_sec": 211.78548611481546, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their output columns. The Reference SQL includes the 'State' column in both SELECT statements, while the Generated SQL omits it. Although both queries aggregate data for 'CA' state, the absence of the 'State' column in the Generated SQL changes the result structure, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because the reference query includes a redundant 'State' column in the output (which is always 'CA' due to the WHERE clause), while the generated query omits it. Both correctly calculate counts and sums for California centers, but the generated query is more concise and avoids unnecessary data. The original question doesn't require the State in the output, only that the centers are located in California. The generated query better fulfills the business intent by focusing on the required metrics without extraneous information.", "overall_assessment": "differently_correct"}}
{"example_id": 2408, "sql_complexity": "aggregation", "prompt": "What is the average number of victories for players from Japan and South Korea, partitioned by game mode?", "context": "CREATE TABLE PlayerVictories (PlayerID INT, GameMode VARCHAR(255), Victories INT, Country VARCHAR(255)); INSERT INTO PlayerVictories (PlayerID, GameMode, Victories, Country) VALUES (1, 'Battle Royale', 25, 'Japan'), (2, 'Team Deathmatch', 18, 'South Korea');", "reference_sql": "SELECT GameMode, AVG(Victories) as AvgVictories FROM PlayerVictories WHERE Country IN ('Japan', 'South Korea') GROUP BY GameMode, Country WITH ROLLUP;", "generated_sql": "SELECT \n    GameMode,\n    Country,\n    AVG(Victories) AS AverageVictories\nFROM \n    PlayerVictories\nWHERE \n    Country IN ('Japan', 'South Korea')\nGROUP BY \n    GameMode, \n    Country;", "raw_model_output": "```sql\nSELECT \n    GameMode,\n    Country,\n    AVG(Victories) AS AverageVictories\nFROM \n    PlayerVictories\nWHERE \n    Country IN ('Japan', 'South Korea')\nGROUP BY \n    GameMode, \n    Country;\n```", "latency_sec": 0.9844508171081543, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 159, "prompt_eval_sec": null, "tokens_completion": 55, "completion_eval_sec": null, "tokens_total": 214, "tokens_per_sec": 217.3800826623616, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a WITH ROLLUP clause which adds summary rows (e.g., total averages per GameMode) and excludes Country from the output. The Generated SQL explicitly includes Country in the output and lacks ROLLUP, resulting in different result structures and content. Additionally, the SELECT clause in the Reference SQL omits Country, while the Generated SQL includes it.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query includes 'Country' in the GROUP BY clause and uses WITH ROLLUP, which adds a summary row for total averages. This produces per-country averages per game mode plus a total, which doesn't align with the original question's request for 'average number of victories for players from Japan and South Korea' partitioned by game mode. The generated query correctly groups by GameMode and Country, providing per-country averages per game mode without the extraneous ROLLUP summary. However, neither query fully addresses the intent if the goal is to calculate a single average per game mode across both countries. The generated query is more precise as it avoids the ROLLUP and focuses on the required grouping.", "overall_assessment": "differently_correct"}}
{"example_id": 2729, "sql_complexity": "subqueries", "prompt": "Find the total number of trips made by shared autonomous vehicles in Seattle", "context": "CREATE TABLE shared_vehicles (id INT, vehicle_type VARCHAR(20), is_autonomous BOOLEAN, trip_count INT); INSERT INTO shared_vehicles (id, vehicle_type, is_autonomous, trip_count) VALUES (1, 'ebike', false, 1200), (2, 'escooter', false, 800), (3, 'car', true, 1500); CREATE TABLE city_data (city VARCHAR(20), has_autonomous_vehicles BOOLEAN); INSERT INTO city_data (city, has_autonomous_vehicles) VALUES ('Seattle', true), ('Denver', false), ('Portland', true);", "reference_sql": "SELECT SUM(trip_count) FROM shared_vehicles WHERE is_autonomous = true AND vehicle_type != 'ebike' AND vehicle_type != 'escooter' AND city IN (SELECT city FROM city_data WHERE has_autonomous_vehicles = true AND city = 'Seattle');", "generated_sql": "SELECT SUM(sv.trip_count) AS total_trips\nFROM shared_vehicles sv\nJOIN city_data cd ON cd.has_autonomous_vehicles = sv.is_autonomous\nWHERE cd.city = 'Seattle' AND sv.is_autonomous = TRUE;", "raw_model_output": "SELECT SUM(sv.trip_count) AS total_trips\nFROM shared_vehicles sv\nJOIN city_data cd ON cd.has_autonomous_vehicles = sv.is_autonomous\nWHERE cd.city = 'Seattle' AND sv.is_autonomous = TRUE;", "latency_sec": 0.8793327808380127, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 208, "prompt_eval_sec": null, "tokens_completion": 51, "completion_eval_sec": null, "tokens_total": 259, "tokens_per_sec": 294.54150424503734, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references a 'city' column in the shared_vehicles table, which does not exist in the provided schema. The Generated SQL correctly joins shared_vehicles with city_data on the autonomous status and filters for Seattle. The Reference SQL is invalid due to the non-existent 'city' column, making the queries not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL contains a critical syntax error by referencing a non-existent 'city' column in the shared_vehicles table, making it invalid. The Generated SQL is syntactically correct but logically flawed. It attempts to join shared_vehicles with city_data on a boolean comparison (cd.has_autonomous_vehicles = sv.is_autonomous), which incorrectly links autonomous vehicles to cities with autonomous vehicle capabilities. However, the shared_vehicles table lacks a city column, making it impossible to determine which vehicles are in Seattle. While the Generated SQL is more efficient and avoids the syntax error, neither query correctly addresses the business intent due to schema limitations.", "overall_assessment": "incorrect"}}
{"example_id": 2952, "sql_complexity": "aggregation", "prompt": "Show the total budget allocated for each program category in 2023.", "context": "CREATE TABLE Budget (id INT, category TEXT, year INT, allocated_amount INT); INSERT INTO Budget (id, category, year, allocated_amount) VALUES (1, 'Education', 2023, 30000); INSERT INTO Budget (id, category, year, allocated_amount) VALUES (2, 'Healthcare', 2023, 50000);", "reference_sql": "SELECT category, SUM(allocated_amount) FROM Budget WHERE year = 2023 GROUP BY category;", "generated_sql": "SELECT category, SUM(allocated_amount) AS total_allocated_amount\nFROM Budget\nWHERE year = 2023\nGROUP BY category;", "raw_model_output": "```sql\nSELECT category, SUM(allocated_amount) AS total_allocated_amount\nFROM Budget\nWHERE year = 2023\nGROUP BY category;\n```", "latency_sec": 0.8269369602203369, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 154, "prompt_eval_sec": null, "tokens_completion": 33, "completion_eval_sec": null, "tokens_total": 187, "tokens_per_sec": 226.1357382673692, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (category and summed allocated_amount) from the Budget table where year is 2023, grouped by category. The only difference is the column alias (total_allocated_amount) in the generated query, which doesn't affect the semantic result set.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the total allocated budget per category for 2023 using SUM and GROUP BY. The reference query is functionally identical but lacks an explicit alias for the calculated column. The generated query improves readability by naming the aggregated column (total_allocated_amount), which better communicates the metric's meaning while maintaining technical equivalence. Both satisfy the business requirement, but the generated version is more semantically clear.", "overall_assessment": "correct"}}
{"example_id": 4328, "sql_complexity": "aggregation", "prompt": "What is the average cargo handling time in hours for each port?", "context": "CREATE TABLE cargo_handling (id INT, port_id INT, time_in_hours DECIMAL(5,2)); INSERT INTO cargo_handling (id, port_id, time_in_hours) VALUES (1, 1, 20.5), (2, 1, 22.3), (3, 2, 18.7);", "reference_sql": "SELECT port_id, AVG(time_in_hours) FROM cargo_handling GROUP BY port_id;", "generated_sql": "SELECT port_id, AVG(time_in_hours) AS average_time_in_hours\nFROM cargo_handling\nGROUP BY port_id;", "raw_model_output": "```sql\nSELECT port_id, AVG(time_in_hours) AS average_time_in_hours\nFROM cargo_handling\nGROUP BY port_id;\n```", "latency_sec": 0.6727502346038818, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 152, "prompt_eval_sec": null, "tokens_completion": 30, "completion_eval_sec": null, "tokens_total": 182, "tokens_per_sec": 270.5313066255003, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average time_in_hours per port_id. The generated query adds an alias for the aggregated column, but this does not affect the semantic result set. The GROUP BY clause and aggregation logic are identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically correct and produce identical results. The reference query omits the column alias, while the generated query explicitly names the calculated column. The generated version improves readability by clarifying the meaning of the aggregated value, which better fulfills the business intent of reporting 'average cargo handling time' explicitly. Both satisfy the requirement to group by port_id and calculate the average, but the generated query's alias makes the output more self-documenting.", "overall_assessment": "correct"}}
{"example_id": 4915, "sql_complexity": "window functions", "prompt": "Calculate the percentage of total Europium production for each country.", "context": "CREATE TABLE europium_production (country VARCHAR(50), quantity INT);", "reference_sql": "SELECT country, quantity * 100.0 / SUM(quantity) OVER (PARTITION BY NULL) AS percentage FROM europium_production;", "generated_sql": "SELECT \n    country,\n    quantity,\n    (quantity * 100.0 / SUM(quantity) OVER ()) AS percentage_of_total\nFROM europium_production;", "raw_model_output": "```sql\nSELECT \n    country,\n    quantity,\n    (quantity * 100.0 / SUM(quantity) OVER ()) AS percentage_of_total\nFROM europium_production;\n```", "latency_sec": 0.5973629951477051, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 94, "prompt_eval_sec": null, "tokens_completion": 38, "completion_eval_sec": null, "tokens_total": 132, "tokens_per_sec": 220.97117007952835, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query returns only 'country' and 'percentage', while the generated query includes an additional 'quantity' column. Although both calculate the same percentage using similar window functions, the generated query's extra column changes the result set structure.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries correctly calculate the percentage of total Europium production per country using window functions. The reference query is technically more precise as it avoids including an extra 'quantity' column (present in generated SQL) that isn't required by the question. While both produce identical percentage values, the reference query's output structure directly matches the business requirement (country + percentage) without unnecessary data. The generated query's inclusion of 'quantity' column doesn't affect correctness but reduces elegance. Both handle division correctly with 100.0, and the window function syntax is equivalent (PARTITION BY NULL = empty partition).", "overall_assessment": "differently_correct"}}
{"example_id": 5030, "sql_complexity": "subqueries", "prompt": "What is the success rate of diverse-led startups (at least 1 female or underrepresented racial or ethnic group executive) in the past 3 years?", "context": "CREATE TABLE DiverseStartups(id INT, name TEXT, country TEXT, year INT, success BOOLEAN);   INSERT INTO DiverseStartups VALUES (1, 'FemTech', 'USA', 2020, true), (2, 'GreenCity', 'Canada', 2019, false), (3, 'AI-Health', 'UK', 2021, true), (4, 'SolarEnergy', 'USA', 2020, false), (5, 'DataAnalytics', 'Germany', 2019, true), (6, 'SmartGrid', 'USA', 2021, true), (7, 'CloudServices', 'India', 2020, false), (8, 'RenewableEnergy', 'USA', 2019, true);", "reference_sql": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3) AS success_rate FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3 AND success = true;", "generated_sql": "SELECT \n    ROUND(100.0 * SUM(CASE WHEN success THEN 1 ELSE 0 END) / COUNT(*), 2) AS success_rate_percentage\nFROM DiverseStartups\nWHERE year >= (EXTRACT(YEAR FROM CURRENT_DATE) - 3 + 1);", "raw_model_output": "SELECT \n    ROUND(100.0 * SUM(CASE WHEN success THEN 1 ELSE 0 END) / COUNT(*), 2) AS success_rate_percentage\nFROM DiverseStartups\nWHERE year >= (EXTRACT(YEAR FROM CURRENT_DATE) - 3 + 1);", "latency_sec": 0.9556050300598145, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 255, "prompt_eval_sec": null, "tokens_completion": 59, "completion_eval_sec": null, "tokens_total": 314, "tokens_per_sec": 328.5876383262086, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their year filtering conditions. The Reference SQL uses `year >= YEAR(CURRENT_DATE) - 3`, while the Generated SQL uses `year >= (EXTRACT(YEAR FROM CURRENT_DATE) - 3 + 1)`. This makes the Generated SQL exclude the earliest year in the range, leading to different subsets of data. Additionally, the Generated SQL rounds the result and uses a different calculation approach, further diverging from the Reference SQL's output.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly calculates the success rate by considering all startups in the past 3 years (year >= YEAR(CURRENT_DATE) - 3), while the Generated SQL incorrectly filters to only the last 2 years (year >= EXTRACT(YEAR FROM CURRENT_DATE) - 3 + 1). This discrepancy causes the Generated SQL to exclude 2020 data (e.g., 3 successful startups in 2020) and only consider 2021 data, leading to a 100% success rate instead of the correct 60% (3/5). The Reference SQL's approach aligns with the business intent of analyzing the full 3-year window, even if the dataset lacks 2022 entries. The Generated SQL's logic for determining the time frame is flawed, making it technically incorrect for the question.", "overall_assessment": "incorrect"}}
{"example_id": 4626, "sql_complexity": "aggregation", "prompt": "What was the maximum number of training hours for farmers in each country in 2020?", "context": "CREATE TABLE training (id INT, country_id INT, farmer_id INT, hours INT, date DATE);", "reference_sql": "SELECT country_id, MAX(hours) FROM training WHERE YEAR(date) = 2020 GROUP BY country_id;", "generated_sql": "SELECT country_id, MAX(hours) AS max_hours\nFROM training\nWHERE date >= '2020-01-01' AND date <= '2020-12-31'\nGROUP BY country_id;", "raw_model_output": "```sql\nSELECT country_id, MAX(hours) AS max_hours\nFROM training\nWHERE date >= '2020-01-01' AND date <= '2020-12-31'\nGROUP BY country_id;\n```", "latency_sec": 0.900810956954956, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 106, "prompt_eval_sec": null, "tokens_completion": 46, "completion_eval_sec": null, "tokens_total": 152, "tokens_per_sec": 168.7368463121398, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter records where the date is in 2020. The reference query uses YEAR(date) = 2020, while the generated query uses date between '2020-01-01' and '2020-12-31'. Since the date column is of type DATE (no time component), both conditions capture the same set of dates. The GROUP BY and MAX(hours) logic is identical in both queries.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the maximum training hours per country for 2020. The reference query uses `YEAR(date) = 2020` which is semantically equivalent to the generated query's date range filter (`date BETWEEN '2020-01-01' AND '2020-12-31'`). However, the generated query is more efficient as it allows potential index usage on the `date` column, whereas `YEAR(date) = 2020` typically prevents index utilization. The generated query also explicitly defines the date range, making it clearer for future maintainability. Both fulfill the business intent of identifying maximum training hours per country in 2020.", "overall_assessment": "correct"}}
{"example_id": 2703, "sql_complexity": "set operations", "prompt": "Identify the species unique to 'MarineResearchAreaA' and 'MarineResearchAreaB'", "context": "CREATE TABLE ResearchAreaSpecies (area VARCHAR(255), species VARCHAR(255)); INSERT INTO ResearchAreaSpecies (area, species) VALUES ('MarineResearchAreaA', 'Coral'), ('MarineResearchAreaA', 'Starfish'), ('MarineResearchAreaB', 'Jellyfish');", "reference_sql": "(SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB') UNION (SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA');", "generated_sql": "SELECT species\nFROM ResearchAreaSpecies\nWHERE area IN ('MarineResearchAreaA', 'MarineResearchAreaB')\nGROUP BY species\nHAVING COUNT(DISTINCT area) = 1;", "raw_model_output": "```sql\nSELECT species\nFROM ResearchAreaSpecies\nWHERE area IN ('MarineResearchAreaA', 'MarineResearchAreaB')\nGROUP BY species\nHAVING COUNT(DISTINCT area) = 1;\n```", "latency_sec": 0.6199028491973877, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 143, "prompt_eval_sec": null, "tokens_completion": 44, "completion_eval_sec": null, "tokens_total": 187, "tokens_per_sec": 301.6601718190458, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve species that are present in exactly one of the two research areas (MarineResearchAreaA or MarineResearchAreaB). The Reference SQL uses EXCEPT and UNION to compute the symmetric difference between the two areas, while the Generated SQL uses GROUP BY and HAVING to filter species appearing in only one area. The result sets are identical given the sample data and schema.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify species present in one area but not the other. The Reference SQL uses two EXCEPT operations combined with UNION, while the Generated SQL uses a single GROUP BY with HAVING COUNT(DISTINCT area) = 1. The Generated SQL is more efficient as it avoids multiple subqueries and leverages aggregation, achieving the same result with simpler logic. Both fulfill the business intent of finding area-specific species.", "overall_assessment": "correct"}}
{"example_id": 200, "sql_complexity": "window functions", "prompt": "List the top three categories of workforce development programs with the highest budget increases.", "context": "CREATE TABLE programs (program_id INT, program_name VARCHAR(50), budget DECIMAL(10, 2), category VARCHAR(50), budget_date DATE);", "reference_sql": "SELECT category, SUM(budget - LAG(budget) OVER (PARTITION BY category ORDER BY budget_date)) as total_budget_increase FROM programs GROUP BY category ORDER BY total_budget_increase DESC LIMIT 3;", "generated_sql": "SELECT\n        category,\n        MIN(budget) AS min_budget,\n        MAX(budget) AS max_budget,\n        MAX(budget) - MIN(budget) AS budget_increase\n    FROM programs\n    WHERE category LIKE '%workforce development%'\n    GROUP BY category\n)\nSELECT category\nFROM category_budgets\nORDER BY budget_increase DESC\nLIMIT 3;", "raw_model_output": "WITH category_budgets AS (\n    SELECT\n        category,\n        MIN(budget) AS min_budget,\n        MAX(budget) AS max_budget,\n        MAX(budget) - MIN(budget) AS budget_increase\n    FROM programs\n    WHERE category LIKE '%workforce development%'\n    GROUP BY category\n)\nSELECT category\nFROM category_budgets\nORDER BY budget_increase DESC\nLIMIT 3;", "latency_sec": 0.9157321453094482, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 114, "prompt_eval_sec": null, "tokens_completion": 86, "completion_eval_sec": null, "tokens_total": 200, "tokens_per_sec": 218.40447670690332, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates the total budget increase by summing consecutive budget differences within each category using LAG(), while the generated query computes the difference between max and min budgets for categories matching '%workforce development%'. They differ in calculation logic (sum of sequential changes vs. total range), filtering (reference has no filter), and output columns (reference includes a calculated total, generated includes min/max values).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL has critical logical flaws: it doesn't filter for 'workforce development' categories (missing WHERE clause), and the LAG-based calculation incorrectly sums consecutive budget differences instead of capturing total increase. The Generated SQL has a syntax error (missing WITH keyword and misplaced parenthesis) and uses MIN/MAX to calculate budget increase, which would only work if programs have a single budget entry per category. Neither query correctly addresses the question, but the Reference SQL at least attempts to calculate total budget increases across time, while the Generated SQL's approach is fundamentally flawed for multi-period analysis.", "overall_assessment": "incorrect"}}
{"example_id": 5131, "sql_complexity": "basic SQL", "prompt": "How many wells were drilled in the Eagle Ford Shale and Bakken Formation?", "context": "CREATE TABLE wells (id INT, region VARCHAR(255), well_type VARCHAR(255), num_drilled INT); INSERT INTO wells (id, region, well_type, num_drilled) VALUES (1, 'Eagle Ford Shale', 'Oil', 2000), (2, 'Eagle Ford Shale', 'Gas', 1500), (3, 'Bakken Formation', 'Oil', 1000), (4, 'Bakken Formation', 'Gas', 1200);", "reference_sql": "SELECT SUM(num_drilled) as total_wells FROM wells WHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "generated_sql": "SELECT SUM(num_drilled) AS total_wells_drilled\nFROM wells\nWHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "raw_model_output": "SELECT SUM(num_drilled) AS total_wells_drilled\nFROM wells\nWHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "latency_sec": 7.722986936569214, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 186, "prompt_eval_sec": null, "tokens_completion": 32, "completion_eval_sec": null, "tokens_total": 218, "tokens_per_sec": 28.22742052919259, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of num_drilled for wells in the 'Eagle Ford Shale' and 'Bakken Formation' regions. The only differences are the column alias name (total_wells vs. total_wells_drilled) and formatting, which do not affect the semantic result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically identical in structure and logic, with the only difference being the alias name ('total_wells' vs 'total_wells_drilled'). The WHERE clause correctly filters for the specified regions, and the SUM function accurately aggregates the 'num_drilled' values. Both queries fulfill the business intent of counting total wells drilled in the Eagle Ford Shale and Bakken Formation. The generated SQL's alias is slightly more descriptive but does not alter the result. Since the core logic and output are identical, neither query is objectively superior.", "overall_assessment": "equal"}}
{"example_id": 1160, "sql_complexity": "subqueries", "prompt": "What is the total revenue generated from ads on Instagram in March 2021, for users in the 'brand' category who have posted more than 10 times?", "context": "CREATE TABLE ads (ad_id INT, user_id INT, platform VARCHAR(255), ad_revenue DECIMAL(10,2), post_count INT); INSERT INTO ads (ad_id, user_id, platform, ad_revenue, post_count) VALUES (1, 1, 'Instagram', 150.50, 12), (2, 2, 'Twitter', 80.00, 15), (3, 3, 'Instagram', 120.75, 8);", "reference_sql": "SELECT SUM(ad_revenue) FROM ads WHERE platform = 'Instagram' AND MONTH(ad_date) = 3 AND YEAR(ad_date) = 2021 AND user_id IN (SELECT user_id FROM users WHERE category = 'brand' AND post_count > 10);", "generated_sql": "-- The provided schema does not include any information about user categories or dates,\n-- so it is not possible to filter by 'brand' category or by March 2021.\n-- Based on the available data, we can only sum ad_revenue for Instagram ads with post_count > 10.\n\nSELECT SUM(ad_revenue) AS total_revenue\nFROM ads\nWHERE platform = 'Instagram'\n  AND post_count > 10;", "raw_model_output": "```sql\n-- The provided schema does not include any information about user categories or dates,\n-- so it is not possible to filter by 'brand' category or by March 2021.\n-- Based on the available data, we can only sum ad_revenue for Instagram ads with post_count > 10.\n\nSELECT SUM(ad_revenue) AS total_revenue\nFROM ads\nWHERE platform = 'Instagram'\n  AND post_count > 10;\n```", "latency_sec": 1.1059479713439941, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 202, "prompt_eval_sec": null, "tokens_completion": 92, "completion_eval_sec": null, "tokens_total": 294, "tokens_per_sec": 265.8352902828864, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL includes conditions for ad_date (March 2021) and a subquery filtering user_id based on users.category and post_count > 10, which are not present in the Generated SQL. The Generated SQL omits these filters, resulting in a different query logic and potential output.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries are not technically equivalent. The Reference SQL assumes the existence of a 'users' table and 'ad_date' column (not in the provided schema) to filter by category and date, which are critical for the original question. The Generated SQL correctly acknowledges these missing elements but instead focuses on available fields (platform and post_count). While neither query fully satisfies the original intent due to schema limitations, the Generated SQL is technically accurate given the provided schema. The Reference SQL contains invalid references to non-existent schema elements, making it incorrect. The Generated SQL, though incomplete, better aligns with the actual data structure.", "overall_assessment": "differently_correct"}}
{"example_id": 4708, "sql_complexity": "subqueries", "prompt": "What is the maximum number of high-level threats reported by a single agency in a month?", "context": "CREATE TABLE Threat_Intelligence (Threat_ID INT, Threat_Type VARCHAR(50), Threat_Level VARCHAR(50), Reported_Date DATE, Reporting_Agency VARCHAR(50)); CREATE VIEW High_Level_Threats AS SELECT Threat_Type, Threat_Level, Reported_Date FROM Threat_Intelligence WHERE Threat_Level = 'High';", "reference_sql": "SELECT Reporting_Agency, MAX(Number_of_High_Level_Threats) as Max_High_Level_Threats_in_a_Month FROM (SELECT Reporting_Agency, TO_CHAR(Reported_Date, 'YYYY-MM') as Month, COUNT(*) as Number_of_High_Level_Threats FROM High_Level_Threats GROUP BY Reporting_Agency, Month) GROUP BY Reporting_Agency;", "generated_sql": "SELECT MAX(Threat_Count) AS Max_High_Level_Threats_Per_Month\nFROM (\n    SELECT Reporting_Agency, DATE_TRUNC('month', Reported_Date) AS Month, COUNT(*) AS Threat_Count\n    FROM Threat_Intelligence\n    WHERE Threat_Level = 'High'\n    GROUP BY Reporting_Agency, DATE_TRUNC('month', Reported_Date)\n) AS Monthly_Agency_Threats;", "raw_model_output": "```sql\nSELECT MAX(Threat_Count) AS Max_High_Level_Threats_Per_Month\nFROM (\n    SELECT Reporting_Agency, DATE_TRUNC('month', Reported_Date) AS Month, COUNT(*) AS Threat_Count\n    FROM Threat_Intelligence\n    WHERE Threat_Level = 'High'\n    GROUP BY Reporting_Agency, DATE_TRUNC('month', Reported_Date)\n) AS Monthly_Agency_Threats;\n```", "latency_sec": 1.0501558780670166, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 148, "prompt_eval_sec": null, "tokens_completion": 90, "completion_eval_sec": null, "tokens_total": 238, "tokens_per_sec": 226.63302179299123, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their output structure and aggregation logic. The Reference SQL groups by Reporting_Agency and calculates the maximum number of high threats per month for each agency, returning multiple rows. The Generated SQL calculates the overall maximum threat count across all agencies and months in a single row, omitting the Reporting_Agency column. Additionally, the Reference SQL uses TO_CHAR('YYYY-MM') while the Generated SQL uses DATE_TRUNC('month'), which may handle date formatting differently.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL calculates the maximum number of high threats per agency (not across all agencies) and returns per-agency results. The Generated SQL correctly computes the maximum threat count across all agencies and months. The original question requires identifying the single highest value (across all agencies/months), which the Generated SQL achieves. The Reference SQL's structure groups by agency and returns per-agency maxima, which does not answer the question as intended. Both queries are technically valid but differ in business intent fulfillment.", "overall_assessment": "differently_correct"}}
{"example_id": 5608, "sql_complexity": "set operations", "prompt": "List the suppliers that provide materials for both product A and product C.", "context": "CREATE TABLE products (product_id INT, product_name TEXT); CREATE TABLE materials (material_id INT, material_name TEXT, product_id INT, supplier_id INT); INSERT INTO products (product_id, product_name) VALUES (1, 'Product A'), (2, 'Product B'), (3, 'Product C'); INSERT INTO materials (material_id, material_name, product_id, supplier_id) VALUES (1, 'Material 1', 1, 101), (2, 'Material 2', 1, 102), (3, 'Material 3', 2, 103), (4, 'Material 4', 3, 101), (5, 'Material 5', 3, 102);", "reference_sql": "SELECT supplier_id FROM materials WHERE product_id = 1 INTERSECT SELECT supplier_id FROM materials WHERE product_id = 3;", "generated_sql": "SELECT supplier_id\nFROM materials\nWHERE product_id IN (\n    SELECT product_id FROM products WHERE product_name IN ('Product A', 'Product C')\n)\nGROUP BY supplier_id\nHAVING COUNT(DISTINCT product_id) = 2;", "raw_model_output": "SELECT supplier_id\nFROM materials\nWHERE product_id IN (\n    SELECT product_id FROM products WHERE product_name IN ('Product A', 'Product C')\n)\nGROUP BY supplier_id\nHAVING COUNT(DISTINCT product_id) = 2;", "latency_sec": 0.7068228721618652, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 232, "prompt_eval_sec": null, "tokens_completion": 50, "completion_eval_sec": null, "tokens_total": 282, "tokens_per_sec": 398.96841359630037, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries identify supplier_ids that have materials for both product_id 1 (Product A) and product_id 3 (Product C). The Reference SQL uses INTERSECT to find common supplier_ids between the two product_id conditions, while the Generated SQL filters materials for products 1 and 3, then groups by supplier_id to ensure they have both product_ids (COUNT(DISTINCT product_id) = 2). Both approaches yield the same result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly identify suppliers providing materials for both Product A and Product C. The reference query uses INTERSECT to find common supplier_ids between product_id=1 (Product A) and product_id=3 (Product C). The generated query dynamically retrieves product_ids via the products table using product names, then groups suppliers with COUNT(DISTINCT product_id) = 2 to ensure they serve both products. While the approaches differ in implementation, they produce identical results. The reference is more concise, while the generated query is more adaptable to schema changes (e.g., if product_id values for A/C change). Both are semantically equivalent and fulfill the business intent.", "overall_assessment": "correct"}}
{"example_id": 1506, "sql_complexity": "basic SQL", "prompt": "How many habitats are in the 'animal_habitats' table?", "context": "CREATE TABLE animal_habitats (id INT PRIMARY KEY, habitat_name VARCHAR, num_animals INT);", "reference_sql": "SELECT COUNT(*) FROM animal_habitats;", "generated_sql": "SELECT COUNT(*) AS num_habitats FROM animal_habitats;", "raw_model_output": "```sql\nSELECT COUNT(*) AS num_habitats FROM animal_habitats;\n```", "latency_sec": 8.064097166061401, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 102, "prompt_eval_sec": null, "tokens_completion": 19, "completion_eval_sec": null, "tokens_total": 121, "tokens_per_sec": 15.00477951942856, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries count the number of rows in the animal_habitats table. The generated query adds an alias (num_habitats) to the COUNT(*) result, but this does not change the actual value returned. The semantic result (a single numeric value representing the row count) remains identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly count the number of rows in the 'animal_habitats' table. The reference query returns the count as an anonymous column, while the generated query explicitly names the result column 'num_habitats'. Since the original question only asks for the count value (not the column name), both produce identical results. The generated query adds clarity through naming but neither is technically superior for this specific question.", "overall_assessment": "correct"}}
{"example_id": 3117, "sql_complexity": "aggregation", "prompt": "What is the percentage of the population that has access to clean water in each continent?", "context": "CREATE TABLE water_data (id INT, country VARCHAR(50), continent CHAR(2), access_to_clean_water BOOLEAN); INSERT INTO water_data VALUES (1, 'Canada', 'NA', true), (2, 'Mexico', 'NA', false), (3, 'Brazil', 'SA', true), (4, 'Russia', 'EU', true);", "reference_sql": "SELECT continent, COUNT(*) FILTER (WHERE access_to_clean_water) * 100.0 / COUNT(*) AS percentage FROM water_data GROUP BY continent;", "generated_sql": "SELECT \n    continent,\n    100.0 * AVG(CASE WHEN access_to_clean_water THEN 1 ELSE 0 END) AS percentage_with_access\nFROM \n    water_data\nGROUP BY \n    continent;", "raw_model_output": "```sql\nSELECT \n    continent,\n    100.0 * AVG(CASE WHEN access_to_clean_water THEN 1 ELSE 0 END) AS percentage_with_access\nFROM \n    water_data\nGROUP BY \n    continent;\n```", "latency_sec": 0.7069618701934814, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 157, "prompt_eval_sec": null, "tokens_completion": 49, "completion_eval_sec": null, "tokens_total": 206, "tokens_per_sec": 291.387709415816, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the percentage of countries with access to clean water per continent. The Reference SQL uses COUNT(*) FILTER to count true values and divides by total count, while the Generated SQL uses AVG(CASE WHEN ... THEN 1 ELSE 0 END) which achieves the same result. Both methods compute (count of true / total count) * 100.0, resulting in identical percentages.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries calculate the percentage of population with access to clean water per continent. The reference query uses COUNT(*) FILTER (WHERE access_to_clean_water) which directly counts true values, while the generated query uses AVG(CASE WHEN ... THEN 1 ELSE 0 END) which calculates the same proportion. Mathematically equivalent, but the reference query is more concise and directly expresses the intent. Both handle NULLs identically since the schema specifies BOOLEAN type. The reference query is more readable and efficient for this specific use case.", "overall_assessment": "correct"}}
{"example_id": 3542, "sql_complexity": "window functions", "prompt": "What is the average yield of crops for each country, ranked by average yield?", "context": "CREATE TABLE farming (id INT, name TEXT, country TEXT, crop TEXT, yield INT); INSERT INTO farming VALUES (1, 'Smith Farm', 'USA', 'Corn', 120), (2, 'Brown Farm', 'Canada', 'Soybeans', 45), (3, 'Jones Farm', 'Mexico', 'Wheat', 80);", "reference_sql": "SELECT country, AVG(yield) as avg_yield, ROW_NUMBER() OVER (ORDER BY AVG(yield) DESC) as rank FROM farming GROUP BY country;", "generated_sql": "SELECT country, AVG(yield) AS average_yield\nFROM farming\nGROUP BY country\nORDER BY average_yield DESC;", "raw_model_output": "```sql\nSELECT country, AVG(yield) AS average_yield\nFROM farming\nGROUP BY country\nORDER BY average_yield DESC;\n```", "latency_sec": 0.679157018661499, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 156, "prompt_eval_sec": null, "tokens_completion": 31, "completion_eval_sec": null, "tokens_total": 187, "tokens_per_sec": 275.34133471600524, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a ROW_NUMBER() column that ranks countries by average yield, while the Generated SQL only returns country and average_yield without the rank. The Generated SQL also lacks the explicit ORDER BY clause present in the Reference SQL, though both would order results by average yield descending. The presence of the rank column in the Reference SQL makes the result sets structurally different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The Reference SQL correctly addresses the ranking requirement by using ROW_NUMBER() to assign numerical ranks based on average yield, while the Generated SQL only orders results without explicit ranking. Both are technically correct, but the Reference explicitly fulfills the 'ranked by average yield' requirement. The Generated SQL lacks the ranking mechanism, making it incomplete for the business intent. The Reference query is more elegant in combining aggregation and ranking in a single query, whereas the Generated query requires additional processing for ranking.", "overall_assessment": "differently_correct"}}
{"example_id": 2274, "sql_complexity": "subqueries", "prompt": "Add a new crop 'amaranth' to farm 'Nourishing Harvest' with yield 50 in 2023", "context": "CREATE TABLE farms (id INT, name TEXT, location TEXT, size FLOAT); INSERT INTO farms (id, name, location, size) VALUES (1, 'Nourishing Harvest', 'Mexico', 120.0); CREATE TABLE crops (id INT, farm_id INT, crop TEXT, yield INT, year INT);", "reference_sql": "INSERT INTO crops (id, farm_id, crop, yield, year) VALUES (5, (SELECT id FROM farms WHERE name = 'Nourishing Harvest'), 'amaranth', 50, 2023);", "generated_sql": "INSERT INTO crops (farm_id, crop, yield, year)\nSELECT id, 'amaranth', 50, 2023\nFROM farms\nWHERE name = 'Nourishing Harvest';", "raw_model_output": "INSERT INTO crops (farm_id, crop, yield, year)\nSELECT id, 'amaranth', 50, 2023\nFROM farms\nWHERE name = 'Nourishing Harvest';", "latency_sec": 0.7075128555297852, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 159, "prompt_eval_sec": null, "tokens_completion": 41, "completion_eval_sec": null, "tokens_total": 200, "tokens_per_sec": 282.68037596326093, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL explicitly sets the 'id' column to 5, while the Generated SQL omits the 'id' column entirely. The Generated SQL also uses a SELECT statement that could insert multiple rows if multiple farms had the same name (though the sample data suggests uniqueness). Additionally, the Generated SQL does not guarantee the same 'id' value as the Reference SQL.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "While both queries achieve the goal of adding 'amaranth' to the farm, they differ in implementation. The reference query hardcodes the id=5 and uses a subquery for farm_id, which could fail if the farm's id isn't 5. The generated query dynamically retrieves the farm_id through a SELECT, making it more reliable. The generated version better fulfills the business intent by avoiding hardcoded values and ensuring correct farm association regardless of the actual farm ID. Both are technically correct, but the generated query is more elegant and maintainable.", "overall_assessment": "differently_correct"}}
{"example_id": 3705, "sql_complexity": "subqueries", "prompt": "What is the percentage of unions with collective bargaining agreements in the Midwest region?", "context": "CREATE TABLE collective_bargaining (bargaining_id INT, union_name VARCHAR(50), contract_start_date DATE, contract_end_date DATE, region VARCHAR(50));CREATE VIEW union_region AS SELECT DISTINCT union_name, region FROM collective_bargaining;", "reference_sql": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM union_region) as percentage FROM union_region ur WHERE ur.region = 'Midwest' AND EXISTS (SELECT 1 FROM collective_bargaining cb WHERE cb.union_name = ur.union_name);", "generated_sql": "SELECT COUNT(DISTINCT union_name) AS total_count\n    FROM collective_bargaining\n),\nmidwest_unions AS (\n    SELECT COUNT(DISTINCT union_name) AS midwest_count\n    FROM collective_bargaining\n    WHERE region = 'Midwest'\n)\nSELECT \n    CASE \n        WHEN total_count = 0 THEN 0\n        ELSE (midwest_count * 100.0 / total_count)\n    END AS percentage_midwest_unions\nFROM total_unions, midwest_unions;", "raw_model_output": "WITH total_unions AS (\n    SELECT COUNT(DISTINCT union_name) AS total_count\n    FROM collective_bargaining\n),\nmidwest_unions AS (\n    SELECT COUNT(DISTINCT union_name) AS midwest_count\n    FROM collective_bargaining\n    WHERE region = 'Midwest'\n)\nSELECT \n    CASE \n        WHEN total_count = 0 THEN 0\n        ELSE (midwest_count * 100.0 / total_count)\n    END AS percentage_midwest_unions\nFROM total_unions, midwest_unions;", "latency_sec": 9.539212703704834, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 133, "prompt_eval_sec": null, "tokens_completion": 114, "completion_eval_sec": null, "tokens_total": 247, "tokens_per_sec": 25.893122176012522, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their calculation logic. The reference query counts (union_name, region) pairs from the union_region view, while the generated query counts distinct union_names directly from collective_bargaining. The denominator in the reference is total (union_name, region) pairs, whereas the generated uses total distinct union_names. Additionally, the reference includes an EXISTS clause that is redundant but doesn't affect the result, while the generated query uses COUNT(DISTINCT) which changes the semantics.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL is technically correct and semantically equivalent to the business question. It uses the union_region view (which ensures distinct unions) and properly filters for Midwest unions with active agreements via EXISTS. The Generated SQL has a critical syntax error: it lacks the 'WITH' keyword for CTEs and improperly formats the query structure, making it invalid. Even if fixed, the Generated SQL's approach (counting distinct unions in collective_bargaining directly) would technically work but is less elegant and lacks the explicit validation of agreements present in the Reference SQL. The Reference SQL also avoids redundant calculations by leveraging the pre-defined union_region view.", "overall_assessment": "incorrect"}}
{"example_id": 240, "sql_complexity": "aggregation", "prompt": "What is the average capacity of renewable energy projects for each country?", "context": "CREATE TABLE projects (name TEXT, type TEXT, capacity INTEGER, country TEXT); INSERT INTO projects (name, type, capacity, country) VALUES ('Project 1', 'Wind', 100, 'USA'), ('Project 2', 'Solar', 200, 'Germany'), ('Project 3', 'Wind', 300, 'France');", "reference_sql": "SELECT country, AVG(capacity) FROM projects GROUP BY country", "generated_sql": "SELECT country, AVG(capacity) AS average_capacity\nFROM projects\nGROUP BY country;", "raw_model_output": "```sql\nSELECT country, AVG(capacity) AS average_capacity\nFROM projects\nGROUP BY country;\n```", "latency_sec": 0.8182830810546875, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 151, "prompt_eval_sec": null, "tokens_completion": 23, "completion_eval_sec": null, "tokens_total": 174, "tokens_per_sec": 212.64034907788988, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries perform the same grouping and aggregation operations. The generated query adds an explicit alias (average_capacity) for the calculated column, but this does not affect the semantic result set. The GROUP BY clause and aggregate function remain identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically correct and produce identical results. The reference query omits the column alias, while the generated query explicitly names the calculated column 'average_capacity'. The generated version improves readability by clarifying the meaning of the aggregated value, which better supports business understanding without altering the computational logic. Both address the original question of calculating average capacity per country, but the generated query's explicit alias enhances clarity.", "overall_assessment": "correct"}}
{"example_id": 2132, "sql_complexity": "set operations", "prompt": "What is the average caseload per attorney in community legal clinics in California, and how does it compare to the state average?", "context": "CREATE TABLE cali_community_legal_clinics(id INT, attorney_count INT, cases_handled INT, state VARCHAR(255));", "reference_sql": "SELECT state, AVG(cases_handled/attorney_count) AS avg_caseload FROM cali_community_legal_clinics WHERE state = 'California' GROUP BY state UNION ALL SELECT 'California', AVG(cases_handled/attorney_count) FROM cali_community_legal_clinics WHERE state = 'California';", "generated_sql": "SELECT \n    AVG(cases_handled * 1.0 / attorney_count) AS avg_caseload_per_attorney,\n    'California' AS location\nFROM cali_community_legal_clinics\nWHERE state = 'California'\n\nUNION ALL\n\nSELECT \n    AVG(cases_handled * 1.0 / attorney_count) AS avg_caseload_per_attorney,\n    'State Average' AS location\nFROM cali_community_legal_clinics;", "raw_model_output": "```sql\nSELECT \n    AVG(cases_handled * 1.0 / attorney_count) AS avg_caseload_per_attorney,\n    'California' AS location\nFROM cali_community_legal_clinics\nWHERE state = 'California'\n\nUNION ALL\n\nSELECT \n    AVG(cases_handled * 1.0 / attorney_count) AS avg_caseload_per_attorney,\n    'State Average' AS location\nFROM cali_community_legal_clinics;\n```", "latency_sec": 0.9940199851989746, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 120, "prompt_eval_sec": null, "tokens_completion": 104, "completion_eval_sec": null, "tokens_total": 224, "tokens_per_sec": 225.3475818749877, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the average caseload for California twice (once grouped by state and once as a standalone value), while the Generated SQL computes the average for California in the first query and a non-California 'State Average' in the second. The second part of the Generated SQL lacks the WHERE state = 'California' filter, leading to different results. Additionally, column aliases and output structure differ.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query is technically flawed. The first SELECT calculates the average caseload for California clinics, but the second UNION ALL subquery redundantly recalculates the same value for California without providing the actual state average. The generated query correctly computes two distinct metrics: (1) the average caseload for California clinics and (2) the state average (assuming the table contains all California clinics, as implied by the table name). The generated query also uses explicit 'location' labels ('California' and 'State Average') for clarity, while the reference query's second subquery incorrectly repeats the same value without meaningful comparison. The generated query better addresses the business intent of comparing California clinics to the broader state average.", "overall_assessment": "differently_correct"}}
{"example_id": 3276, "sql_complexity": "basic SQL", "prompt": "What is the total energy consumption of the Chemical Plant B in the last quarter?", "context": "CREATE TABLE EnergyConsumption (EnergyID INT, Plant VARCHAR(255), EnergyQuantity DECIMAL(5,2), Timestamp DATETIME);", "reference_sql": "SELECT SUM(EnergyQuantity) FROM EnergyConsumption WHERE Plant = 'Chemical Plant B' AND Timestamp BETWEEN DATE_SUB(CURRENT_DATE(), INTERVAL 3 MONTH) AND CURRENT_DATE();", "generated_sql": "SELECT SUM(EnergyQuantity) AS TotalEnergyConsumption\nFROM EnergyConsumption\nWHERE Plant = 'Chemical Plant B'\n  AND Timestamp >= DATEADD(QUARTER, DATEDIFF(QUARTER, 0, GETDATE()) - 1, 0)\n  AND Timestamp < DATEADD(QUARTER, DATEDIFF(QUARTER, 0, GETDATE()), 0);", "raw_model_output": "```sql\nSELECT SUM(EnergyQuantity) AS TotalEnergyConsumption\nFROM EnergyConsumption\nWHERE Plant = 'Chemical Plant B'\n  AND Timestamp >= DATEADD(QUARTER, DATEDIFF(QUARTER, 0, GETDATE()) - 1, 0)\n  AND Timestamp < DATEADD(QUARTER, DATEDIFF(QUARTER, 0, GETDATE()), 0);\n```", "latency_sec": 1.1426770687103271, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 110, "prompt_eval_sec": null, "tokens_completion": 88, "completion_eval_sec": null, "tokens_total": 198, "tokens_per_sec": 173.27730241709588, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their date range calculations. The reference query uses a fixed 3-month window from exactly three months ago to today (CURRENT_DATE()). The generated query uses quarter-based calculations (DATEADD/DATEDIFF) which may not align with a 3-month period. For example, if today is April 5th, the generated query captures data from the start of the previous quarter (January 1st) to the start of the current quarter (April 1st), whereas the reference query captures data from January 5th to April 5th. This results in different date ranges and potentially different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in date calculation logic. The reference uses a 3-month window (DATE_SUB/CURRENT_DATE), while the generated uses QUARTER-based calculations (DATEADD/DATEDIFF). The generated query more accurately captures the 'last quarter' as a calendar quarter (e.g., Q3 if current date is in Q4), whereas the reference captures a rolling 3-month period. This makes the generated query more precise for the business intent of 'last quarter'. However, the generated query uses SQL Server syntax (GETDATE(), DATEADD) while the reference uses MySQL syntax (CURRENT_DATE, DATE_SUB), which could affect technical equivalence depending on the DBMS. Despite this, the generated query better fulfills the business requirement of measuring a full calendar quarter.", "overall_assessment": "differently_correct"}}
{"example_id": 3074, "sql_complexity": "multiple_joins", "prompt": "Find the top 5 players with the highest scores in the 'historical_tournaments' view, including their scores and the names of the tournaments they participated in.", "context": "CREATE VIEW historical_tournaments AS SELECT tournaments.tournament_name, players.player_name, players.score FROM tournaments JOIN players_scores ON tournaments.tournament_id = players_scores.tournament_id JOIN players ON players_scores.player_id = players.player_id;  CREATE TABLE tournaments (tournament_id INT, tournament_name TEXT);  CREATE TABLE players_scores (player_id INT, tournament_id INT, score INT);  CREATE TABLE players (player_id INT, player_name TEXT);", "reference_sql": "SELECT players.player_name, MAX(players_scores.score) as high_score, tournaments.tournament_name FROM historical_tournaments JOIN players ON historical_tournaments.player_id = players.player_id JOIN players_scores ON historical_tournaments.player_id = players_scores.player_id JOIN tournaments ON players_scores.tournament_id = tournaments.tournament_id GROUP BY players.player_id, tournaments.tournament_name ORDER BY high_score DESC LIMIT 5;", "generated_sql": "SELECT player_name, score, tournament_name\nFROM historical_tournaments\nORDER BY score DESC\nLIMIT 5;", "raw_model_output": "SELECT player_name, score, tournament_name\nFROM historical_tournaments\nORDER BY score DESC\nLIMIT 5;", "latency_sec": 0.7551147937774658, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 190, "prompt_eval_sec": null, "tokens_completion": 24, "completion_eval_sec": null, "tokens_total": 214, "tokens_per_sec": 283.4006190362976, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL includes redundant joins and groups by player_id and tournament_name while taking MAX(score), which would aggregate rows. However, the historical_tournaments view does not contain player_id, making the Reference SQL invalid. The Generated SQL simply selects all rows from the view and orders them by score, which would return more rows if multiple entries exist per player-tournament combination. Additionally, the Reference SQL's structure introduces errors due to missing columns.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL contains redundant joins and incorrect aggregation logic. It joins the historical_tournaments view with players, players_scores, and tournaments again, which are already included in the view. The MAX(score) is unnecessary since the view already contains per-tournament scores, and grouping by player_id and tournament_name would split players into multiple rows per tournament. The Generated SQL directly selects from the view, orders by score, and limits to 5 rows, which aligns with the business intent of finding the top 5 highest scores (assuming the question refers to individual scores rather than per-player maxima). While the Generated SQL might return multiple entries per player, the original question's ambiguity about 'players' vs 'scores' makes it the more straightforward and technically correct solution.", "overall_assessment": "differently_correct"}}
{"example_id": 2219, "sql_complexity": "window functions", "prompt": "What is the average population of cities with a UNESCO World Heritage designation, ordered by designation date?", "context": "CREATE TABLE cities (name VARCHAR(255), population INT, designation_date DATE); INSERT INTO cities (name, population, designation_date) VALUES ('Paris', 2141000, '1991-09-16'); INSERT INTO cities (name, population, designation_date) VALUES ('Rio de Janeiro', 6727000, '2012-07-01');", "reference_sql": "SELECT AVG(population) FROM (SELECT population, ROW_NUMBER() OVER (ORDER BY designation_date) rn FROM cities WHERE name IN (SELECT name FROM heritagesites)) t WHERE rn % 2 = 1;", "generated_sql": "SELECT AVG(population) AS average_population\nFROM cities\nWHERE designation_date IS NOT NULL\nORDER BY designation_date;", "raw_model_output": "```sql\nSELECT AVG(population) AS average_population\nFROM cities\nWHERE designation_date IS NOT NULL\nORDER BY designation_date;\n```", "latency_sec": 1.284783124923706, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 160, "prompt_eval_sec": null, "tokens_completion": 29, "completion_eval_sec": null, "tokens_total": 189, "tokens_per_sec": 147.10653987708886, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates the average of populations from cities in heritagesites, ordered by designation_date, and averages only odd-numbered rows. The generated query calculates the average population of cities with non-null designation dates, without filtering by heritagesites or using row numbering. The generated query's ORDER BY has no effect on the AVG result.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference SQL is invalid due to referencing a non-existent 'heritagesites' table, making it technically incorrect. The generated SQL correctly filters cities with non-null designation dates (assuming designation_date indicates UNESCO status) but fails to explicitly address the 'ordered by designation date' requirement. However, the generated query's ORDER BY clause (though redundant for AVG) aligns with the business intent of ordering, while the reference query's logic (ROW_NUMBER() and rn%2=1) is unrelated to the question. The generated query better fulfills the intent despite minor inefficiencies.", "overall_assessment": "differently_correct"}}
{"example_id": 3786, "sql_complexity": "aggregation", "prompt": "Display the names and average co-owner percentages for all properties in the 'property_coownership' table where the co-owner percentage is greater than 60.", "context": "CREATE TABLE property_coownership (property_id INT, owner VARCHAR(255), percentage INT); INSERT INTO property_coownership (property_id, owner, percentage) VALUES (1, 'Mohammed', 70), (1, 'Fatima', 30), (2, 'Jamal', 65), (2, 'Aisha', 35), (3, 'Ali', 75), (3, 'Khadija', 25);", "reference_sql": "SELECT owner, AVG(percentage) FROM property_coownership WHERE percentage > 60 GROUP BY owner;", "generated_sql": "SELECT owner, AVG(percentage) AS average_percentage\nFROM property_coownership\nWHERE percentage > 60\nGROUP BY owner;", "raw_model_output": "```sql\nSELECT owner, AVG(percentage) AS average_percentage\nFROM property_coownership\nWHERE percentage > 60\nGROUP BY owner;\n```", "latency_sec": 0.5721111297607422, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 189, "prompt_eval_sec": null, "tokens_completion": 31, "completion_eval_sec": null, "tokens_total": 220, "tokens_per_sec": 384.5406749769129, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (owner and AVG(percentage)), apply the same WHERE condition (percentage > 60), and group by the same column (owner). The only difference is that the generated query adds an explicit alias (average_percentage) for the calculated column, which does not affect the semantic result set.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically equivalent as they produce identical results: grouping by 'owner', filtering percentages > 60, and calculating average percentages. The generated query improves upon the reference by adding an explicit column alias ('average_percentage'), which makes the output more readable and semantically clear. While the reference query would return 'AVG(percentage)' as the column name, the generated version aligns better with the business requirement to 'display average co-owner percentages' by using a descriptive alias. Both fulfill the intent, but the generated query is more elegant and user-friendly.", "overall_assessment": "correct"}}
{"example_id": 2357, "sql_complexity": "basic SQL", "prompt": "What is the total amount of climate finance invested in renewable energy projects by public and private sectors in Africa?", "context": "CREATE TABLE renewable_energy_projects (project_id INT, sector TEXT, investor_type TEXT, region TEXT, amount FLOAT); INSERT INTO renewable_energy_projects (project_id, sector, investor_type, region, amount) VALUES (1, 'Renewable Energy', 'Public', 'Africa', 5000000); INSERT INTO renewable_energy_projects (project_id, sector, investor_type, region, amount) VALUES (2, 'Renewable Energy', 'Private', 'Africa', 7000000);", "reference_sql": "SELECT SUM(amount) FROM renewable_energy_projects WHERE sector = 'Renewable Energy' AND region = 'Africa';", "generated_sql": "SELECT SUM(amount) AS total_amount\nFROM renewable_energy_projects\nWHERE sector = 'Renewable Energy'\n  AND investor_type IN ('Public', 'Private')\n  AND region = 'Africa';", "raw_model_output": "SELECT SUM(amount) AS total_amount\nFROM renewable_energy_projects\nWHERE sector = 'Renewable Energy'\n  AND investor_type IN ('Public', 'Private')\n  AND region = 'Africa';", "latency_sec": 0.5917849540710449, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 187, "prompt_eval_sec": null, "tokens_completion": 40, "completion_eval_sec": null, "tokens_total": 227, "tokens_per_sec": 383.5852845504217, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query sums all projects in 'Renewable Energy' sector and 'Africa' region without filtering by investor_type. The generated query adds an explicit filter for investor_type IN ('Public', 'Private'). While the sample data contains only these two investor types, the queries are not semantically equivalent because the generated query restricts results to specific investor types, whereas the reference query does not. This difference could lead to different results if other investor types existed in the data.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query omits the investor_type filter, which is critical to the business question's requirement for both public and private sectors. While the sample data coincidentally matches, the generated query explicitly enforces the investor_type IN ('Public', 'Private') condition, ensuring accurate results in all cases. Both queries sum amounts for 'Renewable Energy' in Africa, but the generated version strictly adheres to the dual-sector requirement. The reference query might include other investor types if present in the dataset, making it less precise for the business intent.", "overall_assessment": "differently_correct"}}
{"example_id": 1009, "sql_complexity": "multiple_joins", "prompt": "Find the number of IoT sensors installed in each farm that use Sprinkler irrigation.", "context": "CREATE TABLE IoT_Sensors (id INT, sensor_type VARCHAR(50), Farm_id INT); INSERT INTO IoT_Sensors (id, sensor_type, Farm_id) VALUES (1, 'Soil Moisture', 1), (2, 'Temperature', 1), (3, 'Humidity', 2); CREATE TABLE Irrigation (id INT, Farm_id INT, irrigation_type VARCHAR(50), duration INT); INSERT INTO Irrigation (id, Farm_id, irrigation_type, duration) VALUES (1, 1, 'Sprinkler', 30), (2, 2, 'Drip', 45);", "reference_sql": "SELECT f.id, COUNT(s.id) FROM Farmers f JOIN Irrigation i ON f.id = i.Farm_id JOIN IoT_Sensors s ON f.id = s.Farm_id WHERE i.irrigation_type = 'Sprinkler' GROUP BY f.id;", "generated_sql": "SELECT i.Farm_id, COUNT(s.id) AS sensor_count\nFROM Irrigation i\nJOIN IoT_Sensors s ON i.Farm_id = s.Farm_id\nWHERE i.irrigation_type = 'Sprinkler'\nGROUP BY i.Farm_id;", "raw_model_output": "SELECT i.Farm_id, COUNT(s.id) AS sensor_count\nFROM Irrigation i\nJOIN IoT_Sensors s ON i.Farm_id = s.Farm_id\nWHERE i.irrigation_type = 'Sprinkler'\nGROUP BY i.Farm_id;", "latency_sec": 0.9137938022613525, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 215, "prompt_eval_sec": null, "tokens_completion": 56, "completion_eval_sec": null, "tokens_total": 271, "tokens_per_sec": 296.5658109404552, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count IoT_Sensors per Farm_id where Irrigation_type is 'Sprinkler'. The Reference SQL uses Farmers table but joins on Farm_id, which is equivalent to using Irrigation.Farm_id directly. The Generated SQL simplifies the query by removing unnecessary Farmers table join, but the result remains the same as Farm_id values are consistent between tables. Both group by Farm_id and apply the same filter.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in table usage. The reference query incorrectly references a 'Farmers' table not present in the schema, while the generated query properly uses the available 'Irrigation' and 'IoT_Sensors' tables. Both correctly count sensors per farm with Sprinkler irrigation, but the generated query avoids invalid schema references. The generated query is more accurate as it uses existing tables and achieves the same business intent without technical errors.", "overall_assessment": "differently_correct"}}
{"example_id": 4217, "sql_complexity": "subqueries", "prompt": "Show consumer preference data for foundations, excluding products from the USA.", "context": "CREATE TABLE cosmetics (product_id INT, product_name VARCHAR(100), product_type VARCHAR(50), is_cruelty_free BOOLEAN, consumer_preference_score INT); INSERT INTO cosmetics (product_id, product_name, product_type, is_cruelty_free, consumer_preference_score) VALUES (1, 'Lipstick A', 'Lipstick', TRUE, 80), (2, 'Foundation B', 'Foundation', FALSE, 90), (3, 'Mascara C', 'Mascara', TRUE, 85), (4, 'Eyeshadow D', 'Eyeshadow', TRUE, 70), (5, 'Blush E', 'Blush', FALSE, 95); CREATE TABLE ingredient_sourcing (ingredient_id INT, ingredient_name VARCHAR(100), sourcing_country VARCHAR(50), is_organic BOOLEAN); INSERT INTO ingredient_sourcing (ingredient_id, ingredient_name, sourcing_country, is_organic) VALUES (1, 'Rosehip Oil', 'Chile', TRUE), (2, 'Shea Butter', 'Ghana', TRUE), (3, 'Jojoba Oil', 'India', TRUE), (4, 'Coconut Oil', 'Philippines', FALSE), (5, 'Aloe Vera', 'USA', TRUE);", "reference_sql": "SELECT * FROM cosmetics WHERE product_type = 'Foundation' AND product_id NOT IN (SELECT cosmetics.product_id FROM cosmetics INNER JOIN ingredient_sourcing ON cosmetics.product_id = ingredient_sourcing.ingredient_id WHERE ingredient_sourcing.sourcing_country = 'USA');", "generated_sql": "SELECT product_name, consumer_preference_score\nFROM cosmetics\nWHERE product_type = 'Foundation';", "raw_model_output": "```sql\nSELECT product_name, consumer_preference_score\nFROM cosmetics\nWHERE product_type = 'Foundation';\n```", "latency_sec": 0.8233652114868164, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 336, "prompt_eval_sec": null, "tokens_completion": 24, "completion_eval_sec": null, "tokens_total": 360, "tokens_per_sec": 437.23003471317327, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters Foundation products excluding those linked to ingredients sourced from the USA via a subquery, while the Generated SQL retrieves all Foundation products without any exclusion. The Generated SQL lacks the NOT IN condition and selects different columns, leading to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL attempts to exclude products with USA-sourced ingredients by joining cosmetics with ingredient_sourcing on product_id = ingredient_id, but this is logically flawed since product_id (cosmetics) and ingredient_id (ingredient_sourcing) are unrelated fields. The Generated SQL fails to exclude any products, directly violating the 'excluding USA' requirement. While both queries are technically incorrect, the Reference SQL at least addresses the intent of filtering by sourcing country, albeit with a flawed join condition. The Generated SQL completely ignores the exclusion criterion.", "overall_assessment": "differently_correct"}}
{"example_id": 5620, "sql_complexity": "basic SQL", "prompt": "What is the recycling rate of plastic in the residential sector in the state of New York?", "context": "CREATE TABLE recycling_rates_city (sector VARCHAR(20), city VARCHAR(20), material VARCHAR(20), recycling_rate DECIMAL(5,2)); INSERT INTO recycling_rates_city (sector, city, material, recycling_rate) VALUES ('residential', 'New York City', 'plastic', 0.25), ('commercial', 'New York City', 'plastic', 0.30), ('residential', 'New York City', 'paper', 0.45), ('commercial', 'New York City', 'paper', 0.50), ('residential', 'Los Angeles', 'plastic', 0.20), ('commercial', 'Los Angeles', 'plastic', 0.35), ('residential', 'Los Angeles', 'paper', 0.40), ('commercial', 'Los Angeles', 'paper', 0.50);", "reference_sql": "SELECT recycling_rate FROM recycling_rates_city WHERE sector = 'residential' AND material = 'plastic' AND city = 'New York City';", "generated_sql": "SELECT recycling_rate\nFROM recycling_rates_city\nWHERE sector = 'residential'\n  AND city = 'New York City'\n  AND material = 'plastic';", "raw_model_output": "SELECT recycling_rate\nFROM recycling_rates_city\nWHERE sector = 'residential'\n  AND city = 'New York City'\n  AND material = 'plastic';", "latency_sec": 0.7003457546234131, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 259, "prompt_eval_sec": null, "tokens_completion": 33, "completion_eval_sec": null, "tokens_total": 292, "tokens_per_sec": 416.9369173330864, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select the same column ('recycling_rate') from the same table ('recycling_rates_city') and apply identical WHERE conditions (sector = 'residential', city = 'New York City', material = 'plastic'). The order of conditions in the WHERE clause does not affect the result set.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are syntactically identical in terms of logic and structure, with the only difference being whitespace and line breaks. They both select the recycling_rate from the recycling_rates_city table where sector = 'residential', material = 'plastic', and city = 'New York City'. The conditions are logically equivalent regardless of their order in the WHERE clause. The queries correctly address the business question by retrieving the specific recycling rate for the residential sector in New York City, which matches the data provided in the schema (0.25). Neither query is more efficient or elegant than the other as they perform the same operation with identical constraints.", "overall_assessment": "correct"}}
{"example_id": 3151, "sql_complexity": "basic SQL", "prompt": "List all biotech startups that received funding in 2022 and their respective funding amounts.", "context": "CREATE TABLE biotech_startups (name TEXT, funding FLOAT, date DATE); INSERT INTO biotech_startups (name, funding, date) VALUES ('StartupA', 3500000, '2022-02-28'); INSERT INTO biotech_startups (name, funding, date) VALUES ('StartupB', 4500000, '2022-07-12');", "reference_sql": "SELECT name, funding FROM biotech_startups WHERE date BETWEEN '2022-01-01' AND '2022-12-31';", "generated_sql": "SELECT name, funding\nFROM biotech_startups\nWHERE EXTRACT(YEAR FROM date) = 2022;", "raw_model_output": "```sql\nSELECT name, funding\nFROM biotech_startups\nWHERE EXTRACT(YEAR FROM date) = 2022;\n```", "latency_sec": 0.5453629493713379, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 159, "prompt_eval_sec": null, "tokens_completion": 28, "completion_eval_sec": null, "tokens_total": 187, "tokens_per_sec": 342.8909136852119, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter records where the date falls within the year 2022. The BETWEEN clause explicitly checks if the date is between '2022-01-01' and '2022-12-31' (inclusive), while EXTRACT(YEAR FROM date) = 2022 achieves the same by checking the year part of the date. Since the date column is of type DATE (without time components), both conditions will produce identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries are technically correct and would return identical results for the given schema. The reference query uses a date range comparison (BETWEEN '2022-01-01' AND '2022-12-31') which is more efficient for date-typed columns as it can leverage indexes. The generated query uses EXTRACT(YEAR FROM date) = 2022 which achieves the same semantic result but may be less efficient due to the function applied to the column. Both fulfill the business intent of identifying 2022 funding events, but the reference query is more optimized for date-based filtering.", "overall_assessment": "correct"}}
{"example_id": 2136, "sql_complexity": "window functions", "prompt": "What is the total military equipment sales revenue for each sales representative by fiscal year?", "context": "CREATE TABLE SalesReps (SalesRepID INT, SalesRepName VARCHAR(50), FiscalYear INT, Revenue DECIMAL(10,2)); INSERT INTO SalesReps (SalesRepID, SalesRepName, FiscalYear, Revenue) VALUES (1, 'John Doe', 2020, 150000.00), (2, 'Jane Smith', 2020, 200000.00), (1, 'John Doe', 2021, 180000.00), (2, 'Jane Smith', 2021, 250000.00);", "reference_sql": "SELECT SalesRepName, FiscalYear, SUM(Revenue) OVER (PARTITION BY SalesRepName ORDER BY FiscalYear) AS TotalRevenue FROM SalesReps;", "generated_sql": "SELECT SalesRepName, FiscalYear, SUM(Revenue) AS TotalRevenue\nFROM SalesReps\nGROUP BY SalesRepName, FiscalYear\nORDER BY SalesRepName, FiscalYear;", "raw_model_output": "SELECT SalesRepName, FiscalYear, SUM(Revenue) AS TotalRevenue\nFROM SalesReps\nGROUP BY SalesRepName, FiscalYear\nORDER BY SalesRepName, FiscalYear;", "latency_sec": 1.2205350399017334, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 201, "prompt_eval_sec": null, "tokens_completion": 40, "completion_eval_sec": null, "tokens_total": 241, "tokens_per_sec": 197.45438854373504, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates a running total (cumulative sum) of Revenue for each SalesRepName ordered by FiscalYear using a window function. The Generated SQL aggregates Revenue by SalesRepName and FiscalYear, returning only the per-group sum. For example, for John Doe in 2021, the Reference SQL would show 150000+180000=330000, while the Generated SQL would show 180000. The two queries produce different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL calculates a running total per sales representative across fiscal years using a window function (SUM(...) OVER (PARTITION BY ...)), which does not match the requirement for separate yearly totals. The Generated SQL correctly groups by SalesRepName and FiscalYear, summing revenues for each distinct sales rep-year combination. While both queries include SalesRepName and FiscalYear, the Reference's cumulative sum logic violates the 'total by fiscal year' requirement. The Generated SQL directly addresses the business intent by providing discrete yearly totals.", "overall_assessment": "differently_correct"}}
{"example_id": 5452, "sql_complexity": "basic SQL", "prompt": "What is the name of the farms with a size greater than 150 acres located in 'Texas'?", "context": "CREATE TABLE farms (id INT PRIMARY KEY, name VARCHAR(50), size INT, location VARCHAR(50)); INSERT INTO farms (id, name, size, location) VALUES (1, 'Smith Farms', 200, 'Texas'), (2, 'Johnson Farms', 100, 'California');", "reference_sql": "SELECT name FROM farms WHERE size > 150 AND location = 'Texas'", "generated_sql": "SELECT name\nFROM farms\nWHERE size > 150 AND location = 'Texas';", "raw_model_output": "```sql\nSELECT name\nFROM farms\nWHERE size > 150 AND location = 'Texas';\n```", "latency_sec": 0.7284259796142578, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 149, "prompt_eval_sec": null, "tokens_completion": 22, "completion_eval_sec": null, "tokens_total": 171, "tokens_per_sec": 234.75274741100534, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. The only difference is the formatting (line breaks), which does not affect semantic meaning. Both select 'name' from 'farms' where 'size' > 150 and 'location' = 'Texas'.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are syntactically correct and semantically identical. They select the 'name' column from the 'farms' table where 'size' exceeds 150 and 'location' is 'Texas'. The only difference is formatting (line breaks) which does not affect execution. Both would return ['Smith Farms'] based on the sample data. The business intent of identifying Texas farms over 150 acres is fully addressed by both queries. Neither query is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 5152, "sql_complexity": "aggregation", "prompt": "How many international tourists visited Portugal in 2020, broken down by continent?", "context": "CREATE TABLE international_tourists(tourist_id INT, country TEXT, arrival_year INT, continent TEXT);INSERT INTO international_tourists (tourist_id, country, arrival_year, continent) VALUES (1, 'Spain', 2020, 'Europe'), (2, 'France', 2020, 'Europe'), (3, 'Brazil', 2020, 'South America'), (4, 'United States', 2020, 'North America'), (5, 'China', 2020, 'Asia');", "reference_sql": "SELECT continent, COUNT(*) FROM international_tourists WHERE arrival_year = 2020 GROUP BY continent;", "generated_sql": "SELECT continent, COUNT(*) AS tourist_count\nFROM international_tourists\nWHERE country = 'Portugal' AND arrival_year = 2020\nGROUP BY continent;", "raw_model_output": "SELECT continent, COUNT(*) AS tourist_count\nFROM international_tourists\nWHERE country = 'Portugal' AND arrival_year = 2020\nGROUP BY continent;", "latency_sec": 0.5742740631103516, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 192, "prompt_eval_sec": null, "tokens_completion": 34, "completion_eval_sec": null, "tokens_total": 226, "tokens_per_sec": 393.54032250029064, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL counts all tourists from 2020 across all countries by continent, while the Generated SQL filters for 'Portugal' (which has no entries in the data) and thus returns no results. The WHERE clause difference makes them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly counts all international tourists who arrived in 2020, grouped by continent. The Generated SQL incorrectly filters for tourists from 'Portugal' (country = 'Portugal') instead of tourists visiting Portugal. The original question asks for visitors to Portugal, not tourists originating from Portugal. The schema implies 'country' refers to the tourist's origin, making the Generated SQL's filter invalid. The Reference SQL properly addresses the business intent by focusing on arrival_year and continent without unnecessary country filtering.", "overall_assessment": "incorrect"}}
{"example_id": 2477, "sql_complexity": "set operations", "prompt": "What is the carbon price in Europe and Australia for the last quarter of 2020?", "context": "CREATE TABLE CarbonPrices (Country TEXT, Year INT, Quarter INT, CarbonPrice NUMBER); INSERT INTO CarbonPrices (Country, Year, Quarter, CarbonPrice) VALUES ('Europe', 2020, 4, 25), ('Australia', 2020, 4, 15); CREATE TABLE CarbonTaxes (Country TEXT, Year INT, Quarter INT, CarbonPrice NUMBER); INSERT INTO CarbonTaxes (Country, Year, Quarter, CarbonPrice) VALUES ('Europe', 2019, 4, 20), ('Australia', 2019, 4, 10);", "reference_sql": "SELECT Context.Country, Context.CarbonPrice FROM ( SELECT * FROM CarbonPrices WHERE CarbonPrices.Country IN ('Europe', 'Australia') AND CarbonPrices.Year = 2020 AND CarbonPrices.Quarter = 4 UNION SELECT * FROM CarbonTaxes WHERE CarbonTaxes.Country IN ('Europe', 'Australia') AND CarbonTaxes.Year = 2020 AND CarbonTaxes.Quarter = 4 ) AS Context;", "generated_sql": "SELECT Country, CarbonPrice\nFROM CarbonPrices\nWHERE Year = 2020 AND Quarter = 4 AND Country IN ('Europe', 'Australia');", "raw_model_output": "SELECT Country, CarbonPrice\nFROM CarbonPrices\nWHERE Year = 2020 AND Quarter = 4 AND Country IN ('Europe', 'Australia');", "latency_sec": 0.6404550075531006, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 203, "prompt_eval_sec": null, "tokens_completion": 31, "completion_eval_sec": null, "tokens_total": 234, "tokens_per_sec": 365.36524383502285, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL combines results from both CarbonPrices and CarbonTaxes tables using UNION, while the Generated SQL only queries the CarbonPrices table. The Generated SQL lacks the CarbonTaxes table entirely, so it cannot produce the same results if there are relevant entries in CarbonTaxes.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries produce identical results in this specific case because the CarbonTaxes table has no entries for 2020 Q4 (only 2019 Q4). However, the reference query incorrectly includes the CarbonTaxes table, which stores carbon taxes rather than carbon prices. The generated query directly targets the CarbonPrices table, aligning with the business intent of retrieving carbon prices. While technically equivalent given the sample data, the generated query is more accurate, efficient, and semantically correct.", "overall_assessment": "differently_correct"}}
{"example_id": 4573, "sql_complexity": "subqueries", "prompt": "Find the names of all the indigenous communities in the 'Arctic_Communities' table that have a population size greater than the average population size in the 'Antarctic_Communities' table.", "context": "CREATE TABLE Arctic_Communities (name TEXT, population INTEGER); CREATE TABLE Antarctic_Communities (name TEXT, population INTEGER);", "reference_sql": "SELECT name FROM Arctic_Communities WHERE Arctic_Communities.population > (SELECT AVG(population) FROM Antarctic_Communities)", "generated_sql": "SELECT name\nFROM Arctic_Communities\nWHERE population > (SELECT AVG(population) FROM Antarctic_Communities);", "raw_model_output": "```sql\nSELECT name\nFROM Arctic_Communities\nWHERE population > (SELECT AVG(population) FROM Antarctic_Communities);\n```", "latency_sec": 0.6446099281311035, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 134, "prompt_eval_sec": null, "tokens_completion": 29, "completion_eval_sec": null, "tokens_total": 163, "tokens_per_sec": 252.86610225284704, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select names from Arctic_Communities where population exceeds the average population of Antarctic_Communities. The generated query omits the table alias in the WHERE clause, but since the column is unambiguous (only exists in Arctic_Communities), the semantic meaning remains identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically equivalent as they produce identical results. The reference query explicitly qualifies the 'population' column with the table name, while the generated query relies on implicit column resolution. Since the 'population' column exists only in the Arctic_Communities table in this context, both versions are valid. The generated query is more elegant due to its conciseness without sacrificing clarity or correctness. Both correctly calculate the average population from Antarctic_Communities and filter Arctic_Communities accordingly, fully addressing the business intent.", "overall_assessment": "correct"}}
{"example_id": 3596, "sql_complexity": "window functions", "prompt": "What is the total revenue for each game in the \"Gaming\" category?", "context": "CREATE TABLE Games (GameID int, GameName varchar(50), Category varchar(50), Revenue decimal(10,2));", "reference_sql": "SELECT Category, SUM(Revenue) OVER(PARTITION BY Category) as TotalRevenue FROM Games;", "generated_sql": "SELECT GameName, SUM(Revenue) AS TotalRevenue\nFROM Games\nWHERE Category = 'Gaming'\nGROUP BY GameName;", "raw_model_output": "```sql\nSELECT GameName, SUM(Revenue) AS TotalRevenue\nFROM Games\nWHERE Category = 'Gaming'\nGROUP BY GameName;\n```", "latency_sec": 0.6165003776550293, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 108, "prompt_eval_sec": null, "tokens_completion": 31, "completion_eval_sec": null, "tokens_total": 139, "tokens_per_sec": 225.46620413877383, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates total revenue per category using a window function, returning Category and total revenue for each row. The generated query filters to 'Gaming' category, groups by GameName, and sums revenue per game. Differences include: 1) Category vs GameName in output, 2) Filtering to a single category, 3) Grouping by game instead of category, and 4) Different aggregation logic.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL calculates the total revenue per category using a window function, which repeats the same category total for every row. This does not isolate 'each game' in the Gaming category. The Generated SQL attempts to group by GameName but incorrectly sums Revenue (which would only make sense if multiple rows per game exist). Neither query correctly addresses the ambiguous question: if the intent was 'total revenue per category', the Reference SQL is structurally flawed; if the intent was 'individual game revenue', the Generated SQL's GROUP BY is unnecessary. The Generated SQL is closer to the intent but still flawed due to incorrect aggregation.", "overall_assessment": "differently_correct"}}
{"example_id": 5039, "sql_complexity": "subqueries", "prompt": "What is the total number of community policing events in 'City Park' in 2021?", "context": "CREATE TABLE locations (id INT, name VARCHAR(255)); CREATE TABLE community_policing (id INT, location_id INT, year INT, events INT); INSERT INTO locations (id, name) VALUES (1, 'City Park'); INSERT INTO community_policing (id, location_id, year, events) VALUES (1, 1, 2021, 5);", "reference_sql": "SELECT SUM(events) FROM community_policing WHERE location_id = (SELECT id FROM locations WHERE name = 'City Park') AND year = 2021;", "generated_sql": "SELECT SUM(cp.events) AS total_events\nFROM community_policing cp\nJOIN locations l ON cp.location_id = l.id\nWHERE l.name = 'City Park' AND cp.year = 2021;", "raw_model_output": "```sql\nSELECT SUM(cp.events) AS total_events\nFROM community_policing cp\nJOIN locations l ON cp.location_id = l.id\nWHERE l.name = 'City Park' AND cp.year = 2021;\n```", "latency_sec": 1.682474136352539, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 162, "prompt_eval_sec": null, "tokens_completion": 47, "completion_eval_sec": null, "tokens_total": 209, "tokens_per_sec": 124.22182040378596, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of 'events' from community_policing where the location name is 'City Park' and the year is 2021. The reference query uses a subquery to get the location_id, while the generated query uses a JOIN. Both approaches filter the same data, and since the subquery returns a single id (due to the unique name constraint in the sample data), the results will be identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the total community policing events in 'City Park' for 2021. The reference query uses a subquery to get the location_id, while the generated query uses an explicit JOIN. Technically, they produce identical results given the data constraints (unique location name). The generated query is more readable, uses explicit JOIN syntax (which is generally preferred for clarity and maintainability), and avoids potential issues with subquery returns multiple rows (though the context ensures uniqueness here). Both fulfill the business intent, but the generated version is more elegant and efficient.", "overall_assessment": "correct"}}
{"example_id": 2724, "sql_complexity": "basic SQL", "prompt": "What is the earliest installation date for solar panels in Italy?", "context": "CREATE TABLE solar_panels_italy (id INT, installation_date DATE); INSERT INTO solar_panels_italy (id, installation_date) VALUES (1, '2018-01-01'), (2, '2019-01-01'), (3, '2020-01-01');", "reference_sql": "SELECT MIN(installation_date) as earliest_date FROM solar_panels_italy;", "generated_sql": "SELECT MIN(installation_date) AS earliest_installation_date\nFROM solar_panels_italy;", "raw_model_output": "```sql\nSELECT MIN(installation_date) AS earliest_installation_date\nFROM solar_panels_italy;\n```", "latency_sec": 0.732619047164917, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 143, "prompt_eval_sec": null, "tokens_completion": 25, "completion_eval_sec": null, "tokens_total": 168, "tokens_per_sec": 229.31426728546708, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the minimum installation_date from the same table. The only difference is the column alias name ('earliest_date' vs 'earliest_installation_date'), which does not affect the semantic result. The output value (the earliest installation date) remains the same.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly retrieve the earliest installation date using MIN(installation_date). The only difference is the column alias name ('earliest_date' vs 'earliest_installation_date'), which doesn't affect technical correctness or business intent fulfillment. The queries are equally efficient and semantically equivalent, as the alias difference is purely stylistic and doesn't alter the result set's content or structure.", "overall_assessment": "correct"}}
{"example_id": 2200, "sql_complexity": "single join", "prompt": "Which diversity programs are currently being participated in by employees in the HR department?", "context": "CREATE TABLE Employees (Employee_ID INT, First_Name VARCHAR(20), Last_Name VARCHAR(20), Department VARCHAR(20), Salary DECIMAL(10,2), Date_Hired DATE); CREATE TABLE Diversity_Programs (Program_ID INT, Program_Name VARCHAR(50), Participant_ID INT, Date_Started DATE, Date_Ended DATE);", "reference_sql": "SELECT dp.Program_Name FROM Diversity_Programs dp JOIN Employees e ON dp.Participant_ID = e.Employee_ID WHERE e.Department = 'HR' AND dp.Date_Ended IS NULL;", "generated_sql": "SELECT DISTINCT dp.Program_Name\nFROM Diversity_Programs dp\nJOIN Employees e ON dp.Participant_ID = e.Employee_ID\nWHERE e.Department = 'HR'\n  AND (dp.Date_Ended IS NULL OR dp.Date_Ended > CURRENT_DATE)\n  AND dp.Date_Started <= CURRENT_DATE;", "raw_model_output": "```sql\nSELECT DISTINCT dp.Program_Name\nFROM Diversity_Programs dp\nJOIN Employees e ON dp.Participant_ID = e.Employee_ID\nWHERE e.Department = 'HR'\n  AND (dp.Date_Ended IS NULL OR dp.Date_Ended > CURRENT_DATE)\n  AND dp.Date_Started <= CURRENT_DATE;\n```", "latency_sec": 0.7482290267944336, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 150, "prompt_eval_sec": null, "tokens_completion": 65, "completion_eval_sec": null, "tokens_total": 215, "tokens_per_sec": 287.345174138865, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Generated SQL adds conditions (dp.Date_Started <= CURRENT_DATE) and expands the Date_Ended filter to include programs ending in the future (OR dp.Date_Ended > CURRENT_DATE), while the Reference only checks for NULL. Additionally, the Generated SQL uses DISTINCT, which may eliminate duplicates not present in the Reference. These differences in filtering and deduplication alter the result set.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in their handling of program end dates. The reference query only checks for NULL Date_Ended (assuming unended programs), while the generated query includes both NULL Date_Ended and Date_Ended > CURRENT_DATE, which better captures 'current' participation. The generated query also adds Date_Started <= CURRENT_DATE to ensure programs have started, making it more precise. Both address the business intent, but the generated query accounts for edge cases where Date_Ended might be a future date, making it more robust.", "overall_assessment": "differently_correct"}}
{"example_id": 4359, "sql_complexity": "window functions", "prompt": "Which destinations have the least hotel awards?", "context": "CREATE TABLE Destinations (destination_id INT, destination_name TEXT, country TEXT, awards INT); INSERT INTO Destinations (destination_id, destination_name, country, awards) VALUES (1, 'City A', 'Germany', 3), (2, 'City B', 'Switzerland', 5), (3, 'City C', 'Norway', 2);", "reference_sql": "SELECT destination_name, country, awards, RANK() OVER (PARTITION BY country ORDER BY awards ASC) AS rank FROM Destinations;", "generated_sql": "SELECT destination_name\nFROM Destinations\nWHERE awards = (SELECT MIN(awards) FROM Destinations);", "raw_model_output": "```sql\nSELECT destination_name\nFROM Destinations\nWHERE awards = (SELECT MIN(awards) FROM Destinations);\n```", "latency_sec": 1.8760910034179688, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 151, "prompt_eval_sec": null, "tokens_completion": 27, "completion_eval_sec": null, "tokens_total": 178, "tokens_per_sec": 94.87812674103203, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates a rank for each destination within its country based on awards, while the Generated SQL only selects destinations with the minimum awards. They differ in both output columns (rank vs. no rank) and logic (ranking vs. filtering for minimum value).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query ranks destinations by awards within each country, which introduces country-specific ranking logic not mentioned in the original question. The generated query directly identifies destinations with the absolute minimum awards (3 rows in the sample data: City C with 2 awards). While the reference query could theoretically return the same destinations if they have the minimum awards in their country, it's designed for comparative ranking rather than absolute minimum detection. The generated query more precisely addresses the business intent of finding 'least hotel awards' without unnecessary complexity.", "overall_assessment": "differently_correct"}}
{"example_id": 1373, "sql_complexity": "subqueries", "prompt": "What is the total value of military equipment sales to Africa in the last 12 months?", "context": "CREATE TABLE Military_Equipment_Sales(sale_id INT, sale_date DATE, equipment_type VARCHAR(50), country VARCHAR(50), sale_value DECIMAL(10,2));", "reference_sql": "SELECT SUM(sale_value) FROM Military_Equipment_Sales WHERE country IN (SELECT country FROM World_Countries WHERE continent = 'Africa') AND sale_date >= DATE_SUB(CURRENT_DATE, INTERVAL 12 MONTH);", "generated_sql": "SELECT SUM(sale_value) AS total_sales_value\nFROM Military_Equipment_Sales\nWHERE country = 'Africa'\n  AND sale_date >= CURRENT_DATE - INTERVAL '12' MONTH;", "raw_model_output": "```sql\nSELECT SUM(sale_value) AS total_sales_value\nFROM Military_Equipment_Sales\nWHERE country = 'Africa'\n  AND sale_date >= CURRENT_DATE - INTERVAL '12' MONTH;\n```", "latency_sec": 0.6612858772277832, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 121, "prompt_eval_sec": null, "tokens_completion": 44, "completion_eval_sec": null, "tokens_total": 165, "tokens_per_sec": 249.51387241431277, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their country filtering logic. The reference query uses a subquery to select countries in Africa from World_Countries, while the generated query incorrectly filters for 'Africa' as a country value. This would only be equivalent if the 'country' column stored continent names, which is unlikely. The date calculations are equivalent, but the country condition makes the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly identifies sales to African countries by joining with a World_Countries table that maps countries to continents, ensuring all African nations are included. The Generated SQL incorrectly assumes the 'country' column contains a single 'Africa' value rather than individual African countries. While both handle the 12-month date filter correctly (though with different syntax), the Generated SQL's country filter is fundamentally flawed for the business question. The Reference better addresses the intent of aggregating sales to the entire continent.", "overall_assessment": "differently_correct"}}
{"example_id": 904, "sql_complexity": "basic SQL", "prompt": "What is the minimum Shariah-compliant loan amount issued in the last quarter of 2021?", "context": "CREATE TABLE loans (id INT, amount DECIMAL, date DATE, loan_type VARCHAR); INSERT INTO loans (id, amount, date, loan_type) VALUES (1, 5000, '2021-09-05', 'Shariah-compliant'), (2, 7000, '2021-10-07', 'socially responsible'), (3, 9000, '2021-11-03', 'Shariah-compliant'), (4, 11000, '2021-12-31', 'Shariah-compliant');", "reference_sql": "SELECT MIN(amount) FROM loans WHERE EXTRACT(YEAR FROM date) = 2021 AND EXTRACT(QUARTER FROM date) = 4 AND loan_type = 'Shariah-compliant';", "generated_sql": "SELECT MIN(amount) AS min_shariah_loan_amount\nFROM loans\nWHERE loan_type = 'Shariah-compliant'\n  AND date >= '2021-10-01'\n  AND date <= '2021-12-31';", "raw_model_output": "SELECT MIN(amount) AS min_shariah_loan_amount\nFROM loans\nWHERE loan_type = 'Shariah-compliant'\n  AND date >= '2021-10-01'\n  AND date <= '2021-12-31';", "latency_sec": 0.7795970439910889, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 206, "prompt_eval_sec": null, "tokens_completion": 52, "completion_eval_sec": null, "tokens_total": 258, "tokens_per_sec": 330.9401978734915, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter loans with 'Shariah-compliant' type and dates in the fourth quarter of 2021. The reference query uses EXTRACT(YEAR=2021 AND QUARTER=4) while the generated query uses date range '2021-10-01' to '2021-12-31', which corresponds to Q4. Both approaches capture the same subset of data, so they will produce identical MIN(amount) results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify the minimum Shariah-compliant loan amount in Q4 2021. The reference query uses EXTRACT() to filter by year and quarter, while the generated query uses explicit date ranges. Semantically, both achieve the same result: filtering loans in October-December 2021. However, the generated query is more efficient as date ranges can leverage indexes, and its logic is more explicit about the quarter's date boundaries. The reference query's EXTRACT() approach might be less performant in some databases. Both fulfill the business intent, but the generated query is more elegant and efficient.", "overall_assessment": "correct"}}
{"example_id": 3299, "sql_complexity": "set operations", "prompt": "How many schools and hospitals are there in Colombia and which ones need repairs?", "context": "CREATE TABLE schools (id INT, country VARCHAR(20), name VARCHAR(50), needs_repair BOOLEAN); CREATE TABLE hospitals (id INT, country VARCHAR(20), name VARCHAR(50), needs_repair BOOLEAN);", "reference_sql": "SELECT 'Schools' as facility_type, COUNT(*) as total, SUM(needs_repair) as repairs_needed FROM schools WHERE country = 'Colombia' UNION ALL SELECT 'Hospitals' as facility_type, COUNT(*) as total, SUM(needs_repair) as repairs_needed FROM hospitals WHERE country = 'Colombia';", "generated_sql": "SELECT \n    'schools' AS type,\n    COUNT(*) AS total_count,\n    SUM(CASE WHEN needs_repair THEN 1 ELSE 0 END) AS needs_repair_count\nFROM schools\nWHERE country = 'Colombia'\nUNION ALL\nSELECT \n    'hospitals' AS type,\n    COUNT(*) AS total_count,\n    SUM(CASE WHEN needs_repair THEN 1 ELSE 0 END) AS needs_repair_count\nFROM hospitals\nWHERE country = 'Colombia';", "raw_model_output": "SELECT \n    'schools' AS type,\n    COUNT(*) AS total_count,\n    SUM(CASE WHEN needs_repair THEN 1 ELSE 0 END) AS needs_repair_count\nFROM schools\nWHERE country = 'Colombia'\nUNION ALL\nSELECT \n    'hospitals' AS type,\n    COUNT(*) AS total_count,\n    SUM(CASE WHEN needs_repair THEN 1 ELSE 0 END) AS needs_repair_count\nFROM hospitals\nWHERE country = 'Colombia';", "latency_sec": 1.0080158710479736, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 126, "prompt_eval_sec": null, "tokens_completion": 103, "completion_eval_sec": null, "tokens_total": 229, "tokens_per_sec": 227.17896272994435, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the facility_type values use different casing ('Schools' vs 'schools'). Second, the column names differ (e.g., 'total' vs 'total_count', 'repairs_needed' vs 'needs_repair_count'). While the data logic (counting and summing) is equivalent, the result set structure and string values are not identical, making them semantically distinct.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly count total facilities and those needing repairs in Colombia for schools and hospitals. The reference query uses explicit 'Schools'/'Hospitals' labels with 'total'/'repairs_needed' columns, while the generated query uses lowercase 'schools'/'hospitals' labels with 'total_count'/'needs_repair_count' columns. The SUM logic differs slightly: reference uses SUM(needs_repair) (treats BOOLEAN as 0/1) while generated uses CASE WHEN needs_repair THEN 1 ELSE 0 END. Both approaches are valid and produce identical results. The queries are structurally equivalent but differ in naming conventions and explicitness of repair counting logic.", "overall_assessment": "correct"}}
{"example_id": 907, "sql_complexity": "set operations", "prompt": "What is the total quantity of items with type 'E' or type 'F' in warehouse O and warehouse P?", "context": "CREATE TABLE warehouse_o(item_id INT, item_type VARCHAR(10), quantity INT);CREATE TABLE warehouse_p(item_id INT, item_type VARCHAR(10), quantity INT);INSERT INTO warehouse_o(item_id, item_type, quantity) VALUES (1, 'E', 200), (2, 'F', 300), (3, 'E', 50), (4, 'F', 400);INSERT INTO warehouse_p(item_id, item_type, quantity) VALUES (1, 'E', 150), (2, 'F', 250), (3, 'E', 40), (4, 'F', 350);", "reference_sql": "SELECT quantity FROM warehouse_o WHERE item_type IN ('E', 'F') UNION ALL SELECT quantity FROM warehouse_p WHERE item_type IN ('E', 'F');", "generated_sql": "SELECT \n    SUM(quantity) AS total_quantity\nFROM (\n    SELECT quantity FROM warehouse_o WHERE item_type IN ('E', 'F')\n    UNION ALL\n    SELECT quantity FROM warehouse_p WHERE item_type IN ('E', 'F')\n) AS combined;", "raw_model_output": "SELECT \n    SUM(quantity) AS total_quantity\nFROM (\n    SELECT quantity FROM warehouse_o WHERE item_type IN ('E', 'F')\n    UNION ALL\n    SELECT quantity FROM warehouse_p WHERE item_type IN ('E', 'F')\n) AS combined;", "latency_sec": 0.9031071662902832, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 223, "prompt_eval_sec": null, "tokens_completion": 53, "completion_eval_sec": null, "tokens_total": 276, "tokens_per_sec": 305.61157114247294, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns individual quantity values from both tables combined with UNION ALL, while the Generated SQL aggregates all quantities into a single sum. The first produces multiple rows of individual values, the second produces one row with a total, so they are not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query returns individual quantities from both warehouses without aggregation, while the generated query properly sums all qualifying quantities. The original question explicitly asks for 'total quantity,' which requires aggregation. The reference query would return four rows of data (200, 300, 50, 400 from O and 150, 250, 40, 350 from P) whereas the generated query correctly calculates the sum (200+300+50+400+150+250+40+350 = 1740). The generated query also follows better SQL practices by using a subquery with SUM for clarity and efficiency.", "overall_assessment": "differently_correct"}}
{"example_id": 1400, "sql_complexity": "single join", "prompt": "What is the maximum co-ownership duration for properties in the neighborhood of 'Chinatown' in San Francisco?'", "context": "CREATE TABLE sf_neighborhoods (neighborhood_id INT, name VARCHAR(255), city VARCHAR(255)); INSERT INTO sf_neighborhoods (neighborhood_id, name, city) VALUES (1, 'Chinatown', 'San Francisco'); CREATE TABLE co_ownership (co_ownership_id INT, property_id INT, co_owner_id INT, start_date DATE, end_date DATE); INSERT INTO co_ownership (co_ownership_id, property_id, co_owner_id, start_date, end_date) VALUES (1, 1, 2, '2010-01-01', '2020-01-01'), (2, 2, 3, '2015-01-01', '2022-01-01'); CREATE TABLE properties (property_id INT, city VARCHAR(255)); INSERT INTO properties (property_id, city) VALUES (1, 'San Francisco'), (2, 'San Francisco');", "reference_sql": "SELECT MAX(DATEDIFF(end_date, start_date)) as max_duration FROM co_ownership JOIN properties ON co_ownership.property_id = properties.property_id WHERE properties.city = 'San Francisco' AND name = 'Chinatown';", "generated_sql": "SELECT MAX(DATEDIFF(\n    COALESCE(end_date, CURRENT_DATE),\n    start_date\n)) AS max_co_ownership_duration\nFROM co_ownership co\nJOIN properties p ON co.property_id = p.property_id\nJOIN sf_neighborhoods n ON p.city = n.city\nWHERE n.name = 'Chinatown' AND n.city = 'San Francisco';", "raw_model_output": "```sql\nSELECT MAX(DATEDIFF(\n    COALESCE(end_date, CURRENT_DATE),\n    start_date\n)) AS max_co_ownership_duration\nFROM co_ownership co\nJOIN properties p ON co.property_id = p.property_id\nJOIN sf_neighborhoods n ON p.city = n.city\nWHERE n.name = 'Chinatown' AND n.city = 'San Francisco';\n```", "latency_sec": 1.216822862625122, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 280, "prompt_eval_sec": null, "tokens_completion": 80, "completion_eval_sec": null, "tokens_total": 360, "tokens_per_sec": 295.85242935307053, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references 'name' in the WHERE clause, but 'name' is not present in the joined tables (co_ownership and properties). The Generated SQL correctly joins with sf_neighborhoods to access the 'name' column. Additionally, the Generated SQL uses COALESCE(end_date, CURRENT_DATE) which handles NULL end_date values differently than the Reference SQL's direct end_date usage. These differences in schema usage and NULL handling make the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query is technically incorrect because it references 'name' in the WHERE clause without joining the sf_neighborhoods table, leading to an invalid column reference. The generated query correctly joins sf_neighborhoods and filters on both name and city. Additionally, the generated query handles potential null end_date values using COALESCE, making it more robust. While both aim to calculate co-ownership duration, the reference query fails to properly filter properties in Chinatown due to schema misunderstanding. The generated query better addresses the business intent by accurately linking neighborhoods and handling edge cases.", "overall_assessment": "incorrect"}}
{"example_id": 5248, "sql_complexity": "window functions", "prompt": "Find the top 5 games by rating", "context": "CREATE TABLE games (game_id INT PRIMARY KEY, name VARCHAR(50), genre VARCHAR(50), rating DECIMAL(3,2));", "reference_sql": "SELECT * FROM (SELECT name, rating, ROW_NUMBER() OVER (ORDER BY rating DESC) as rn FROM games) t WHERE rn <= 5;", "generated_sql": "SELECT game_id, name, genre, rating\nFROM games\nORDER BY rating DESC\nLIMIT 5;", "raw_model_output": "```sql\nSELECT game_id, name, genre, rating\nFROM games\nORDER BY rating DESC\nLIMIT 5;\n```", "latency_sec": 0.7800228595733643, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 104, "prompt_eval_sec": null, "tokens_completion": 27, "completion_eval_sec": null, "tokens_total": 131, "tokens_per_sec": 167.94379599547997, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query returns only 'name', 'rating', and 'rn' columns, while the generated query returns 'game_id', 'name', 'genre', and 'rating'. Additionally, the reference query uses ROW_NUMBER() which assigns unique ranks, whereas the generated query uses LIMIT 5 which directly restricts the result set. The column sets and ranking mechanisms differ, leading to different output structures.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "While both queries aim to retrieve top-rated games, they differ in implementation. The reference query uses ROW_NUMBER() with a subquery, which is unnecessarily complex for this task. The generated query directly orders by rating and limits results, which is more efficient and straightforward. Semantically, they may produce different results when there are tie ratings (ROW_NUMBER() assigns unique ranks while ORDER BY/LIMIT may return arbitrary ties). The generated query better fulfills the business intent by being simpler, more efficient, and directly addressing the 'top 5' requirement without overcomplication.", "overall_assessment": "differently_correct"}}
{"example_id": 778, "sql_complexity": "single join", "prompt": "What is the maximum property price in wheelchair-accessible neighborhoods in Singapore?", "context": "CREATE TABLE Singapore_Neighborhoods (Neighborhood_Name TEXT, Wheelchair_Accessibility BOOLEAN); INSERT INTO Singapore_Neighborhoods (Neighborhood_Name, Wheelchair_Accessibility) VALUES ('Orchard', true), ('Marina Bay', true), ('Chinatown', false), ('Little India', false), ('Bugis', true); CREATE TABLE Singapore_Properties (Neighborhood_Name TEXT, Property_Price INTEGER); INSERT INTO Singapore_Properties (Neighborhood_Name, Property_Price) VALUES ('Orchard', 2000000), ('Marina Bay', 3000000), ('Chinatown', 1500000), ('Little India', 1200000), ('Bugis', 1800000);", "reference_sql": "SELECT MAX(Singapore_Properties.Property_Price) FROM Singapore_Properties INNER JOIN Singapore_Neighborhoods ON Singapore_Properties.Neighborhood_Name = Singapore_Neighborhoods.Neighborhood_Name WHERE Singapore_Neighborhoods.Wheelchair_Accessibility = true;", "generated_sql": "SELECT MAX(Property_Price) AS Max_Property_Price\nFROM Singapore_Properties p\nJOIN Singapore_Neighborhoods n ON p.Neighborhood_Name = n.Neighborhood_Name\nWHERE n.Wheelchair_Accessibility = TRUE;", "raw_model_output": "SELECT MAX(Property_Price) AS Max_Property_Price\nFROM Singapore_Properties p\nJOIN Singapore_Neighborhoods n ON p.Neighborhood_Name = n.Neighborhood_Name\nWHERE n.Wheelchair_Accessibility = TRUE;", "latency_sec": 0.7461609840393066, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 226, "prompt_eval_sec": null, "tokens_completion": 48, "completion_eval_sec": null, "tokens_total": 274, "tokens_per_sec": 367.212981998488, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the maximum property price from neighborhoods with wheelchair accessibility. The generated query uses table aliases and an explicit AS clause for the column alias, but these are syntactic variations that do not affect the semantic result. The JOIN condition, WHERE filter, and aggregate function remain identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly identify the maximum property price in wheelchair-accessible Singapore neighborhoods by joining the two tables on Neighborhood_Name and filtering where Wheelchair_Accessibility = TRUE. The reference query uses explicit table names while the generated query uses aliases, but this does not affect the result. Both produce the same output (3,000,000 from Marina Bay) and are syntactically valid. The generated query adds an explicit column alias (Max_Property_Price) which improves readability but is not required for correctness. Neither query demonstrates significant efficiency differences given the small dataset.", "overall_assessment": "correct"}}
{"example_id": 3859, "sql_complexity": "aggregation", "prompt": "What is the total number of mental health parity violations by month and year?", "context": "CREATE TABLE mental_health_parity_reports (report_id INT, violation_date DATE); INSERT INTO mental_health_parity_reports (report_id, violation_date) VALUES (1, '2022-01-01'), (2, '2022-02-15'), (3, '2022-03-05'), (4, '2022-04-20'), (5, '2021-06-12'), (6, '2021-07-28');", "reference_sql": "SELECT EXTRACT(MONTH FROM violation_date) AS month, EXTRACT(YEAR FROM violation_date) AS year, COUNT(*) FROM mental_health_parity_reports GROUP BY month, year;", "generated_sql": "SELECT \n    EXTRACT(YEAR FROM violation_date) AS year,\n    EXTRACT(MONTH FROM violation_date) AS month,\n    COUNT(*) AS total_violations\nFROM mental_health_parity_reports\nGROUP BY \n    EXTRACT(YEAR FROM violation_date),\n    EXTRACT(MONTH FROM violation_date)\nORDER BY \n    year,\n    month;", "raw_model_output": "```sql\nSELECT \n    EXTRACT(YEAR FROM violation_date) AS year,\n    EXTRACT(MONTH FROM violation_date) AS month,\n    COUNT(*) AS total_violations\nFROM mental_health_parity_reports\nGROUP BY \n    EXTRACT(YEAR FROM violation_date),\n    EXTRACT(MONTH FROM violation_date)\nORDER BY \n    year,\n    month;\n```", "latency_sec": 0.8526709079742432, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 179, "prompt_eval_sec": null, "tokens_completion": 79, "completion_eval_sec": null, "tokens_total": 258, "tokens_per_sec": 302.5786356578656, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries group by year and month, count violations, and return the same data. The differences are in column order (month/year), alias names (COUNT(*) vs. total_violations), and the Generated SQL includes an ORDER BY. These do not affect the semantic equivalence as the core aggregation and grouping logic are identical.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The Reference SQL uses column aliases (month, year) in the GROUP BY clause, which is invalid in standard SQL (aliases cannot be used in GROUP BY). The Generated SQL correctly uses the EXTRACT expressions in GROUP BY, making it technically valid. Both queries fulfill the business intent of counting violations by month/year, but the Generated SQL is more robust. The Generated SQL also includes an explicit ORDER BY, which improves result readability without altering the core logic. While the Reference SQL might work in some non-standard SQL implementations, the Generated SQL is technically superior and adheres to SQL standards.", "overall_assessment": "differently_correct"}}
{"example_id": 3551, "sql_complexity": "multiple_joins", "prompt": "List all artists who have performed in New York and Chicago, along with their highest-earning performance.", "context": "CREATE TABLE artist_events (artist_id INT, event_id INT, earnings DECIMAL(5,2)); CREATE TABLE artists (id INT, name VARCHAR(50)); CREATE TABLE events (id INT, city VARCHAR(20));", "reference_sql": "SELECT artists.name, MAX(artist_events.earnings) FROM artists INNER JOIN artist_events ON artists.id = artist_events.artist_id INNER JOIN events ON artist_events.event_id = events.id WHERE city IN ('New York', 'Chicago') GROUP BY artists.name;", "generated_sql": "WITH artist_cities AS (\n    SELECT ae.artist_id, e.city\n    FROM artist_events ae\n    JOIN events e ON ae.event_id = e.id\n    WHERE e.city IN ('New York', 'Chicago')\n    GROUP BY ae.artist_id, e.city\n),\nartists_in_both_cities AS (\n    SELECT artist_id\n    FROM artist_cities\n    GROUP BY artist_id\n    HAVING COUNT(DISTINCT city) = 2\n),\nartist_max_earnings AS (\n    SELECT artist_id, MAX(earnings) AS max_earnings\n    FROM artist_events\n    GROUP BY artist_id\n)\nSELECT ar.name, am.max_earnings\nFROM artists_in_both_cities aib\nJOIN artist_max_earnings am ON aib.artist_id = am.artist_id\nJOIN artists ar ON ar.id = aib.artist_id;", "raw_model_output": "```sql\nWITH artist_cities AS (\n    SELECT ae.artist_id, e.city\n    FROM artist_events ae\n    JOIN events e ON ae.event_id = e.id\n    WHERE e.city IN ('New York', 'Chicago')\n    GROUP BY ae.artist_id, e.city\n),\nartists_in_both_cities AS (\n    SELECT artist_id\n    FROM artist_cities\n    GROUP BY artist_id\n    HAVING COUNT(DISTINCT city) = 2\n),\nartist_max_earnings AS (\n    SELECT artist_id, MAX(earnings) AS max_earnings\n    FROM artist_events\n    GROUP BY artist_id\n)\nSELECT ar.name, am.max_earnings\nFROM artists_in_both_cities aib\nJOIN artist_max_earnings am ON aib.artist_id = am.artist_id\nJOIN artists ar ON ar.id = aib.artist_id;\n```", "latency_sec": 1.8691740036010742, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 132, "prompt_eval_sec": null, "tokens_completion": 184, "completion_eval_sec": null, "tokens_total": 316, "tokens_per_sec": 169.05863198996312, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL retrieves each artist's maximum earnings from events in 'New York' or 'Chicago', while the Generated SQL filters artists who have events in *both* cities and uses their overall maximum earnings (from all events, not just the specified cities). The Generated SQL also excludes artists who only performed in one of the two cities, making the result sets different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is technically correct but fails to fulfill the business intent. It returns artists who performed in either New York or Chicago (not both) and their maximum earnings across all events. The Generated SQL correctly identifies artists who performed in *both* cities (via HAVING COUNT(DISTINCT city) = 2) and retrieves their highest-earning performance. While the Generated SQL is more complex, it accurately addresses the requirement for artists with performances in *both* cities. The Reference SQL would include artists who only performed in one of the two cities, violating the original question's constraints.", "overall_assessment": "differently_correct"}}
{"example_id": 5168, "sql_complexity": "aggregation", "prompt": "Get the number of renewable energy projects in Australia for each project type.", "context": "CREATE TABLE renewable_projects (id INT PRIMARY KEY, project_name VARCHAR(255), project_location VARCHAR(255), project_type VARCHAR(255), capacity_mw FLOAT);", "reference_sql": "SELECT project_type, COUNT(*) FROM renewable_projects WHERE project_location = 'Australia' GROUP BY project_type;", "generated_sql": "SELECT project_type, COUNT(*) AS project_count\nFROM renewable_projects\nWHERE project_location = 'Australia'\nGROUP BY project_type;", "raw_model_output": "```sql\nSELECT project_type, COUNT(*) AS project_count\nFROM renewable_projects\nWHERE project_location = 'Australia'\nGROUP BY project_type;\n```", "latency_sec": 0.5558309555053711, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 114, "prompt_eval_sec": null, "tokens_completion": 31, "completion_eval_sec": null, "tokens_total": 145, "tokens_per_sec": 260.87068120947583, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same data: counts of projects by type in Australia. The generated query adds an alias (project_count) to the COUNT(*) column, but this does not affect the semantic result. The WHERE clause, GROUP BY, and aggregate function are identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically correct and produce identical results. The reference query returns the same data as the generated query, but the generated version adds an explicit alias ('project_count') for the COUNT(*) column. This improves readability and clarity of the output, making it slightly more elegant while maintaining semantic equivalence. Both address the business intent of counting Australian renewable projects by type.", "overall_assessment": "correct"}}
{"example_id": 4916, "sql_complexity": "aggregation", "prompt": "What is the maximum revenue generated from selling Yttrium in India in the past 3 years?", "context": "CREATE TABLE Yttrium_Sales (id INT PRIMARY KEY, year INT, country VARCHAR(20), quantity INT, price PER_KG); INSERT INTO Yttrium_Sales (id, year, country, quantity, price) VALUES (1, 2019, 'India', 120, 40), (2, 2020, 'India', 130, 45), (3, 2021, 'India', 140, 50), (4, 2019, 'China', 150, 35), (5, 2020, 'China', 160, 40), (6, 2021, 'China', 170, 45);", "reference_sql": "SELECT MAX(quantity * price) FROM Yttrium_Sales WHERE country = 'India' GROUP BY year ORDER BY year DESC LIMIT 3;", "generated_sql": "SELECT MAX(quantity * price) AS max_revenue\nFROM Yttrium_Sales\nWHERE country = 'India' AND year BETWEEN 2019 AND 2021;", "raw_model_output": "SELECT MAX(quantity * price) AS max_revenue\nFROM Yttrium_Sales\nWHERE country = 'India' AND year BETWEEN 2019 AND 2021;", "latency_sec": 0.6159589290618896, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 234, "prompt_eval_sec": null, "tokens_completion": 37, "completion_eval_sec": null, "tokens_total": 271, "tokens_per_sec": 439.964398945779, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL groups by year and returns the maximum quantity*price per year (3 rows), while the Generated SQL calculates a single maximum value across all India records between 2019-2021. The first returns multiple rows with per-year maxima, the second returns a single global maximum.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query groups by year and returns three separate maximum values (one per year), but the question asks for the single maximum revenue across all three years. The generated query correctly calculates the overall maximum revenue in India from 2019-2021. While both queries filter India and the 3-year window, the reference's GROUP BY clause fundamentally changes the result structure. The generated query is more efficient and directly addresses the business intent of finding the absolute maximum.", "overall_assessment": "differently_correct"}}
{"example_id": 812, "sql_complexity": "multiple_joins", "prompt": "What is the average salary of 'engineer' workers in each factory?", "context": "CREATE TABLE factories (factory_id INT, factory_name VARCHAR(20)); INSERT INTO factories VALUES (1, 'Factory X'), (2, 'Factory Y'), (3, 'Factory Z'); CREATE TABLE roles (role_id INT, role_name VARCHAR(20)); INSERT INTO roles VALUES (1, 'engineer'), (2, 'manager'), (3, 'assistant'); CREATE TABLE workers (worker_id INT, factory_id INT, role_id INT, salary DECIMAL(5,2)); INSERT INTO workers VALUES (1, 1, 1, 50000.00), (2, 1, 2, 70000.00), (3, 2, 1, 55000.00), (4, 2, 3, 40000.00), (5, 3, 1, 60000.00);", "reference_sql": "SELECT f.factory_name, AVG(salary) FROM workers w INNER JOIN factories f ON w.factory_id = f.factory_id INNER JOIN roles r ON w.role_id = r.role_id WHERE r.role_name = 'engineer' GROUP BY f.factory_name;", "generated_sql": "SELECT f.factory_name, AVG(w.salary) AS average_salary\nFROM workers w\nJOIN factories f ON w.factory_id = f.factory_id\nJOIN roles r ON w.role_id = r.role_id\nWHERE r.role_name = 'engineer'\nGROUP BY f.factory_name;", "raw_model_output": "SELECT f.factory_name, AVG(w.salary) AS average_salary\nFROM workers w\nJOIN factories f ON w.factory_id = f.factory_id\nJOIN roles r ON w.role_id = r.role_id\nWHERE r.role_name = 'engineer'\nGROUP BY f.factory_name;", "latency_sec": 0.7545468807220459, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 261, "prompt_eval_sec": null, "tokens_completion": 57, "completion_eval_sec": null, "tokens_total": 318, "tokens_per_sec": 421.44498655364845, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same data by joining the same tables (workers, factories, roles) with identical conditions. The only differences are: 1) the generated query uses an explicit table alias (w, f, r) while the reference uses unqualified column names, 2) the generated query uses JOIN instead of INNER JOIN (which are equivalent), and 3) the generated query adds an alias (average_salary) for the AVG(salary) column. These syntactic differences do not affect the semantic result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the average salary of 'engineer' workers per factory. They use identical joins (workers-factories-roles), filter on 'engineer' role, and group by factory name. The reference query uses implicit column qualification (AVG(salary)) while the generated query explicitly aliases the salary column (AVG(w.salary)), but both produce the same numerical results. The GROUP BY clause is valid as factory_name is functionally dependent on factory_id. Both queries address the business intent of calculating average salaries per factory for engineers.", "overall_assessment": "correct"}}
{"example_id": 5784, "sql_complexity": "set operations", "prompt": "List the number of users who have completed a workout of a specific type (e.g. Running) and have a membership status of 'Active'.", "context": "CREATE TABLE workouts (id INT, user_id INT, workout_type VARCHAR(20)); CREATE TABLE members (id INT, name VARCHAR(50), membership_status VARCHAR(20), state VARCHAR(20)); INSERT INTO workouts (id, user_id, workout_type) VALUES (1, 1, 'Running'), (2, 1, 'Cycling'), (3, 2, 'Running'), (4, 3, 'Cycling'), (5, 3, 'Swimming'), (6, 4, 'Running'), (7, 4, 'Swimming'); INSERT INTO members (id, name, membership_status, state) VALUES (1, 'John Doe', 'Active', 'Texas'), (2, 'Jane Doe', 'Inactive', 'California'), (3, 'Bob Smith', 'Active', 'Texas'), (4, 'Alice Johnson', 'Active', 'California');", "reference_sql": "SELECT COUNT(*) FROM (SELECT user_id FROM workouts WHERE workout_type = 'Running' INTERSECT SELECT id FROM members WHERE membership_status = 'Active') AS user_set;", "generated_sql": "SELECT COUNT(DISTINCT w.user_id) AS active_users_with_workout\nFROM workouts w\nJOIN members m ON w.user_id = m.id\nWHERE w.workout_type = 'Running'\n  AND m.membership_status = 'Active';", "raw_model_output": "```sql\nSELECT COUNT(DISTINCT w.user_id) AS active_users_with_workout\nFROM workouts w\nJOIN members m ON w.user_id = m.id\nWHERE w.workout_type = 'Running'\n  AND m.membership_status = 'Active';\n```", "latency_sec": 0.7176640033721924, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 280, "prompt_eval_sec": null, "tokens_completion": 55, "completion_eval_sec": null, "tokens_total": 335, "tokens_per_sec": 466.79225713688675, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of distinct user_ids that have at least one 'Running' workout and are active members. The Reference SQL uses INTERSECT to find user_ids present in both the 'Running' workouts and active members, while the Generated SQL achieves the same via a JOIN with DISTINCT. Both approaches yield the same result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count users with 'Running' workouts and active memberships. The reference query uses INTERSECT to find overlapping user_ids between two subqueries, while the generated query uses a JOIN to combine relevant rows and COUNT(DISTINCT) to eliminate duplicates. Both produce identical results (2 in the sample data). However, the generated query is more efficient and readable: it avoids the overhead of INTERSECT, explicitly joins related tables, and uses COUNT(DISTINCT) which is semantically clearer for this use case. The reference query's INTERSECT approach is technically correct but less optimal for large datasets.", "overall_assessment": "correct"}}
{"example_id": 3038, "sql_complexity": "subqueries", "prompt": "What is the total assets of clients who have invested in mutual funds but not in stocks?", "context": "CREATE TABLE clients (client_id INT, name TEXT, age INT, gender TEXT, total_assets DECIMAL(10,2)); INSERT INTO clients VALUES (1, 'John Doe', 35, 'Male', 250000.00), (2, 'Jane Smith', 45, 'Female', 500000.00); CREATE TABLE investments (client_id INT, investment_type TEXT); INSERT INTO investments VALUES (1, 'Stocks'), (1, 'Bonds'), (2, 'Stocks'), (3, 'Mutual Funds');", "reference_sql": "SELECT c.total_assets FROM clients c INNER JOIN investments i ON c.client_id = i.client_id WHERE i.investment_type = 'Mutual Funds' AND c.client_id NOT IN (SELECT client_id FROM investments WHERE investment_type = 'Stocks');", "generated_sql": "SELECT SUM(c.total_assets) AS total_assets\nFROM clients c\nJOIN investments i_mutual ON c.client_id = i_mutual.client_id AND i_mutual.investment_type = 'Mutual Funds'\nLEFT JOIN investments i_stocks ON c.client_id = i_stocks.client_id AND i_stocks.investment_type = 'Stocks'\nWHERE i_stocks.client_id IS NULL;", "raw_model_output": "```sql\nSELECT SUM(c.total_assets) AS total_assets\nFROM clients c\nJOIN investments i_mutual ON c.client_id = i_mutual.client_id AND i_mutual.investment_type = 'Mutual Funds'\nLEFT JOIN investments i_stocks ON c.client_id = i_stocks.client_id AND i_stocks.investment_type = 'Stocks'\nWHERE i_stocks.client_id IS NULL;\n```", "latency_sec": 1.3785531520843506, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 196, "prompt_eval_sec": null, "tokens_completion": 85, "completion_eval_sec": null, "tokens_total": 281, "tokens_per_sec": 203.836899270175, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns individual client assets where clients have 'Mutual Funds' and not 'Stocks', while the Generated SQL aggregates total_assets with SUM and uses a LEFT JOIN to exclude 'Stocks' investments. The SUM operation and differing result structures (individual rows vs. single aggregated value) make them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in two critical aspects.  The reference query returns individual client assets rather than a total, which directly contradicts the question's request for 'total assets'. The generated query correctly uses SUM() to aggregate the assets.  Both queries correctly identify clients with mutual fund investments and no stock investments, but only the generated query provides the requested aggregated result.  While the reference query is technically correct in identifying the appropriate clients, it fails to fulfill the business intent of providing a total.  The generated query is more efficient as it avoids a subquery and directly calculates the required aggregate value.", "overall_assessment": "differently_correct"}}
{"example_id": 1078, "sql_complexity": "basic SQL", "prompt": "What is the maximum and minimum temperature difference between any two Arctic research stations?", "context": "CREATE TABLE arctic_stations (id INT, name TEXT, location TEXT, temperature DECIMAL(5,2)); INSERT INTO arctic_stations (id, name, location, temperature) VALUES (1, 'Station A', 'Greenland', 2.3), (2, 'Station B', 'Canada', -5.2);", "reference_sql": "SELECT a.name as station1, b.name as station2, MAX(ABS(a.temperature - b.temperature)) as temp_diff FROM arctic_stations a, arctic_stations b ORDER BY temp_diff DESC LIMIT 1", "generated_sql": "SELECT \n        ABS(a.temperature - b.temperature) AS diff\n    FROM \n        arctic_stations a\n    CROSS JOIN \n        arctic_stations b\n    WHERE \n        a.id <> b.id\n)\nSELECT \n    MAX(diff) AS max_temperature_difference,\n    MIN(diff) AS min_temperature_difference\nFROM \n    temp_diff;", "raw_model_output": "WITH temp_diff AS (\n    SELECT \n        ABS(a.temperature - b.temperature) AS diff\n    FROM \n        arctic_stations a\n    CROSS JOIN \n        arctic_stations b\n    WHERE \n        a.id <> b.id\n)\nSELECT \n    MAX(diff) AS max_temperature_difference,\n    MIN(diff) AS min_temperature_difference\nFROM \n    temp_diff;", "latency_sec": 1.131847858428955, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 153, "prompt_eval_sec": null, "tokens_completion": 78, "completion_eval_sec": null, "tokens_total": 231, "tokens_per_sec": 204.09103421429464, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns the maximum temperature difference along with station names, while the Generated SQL calculates both max and min differences without station names. The result structures differ, and the Generated SQL includes additional data not present in the Reference.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query is technically correct but only returns the maximum temperature difference (via MAX(ABS(...)) and LIMIT 1), not the minimum. The generated query attempts to calculate both max and min but contains a syntax error: the CTE is improperly formatted with an extra closing parenthesis and lacks a WITH clause. While the generated query's logic would theoretically fulfill the intent if fixed, its syntax makes it invalid. The reference query, though incomplete for the original question, is technically valid.", "overall_assessment": "incorrect"}}
{"example_id": 5015, "sql_complexity": "basic SQL", "prompt": "Calculate the average recycling rate", "context": "CREATE TABLE recycling_rates (id INT PRIMARY KEY, location VARCHAR(50), rate FLOAT);", "reference_sql": "SELECT AVG(rate) FROM recycling_rates;", "generated_sql": "SELECT AVG(rate) AS average_recycling_rate\nFROM recycling_rates;", "raw_model_output": "```sql\nSELECT AVG(rate) AS average_recycling_rate\nFROM recycling_rates;\n```", "latency_sec": 0.70701003074646, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 91, "prompt_eval_sec": null, "tokens_completion": 19, "completion_eval_sec": null, "tokens_total": 110, "tokens_per_sec": 155.58477987060834, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average of the 'rate' column from the 'recycling_rates' table. The generated query adds an alias ('average_recycling_rate') to the result, but this does not affect the computed value. The semantic result (the average value) remains identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the average recycling rate using AVG(rate). The reference query is more concise while the generated query adds an explicit alias. The alias in the generated query improves readability but doesn't alter the mathematical result. Since the original question didn't specify formatting requirements, both satisfy the business intent equally. The technical equivalence is confirmed by identical execution plans and results. Neither query is more efficient than the other as they perform the same aggregation operation.", "overall_assessment": "correct"}}
{"example_id": 1533, "sql_complexity": "subqueries", "prompt": "Which programs had the highest volunteer participation rate in the last quarter?", "context": "CREATE TABLE Programs (ProgramID INT, ProgramName TEXT, Budget DECIMAL(10,2), NumVolunteers INT); CREATE TABLE VolunteerEvents (EventID INT, ProgramID INT, EventDate DATE, NumVolunteers INT);", "reference_sql": "SELECT p.ProgramName, COUNT(v.EventID) / (SELECT COUNT(*) FROM VolunteerEvents WHERE EventDate >= DATEADD(quarter, -1, GETDATE())) * 100.0 AS VolunteerParticipationRate FROM Programs p INNER JOIN VolunteerEvents v ON p.ProgramID = v.ProgramID WHERE v.EventDate >= DATEADD(quarter, -1, GETDATE()) GROUP BY p.ProgramName ORDER BY VolunteerParticipationRate DESC;", "generated_sql": "WITH LastQuarter AS (\n    SELECT \n        DATE_TRUNC('quarter', CURRENT_DATE) - INTERVAL '3 months' AS StartDate,\n        DATE_TRUNC('quarter', CURRENT_DATE) - INTERVAL '1 day' AS EndDate\n),\nProgramVolunteerTotals AS (\n    SELECT \n        p.ProgramID,\n        p.ProgramName,\n        COALESCE(SUM(ve.NumVolunteers), 0) AS TotalVolunteers\n    FROM Programs p\n    LEFT JOIN VolunteerEvents ve ON p.ProgramID = ve.ProgramID\n    CROSS JOIN LastQuarter lq\n    WHERE ve.EventDate BETWEEN lq.StartDate AND lq.EndDate\n       OR ve.EventDate IS NULL\n    GROUP BY p.ProgramID, p.ProgramName\n),\nMaxVolunteers AS (\n    SELECT MAX(TotalVolunteers) AS MaxVol FROM ProgramVolunteerTotals\n)\nSELECT pvt.ProgramID, pvt.ProgramName, pvt.TotalVolunteers\nFROM ProgramVolunteerTotals pvt\nJOIN MaxVolunteers mv ON pvt.TotalVolunteers = mv.MaxVol;", "raw_model_output": "```sql\nWITH LastQuarter AS (\n    SELECT \n        DATE_TRUNC('quarter', CURRENT_DATE) - INTERVAL '3 months' AS StartDate,\n        DATE_TRUNC('quarter', CURRENT_DATE) - INTERVAL '1 day' AS EndDate\n),\nProgramVolunteerTotals AS (\n    SELECT \n        p.ProgramID,\n        p.ProgramName,\n        COALESCE(SUM(ve.NumVolunteers), 0) AS TotalVolunteers\n    FROM Programs p\n    LEFT JOIN VolunteerEvents ve ON p.ProgramID = ve.ProgramID\n    CROSS JOIN LastQuarter lq\n    WHERE ve.EventDate BETWEEN lq.StartDate AND lq.EndDate\n       OR ve.EventDate IS NULL\n    GROUP BY p.ProgramID, p.ProgramName\n),\nMaxVolunteers AS (\n    SELECT MAX(TotalVolunteers) AS MaxVol FROM ProgramVolunteerTotals\n)\nSELECT pvt.ProgramID, pvt.ProgramName, pvt.TotalVolunteers\nFROM ProgramVolunteerTotals pvt\nJOIN MaxVolunteers mv ON pvt.TotalVolunteers = mv.MaxVol;\n```", "latency_sec": 2.4957730770111084, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 127, "prompt_eval_sec": null, "tokens_completion": 220, "completion_eval_sec": null, "tokens_total": 347, "tokens_per_sec": 139.03507622398138, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The reference query calculates a volunteer participation rate (event count ratio) for each program, while the generated query computes total volunteers per program and identifies the maximum. The metrics (rate vs. absolute numbers), aggregation methods (COUNT vs. SUM), and final results (ranked rates vs. top total volunteers) differ fundamentally.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent. The reference query calculates a participation rate as (program event count / total events in last quarter) * 100, while the generated query calculates absolute volunteer totals. The reference attempts to address 'participation rate' as a percentage, but the generated query focuses on total volunteers without normalizing for comparison. Neither query perfectly captures 'volunteer participation rate' (which likely requires volunteers / capacity or similar), but the reference better aligns with the intent of measuring relative participation. The generated query fails to calculate a rate and instead identifies programs with the highest absolute volunteer counts, which doesn't answer the original question.", "overall_assessment": "differently_correct"}}
{"example_id": 4021, "sql_complexity": "subqueries", "prompt": "What is the percentage of energy efficiency improvement, per sector, compared to 2015 levels?", "context": "CREATE TABLE energy_efficiency (id INT, sector VARCHAR(50), year INT, efficiency FLOAT); INSERT INTO energy_efficiency (id, sector, year, efficiency) VALUES (1, 'Industry', 2015, 100.0), (2, 'Industry', 2020, 105.0), (3, 'Residential', 2015, 100.0), (4, 'Residential', 2020, 103.0);", "reference_sql": "SELECT sector, (SUM(efficiency) / (SELECT SUM(efficiency) FROM energy_efficiency WHERE year = 2015 AND sector = e.sector) * 100.0) - 100.0 AS improvement FROM energy_efficiency e WHERE year = 2020 GROUP BY sector;", "generated_sql": "SELECT \n    sector,\n    ((MAX(CASE WHEN year = 2020 THEN efficiency END) - MAX(CASE WHEN year = 2015 THEN efficiency END)) / MAX(CASE WHEN year = 2015 THEN efficiency END)) * 100 AS efficiency_improvement_percentage\nFROM \n    energy_efficiency\nWHERE \n    year IN (2015, 2020)\nGROUP BY \n    sector;", "raw_model_output": "```sql\nSELECT \n    sector,\n    ((MAX(CASE WHEN year = 2020 THEN efficiency END) - MAX(CASE WHEN year = 2015 THEN efficiency END)) / MAX(CASE WHEN year = 2015 THEN efficiency END)) * 100 AS efficiency_improvement_percentage\nFROM \n    energy_efficiency\nWHERE \n    year IN (2015, 2020)\nGROUP BY \n    sector;\n```", "latency_sec": 0.933783769607544, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 181, "prompt_eval_sec": null, "tokens_completion": 88, "completion_eval_sec": null, "tokens_total": 269, "tokens_per_sec": 288.07525762956544, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in how they calculate efficiency improvements. The Reference SQL uses SUM(efficiency) for 2020 and divides by the 2015 SUM for the same sector, while the Generated SQL uses MAX() to extract individual 2020 and 2015 values. If there are multiple entries per sector/year, SUM would aggregate values while MAX would only take the highest value, leading to different results. Though they produce the same output for the given data (single entry per sector/year), they are not semantically equivalent in general.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the percentage improvement in energy efficiency per sector compared to 2015. The Reference SQL uses SUM with a correlated subquery, while the Generated SQL uses conditional aggregation. For the given data (one entry per sector/year), both produce identical results. However, the Generated SQL is more efficient as it avoids a correlated subquery and explicitly handles 2015/2020 values with CASE statements. It also better handles potential edge cases (e.g., multiple entries per sector/year) if modified to use AVG/SUM instead of MAX, though the current implementation works for the provided schema.", "overall_assessment": "correct"}}
{"example_id": 1551, "sql_complexity": "single join", "prompt": "How many unique donors made donations in the healthcare industry in Q3 2022?", "context": "CREATE TABLE donations (id INT, donor_id INT, amount FLOAT, donation_date DATE); INSERT INTO donations (id, donor_id, amount, donation_date) VALUES (1, 7, 100, '2022-07-01'); INSERT INTO donations (id, donor_id, amount, donation_date) VALUES (2, 8, 200, '2022-09-15'); INSERT INTO donors (id, name, industry, first_donation_date DATE) VALUES (7, 'Charlie Davis', 'Healthcare', '2022-07-01'); INSERT INTO donors (id, name, industry, first_donation_date DATE) VALUES (8, 'Dana Wilson', 'Healthcare', '2022-09-15');", "reference_sql": "SELECT COUNT(DISTINCT donor_id) FROM donations d JOIN donors don ON d.donor_id = don.id WHERE industry = 'Healthcare' AND donation_date BETWEEN '2022-07-01' AND '2022-09-30';", "generated_sql": "SELECT COUNT(DISTINCT d.donor_id) AS unique_donors\nFROM donations d\nJOIN donors r ON d.donor_id = r.id\nWHERE r.industry = 'Healthcare'\n  AND d.donation_date >= '2022-07-01'\n  AND d.donation_date < '2022-10-01';", "raw_model_output": "```sql\nSELECT COUNT(DISTINCT d.donor_id) AS unique_donors\nFROM donations d\nJOIN donors r ON d.donor_id = r.id\nWHERE r.industry = 'Healthcare'\n  AND d.donation_date >= '2022-07-01'\n  AND d.donation_date < '2022-10-01';\n```", "latency_sec": 1.4956507682800293, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 236, "prompt_eval_sec": null, "tokens_completion": 75, "completion_eval_sec": null, "tokens_total": 311, "tokens_per_sec": 207.93624193276366, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count distinct donor_ids from donations joined with donors where industry is 'Healthcare' and donation dates fall within the same range. The date conditions are equivalent: 'BETWEEN '2022-07-01' AND '2022-09-30'' (inclusive) matches 'donation_date >= '2022-07-01' AND donation_date < '2022-10-01'' (exclusive upper bound). The COUNT(DISTINCT) syntax and join logic are identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly count unique healthcare donors who made donations in Q3 2022. The reference query uses BETWEEN '2022-07-01' AND '2022-09-30' while the generated query uses >= '2022-07-01' and < '2022-10-01'. These date ranges are functionally equivalent for DATE-typed donation_date values. Both use COUNT(DISTINCT donor_id) after joining donations with donors on donor_id, and filter for industry = 'Healthcare'. The generated query uses more explicit date boundaries (avoiding potential edge cases with BETWEEN) but achieves the same result. The different table aliases (don vs r) have no impact on functionality.", "overall_assessment": "correct"}}
{"example_id": 2592, "sql_complexity": "window functions", "prompt": "What is the third highest account balance for Shariah-compliant finance customers?", "context": "CREATE TABLE shariah_compliant_finance(customer_id INT, account_balance DECIMAL(10, 2)); INSERT INTO shariah_compliant_finance VALUES (1, 5000), (2, 7000), (3, 6000), (4, 8000), (5, 9000);", "reference_sql": "SELECT account_balance FROM (SELECT account_balance, RANK() OVER (ORDER BY account_balance DESC) as rn FROM shariah_compliant_finance) t WHERE rn = 3;", "generated_sql": "SELECT DISTINCT account_balance\nFROM shariah_compliant_finance\nORDER BY account_balance DESC\nLIMIT 1 OFFSET 2;", "raw_model_output": "```sql\nSELECT DISTINCT account_balance\nFROM shariah_compliant_finance\nORDER BY account_balance DESC\nLIMIT 1 OFFSET 2;\n```", "latency_sec": 0.5715928077697754, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 151, "prompt_eval_sec": null, "tokens_completion": 32, "completion_eval_sec": null, "tokens_total": 183, "tokens_per_sec": 320.15798224268116, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the third highest account balance. The reference query uses RANK() to find the 3rd rank, while the generated query uses ORDER BY with LIMIT/OFFSET. In the given data, account balances are unique, so both approaches return the same value (7000).", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries return the third highest account balance (7000) in the provided sample data. The Reference SQL uses RANK() which handles ties by assigning the same rank, but the sample data has unique values. The Generated SQL uses a simpler approach with LIMIT/OFFSET, which is more efficient for this specific case. While RANK() is theoretically more robust for ties, the Generated SQL is technically equivalent here and more concise. Both fulfill the business intent of finding the third highest balance, but the Generated SQL is more efficient.", "overall_assessment": "correct"}}
{"example_id": 3795, "sql_complexity": "single join", "prompt": "What is the total quantity of unsold garments for each manufacturer based in 'Italy' or 'Spain'?", "context": "CREATE TABLE manufacturers (id INT PRIMARY KEY, name VARCHAR(255), country VARCHAR(255)); CREATE TABLE garments (id INT PRIMARY KEY, manufacturer_id INT, quantity_manufactured INT, quantity_sold INT);", "reference_sql": "SELECT m.name, SUM(g.quantity_manufactured - g.quantity_sold) as total_unsold_quantity FROM manufacturers m JOIN garments g ON m.id = g.manufacturer_id WHERE m.country IN ('Italy', 'Spain') GROUP BY m.name;", "generated_sql": "SELECT m.name, SUM(g.quantity_manufactured - g.quantity_sold) AS total_unsold_quantity\nFROM manufacturers m\nJOIN garments g ON m.id = g.manufacturer_id\nWHERE m.country IN ('Italy', 'Spain')\nGROUP BY m.name;", "raw_model_output": "```sql\nSELECT m.name, SUM(g.quantity_manufactured - g.quantity_sold) AS total_unsold_quantity\nFROM manufacturers m\nJOIN garments g ON m.id = g.manufacturer_id\nWHERE m.country IN ('Italy', 'Spain')\nGROUP BY m.name;\n```", "latency_sec": 0.7293121814727783, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 132, "prompt_eval_sec": null, "tokens_completion": 58, "completion_eval_sec": null, "tokens_total": 190, "tokens_per_sec": 260.5194384883475, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select manufacturer names and calculate total unsold quantities by subtracting quantity_sold from quantity_manufactured, filtering for Italy and Spain, and grouping by manufacturer name. The formatting differences (e.g., line breaks) do not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "The reference and generated SQL queries are identical in structure, logic, and syntax. Both correctly calculate the total unsold garments (quantity_manufactured - quantity_sold) for manufacturers in 'Italy' or 'Spain' by joining the manufacturers and garments tables, applying the country filter, and grouping by manufacturer name. The queries are semantically equivalent, fulfill the business intent of determining unsold inventory for specified countries, and are equally efficient and elegant. No differences exist between them.", "overall_assessment": "correct"}}
{"example_id": 4138, "sql_complexity": "window functions", "prompt": "How many lifelong learning courses has a student with ID '2' completed, in chronological order?", "context": "CREATE TABLE lifelong_learning (student_id INT, course_id INT, completion_date DATE); INSERT INTO lifelong_learning VALUES (2, 1001, '2015-01-01'), (2, 1002, '2016-01-01');", "reference_sql": "SELECT student_id, course_id, COUNT(course_id) OVER (PARTITION BY student_id ORDER BY completion_date) as completed_courses FROM lifelong_learning WHERE student_id = 2;", "generated_sql": "SELECT COUNT(*) AS completed_courses_count\nFROM lifelong_learning\nWHERE student_id = 2\nORDER BY completion_date;", "raw_model_output": "SELECT COUNT(*) AS completed_courses_count\nFROM lifelong_learning\nWHERE student_id = 2\nORDER BY completion_date;", "latency_sec": 0.5341110229492188, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 138, "prompt_eval_sec": null, "tokens_completion": 25, "completion_eval_sec": null, "tokens_total": 163, "tokens_per_sec": 305.17999628608567, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns multiple rows with a cumulative count of courses per student, while the Generated SQL returns a single total count. The Reference includes course_id and a window function, whereas the Generated only counts total rows without per-row aggregation.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query uses a window function to create a running total of courses per student, returning multiple rows with incremental counts (e.g., 1, 2 for two courses). The generated query correctly counts total courses (returns 2) but lacks the explicit chronological ordering in its output. However, the original question asks for a count, not a running total. While the generated query's ORDER BY is redundant for a count, it technically answers the core question. The reference query fails to fulfill the intent as it returns per-row counts instead of a single total. The generated query is more efficient and directly addresses the count requirement.", "overall_assessment": "differently_correct"}}
{"example_id": 312, "sql_complexity": "aggregation", "prompt": "List the top 3 most represented ethnicities in movies produced in the USA.", "context": "CREATE TABLE movies (title VARCHAR(255), production_country VARCHAR(64), lead_actor_ethnicity VARCHAR(64));", "reference_sql": "SELECT lead_actor_ethnicity, COUNT(*) AS count FROM movies WHERE production_country = 'USA' GROUP BY lead_actor_ethnicity ORDER BY count DESC LIMIT 3;", "generated_sql": "SELECT lead_actor_ethnicity, COUNT(*) AS count\nFROM movies\nWHERE production_country = 'USA'\nGROUP BY lead_actor_ethnicity\nORDER BY count DESC\nLIMIT 3;", "raw_model_output": "SELECT lead_actor_ethnicity, COUNT(*) AS count\nFROM movies\nWHERE production_country = 'USA'\nGROUP BY lead_actor_ethnicity\nORDER BY count DESC\nLIMIT 3;", "latency_sec": 0.5956869125366211, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 106, "prompt_eval_sec": null, "tokens_completion": 38, "completion_eval_sec": null, "tokens_total": 144, "tokens_per_sec": 241.73772659668313, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select the lead_actor_ethnicity and count of movies from the movies table where production_country is 'USA', group by lead_actor_ethnicity, order by count descending, and limit to 3 results. The only differences are whitespace and formatting, which do not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "The reference and generated queries are identical in structure, logic, and syntax. Both correctly filter USA-produced movies, group by lead_actor_ethnicity, count occurrences, order by count descending, and limit to top 3 results. They perfectly address the business intent of identifying the most represented ethnicities in US movies. Since they are functionally identical, neither is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 4298, "sql_complexity": "single join", "prompt": "How many users joined the gym in Q1 2023?", "context": "CREATE TABLE memberships (id INT, user_id INT, join_date DATE); INSERT INTO memberships (id, user_id, join_date) VALUES (1, 5, '2023-01-15'), (2, 6, '2023-02-03'), (3, 7, '2023-03-20'), (4, 8, '2022-12-31');", "reference_sql": "SELECT COUNT(*) FROM memberships WHERE join_date BETWEEN '2023-01-01' AND '2023-03-31';", "generated_sql": "SELECT COUNT(DISTINCT user_id) AS users_joined_q1_2023\nFROM memberships\nWHERE join_date >= '2023-01-01' AND join_date < '2023-04-01';", "raw_model_output": "```sql\nSELECT COUNT(DISTINCT user_id) AS users_joined_q1_2023\nFROM memberships\nWHERE join_date >= '2023-01-01' AND join_date < '2023-04-01';\n```", "latency_sec": 0.6658880710601807, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 164, "prompt_eval_sec": null, "tokens_completion": 50, "completion_eval_sec": null, "tokens_total": 214, "tokens_per_sec": 321.37533213244694, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query uses COUNT(*) to count all rows in the date range, while the generated query uses COUNT(DISTINCT user_id) which would return a different value if there are multiple memberships per user. Additionally, the date range in the generated query (using >= and <) is functionally equivalent to BETWEEN, but the counting mechanism differs.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "While both queries correctly filter for Q1 2023 dates, they differ in counting logic. The reference query uses COUNT(*), which counts all rows, potentially overcounting if users have multiple memberships. The generated query uses COUNT(DISTINCT user_id), which accurately counts unique users. The date ranges are functionally equivalent (BETWEEN '2023-01-01' AND '2023-03-31' vs. >= '2023-01-01' AND < '2023-04-01'), but the generated query's explicit date boundary is more robust for datetime values. The generated query better fulfills the business intent of counting distinct users.", "overall_assessment": "differently_correct"}}
{"example_id": 5211, "sql_complexity": "multiple_joins", "prompt": "What is the average transaction value in the last week, split by product category and customer demographics?", "context": "CREATE TABLE transactions (transaction_id INT, customer_id INT, product_id INT, category_id INT, transaction_date DATE, amount DECIMAL(10,2)); CREATE TABLE customers (customer_id INT, age INT, gender VARCHAR(10), location VARCHAR(255)); CREATE TABLE products (product_id INT, name VARCHAR(255), category_id INT);", "reference_sql": "SELECT c.age, c.gender, p.category_id, AVG(t.amount) as avg_transaction_value FROM transactions t INNER JOIN customers c ON t.customer_id = c.customer_id INNER JOIN products p ON t.product_id = p.product_id WHERE t.transaction_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 WEEK) GROUP BY c.age, c.gender, p.category_id;", "generated_sql": "SELECT \n    t.category_id,\n    c.age,\n    c.gender,\n    c.location,\n    AVG(t.amount) AS average_transaction_value\nFROM \n    transactions t\nJOIN \n    customers c ON t.customer_id = c.customer_id\nWHERE \n    t.transaction_date >= CURRENT_DATE - INTERVAL '7' DAY\nGROUP BY \n    t.category_id,\n    c.age,\n    c.gender,\n    c.location\nORDER BY\n    t.category_id,\n    c.age,\n    c.gender,\n    c.location;", "raw_model_output": "```sql\nSELECT \n    t.category_id,\n    c.age,\n    c.gender,\n    c.location,\n    AVG(t.amount) AS average_transaction_value\nFROM \n    transactions t\nJOIN \n    customers c ON t.customer_id = c.customer_id\nWHERE \n    t.transaction_date >= CURRENT_DATE - INTERVAL '7' DAY\nGROUP BY \n    t.category_id,\n    c.age,\n    c.gender,\n    c.location\nORDER BY\n    t.category_id,\n    c.age,\n    c.gender,\n    c.location;\n```", "latency_sec": 1.1392860412597656, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 156, "prompt_eval_sec": null, "tokens_completion": 111, "completion_eval_sec": null, "tokens_total": 267, "tokens_per_sec": 234.35729951081007, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in several key aspects.  The Reference query includes the 'products' table and groups by 'p.category_id', while the Generated query doesn't join the 'products' table and groups by 't.category_id'.  Additionally, the Generated query includes 'c.location' in the SELECT and GROUP BY clauses, which are absent in the Reference query.  These differences in selected columns and grouping criteria will result in different output.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in three key areas: 1) The generated query includes 'location' in the GROUP BY clause, which is part of customer demographics (though not explicitly requested, it's a valid demographic attribute). 2) The reference query unnecessarily joins with the 'products' table when 'category_id' is already present in the 'transactions' table. 3) The date calculation syntax differs (DATE_SUB vs. CURRENT_DATE - INTERVAL '7' DAY) but both are valid. The generated query is more efficient by avoiding the redundant join and provides more detailed demographic segmentation. Both fulfill the core intent of splitting by category and demographics, but the generated query offers better granularity and performance.", "overall_assessment": "differently_correct"}}
{"example_id": 382, "sql_complexity": "window functions", "prompt": "What is the average annual precipitation in the past 10 years for each weather station?", "context": "CREATE TABLE WeatherStation (ID INT, Name VARCHAR(100), Location VARCHAR(100), Elevation FLOAT, AnnualPrecipitation FLOAT); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (1, 'Station A', 'Arctic Circle', 100, 450); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (2, 'Station B', 'North Pole', 200, 300);", "reference_sql": "SELECT Name, AVG(AnnualPrecipitation) OVER (PARTITION BY Name ORDER BY Name ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS AvgAnnualPrecipitation FROM WeatherStation WHERE YEAR(CurrentDate) - YEAR(DateInstalled) BETWEEN 1 AND 10;", "generated_sql": "SELECT Name, AVG(AnnualPrecipitation) AS AverageAnnualPrecipitation\nFROM WeatherStation\nGROUP BY Name;", "raw_model_output": "SELECT Name, AVG(AnnualPrecipitation) AS AverageAnnualPrecipitation\nFROM WeatherStation\nGROUP BY Name;", "latency_sec": 0.560866117477417, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 187, "prompt_eval_sec": null, "tokens_completion": 26, "completion_eval_sec": null, "tokens_total": 213, "tokens_per_sec": 379.76977635589895, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL contains a WHERE clause referencing a non-existent 'DateInstalled' column, making it invalid. Additionally, even if this were resolved, the Reference SQL uses a window function that returns one row per original row (with duplicate averages for each Name), while the Generated SQL groups results into one row per Name. The semantic structure and output format differ fundamentally.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference SQL contains a critical technical error: it references a non-existent 'DateInstalled' column in the WHERE clause. The generated SQL is syntactically correct but lacks filtering for the 'past 10 years' requirement. However, the schema's design is problematic - the 'AnnualPrecipitation' column appears to store a single value per station rather than yearly data, making both queries ill-suited to calculate a 10-year average. The generated query correctly groups by station and calculates an average, but the schema's limitations prevent proper implementation of the time-based filter.", "overall_assessment": "differently_correct"}}
{"example_id": 2190, "sql_complexity": "single join", "prompt": "What is the total number of humanitarian assistance events by each country in the last 3 years?", "context": "CREATE TABLE Humanitarian_Assistance (id INT, country VARCHAR(50), year INT, events INT); CREATE TABLE Countries (id INT, name VARCHAR(50), region VARCHAR(50));", "reference_sql": "SELECT co.name, SUM(ha.events) FROM Humanitarian_Assistance ha INNER JOIN Countries co ON ha.country = co.name WHERE ha.year BETWEEN (YEAR(CURRENT_DATE) - 3) AND YEAR(CURRENT_DATE) GROUP BY co.name;", "generated_sql": "SELECT ha.country, SUM(ha.events) AS total_events\nFROM Humanitarian_Assistance ha\nWHERE ha.year >= (SELECT MAX(year) FROM Humanitarian_Assistance) - 2\nGROUP BY ha.country;", "raw_model_output": "SELECT ha.country, SUM(ha.events) AS total_events\nFROM Humanitarian_Assistance ha\nWHERE ha.year >= (SELECT MAX(year) FROM Humanitarian_Assistance) - 2\nGROUP BY ha.country;", "latency_sec": 1.3114690780639648, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 124, "prompt_eval_sec": null, "tokens_completion": 45, "completion_eval_sec": null, "tokens_total": 169, "tokens_per_sec": 128.86312214809024, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their year filtering logic and table joining. The reference query uses a 4-year range (current year -3 to current) and joins with the Countries table, while the generated query uses a 3-year range (max year -2) and omits the join. Additionally, the generated query's subquery for max year may not align with the reference's current year calculation, leading to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query is technically incorrect because it uses BETWEEN (YEAR(CURRENT_DATE) - 3) AND YEAR(CURRENT_DATE), which includes 4 years (e.g., 2020-2023 when current year is 2023) instead of the required 3 years. The generated query correctly uses (SELECT MAX(year) FROM Humanitarian_Assistance) - 2 to capture exactly 3 years (e.g., 2021-2023 if max year is 2023). However, the generated query lacks a join with the Countries table, which might be necessary if the Humanitarian_Assistance.country field requires mapping to country names in the Countries table. While the reference query's join is unnecessary for the current question (since it only asks for country names from Humanitarian_Assistance), the generated query's logic better aligns with the 'last 3 years' requirement. The generated query is more efficient as it avoids the join and uses a subquery to determine the time window.", "overall_assessment": "differently_correct"}}
{"example_id": 1852, "sql_complexity": "set operations", "prompt": "Compare coal production and employment rates in China and India between 2018 and 2020.", "context": "CREATE TABLE china_coal_production (year INT, production FLOAT); INSERT INTO china_coal_production (year, production) VALUES (2018, 3500.0), (2019, 3600.0), (2020, 3700.0); CREATE TABLE china_employment (year INT, employment FLOAT); INSERT INTO china_employment (year, employment) VALUES (2018, 8000000.0), (2019, 8100000.0), (2020, 8200000.0); CREATE TABLE india_coal_production (year INT, production FLOAT); INSERT INTO india_coal_production (year, production) VALUES (2018, 700.0), (2019, 750.0), (2020, 800.0); CREATE TABLE india_employment (year INT, employment FLOAT); INSERT INTO india_employment (year, employment) VALUES (2018, 1000000.0), (2019, 1050000.0), (2020, 1100000.0);", "reference_sql": "SELECT 'China' AS country, china_coal_production.production, china_employment.employment FROM china_coal_production INNER JOIN china_employment ON china_coal_production.year = china_employment.year WHERE china_coal_production.year BETWEEN 2018 AND 2020 UNION ALL SELECT 'India', india_coal_production.production, india_employment.employment FROM india_coal_production INNER JOIN india_employment ON india_coal_production.year = india_employment.year WHERE india_coal_production.year BETWEEN 2018 AND 2020;", "generated_sql": "SELECT \n    ccp.year,\n    ccp.production AS china_coal_production,\n    ce.employment AS china_employment,\n    icp.production AS india_coal_production,\n    ie.employment AS india_employment\nFROM \n    china_coal_production ccp\nJOIN \n    china_employment ce ON ccp.year = ce.year\nJOIN \n    india_coal_production icp ON ccp.year = icp.year\nJOIN \n    india_employment ie ON ccp.year = ie.year\nWHERE \n    ccp.year BETWEEN 2018 AND 2020\nORDER BY \n    ccp.year;", "raw_model_output": "SELECT \n    ccp.year,\n    ccp.production AS china_coal_production,\n    ce.employment AS china_employment,\n    icp.production AS india_coal_production,\n    ie.employment AS india_employment\nFROM \n    china_coal_production ccp\nJOIN \n    china_employment ce ON ccp.year = ce.year\nJOIN \n    india_coal_production icp ON ccp.year = icp.year\nJOIN \n    india_employment ie ON ccp.year = ie.year\nWHERE \n    ccp.year BETWEEN 2018 AND 2020\nORDER BY \n    ccp.year;", "latency_sec": 1.435394048690796, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 309, "prompt_eval_sec": null, "tokens_completion": 131, "completion_eval_sec": null, "tokens_total": 440, "tokens_per_sec": 306.5360347573673, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two rows per year (China and India) with separate columns for production and employment, while the Generated SQL returns one row per year with all four columns (China and India production/employment side-by-side). The structure and number of rows differ, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The Reference SQL returns separate rows for China and India per year (6 rows total), while the Generated SQL returns one row per year with combined data (3 rows total). Both correctly answer the business question by comparing production/employment metrics, but the Generated query provides a more integrated view that directly aligns with the comparative analysis request. The Generated query is more efficient as it avoids UNION ALL and presents data in a normalized format, making cross-country comparisons easier. The Reference query requires additional post-processing to compare countries side-by-side.", "overall_assessment": "differently_correct"}}
{"example_id": 2535, "sql_complexity": "subqueries", "prompt": "What is the maximum safety rating for vehicles in the vehiclesafety schema?", "context": "CREATE TABLE VehicleSafety (id INT, vehicle_id INT, safetyrating INT, PRIMARY KEY (id)); CREATE TABLE Vehicles (id INT, make VARCHAR(50), model VARCHAR(50), PRIMARY KEY (id)); CREATE TABLE LuxuryVehicles (id INT, vehicle_id INT, PRIMARY KEY (id), FOREIGN KEY (vehicle_id) REFERENCES Vehicles(id));", "reference_sql": "SELECT MAX(safetyrating) FROM vehicleSafety JOIN Vehicles ON vehicleSafety.vehicle_id = Vehicles.id WHERE EXISTS (SELECT * FROM LuxuryVehicles WHERE Vehicles.id = LuxuryVehicles.vehicle_id);", "generated_sql": "SELECT MAX(safetyrating) AS max_safety_rating\nFROM VehicleSafety;", "raw_model_output": "```sql\nSELECT MAX(safetyrating) AS max_safety_rating\nFROM VehicleSafety;\n```", "latency_sec": 0.6855227947235107, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 153, "prompt_eval_sec": null, "tokens_completion": 22, "completion_eval_sec": null, "tokens_total": 175, "tokens_per_sec": 255.27962213215983, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters vehicles to only those that exist in LuxuryVehicles via the EXISTS clause, while the Generated SQL retrieves the maximum safetyrating from all entries in VehicleSafety without any filtering. The Generated SQL lacks the join and EXISTS condition, so it may include safety ratings from non-luxury vehicles, leading to potentially different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query incorrectly filters results to only luxury vehicles using the EXISTS clause with LuxuryVehicles, while the original question makes no mention of luxury vehicles. The generated query directly retrieves the maximum safety rating from the VehicleSafety table, which is the most straightforward and technically correct approach for the stated question. The reference query introduces an unnecessary constraint that changes the result set, making them non-equivalent. The generated query is more efficient as it avoids unnecessary joins and subqueries.", "overall_assessment": "correct"}}
{"example_id": 2140, "sql_complexity": "aggregation", "prompt": "What was the total amount of minerals extracted in the 'north' region for each month in 2020?", "context": "CREATE TABLE extraction(id INT, location TEXT, month INT, year INT, minerals_extracted FLOAT);INSERT INTO extraction(id, location, month, year, minerals_extracted) VALUES (1, 'north', 1, 2020, 1500), (2, 'north', 2, 2020, 1800), (3, 'south', 1, 2020, 1200);", "reference_sql": "SELECT month, SUM(minerals_extracted) FROM extraction WHERE location = 'north' AND year = 2020 GROUP BY month;", "generated_sql": "SELECT month, SUM(minerals_extracted) AS total_minerals_extracted\nFROM extraction\nWHERE location = 'north' AND year = 2020\nGROUP BY month\nORDER BY month;", "raw_model_output": "```sql\nSELECT month, SUM(minerals_extracted) AS total_minerals_extracted\nFROM extraction\nWHERE location = 'north' AND year = 2020\nGROUP BY month\nORDER BY month;\n```", "latency_sec": 0.6582608222961426, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 176, "prompt_eval_sec": null, "tokens_completion": 47, "completion_eval_sec": null, "tokens_total": 223, "tokens_per_sec": 338.7714906412512, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of minerals_extracted per month for 'north' location in 2020. The generated query adds an ORDER BY clause, which affects result ordering but not the semantic content. Since SQL result sets are inherently unordered, the additional sorting does not change the semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically equivalent as they produce identical results through the same logic (filtering 'north' region and 2020 year, grouping by month, and summing minerals_extracted). The generated query improves upon the reference by adding an explicit column alias (total_minerals_extracted) for clarity and an ORDER BY clause to ensure results are sorted by month, which aligns with the natural expectation of monthly data. While the reference query is correct, the generated version is more readable and practical for end-users. Both fulfill the business intent of calculating monthly totals for the 'north' region in 2020.", "overall_assessment": "correct"}}
{"example_id": 4779, "sql_complexity": "window functions", "prompt": "What is the average CO2 emission for the top 3 highest emitting countries since 2015?", "context": "CREATE TABLE emissions (country VARCHAR(50), year INT, co2_emission INT); INSERT INTO emissions (country, year, co2_emission) VALUES ('USA', 2015, 5373978000); INSERT INTO emissions (country, year, co2_emission) VALUES ('China', 2015, 10498600000); INSERT INTO emissions (country, year, co2_emission) VALUES ('India', 2015, 2633830000); INSERT INTO emissions (country, year, co2_emission) VALUES ('USA', 2016, 5518004000); INSERT INTO emissions (country, year, co2_emission) VALUES ('China', 2016, 10813000000); INSERT INTO emissions (country, year, co2_emission) VALUES ('India', 2016, 2799280000);", "reference_sql": "SELECT AVG(co2_emission) as avg_emission FROM (SELECT country, year, co2_emission, ROW_NUMBER() OVER (ORDER BY co2_emission DESC) as rn FROM emissions WHERE year >= 2015) t WHERE rn <= 3 GROUP BY country;", "generated_sql": "WITH avg_emissions AS (\n    SELECT country, AVG(co2_emission) AS avg_co2\n    FROM emissions\n    WHERE year >= 2015\n    GROUP BY country\n),\ntop3_countries AS (\n    SELECT country\n    FROM avg_emissions\n    ORDER BY avg_co2 DESC\n    LIMIT 3\n)\nSELECT AVG(avg_co2) AS average_co2_emission_top3\nFROM avg_emissions\nWHERE country IN (SELECT country FROM top3_countries);", "raw_model_output": "```sql\nWITH avg_emissions AS (\n    SELECT country, AVG(co2_emission) AS avg_co2\n    FROM emissions\n    WHERE year >= 2015\n    GROUP BY country\n),\ntop3_countries AS (\n    SELECT country\n    FROM avg_emissions\n    ORDER BY avg_co2 DESC\n    LIMIT 3\n)\nSELECT AVG(avg_co2) AS average_co2_emission_top3\nFROM avg_emissions\nWHERE country IN (SELECT country FROM top3_countries);\n```", "latency_sec": 0.9984560012817383, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 267, "prompt_eval_sec": null, "tokens_completion": 106, "completion_eval_sec": null, "tokens_total": 373, "tokens_per_sec": 373.5768021036203, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the average of the top 3 co2_emission values (across all countries) grouped by country, while the Generated SQL first computes average emissions per country, then averages the top 3 countries by their average. The Reference SQL's grouping by country after selecting top 3 emissions leads to different results compared to the Generated SQL's approach of averaging top 3 countries' averages.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL incorrectly groups by country after selecting top 3 rows, which would average emissions for individual years rather than countries. It fails to properly identify the top 3 countries by total emissions. The Generated SQL correctly calculates country-level averages first, identifies the top 3 countries by these averages, and then computes the final average. While both queries have issues with the ambiguous question (whether to use total or average emissions), the Generated SQL better aligns with the business intent of analyzing country-level performance.", "overall_assessment": "differently_correct"}}
{"example_id": 1015, "sql_complexity": "subqueries", "prompt": "List the top 3 most expensive eco-friendly products in Europe and their suppliers.", "context": "CREATE TABLE Suppliers (supplierID INT, supplierName VARCHAR(50), country VARCHAR(50)); CREATE TABLE Products (productID INT, productName VARCHAR(50), price DECIMAL(10,2), ecoFriendly BOOLEAN, supplierID INT);", "reference_sql": "SELECT P.productName, P.price, S.supplierName FROM (SELECT * FROM Products WHERE ecoFriendly = TRUE ORDER BY price DESC LIMIT 3) P JOIN Suppliers S ON P.supplierID = S.supplierID;", "generated_sql": "SELECT p.productName, p.price, s.supplierName\nFROM Products p\nJOIN Suppliers s ON p.supplierID = s.supplierID\nWHERE p.ecoFriendly = TRUE\n  AND s.country = 'Europe'\nORDER BY p.price DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT p.productName, p.price, s.supplierName\nFROM Products p\nJOIN Suppliers s ON p.supplierID = s.supplierID\nWHERE p.ecoFriendly = TRUE\n  AND s.country = 'Europe'\nORDER BY p.price DESC\nLIMIT 3;\n```", "latency_sec": 0.9759540557861328, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 132, "prompt_eval_sec": null, "tokens_completion": 62, "completion_eval_sec": null, "tokens_total": 194, "tokens_per_sec": 198.7798491638345, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the filtering condition. The Reference SQL does not restrict by supplier country, while the Generated SQL includes an additional WHERE clause (s.country = 'Europe'). This makes the Generated SQL more restrictive, potentially returning fewer rows. The order of operations (ordering/limiting before joining vs. joining first) could also affect results if there are multiple suppliers per product, but the country filter is the critical difference.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL fails to filter products by Europe, as it only applies the ecoFriendly condition in the subquery and doesn't check the supplier's country. The Generated SQL correctly filters suppliers in Europe via the WHERE clause, ensuring products are associated with European suppliers. While both retrieve top 3 expensive eco-friendly products, only the Generated SQL addresses the 'Europe' requirement. The Reference SQL might include products from non-European suppliers, making it incomplete for the business question.", "overall_assessment": "differently_correct"}}
{"example_id": 3715, "sql_complexity": "aggregation", "prompt": "What is the average age of engines still in service for each engine type?", "context": "CREATE TABLE Engine (id INT, aircraft_id INT, engine_type VARCHAR(255), hours_since_last_service INT, manufacture_year INT); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (1, 1, 'GE90-115B', 500, 2000); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (2, 2, 'CFM56-5B', 1000, 1995); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (3, 1, 'GE90-115B', 700, 2002);", "reference_sql": "SELECT engine_type, AVG(YEAR(CURRENT_DATE) - manufacture_year) as avg_age FROM Engine GROUP BY engine_type;", "generated_sql": "SELECT \n    engine_type,\n    AVG(EXTRACT(YEAR FROM CURRENT_DATE) - manufacture_year) AS average_age\nFROM \n    Engine\nGROUP BY \n    engine_type;", "raw_model_output": "SELECT \n    engine_type,\n    AVG(EXTRACT(YEAR FROM CURRENT_DATE) - manufacture_year) AS average_age\nFROM \n    Engine\nGROUP BY \n    engine_type;", "latency_sec": 0.6076390743255615, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 234, "prompt_eval_sec": null, "tokens_completion": 37, "completion_eval_sec": null, "tokens_total": 271, "tokens_per_sec": 445.9884353237023, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average age of engines by subtracting the manufacture_year from the current year. The reference SQL uses YEAR(CURRENT_DATE) while the generated SQL uses EXTRACT(YEAR FROM CURRENT_DATE). Both functions return the same numeric year value when applied to the same date, so the computed averages will be identical. The grouping and column aliases are also equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries calculate the average age of engines by subtracting the manufacture year from the current year, grouped by engine type. The reference query uses YEAR(CURRENT_DATE) while the generated query uses EXTRACT(YEAR FROM CURRENT_DATE). These expressions are functionally equivalent in standard SQL for retrieving the current year. However, neither query explicitly checks if engines are 'still in service' as required by the question. The context provided lacks a status field to filter active engines, so both queries assume all records in the Engine table represent engines in service. The queries are equally efficient and elegant, with no significant differences in logic or performance.", "overall_assessment": "correct"}}
{"example_id": 1957, "sql_complexity": "set operations", "prompt": "What is the average temperature recorded for the 'polar_bear' species in the 'Arctic_Animals' table compared to the 'penguin' species in the 'Antarctic_Animals' table?", "context": "CREATE TABLE Arctic_Animals (species TEXT, avg_temp FLOAT); CREATE TABLE Antarctic_Animals (species TEXT, avg_temp FLOAT);", "reference_sql": "SELECT AVG(Arctic_Animals.avg_temp) FROM Arctic_Animals WHERE Arctic_Animals.species = 'polar_bear' INTERSECT SELECT AVG(Antarctic_Animals.avg_temp) FROM Antarctic_Animals WHERE Antarctic_Animals.species = 'penguin'", "generated_sql": "SELECT \n    (SELECT AVG(avg_temp) FROM Arctic_Animals WHERE species = 'polar_bear') AS polar_bear_avg_temp,\n    (SELECT AVG(avg_temp) FROM Antarctic_Animals WHERE species = 'penguin') AS penguin_avg_temp;", "raw_model_output": "SELECT \n    (SELECT AVG(avg_temp) FROM Arctic_Animals WHERE species = 'polar_bear') AS polar_bear_avg_temp,\n    (SELECT AVG(avg_temp) FROM Antarctic_Animals WHERE species = 'penguin') AS penguin_avg_temp;", "latency_sec": 0.8245151042938232, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 135, "prompt_eval_sec": null, "tokens_completion": 53, "completion_eval_sec": null, "tokens_total": 188, "tokens_per_sec": 228.01280294436492, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses INTERSECT to return rows that exist in both result sets, which would only produce a result if the two averages are equal. The Generated SQL returns both averages as separate columns in a single row. The output structures differ (single column vs two columns) and the logical operation (INTERSECT vs parallel selection) produces different semantic results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is incorrect because it uses INTERSECT, which returns only common rows between two result sets. Since each subquery returns a single value (average temperature), INTERSECT would only return a result if both averages are identical, which is not the intended comparison. The Generated SQL correctly calculates separate averages for each species using correlated subqueries, producing two columns with the required values for direct comparison. The Reference SQL fails to fulfill the business intent of comparing the two averages, while the Generated SQL explicitly addresses the question by returning both metrics side-by-side.", "overall_assessment": "incorrect"}}
{"example_id": 1311, "sql_complexity": "basic SQL", "prompt": "What is the total number of veteran job applications in Texas in the last year?", "context": "CREATE TABLE veteran_jobs (id INT, state VARCHAR(50), application_date DATE); INSERT INTO veteran_jobs (id, state, application_date) VALUES (1, 'Texas', '2021-02-15'), (2, 'California', '2021-04-10'), (3, 'Texas', '2022-01-05');", "reference_sql": "SELECT COUNT(*) FROM veteran_jobs WHERE state = 'Texas' AND application_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR);", "generated_sql": "SELECT COUNT(*) AS total_applications\nFROM veteran_jobs\nWHERE state = 'Texas'\n  AND application_date >= DATEADD(year, -1, CURRENT_DATE);", "raw_model_output": "```sql\nSELECT COUNT(*) AS total_applications\nFROM veteran_jobs\nWHERE state = 'Texas'\n  AND application_date >= DATEADD(year, -1, CURRENT_DATE);\n```", "latency_sec": 0.6735491752624512, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 155, "prompt_eval_sec": null, "tokens_completion": 38, "completion_eval_sec": null, "tokens_total": 193, "tokens_per_sec": 286.54181029142643, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count records where state is 'Texas' and application_date is within the last year. DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR) and DATEADD(year, -1, CURRENT_DATE) produce the same date value (current date minus one year) in their respective SQL dialects. The alias 'total_applications' in the generated query doesn't affect the result's semantics.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count Texas veteran job applications within the last year. The reference uses MySQL's DATE_SUB function, while the generated query uses SQL Server's DATEADD function. Though syntax differs by DBMS, both achieve the same date calculation. The generated query improves readability with an explicit alias (total_applications) and clearer date arithmetic syntax. Both are logically equivalent and fulfill the business intent of counting recent Texas applications.", "overall_assessment": "correct"}}
{"example_id": 2997, "sql_complexity": "window functions", "prompt": "What is the earliest capture time for each satellite image in the 'satellite_images' table?", "context": "CREATE TABLE satellite_images (image_id INT, image_url TEXT, capture_time TIMESTAMP); INSERT INTO satellite_images (image_id, image_url, capture_time) VALUES (1, 'image1.jpg', '2022-01-01 10:00:00'), (2, 'image2.jpg', '2021-05-01 10:00:00');", "reference_sql": "SELECT image_id, MIN(capture_time) OVER (PARTITION BY image_id) FROM satellite_images;", "generated_sql": "SELECT image_id, MIN(capture_time) AS earliest_capture_time\nFROM satellite_images\nGROUP BY image_id;", "raw_model_output": "SELECT image_id, MIN(capture_time) AS earliest_capture_time\nFROM satellite_images\nGROUP BY image_id;", "latency_sec": 0.5414798259735107, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 163, "prompt_eval_sec": null, "tokens_completion": 24, "completion_eval_sec": null, "tokens_total": 187, "tokens_per_sec": 345.3498930708973, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses a window function to return all rows with the minimum capture_time for each image_id, while the Generated SQL groups by image_id, returning one row per image_id. If there are multiple rows with the same image_id, the Reference SQL would return multiple rows with the same min value, whereas the Generated SQL would return a single row per image_id. Thus, they are not semantically equivalent in all cases.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries return the same result for the given schema. The Reference SQL uses a window function (MIN() OVER) which, when partitioned by image_id (a unique identifier), produces the same value as the original capture_time. The Generated SQL uses GROUP BY to achieve the same outcome. However, the Generated SQL is more efficient and semantically appropriate for this task, as it directly aggregates the minimum capture_time per image_id. The Reference SQL's window function is unnecessary in this context and could be misleading if image_id were not unique.", "overall_assessment": "correct"}}
{"example_id": 3743, "sql_complexity": "aggregation", "prompt": "What is the maximum budget spent on peacekeeping operations by each department?", "context": "CREATE TABLE DepartmentPeacekeeping (id INT, department VARCHAR(50), budget INT);", "reference_sql": "SELECT department, MAX(budget) FROM DepartmentPeacekeeping GROUP BY department;", "generated_sql": "SELECT department, MAX(budget) AS max_budget\nFROM DepartmentPeacekeeping\nGROUP BY department;", "raw_model_output": "```sql\nSELECT department, MAX(budget) AS max_budget\nFROM DepartmentPeacekeeping\nGROUP BY department;\n```", "latency_sec": 0.7885100841522217, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 98, "prompt_eval_sec": null, "tokens_completion": 25, "completion_eval_sec": null, "tokens_total": 123, "tokens_per_sec": 155.9903956488334, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries group by 'department' and calculate the maximum 'budget' for each group. The generated query adds an alias 'max_budget' to the MAX(budget) column, but this does not affect the semantic result (the data returned). Column names in the result set are not part of the semantic equivalence when comparing query outputs.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically correct and produce identical results. The reference query returns the department and maximum budget without an explicit alias, while the generated query adds an alias 'max_budget' for the calculated column. This alias improves readability without altering the semantic meaning. Both correctly group by department and calculate the maximum budget per department, fully addressing the business intent. The generated query is more elegant due to the explicit alias, which makes the output clearer for end-users.", "overall_assessment": "correct"}}
{"example_id": 4664, "sql_complexity": "multiple_joins", "prompt": "Calculate the total number of volunteer hours contributed by volunteers from 'California' in 'Health' projects in 2021.", "context": "CREATE TABLE volunteers (volunteer_id INT, name VARCHAR(255), state VARCHAR(255));", "reference_sql": "SELECT SUM(vh.hours) as total_hours FROM volunteer_projects vp JOIN volunteer_hours vh ON vp.project_id = vh.project_id JOIN volunteers vol ON vh.volunteer_id = vol.volunteer_id WHERE vp.cause = 'Health' AND vol.state = 'California' AND vh.volunteer_date BETWEEN '2021-01-01' AND '2021-12-31';", "generated_sql": "SELECT SUM(vh.hours) AS total_hours\nFROM volunteers v\nJOIN volunteer_hours vh ON v.volunteer_id = vh.volunteer_id\nJOIN projects p ON vh.project_id = p.project_id\nWHERE v.state = 'California'\n  AND p.category = 'Health'\n  AND YEAR(vh.date) = 2021;", "raw_model_output": "```sql\nSELECT SUM(vh.hours) AS total_hours\nFROM volunteers v\nJOIN volunteer_hours vh ON v.volunteer_id = vh.volunteer_id\nJOIN projects p ON vh.project_id = p.project_id\nWHERE v.state = 'California'\n  AND p.category = 'Health'\n  AND YEAR(vh.date) = 2021;\n```", "latency_sec": 1.1405529975891113, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 110, "prompt_eval_sec": null, "tokens_completion": 73, "completion_eval_sec": null, "tokens_total": 183, "tokens_per_sec": 160.44848453936243, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL joins 'volunteer_projects' (using 'cause' = 'Health') while the Generated SQL joins 'projects' (using 'category' = 'Health'), which are different tables with potentially different data. Additionally, the date condition in the Reference uses a range ('BETWEEN') while the Generated uses 'YEAR()' function, which may behave differently for datetime values. The column names ('volunteer_date' vs 'date') also differ, introducing potential mismatches.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in critical aspects. The reference query uses the correct schema elements (volunteer_projects, volunteer_hours, volunteers) with proper joins and columns (cause, state, volunteer_date). The generated query introduces a 'projects' table not present in the context, uses 'category' instead of 'cause', and references a 'date' column instead of 'volunteer_date'. Additionally, the generated query's YEAR() function may prevent index usage. While both aim to solve the business problem, the generated query is technically invalid due to schema inconsistencies.", "overall_assessment": "incorrect"}}
{"example_id": 251, "sql_complexity": "set operations", "prompt": "Compare the number of economic diversification projects in two regions, one in Europe and one in Oceania, by showing the project type and the number of projects in each region.", "context": "CREATE TABLE economic_diversification (region VARCHAR(50), project_type VARCHAR(50), project_start_date DATE);", "reference_sql": "SELECT 'Europe' as region, project_type, COUNT(*) as project_count FROM economic_diversification WHERE region = 'Europe' UNION ALL SELECT 'Oceania' as region, project_type, COUNT(*) as project_count FROM economic_diversification WHERE region = 'Oceania';", "generated_sql": "SELECT \n    project_type,\n    SUM(CASE WHEN region IN ('Europe') THEN 1 ELSE 0 END) AS europe_project_count,\n    SUM(CASE WHEN region IN ('Oceania') THEN 1 ELSE 0 END) AS oceania_project_count\nFROM economic_diversification\nWHERE region IN ('Europe', 'Oceania')\nGROUP BY project_type;", "raw_model_output": "```sql\nSELECT \n    project_type,\n    SUM(CASE WHEN region IN ('Europe') THEN 1 ELSE 0 END) AS europe_project_count,\n    SUM(CASE WHEN region IN ('Oceania') THEN 1 ELSE 0 END) AS oceania_project_count\nFROM economic_diversification\nWHERE region IN ('Europe', 'Oceania')\nGROUP BY project_type;\n```", "latency_sec": 1.5068910121917725, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 124, "prompt_eval_sec": null, "tokens_completion": 82, "completion_eval_sec": null, "tokens_total": 206, "tokens_per_sec": 136.70530803709093, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries have different result structures. The Reference query returns two rows per project_type (one for Europe and one for Oceania) with columns (region, project_type, project_count). The Generated query returns one row per project_type with columns (project_type, europe_project_count, oceania_project_count). The semantic output format differs, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL produces two separate rows per project type (one for Europe, one for Oceania), while the Generated SQL consolidates both regions into a single row per project type with separate columns. This makes the Generated SQL more effective for direct comparison as required by the question. The Reference SQL fails to fulfill the intent because it doesn't present both regions side-by-side. The Generated SQL is also more efficient, using a single GROUP BY operation instead of two separate queries with UNION ALL.", "overall_assessment": "correct"}}
{"example_id": 610, "sql_complexity": "subqueries", "prompt": "What is the percentage of community development projects completed in 'Caribbean' in 2020?", "context": "CREATE TABLE community_projects (project_id INT, project_name TEXT, location TEXT, completion_year INT); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (1, 'Community Center', 'Southern Region, Caribbean', 2020); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (2, 'Park Renovation', 'Northern Region, Caribbean', 2019); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (3, 'Library Construction', 'Caribbean', 2020);", "reference_sql": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM community_projects WHERE location = 'Caribbean')) FROM community_projects WHERE completion_year = 2020 AND location = 'Caribbean';", "generated_sql": "SELECT \n    100.0 * COUNT(CASE WHEN location = 'Caribbean' AND completion_year = 2020 THEN 1 END) / COUNT(*) AS percentage_completed_in_caribbean_2020\nFROM \n    community_projects;", "raw_model_output": "SELECT \n    100.0 * COUNT(CASE WHEN location = 'Caribbean' AND completion_year = 2020 THEN 1 END) / COUNT(*) AS percentage_completed_in_caribbean_2020\nFROM \n    community_projects;", "latency_sec": 0.7320780754089355, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 207, "prompt_eval_sec": null, "tokens_completion": 50, "completion_eval_sec": null, "tokens_total": 257, "tokens_per_sec": 351.05545246173494, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the percentage of Caribbean projects completed in 2020 relative to all Caribbean projects (denominator is subquery COUNT(*) for Caribbean). The Generated SQL calculates the percentage of Caribbean 2020 projects relative to all projects (denominator is COUNT(*) for entire table). The denominators differ, leading to different results when there are projects outside the Caribbean.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly calculates the percentage of Caribbean projects completed in 2020 by using the total Caribbean projects as the denominator. The Generated SQL incorrectly uses the total projects (all locations) as the denominator, which would produce an inaccurate percentage if there were projects outside the Caribbean. While both queries return the same numerical result in the provided sample data (due to all projects being in the Caribbean), the Generated SQL's logic fails to meet the business requirement of focusing on Caribbean-specific projects. The Reference SQL explicitly filters the denominator to only include Caribbean projects, ensuring semantic correctness.", "overall_assessment": "correct"}}
{"example_id": 421, "sql_complexity": "set operations", "prompt": "What is the combined landfill capacity for 'City A' and 'City B'?", "context": "CREATE TABLE landfill_capacity (city VARCHAR(255), capacity INT); INSERT INTO landfill_capacity (city, capacity) VALUES ('City A', 500000), ('City B', 600000);", "reference_sql": "SELECT SUM(capacity) FROM (SELECT capacity FROM landfill_capacity WHERE city = 'City A' UNION ALL SELECT capacity FROM landfill_capacity WHERE city = 'City B') AS combined_capacity;", "generated_sql": "SELECT SUM(capacity) AS combined_capacity\nFROM landfill_capacity\nWHERE city IN ('City A', 'City B');", "raw_model_output": "```sql\nSELECT SUM(capacity) AS combined_capacity\nFROM landfill_capacity\nWHERE city IN ('City A', 'City B');\n```", "latency_sec": 0.778527021408081, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 123, "prompt_eval_sec": null, "tokens_completion": 29, "completion_eval_sec": null, "tokens_total": 152, "tokens_per_sec": 195.24049367623175, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of capacities for 'City A' and 'City B'. The reference query uses a subquery with UNION ALL to combine the two cities' capacities before summing, while the generated query directly filters the cities using IN. Since SUM aggregates all matching rows regardless of how they are combined, both approaches yield the same result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the combined landfill capacity for 'City A' and 'City B'. The Reference query uses a subquery with UNION ALL to isolate the capacities before summing, while the Generated query directly sums the capacities using a WHERE clause with IN. Both produce identical results. However, the Generated query is more efficient as it avoids unnecessary subquery overhead and directly filters the relevant rows. The business intent of combining capacities is equally fulfilled by both, but the Generated query achieves it with simpler, more elegant syntax.", "overall_assessment": "correct"}}
{"example_id": 880, "sql_complexity": "aggregation", "prompt": "Show veteran employment statistics for each state in the 'veteran_employment' table", "context": "CREATE TABLE veteran_employment (employee_id INT, state VARCHAR(2), job_title VARCHAR(50), employment_date DATE);", "reference_sql": "SELECT state, COUNT(*) as veteran_employees FROM veteran_employment WHERE state IN ('CA', 'NY', 'TX', 'FL', 'PA') GROUP BY state;", "generated_sql": "SELECT \n    state,\n    COUNT(*) AS total_employees,\n    COUNT(DISTINCT job_title) AS distinct_job_titles,\n    MIN(employment_date) AS earliest_employment_date,\n    MAX(employment_date) AS latest_employment_date\nFROM veteran_employment\nGROUP BY state\nORDER BY state;", "raw_model_output": "```sql\nSELECT \n    state,\n    COUNT(*) AS total_employees,\n    COUNT(DISTINCT job_title) AS distinct_job_titles,\n    MIN(employment_date) AS earliest_employment_date,\n    MAX(employment_date) AS latest_employment_date\nFROM veteran_employment\nGROUP BY state\nORDER BY state;\n```", "latency_sec": 0.7977299690246582, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 110, "prompt_eval_sec": null, "tokens_completion": 68, "completion_eval_sec": null, "tokens_total": 178, "tokens_per_sec": 223.13314894967664, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL only selects 'state' and a count of employees, filtering for specific states. The Generated SQL includes additional columns (total_employees, distinct_job_titles, earliest_employment_date, latest_employment_date) and lacks the state filter, resulting in different output structures and potentially different data.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query restricts results to specific states ('CA', 'NY', 'TX', 'FL', 'PA') and only returns a count of employees, while the generated query includes all states and provides multiple statistics (total employees, distinct job titles, and employment date ranges). The generated query better fulfills the business intent of showing 'employment statistics' by offering more comprehensive metrics. Although the reference query is technically correct for its narrower scope, the generated query aligns more broadly with the open-ended request for statistics without arbitrary state filtering. The generated query's additional metrics add value without contradicting the original question.", "overall_assessment": "differently_correct"}}
{"example_id": 454, "sql_complexity": "single join", "prompt": "Which excavation sites have more than 10 artifacts?", "context": "CREATE TABLE ExcavationSite (SiteID INT, SiteName VARCHAR(50)); INSERT INTO ExcavationSite (SiteID, SiteName) VALUES (1, 'Site A'), (2, 'Site B'), (3, 'Site C'); CREATE TABLE Artifact (ArtifactID INT, SiteID INT, ObjectType VARCHAR(50)); INSERT INTO Artifact (ArtifactID, SiteID, ObjectType) VALUES (1, 1, 'Pottery'), (2, 1, 'Tool'), (3, 2, 'Statue'), (4, 2, 'Bead'), (5, 3, 'Bead'), (6, 3, 'Bead'), (7, 3, 'Bead'), (8, 3, 'Bead'), (9, 3, 'Bead'), (10, 3, 'Bead'), (11, 3, 'Bead');", "reference_sql": "SELECT e.SiteName FROM ExcavationSite e JOIN Artifact a ON e.SiteID = a.SiteID GROUP BY e.SiteName HAVING COUNT(a.ArtifactID) > 10;", "generated_sql": "SELECT SiteID, SiteName\nFROM ExcavationSite\nWHERE SiteID IN (\n    SELECT SiteID\n    FROM Artifact\n    GROUP BY SiteID\n    HAVING COUNT(*) > 10\n);", "raw_model_output": "SELECT SiteID, SiteName\nFROM ExcavationSite\nWHERE SiteID IN (\n    SELECT SiteID\n    FROM Artifact\n    GROUP BY SiteID\n    HAVING COUNT(*) > 10\n);", "latency_sec": 0.7004818916320801, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 268, "prompt_eval_sec": null, "tokens_completion": 43, "completion_eval_sec": null, "tokens_total": 311, "tokens_per_sec": 443.9800710270882, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL returns only 'SiteName' from ExcavationSite, grouped by SiteName with a HAVING clause on artifact count. The Generated SQL returns both 'SiteID' and 'SiteName' from ExcavationSite, filtered by a subquery checking artifact counts per SiteID. The column sets differ (one column vs two columns), and the GROUP BY logic in the Reference SQL could behave differently if multiple sites shared the same SiteName (though the sample data has unique SiteNames).", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries correctly identify excavation sites with more than 10 artifacts. The reference query uses an explicit JOIN and groups by SiteName, while the generated query uses a subquery with SiteID. However, in the given schema, SiteID is the primary key and SiteName is unique, making both approaches logically equivalent. The reference query directly returns SiteName (the exact column requested in the question), whereas the generated query includes unnecessary SiteID columns. The reference query is more aligned with the business intent of reporting site names.", "overall_assessment": "correct"}}
{"example_id": 1086, "sql_complexity": "aggregation", "prompt": "What is the total CO2 emission for each equipment type, excluding equipment that is older than 8 years?", "context": "CREATE TABLE EmissionData (EquipmentID INT, EquipmentType VARCHAR(50), CO2Emission INT, Age INT); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (1, 'Excavator', 50, 8); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (2, 'Haul Truck', 70, 7); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (3, 'Shovel', 30, 6); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (4, 'Drilling Rig', 40, 3);", "reference_sql": "SELECT EquipmentType, SUM(CO2Emission) as TotalCO2Emission FROM EmissionData WHERE Age <= 8 GROUP BY EquipmentType;", "generated_sql": "SELECT EquipmentType, SUM(CO2Emission) AS TotalCO2Emission\nFROM EmissionData\nWHERE Age <= 8\nGROUP BY EquipmentType;", "raw_model_output": "```sql\nSELECT EquipmentType, SUM(CO2Emission) AS TotalCO2Emission\nFROM EmissionData\nWHERE Age <= 8\nGROUP BY EquipmentType;\n```", "latency_sec": 0.8640129566192627, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 244, "prompt_eval_sec": null, "tokens_completion": 37, "completion_eval_sec": null, "tokens_total": 281, "tokens_per_sec": 325.2266043549922, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure, logic, and syntax. Both select EquipmentType and sum CO2Emission for rows where Age <= 8, grouping by EquipmentType. The only differences are formatting (capitalization of keywords and line breaks), which do not affect semantic meaning.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are syntactically identical except for minor formatting differences (capitalization of 'AS' and spacing). They correctly filter equipment with Age <= 8, group by EquipmentType, and calculate total CO2 emissions. The business intent to exclude equipment older than 8 years is fully addressed by the WHERE Age <= 8 condition. Both queries are equally efficient and elegant.", "overall_assessment": "correct"}}
{"example_id": 3455, "sql_complexity": "basic SQL", "prompt": "What are the names of all innovation projects in the 'rural_infrastructure' table, excluding those with a budget over 50000?", "context": "CREATE TABLE rural_infrastructure (name VARCHAR(255), budget INT); INSERT INTO rural_infrastructure (name, budget) VALUES ('Dam Construction', 40000), ('Well Digging', 30000), ('Irrigation System', 70000);", "reference_sql": "SELECT name FROM rural_infrastructure WHERE budget <= 50000;", "generated_sql": "SELECT name\nFROM rural_infrastructure\nWHERE budget <= 50000;", "raw_model_output": "```sql\nSELECT name\nFROM rural_infrastructure\nWHERE budget <= 50000;\n```", "latency_sec": 0.4929828643798828, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 147, "prompt_eval_sec": null, "tokens_completion": 20, "completion_eval_sec": null, "tokens_total": 167, "tokens_per_sec": 338.75416787572783, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. The only difference is formatting (line breaks), which does not affect SQL execution. Both select 'name' from the same table where budget <= 50000.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are syntactically correct and semantically identical. They select project names from the rural_infrastructure table where budget is less than or equal to 50000, perfectly matching the requirement to exclude projects with budgets over 50000. The only difference is formatting (line breaks), which doesn't affect execution. Both efficiently answer the business question with optimal logic.", "overall_assessment": "correct"}}
{"example_id": 3936, "sql_complexity": "window functions", "prompt": "What is the total investment per client for each investment type?", "context": "CREATE TABLE clients (client_id INT, name TEXT, investment_type TEXT, investment FLOAT); INSERT INTO clients (client_id, name, investment_type, investment) VALUES (1, 'John Doe', 'Stocks', 3000.00), (1, 'John Doe', 'Bonds', 2000.00), (2, 'Jane Smith', 'Stocks', 5000.00);", "reference_sql": "SELECT client_id, name, investment_type, SUM(investment) OVER (PARTITION BY client_id, investment_type ORDER BY client_id) as total_investment FROM clients;", "generated_sql": "SELECT client_id, name, investment_type, SUM(investment) AS total_investment\nFROM clients\nGROUP BY client_id, name, investment_type;", "raw_model_output": "```sql\nSELECT client_id, name, investment_type, SUM(investment) AS total_investment\nFROM clients\nGROUP BY client_id, name, investment_type;\n```", "latency_sec": 0.5975511074066162, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 161, "prompt_eval_sec": null, "tokens_completion": 38, "completion_eval_sec": null, "tokens_total": 199, "tokens_per_sec": 333.02590779835384, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL uses a window function to calculate a running sum within partitions, retaining all original rows. The Generated SQL aggregates rows using GROUP BY, collapsing duplicates into single rows. For the given sample data, they may produce similar results, but they differ in handling multiple rows within the same client_id/investment_type group (the Reference SQL retains all rows with cumulative sums, while the Generated SQL collapses them into one row per group).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query uses a window function that calculates a cumulative sum within partitions, but the ORDER BY clause is unnecessary and could lead to confusion. It returns all original rows with duplicated totals per client-investment_type group, whereas the generated query properly aggregates data using GROUP BY. The original question requires summarizing investments into one row per client-investment_type combination, which the generated query achieves through SUM(investment) with GROUP BY. The reference query fails to fulfill the business intent by not collapsing rows and potentially misleading with window function behavior.", "overall_assessment": "incorrect"}}
{"example_id": 1838, "sql_complexity": "window functions", "prompt": "What are the top 3 species with the most sightings across all arctic research stations?", "context": "CREATE TABLE research_station (id INT, name TEXT); INSERT INTO research_station (id, name) VALUES (1, 'Station A'); INSERT INTO research_station (id, name) VALUES (2, 'Station B'); CREATE TABLE species_observations (station_id INT, species_name TEXT, sightings INT); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (1, 'Species 1', 10); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (1, 'Species 2', 5); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (2, 'Species 1', 8); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (2, 'Species 3', 15);", "reference_sql": "SELECT species_name, SUM(sightings) as total_sightings, RANK() OVER (ORDER BY SUM(sightings) DESC) as rank FROM species_observations GROUP BY species_name HAVING rank <= 3;", "generated_sql": "SELECT species_name, SUM(sightings) AS total_sightings\nFROM species_observations\nGROUP BY species_name\nORDER BY total_sightings DESC\nLIMIT 3;", "raw_model_output": "SELECT species_name, SUM(sightings) AS total_sightings\nFROM species_observations\nGROUP BY species_name\nORDER BY total_sightings DESC\nLIMIT 3;", "latency_sec": 0.9328198432922363, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 256, "prompt_eval_sec": null, "tokens_completion": 39, "completion_eval_sec": null, "tokens_total": 295, "tokens_per_sec": 316.2454166485624, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a RANK() window function and a HAVING clause filtering by 'rank', which is not valid SQL syntax (window functions cannot be used in HAVING). The Generated SQL correctly groups, sums, and limits results without ranking. Additionally, the Reference SQL would likely fail to execute, while the Generated SQL produces the top 3 species by sightings. The output structures also differ (columns vary).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL contains a critical technical error: the HAVING clause references 'rank' which is an alias from the SELECT clause. In SQL, aliases cannot be used in HAVING clauses because they are evaluated before the SELECT list. This makes the Reference SQL invalid and non-functional. The Generated SQL correctly groups by species_name, sums sightings, orders by total sightings in descending order, and limits to 3 results. It directly addresses the business intent of identifying the top 3 species without unnecessary complexity. While both queries aim to solve the same problem, the Generated SQL is technically correct, efficient, and produces the intended results.", "overall_assessment": "incorrect"}}
{"example_id": 3091, "sql_complexity": "single join", "prompt": "Find the number of hybrid vehicles sold in the US, Germany, and Japan.", "context": "CREATE TABLE vehicle_sales (sale_id INT, vehicle_id INT, country VARCHAR(20), quantity INT); CREATE TABLE vehicles (vehicle_id INT, model VARCHAR(20), manufacture VARCHAR(20), vehicle_type VARCHAR(20));", "reference_sql": "SELECT SUM(vs.quantity) FROM vehicle_sales vs JOIN vehicles v ON vs.vehicle_id = v.vehicle_id WHERE v.vehicle_type = 'hybrid' AND vs.country IN ('US', 'Germany', 'Japan');", "generated_sql": "SELECT SUM(vs.quantity) AS total_hybrid_vehicles_sold\nFROM vehicle_sales vs\nJOIN vehicles v ON vs.vehicle_id = v.vehicle_id\nWHERE v.vehicle_type = 'hybrid'\n  AND vs.country IN ('US', 'Germany', 'Japan');", "raw_model_output": "```sql\nSELECT SUM(vs.quantity) AS total_hybrid_vehicles_sold\nFROM vehicle_sales vs\nJOIN vehicles v ON vs.vehicle_id = v.vehicle_id\nWHERE v.vehicle_type = 'hybrid'\n  AND vs.country IN ('US', 'Germany', 'Japan');\n```", "latency_sec": 1.4920518398284912, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 128, "prompt_eval_sec": null, "tokens_completion": 60, "completion_eval_sec": null, "tokens_total": 188, "tokens_per_sec": 126.00098400174238, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. The only difference is the alias 'total_hybrid_vehicles_sold' in the Generated SQL, which does not affect the result's content or calculation. Both queries perform the same aggregation, join, and filtering operations.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically correct and semantically equivalent, as they perform the same join, filters, and aggregation. The generated query adds an explicit alias ('total_hybrid_vehicles_sold') to the SUM result, improving readability and clarity of the output column. While the reference query is functionally identical, the generated version is more elegant by providing a descriptive column name, which better supports downstream data interpretation without altering the business logic. Neither query is inefficient, but the generated version slightly enhances usability.", "overall_assessment": "correct"}}
{"example_id": 2399, "sql_complexity": "set operations", "prompt": "What is the average duration of criminal trials for Indigenous defendants compared to non-Indigenous defendants in Canada and New Zealand?", "context": "CREATE TABLE canada_criminal_trials (id INT, defendant_type VARCHAR(255), days_to_completion INT); INSERT INTO canada_criminal_trials (id, defendant_type, days_to_completion) VALUES (1, 'Indigenous', 60), (2, 'Non-Indigenous', 45);CREATE TABLE nz_criminal_trials (id INT, defendant_type VARCHAR(255), days_to_completion INT); INSERT INTO nz_criminal_trials (id, defendant_type, days_to_completion) VALUES (1, 'Indigenous', 70), (2, 'Non-Indigenous', 50);", "reference_sql": "SELECT AVG(days_to_completion) AS avg_duration FROM canada_criminal_trials WHERE defendant_type = 'Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM canada_criminal_trials WHERE defendant_type = 'Non-Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM nz_criminal_trials WHERE defendant_type = 'Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM nz_criminal_trials WHERE defendant_type = 'Non-Indigenous';", "generated_sql": "SELECT \n    'Canada' AS country,\n    defendant_type,\n    AVG(days_to_completion) AS avg_days_to_completion\nFROM canada_criminal_trials\nGROUP BY defendant_type\n\nUNION ALL\n\nSELECT \n    'New Zealand' AS country,\n    defendant_type,\n    AVG(days_to_completion) AS avg_days_to_completion\nFROM nz_criminal_trials\nGROUP BY defendant_type;", "raw_model_output": "SELECT \n    'Canada' AS country,\n    defendant_type,\n    AVG(days_to_completion) AS avg_days_to_completion\nFROM canada_criminal_trials\nGROUP BY defendant_type\n\nUNION ALL\n\nSELECT \n    'New Zealand' AS country,\n    defendant_type,\n    AVG(days_to_completion) AS avg_days_to_completion\nFROM nz_criminal_trials\nGROUP BY defendant_type;", "latency_sec": 1.1700160503387451, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 208, "prompt_eval_sec": null, "tokens_completion": 78, "completion_eval_sec": null, "tokens_total": 286, "tokens_per_sec": 244.4410911433196, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in output structure. The Reference SQL returns only average values in a single column, while the Generated SQL includes additional 'country' and 'defendant_type' columns. Although both calculate the same averages, the result sets have different schemas, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the average trial durations for Indigenous and non-Indigenous defendants in Canada and New Zealand. The reference query uses four separate SELECT statements with UNION ALL to return four rows, while the generated query uses GROUP BY to combine country and defendant_type into a structured format. The generated query is more efficient and elegant, as it avoids repetitive subqueries and provides a clearer organizational structure that explicitly includes the 'country' field. This structure better supports direct comparison between jurisdictions and defendant types, fulfilling the business intent more effectively.", "overall_assessment": "correct"}}
{"example_id": 2972, "sql_complexity": "set operations", "prompt": "How many indigenous communities are in the Arctic Research Station 13 and 14?", "context": "CREATE TABLE Arctic_Research_Station_13 (id INT, community TEXT); CREATE TABLE Arctic_Research_Station_14 (id INT, community TEXT);", "reference_sql": "SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_13; SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_14; SELECT COUNT(DISTINCT community) FROM (SELECT * FROM Arctic_Research_Station_13 UNION ALL SELECT * FROM Arctic_Research_Station_14) AS Arctic_Communities;", "generated_sql": "SELECT \n    (SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_13) +\n    (SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_14) AS total_indigenous_communities;", "raw_model_output": "SELECT \n    (SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_13) +\n    (SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_14) AS total_indigenous_communities;", "latency_sec": 1.0989789962768555, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 115, "prompt_eval_sec": null, "tokens_completion": 48, "completion_eval_sec": null, "tokens_total": 163, "tokens_per_sec": 148.3194861341435, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL's third query uses UNION ALL to combine both tables before counting distinct communities, ensuring overlapping communities are counted once. The Generated SQL adds the separate counts from each table, which would overcount communities present in both tables. Thus, they are not equivalent when there are overlapping community values between the two tables.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL includes three queries: separate counts for each station and a combined count using UNION ALL. The Generated SQL sums the counts from each station. These differ fundamentally: the Generated SQL would overcount communities present in both stations (e.g., a community in both 13 and 14 would be counted twice), while the Reference's third query correctly identifies unique communities across both stations. The original question's intent is ambiguous but likely seeks the total unique communities, making the Reference's approach technically correct. The Generated SQL fails to account for potential overlaps, thus not fulfilling the business intent accurately.", "overall_assessment": "differently_correct"}}
{"example_id": 5576, "sql_complexity": "window functions", "prompt": "Who are the top 5 users with the most followers, and what is their location?", "context": "CREATE TABLE user_data (user_id INT, name VARCHAR(50), followers INT, location VARCHAR(50)); INSERT INTO user_data (user_id, name, followers, location) VALUES (1, 'Alice', 10000, 'New York'), (2, 'Bob', 15000, 'California'), (3, 'Charlie', 12000, 'Texas'), (4, 'David', 8000, 'Florida'), (5, 'Eve', 9000, 'Illinois');", "reference_sql": "SELECT name, location FROM (SELECT name, location, ROW_NUMBER() OVER (ORDER BY followers DESC) AS rank FROM user_data) AS user_ranks WHERE rank <= 5;", "generated_sql": "SELECT name, location\nFROM user_data\nORDER BY followers DESC\nLIMIT 5;", "raw_model_output": "SELECT name, location\nFROM user_data\nORDER BY followers DESC\nLIMIT 5;", "latency_sec": 1.6299960613250732, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 189, "prompt_eval_sec": null, "tokens_completion": 19, "completion_eval_sec": null, "tokens_total": 208, "tokens_per_sec": 127.60767030989663, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the top 5 users by followers in descending order. The Reference SQL uses ROW_NUMBER() to assign ranks and filters where rank <= 5, while the Generated SQL directly uses ORDER BY with LIMIT 5. Since the data has unique follower counts, both approaches yield identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly retrieve the top 5 users by followers and their locations. The Reference SQL uses a window function with ROW_NUMBER() and a subquery, while the Generated SQL uses simple ORDER BY and LIMIT. Technically, they produce identical results in this specific case because followers are unique. However, the Generated SQL is more efficient and elegant, as it avoids unnecessary complexity. The Reference might behave differently with tie-breaking scenarios (e.g., multiple users with same follower count), but the question implies a strict top 5 without handling ties. Both fulfill the business intent, but the Generated query is superior for its simplicity and performance.", "overall_assessment": "correct"}}
{"example_id": 1560, "sql_complexity": "basic SQL", "prompt": "What is the average media literacy score for users in the 'Young Adult' age group who have completed at least one disinformation detection course?", "context": "CREATE TABLE users (id INT, age VARCHAR(20), media_literacy_score INT, courses_completed INT);", "reference_sql": "SELECT AVG(media_literacy_score) FROM users WHERE age = 'Young Adult' AND courses_completed > 0;", "generated_sql": "SELECT AVG(media_literacy_score) AS average_media_literacy_score\nFROM users\nWHERE age = 'Young Adult' AND courses_completed >= 1;", "raw_model_output": "```sql\nSELECT AVG(media_literacy_score) AS average_media_literacy_score\nFROM users\nWHERE age = 'Young Adult' AND courses_completed >= 1;\n```", "latency_sec": 1.1910288333892822, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 118, "prompt_eval_sec": null, "tokens_completion": 38, "completion_eval_sec": null, "tokens_total": 156, "tokens_per_sec": 130.97919683109143, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The WHERE clauses 'courses_completed > 0' and 'courses_completed >= 1' are equivalent for integer values, as both filter rows where courses_completed is 1 or higher. The generated query adds an alias (average_media_literacy_score) which doesn't affect the result's semantic content.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically equivalent as 'courses_completed > 0' and 'courses_completed >= 1' produce identical filtering results. The generated query explicitly uses '>= 1' which directly maps to the business requirement of 'at least one course', enhancing readability. The generated query also includes an alias ('average_media_literacy_score') that improves result clarity without affecting functionality. While both fulfill the intent, the generated version is slightly more elegant and semantically aligned with the phrasing of the question.", "overall_assessment": "correct"}}
{"example_id": 1201, "sql_complexity": "basic SQL", "prompt": "What is the maximum energy efficiency rating of hydroelectric dams in Canada?", "context": "CREATE TABLE hydro_dams (id INT, name TEXT, country TEXT, energy_efficiency_rating FLOAT); INSERT INTO hydro_dams (id, name, country, energy_efficiency_rating) VALUES (1, 'Robert-Bourassa', 'Canada', 0.94), (2, 'Churchill Falls', 'Canada', 0.92);", "reference_sql": "SELECT MAX(energy_efficiency_rating) FROM hydro_dams WHERE country = 'Canada';", "generated_sql": "SELECT MAX(energy_efficiency_rating) AS max_efficiency\nFROM hydro_dams\nWHERE country = 'Canada';", "raw_model_output": "```sql\nSELECT MAX(energy_efficiency_rating) AS max_efficiency\nFROM hydro_dams\nWHERE country = 'Canada';\n```", "latency_sec": 0.6081018447875977, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 153, "prompt_eval_sec": null, "tokens_completion": 29, "completion_eval_sec": null, "tokens_total": 182, "tokens_per_sec": 299.29197150120524, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the maximum energy_efficiency_rating for dams in Canada. The generated query adds an alias (max_efficiency) to the result column, but this does not affect the semantic value of the result. The WHERE clause and aggregate function are identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly retrieve the maximum energy efficiency rating for Canadian hydroelectric dams using the MAX() function and country filter. The only difference is the alias 'AS max_efficiency' in the generated query, which doesn't affect the result but improves column readability. Neither query has syntax errors or logical flaws. The reference query is more concise while the generated query is slightly more readable. Both fully address the business intent of identifying the maximum rating.", "overall_assessment": "correct"}}
{"example_id": 4243, "sql_complexity": "single join", "prompt": "How many orders were placed by new and returning customers in each month of the year 2021?'", "context": "CREATE TABLE customer (id INT, first_order_date DATE, last_order_date DATE);", "reference_sql": "INSERT INTO customer (id, first_order_date, last_order_date) SELECT customer_id, MIN(order_date) AS first_order_date, MAX(order_date) AS last_order_date FROM orders GROUP BY customer_id; SELECT YEAR(order_date) AS year, MONTH(order_date) AS month, CASE WHEN DATEDIFF(last_order_date, first_order_date) > 30 THEN 'returning' ELSE 'new' END AS customer_type, COUNT(DISTINCT id) AS num_orders FROM orders JOIN customer ON orders.customer_id = customer.id WHERE YEAR(order_date) = 2021 GROUP BY year, month, customer_type;", "generated_sql": "WITH orders_2021 AS (\n  SELECT \n    DATE_TRUNC('month', o.order_date) AS order_month,\n    o.customer_id,\n    MIN(o.order_date) OVER (PARTITION BY o.customer_id) AS first_order_date\n  FROM orders o\n  WHERE o.order_date >= '2021-01-01' AND o.order_date < '2022-01-01'\n),\ncategorized_orders AS (\n  SELECT\n    order_month,\n    CASE \n      WHEN first_order_date >= '2021-01-01' AND first_order_date < '2022-01-01' THEN 'new'\n      ELSE 'returning'\n    END AS customer_type\n  FROM orders_2021\n)\nSELECT \n  order_month,\n  customer_type,\n  COUNT(*) AS order_count\nFROM categorized_orders\nGROUP BY order_month, customer_type\nORDER BY order_month, customer_type;", "raw_model_output": "```sql\nWITH orders_2021 AS (\n  SELECT \n    DATE_TRUNC('month', o.order_date) AS order_month,\n    o.customer_id,\n    MIN(o.order_date) OVER (PARTITION BY o.customer_id) AS first_order_date\n  FROM orders o\n  WHERE o.order_date >= '2021-01-01' AND o.order_date < '2022-01-01'\n),\ncategorized_orders AS (\n  SELECT\n    order_month,\n    CASE \n      WHEN first_order_date >= '2021-01-01' AND first_order_date < '2022-01-01' THEN 'new'\n      ELSE 'returning'\n    END AS customer_type\n  FROM orders_2021\n)\nSELECT \n  order_month,\n  customer_type,\n  COUNT(*) AS order_count\nFROM categorized_orders\nGROUP BY order_month, customer_type\nORDER BY order_month, customer_type;\n```", "latency_sec": 1.8462169170379639, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 105, "prompt_eval_sec": null, "tokens_completion": 190, "completion_eval_sec": null, "tokens_total": 295, "tokens_per_sec": 159.78620782724303, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in customer_type classification logic and aggregation metrics. The Reference SQL uses DATEDIFF between first/last order dates to determine 'new'/'returning', while the Generated SQL checks if the first_order_date falls within 2021. Additionally, the Reference SQL counts distinct customer IDs (COUNT(DISTINCT id)) whereas the Generated SQL counts all orders (COUNT(*)). The Generated SQL also omits the customer table entirely, relying on window functions instead of precomputed first_order_date values.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL contains a critical flaw in its customer_type logic. It uses DATEDIFF(last_order_date, first_order_date) > 30 to determine new vs returning customers, which incorrectly categorizes customers based on the duration between their first and last orders rather than their status relative to 2021. This approach would misclassify customers who had multiple orders in 2021 but with short intervals between them. The Generated SQL correctly identifies new customers as those whose first order occurred in 2021 (using first_order_date from the CTE) and returning customers as those with first orders before 2021. While both queries count orders by month, only the Generated SQL accurately addresses the business intent of distinguishing new vs returning customers based on their first order date relative to 2021. The Generated SQL also avoids the questionable INSERT INTO customer operation present in the Reference SQL.", "overall_assessment": "differently_correct"}}
{"example_id": 2321, "sql_complexity": "subqueries", "prompt": "What are the names and types of vessels used in research expeditions in the regions with the lowest ocean acidification levels?", "context": "CREATE TABLE ocean_acidification (id INT PRIMARY KEY, region VARCHAR(255), year INT, acidification_level INT); INSERT INTO ocean_acidification (id, region, year, acidification_level) VALUES (1, 'Arctic Ocean', 2018, 20), (2, 'Southern Ocean', 2019, 22); CREATE TABLE expedition_vessels (id INT PRIMARY KEY, name VARCHAR(255), type VARCHAR(255), region VARCHAR(255)); INSERT INTO expedition_vessels (id, name, type, region) VALUES (1, 'Sea Researcher', 'Research Vessel', 'Arctic Ocean');", "reference_sql": "SELECT v.name, v.type FROM expedition_vessels v INNER JOIN ocean_acidification oa ON v.region = oa.region WHERE oa.acidification_level = (SELECT MIN(acidification_level) FROM ocean_acidification);", "generated_sql": "SELECT MIN(acidification_level) AS min_level\n    FROM ocean_acidification\n),\nRegionsWithMinAcidification AS (\n    SELECT region\n    FROM ocean_acidification, MinAcidification\n    WHERE acidification_level = min_level\n)\nSELECT name, type\nFROM expedition_vessels\nWHERE region IN (SELECT region FROM RegionsWithMinAcidification);", "raw_model_output": "WITH MinAcidification AS (\n    SELECT MIN(acidification_level) AS min_level\n    FROM ocean_acidification\n),\nRegionsWithMinAcidification AS (\n    SELECT region\n    FROM ocean_acidification, MinAcidification\n    WHERE acidification_level = min_level\n)\nSELECT name, type\nFROM expedition_vessels\nWHERE region IN (SELECT region FROM RegionsWithMinAcidification);", "latency_sec": 1.1615591049194336, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 223, "prompt_eval_sec": null, "tokens_completion": 87, "completion_eval_sec": null, "tokens_total": 310, "tokens_per_sec": 266.88267406031116, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve expedition vessels located in regions with the minimum acidification level. The Reference SQL uses an INNER JOIN with a subquery to filter by the minimum acidification level, while the Generated SQL uses CTEs to first identify regions with the minimum level and then select vessels in those regions. Both approaches ultimately filter vessels based on regions associated with the minimum acidification value, producing identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries are technically equivalent and fulfill the business intent of identifying vessels in regions with the lowest ocean acidification levels. The Reference SQL achieves this with a simpler, more direct approach using a single INNER JOIN and subquery. The Generated SQL uses CTEs and a cross join (implicit via comma), which adds unnecessary complexity without improving correctness. While both produce identical results, the Reference SQL is more efficient, readable, and elegant.", "overall_assessment": "correct"}}
{"example_id": 4349, "sql_complexity": "multiple_joins", "prompt": "Show the research grants awarded to professors in the Computer Science department.", "context": "CREATE TABLE departments (id INT, name VARCHAR(50)); INSERT INTO departments (id, name) VALUES (1, 'Computer Science'), (2, 'Mathematics'); CREATE TABLE professors (id INT, name VARCHAR(50), department_id INT); INSERT INTO professors (id, name, department_id) VALUES (1, 'John Smith', 1), (2, 'Jane Doe', 2); CREATE TABLE grants (id INT, professor_id INT, year INT, amount FLOAT); INSERT INTO grants (id, professor_id, year, amount) VALUES (1, 1, 2021, 5000.0), (2, 2, 2020, 7000.0);", "reference_sql": "SELECT professors.name, grants.amount FROM professors INNER JOIN grants ON professors.id = grants.professor_id INNER JOIN departments ON professors.department_id = departments.id WHERE departments.name = 'Computer Science';", "generated_sql": "SELECT g.*\nFROM grants g\nJOIN professors p ON g.professor_id = p.id\nJOIN departments d ON p.department_id = d.id\nWHERE d.name = 'Computer Science';", "raw_model_output": "SELECT g.*\nFROM grants g\nJOIN professors p ON g.professor_id = p.id\nJOIN departments d ON p.department_id = d.id\nWHERE d.name = 'Computer Science';", "latency_sec": 0.8383450508117676, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 227, "prompt_eval_sec": null, "tokens_completion": 39, "completion_eval_sec": null, "tokens_total": 266, "tokens_per_sec": 317.2917878413343, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL selects specific columns (professors.name and grants.amount), while the Generated SQL selects all columns from the grants table (g.*). This results in different output structures, making them semantically distinct.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because they select different columns (Reference selects specific columns, while Generated uses SELECT *). Both correctly join the required tables and filter for 'Computer Science' department. The Generated query better fulfills the business intent by returning all grant details (which aligns with 'research grants' as a dataset) and uses concise aliases. While the Reference includes professor names, the original question focuses on grants, not professor identities. The Generated query is more elegant with table aliases and avoids potential ambiguity in column selection.", "overall_assessment": "differently_correct"}}
{"example_id": 476, "sql_complexity": "basic SQL", "prompt": "Insert new food safety records for locations \"A123\", \"B456\", and \"C789\"", "context": "CREATE TABLE food_safety_records (id INT, location VARCHAR(255), inspection_date DATE, violation_count INT);", "reference_sql": "INSERT INTO food_safety_records (location, inspection_date, violation_count) VALUES ('A123', '2022-03-01', 0), ('B456', '2022-03-05', 2), ('C789', '2022-03-10', 1);", "generated_sql": "INSERT INTO food_safety_records (location, inspection_date, violation_count) VALUES\n('A123', CURRENT_DATE, 0),\n('B456', CURRENT_DATE, 0),\n('C789', CURRENT_DATE, 0);", "raw_model_output": "INSERT INTO food_safety_records (location, inspection_date, violation_count) VALUES\n('A123', CURRENT_DATE, 0),\n('B456', CURRENT_DATE, 0),\n('C789', CURRENT_DATE, 0);", "latency_sec": 0.6306962966918945, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 110, "prompt_eval_sec": null, "tokens_completion": 48, "completion_eval_sec": null, "tokens_total": 158, "tokens_per_sec": 250.5167714298243, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL inserts specific dates (2022-03-01, 2022-03-05, 2022-03-10) with varying violation counts (0, 2, 1), while the Generated SQL uses CURRENT_DATE (which would insert today's date) and sets all violation_counts to 0. The inspection dates and violation counts differ between the two queries.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent because they insert different data. The Reference SQL uses specific inspection dates and violation counts for each location, while the Generated SQL uses CURRENT_DATE (dynamic) and fixed 0 violation counts. The original question only specified location identifiers without data details, making both queries partially correct. However, the Reference SQL better fulfills the intent of inserting 'new food safety records' with realistic, varied data (dates and violations), whereas the Generated SQL assumes default values not mentioned in the question. The Generated SQL could be seen as less accurate if the business requires specific historical data. Both queries are syntactically correct but differ in data assumptions.", "overall_assessment": "differently_correct"}}
{"example_id": 2908, "sql_complexity": "single join", "prompt": "List all co-owners and the properties they own in New York, NY.", "context": "CREATE TABLE properties (id INT, city VARCHAR(50), price INT); CREATE TABLE co_owners (property_id INT, owner_name VARCHAR(50)); INSERT INTO properties (id, city, price) VALUES (1, 'New York', 800000), (2, 'Los Angeles', 600000); INSERT INTO co_owners (property_id, owner_name) VALUES (1, 'David'), (1, 'Ella'), (2, 'Frank');", "reference_sql": "SELECT properties.city, co_owners.owner_name FROM properties INNER JOIN co_owners ON properties.id = co_owners.property_id WHERE properties.city = 'New York';", "generated_sql": "SELECT co_owners.owner_name, properties.id AS property_id, properties.city, properties.price\nFROM co_owners\nJOIN properties ON co_owners.property_id = properties.id\nWHERE properties.city = 'New York';", "raw_model_output": "```sql\nSELECT co_owners.owner_name, properties.id AS property_id, properties.city, properties.price\nFROM co_owners\nJOIN properties ON co_owners.property_id = properties.id\nWHERE properties.city = 'New York';\n```", "latency_sec": 0.6810879707336426, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 178, "prompt_eval_sec": null, "tokens_completion": 49, "completion_eval_sec": null, "tokens_total": 227, "tokens_per_sec": 333.29027930927055, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects only 'city' and 'owner_name', while the Generated SQL includes additional columns ('owner_name', 'property_id', 'city', 'price'). The extra columns and different column order in the Generated SQL result in a different output structure, even though both queries retrieve data from the same tables with the same join condition and filter.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because the generated query includes additional columns (property_id, price) not present in the reference. Both correctly join properties and co_owners tables with the same WHERE condition filtering for 'New York'. The reference query focuses on city and owner_name, while the generated query provides more detailed property information (id, price) which better fulfills the business intent of 'listing properties they own' by including explicit property identifiers. The generated query is more comprehensive and elegant in addressing the full scope of the question.", "overall_assessment": "differently_correct"}}
{"example_id": 636, "sql_complexity": "set operations", "prompt": "Insert new data into the 'cosmetic_ingredients' table for a vegan eyeshadow product by brand 'Ara' with ingredients 'Mica', 'Iron Oxide', 'Titanium Dioxide' and 'Zinc Oxide'.", "context": "CREATE TABLE cosmetic_ingredients (ingredient_id INT, product_name TEXT, brand_name TEXT, ingredient_type TEXT);", "reference_sql": "INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type) VALUES (NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient'); INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type, ingredient_name) SELECT ingredient_id, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Mica' FROM cosmetic_ingredients WHERE ingredient_name = 'Mica' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Iron Oxide' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Titanium Dioxide' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Zinc Oxide';", "generated_sql": "INSERT INTO cosmetic_ingredients (product_name, brand_name, ingredient_type) VALUES \n('vegan eyeshadow', 'Ara', 'Mica'),\n('vegan eyeshadow', 'Ara', 'Iron Oxide'),\n('vegan eyeshadow', 'Ara', 'Titanium Dioxide'),\n('vegan eyeshadow', 'Ara', 'Zinc Oxide');", "raw_model_output": "INSERT INTO cosmetic_ingredients (product_name, brand_name, ingredient_type) VALUES \n('vegan eyeshadow', 'Ara', 'Mica'),\n('vegan eyeshadow', 'Ara', 'Iron Oxide'),\n('vegan eyeshadow', 'Ara', 'Titanium Dioxide'),\n('vegan eyeshadow', 'Ara', 'Zinc Oxide');", "latency_sec": 1.168483018875122, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 136, "prompt_eval_sec": null, "tokens_completion": 75, "completion_eval_sec": null, "tokens_total": 211, "tokens_per_sec": 180.57600888639868, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL attempts to insert into a non-existent 'ingredient_name' column (schema mismatch) and includes a row with 'ingredient_type' as 'Ingredient' alongside other rows with 'ingredient_type' as specific ingredients. The Generated SQL omits 'ingredient_id' (assuming it's nullable or has a default), uses lowercase product names, and directly assigns ingredient names to 'ingredient_type' instead of a separate 'ingredient_name' column. Additionally, the Reference SQL inserts 5 rows (1 initial + 4 via UNION), while the Generated SQL inserts 4 rows.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL contains critical errors: it references an 'ingredient_name' column that doesn't exist in the schema, and the initial INSERT statement inserts a generic 'Ingredient' type without actual ingredient names. The Generated SQL correctly inserts the specified ingredients into the available columns (product_name, brand_name, ingredient_type) using proper syntax. While both queries aim to add data for Ara's vegan eyeshadow, the Generated SQL directly addresses the business intent by inserting the exact ingredient names as the 'ingredient_type' value, which is the only available column for ingredient data in the given schema. The Reference SQL's approach is invalid due to schema mismatch and incomplete data insertion.", "overall_assessment": "differently_correct"}}
{"example_id": 3404, "sql_complexity": "multiple_joins", "prompt": "What are the names of startups that have received funding from investors with over 3 million funds, and are involved in Genetic Research or Bioprocess Engineering?", "context": "CREATE TABLE public.investors ( id SERIAL PRIMARY KEY, name VARCHAR(100), type VARCHAR(50), funds INTEGER ); CREATE TABLE public.investments ( id SERIAL PRIMARY KEY, investor_id INTEGER, startup_id INTEGER ); CREATE TABLE public.startups ( id SERIAL PRIMARY KEY, name VARCHAR(100), industry VARCHAR(50), funding INTEGER );", "reference_sql": "SELECT startups.name FROM public.startups JOIN public.investments ON startups.id = investments.startup_id JOIN public.investors ON investments.investor_id = investors.id WHERE (startups.industry = 'Genetic Research' OR startups.industry = 'Bioprocess Engineering') AND investors.funds > 3000000;", "generated_sql": "SELECT DISTINCT s.name\nFROM startups s\nJOIN investments i ON s.id = i.startup_id\nJOIN investors inv ON i.investor_id = inv.id\nWHERE inv.funds > 3000000\n  AND s.industry IN ('Genetic Research', 'Bioprocess Engineering');", "raw_model_output": "```sql\nSELECT DISTINCT s.name\nFROM startups s\nJOIN investments i ON s.id = i.startup_id\nJOIN investors inv ON i.investor_id = inv.id\nWHERE inv.funds > 3000000\n  AND s.industry IN ('Genetic Research', 'Bioprocess Engineering');\n```", "latency_sec": 1.0858509540557861, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 167, "prompt_eval_sec": null, "tokens_completion": 66, "completion_eval_sec": null, "tokens_total": 233, "tokens_per_sec": 214.5782523188072, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the use of DISTINCT in the Generated SQL, which ensures unique results, while the Reference SQL may return duplicates. Additionally, the Generated SQL uses IN for industry filtering (equivalent to OR) and table aliases, but these are syntactic differences. The presence of DISTINCT could lead to different result sets if duplicate startup names exist under the given conditions.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "While both queries correctly identify startups in the specified industries with investors having >3M funds, they differ in technical implementation. The generated query uses DISTINCT to eliminate potential duplicate startup names (which could occur if a startup has multiple qualifying investors), whereas the reference query might return duplicates. The IN clause in the generated query is semantically equivalent to the OR condition in the reference query. The generated query better fulfills the business intent by ensuring unique startup names, which aligns with the phrasing 'names of startups' in the original question. Both queries are logically correct but the generated version is more precise in handling duplicates.", "overall_assessment": "differently_correct"}}
{"example_id": 134, "sql_complexity": "subqueries", "prompt": "Who are the top 3 authors with the most citations in the Mathematics department in the past 5 years?", "context": "CREATE TABLE authors (id INT, name VARCHAR(50), department VARCHAR(50)); INSERT INTO authors (id, name, department) VALUES (1, 'Author Name', 'Mathematics'); CREATE TABLE publications (id INT, title VARCHAR(100), author VARCHAR(50), journal VARCHAR(50), year INT, cites INT); INSERT INTO publications (id, title, author, journal, year, cites) VALUES (1, 'Publication Title', 'Author Name', 'Journal Name', 2021, 10);", "reference_sql": "SELECT author, SUM(cites) as total_cites FROM publications WHERE author IN (SELECT name FROM authors WHERE department = 'Mathematics') AND year BETWEEN YEAR(CURRENT_DATE) - 5 AND YEAR(CURRENT_DATE) GROUP BY author ORDER BY total_cites DESC LIMIT 3;", "generated_sql": "SELECT a.name, SUM(p.cites) AS total_citations\nFROM authors a\nJOIN publications p ON a.name = p.author\nWHERE a.department = 'Mathematics'\n  AND p.year >= YEAR(CURRENT_DATE) - 5\nGROUP BY a.name\nORDER BY total_citations DESC\nLIMIT 3;", "raw_model_output": "SELECT a.name, SUM(p.cites) AS total_citations\nFROM authors a\nJOIN publications p ON a.name = p.author\nWHERE a.department = 'Mathematics'\n  AND p.year >= YEAR(CURRENT_DATE) - 5\nGROUP BY a.name\nORDER BY total_citations DESC\nLIMIT 3;", "latency_sec": 1.0252349376678467, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 196, "prompt_eval_sec": null, "tokens_completion": 68, "completion_eval_sec": null, "tokens_total": 264, "tokens_per_sec": 257.501954235518, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their year filtering logic. The Reference SQL uses `BETWEEN YEAR(CURRENT_DATE) - 5 AND YEAR(CURRENT_DATE)` which explicitly includes both lower and upper bounds (e.g., 2018-2023 if current year is 2023). The Generated SQL uses `p.year >= YEAR(CURRENT_DATE) - 5` which only enforces the lower bound, allowing years beyond the current year. This makes the Generated SQL potentially include more records (e.g., 2024+ if current year is 2023) compared to the Reference SQL. Additionally, the Generated SQL uses an explicit JOIN while the Reference uses a subquery, but this does not affect semantic equivalence as both achieve the same filtering of authors in the 'Mathematics' department.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically correct and produce equivalent results. The Reference SQL uses a subquery to filter authors in the Mathematics department, while the Generated SQL uses an explicit JOIN between authors and publications tables. The date filtering logic (past 5 years) is equivalent in both queries. However, the Generated SQL is more robust because it explicitly joins the authors table, ensuring that only valid authors in the Mathematics department are considered. The Reference SQL's subquery approach could potentially include authors with matching names but incorrect department assignments if there were data inconsistencies, though this is mitigated by the WHERE clause. The Generated SQL's JOIN structure is more maintainable and semantically clearer for this use case.", "overall_assessment": "correct"}}
{"example_id": 592, "sql_complexity": "set operations", "prompt": "How many public healthcare facilities and public parks are there in total, in the 'StateData' schema's 'StateHealthcare' and 'StateParks' tables?", "context": "CREATE SCHEMA StateData; CREATE TABLE StateHealthcare (Name varchar(255), Type varchar(255)); INSERT INTO StateHealthcare (Name, Type) VALUES ('FacilityA', 'Public'), ('FacilityB', 'Public'), ('FacilityC', 'Private'); CREATE TABLE StateParks (Name varchar(255), Type varchar(255)); INSERT INTO StateParks (Name, Type) VALUES ('ParkA', 'Public'), ('ParkB', 'Public'), ('ParkC', 'Private');", "reference_sql": "SELECT COUNT(*) FROM StateData.StateHealthcare WHERE Type = 'Public' UNION ALL SELECT COUNT(*) FROM StateData.StateParks WHERE Type = 'Public';", "generated_sql": "SELECT \n    (SELECT COUNT(*) FROM StateData.StateHealthcare WHERE Type = 'Public') +\n    (SELECT COUNT(*) FROM StateData.StateParks WHERE Type = 'Public') AS TotalPublicFacilitiesAndParks;", "raw_model_output": "SELECT \n    (SELECT COUNT(*) FROM StateData.StateHealthcare WHERE Type = 'Public') +\n    (SELECT COUNT(*) FROM StateData.StateParks WHERE Type = 'Public') AS TotalPublicFacilitiesAndParks;", "latency_sec": 0.8655266761779785, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 200, "prompt_eval_sec": null, "tokens_completion": 45, "completion_eval_sec": null, "tokens_total": 245, "tokens_per_sec": 283.0646434629596, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate counts (one for StateHealthcare and one for StateParks) as two rows via UNION ALL, while the Generated SQL returns a single row with the summed total of both counts. The result structures differ (two rows vs. one row), so they are not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query uses UNION ALL to return two separate counts (healthcare and parks) as two rows, while the generated query calculates a single summed total. The original question explicitly asks for a 'total' count, making the generated query's approach semantically correct for the business intent. Technically, they produce different result structures (two rows vs. one row with a sum). The generated query also avoids potential misinterpretation of the results as separate metrics rather than a combined total. Both queries are syntactically correct, but the generated version better addresses the explicit request for a combined total.", "overall_assessment": "differently_correct"}}
{"example_id": 1989, "sql_complexity": "single join", "prompt": "What are the names and production dates of garments made from fabrics with a sustainability score over 70, produced after 2021-01-01?", "context": "CREATE TABLE fabrics (id INT, name VARCHAR(50), type VARCHAR(50), sustainability_score INT); INSERT INTO fabrics (id, name, type, sustainability_score) VALUES (1, 'Organic Linen', 'Natural', 80); INSERT INTO fabrics (id, name, type, sustainability_score) VALUES (2, 'Recycled Nylon', 'Synthetic', 72);", "reference_sql": "SELECT garments.name, garments.production_date FROM garments JOIN fabrics ON garments.fabric_id = fabrics.id WHERE fabrics.sustainability_score > 70 AND garments.production_date > '2021-01-01';", "generated_sql": "SELECT g.name, g.production_date\nFROM garments g\nJOIN fabrics f ON g.fabric_id = f.id\nWHERE f.sustainability_score > 70\n  AND g.production_date > '2021-01-01';", "raw_model_output": "```sql\nSELECT g.name, g.production_date\nFROM garments g\nJOIN fabrics f ON g.fabric_id = f.id\nWHERE f.sustainability_score > 70\n  AND g.production_date > '2021-01-01';\n```", "latency_sec": 0.6722402572631836, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 173, "prompt_eval_sec": null, "tokens_completion": 52, "completion_eval_sec": null, "tokens_total": 225, "tokens_per_sec": 334.7017640925244, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between 'garments' and 'fabrics' tables on fabric_id, apply the same filters (sustainability_score > 70 and production_date > '2021-01-01'), and select the same columns (garments.name and garments.production_date). The generated query uses table aliases ('g' for garments, 'f' for fabrics) but maintains identical logical conditions and column references.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent as they perform identical joins, filters, and column selections. The reference query uses explicit table names while the generated query uses aliases (g/f), but this is purely syntactic style and does not affect results. Both correctly address the business intent by filtering fabrics with sustainability_score > 70 and production_date after 2021-01-01. The generated query's aliases improve readability without sacrificing clarity, but neither version is objectively more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 1388, "sql_complexity": "aggregation", "prompt": "What was the total donation amount by each organization in the last 30 days?", "context": "CREATE TABLE organization_donations (id INT, organization TEXT, donation_date DATE, donation_amount DECIMAL(10,2)); INSERT INTO organization_donations (id, organization, donation_date, donation_amount) VALUES (1, 'Organization A', '2021-03-15', 100.00), (2, 'Organization B', '2021-03-25', 200.00);", "reference_sql": "SELECT organization, SUM(donation_amount) FROM organization_donations WHERE donation_date >= DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY) GROUP BY organization;", "generated_sql": "SELECT \n    organization, \n    SUM(donation_amount) AS total_donation_amount\nFROM \n    organization_donations\nWHERE \n    donation_date >= CURRENT_DATE - INTERVAL '30' DAY\nGROUP BY \n    organization;", "raw_model_output": "```sql\nSELECT \n    organization, \n    SUM(donation_amount) AS total_donation_amount\nFROM \n    organization_donations\nWHERE \n    donation_date >= CURRENT_DATE - INTERVAL '30' DAY\nGROUP BY \n    organization;\n```", "latency_sec": 0.8207240104675293, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 167, "prompt_eval_sec": null, "tokens_completion": 53, "completion_eval_sec": null, "tokens_total": 220, "tokens_per_sec": 268.0560056658705, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the total donations per organization for the last 30 days. The date calculation syntax differs (DATE_SUB vs. CURRENT_DATE - INTERVAL), but both achieve the same logical result. The generated query adds an alias for the sum, which doesn't affect the semantic equivalence of the result set.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the total donations per organization for the last 30 days using date filtering and aggregation. The reference query uses MySQL's DATE_SUB function, while the generated query uses PostgreSQL-style interval subtraction (CURRENT_DATE - INTERVAL '30' DAY). Assuming the database system supports either syntax, both produce identical results. The generated query improves readability with a clear alias (total_donation_amount) and uses a more modern interval syntax. The reference query is functionally equivalent but slightly less descriptive.", "overall_assessment": "correct"}}
{"example_id": 1628, "sql_complexity": "window functions", "prompt": "What is the ranking of national security measures for Russia based on the publication date?", "context": "CREATE TABLE national_security (id INT, title VARCHAR(255), description TEXT, agency VARCHAR(255), date DATE); INSERT INTO national_security (id, title, description, agency, date) VALUES (1, 'National Cyber Strategy', 'Outlines the approach to protecting the American people and the American way of life in the digital age', 'White House', '2018-09-20'); INSERT INTO national_security (id, title, description, agency, date) VALUES (2, 'Cybersecurity and Infrastructure Security Agency Act of 2018', 'Establishes the Cybersecurity and Infrastructure Security Agency within the Department of Homeland Security', 'Congress', '2018-11-16'); INSERT INTO national_security (id, title, description, agency, date) VALUES (3, 'Russian Military Doctrine', 'Outlines the country\u2019s stance on military security', 'Russian Government', '2014-12-26');", "reference_sql": "SELECT title, description, agency, date, ROW_NUMBER() OVER (PARTITION BY agency ORDER BY date DESC) as ranking FROM national_security WHERE agency = 'Russian Government';", "generated_sql": "SELECT id, title, description, agency, date,\n       RANK() OVER (ORDER BY date) AS ranking\nFROM national_security\nWHERE agency = 'Russian Government'\nORDER BY date;", "raw_model_output": "```sql\nSELECT id, title, description, agency, date,\n       RANK() OVER (ORDER BY date) AS ranking\nFROM national_security\nWHERE agency = 'Russian Government'\nORDER BY date;\n```", "latency_sec": 0.6411709785461426, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 272, "prompt_eval_sec": null, "tokens_completion": 44, "completion_eval_sec": null, "tokens_total": 316, "tokens_per_sec": 492.8482582236194, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in several key aspects. 1) The Reference SQL uses ROW_NUMBER() with PARTITION BY agency and ORDER BY date DESC, while the Generated SQL uses RANK() with no partitioning and ORDER BY date (ascending). This leads to different ranking logic and potentially different results. 2) The Generated SQL includes an additional 'id' column not present in the Reference SQL. 3) The Generated SQL includes an ORDER BY clause not present in the Reference SQL. These differences mean the queries will not produce identical result sets.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent. The reference query uses ROW_NUMBER() with DESC ordering to rank Russian Government measures by newest first, while the generated query uses RANK() with ASC ordering (oldest first). The reference query's partitioning is redundant but harmless, whereas the generated query's RANK() function would produce different results than ROW_NUMBER() if there were date ties. The original question asks for 'ranking' without specifying order, but the reference's descending date order better aligns with typical ranking conventions (highest priority first). The generated query's ascending order and RANK() function fail to fully address the intent of ranking by publication date.", "overall_assessment": "differently_correct"}}
{"example_id": 2300, "sql_complexity": "aggregation", "prompt": "What is the minimum capacity for schools in each location ('community_development')?", "context": "CREATE TABLE community_development.schools (id INT, name VARCHAR(50), capacity INT, location VARCHAR(50));", "reference_sql": "SELECT location, MIN(capacity) FROM community_development.schools GROUP BY location;", "generated_sql": "SELECT location, MIN(capacity) AS min_capacity\nFROM community_development.schools\nGROUP BY location;", "raw_model_output": "```sql\nSELECT location, MIN(capacity) AS min_capacity\nFROM community_development.schools\nGROUP BY location;\n```", "latency_sec": 0.8556160926818848, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 107, "prompt_eval_sec": null, "tokens_completion": 27, "completion_eval_sec": null, "tokens_total": 134, "tokens_per_sec": 156.61229510069623, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries group schools by location and calculate the minimum capacity for each group. The generated query adds an explicit column alias ('min_capacity') for clarity, but this does not affect the semantic result. The core logic (grouping and aggregation) remains identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the minimum capacity per location using GROUP BY. The reference query omits an explicit column alias, while the generated query adds 'AS min_capacity' for clarity. The results would be semantically identical (same values, different column name). The generated query is more readable and follows best practices for column naming, making it slightly superior for business clarity without sacrificing technical correctness.", "overall_assessment": "correct"}}
{"example_id": 4976, "sql_complexity": "set operations", "prompt": "What is the most common hashtag used in posts made by users from Brazil?", "context": "CREATE TABLE posts (id INT, user_id INT, content TEXT, hashtags TEXT, post_date DATE); INSERT INTO posts (id, user_id, content, hashtags, post_date) VALUES (1, 1, 'Hello World', '#datascience', '2022-06-01'), (2, 1, 'I love data', '#ai', '2022-06-02'), (3, 2, 'Ol\u00e1 Mundo', '#brasil', '2022-06-03'); CREATE TABLE users (id INT, name VARCHAR(100), country VARCHAR(50)); INSERT INTO users (id, name, country) VALUES (1, 'Jo\u00e3o Silva', 'Brazil'), (2, 'Maria Souza', 'Brazil');", "reference_sql": "SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(hashtags, ' ', n.n), ' ', -1) hashtag, COUNT(*) count FROM posts JOIN users ON posts.user_id = users.id CROSS JOIN (SELECT 1 n UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5) n WHERE users.country = 'Brazil' GROUP BY hashtag ORDER BY count DESC LIMIT 1;", "generated_sql": "SELECT hashtags\nFROM posts p\nJOIN users u ON p.user_id = u.id\nWHERE u.country = 'Brazil'\nGROUP BY hashtags\nORDER BY COUNT(*) DESC\nLIMIT 1;", "raw_model_output": "```sql\nSELECT hashtags\nFROM posts p\nJOIN users u ON p.user_id = u.id\nWHERE u.country = 'Brazil'\nGROUP BY hashtags\nORDER BY COUNT(*) DESC\nLIMIT 1;\n```", "latency_sec": 0.6727838516235352, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 235, "prompt_eval_sec": null, "tokens_completion": 44, "completion_eval_sec": null, "tokens_total": 279, "tokens_per_sec": 414.694852331441, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL splits multi-word hashtags (if present) into individual elements using SUBSTRING_INDEX, while the Generated SQL treats the entire hashtags column as a single string. Although the sample data contains single hashtags, the Reference SQL's logic is designed for scenarios with multiple hashtags, leading to different results in general cases. The Generated SQL lacks the splitting logic and groups by the raw hashtags column directly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly handles multiple hashtags per post by splitting them into individual rows using SUBSTRING_INDEX and a numbers table, ensuring accurate counting of each hashtag. The Generated SQL incorrectly treats multi-tag posts as single entities (e.g., '#datascience #ai' would be counted as one hashtag), leading to incorrect results. While both queries filter Brazilian users, only the Reference SQL addresses the actual requirement of counting individual hashtags. The Generated SQL is simpler but fundamentally flawed for the task.", "overall_assessment": "differently_correct"}}
{"example_id": 4637, "sql_complexity": "single join", "prompt": "What is the total value of transactions for each customer in the last 30 days?", "context": "CREATE TABLE transactions (id INT, customer_id INT, value DECIMAL(10, 2), transaction_date DATE); INSERT INTO transactions (id, customer_id, value, transaction_date) VALUES (1, 1, 100, '2022-01-01'), (2, 1, 200, '2022-01-15'), (3, 2, 50, '2022-01-05'), (4, 2, 150, '2022-01-30'), (5, 3, 300, '2022-01-20');", "reference_sql": "SELECT c.id, SUM(t.value) FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE t.transaction_date >= CURDATE() - INTERVAL 30 DAY GROUP BY c.id;", "generated_sql": "SELECT customer_id, SUM(value) AS total_value\nFROM transactions\nWHERE transaction_date >= CURRENT_DATE - INTERVAL '30' DAY\nGROUP BY customer_id;", "raw_model_output": "SELECT customer_id, SUM(value) AS total_value\nFROM transactions\nWHERE transaction_date >= CURRENT_DATE - INTERVAL '30' DAY\nGROUP BY customer_id;", "latency_sec": 0.7833230495452881, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 208, "prompt_eval_sec": null, "tokens_completion": 34, "completion_eval_sec": null, "tokens_total": 242, "tokens_per_sec": 308.9402260542171, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of transaction values for each customer over the last 30 days. The Reference SQL uses an INNER JOIN with customers (which doesn't affect the result since transactions already imply existing customers) and groups by c.id, while the Generated SQL directly groups by customer_id. The date filtering logic (CURDATE() - INTERVAL 30 DAY vs CURRENT_DATE - INTERVAL '30' DAY) is equivalent in MySQL. Both return the same customer identifiers and aggregated values.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries differ in two key technical aspects. 1) The Reference SQL uses an INNER JOIN with the customers table, while the Generated SQL directly queries the transactions table. This difference is not critical for the core functionality, as both ultimately group by customer_id. 2) The most significant difference lies in the date calculation. The Reference SQL uses the MySQL-specific CURDATE() function, while the Generated SQL uses CURRENT_DATE with an interval expressed as a string ('30' DAY). This syntax is invalid in MySQL, which requires numeric literals for intervals (e.g., INTERVAL 30 DAY).  The Generated SQL would fail to execute in a MySQL environment, making it technically incorrect. Both queries fulfill the business intent of calculating the total transaction value per customer for the last 30 days, assuming the date calculation is corrected. However, the Reference SQL is technically correct and more portable across different SQL dialects.", "overall_assessment": "differently_correct"}}
{"example_id": 4947, "sql_complexity": "aggregation", "prompt": "What is the total revenue for drugs approved between 2017 and 2019?", "context": "CREATE TABLE drug_sales_3 (drug_name TEXT, revenue FLOAT, year INT); INSERT INTO drug_sales_3 (drug_name, revenue, year) VALUES ('DrugG', 20000000, 2019), ('DrugG', 19000000, 2018), ('DrugH', 15000000, 2017), ('DrugH', 16000000, 2018);", "reference_sql": "SELECT drug_name, SUM(revenue) FROM drug_sales_3 WHERE year BETWEEN 2017 AND 2019 GROUP BY drug_name;", "generated_sql": "SELECT SUM(revenue) AS total_revenue\nFROM drug_sales_3\nWHERE year BETWEEN 2017 AND 2019;", "raw_model_output": "SELECT SUM(revenue) AS total_revenue\nFROM drug_sales_3\nWHERE year BETWEEN 2017 AND 2019;", "latency_sec": 0.7671430110931396, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 168, "prompt_eval_sec": null, "tokens_completion": 28, "completion_eval_sec": null, "tokens_total": 196, "tokens_per_sec": 255.49343103668505, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query groups results by drug_name and calculates individual drug revenues, while the generated query returns a single total revenue for all drugs combined. The GROUP BY clause in the reference query ensures per-drug aggregation, whereas the generated query lacks this and sums all revenues into one value.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query groups results by drug_name, returning per-drug revenue totals, while the generated query calculates a single overall total revenue. The original question asks for 'total revenue for drugs' (singular), which implies a single aggregate value rather than per-drug breakdowns. The generated query correctly sums all revenues within the specified years, aligning with the business intent of calculating overall revenue. The reference query, while technically correct for a different question, does not fulfill the original intent of providing a single total. Both queries are syntactically valid, but the generated version is more efficient and directly addresses the stated requirement.", "overall_assessment": "correct"}}
{"example_id": 4767, "sql_complexity": "window functions", "prompt": "List the top 2 AI algorithms with the highest explainability scores, by algorithm subtype, ordered by scores in descending order for the European region.", "context": "CREATE TABLE ai_algorithms (algorithm_id INT, algorithm_name VARCHAR(50), algorithm_subtype VARCHAR(50), region VARCHAR(50), explainability_score FLOAT); INSERT INTO ai_algorithms (algorithm_id, algorithm_name, algorithm_subtype, region, explainability_score) VALUES (1, 'AlgoA', 'Tree-based', 'Europe', 0.85), (2, 'AlgoB', 'Computer Vision', 'Europe', 0.92), (3, 'AlgoC', 'Tree-based', 'Europe', 0.78), (4, 'AlgoD', 'Transformer', 'Europe', 0.90), (5, 'AlgoE', 'Tree-based', 'Europe', 0.80);", "reference_sql": "SELECT algorithm_subtype, region, * FROM (SELECT algorithm_subtype, region, algorithm_id, algorithm_name, explainability_score, RANK() OVER (PARTITION BY algorithm_subtype ORDER BY explainability_score DESC) AS rank FROM ai_algorithms WHERE region = 'Europe') ranked WHERE rank <= 2 ORDER BY algorithm_subtype, region, explainability_score DESC;", "generated_sql": "SELECT\n    algorithm_id,\n    algorithm_name,\n    algorithm_subtype,\n    explainability_score,\n    ROW_NUMBER() OVER (PARTITION BY algorithm_subtype ORDER BY explainability_score DESC) AS rn\n  FROM ai_algorithms\n  WHERE region = 'Europe'\n)\nSELECT\n  algorithm_id,\n  algorithm_name,\n  algorithm_subtype,\n  explainability_score\nFROM RankedAlgorithms\nWHERE rn <= 2\nORDER BY algorithm_subtype, explainability_score DESC;", "raw_model_output": "WITH RankedAlgorithms AS (\n  SELECT\n    algorithm_id,\n    algorithm_name,\n    algorithm_subtype,\n    explainability_score,\n    ROW_NUMBER() OVER (PARTITION BY algorithm_subtype ORDER BY explainability_score DESC) AS rn\n  FROM ai_algorithms\n  WHERE region = 'Europe'\n)\nSELECT\n  algorithm_id,\n  algorithm_name,\n  algorithm_subtype,\n  explainability_score\nFROM RankedAlgorithms\nWHERE rn <= 2\nORDER BY algorithm_subtype, explainability_score DESC;", "latency_sec": 1.0685839653015137, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 246, "prompt_eval_sec": null, "tokens_completion": 104, "completion_eval_sec": null, "tokens_total": 350, "tokens_per_sec": 327.5362642197643, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects: 1) The Reference SQL uses RANK() while the Generated SQL uses ROW_NUMBER(), which handle ties differently. 2) The Reference SQL selects all columns (including the rank) via *, whereas the Generated SQL only selects specific columns. These differences in both ranking logic and column selection make the result sets non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in two critical aspects: 1) The Reference SQL uses RANK() which handles ties by allowing multiple entries with the same rank, while the Generated SQL uses ROW_NUMBER() which assigns unique ranks. 2) The Generated SQL contains a syntax error - the subquery is not properly enclosed (missing a CTE or subquery wrapper). The Reference SQL is syntactically correct and would return the top 2 algorithms per subtype by explainability score, but might include more than 2 rows if there are ties. The Generated SQL is invalid and would fail to execute.", "overall_assessment": "incorrect"}}
{"example_id": 4495, "sql_complexity": "basic SQL", "prompt": "Which countries are the top 3 sources of sustainable textiles?", "context": "CREATE TABLE Textile_Sources (Source_ID INT, Source_Country TEXT, Sustainable BOOLEAN, Quantity INT); INSERT INTO Textile_Sources (Source_ID, Source_Country, Sustainable, Quantity) VALUES (1, 'India', true, 1000), (2, 'Bangladesh', false, 800), (3, 'China', true, 1200), (4, 'Vietnam', false, 900), (5, 'Italy', true, 1100), (6, 'USA', false, 700);", "reference_sql": "SELECT Source_Country FROM Textile_Sources WHERE Sustainable = true ORDER BY Quantity DESC LIMIT 3;", "generated_sql": "SELECT Source_Country\nFROM Textile_Sources\nWHERE Sustainable = TRUE\nORDER BY Quantity DESC\nLIMIT 3;", "raw_model_output": "SELECT Source_Country\nFROM Textile_Sources\nWHERE Sustainable = TRUE\nORDER BY Quantity DESC\nLIMIT 3;", "latency_sec": 1.0593597888946533, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 188, "prompt_eval_sec": null, "tokens_completion": 25, "completion_eval_sec": null, "tokens_total": 213, "tokens_per_sec": 201.06483390524605, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. The only difference is the case of the boolean literal ('true' vs 'TRUE'), which does not affect the query's logic or result. Both queries select the same columns, apply the same filter (Sustainable = true), sort by Quantity descending, and limit to 3 results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are syntactically identical except for the case of the BOOLEAN literal ('true' vs 'TRUE'). SQL is case-insensitive for boolean values, so they will produce identical results. The queries correctly filter sustainable sources (Sustainable = true), order by quantity descending, and limit to top 3 countries. Both effectively answer the business question by identifying the three largest sustainable textile suppliers. The generated query uses uppercase TRUE which is a style preference but does not affect functionality. Neither query is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 2513, "sql_complexity": "single join", "prompt": "What is the total number of concert ticket sales for artists who released their first album between 2015 and 2017?", "context": "CREATE TABLE ConcertTicketSales (id INT, year INT, artist_id INT); CREATE TABLE ArtistAlbums (id INT, artist_id INT, year INT);", "reference_sql": "SELECT COUNT(DISTINCT cts.artist_id) FROM ConcertTicketSales cts JOIN ArtistAlbums a ON cts.artist_id = a.artist_id WHERE a.year BETWEEN 2015 AND 2017;", "generated_sql": "SELECT COUNT(*)\nFROM ConcertTicketSales cts\nWHERE cts.artist_id IN (\n    SELECT aa.artist_id\n    FROM ArtistAlbums aa\n    GROUP BY aa.artist_id\n    HAVING MIN(aa.year) BETWEEN 2015 AND 2017\n)", "raw_model_output": "```sql\nSELECT COUNT(*)\nFROM ConcertTicketSales cts\nWHERE cts.artist_id IN (\n    SELECT aa.artist_id\n    FROM ArtistAlbums aa\n    GROUP BY aa.artist_id\n    HAVING MIN(aa.year) BETWEEN 2015 AND 2017\n)\n```", "latency_sec": 0.7153110504150391, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 123, "prompt_eval_sec": null, "tokens_completion": 60, "completion_eval_sec": null, "tokens_total": 183, "tokens_per_sec": 255.83275959992426, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query counts distinct artists with any album between 2015-2017, while the generated query only includes artists whose earliest album is between 2015-2017. The generated query's HAVING clause with MIN(year) creates a stricter condition than the reference's BETWEEN filter on a.year.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query is technically incorrect because it joins ConcertTicketSales with ArtistAlbums and filters on any album year between 2015-2017, not the artist's *first* album. This would include artists with later albums in the range but whose first album was outside it. The generated query correctly identifies artists whose earliest album (via MIN(aa.year)) falls in 2015-2017 using a subquery. While both queries count artists, the generated query accurately filters by first album year. The reference query's COUNT(DISTINCT) counts unique artists with any album in the range, which doesn't align with the business intent. The generated query better fulfills the intent by addressing the 'first album' requirement.", "overall_assessment": "differently_correct"}}
{"example_id": 873, "sql_complexity": "subqueries", "prompt": "Identify attorneys who have never handled cases in the 'West' region but have in the 'North' or 'South'.", "context": "CREATE TABLE attorney_regions(attorney_id INT, region VARCHAR(20)); INSERT INTO attorney_regions(attorney_id, region) VALUES (1, 'North'), (2, 'South'), (3, 'East'), (4, 'West'), (5, 'West'), (6, 'North'); CREATE TABLE handled_cases(attorney_id INT, case_id INT); INSERT INTO handled_cases(attorney_id, case_id) VALUES (1, 101), (2, 102), (3, 103), (4, 104), (5, 105), (6, 106), (1, 107), (1, 108);", "reference_sql": "SELECT h.attorney_id FROM attorney_regions h LEFT JOIN handled_cases i ON h.attorney_id = i.attorney_id WHERE h.region IN ('North', 'South') AND h.region != 'West' AND i.attorney_id IS NOT NULL AND h.attorney_id NOT IN (SELECT attorney_id FROM attorney_regions WHERE region = 'West');", "generated_sql": "SELECT DISTINCT ar1.attorney_id\nFROM attorney_regions ar1\nWHERE ar1.region IN ('North', 'South')\n  AND ar1.attorney_id NOT IN (\n    SELECT ar2.attorney_id\n    FROM attorney_regions ar2\n    WHERE ar2.region = 'West'\n  )\n  AND ar1.attorney_id IN (\n    SELECT hc.attorney_id\n    FROM handled_cases hc\n  );", "raw_model_output": "SELECT DISTINCT ar1.attorney_id\nFROM attorney_regions ar1\nWHERE ar1.region IN ('North', 'South')\n  AND ar1.attorney_id NOT IN (\n    SELECT ar2.attorney_id\n    FROM attorney_regions ar2\n    WHERE ar2.region = 'West'\n  )\n  AND ar1.attorney_id IN (\n    SELECT hc.attorney_id\n    FROM handled_cases hc\n  );", "latency_sec": 5.61307168006897, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 225, "prompt_eval_sec": null, "tokens_completion": 86, "completion_eval_sec": null, "tokens_total": 311, "tokens_per_sec": 55.406383122507826, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL may return duplicate attorney_ids due to multiple cases (e.g., attorney 1 has 3 cases), while the Generated SQL uses SELECT DISTINCT to eliminate duplicates. This difference in output structure makes them non-equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically equivalent and fulfill the business intent. The Reference SQL uses a LEFT JOIN with a redundant 'h.region != 'West'' condition and checks for non-null handled cases, while the Generated SQL uses IN clauses for clarity and efficiency. The Generated SQL avoids unnecessary JOINs and explicitly ensures attorneys have handled cases via the IN clause, making it more efficient and readable. Both correctly identify attorneys in North/South regions without West region assignments, but the Generated version is more elegant.", "overall_assessment": "correct"}}
{"example_id": 471, "sql_complexity": "set operations", "prompt": "Find the number of donations made by first-time donors in the last quarter.", "context": "CREATE TABLE Donations (DonationID INT, DonorID INT, DonationDate DATE, DonationType TEXT, DonationAmount FLOAT); INSERT INTO Donations (DonationID, DonorID, DonationDate, DonationType, DonationAmount) VALUES (1, 1, '2021-01-01', 'Individual', 100), (2, 2, '2021-02-01', 'Corporate', 5000);", "reference_sql": "SELECT COUNT(*) FROM (SELECT DonationID FROM Donations WHERE DonationType = 'Individual' AND DonationDate >= DATEADD(quarter, -1, CURRENT_DATE) EXCEPT SELECT DonationID FROM PreviousDonations) AS FirstTimeDonors;", "generated_sql": "WITH FirstDonations AS (\n    SELECT DonorID, MIN(DonationDate) AS FirstDonationDate\n    FROM Donations\n    GROUP BY DonorID\n),\nLastQuarter AS (\n    SELECT \n        DATEADD(quarter, DATEDIFF(quarter, 0, CURRENT_DATE) - 1, 0) AS QuarterStart,\n        DATEADD(day, -1, DATEADD(quarter, DATEDIFF(quarter, 0, CURRENT_DATE), 0)) AS QuarterEnd\n)\nSELECT COUNT(*) AS NumberOfFirstTimeDonationsLastQuarter\nFROM Donations d\nJOIN FirstDonations fd ON d.DonorID = fd.DonorID AND d.DonationDate = fd.FirstDonationDate\nCROSS JOIN LastQuarter lq\nWHERE d.DonationDate BETWEEN lq.QuarterStart AND lq.QuarterEnd;", "raw_model_output": "```sql\nWITH FirstDonations AS (\n    SELECT DonorID, MIN(DonationDate) AS FirstDonationDate\n    FROM Donations\n    GROUP BY DonorID\n),\nLastQuarter AS (\n    SELECT \n        DATEADD(quarter, DATEDIFF(quarter, 0, CURRENT_DATE) - 1, 0) AS QuarterStart,\n        DATEADD(day, -1, DATEADD(quarter, DATEDIFF(quarter, 0, CURRENT_DATE), 0)) AS QuarterEnd\n)\nSELECT COUNT(*) AS NumberOfFirstTimeDonationsLastQuarter\nFROM Donations d\nJOIN FirstDonations fd ON d.DonorID = fd.DonorID AND d.DonationDate = fd.FirstDonationDate\nCROSS JOIN LastQuarter lq\nWHERE d.DonationDate BETWEEN lq.QuarterStart AND lq.QuarterEnd;\n```", "latency_sec": 1.8300433158874512, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 169, "prompt_eval_sec": null, "tokens_completion": 177, "completion_eval_sec": null, "tokens_total": 346, "tokens_per_sec": 189.0665630677778, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL counts 'Individual' donations in the last quarter not present in PreviousDonations, while the Generated SQL counts first-time donations (regardless of type) in the previous quarter. The logic, conditions, and tables involved differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL contains a critical error by referencing a non-existent 'PreviousDonations' table, making it technically invalid. The Generated SQL correctly identifies first-time donors by finding their earliest donation date (using FirstDonations CTE) and filters donations in the last quarter (using LastQuarter CTE). While both queries aim to count first-time donations in the last quarter, the Generated SQL properly handles the business logic without relying on undefined tables. The Reference SQL's approach with EXCEPT is logically flawed without the required table. The Generated SQL also explicitly defines the last quarter's date range, ensuring accurate temporal filtering.", "overall_assessment": "differently_correct"}}
{"example_id": 1301, "sql_complexity": "multiple_joins", "prompt": "What is the total quantity of corn sold by farmers in 'Summerfield'?", "context": "CREATE TABLE farmers (id INT, name VARCHAR(50), location VARCHAR(50), crops VARCHAR(50)); CREATE TABLE crops (id INT, name VARCHAR(50), yield INT); CREATE TABLE sales (id INT, farmer_id INT, crop_name VARCHAR(50), quantity INT, price DECIMAL(5,2)); INSERT INTO farmers VALUES (1, 'Jane Doe', 'Summerfield', 'Corn'); INSERT INTO crops VALUES (1, 'Corn', 100); INSERT INTO sales VALUES (1, 1, 'Corn', 50, 2.50);", "reference_sql": "SELECT SUM(quantity) FROM sales INNER JOIN farmers ON sales.farmer_id = farmers.id INNER JOIN crops ON sales.crop_name = crops.name WHERE farmers.location = 'Summerfield' AND crops.name = 'Corn';", "generated_sql": "SELECT SUM(s.quantity) AS total_quantity\nFROM sales s\nJOIN farmers f ON s.farmer_id = f.id\nWHERE f.location = 'Summerfield' AND s.crop_name = 'Corn';", "raw_model_output": "```sql\nSELECT SUM(s.quantity) AS total_quantity\nFROM sales s\nJOIN farmers f ON s.farmer_id = f.id\nWHERE f.location = 'Summerfield' AND s.crop_name = 'Corn';\n```", "latency_sec": 0.6696779727935791, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 200, "prompt_eval_sec": null, "tokens_completion": 47, "completion_eval_sec": null, "tokens_total": 247, "tokens_per_sec": 368.83399191051944, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes an INNER JOIN with the 'crops' table and filters on 'crops.name = 'Corn'', ensuring only sales with valid crop entries in the crops table are considered. The Generated SQL omits the crops table join and only filters on 'sales.crop_name = 'Corn'', which could include sales entries with crop names not present in the crops table. This difference in join conditions may lead to different results when invalid crop names exist in the sales table.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the total corn quantity sold by Summerfield farmers. The reference query includes an unnecessary join to the 'crops' table, which doesn't affect the result since the sales.corn_name filter is sufficient. The generated query is more efficient by avoiding this redundant join while maintaining semantic equivalence. Both satisfy the business intent, but the generated version is simpler and more elegant.", "overall_assessment": "correct"}}
{"example_id": 4667, "sql_complexity": "aggregation", "prompt": "Find the number of unique organizations in each country in the Philanthropy Trends table?", "context": "CREATE TABLE PhilanthropyTrends (OrgID INT, Name TEXT, Country TEXT);", "reference_sql": "SELECT Country, COUNT(DISTINCT OrgID) as UniqueOrganizations FROM PhilanthropyTrends GROUP BY Country;", "generated_sql": "SELECT Country, COUNT(DISTINCT OrgID) AS UniqueOrganizations\nFROM PhilanthropyTrends\nGROUP BY Country;", "raw_model_output": "```sql\nSELECT Country, COUNT(DISTINCT OrgID) AS UniqueOrganizations\nFROM PhilanthropyTrends\nGROUP BY Country;\n```", "latency_sec": 1.4144301414489746, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 102, "prompt_eval_sec": null, "tokens_completion": 30, "completion_eval_sec": null, "tokens_total": 132, "tokens_per_sec": 93.32380308636253, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select the 'Country' column and count distinct 'OrgID' values, grouping by 'Country'. The only differences are whitespace and formatting, which do not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure, logic, and output. They correctly group by 'Country' and count distinct 'OrgID' values to determine unique organizations per country. The formatting differences (e.g., line breaks, capitalization) do not affect functionality. Both queries perfectly fulfill the business intent of counting unique organizations by country.", "overall_assessment": "correct"}}
{"example_id": 1006, "sql_complexity": "subqueries", "prompt": "What is the average word count of news articles written by investigative journalists?", "context": "CREATE TABLE reporters (id INT, name VARCHAR(50), gender VARCHAR(10), age INT, position VARCHAR(20), country VARCHAR(50)); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (1, 'Anna Smith', 'Female', 35, 'News Reporter', 'USA'); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (2, 'Mike Johnson', 'Male', 40, 'Investigative Journalist', 'Canada'); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (3, 'Sofia Rodriguez', 'Female', 32, 'Investigative Journalist', 'Mexico'); CREATE TABLE news_articles (id INT, title VARCHAR(100), content TEXT, publication_date DATE, reporter_id INT); INSERT INTO news_articles (id, title, content, publication_date, reporter_id) VALUES (1, 'News Article 1', 'Content of News Article 1', '2021-01-01', 2); INSERT INTO news_articles (id, title, content, publication_date, reporter_id) VALUES (2, 'News Article 2', 'Content of News Article 2', '2021-02-01', 3);", "reference_sql": "SELECT AVG(LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1) AS avg_word_count FROM news_articles WHERE reporter_id IN (SELECT id FROM reporters WHERE position = 'Investigative Journalist');", "generated_sql": "SELECT AVG(LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1) AS average_word_count\nFROM news_articles na\nJOIN reporters r ON na.reporter_id = r.id\nWHERE r.position = 'Investigative Journalist';", "raw_model_output": "```sql\nSELECT AVG(LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1) AS average_word_count\nFROM news_articles na\nJOIN reporters r ON na.reporter_id = r.id\nWHERE r.position = 'Investigative Journalist';\n```", "latency_sec": 0.787686824798584, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 341, "prompt_eval_sec": null, "tokens_completion": 56, "completion_eval_sec": null, "tokens_total": 397, "tokens_per_sec": 504.00741449689116, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average word count of news articles written by investigative journalists. The Reference SQL uses a subquery with IN to filter reporter_ids, while the Generated SQL uses a JOIN to achieve the same filtering. The word count calculation (LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1) is identical in both queries. Both approaches will produce the same result set.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the average word count of articles by investigative journalists. The reference uses a subquery with IN, while the generated uses an explicit JOIN. Semantically, they produce identical results by filtering the same set of reporters. However, the generated query is more efficient and elegant: 1) JOINs are generally more performant than subqueries in relational databases, 2) the explicit JOIN condition improves readability, and 3) it avoids potential issues with subquery cardinality. Both fulfill the business intent of calculating the average word count for investigative journalists.", "overall_assessment": "correct"}}
{"example_id": 3635, "sql_complexity": "set operations", "prompt": "Which brands have certifications related to cruelty-free, vegan, or organic products?", "context": "CREATE TABLE brands (brand_name VARCHAR(50), is_cruelty_free BOOLEAN, is_vegan BOOLEAN, is_organic BOOLEAN); INSERT INTO brands (brand_name, is_cruelty_free, is_vegan, is_organic) VALUES ('Lush', TRUE, TRUE, FALSE), ('The Body Shop', TRUE, FALSE, FALSE), ('Est\u00e9e Lauder', FALSE, FALSE, FALSE), ('Urban Decay', TRUE, TRUE, FALSE), ('Maybelline', FALSE, FALSE, FALSE), ('Kat Von D', TRUE, TRUE, FALSE), ('Tarte', TRUE, TRUE, TRUE);", "reference_sql": "SELECT brand_name, 'Cruelty-free' as certification FROM brands WHERE is_cruelty_free = TRUE UNION SELECT brand_name, 'Vegan' as certification FROM brands WHERE is_vegan = TRUE UNION SELECT brand_name, 'Organic' as certification FROM brands WHERE is_organic = TRUE;", "generated_sql": "SELECT brand_name\nFROM brands\nWHERE is_cruelty_free = TRUE\n   OR is_vegan = TRUE\n   OR is_organic = TRUE;", "raw_model_output": "SELECT brand_name\nFROM brands\nWHERE is_cruelty_free = TRUE\n   OR is_vegan = TRUE\n   OR is_organic = TRUE;", "latency_sec": 0.5857219696044922, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 209, "prompt_eval_sec": null, "tokens_completion": 34, "completion_eval_sec": null, "tokens_total": 243, "tokens_per_sec": 414.87260613441794, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two columns (brand_name and certification type) with separate rows for each certification a brand meets, while the Generated SQL only returns brand_name and combines all conditions into a single column. The Reference SQL also implicitly removes duplicates across certification types, whereas the Generated SQL may return brands with multiple certifications as single entries. The result structures and data contents differ.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query returns each brand once per certification they hold (e.g., a brand with all three certifications would appear three times), while the generated query returns each brand only once regardless of how many certifications they have. Both correctly identify brands with at least one certification, but the generated query is more efficient and directly answers the business question of 'which brands' without unnecessary duplication. The reference query provides more detailed certification information but is less efficient and not strictly required by the original question.", "overall_assessment": "differently_correct"}}
{"example_id": 4932, "sql_complexity": "basic SQL", "prompt": "Delete the workout row with the id of 2.", "context": "CREATE TABLE Workouts (id INT, user_id INT, workout_name TEXT, calories INT); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (1, 1, 'Running', 300); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (2, 1, 'Cycling', 400); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (3, 2, 'Yoga', 200);", "reference_sql": "DELETE FROM Workouts WHERE id = 2;", "generated_sql": "DELETE FROM Workouts WHERE id = 2;", "raw_model_output": "DELETE FROM Workouts WHERE id = 2;", "latency_sec": 0.45660400390625, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 182, "prompt_eval_sec": null, "tokens_completion": 11, "completion_eval_sec": null, "tokens_total": 193, "tokens_per_sec": 422.685737200909, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure and purpose. Both execute the same DELETE operation on the Workouts table where the id equals 2, resulting in the removal of the same record (Cycling with 400 calories).", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in syntax, logic, and effect. They both correctly delete the row with id=2 from the Workouts table, matching the business requirement. The queries are equally efficient, semantically equivalent, and fulfill the intent of removing the specified workout record.", "overall_assessment": "correct"}}
{"example_id": 365, "sql_complexity": "aggregation", "prompt": "Identify the total number of military personnel and their corresponding rank for each branch and country in the 'military_personnel' table, sorted by the total number of personnel in descending order.", "context": "CREATE TABLE military_personnel (id INT, branch VARCHAR(255), rank VARCHAR(255), country VARCHAR(255), personnel INT);", "reference_sql": "SELECT branch, country, SUM(personnel) as total_personnel FROM military_personnel GROUP BY branch, country ORDER BY total_personnel DESC;", "generated_sql": "SELECT branch, country, rank, SUM(personnel) AS total_personnel\nFROM military_personnel\nGROUP BY branch, country, rank\nORDER BY total_personnel DESC;", "raw_model_output": "```sql\nSELECT branch, country, rank, SUM(personnel) AS total_personnel\nFROM military_personnel\nGROUP BY branch, country, rank\nORDER BY total_personnel DESC;\n```", "latency_sec": 7.6773481369018555, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 131, "prompt_eval_sec": null, "tokens_completion": 41, "completion_eval_sec": null, "tokens_total": 172, "tokens_per_sec": 22.40356916645042, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their GROUP BY clauses. The reference query groups by (branch, country), aggregating all ranks within each branch-country combination. The generated query groups by (branch, country, rank), which splits the aggregation into separate groups for each rank within branch-country pairs. This results in different aggregation levels and output rows.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly groups by branch and country to calculate total personnel per combination, while the generated query adds an unnecessary GROUP BY on rank. This causes the generated query to return per-rank totals instead of the requested overall totals per branch/country. The original question asks for 'total number of military personnel' without specifying rank-level breakdowns, making the reference query technically correct and semantically aligned with the business intent. The generated query violates the 'corresponding rank' requirement by aggregating ranks separately, leading to incorrect results. The reference is also more efficient as it processes fewer groupings.", "overall_assessment": "incorrect"}}
{"example_id": 521, "sql_complexity": "subqueries", "prompt": "How many vessels have not had an inspection in the past year?", "context": "CREATE TABLE safety_records(id INT, vessel_name VARCHAR(50), inspection_date DATE); CREATE TABLE vessels(id INT, name VARCHAR(50), country VARCHAR(50)); INSERT INTO vessels(id, name, country) VALUES (1, 'Vessel A', 'Philippines'), (2, 'Vessel B', 'Philippines'); INSERT INTO safety_records(id, vessel_name, inspection_date) VALUES (1, 'Vessel A', '2022-01-01');", "reference_sql": "SELECT COUNT(*) FROM vessels WHERE name NOT IN (SELECT vessel_name FROM safety_records WHERE inspection_date BETWEEN DATE_SUB(NOW(), INTERVAL 1 YEAR) AND NOW());", "generated_sql": "SELECT COUNT(*)\nFROM vessels v\nWHERE NOT EXISTS (\n    SELECT 1\n    FROM safety_records sr\n    WHERE sr.vessel_name = v.name\n      AND sr.inspection_date >= CURRENT_DATE - INTERVAL '1' YEAR\n);", "raw_model_output": "```sql\nSELECT COUNT(*)\nFROM vessels v\nWHERE NOT EXISTS (\n    SELECT 1\n    FROM safety_records sr\n    WHERE sr.vessel_name = v.name\n      AND sr.inspection_date >= CURRENT_DATE - INTERVAL '1' YEAR\n);\n```", "latency_sec": 0.944976806640625, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 176, "prompt_eval_sec": null, "tokens_completion": 56, "completion_eval_sec": null, "tokens_total": 232, "tokens_per_sec": 245.5086710802519, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their date condition handling. The Reference SQL uses BETWEEN with DATE_SUB(NOW(), INTERVAL 1 YEAR) (a DATETIME) and NOW(), which excludes inspection dates exactly on the start date (as they are treated as DATETIME 00:00:00). The Generated SQL uses >= CURRENT_DATE - INTERVAL '1' YEAR (a DATE), which includes those exact dates. This discrepancy makes the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify vessels without inspections in the past year. The reference query uses NOT IN with a subquery, while the generated query uses NOT EXISTS with a correlated subquery. The generated query is more efficient due to NOT EXISTS' early termination on matches and avoids potential NULL issues (though not critical here). Both handle date ranges correctly (DATE_SUB vs CURRENT_DATE - INTERVAL, which are functionally equivalent for DATE-typed inspection_date). The generated query's explicit correlation (sr.vessel_name = v.name) ensures clarity and correctness.", "overall_assessment": "correct"}}
{"example_id": 5687, "sql_complexity": "multiple_joins", "prompt": "List organizations with more than 200 volunteers, and their average donation amounts, excluding donations less than $10.", "context": "CREATE TABLE organizations (org_id INT, org_name TEXT, social_impact_score INT);CREATE TABLE volunteers (vol_id INT, org_id INT, vol_country TEXT);CREATE TABLE donations (donation_id INT, donor_id INT, donation_amount INT, donation_date DATE);", "reference_sql": "SELECT o.org_name, AVG(donation_amount) AS avg_donation_amount FROM organizations o JOIN volunteers v ON o.org_id = v.org_id JOIN donations don ON o.org_id = don.org_id WHERE donation_amount >= 10 GROUP BY o.org_name HAVING COUNT(v.vol_id) > 200;", "generated_sql": "SELECT \n    o.org_name,\n    AVG(d.donation_amount) AS avg_donation_amount\nFROM \n    organizations o\nJOIN \n    volunteers v ON o.org_id = v.org_id\nJOIN \n    donations d ON d.donor_id = o.org_id\nWHERE \n    d.donation_amount >= 10\nGROUP BY \n    o.org_id, o.org_name\nHAVING \n    COUNT(v.vol_id) > 200;", "raw_model_output": "```sql\nSELECT \n    o.org_name,\n    AVG(d.donation_amount) AS avg_donation_amount\nFROM \n    organizations o\nJOIN \n    volunteers v ON o.org_id = v.org_id\nJOIN \n    donations d ON d.donor_id = o.org_id\nWHERE \n    d.donation_amount >= 10\nGROUP BY \n    o.org_id, o.org_name\nHAVING \n    COUNT(v.vol_id) > 200;\n```", "latency_sec": 1.4265148639678955, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 144, "prompt_eval_sec": null, "tokens_completion": 96, "completion_eval_sec": null, "tokens_total": 240, "tokens_per_sec": 168.24220066830046, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their join conditions between the 'donations' table and 'organizations'. The Reference SQL uses 'o.org_id = don.org_id' (invalid as 'donations' lacks an 'org_id' column), while the Generated SQL uses 'd.donor_id = o.org_id' (a different relationship). Additionally, the Generated SQL groups by 'o.org_id' and 'o.org_name' (safer for uniqueness) whereas the Reference SQL groups only by 'o.org_name' (risking incorrect aggregation if names are non-unique). These differences in join logic and grouping make the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries differ in critical aspects. The Reference SQL incorrectly joins donations using 'don.org_id' (a non-existent column in the donations table), while the Generated SQL incorrectly joins donations on 'd.donor_id = o.org_id' (which conflates donor IDs with organization IDs). Both have logical flaws in linking donations to organizations. However, the Generated SQL groups by both 'org_id' and 'org_name', ensuring uniqueness, whereas the Reference SQL groups by 'org_name' alone, risking incorrect aggregation if organizations share names. The Generated SQL also explicitly filters donations >= $10, aligning with the exclusion requirement. Despite flawed join logic, the Generated SQL is more structurally sound in grouping and avoids potential name-based aggregation errors.", "overall_assessment": "differently_correct"}}
{"example_id": 1281, "sql_complexity": "subqueries", "prompt": "Find the top 3 contributors with the lowest recycling rate in the 'waste_contributors' table.", "context": "CREATE TABLE waste_contributors (contributor VARCHAR(20), recycling_rate FLOAT); INSERT INTO waste_contributors (contributor, recycling_rate) VALUES ('Manufacturing', 0.4), ('Commercial', 0.38), ('Residential', 0.35), ('Institutional', 0.32), ('Agricultural', 0.2), ('Industrial', 0.15);", "reference_sql": "SELECT contributor FROM waste_contributors WHERE recycling_rate IN (SELECT MIN(recycling_rate) FROM waste_contributors) LIMIT 3;", "generated_sql": "SELECT contributor, recycling_rate\nFROM waste_contributors\nORDER BY recycling_rate ASC\nLIMIT 3;", "raw_model_output": "SELECT contributor, recycling_rate\nFROM waste_contributors\nORDER BY recycling_rate ASC\nLIMIT 3;", "latency_sec": 0.7314648628234863, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 168, "prompt_eval_sec": null, "tokens_completion": 22, "completion_eval_sec": null, "tokens_total": 190, "tokens_per_sec": 259.7527368117064, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL selects contributors with the minimum recycling rate (0.15) and limits to 3 rows, returning only 'Industrial' (since it's the only one with the minimum). The Generated SQL orders all contributors by recycling rate ascending and returns the top 3 (Industrial, Agricultural, Institutional). The results differ in both row count and content.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query incorrectly uses a subquery to find only the absolute minimum recycling rate (which would return only 'Industrial' in this dataset) and then applies LIMIT 3. This approach would fail to return multiple contributors with the same minimum rate and would not properly retrieve the 3 lowest rates if there are ties. The generated query correctly sorts contributors by recycling_rate in ascending order and explicitly limits to the top 3, which aligns with the business requirement for the 'lowest' rates. While both queries are syntactically valid, only the generated query fulfills the intent of identifying the 3 contributors with the lowest rates.", "overall_assessment": "differently_correct"}}
{"example_id": 5669, "sql_complexity": "window functions", "prompt": "What is the total number of new and returning volunteers in each program in each month?", "context": "CREATE TABLE Volunteers (VolunteerID INT, VolunteerName TEXT, ProgramID INT, VolunteerDate DATE, IsReturning BOOLEAN); INSERT INTO Volunteers (VolunteerID, VolunteerName, ProgramID, VolunteerDate, IsReturning) VALUES (6, 'David Kim', 1, '2022-03-01', FALSE), (7, 'Emily Chen', 2, '2022-03-15', TRUE), (8, 'James Lee', 2, '2022-04-01', FALSE), (9, 'Grace Park', 3, '2022-04-15', TRUE), (10, 'Daniel Kim', 1, '2022-04-01', FALSE);", "reference_sql": "SELECT ProgramID, EXTRACT(MONTH FROM VolunteerDate) AS Month, SUM(CASE WHEN IsReturning THEN 1 ELSE 0 END) OVER (PARTITION BY ProgramID, EXTRACT(MONTH FROM VolunteerDate) ORDER BY ProgramID, EXTRACT(MONTH FROM VolunteerDate)) + COUNT(DISTINCT VolunteerID) OVER (PARTITION BY ProgramID, EXTRACT(MONTH FROM VolunteerDate) ORDER BY ProgramID, EXTRACT(MONTH FROM VolunteerDate)) AS TotalVolunteers FROM Volunteers;", "generated_sql": "SELECT \n    ProgramID,\n    EXTRACT(YEAR FROM VolunteerDate) AS Year,\n    EXTRACT(MONTH FROM VolunteerDate) AS Month,\n    SUM(CASE WHEN IsReturning = FALSE THEN 1 ELSE 0 END) AS NewVolunteers,\n    SUM(CASE WHEN IsReturning = TRUE THEN 1 ELSE 0 END) AS ReturningVolunteers\nFROM Volunteers\nGROUP BY ProgramID, EXTRACT(YEAR FROM VolunteerDate), EXTRACT(MONTH FROM VolunteerDate)\nORDER BY ProgramID, Year, Month;", "raw_model_output": "SELECT \n    ProgramID,\n    EXTRACT(YEAR FROM VolunteerDate) AS Year,\n    EXTRACT(MONTH FROM VolunteerDate) AS Month,\n    SUM(CASE WHEN IsReturning = FALSE THEN 1 ELSE 0 END) AS NewVolunteers,\n    SUM(CASE WHEN IsReturning = TRUE THEN 1 ELSE 0 END) AS ReturningVolunteers\nFROM Volunteers\nGROUP BY ProgramID, EXTRACT(YEAR FROM VolunteerDate), EXTRACT(MONTH FROM VolunteerDate)\nORDER BY ProgramID, Year, Month;", "latency_sec": 1.6374459266662598, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 228, "prompt_eval_sec": null, "tokens_completion": 110, "completion_eval_sec": null, "tokens_total": 338, "tokens_per_sec": 206.4190300855598, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL uses window functions to calculate a running total of returning volunteers and distinct volunteers per ProgramID and month, without grouping, resulting in multiple rows per group. The Generated SQL groups by ProgramID, year, and month, calculating separate counts for new and returning volunteers. Key differences include: 1) The Reference SQL lacks year extraction and groups by month only, while the Generated SQL includes year; 2) The Reference SQL returns all rows with aggregated values per row, whereas the Generated SQL aggregates into one row per group; 3) The Reference SQL sums two window functions, while the Generated SQL separates new/returning counts.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL fails to separate new and returning volunteers, instead combining them into a 'TotalVolunteers' column through incorrect window function logic. It lacks proper GROUP BY clauses, leading to potential overcounting. The Generated SQL correctly separates new and returning volunteers using explicit CASE statements, groups by ProgramID, Year, and Month (ensuring accurate monthly aggregation), and avoids window functions which are unnecessary for this task. While both queries lack explicit handling of 'new' vs 'returning' in their output, the Generated SQL directly addresses the business intent by providing distinct counts, whereas the Reference SQL conflates them. The Generated SQL also includes YEAR in the grouping, which is critical for accurate monthly aggregation across multiple years.", "overall_assessment": "differently_correct"}}
{"example_id": 3576, "sql_complexity": "window functions", "prompt": "What is the difference in the number of eco-friendly hotels between the top 2 countries?", "context": "CREATE TABLE eco_hotel_count (country TEXT, num_hotels INT); INSERT INTO eco_hotel_count (country, num_hotels) VALUES ('France', 100), ('Italy', 120), ('Germany', 150), ('Spain', 110), ('UK', 160);", "reference_sql": "SELECT (MAX(num_hotels) OVER (PARTITION BY num_hotels <= 2) - MIN(num_hotels) OVER (PARTITION BY num_hotels <= 2)) AS hotel_difference FROM eco_hotel_count WHERE country IN ('France', 'Italy');", "generated_sql": "SELECT ABS(\n    (SELECT num_hotels FROM eco_hotel_count ORDER BY num_hotels DESC LIMIT 1 OFFSET 0) -\n    (SELECT num_hotels FROM eco_hotel_count ORDER BY num_hotels DESC LIMIT 1 OFFSET 1)\n) AS difference;", "raw_model_output": "```sql\nSELECT ABS(\n    (SELECT num_hotels FROM eco_hotel_count ORDER BY num_hotels DESC LIMIT 1 OFFSET 0) -\n    (SELECT num_hotels FROM eco_hotel_count ORDER BY num_hotels DESC LIMIT 1 OFFSET 1)\n) AS difference;\n```", "latency_sec": 1.0004620552062988, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 144, "prompt_eval_sec": null, "tokens_completion": 61, "completion_eval_sec": null, "tokens_total": 205, "tokens_per_sec": 204.90532242897336, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the difference between max and min num_hotels for rows where num_hotels <= 2 (which affects all rows since none meet this condition) and filters countries to France/Italy. The Generated SQL computes the absolute difference between the top two num_hotels across all countries without filtering. The Reference SQL returns 20 for two rows (France and Italy), while the Generated SQL returns 10 for a single row (UK and Germany). The logic, filtering, and results differ.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is technically incorrect and fails to fulfill the business intent. It uses a flawed PARTITION BY condition (num_hotels <= 2) which creates an invalid partition, and the WHERE clause restricts results to France and Italy (which are not the top 2 countries in the data). The Generated SQL correctly identifies the top 2 hotel counts using subqueries with ORDER BY and LIMIT, calculates their absolute difference, and avoids filtering constraints. While both queries aim to find the difference between top 2 values, the Generated SQL accurately addresses the question by focusing on numerical values rather than country-specific filters.", "overall_assessment": "differently_correct"}}
{"example_id": 1970, "sql_complexity": "multiple_joins", "prompt": "List all players who have played a specific VR game, 'CyberSphere', and their ages.", "context": "CREATE TABLE Players (PlayerID INT, Age INT, Gender VARCHAR(10), Country VARCHAR(50)); CREATE TABLE VRPlayers (PlayerID INT, VRGameID INT); CREATE TABLE VRGames (VRGameID INT, Title VARCHAR(50)); INSERT INTO Players (PlayerID, Age, Gender, Country) VALUES (1, 25, 'Male', 'USA'); INSERT INTO Players (PlayerID, Age, Gender, Country) VALUES (2, 28, 'Female', 'Canada'); INSERT INTO VRPlayers (PlayerID, VRGameID) VALUES (1, 1); INSERT INTO VRPlayers (PlayerID, VRGameID) VALUES (2, 1); INSERT INTO VRGames (VRGameID, Title) VALUES (1, 'CyberSphere');", "reference_sql": "SELECT Players.Age, Players.PlayerID FROM Players INNER JOIN VRPlayers ON Players.PlayerID = VRPlayers.PlayerID INNER JOIN VRGames ON VRPlayers.VRGameID = VRGames.VRGameID WHERE VRGames.Title = 'CyberSphere';", "generated_sql": "SELECT p.PlayerID, p.Age\nFROM Players p\nJOIN VRPlayers vp ON p.PlayerID = vp.PlayerID\nJOIN VRGames vg ON vp.VRGameID = vg.VRGameID\nWHERE vg.Title = 'CyberSphere';", "raw_model_output": "SELECT p.PlayerID, p.Age\nFROM Players p\nJOIN VRPlayers vp ON p.PlayerID = vp.PlayerID\nJOIN VRGames vg ON vp.VRGameID = vg.VRGameID\nWHERE vg.Title = 'CyberSphere';", "latency_sec": 1.007004976272583, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 245, "prompt_eval_sec": null, "tokens_completion": 52, "completion_eval_sec": null, "tokens_total": 297, "tokens_per_sec": 294.9339943674777, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (PlayerID and Age) from the Players table, join with VRPlayers and VRGames on identical conditions, and apply the same filter on VRGames.Title. The differences are purely syntactic (column order and table aliases) and do not affect the result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent as they produce identical results by joining the same tables with equivalent conditions and filtering on 'CyberSphere'. The reference query uses explicit table names while the generated query uses aliases, but this does not affect semantic output. Both fulfill the business intent by retrieving PlayerID and Age for players who played the specified VR game. The generated query is slightly more concise with aliases, but neither demonstrates significant efficiency differences. The column order differs (Age/PlayerID vs PlayerID/Age) but this is irrelevant for result equivalence.", "overall_assessment": "correct"}}
{"example_id": 2414, "sql_complexity": "window functions", "prompt": "List the policy areas with the lowest citizen satisfaction scores.", "context": "CREATE TABLE Policy (Area VARCHAR(20), Score INT); INSERT INTO Policy (Area, Score) VALUES ('Transportation', 70), ('Education', 85), ('Healthcare', 75), ('PublicSafety', 80);", "reference_sql": "SELECT Area, Score FROM (SELECT Area, Score, ROW_NUMBER() OVER (ORDER BY Score) AS RN FROM Policy) X WHERE RN IN (1, 2);", "generated_sql": "SELECT Area\nFROM Policy\nWHERE Score = (SELECT MIN(Score) FROM Policy);", "raw_model_output": "```sql\nSELECT Area\nFROM Policy\nWHERE Score = (SELECT MIN(Score) FROM Policy);\n```", "latency_sec": 0.5218019485473633, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 124, "prompt_eval_sec": null, "tokens_completion": 23, "completion_eval_sec": null, "tokens_total": 147, "tokens_per_sec": 281.71608099439095, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns the top 2 lowest-scoring policies using ROW_NUMBER(), while the Generated SQL returns all policies with the minimum score. In the sample data, the minimum score (70) is unique, so the Generated SQL returns 1 row, whereas the Reference SQL returns 2 rows (70 and 75). They produce different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL uses ROW_NUMBER() to select the top 2 lowest scores, which would return the two policies with the lowest scores (e.g., Transportation and Healthcare in the sample data). However, the Generated SQL correctly identifies all policies with the absolute minimum score (e.g., only Transportation in the sample data). The original question asks for 'lowest citizen satisfaction scores' (plural), which implies all policies sharing the minimum score. The Generated SQL fulfills this intent by capturing all policies with the minimum score, while the Reference SQL only returns the first two when ordered by score, which may not represent the true minimum. The Generated SQL is more accurate for the business intent and technically correct.", "overall_assessment": "correct"}}
{"example_id": 1898, "sql_complexity": "single join", "prompt": "What are the total sales for each drug in Q2 2020?", "context": "CREATE TABLE drugs (drug_id INT, drug_name TEXT); INSERT INTO drugs (drug_id, drug_name) VALUES (1001, 'Ibuprofen'), (1002, 'Paracetamol'), (1003, 'Aspirin'); CREATE TABLE sales (sale_id INT, drug_id INT, sale_date DATE, revenue FLOAT); INSERT INTO sales (sale_id, drug_id, sale_date, revenue) VALUES (1, 1001, '2020-04-05', 1800.0), (2, 1002, '2020-04-10', 2300.0), (3, 1003, '2020-04-15', 1400.0), (4, 1001, '2020-05-20', 1900.0), (5, 1002, '2020-06-25', 2400.0);", "reference_sql": "SELECT drug_name, SUM(revenue) as total_sales FROM sales JOIN drugs ON sales.drug_id = drugs.drug_id WHERE sale_date BETWEEN '2020-04-01' AND '2020-06-30' GROUP BY drug_name;", "generated_sql": "SELECT d.drug_name, SUM(s.revenue) AS total_sales\nFROM drugs d\nJOIN sales s ON d.drug_id = s.drug_id\nWHERE s.sale_date >= '2020-04-01' AND s.sale_date < '2020-07-01'\nGROUP BY d.drug_name;", "raw_model_output": "SELECT d.drug_name, SUM(s.revenue) AS total_sales\nFROM drugs d\nJOIN sales s ON d.drug_id = s.drug_id\nWHERE s.sale_date >= '2020-04-01' AND s.sale_date < '2020-07-01'\nGROUP BY d.drug_name;", "latency_sec": 0.7592267990112305, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 271, "prompt_eval_sec": null, "tokens_completion": 67, "completion_eval_sec": null, "tokens_total": 338, "tokens_per_sec": 445.18976469243455, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate total sales per drug within the same date range. The Reference SQL uses BETWEEN '2020-04-01' AND '2020-06-30' (inclusive), while the Generated SQL uses >= '2020-04-01' and < '2020-07-01' (equivalent to <= '2020-06-30'). The date ranges are functionally identical. Both group by drug_name (or d.drug_name) and join on drug_id. The schema ensures drug_name is unique per drug_id, making the grouping equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate total sales per drug for Q2 2020. The Reference SQL uses BETWEEN '2020-04-01' AND '2020-06-30' while the Generated SQL uses >= '2020-04-01' AND < '2020-07-01'. These date ranges are semantically equivalent for capturing all dates in April-June 2020. Both queries join drugs and sales tables correctly, group by drug_name (which is unique per drug_id), and aggregate revenue. The Generated SQL is more elegant with explicit date boundaries (avoiding potential confusion with BETWEEN) and uses table aliases for clarity. Both fulfill the business intent of calculating Q2 2020 sales per drug.", "overall_assessment": "correct"}}
{"example_id": 2403, "sql_complexity": "multiple_joins", "prompt": "Who is the most frequent customer ordering vegetarian items?", "context": "CREATE TABLE customers (customer_id INT, customer_name VARCHAR(50)); INSERT INTO customers VALUES (1, 'John Doe'), (2, 'Jane Smith'), (3, 'Alice Johnson'); CREATE TABLE orders (order_id INT, customer_id INT, menu_id INT, order_date DATE); INSERT INTO orders VALUES (1, 1, 1, '2022-01-01'), (2, 2, 3, '2022-01-02'), (3, 3, 2, '2022-01-03'); CREATE TABLE menu (menu_id INT, item_name VARCHAR(50), is_vegetarian BOOLEAN, price DECIMAL(5,2)); INSERT INTO menu VALUES (1, 'Veggie Burger', true, 8.99), (2, 'Cheeseburger', false, 7.99), (3, 'Tofu Stir Fry', true, 11.99);", "reference_sql": "SELECT customers.customer_name, COUNT(orders.order_id) as order_count FROM customers INNER JOIN orders ON customers.customer_id = orders.customer_id INNER JOIN menu ON orders.menu_id = menu.menu_id WHERE menu.is_vegetarian = true GROUP BY customers.customer_name ORDER BY order_count DESC LIMIT 1;", "generated_sql": "SELECT c.customer_name\nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nJOIN menu m ON o.menu_id = m.menu_id\nWHERE m.is_vegetarian = TRUE\nGROUP BY c.customer_id, c.customer_name\nORDER BY COUNT(*) DESC\nLIMIT 1;", "raw_model_output": "```sql\nSELECT c.customer_name\nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nJOIN menu m ON o.menu_id = m.menu_id\nWHERE m.is_vegetarian = TRUE\nGROUP BY c.customer_id, c.customer_name\nORDER BY COUNT(*) DESC\nLIMIT 1;\n```", "latency_sec": 1.0825788974761963, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 270, "prompt_eval_sec": null, "tokens_completion": 67, "completion_eval_sec": null, "tokens_total": 337, "tokens_per_sec": 311.2937087409003, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their GROUP BY clauses. The Reference SQL groups by customer_name, which may not be functionally dependent on customer_id (as names aren't guaranteed unique), potentially causing incorrect aggregation. The Generated SQL groups by both customer_id and customer_name, ensuring accurate grouping. While both count vegetarian orders, the Reference's grouping could produce different results in cases of duplicate names, making them semantically non-equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify the most frequent customer ordering vegetarian items by joining customers, orders, and menu tables with a vegetarian filter. The key difference lies in grouping: the reference query groups by customer_name (which works in this specific dataset with unique names) while the generated query groups by customer_id and customer_name (more robust for general cases). The generated query also uses COUNT(*) which is slightly more efficient than COUNT(orders.order_id). Both produce the same result here, but the generated version is more technically sound and safer for real-world scenarios with potential name duplicates.", "overall_assessment": "correct"}}
{"example_id": 124, "sql_complexity": "set operations", "prompt": "Find the intersection of AI and accessibility research projects in the EU and those in Africa.", "context": "CREATE SCHEMA if not exists accessibility; CREATE TABLE if not exists accessibility.research (id INT PRIMARY KEY, project_name VARCHAR(255), region VARCHAR(255)); INSERT INTO accessibility.research (id, project_name, region) VALUES (1, 'AI for Accessibility EU', 'EU'), (2, 'Accessibility Africa', 'Africa'), (3, 'AI for Accessibility Africa', 'Africa'), (4, 'Accessibility EU', 'EU');", "reference_sql": "SELECT project_name FROM accessibility.research WHERE region = 'EU' INTERSECT SELECT project_name FROM accessibility.research WHERE region = 'Africa';", "generated_sql": "SELECT project_name, region\nFROM accessibility.research\nWHERE project_name LIKE '%AI%' AND project_name LIKE '%Accessibility%'\n  AND region IN ('EU', 'Africa');", "raw_model_output": "```sql\nSELECT project_name, region\nFROM accessibility.research\nWHERE project_name LIKE '%AI%' AND project_name LIKE '%Accessibility%'\n  AND region IN ('EU', 'Africa');\n```", "latency_sec": 0.8874030113220215, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 175, "prompt_eval_sec": null, "tokens_completion": 40, "completion_eval_sec": null, "tokens_total": 215, "tokens_per_sec": 242.27999821603112, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL finds project_names present in both 'EU' and 'Africa' regions using INTERSECT, while the Generated SQL selects projects containing 'AI' and 'Accessibility' in their names with regions 'EU' or 'Africa'. The Reference SQL would return no results (no overlapping project names between regions), whereas the Generated SQL returns two rows. The logic and output differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly uses INTERSECT to find projects present in both EU and Africa regions, which aligns with the 'intersection' requirement. The generated query instead filters projects containing 'AI' and 'Accessibility' in their names, regardless of region, and returns projects from either region. This approach fails to address the intersection of regions and instead focuses on keyword matching. The reference query is technically correct and directly answers the business question, while the generated query misinterprets the requirement by prioritizing text patterns over spatial intersection.", "overall_assessment": "incorrect"}}
{"example_id": 1231, "sql_complexity": "basic SQL", "prompt": "What is the average ticket price for performances at the 'Downtown Theater'?", "context": "CREATE TABLE DowntownTheater (show_name TEXT, date DATE, ticket_price FLOAT); INSERT INTO DowntownTheater (show_name, date, ticket_price) VALUES ('Play 1', '2022-01-01', 30.0), ('Play 2', '2022-01-02', 40.0), ('Concert 1', '2022-01-03', 50.0);", "reference_sql": "SELECT AVG(ticket_price) FROM DowntownTheater WHERE show_name = 'Downtown Theater'", "generated_sql": "SELECT AVG(ticket_price) AS average_ticket_price FROM DowntownTheater;", "raw_model_output": "SELECT AVG(ticket_price) AS average_ticket_price FROM DowntownTheater;", "latency_sec": 0.4838368892669678, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 169, "prompt_eval_sec": null, "tokens_completion": 15, "completion_eval_sec": null, "tokens_total": 184, "tokens_per_sec": 380.2934502963744, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters for show_name = 'Downtown Theater' (which has no matching rows in the sample data, returning NULL), while the Generated SQL calculates the average of all rows. The WHERE clause in the Reference SQL drastically changes the result set compared to the Generated SQL.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query is incorrect because it filters for show_name = 'Downtown Theater', but the table contains shows like 'Play 1', 'Play 2', and 'Concert 1' - none of which match the theater name. This would return NULL/0 since no rows satisfy the condition. The generated query correctly calculates the average ticket price for all performances in the DowntownTheater table, which contains all relevant data. The original question's phrasing may be slightly ambiguous, but the table structure implies all entries are for the Downtown Theater. The generated query better fulfills the business intent by averaging all ticket prices without incorrect filtering.", "overall_assessment": "incorrect"}}
{"example_id": 1485, "sql_complexity": "set operations", "prompt": "How many public schools and public libraries exist in total, in the 'CityData' schema's 'CityEducation' and 'CityLibrary' tables?", "context": "CREATE SCHEMA CityData; CREATE TABLE CityEducation (Name varchar(255), Type varchar(255)); INSERT INTO CityEducation (Name, Type) VALUES ('SchoolA', 'Public'), ('SchoolB', 'Public'), ('SchoolC', 'Private'); CREATE TABLE CityLibrary (Name varchar(255), Type varchar(255)); INSERT INTO CityLibrary (Name, Type) VALUES ('LibraryA', 'Public'), ('LibraryB', 'Public'), ('LibraryC', 'Private');", "reference_sql": "SELECT COUNT(*) FROM CityData.CityEducation WHERE Type = 'Public' UNION ALL SELECT COUNT(*) FROM CityData.CityLibrary WHERE Type = 'Public';", "generated_sql": "SELECT \n    (SELECT COUNT(*) FROM CityData.CityEducation WHERE Type = 'Public') +\n    (SELECT COUNT(*) FROM CityData.CityLibrary WHERE Type = 'Public') AS TotalPublicSchoolsAndLibraries;", "raw_model_output": "SELECT \n    (SELECT COUNT(*) FROM CityData.CityEducation WHERE Type = 'Public') +\n    (SELECT COUNT(*) FROM CityData.CityLibrary WHERE Type = 'Public') AS TotalPublicSchoolsAndLibraries;", "latency_sec": 0.7354340553283691, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 195, "prompt_eval_sec": null, "tokens_completion": 43, "completion_eval_sec": null, "tokens_total": 238, "tokens_per_sec": 323.6184104824106, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query returns two separate counts (public schools and public libraries) as two rows via UNION ALL, while the generated query returns a single row with the summed total of both counts. The output structure and values differ.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL uses UNION ALL to return two separate counts (schools and libraries) as two rows, while the Generated SQL calculates a single total by summing the counts. The original question explicitly asks for a 'total,' making the Generated SQL technically more correct. Both queries correctly filter for 'Public' entities, but the Generated SQL's output format aligns with the business requirement for a single aggregated number. The Generated SQL is also more efficient as it avoids the overhead of combining result sets.", "overall_assessment": "correct"}}
{"example_id": 5806, "sql_complexity": "single join", "prompt": "List the top 3 countries with the most veteran employment in the IT industry", "context": "CREATE TABLE veteran_employment (employee_id INT, industry VARCHAR(255), salary DECIMAL(10,2), state VARCHAR(2), country VARCHAR(255)); CREATE TABLE countries (country_id INT, country VARCHAR(255));", "reference_sql": "SELECT country, COUNT(*) as num_veterans FROM veteran_employment JOIN countries ON veteran_employment.country = countries.country WHERE industry = 'IT' GROUP BY country ORDER BY num_veterans DESC LIMIT 3;", "generated_sql": "SELECT country, COUNT(*) AS veteran_count\nFROM veteran_employment\nWHERE industry = 'IT'\nGROUP BY country\nORDER BY veteran_count DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT country, COUNT(*) AS veteran_count\nFROM veteran_employment\nWHERE industry = 'IT'\nGROUP BY country\nORDER BY veteran_count DESC\nLIMIT 3;\n```", "latency_sec": 0.7903590202331543, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 129, "prompt_eval_sec": null, "tokens_completion": 39, "completion_eval_sec": null, "tokens_total": 168, "tokens_per_sec": 212.56162794275485, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a JOIN with the countries table, which is not present in the Generated SQL. This join could filter or alter results if there are country names in veteran_employment that don't exist in the countries table. Additionally, the Generated SQL uses 'veteran_count' alias in ORDER BY, while the Reference SQL uses 'num_veterans'\u2014though this is a syntactic difference, the core semantic difference lies in the missing JOIN, which may lead to different result sets.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify the top 3 countries with IT veteran employment by counting entries in the veteran_employment table. The Reference SQL includes an unnecessary JOIN with the countries table, which doesn't affect the count since the country column exists directly in veteran_employment. The Generated SQL is more efficient and elegant by avoiding the redundant join while maintaining identical results. Both fulfill the business intent, but the Generated version is technically superior.", "overall_assessment": "correct"}}
{"example_id": 4126, "sql_complexity": "window functions", "prompt": "What is the average crime rate per capita in each neighborhood?", "context": "CREATE TABLE neighborhoods (name VARCHAR(255), population INT, crime_count INT); INSERT INTO neighborhoods (name, population, crime_count) VALUES ('Central Park', 1000, 25), ('Harlem', 2500, 75), ('Brooklyn', 5000, 120);", "reference_sql": "SELECT name, AVG(crime_count/population) OVER (PARTITION BY name) FROM neighborhoods;", "generated_sql": "SELECT \n    name, \n    CAST(crime_count AS FLOAT) / population AS average_crime_rate_per_capita\nFROM \n    neighborhoods;", "raw_model_output": "SELECT \n    name, \n    CAST(crime_count AS FLOAT) / population AS average_crime_rate_per_capita\nFROM \n    neighborhoods;", "latency_sec": 0.8783488273620605, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 140, "prompt_eval_sec": null, "tokens_completion": 31, "completion_eval_sec": null, "tokens_total": 171, "tokens_per_sec": 194.68347275371588, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in how they handle division. The reference query uses integer division (crime_count/population) which may truncate results, while the generated query explicitly casts crime_count to FLOAT before division, ensuring floating-point results. This leads to different numerical outputs for cases where crime_count is not divisible by population.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query uses an unnecessary analytic function (AVG with PARTITION BY name) that produces the same value as the raw ratio but complicates the logic. Since each neighborhood is a single row, the AVG() over a partition of one row equals the original value. However, the reference query does not handle integer division (e.g., 25/1000 would return 0 in some SQL dialects), while the generated query explicitly casts crime_count to FLOAT, ensuring accurate decimal results. Both queries address the business intent of calculating crime rate per capita, but the generated query is more efficient, elegant, and technically correct.", "overall_assessment": "differently_correct"}}
{"example_id": 4559, "sql_complexity": "basic SQL", "prompt": "List the top 3 energy efficient appliances in the US by energy star rating?", "context": "CREATE TABLE appliances (id INT, name VARCHAR(255), country VARCHAR(255), energy_star_rating INT); INSERT INTO appliances (id, name, country, energy_star_rating) VALUES (1, 'Fridge A', 'USA', 5), (2, 'TV B', 'USA', 4), (3, 'Laptop C', 'USA', 5), (4, 'Microwave D', 'USA', 3);", "reference_sql": "SELECT name, energy_star_rating FROM appliances WHERE country = 'USA' ORDER BY energy_star_rating DESC LIMIT 3;", "generated_sql": "SELECT name, energy_star_rating\nFROM appliances\nWHERE country = 'USA'\nORDER BY energy_star_rating DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT name, energy_star_rating\nFROM appliances\nWHERE country = 'USA'\nORDER BY energy_star_rating DESC\nLIMIT 3;\n```", "latency_sec": 0.8250422477722168, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 174, "prompt_eval_sec": null, "tokens_completion": 32, "completion_eval_sec": null, "tokens_total": 206, "tokens_per_sec": 249.6841835145318, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. The only differences are formatting (line breaks and whitespace) which do not affect SQL execution. Both select the same columns, apply the same WHERE condition, order by the same column in descending order, and limit to 3 results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure, logic, and output. They correctly filter US appliances, order by energy_star_rating descending, and limit to 3 results. The reference and generated queries differ only in formatting (whitespace), not in functionality. Both accurately address the business intent of identifying top energy-efficient appliances by their Energy Star ratings.", "overall_assessment": "correct"}}
{"example_id": 456, "sql_complexity": "window functions", "prompt": "List the intelligence operations and their corresponding threat levels, and rank them based on their threat level and budget.", "context": "CREATE TABLE intel_ops_threat (id INT, operation VARCHAR, threat VARCHAR, budget INT); INSERT INTO intel_ops_threat (id, operation, threat, budget) VALUES (1, 'Operation Red Folder', 'High', 5000000), (2, 'Operation Black Vault', 'Medium', 7000000), (3, 'Operation Blue Sail', 'Low', 6000000);", "reference_sql": "SELECT operation, threat, budget, ROW_NUMBER() OVER (PARTITION BY threat ORDER BY budget DESC) as rank FROM intel_ops_threat;", "generated_sql": "SELECT \n    operation, \n    threat,\n    RANK() OVER (\n        ORDER BY \n            CASE threat\n                WHEN 'High' THEN 1\n                WHEN 'Medium' THEN 2\n                WHEN 'Low' THEN 3\n                ELSE 4\n            END,\n            budget DESC\n    ) AS rank\nFROM intel_ops_threat;", "raw_model_output": "```sql\nSELECT \n    operation, \n    threat,\n    RANK() OVER (\n        ORDER BY \n            CASE threat\n                WHEN 'High' THEN 1\n                WHEN 'Medium' THEN 2\n                WHEN 'Low' THEN 3\n                ELSE 4\n            END,\n            budget DESC\n    ) AS rank\nFROM intel_ops_threat;\n```", "latency_sec": 0.890812873840332, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 171, "prompt_eval_sec": null, "tokens_completion": 78, "completion_eval_sec": null, "tokens_total": 249, "tokens_per_sec": 279.519983727391, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL uses ROW_NUMBER() with PARTITION BY threat, ranking within each threat group. The Generated SQL uses RANK() over the entire dataset ordered by a custom threat priority and budget, resulting in global rankings rather than per-threat rankings. Additionally, the Generated SQL's ORDER BY clause changes the overall row ordering compared to the Reference SQL.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries are not technically equivalent. The Reference query uses ROW_NUMBER() with PARTITION BY threat, creating separate rankings within each threat level, while the Generated query uses RANK() with a custom ordering of threat levels (High/Medium/Low) and budget. The original question requires a global ranking based on both threat level and budget, not per-group rankings. The Generated query correctly maps threat levels to numerical values for ordered ranking, while the Reference query's approach would produce ranks like 1,2,3 within each threat category rather than a single unified ranking. The Generated query better fulfills the business intent of ranking operations by threat level priority and budget magnitude.", "overall_assessment": "differently_correct"}}
{"example_id": 459, "sql_complexity": "set operations", "prompt": "What is the total installed capacity of hydroelectric power plants in Brazil and Canada?", "context": "CREATE TABLE hydroelectric_power (country TEXT, capacity INTEGER); INSERT INTO hydroelectric_power (country, capacity) VALUES ('Brazil', 104000), ('Canada', 78000), ('China', 350000), ('United States', 100000), ('Russia', 45000);", "reference_sql": "(SELECT capacity FROM hydroelectric_power WHERE country = 'Brazil') UNION (SELECT capacity FROM hydroelectric_power WHERE country = 'Canada');", "generated_sql": "SELECT SUM(capacity) AS total_capacity\nFROM hydroelectric_power\nWHERE country IN ('Brazil', 'Canada');", "raw_model_output": "```sql\nSELECT SUM(capacity) AS total_capacity\nFROM hydroelectric_power\nWHERE country IN ('Brazil', 'Canada');\n```", "latency_sec": 0.9026758670806885, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 142, "prompt_eval_sec": null, "tokens_completion": 28, "completion_eval_sec": null, "tokens_total": 170, "tokens_per_sec": 188.32895195236676, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate capacity values (Brazil and Canada) as individual rows, while the Generated SQL returns a single summed value for both countries. The UNION operator combines results into separate rows, whereas SUM aggregates them into one value.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query retrieves individual capacities for Brazil and Canada using UNION, which returns two separate rows instead of a single total. The generated query correctly uses SUM(capacity) with a WHERE clause to calculate the combined total. While both queries access the correct data, only the generated query addresses the business requirement for a total value. The generated query is also more efficient and elegant as it performs aggregation in a single operation.", "overall_assessment": "correct"}}
{"example_id": 2356, "sql_complexity": "window functions", "prompt": "Find the total billing amount for attorneys in the 'Criminal Law' practice area, for the year 2020, partitioned by attorney's last name and ordered by the total billing amount in descending order.", "context": "CREATE TABLE Attorneys (AttorneyID INT, FirstName VARCHAR(50), LastName VARCHAR(50), PracticeArea VARCHAR(50), TotalBilling FLOAT, BillingYear INT); INSERT INTO Attorneys (AttorneyID, FirstName, LastName, PracticeArea, TotalBilling, BillingYear) VALUES (1, 'Clara', 'Rivera', 'Personal Injury', 8000.00, 2020), (2, 'Jamal', 'Lee', 'Personal Injury', 6000.00, 2019), (3, 'Sophia', 'Gomez', 'Criminal Law', 9000.00, 2020);", "reference_sql": "SELECT LastName, SUM(TotalBilling) OVER (PARTITION BY PracticeArea, LastName, BillingYear) AS TotalBilling FROM Attorneys WHERE PracticeArea = 'Criminal Law' AND BillingYear = 2020 ORDER BY TotalBilling DESC;", "generated_sql": "SELECT LastName, SUM(TotalBilling) AS TotalBillingAmount\nFROM Attorneys\nWHERE PracticeArea = 'Criminal Law' AND BillingYear = 2020\nGROUP BY LastName\nORDER BY TotalBillingAmount DESC;", "raw_model_output": "```sql\nSELECT LastName, SUM(TotalBilling) AS TotalBillingAmount\nFROM Attorneys\nWHERE PracticeArea = 'Criminal Law' AND BillingYear = 2020\nGROUP BY LastName\nORDER BY TotalBillingAmount DESC;\n```", "latency_sec": 0.7109167575836182, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 241, "prompt_eval_sec": null, "tokens_completion": 51, "completion_eval_sec": null, "tokens_total": 292, "tokens_per_sec": 410.7372584555441, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL uses a window function to calculate the sum per (PracticeArea, LastName, BillingYear) without grouping, potentially returning multiple rows per LastName if there are multiple entries. The Generated SQL groups by LastName, aggregating all rows with the same LastName into a single row. This difference in handling duplicates means they produce different result structures when multiple entries exist for the same LastName in the filtered dataset.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL uses a window function (SUM(...) OVER) which calculates running totals per partition, but the WHERE clause already restricts to a single PracticeArea ('Criminal Law') and BillingYear (2020). This makes the PARTITION BY PracticeArea and BillingYear redundant. The window function would return the same value as TotalBilling for each row (since all rows share the same PracticeArea and BillingYear), but it would also include multiple rows per attorney if they have multiple entries. The Generated SQL correctly uses GROUP BY LastName to aggregate total billing amounts per attorney, which aligns with the business requirement to 'partition by attorney's last name'. The Generated SQL is more efficient and semantically accurate for this specific question.", "overall_assessment": "differently_correct"}}
