{"example_id": 2656, "sql_complexity": "multiple_joins", "prompt": "Find the drugs and their respective total sales for rare diseases indication with sales greater than the average sales for infectious diseases.", "context": "CREATE TABLE sales (id INT, drug_id INT, quarter INT, year INT, revenue FLOAT); INSERT INTO sales (id, drug_id, quarter, year, revenue) VALUES (1, 1, 1, 2022, 1500000); CREATE TABLE drugs (id INT, name VARCHAR(50), company VARCHAR(50), indication VARCHAR(50)); INSERT INTO drugs (id, name, company, indication) VALUES (1, 'DrugA', 'ABC Corp', 'Rare_Diseases');", "reference_sql": "SELECT s.drug_id, d.name, SUM(s.revenue) as total_sales FROM sales s JOIN drugs d ON s.drug_id = d.id WHERE d.indication = 'Rare_Diseases' GROUP BY s.drug_id HAVING total_sales > (SELECT AVG(s2.revenue) FROM sales s2 JOIN drugs d2 ON s2.drug_id = d2.id WHERE d2.indication = 'Infectious_Diseases')", "generated_sql": "SELECT d.name, SUM(s.revenue) AS total_sales\nFROM drugs d\nJOIN sales s ON d.id = s.drug_id\nWHERE d.indication = 'Rare_Diseases'\n  AND SUM(s.revenue) > (\n    SELECT AVG(s2.revenue)\n    FROM drugs d2\n    JOIN sales s2 ON d2.id = s2.drug_id\n    WHERE d2.indication = 'Infectious Diseases'\n  )\nGROUP BY d.name;", "raw_model_output": "\n\nTo solve the question, we need to:\n\n1. Identify drugs with the `indication` of 'Rare_Diseases'.\n2. Calculate their total sales.\n3. Calculate the average sales for drugs with the `indication` of 'Infectious Diseases'.\n4. Filter the drugs with 'Rare_Diseases' indication whose total sales are greater than the average sales of 'Infectious Diseases' drugs.\n\nHere is the SQL query:\n\n```sql\nSELECT d.name, SUM(s.revenue) AS total_sales\nFROM drugs d\nJOIN sales s ON d.id = s.drug_id\nWHERE d.indication = 'Rare_Diseases'\n  AND SUM(s.revenue) > (\n    SELECT AVG(s2.revenue)\n    FROM drugs d2\n    JOIN sales s2 ON d2.id = s2.drug_id\n    WHERE d2.indication = 'Infectious Diseases'\n  )\nGROUP BY d.name;\n```", "latency_sec": 1.5549678802490234, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 786, "prompt_eval_sec": null, "tokens_completion": 199, "completion_eval_sec": null, "tokens_total": 985, "tokens_per_sec": 633.4535989529605, "retrieval_latency_sec": 0.8208909034729004, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in three key ways: 1) The generated query incorrectly uses SUM(s.revenue) in the WHERE clause (invalid syntax for aggregates) vs the reference's HAVING clause. 2) The subquery in the generated query uses 'Infectious Diseases' (space) instead of 'Infectious_Diseases' (underscore) matching the reference. 3) The generated query groups by d.name (which could combine drugs with same names) vs the reference's grouping by s.drug_id (unique identifier). These differences ensure they produce different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query is technically correct while the generated query contains a critical error. The generated query incorrectly places the SUM(s.revenue) aggregate function in the WHERE clause, which is invalid SQL syntax. The WHERE clause cannot contain aggregate functions; this requires a HAVING clause instead. The reference query properly uses HAVING after grouping. Additionally, the generated query groups by d.name instead of drug_id, which could produce incorrect results if multiple drugs share the same name. Both queries attempt to compare rare disease sales against infectious disease averages, but only the reference query executes correctly.", "overall_assessment": "incorrect"}}
{"example_id": 3008, "sql_complexity": "multiple_joins", "prompt": "Who are the users who used electric vehicles and their trip details?", "context": "CREATE TABLE users (id INT, name VARCHAR(50), age INT, gender VARCHAR(10), city VARCHAR(50));CREATE TABLE vehicles (id INT, vehicle_type VARCHAR(20), is_electric BOOLEAN);CREATE TABLE trips (id INT, user_id INT, vehicle_id INT, trip_distance FLOAT, trip_duration INT, departure_time TIMESTAMP, arrival_time TIMESTAMP);INSERT INTO users (id, name, age, gender, city) VALUES (3, 'Alex', 30, 'Female', 'New York');INSERT INTO vehicles (id, vehicle_type, is_electric) VALUES (1, 'Tesla', true), (2, 'Bike', false);INSERT INTO trips (id, user_id, vehicle_id, trip_distance, trip_duration, departure_time, arrival_time) VALUES (3, 3, 1, 15.3, 25, '2022-01-03 12:00:00', '2022-01-03 12:25:00');", "reference_sql": "SELECT u.name, v.vehicle_type, t.trip_distance, t.trip_duration FROM users u JOIN trips t ON u.id = t.user_id JOIN vehicles v ON t.vehicle_id = v.id WHERE v.is_electric = true;", "generated_sql": "SELECT u.name, t.trip_distance, t.trip_duration, t.departure_time, t.arrival_time \nFROM users u \nJOIN trips t ON u.id = t.user_id \nJOIN vehicles v ON t.vehicle_id = v.id \nWHERE v.is_electric = TRUE;", "raw_model_output": "\n\nSELECT u.name, t.trip_distance, t.trip_duration, t.departure_time, t.arrival_time \nFROM users u \nJOIN trips t ON u.id = t.user_id \nJOIN vehicles v ON t.vehicle_id = v.id \nWHERE v.is_electric = TRUE;", "latency_sec": 0.5849871635437012, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 807, "prompt_eval_sec": null, "tokens_completion": 61, "completion_eval_sec": null, "tokens_total": 868, "tokens_per_sec": 1483.7932421318105, "retrieval_latency_sec": 0.14033913612365723, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL selects columns (name, vehicle_type, trip_distance, trip_duration) while the Generated SQL includes additional columns (departure_time, arrival_time). The SELECT list differs, leading to different result sets.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because they select different columns: the reference query includes vehicle_type while the generated query includes departure_time/arrival_time. Both correctly join the required tables and filter electric vehicles, fulfilling the business intent of identifying users and their trip details. The generated query provides more comprehensive trip details (times) which better addresses the 'trip details' aspect of the question. Both are efficient, but the generated version offers richer data without violating correctness.", "overall_assessment": "differently_correct"}}
{"example_id": 2531, "sql_complexity": "basic SQL", "prompt": "Who is the top customer by sales in 2022?", "context": "CREATE TABLE customers (customer_id INT, total_sales_2022 FLOAT); INSERT INTO customers (customer_id, total_sales_2022) VALUES (1, 25000.0), (2, 30000.0), (3, 22000.0), (4, 35000.0);", "reference_sql": "SELECT customer_id, total_sales_2022 FROM customers ORDER BY total_sales_2022 DESC LIMIT 1;", "generated_sql": "SELECT customer_id FROM customers ORDER BY total_sales_2022 DESC LIMIT 1;", "raw_model_output": "\n\nSELECT customer_id FROM customers ORDER BY total_sales_2022 DESC LIMIT 1;", "latency_sec": 0.26017117500305176, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1437, "prompt_eval_sec": null, "tokens_completion": 24, "completion_eval_sec": null, "tokens_total": 1461, "tokens_per_sec": 5615.533696163162, "retrieval_latency_sec": 0.13079094886779785, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query returns both customer_id and total_sales_2022 columns, while the generated query only returns customer_id. The additional column in the reference query makes the result sets structurally different, even though they might return the same customer_id value.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because the reference query returns both customer_id and total_sales_2022 while the generated query only returns customer_id. However, both correctly identify the top customer by sales through the same ordering and limit logic. The generated query better fulfills the business intent of 'who is the top customer' by directly answering with the customer ID without extraneous data. While the reference query provides additional context (sales amount), the question specifically asks for identification of the customer, making the generated query more efficient and focused.", "overall_assessment": "differently_correct"}}
{"example_id": 3792, "sql_complexity": "single join", "prompt": "What is the maximum distance traveled by an electric vehicle in a single trip, grouped by vehicle model?", "context": "CREATE TABLE Trips (trip_id INT, vehicle_id INT, distance FLOAT); CREATE TABLE ElectricVehicleModels (vehicle_id INT, vehicle_model TEXT);", "reference_sql": "SELECT evm.vehicle_model, MAX(trips.distance) AS max_distance_traveled FROM Trips trips INNER JOIN ElectricVehicleModels evm ON trips.vehicle_id = evm.vehicle_id GROUP BY 1;", "generated_sql": "SELECT evm.vehicle_model, MAX(t.distance) AS max_distance\nFROM Trips t\nJOIN ElectricVehicleModels evm ON t.vehicle_id = evm.vehicle_id\nGROUP BY evm.vehicle_model;", "raw_model_output": "\n\nSELECT evm.vehicle_model, MAX(t.distance) AS max_distance\nFROM Trips t\nJOIN ElectricVehicleModels evm ON t.vehicle_id = evm.vehicle_id\nGROUP BY evm.vehicle_model;", "latency_sec": 0.39337992668151855, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 928, "prompt_eval_sec": null, "tokens_completion": 47, "completion_eval_sec": null, "tokens_total": 975, "tokens_per_sec": 2478.5199596352627, "retrieval_latency_sec": 0.11494588851928711, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between Trips and ElectricVehicleModels on vehicle_id, group by vehicle_model, and calculate the maximum distance per model. The differences are purely syntactic (table aliases 'trips' vs 't' and 'GROUP BY 1' vs 'GROUP BY evm.vehicle_model') which do not affect the semantic result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically correct and produce identical results. The Reference SQL uses 'GROUP BY 1' (implicit column reference), while the Generated SQL explicitly groups by 'evm.vehicle_model'. The Generated version is more readable and avoids potential ambiguity with implicit column references. Both correctly join the Trips and ElectricVehicleModels tables, calculate MAX(distance) per vehicle model, and address the business requirement. The Generated SQL's explicit grouping clause makes it slightly more elegant and maintainable.", "overall_assessment": "correct"}}
{"example_id": 2311, "sql_complexity": "subqueries", "prompt": "Determine the percentage of sales from each ingredient category", "context": "CREATE TABLE Sales_Details (sale_id INT, ingredient_id INT, quantity INT); INSERT INTO Sales_Details (sale_id, ingredient_id, quantity) VALUES (1, 1, 2), (1, 2, 8), (2, 1, 3), (2, 2, 7); CREATE TABLE Ingredient_Categories (ingredient_id INT, ingredient_category VARCHAR(255)); INSERT INTO Ingredient_Categories (ingredient_id, ingredient_category) VALUES (1, 'Legumes'), (2, 'Poultry');", "reference_sql": "SELECT ingredient_category, SUM(quantity) AS total_quantity, SUM(quantity) * 100.0 / (SELECT SUM(quantity) FROM Sales_Details) AS percentage_of_sales FROM Sales_Details, Ingredient_Categories WHERE Sales_Details.ingredient_id = Ingredient_Categories.ingredient_id GROUP BY ingredient_category;", "generated_sql": "SELECT ic.ingredient_category, 100.0 * SUM(sd.quantity) / (SELECT SUM(quantity) FROM Sales_Details) AS percentage \nFROM Sales_Details sd \nJOIN Ingredient_Categories ic ON sd.ingredient_id = ic.ingredient_id \nGROUP BY ic.ingredient_category;", "raw_model_output": "\n\n```sql\nSELECT ic.ingredient_category, 100.0 * SUM(sd.quantity) / (SELECT SUM(quantity) FROM Sales_Details) AS percentage \nFROM Sales_Details sd \nJOIN Ingredient_Categories ic ON sd.ingredient_id = ic.ingredient_id \nGROUP BY ic.ingredient_category;\n```", "latency_sec": 0.5149431228637695, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 793, "prompt_eval_sec": null, "tokens_completion": 67, "completion_eval_sec": null, "tokens_total": 860, "tokens_per_sec": 1670.0873588082013, "retrieval_latency_sec": 0.10441803932189941, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the total quantity sold per ingredient category and its percentage of total sales. They use equivalent joins (implicit vs explicit), same grouping, and identical percentage calculation logic (100.0 * SUM(quantity) / total). The reference query includes an extra 'total_quantity' column but the core aggregation and grouping are equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the percentage of sales per ingredient category by summing quantities and dividing by total sales. The reference query uses an implicit join (comma syntax) which is functionally equivalent to the generated query's explicit JOIN. However, the generated query improves readability with table aliases and explicit join syntax. Both handle the calculation correctly, but the generated version is more modern and maintainable. The business intent of determining category sales percentages is fully addressed by both.", "overall_assessment": "correct"}}
{"example_id": 3329, "sql_complexity": "set operations", "prompt": "Which causes received funding from donors in both the United States and Canada?", "context": "CREATE TABLE donor_location (donor_id INT, country VARCHAR(50), cause VARCHAR(50), donation DECIMAL(10,2)); INSERT INTO donor_location (donor_id, country, cause, donation) VALUES (1, 'United States', 'Global Health', 1000.00), (2, 'Canada', 'Education', 2000.00), (3, 'United States', 'Environment', 1500.00), (4, 'Canada', 'Animal Welfare', 2500.00);", "reference_sql": "SELECT cause FROM donor_location WHERE country = 'United States' INTERSECT SELECT cause FROM donor_location WHERE country = 'Canada';", "generated_sql": "SELECT cause \nFROM donor_location \nWHERE country IN ('United States', 'Canada') \nGROUP BY cause \nHAVING COUNT(DISTINCT country) = 2;", "raw_model_output": "\n\n```sql\nSELECT cause \nFROM donor_location \nWHERE country IN ('United States', 'Canada') \nGROUP BY cause \nHAVING COUNT(DISTINCT country) = 2;\n```", "latency_sec": 0.36763811111450195, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 953, "prompt_eval_sec": null, "tokens_completion": 43, "completion_eval_sec": null, "tokens_total": 996, "tokens_per_sec": 2709.1859355402707, "retrieval_latency_sec": 0.12644600868225098, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve causes that appear in both 'United States' and 'Canada'. The reference query uses INTERSECT to find common causes between the two countries, while the generated query uses GROUP BY with HAVING COUNT(DISTINCT country) = 2 to ensure a cause exists in both countries. Both approaches effectively identify causes present in both regions, producing identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify causes with donations from both the United States and Canada. The Reference SQL uses INTERSECT to find common causes between two filtered subsets, while the Generated SQL uses GROUP BY and HAVING to count distinct countries per cause. They produce identical results because both ensure a cause appears in both countries. The Generated SQL is more efficient as it requires a single table scan and avoids set operations, making it more scalable for large datasets. Both fulfill the business intent, but the Generated SQL is more elegant and performant.", "overall_assessment": "correct"}}
{"example_id": 2912, "sql_complexity": "single join", "prompt": "Which company has manufactured the most satellites?", "context": "CREATE TABLE manufacturers (id INT, name TEXT); CREATE TABLE satellites (id INT, manufacturer_id INT, name TEXT, launch_date DATE); INSERT INTO manufacturers (id, name) VALUES (1, 'SpaceX'), (2, 'Blue Origin'), (3, 'ISRO'), (4, 'CAST'); INSERT INTO satellites (id, manufacturer_id, name, launch_date) VALUES (1, 1, 'StarDragon', '2012-05-25'), (2, 1, 'Falcon', '2015-12-21'), (3, 2, 'New Glenn', '2022-01-11'), (4, 3, 'ChinaSat 1E', '2000-12-05'), (5, 3, 'ChinaSat 2A', '2003-08-13'), (6, 4, 'Shijian 9', '2017-11-19'), (7, 1, 'StarLink', '2020-05-24'), (8, 1, 'StarLink', '2020-06-13');", "reference_sql": "SELECT m.name, COUNT(s.id) FROM manufacturers m JOIN satellites s ON m.id = s.manufacturer_id GROUP BY m.name ORDER BY COUNT(s.id) DESC;", "generated_sql": "SELECT m.name, COUNT(s.id) AS satellite_count\nFROM manufacturers m\nJOIN satellites s ON m.id = s.manufacturer_id\nGROUP BY m.name\nORDER BY satellite_count DESC\nLIMIT 1;", "raw_model_output": "\n\n```sql\nSELECT m.name, COUNT(s.id) AS satellite_count\nFROM manufacturers m\nJOIN satellites s ON m.id = s.manufacturer_id\nGROUP BY m.name\nORDER BY satellite_count DESC\nLIMIT 1;\n```", "latency_sec": 0.4261586666107178, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1029, "prompt_eval_sec": null, "tokens_completion": 52, "completion_eval_sec": null, "tokens_total": 1081, "tokens_per_sec": 2536.613906264773, "retrieval_latency_sec": 0.12636804580688477, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns all manufacturers with their satellite counts ordered by count descending, while the Generated SQL adds a LIMIT 1 clause which restricts the result to only the top row. This makes them non-equivalent as the Generated version truncates the output.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query returns all manufacturers with their satellite counts ordered by quantity, while the generated query explicitly retrieves only the top result using LIMIT 1. Both correctly count satellites per manufacturer, but the generated query directly answers the singular 'which company' question by returning a single result. The reference might require additional processing to extract the top row. The generated query is more efficient and precisely aligns with the business intent of identifying the single top manufacturer.", "overall_assessment": "differently_correct"}}
{"example_id": 3170, "sql_complexity": "aggregation", "prompt": "Determine the total production quantity of silver for mining sites in Mexico, between the dates '2017-05-01' and '2017-09-30', having less than 40 employees.", "context": "CREATE TABLE silver_mine_2 (site_id INT, country VARCHAR(50), num_employees INT, extraction_date DATE, quantity INT); INSERT INTO silver_mine_2 (site_id, country, num_employees, extraction_date, quantity) VALUES (1, 'Mexico', 35, '2017-05-02', 1200), (2, 'Mexico', 30, '2017-08-31', 1800), (3, 'Mexico', 37, '2017-07-04', 2200);", "reference_sql": "SELECT country, SUM(quantity) as total_silver_prod FROM silver_mine_2 WHERE num_employees < 40 AND country = 'Mexico' AND extraction_date >= '2017-05-01' AND extraction_date <= '2017-09-30' GROUP BY country;", "generated_sql": "SELECT SUM(quantity) FROM silver_mine_2 WHERE country = 'Mexico' AND extraction_date BETWEEN '2017-05-01' AND '2017-09-30' AND num_employees < 40;", "raw_model_output": "\n\nSELECT SUM(quantity) FROM silver_mine_2 WHERE country = 'Mexico' AND extraction_date BETWEEN '2017-05-01' AND '2017-09-30' AND num_employees < 40;", "latency_sec": 0.47072505950927734, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1031, "prompt_eval_sec": null, "tokens_completion": 59, "completion_eval_sec": null, "tokens_total": 1090, "tokens_per_sec": 2315.576742687772, "retrieval_latency_sec": 0.13418793678283691, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a GROUP BY country and selects the country column, resulting in a two-column output (country, total_silver_prod). The Generated SQL omits the GROUP BY and country column, producing a single-column output of just the sum. While both calculate the same aggregate value, their result structures differ, making them semantically non-equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly filter for Mexico, the date range, and employee count <40, and calculate the same total silver production. The Reference SQL includes an unnecessary GROUP BY country, which adds an extra column to the output but doesn't affect the sum. The Generated SQL is more efficient by omitting the redundant GROUP BY and directly returning the scalar value. While the Reference SQL technically produces the same numerical result, the Generated SQL better aligns with the business intent of returning a single total value without extraneous columns.", "overall_assessment": "correct"}}
{"example_id": 3518, "sql_complexity": "basic SQL", "prompt": "Insert new records of ticket sales for a new event, including event and salesperson information.", "context": "CREATE TABLE salesperson (salesperson_id INT, name VARCHAR(50), position VARCHAR(50)); CREATE TABLE tickets (ticket_id INT, salesperson_id INT, event_id INT, price DECIMAL(5,2), quantity INT); CREATE TABLE events (event_id INT, name VARCHAR(50), date DATE); INSERT INTO salesperson VALUES (1, 'John Doe', 'Senior Salesperson'); INSERT INTO events VALUES (2, 'New Event', '2023-04-15');", "reference_sql": "INSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity) VALUES (2, 1, 2, 75, 50), (3, 2, 2, 65, 75); INSERT INTO events (event_id, name, date) VALUES (2, 'New Event', '2023-04-15');", "generated_sql": "INSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity) VALUES (3, 1, 2, 50, 100);", "raw_model_output": "\n\nINSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity) VALUES (3, 1, 2, 50, 100);", "latency_sec": 0.364696741104126, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 960, "prompt_eval_sec": null, "tokens_completion": 42, "completion_eval_sec": null, "tokens_total": 1002, "tokens_per_sec": 2747.488219846514, "retrieval_latency_sec": 0.12429523468017578, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL inserts two rows into the tickets table and one row into the events table, while the Generated SQL only inserts a single row into the tickets table. The data values and number of rows inserted differ between the two queries, so they are not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is technically flawed as it attempts to reinsert an existing event (event_id=2) that already exists in the context, which would cause a primary key violation if event_id is unique. It also inserts two ticket records, but the original question specifies 'new records' without quantifying the number. The Generated SQL correctly inserts a single ticket record with valid foreign keys (salesperson_id=1 exists, event_id=2 exists in context) but omits inserting the event itself. While the original question mentions 'new event,' the context already contains an event with event_id=2, suggesting the event might already exist. The Generated SQL better fulfills the intent by focusing on ticket sales without redundant data insertion, though neither query fully addresses the 'new event' requirement. The Reference SQL's redundancy makes it less efficient, while the Generated SQL is more concise but incomplete.", "overall_assessment": "differently_correct"}}
{"example_id": 3925, "sql_complexity": "set operations", "prompt": "What is the total number of students and staff with accommodations in the \"disability_services\" schema, excluding the \"accessibility_parking\" type?", "context": "CREATE SCHEMA disability_services; CREATE TABLE staff (id INT, name VARCHAR(50), accommodation VARCHAR(50)); CREATE TABLE students (id INT, name VARCHAR(50), accommodation VARCHAR(50));", "reference_sql": "SELECT COUNT(*) FROM disability_services.staff WHERE accommodation != 'accessibility_parking' UNION SELECT COUNT(*) FROM disability_services.students WHERE accommodation != 'accessibility_parking';", "generated_sql": "SELECT (SELECT COUNT(*) FROM disability_services.staff WHERE accommodation != 'accessibility_parking') + (SELECT COUNT(*) FROM disability_services.students WHERE accommodation != 'accessibility_parking') AS total;", "raw_model_output": "\n\nSELECT (SELECT COUNT(*) FROM disability_services.staff WHERE accommodation != 'accessibility_parking') + (SELECT COUNT(*) FROM disability_services.students WHERE accommodation != 'accessibility_parking') AS total;", "latency_sec": 0.3671228885650635, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 629, "prompt_eval_sec": null, "tokens_completion": 44, "completion_eval_sec": null, "tokens_total": 673, "tokens_per_sec": 1833.173634666277, "retrieval_latency_sec": 0.13010120391845703, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate counts as individual rows via UNION, while the Generated SQL returns a single summed value. The first query's output has two rows (staff count and student count), whereas the second query's output is a single row with the total. The result structures differ, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query uses UNION to combine two separate counts, resulting in two rows of output (e.g., [10, 20]) rather than a single total. The generated query correctly sums the counts using arithmetic addition, producing a single numeric result. While both queries exclude 'accessibility_parking' properly, only the generated query aligns with the business requirement for a total number. The reference query technically fulfills the filtering logic but fails to aggregate the results as requested.", "overall_assessment": "differently_correct"}}
{"example_id": 3340, "sql_complexity": "subqueries", "prompt": "Calculate the total revenue for garments manufactured in the US and sold in California.", "context": "CREATE TABLE garment_manufacturing(id INT PRIMARY KEY, garment_id INT, country VARCHAR(50), material VARCHAR(50), manufacturing_date DATE, quantity INT); CREATE TABLE garment_sales(id INT PRIMARY KEY, garment_id INT, store_id INT, sale_date DATE, units INT, revenue DECIMAL(10,2));", "reference_sql": "SELECT SUM(gs.revenue) FROM garment_manufacturing gm JOIN garment_sales gs ON gm.garment_id = gs.garment_id WHERE gm.country = 'United States' AND gs.store_id IN (SELECT id FROM stores WHERE region = 'California');", "generated_sql": "SELECT SUM(garment_sales.revenue) \nFROM garment_sales \nINNER JOIN garment_manufacturing \nON garment_sales.garment_id = garment_manufacturing.garment_id \nWHERE garment_manufacturing.country = 'US' AND garment_sales.store_id IN (SELECT id FROM stores WHERE state = 'California');", "raw_model_output": "\n\n```sql\nSELECT SUM(garment_sales.revenue) \nFROM garment_sales \nINNER JOIN garment_manufacturing \nON garment_sales.garment_id = garment_manufacturing.garment_id \nWHERE garment_manufacturing.country = 'US' AND garment_sales.store_id IN (SELECT id FROM stores WHERE state = 'California');\n```", "latency_sec": 0.5627930164337158, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 937, "prompt_eval_sec": null, "tokens_completion": 74, "completion_eval_sec": null, "tokens_total": 1011, "tokens_per_sec": 1796.3975573230532, "retrieval_latency_sec": 0.11960697174072266, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects: 1) The country filter uses 'United States' vs 'US' (potential data mismatch), and 2) The subquery references 'region' vs 'state' in the stores table (assuming stores schema exists). These differences in conditions would produce different results unless the stores table's 'region' and 'state' columns are identical and the country values are stored consistently as 'US' vs 'United States'.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in two critical aspects: 1) The reference uses 'United States' while the generated uses 'US' for country comparison, which may not match stored data. 2) The reference uses 'region = 'California'' while the generated uses 'state = 'California'' in the subquery. Since the stores table schema isn't provided, but the original question mentions 'California' as a state, the generated query's 'state' column might be correct. However, the reference's 'region' could be appropriate if the stores table uses that terminology. The generated query's use of 'US' vs 'United States' introduces ambiguity. Neither query is definitively correct without knowing the actual schema, but the reference better aligns with the question's phrasing of 'sold in California' (implying state-level data) and uses more explicit country naming. The generated query's subquery might fail if the stores table lacks a 'state' column.", "overall_assessment": "differently_correct"}}
{"example_id": 596, "sql_complexity": "basic SQL", "prompt": "What is the minimum energy production cost of wind farms in Spain?", "context": "CREATE TABLE wind_farm_costs (id INT, name TEXT, country TEXT, energy_production_cost FLOAT); INSERT INTO wind_farm_costs (id, name, country, energy_production_cost) VALUES (1, 'Las Tiesas', 'Spain', 0.045), (2, 'Eolo', 'Spain', 0.050);", "reference_sql": "SELECT MIN(energy_production_cost) FROM wind_farm_costs WHERE country = 'Spain';", "generated_sql": "SELECT MIN(energy_production_cost) FROM wind_farm_costs WHERE country = 'Spain';", "raw_model_output": "\n\nSELECT MIN(energy_production_cost) FROM wind_farm_costs WHERE country = 'Spain';", "latency_sec": 0.34901905059814453, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 709, "prompt_eval_sec": null, "tokens_completion": 23, "completion_eval_sec": null, "tokens_total": 732, "tokens_per_sec": 2097.306719348149, "retrieval_latency_sec": 0.12809205055236816, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They both select the minimum energy_production_cost from the wind_farm_costs table where the country is 'Spain'. The output will be the same as they execute the same operation on the same data.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic. They correctly filter wind farms in Spain and calculate the minimum energy production cost. The queries are technically identical, semantically equivalent, and fully address the business question. Neither query demonstrates superior efficiency or elegance since they are the same.", "overall_assessment": "correct"}}
{"example_id": 2604, "sql_complexity": "subqueries", "prompt": "What is the maximum number of virtual tours taken by a single user in the UK?", "context": "CREATE TABLE virtual_tour_data (user_id INT, hotel_id INT, tour_date DATE); INSERT INTO virtual_tour_data (user_id, hotel_id, tour_date) VALUES (1, 10, '2022-01-01'), (2, 11, '2022-01-03'), (3, 12, '2022-01-05'), (4, 10, '2022-01-07'), (5, 10, '2022-01-09'); CREATE TABLE hotels (hotel_id INT, hotel_name TEXT, country TEXT); INSERT INTO hotels (hotel_id, hotel_name, country) VALUES (10, 'Royal Park Hotel', 'UK'), (11, 'The Ritz London', 'UK'), (12, 'Hotel de Crillon', 'France');", "reference_sql": "SELECT MAX(vt.user_tours) FROM (SELECT user_id, COUNT(DISTINCT hotel_id) as user_tours FROM virtual_tour_data WHERE country = 'UK' GROUP BY user_id) as vt;", "generated_sql": "SELECT MAX(tour_count) AS max_tours_by_user\nFROM (\n    SELECT COUNT(*) AS tour_count\n    FROM virtual_tour_data v\n    JOIN hotels h ON v.hotel_id = h.hotel_id\n    WHERE h.country = 'UK'\n    GROUP BY v.user_id\n) AS user_tour_counts;", "raw_model_output": "\n\nTo answer the question \"What is the maximum number of virtual tours taken by a single user in the UK?\", we need to:\n\n1. Join the `virtual_tour_data` table with the `hotels` table on `hotel_id`.\n2. Filter the results to include only hotels located in the UK.\n3. Count the number of virtual tours per user.\n4. Find the maximum count.\n\nHere is the SQL query:\n\n```sql\nSELECT MAX(tour_count) AS max_tours_by_user\nFROM (\n    SELECT COUNT(*) AS tour_count\n    FROM virtual_tour_data v\n    JOIN hotels h ON v.hotel_id = h.hotel_id\n    WHERE h.country = 'UK'\n    GROUP BY v.user_id\n) AS user_tour_counts;\n```", "latency_sec": 1.1498329639434814, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 878, "prompt_eval_sec": null, "tokens_completion": 164, "completion_eval_sec": null, "tokens_total": 1042, "tokens_per_sec": 906.2185836335252, "retrieval_latency_sec": 0.12853598594665527, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references a 'country' column in virtual_tour_data, which does not exist. The Generated SQL correctly joins with the hotels table to filter by country. Additionally, the Reference SQL uses COUNT(DISTINCT hotel_id) while the Generated SQL uses COUNT(*), leading to different results when users visit the same hotel multiple times.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query is technically incorrect because it references a 'country' column in the virtual_tour_data table, which doesn't exist. The generated query correctly joins with the hotels table to filter UK-based tours. While both aim to find the maximum tours per user, only the generated query properly addresses the business intent by accurately filtering UK hotels through a join. The reference query would fail due to invalid column reference.", "overall_assessment": "differently_correct"}}
{"example_id": 5812, "sql_complexity": "single join", "prompt": "Calculate the percentage of Shariah-compliant investments held by each investor in the top 5 countries with the highest percentage?", "context": "CREATE TABLE investors (investor_id INT, investor_name TEXT, country TEXT); INSERT INTO investors (investor_id, investor_name, country) VALUES (1, 'Al Thani', 'Qatar'), (2, 'Saudi Investment Group', 'Saudi Arabia'), (3, 'Temasek Holdings', 'Singapore'); CREATE TABLE investments (investment_id INT, investor_id INT, investment_type TEXT, investment_value DECIMAL, is_shariah_compliant BOOLEAN); INSERT INTO investments (investment_id, investor_id, investment_type, investment_value, is_shariah_compliant) VALUES (1, 1, 'Real Estate', 15000000, true), (2, 2, 'Stocks', 20000000, false);", "reference_sql": "SELECT investor_name, ROUND((SUM(CASE WHEN is_shariah_compliant THEN investment_value ELSE 0 END) / SUM(investment_value)) * 100, 2) AS percentage FROM investments JOIN investors ON investments.investor_id = investors.investor_id GROUP BY investor_name ORDER BY percentage DESC LIMIT 5;", "generated_sql": "SELECT i.country, \n       (COUNT(CASE WHEN inv.is_shariah_compliant THEN 1 END) * 100.0 / COUNT(*)) AS shariah_percentage\nFROM investors i\nJOIN investments inv ON i.investor_id = inv.investor_id\nGROUP BY i.country\nORDER BY shariah_percentage DESC\nLIMIT 5;", "raw_model_output": "\n\n```sql\nSELECT i.country, \n       (COUNT(CASE WHEN inv.is_shariah_compliant THEN 1 END) * 100.0 / COUNT(*)) AS shariah_percentage\nFROM investors i\nJOIN investments inv ON i.investor_id = inv.investor_id\nGROUP BY i.country\nORDER BY shariah_percentage DESC\nLIMIT 5;\n```", "latency_sec": 0.6871001720428467, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1172, "prompt_eval_sec": null, "tokens_completion": 86, "completion_eval_sec": null, "tokens_total": 1258, "tokens_per_sec": 1830.8829646480613, "retrieval_latency_sec": 0.12057232856750488, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates the percentage of investment value that is shariah-compliant per investor, while the Generated SQL calculates the percentage of shariah-compliant investments (count-based) per country. Key differences: 1) Grouping by investor_name vs. country, 2) Value-based ratio vs. count-based ratio, 3) Different output columns (investor_name vs. country).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL calculates Shariah-compliant percentages per investor, while the question requires percentages per country. The Generated SQL groups by country, aligning with the 'top 5 countries' requirement. However, neither query fully addresses the 'investor in top 5 countries' aspect. The Generated SQL better fulfills the intent by focusing on countries, but both fail to calculate investor-level percentages within those countries. The Reference SQL is technically correct but misaligned with the question's focus on countries.", "overall_assessment": "differently_correct"}}
{"example_id": 4706, "sql_complexity": "multiple_joins", "prompt": "Who are the top 3 customers by total spend on makeup products from Italy and Spain?", "context": "CREATE TABLE customers (customer_id INT, customer_name TEXT, country TEXT); INSERT INTO customers (customer_id, customer_name, country) VALUES (1, 'Alessandro Martini', 'IT'), (2, 'Laura Rossi', 'ES'), (3, 'Daniela Gonzalez', 'MX'), (4, 'Jose Hernandez', 'ES'), (5, 'Sophia Rodriguez', 'IT'); CREATE TABLE sales (sale_id INT, customer_id INT, product_id INT, sale_quantity INT, sale_country TEXT); INSERT INTO sales (sale_id, customer_id, product_id, sale_quantity, sale_country) VALUES (1, 1, 1, 100, 'IT'), (2, 2, 2, 150, 'ES'), (3, 3, 3, 200, 'MX'), (4, 4, 4, 250, 'ES'), (5, 5, 5, 300, 'IT'); CREATE TABLE products (product_id INT, product_name TEXT, category TEXT); INSERT INTO products (product_id, product_name, category) VALUES (1, 'Eyeshadow Palette', 'makeup'), (2, 'Liquid Lipstick', 'makeup'), (3, 'BB Cream', 'makeup'), (4, 'Volumizing Mascara', 'makeup'), (5, 'Nourishing Lip Balm', 'makeup');", "reference_sql": "SELECT c.customer_name, SUM(s.sale_quantity) as total_spent_on_makeup FROM sales s JOIN customers c ON s.customer_id = c.customer_id JOIN products p ON s.product_id = p.product_id WHERE c.country IN ('IT', 'ES') AND p.category = 'makeup' GROUP BY c.customer_name ORDER BY total_spent_on_makeup DESC LIMIT 3;", "generated_sql": "SELECT customers.customer_name \nFROM customers \nJOIN sales ON customers.customer_id = sales.customer_id \nJOIN products ON sales.product_id = products.product_id \nWHERE sales.sale_country IN ('IT', 'ES') AND products.category = 'makeup' \nGROUP BY customers.customer_id \nORDER BY SUM(sales.sale_quantity) DESC \nLIMIT 3;", "raw_model_output": "\n\n```sql\nSELECT customers.customer_name \nFROM customers \nJOIN sales ON customers.customer_id = sales.customer_id \nJOIN products ON sales.product_id = products.product_id \nWHERE sales.sale_country IN ('IT', 'ES') AND products.category = 'makeup' \nGROUP BY customers.customer_id \nORDER BY SUM(sales.sale_quantity) DESC \nLIMIT 3;\n```", "latency_sec": 0.6106307506561279, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1409, "prompt_eval_sec": null, "tokens_completion": 79, "completion_eval_sec": null, "tokens_total": 1488, "tokens_per_sec": 2436.824543148427, "retrieval_latency_sec": 0.1255970001220703, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Reference SQL uses `c.country IN ('IT', 'ES')` while the Generated SQL uses `sales.sale_country IN ('IT', 'ES')` - these could filter different rows if sale_country differs from customer.country. Second, the Reference groups by `customer_name` (which may have duplicates) while the Generated groups by `customer_id` (unique). Though the sample data may produce similar results, the queries are not semantically equivalent in general.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly filters customers by their country (customers.country IN ('IT', 'ES')) while the generated query incorrectly filters by sale_country (sales.sale_country IN ('IT', 'ES')). This means the generated query could include customers from other countries who made purchases in Italy/Spain, violating the original requirement. The reference query groups by customer_name (which may not be unique) while the generated groups by customer_id (more reliable), but the critical business intent violation in the generated query makes it incorrect. Both queries calculate total spend correctly, but the reference better aligns with the question's requirements.", "overall_assessment": "differently_correct"}}
{"example_id": 1515, "sql_complexity": "multiple_joins", "prompt": "What is the average age of clients who lost cases in the 'personal injury' category?", "context": "CREATE TABLE Cases (CaseID int, ClientID int, Category varchar(50)); INSERT INTO Cases (CaseID, ClientID, Category) VALUES (701, 7, 'Personal Injury'); CREATE TABLE Clients (ClientID int, Age int, Gender varchar(10)); INSERT INTO Clients (ClientID, Age, Gender) VALUES (7, 45, 'Male'); CREATE TABLE CaseOutcomes (CaseID int, Outcome varchar(50)); INSERT INTO CaseOutcomes (CaseID, Outcome) VALUES (701, 'Lost');", "reference_sql": "SELECT AVG(C.Age) as AvgAge FROM Clients C INNER JOIN Cases CA ON C.ClientID = CA.ClientID INNER JOIN CaseOutcomes CO ON CA.CaseID = CO.CaseID WHERE CA.Category = 'Personal Injury' AND CO.Outcome = 'Lost';", "generated_sql": "SELECT AVG(C.Age) FROM Clients C INNER JOIN Cases CA ON C.ClientID = CA.ClientID INNER JOIN CaseOutcomes CO ON CA.CaseID = CO.CaseID WHERE CA.Category = 'Personal Injury' AND CO.Outcome = 'Lost';", "raw_model_output": "\n\nSELECT AVG(C.Age) FROM Clients C INNER JOIN Cases CA ON C.ClientID = CA.ClientID INNER JOIN CaseOutcomes CO ON CA.CaseID = CO.CaseID WHERE CA.Category = 'Personal Injury' AND CO.Outcome = 'Lost';", "latency_sec": 0.5672781467437744, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 751, "prompt_eval_sec": null, "tokens_completion": 57, "completion_eval_sec": null, "tokens_total": 808, "tokens_per_sec": 1424.3453667975575, "retrieval_latency_sec": 0.13798809051513672, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. The only difference is the presence of an alias ('as AvgAge') in the reference query, which does not affect the computed result. Both queries calculate the same average age using identical joins and filters.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are structurally identical except for the column alias in the SELECT clause. The reference query explicitly names the result column as 'AvgAge', while the generated query omits the alias. Since the question only asks for the average value (not a named column), both produce the same numerical result. The technical logic (joins, filters, aggregation) is identical. The generated query is slightly more concise but lacks the explicit alias. Neither query has syntax errors or logical flaws. Both correctly address the business intent of calculating the average age of clients who lost personal injury cases.", "overall_assessment": "correct"}}
{"example_id": 4388, "sql_complexity": "subqueries", "prompt": "Insert a new drug with a price 10% higher than the average price", "context": "CREATE TABLE drugs (drug_id INT, drug_name VARCHAR(50), price DECIMAL(10, 2)); INSERT INTO drugs (drug_id, drug_name, price) VALUES (1, 'DrugA', 50), (2, 'DrugB', 75), (3, 'DrugC', 100)", "reference_sql": "INSERT INTO drugs (drug_id, drug_name, price) VALUES ((SELECT MAX(drug_id) FROM drugs) + 1, 'DrugD', (SELECT AVG(price) * 1.1 FROM drugs))", "generated_sql": "INSERT INTO drugs (drug_name, price) VALUES ('NewDrug', (SELECT 1.1 * AVG(price) FROM drugs));", "raw_model_output": "\n\nINSERT INTO drugs (drug_name, price) VALUES ('NewDrug', (SELECT 1.1 * AVG(price) FROM drugs));", "latency_sec": 0.29631996154785156, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 777, "prompt_eval_sec": null, "tokens_completion": 32, "completion_eval_sec": null, "tokens_total": 809, "tokens_per_sec": 2730.1569417535097, "retrieval_latency_sec": 0.14064931869506836, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL explicitly sets drug_id to (SELECT MAX(drug_id) FROM drugs) + 1, while the Generated SQL omits drug_id entirely. The Generated SQL would insert a NULL or default value for drug_id (assuming the database allows it), which differs from the Reference SQL's calculated value. Additionally, the drug_name values differ ('DrugD' vs 'NewDrug'), making the inserted rows semantically different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly calculates the next drug_id by using (SELECT MAX(drug_id) FROM drugs) + 1, ensuring proper sequence. It also explicitly includes all required columns (drug_id, drug_name, price) in the INSERT. The generated query omits the drug_id column entirely, which is a required field in the schema (as seen in the initial INSERT statement). While both calculate the price as 1.1 * AVG(price), the generated query would fail due to missing required columns. The reference better fulfills the business intent by handling both the ID sequence and price calculation correctly.", "overall_assessment": "incorrect"}}
{"example_id": 5431, "sql_complexity": "basic SQL", "prompt": "What is the average CO2 emission of ride-hailing vehicles in San Francisco?", "context": "CREATE TABLE SFRideHailing (id INT, company VARCHAR(20), co2_emission DECIMAL(5,2));", "reference_sql": "SELECT AVG(co2_emission) FROM SFRideHailing WHERE company = 'Uber';", "generated_sql": "SELECT AVG(co2_emission) FROM SFRideHailing;", "raw_model_output": "\n\nSQL: SELECT AVG(co2_emission) FROM SFRideHailing;", "latency_sec": 0.3327510356903076, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 584, "prompt_eval_sec": null, "tokens_completion": 21, "completion_eval_sec": null, "tokens_total": 605, "tokens_per_sec": 1818.1761590761066, "retrieval_latency_sec": 0.13086795806884766, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query filters results to only include rows where company = 'Uber' before calculating the average, while the generated query calculates the average for all companies without any filtering. This will produce different results unless all rows in the table belong to Uber.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query incorrectly filters for 'Uber' vehicles only, while the original question asks about all ride-hailing vehicles in San Francisco (without specifying a company). The generated query correctly calculates the average CO2 emission for all vehicles in the table, which aligns with the broader scope of the question. However, neither query explicitly filters for San Francisco (though the table name SFRideHailing implies location). The generated query is more inclusive and technically correct for the stated schema, but both fail to explicitly address the 'San Francisco' aspect beyond the table name.", "overall_assessment": "differently_correct"}}
{"example_id": 3531, "sql_complexity": "single join", "prompt": "What is the total number of workouts and total workout time per user for users with a membership type of 'Basic'?", "context": "CREATE TABLE Members (id INT, user_name VARCHAR, membership_type VARCHAR, signup_date DATE); CREATE TABLE Workouts (id INT, user_id INT, workout_date DATE, workout_duration INT); INSERT INTO Members (id, user_name, membership_type, signup_date) VALUES (1, 'John Doe', 'Premium', '2020-01-01'), (2, 'Jane Smith', 'Basic', '2019-06-15'), (3, 'Alice Johnson', 'Premium', '2020-03-20'); INSERT INTO Workouts (id, user_id, workout_date, workout_duration) VALUES (1, 1, '2020-01-01', 60), (2, 1, '2020-01-02', 70), (3, 2, '2019-06-15', 90), (4, 3, '2020-03-20', 65), (5, 3, '2020-03-21', 70);", "reference_sql": "SELECT Members.user_name, SUM(Workouts.workout_duration) AS total_workout_time, COUNT(Workouts.id) AS total_workouts FROM Members JOIN Workouts ON Members.id = Workouts.user_id WHERE Members.membership_type = 'Basic' GROUP BY Members.user_name;", "generated_sql": "SELECT Members.user_name, COUNT(Workouts.id) AS total_workouts, SUM(Workouts.workout_duration) AS total_workout_time\nFROM Members\nJOIN Workouts ON Members.id = Workouts.user_id\nWHERE Members.membership_type = 'Basic'\nGROUP BY Members.user_name;", "raw_model_output": "\n\nSELECT Members.user_name, COUNT(Workouts.id) AS total_workouts, SUM(Workouts.workout_duration) AS total_workout_time\nFROM Members\nJOIN Workouts ON Members.id = Workouts.user_id\nWHERE Members.membership_type = 'Basic'\nGROUP BY Members.user_name;", "latency_sec": 0.5131278038024902, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1125, "prompt_eval_sec": null, "tokens_completion": 65, "completion_eval_sec": null, "tokens_total": 1190, "tokens_per_sec": 2319.110348692091, "retrieval_latency_sec": 0.12200021743774414, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The two queries are semantically equivalent. Both select the same columns (user_name, total_workout_time, total_workouts) with identical aggregate functions (SUM and COUNT) on the same tables. The order of columns in the SELECT clause does not affect semantic equivalence. Both queries apply the same JOIN condition, WHERE filter, and GROUP BY clause, ensuring identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are structurally identical except for the order of columns in the SELECT clause. The reference query lists 'total_workout_time' first while the generated query lists 'total_workouts' first, but this does not affect the results. Both correctly join Members and Workouts tables on user_id, filter for 'Basic' membership, group by user_name, and calculate the required aggregates (COUNT and SUM). The business intent is fully satisfied as both queries return the total workouts and total workout time per eligible user.", "overall_assessment": "correct"}}
{"example_id": 5678, "sql_complexity": "set operations", "prompt": "How many public works projects are there in 'Sydney' and 'Melbourne' combined?", "context": "CREATE TABLE PublicWorksC(id INT, city VARCHAR(20), project VARCHAR(30)); INSERT INTO PublicWorksC(id, city, project) VALUES (1, 'Sydney', 'Park Renovation'), (2, 'Melbourne', 'Sidewalk Repair');", "reference_sql": "SELECT COUNT(*) FROM (SELECT city FROM PublicWorksC WHERE city = 'Sydney' UNION ALL SELECT city FROM PublicWorksC WHERE city = 'Melbourne') AS Total;", "generated_sql": "SELECT COUNT(*) FROM PublicWorksC WHERE city IN ('Sydney', 'Melbourne');", "raw_model_output": "\n\nSELECT COUNT(*) FROM PublicWorksC WHERE city IN ('Sydney', 'Melbourne');", "latency_sec": 0.24027323722839355, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 748, "prompt_eval_sec": null, "tokens_completion": 23, "completion_eval_sec": null, "tokens_total": 771, "tokens_per_sec": 3208.8467650149487, "retrieval_latency_sec": 0.13319015502929688, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of rows where the city is either 'Sydney' or 'Melbourne'. The Reference SQL uses a UNION ALL to combine results from two separate selects, while the Generated SQL uses IN to filter directly. Since UNION ALL preserves all rows (and there's no overlap between the two cities), the final count remains the same.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count projects in Sydney and Melbourne. The Reference query uses a UNION ALL subquery to combine results from two separate city filters, while the Generated query uses a single WHERE clause with IN. Both produce identical counts. However, the Generated query is more efficient as it scans the table once versus two separate scans in the Reference query. The Generated version is also more concise and directly addresses the business intent of counting combined projects.", "overall_assessment": "correct"}}
{"example_id": 5792, "sql_complexity": "multiple_joins", "prompt": "How many cases were handled by attorneys in the 'Los Angeles' office?", "context": "CREATE TABLE offices (office_id INT, office_name VARCHAR(20), city VARCHAR(20), state VARCHAR(20)); INSERT INTO offices (office_id, office_name, city, state) VALUES (1, 'Boston', 'Boston', 'MA'), (2, 'New York', 'New York', 'NY'), (3, 'Los Angeles', 'Los Angeles', 'CA'); CREATE TABLE attorneys (attorney_id INT, office_id INT); INSERT INTO attorneys (attorney_id, office_id) VALUES (1, 1), (2, 2), (3, 3); CREATE TABLE cases (case_id INT, attorney_id INT); INSERT INTO cases (case_id, attorney_id) VALUES (1, 1), (2, 2), (3, 3);", "reference_sql": "SELECT COUNT(*) FROM cases JOIN attorneys ON cases.attorney_id = attorneys.attorney_id JOIN offices ON attorneys.office_id = offices.office_id WHERE offices.city = 'Los Angeles';", "generated_sql": "SELECT COUNT(*) \nFROM cases \nINNER JOIN attorneys ON cases.attorney_id = attorneys.attorney_id \nINNER JOIN offices ON attorneys.office_id = offices.office_id \nWHERE offices.office_name = 'Los Angeles';", "raw_model_output": "\n\nSELECT COUNT(*) \nFROM cases \nINNER JOIN attorneys ON cases.attorney_id = attorneys.attorney_id \nINNER JOIN offices ON attorneys.office_id = offices.office_id \nWHERE offices.office_name = 'Los Angeles';", "latency_sec": 0.39292287826538086, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 899, "prompt_eval_sec": null, "tokens_completion": 47, "completion_eval_sec": null, "tokens_total": 946, "tokens_per_sec": 2407.5971452114577, "retrieval_latency_sec": 0.13680100440979004, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their WHERE clause conditions: the Reference SQL filters on 'offices.city = 'Los Angeles'', while the Generated SQL filters on 'offices.office_name = 'Los Angeles''. Although the sample data has matching values for these columns, the conditions are logically distinct. Semantically, they are not equivalent because they could produce different results with different data (e.g., an office with a different city but same name, or same city but different name).", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries produce the same result in this specific dataset because the 'Los Angeles' office has both office_name and city set to 'Los Angeles'. However, the Generated SQL explicitly filters on offices.office_name = 'Los Angeles', which directly matches the phrasing of the original question ('Los Angeles office'). The Reference SQL uses offices.city = 'Los Angeles', which could be less precise if the office's name differed from its city (e.g., a branch named 'LA Downtown' in Los Angeles). While both are technically correct in this context, the Generated SQL better aligns with the business intent by matching the office's name as referenced in the question.", "overall_assessment": "differently_correct"}}
{"example_id": 5148, "sql_complexity": "window functions", "prompt": "List the unique types of smart city technologies that have been implemented in the top 3 most populous countries in the world.", "context": "CREATE TABLE smart_city_tech (tech_type VARCHAR(255), country VARCHAR(255)); CREATE TABLE country_populations (country VARCHAR(255), population INT);", "reference_sql": "SELECT DISTINCT tech_type FROM smart_city_tech SCT WHERE country IN (SELECT country FROM (SELECT country, ROW_NUMBER() OVER (ORDER BY population DESC) as rank FROM country_populations) CP WHERE rank <= 3);", "generated_sql": "SELECT DISTINCT st.tech_type\nFROM smart_city_tech st\nWHERE st.country IN (\n    SELECT country\n    FROM country_populations\n    ORDER BY population DESC\n    LIMIT 3\n);", "raw_model_output": "\n\n```sql\nSELECT DISTINCT st.tech_type\nFROM smart_city_tech st\nWHERE st.country IN (\n    SELECT country\n    FROM country_populations\n    ORDER BY population DESC\n    LIMIT 3\n);\n```", "latency_sec": 0.5033628940582275, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 745, "prompt_eval_sec": null, "tokens_completion": 49, "completion_eval_sec": null, "tokens_total": 794, "tokens_per_sec": 1577.3908036776195, "retrieval_latency_sec": 0.12055516242980957, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries aim to retrieve distinct tech_types from smart_city_tech where the country is among the top 3 most populous countries. The reference query uses ROW_NUMBER() to explicitly rank countries by population and filter the top 3, while the generated query uses ORDER BY and LIMIT 3 to achieve the same result. Since both methods ultimately select the same set of countries (assuming deterministic ordering), the final results will be identical. The DISTINCT keyword in the outer query ensures uniqueness, and the IN clause handles duplicates in the subquery results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify unique smart city technologies in the top 3 most populous countries. The reference query uses a window function with ROW_NUMBER() to rank countries, while the generated query uses ORDER BY + LIMIT 3. Both approaches yield the same result set in standard scenarios. However, the generated query is more efficient and elegant, as LIMIT 3 directly achieves the goal without complex window functions. The reference query's subquery structure is functionally equivalent but adds unnecessary complexity. Both fulfill the business intent, but the generated query is technically superior due to simplicity and performance.", "overall_assessment": "correct"}}
{"example_id": 5547, "sql_complexity": "multiple_joins", "prompt": "Which species have a population growth rate higher than the average for protected areas?", "context": "CREATE TABLE species (id INT, name VARCHAR(50), population DECIMAL(5,2), protected_area_id INT, growth_rate DECIMAL(5,2)); INSERT INTO species (id, name, population, protected_area_id, growth_rate) VALUES (1, 'Species 1', 500.00, 1, 0.05), (2, 'Species 2', 800.00, 1, 0.03), (3, 'Species 3', 1200.00, 2, 0.07), (4, 'Species 4', 700.00, 2, 0.02); CREATE TABLE protected_areas (id INT, name VARCHAR(50)); INSERT INTO protected_areas (id, name) VALUES (1, 'Area 1'), (2, 'Area 2');", "reference_sql": "SELECT s.name, s.growth_rate FROM species s INNER JOIN protected_areas pa ON s.protected_area_id = pa.id GROUP BY s.name, s.growth_rate HAVING s.growth_rate > (SELECT AVG(s.growth_rate) FROM species s INNER JOIN protected_areas pa ON s.protected_area_id = pa.id);", "generated_sql": "SELECT name\nFROM species\nWHERE growth_rate > (SELECT AVG(growth_rate) FROM species);", "raw_model_output": "\n\nTo answer the question \"Which species have a population growth rate higher than the average for protected areas?\" we need to calculate the average growth rate of all species and then select those species whose growth rate is higher than this average.\n\nHere is the SQL query:\n\n```sql\nSELECT name\nFROM species\nWHERE growth_rate > (SELECT AVG(growth_rate) FROM species);\n```", "latency_sec": 0.7169060707092285, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1183, "prompt_eval_sec": null, "tokens_completion": 80, "completion_eval_sec": null, "tokens_total": 1263, "tokens_per_sec": 1761.7370693353535, "retrieval_latency_sec": 0.13976216316223145, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL includes a redundant JOIN with protected_areas in its subquery (which doesn't affect the AVG calculation) and returns both 'name' and 'growth_rate' columns. The Generated SQL omits the JOIN, calculates the average directly from the species table, and only returns 'name'. Additionally, the Reference SQL uses GROUP BY and HAVING, which are unnecessary here and would produce the same result as a WHERE clause. However, the differing column outputs and subquery logic make them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The Reference SQL correctly calculates the average growth rate specifically for species in protected areas by joining with the protected_areas table, ensuring the comparison is contextually accurate. The Generated SQL incorrectly calculates the average growth rate across all species without considering the protected_areas context, which violates the original question's requirement. While both queries identify species with growth rates above averages, the Reference SQL's subquery explicitly filters to protected area species, making it technically correct and semantically aligned with the business intent. The Generated SQL's subquery includes all species, potentially including non-protected ones, which would distort the average.", "overall_assessment": "{'reference': 'correct', 'generated': 'incorrect'}"}}
{"example_id": 5498, "sql_complexity": "aggregation", "prompt": "Identify the destinations with the highest number of repeat visitors from the US.", "context": "CREATE TABLE RepeatTravelers (Visitor VARCHAR(20), Destination VARCHAR(20), VisitCount INT); INSERT INTO RepeatTravelers (Visitor, Destination, VisitCount) VALUES ('David', 'Paris', 3), ('Ella', 'London', 4), ('Fiona', 'Paris', 2);", "reference_sql": "SELECT Destination, AVG(VisitCount) AS AvgVisitCount FROM RepeatTravelers WHERE Visitor LIKE '%USA%' GROUP BY Destination ORDER BY AvgVisitCount DESC;", "generated_sql": "SELECT Destination, VisitCount\nFROM RepeatTravelers\nORDER BY VisitCount DESC;", "raw_model_output": "\n\nBased on the provided schema, the question \"Identify the destinations with the highest number of repeat visitors from the US\" cannot be directly answered because the schema does not include any information about the visitors' country of origin or their nationality. The schema only contains the `RepeatTravelers` table with columns `Visitor`, `Destination`, and `VisitCount`.\n\nTherefore, it is not possible to determine which visitors are from the US with the given schema.\n\nHowever, if we assume that the `Visitor` column in the `RepeatTravelers` table represents a unique identifier for visitors and that we are to find the destinations with the highest `VisitCount` (interpreted as the number of repeat visits), the SQL query would be:\n\n```sql\nSELECT Destination, VisitCount\nFROM RepeatTravelers\nORDER BY VisitCount DESC;\n```", "latency_sec": 1.2756099700927734, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 860, "prompt_eval_sec": null, "tokens_completion": 171, "completion_eval_sec": null, "tokens_total": 1031, "tokens_per_sec": 808.2407821922376, "retrieval_latency_sec": 0.13075900077819824, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query filters for visitors with 'USA' in their name (which returns no rows in the sample data) and calculates average visit counts per destination. The generated query returns all rows without filtering or aggregation, ordering by individual visit counts. The WHERE clause and aggregation make them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL attempts to filter for US visitors using a flawed WHERE clause (Visitor LIKE '%USA%') but fails because the sample data contains names like 'David' instead of country codes. It also calculates an average VisitCount per destination, which doesn't directly answer 'highest number of repeat visitors' (which might require counting distinct visitors or total visits). The Generated SQL ignores the US filter entirely and returns raw VisitCount values without aggregation, making it irrelevant to the question. While both queries fail to fulfill the intent, the Reference SQL at least addresses the US filter requirement, albeit incorrectly.", "overall_assessment": "incorrect"}}
{"example_id": 3546, "sql_complexity": "window functions", "prompt": "What are the cryptocurrency exchanges with their corresponding blockchain companies, ranked by exchange ID in ascending order, for the Bitcoin platform?", "context": "CREATE TABLE cryptocurrency_exchanges (exchange_id INT, exchange_name VARCHAR(50), company_id INT); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (1, 'Binance', 1); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (2, 'Coinbase', 2); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (3, 'Kraken', 3); CREATE TABLE blockchain_companies (company_id INT, company_name VARCHAR(50), platform VARCHAR(50)); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (1, 'Binance', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (2, 'Blockstream', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (3, 'Blockchair', 'Bitcoin');", "reference_sql": "SELECT ce.exchange_name, bc.company_name, ce.exchange_id, ROW_NUMBER() OVER (PARTITION BY bc.platform ORDER BY ce.exchange_id ASC) as rank FROM cryptocurrency_exchanges ce JOIN blockchain_companies bc ON ce.company_id = bc.company_id WHERE bc.platform = 'Bitcoin';", "generated_sql": "SELECT ce.exchange_name, bc.company_name, ce.exchange_id \nFROM cryptocurrency_exchanges ce \nJOIN blockchain_companies bc ON ce.company_id = bc.company_id \nWHERE bc.platform = 'Bitcoin' \nORDER BY ce.exchange_id ASC;", "raw_model_output": "\n\nSELECT ce.exchange_name, bc.company_name, ce.exchange_id \nFROM cryptocurrency_exchanges ce \nJOIN blockchain_companies bc ON ce.company_id = bc.company_id \nWHERE bc.platform = 'Bitcoin' \nORDER BY ce.exchange_id ASC;", "latency_sec": 0.4348728656768799, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1038, "prompt_eval_sec": null, "tokens_completion": 53, "completion_eval_sec": null, "tokens_total": 1091, "tokens_per_sec": 2508.7791998745606, "retrieval_latency_sec": 0.14450311660766602, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes an additional 'rank' column generated by the ROW_NUMBER() function, while the Generated SQL omits this column. Although both queries join the same tables and filter on 'Bitcoin', the presence of the extra column in the Reference SQL makes their result sets structurally different. Additionally, the Reference SQL does not include an ORDER BY clause, whereas the Generated SQL explicitly sorts by exchange_id. These differences in output structure and ordering behavior prevent semantic equivalence.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query includes a ROW_NUMBER() ranking column that wasn't explicitly requested in the original question, while the generated query directly addresses the requirements. Both queries correctly join the tables and filter for 'Bitcoin', but the generated query's ORDER BY ce.exchange_id ASC achieves the 'ranked by exchange ID' requirement through simple sorting rather than a window function. The reference query's ranking is technically valid but introduces unnecessary complexity. The generated query is more efficient and directly answers the business question without additional artifacts.", "overall_assessment": "differently_correct"}}
{"example_id": 486, "sql_complexity": "single join", "prompt": "What is the average price of paintings from African artists in our collection?", "context": "CREATE TABLE Artworks (id INT, title VARCHAR(50), price DECIMAL(10,2), medium VARCHAR(50), artist_nationality VARCHAR(50)); CREATE TABLE Collections (id INT, name VARCHAR(50), continent VARCHAR(50));", "reference_sql": "SELECT AVG(Artworks.price) FROM Artworks INNER JOIN Collections ON Artworks.artist_nationality = Collections.continent WHERE Artworks.medium = 'Painting' AND Collections.continent = 'Africa';", "generated_sql": "SELECT AVG(Artworks.price) AS AveragePrice FROM Artworks WHERE Artworks.artist_nationality = 'African';", "raw_model_output": "\n\nSELECT AVG(Artworks.price) AS AveragePrice FROM Artworks WHERE Artworks.artist_nationality = 'African';", "latency_sec": 0.28538990020751953, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 881, "prompt_eval_sec": null, "tokens_completion": 29, "completion_eval_sec": null, "tokens_total": 910, "tokens_per_sec": 3188.6201976254206, "retrieval_latency_sec": 0.129194974899292, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the average price of 'Painting' artworks where the artist's nationality matches the 'Africa' continent via a join, while the Generated SQL averages all artworks with 'African' as the artist's nationality (without medium filter or join). Differences include: 1) Missing 'medium = 'Painting'' filter in Generated SQL, 2) Potential string mismatch ('Africa' vs 'African'), and 3) Absence of the join logic in the Generated SQL.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query incorrectly joins Artworks with Collections on artist_nationality = continent, which misaligns the schema (artist_nationality is a country, not a continent). It also filters for 'Painting' medium but the generated query does not, creating a discrepancy. The generated query directly filters Artworks where artist_nationality = 'African', which may not align with actual data (e.g., if nationalities are country-specific like 'Nigerian'). However, the generated query is simpler and more directly addresses the intent by focusing on the artist_nationality field, while the reference query introduces unnecessary complexity and logical errors. Neither fully fulfills the intent due to schema limitations, but the generated query is more straightforward.", "overall_assessment": "differently_correct"}}
{"example_id": 794, "sql_complexity": "multiple_joins", "prompt": "Which suppliers have provided raw materials for the production of chemicals with high environmental impact?", "context": "CREATE TABLE suppliers (id INT, name TEXT); INSERT INTO suppliers (id, name) VALUES (1, 'Supplier1'), (2, 'Supplier2'), (3, 'Supplier3'); CREATE TABLE chemicals (id INT, name TEXT, environmental_impact INT); INSERT INTO chemicals (id, name, environmental_impact) VALUES (1, 'ChemA', 10), (2, 'ChemB', 20), (3, 'ChemC', 15); CREATE TABLE raw_materials (chemical_id INT, supplier_id INT); INSERT INTO raw_materials (chemical_id, supplier_id) VALUES (1, 1), (1, 2), (2, 3), (3, 1);", "reference_sql": "SELECT s.name FROM suppliers s INNER JOIN raw_materials rm ON s.id = rm.supplier_id INNER JOIN chemicals c ON rm.chemical_id = c.id WHERE c.environmental_impact > 10;", "generated_sql": "SELECT DISTINCT s.name\nFROM suppliers s\nJOIN raw_materials rm ON s.id = rm.supplier_id\nJOIN chemicals c ON rm.chemical_id = c.id\nWHERE c.environmental_impact > 15;", "raw_model_output": "\n\nSELECT DISTINCT s.name\nFROM suppliers s\nJOIN raw_materials rm ON s.id = rm.supplier_id\nJOIN chemicals c ON rm.chemical_id = c.id\nWHERE c.environmental_impact > 15;", "latency_sec": 0.5153567790985107, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 924, "prompt_eval_sec": null, "tokens_completion": 51, "completion_eval_sec": null, "tokens_total": 975, "tokens_per_sec": 1891.8932272619397, "retrieval_latency_sec": 0.11456775665283203, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their WHERE conditions (10 vs 15) and use of DISTINCT. The Reference SQL filters chemicals with environmental_impact > 10 (including 15), while the Generated SQL filters >15 (excluding 15). This results in different sets of chemicals being considered, leading to different supplier names in the output.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent due to differing WHERE conditions (10 vs 15) and the use of DISTINCT in the generated query. The reference query uses a lower threshold (environmental_impact > 10), which includes chemicals with environmental impact values of 15 (ChemC) and 20 (ChemB), while the generated query uses a higher threshold (15), excluding ChemC. This results in different supplier sets: reference returns suppliers for ChemB (Supplier3) and ChemC (Supplier1), while generated only returns Supplier3. The original question lacks a defined threshold for 'high environmental impact,' but the reference's lower threshold better aligns with a broader interpretation of 'high' impact. The generated query's stricter condition may not fully capture the intended business intent. The reference query also avoids unnecessary DISTINCT, making it more efficient.", "overall_assessment": "differently_correct"}}
{"example_id": 3164, "sql_complexity": "set operations", "prompt": "What is the average age of patients who received therapy in 'clinic_a' and 'clinic_b'?", "context": "CREATE TABLE clinic_a (patient_id INT, age INT, therapy_received BOOLEAN); INSERT INTO clinic_a (patient_id, age, therapy_received) VALUES (1, 35, true), (2, 42, true), (3, 28, false); CREATE TABLE clinic_b (patient_id INT, age INT, therapy_received BOOLEAN); INSERT INTO clinic_b (patient_id, age, therapy_received) VALUES (4, 50, true), (5, 32, false), (6, 45, true);", "reference_sql": "SELECT AVG(age) FROM (SELECT age FROM clinic_a WHERE therapy_received = true UNION ALL SELECT age FROM clinic_b WHERE therapy_received = true) AS combined_clinics;", "generated_sql": "SELECT AVG(clinic_a.age) + AVG(clinic_b.age) / 2 \nFROM clinic_a \nJOIN clinic_b \nON clinic_a.patient_id = clinic_b.patient_id \nWHERE clinic_a.therapy_received = true AND clinic_b.therapy_received = true;", "raw_model_output": "\n\nSELECT AVG(clinic_a.age) + AVG(clinic_b.age) / 2 \nFROM clinic_a \nJOIN clinic_b \nON clinic_a.patient_id = clinic_b.patient_id \nWHERE clinic_a.therapy_received = true AND clinic_b.therapy_received = true;", "latency_sec": 0.4619882106781006, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 760, "prompt_eval_sec": null, "tokens_completion": 59, "completion_eval_sec": null, "tokens_total": 819, "tokens_per_sec": 1772.772510358829, "retrieval_latency_sec": 0.13367009162902832, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query calculates the average age of all patients who received therapy from both clinics combined. The generated query attempts to join clinic_a and clinic_b on patient_id (which has no matching rows) and incorrectly computes (AVG(clinic_a.age) + AVG(clinic_b.age)/2). This would return NULL due to no matching rows in the join, and even if there were matches, the formula is mathematically different from a combined average.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly combines all therapy-receiving patients from both clinics using UNION ALL and calculates the true average age. The Generated SQL incorrectly uses a JOIN between clinics (which would return no rows due to mismatched patient_ids) and improperly averages ages by adding and dividing by 2, which mathematically distorts the result. The Reference properly addresses the business intent of aggregating patients across both clinics, while the Generated query fails due to flawed logic and incorrect table relationships.", "overall_assessment": "incorrect"}}
{"example_id": 3704, "sql_complexity": "aggregation", "prompt": "What is the total sales revenue for each category of garments in the South America region in Q1 2022?", "context": "CREATE TABLE sales_category (sale_id INT, garment_category VARCHAR(50), sale_date DATE, total_sales DECIMAL(10, 2), region VARCHAR(50));", "reference_sql": "SELECT garment_category, SUM(total_sales) FROM sales_category WHERE sale_date BETWEEN '2022-01-01' AND '2022-03-31' AND region = 'South America' GROUP BY garment_category;", "generated_sql": "SELECT garment_category, SUM(total_sales) \nFROM sales_category \nWHERE sale_date BETWEEN '2022-01-01' AND '2022-03-31' \n  AND region = 'South America' \nGROUP BY garment_category;", "raw_model_output": "\n\nSELECT garment_category, SUM(total_sales) \nFROM sales_category \nWHERE sale_date BETWEEN '2022-01-01' AND '2022-03-31' \n  AND region = 'South America' \nGROUP BY garment_category;", "latency_sec": 0.5844860076904297, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 841, "prompt_eval_sec": null, "tokens_completion": 62, "completion_eval_sec": null, "tokens_total": 903, "tokens_per_sec": 1544.9471640359093, "retrieval_latency_sec": 0.1230018138885498, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select garment_category and sum of total_sales from sales_category, apply the same date range filter (BETWEEN '2022-01-01' AND '2022-03-31'), same region condition (region = 'South America'), and group by garment_category. The only difference is formatting/whitepace, which does not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are syntactically and semantically identical. They both select garment categories and sum total_sales from the sales_category table, filtering for South America region and Q1 2022 dates (January 1 to March 31). The GROUP BY clause is correctly applied to garment_category. The only difference is formatting (line breaks/whitespace), which doesn't affect functionality. Both queries perfectly address the business question by calculating category-specific sales revenue for the specified region and time period.", "overall_assessment": "correct"}}
{"example_id": 2851, "sql_complexity": "single join", "prompt": "How many cases were handled by attorneys who joined the firm in 2015 or later?", "context": "CREATE TABLE attorneys (attorney_id INT, join_year INT); CREATE TABLE cases (case_id INT, attorney_id INT, billing_amount INT);", "reference_sql": "SELECT COUNT(DISTINCT cases.case_id) FROM cases INNER JOIN attorneys ON cases.attorney_id = attorneys.attorney_id WHERE attorneys.join_year >= 2015;", "generated_sql": "SELECT COUNT(cases.case_id) \nFROM cases \nINNER JOIN attorneys ON cases.attorney_id = attorneys.attorney_id \nWHERE attorneys.join_year >= 2015;", "raw_model_output": "\n\nSELECT COUNT(cases.case_id) \nFROM cases \nINNER JOIN attorneys ON cases.attorney_id = attorneys.attorney_id \nWHERE attorneys.join_year >= 2015;", "latency_sec": 0.356309175491333, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 913, "prompt_eval_sec": null, "tokens_completion": 41, "completion_eval_sec": null, "tokens_total": 954, "tokens_per_sec": 2677.4499946134715, "retrieval_latency_sec": 0.11536812782287598, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of cases linked to attorneys who joined in 2015 or later. Since case_id is a primary key (implied by typical schema design), COUNT(cases.case_id) and COUNT(DISTINCT cases.case_id) will yield the same result. The DISTINCT keyword is redundant here but does not affect the outcome.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in their use of COUNT(DISTINCT) vs. COUNT. The reference query correctly ensures each case is counted only once (even if multiple attorneys handled it), while the generated query may overcount cases with multiple qualifying attorneys. Both queries correctly join tables and filter by join_year >= 2015, but the reference better addresses the business intent of counting unique cases. The generated query fails to handle potential duplicate case_id entries from multi-attorney cases.", "overall_assessment": "differently_correct"}}
{"example_id": 3246, "sql_complexity": "single join", "prompt": "What is the average eco-friendliness score of accommodations in Oceania by year?", "context": "CREATE TABLE Accommodations (Accommodation_ID INT, Accommodation_Name VARCHAR(50), City VARCHAR(30), Country VARCHAR(50), Eco_Friendliness_Score INT, Visit_Year INT); INSERT INTO Accommodations (Accommodation_ID, Accommodation_Name, City, Country, Eco_Friendliness_Score, Visit_Year) VALUES (1, 'EcoLodge', 'Sydney', 'Australia', 85, 2019), (2, 'GreenHotel', 'Melbourne', 'Australia', 90, 2019), (3, 'SustainableResort', 'Auckland', 'New Zealand', 80, 2019), (4, 'EcoVilla', 'Wellington', 'New Zealand', 88, 2019); CREATE TABLE Countries (Country VARCHAR(50), Continent VARCHAR(30)); INSERT INTO Countries (Country, Continent) VALUES ('Australia', 'Oceania'), ('New Zealand', 'Oceania');", "reference_sql": "SELECT C.Continent, V.Visit_Year, AVG(A.Eco_Friendliness_Score) AS Avg_Eco_Score  FROM Accommodations A  JOIN Countries C  ON A.Country = C.Country  WHERE C.Continent = 'Oceania'  GROUP BY C.Continent, V.Visit_Year  ORDER BY V.Visit_Year;", "generated_sql": "SELECT AVG(Accommodations.Eco_Friendliness_Score), Accommodations.Visit_Year\nFROM Accommodations\nINNER JOIN Countries ON Accommodations.Country = Countries.Country\nWHERE Countries.Continent = 'Oceania'\nGROUP BY Accommodations.Visit_Year;", "raw_model_output": "\n\n```sql\nSELECT AVG(Accommodations.Eco_Friendliness_Score), Accommodations.Visit_Year\nFROM Accommodations\nINNER JOIN Countries ON Accommodations.Country = Countries.Country\nWHERE Countries.Continent = 'Oceania'\nGROUP BY Accommodations.Visit_Year;\n```", "latency_sec": 0.6332781314849854, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 989, "prompt_eval_sec": null, "tokens_completion": 69, "completion_eval_sec": null, "tokens_total": 1058, "tokens_per_sec": 1670.6719329137052, "retrieval_latency_sec": 0.11244630813598633, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL includes 'Continent' in the SELECT and GROUP BY clauses, while the Generated SQL omits it. Although the WHERE clause filters for 'Oceania', the GROUP BY in the Generated SQL only groups by 'Visit_Year', which could lead to incorrect aggregation if multiple continents were present. Additionally, the SELECT list differs in column count and names.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query contains a syntax error: it references 'V.Visit_Year' in the GROUP BY clause, but 'V' is not defined as a table alias anywhere in the query. The generated query correctly uses 'Accommodations.Visit_Year' without unnecessary columns. Both queries calculate the average eco-friendliness score by year for Oceania, but the generated query is syntactically correct and more concise. The reference query's inclusion of 'Continent' in the output is redundant since the WHERE clause already filters to Oceania, making it less elegant. The generated query better fulfills the business intent by producing valid results without extraneous data.", "overall_assessment": "incorrect"}}
{"example_id": 3056, "sql_complexity": "multiple_joins", "prompt": "Identify all suppliers who provide non-GMO ingredients to restaurants with Michelin stars.", "context": "CREATE TABLE Suppliers (id INT, name VARCHAR(50), isNonGMO BOOLEAN); CREATE TABLE Restaurants (id INT, name VARCHAR(50), numStars INT); CREATE TABLE Ingredients (supplierId INT, restaurantId INT, isNonGMO BOOLEAN);", "reference_sql": "SELECT Suppliers.name FROM Suppliers INNER JOIN Ingredients ON Suppliers.id = Ingredients.supplierId INNER JOIN Restaurants ON Ingredients.restaurantId = Restaurants.id WHERE Restaurants.numStars > 2 AND Ingredients.isNonGMO = TRUE;", "generated_sql": "SELECT DISTINCT s.id, s.name\nFROM Suppliers s\nJOIN Ingredients i ON s.id = i.supplierId\nJOIN Restaurants r ON i.restaurantId = r.id\nWHERE i.isNonGMO = TRUE AND r.numStars > 0;", "raw_model_output": "\n\nTo identify all suppliers who provide non-GMO ingredients to restaurants with Michelin stars, we need to:\n\n1. Join the `Suppliers`, `Ingredients`, and `Restaurants` tables.\n2. Filter for ingredients that are non-GMO (`isNonGMO = TRUE`).\n3. Filter for restaurants that have Michelin stars (`numStars > 0`).\n4. Select distinct suppliers to avoid duplicates.\n\nHere is the SQL query:\n\n```sql\nSELECT DISTINCT s.id, s.name\nFROM Suppliers s\nJOIN Ingredients i ON s.id = i.supplierId\nJOIN Restaurants r ON i.restaurantId = r.id\nWHERE i.isNonGMO = TRUE AND r.numStars > 0;\n```", "latency_sec": 1.0453462600708008, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 797, "prompt_eval_sec": null, "tokens_completion": 151, "completion_eval_sec": null, "tokens_total": 948, "tokens_per_sec": 906.8765405405405, "retrieval_latency_sec": 0.14000988006591797, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in three key aspects: 1) The Reference query selects only 'Suppliers.name' while the Generated query selects 's.id' and 's.name' (different column sets). 2) The WHERE clause conditions differ (Restaurants.numStars > 2 vs numStars > 0). 3) The Generated query uses DISTINCT which could eliminate duplicates not present in the Reference query. These differences ensure they do not produce identical results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in two critical aspects. 1) The Reference SQL uses 'numStars > 2' which only includes 3-star restaurants, while the Generated SQL uses 'numStars > 0' which includes all restaurants with any Michelin stars (1, 2, or 3). 2) The Generated SQL includes 'DISTINCT' to avoid duplicate supplier entries, which is more appropriate for the question's requirement to 'identify all suppliers'. While both queries correctly join the tables and filter for non-GMO ingredients, the Generated SQL better fulfills the business intent by including all Michelin-starred restaurants and avoiding duplicate results.", "overall_assessment": "differently_correct"}}
{"example_id": 264, "sql_complexity": "set operations", "prompt": "List the number of community health centers and infectious disease tracking facilities in 'southwest' regions.", "context": "CREATE TABLE centers (id INT, name TEXT, region TEXT); INSERT INTO centers (id, name, region) VALUES (1, 'Center A', 'southwest'); INSERT INTO centers (id, name, region) VALUES (2, 'Center B', 'northeast'); INSERT INTO centers (id, name, region) VALUES (3, 'Center C', 'northwest'); CREATE TABLE diseases (id INT, name TEXT, region TEXT); INSERT INTO diseases (id, name, region) VALUES (1, 'Disease A', 'southwest'); INSERT INTO diseases (id, name, region) VALUES (2, 'Disease B', 'southeast');", "reference_sql": "SELECT COUNT(*) FROM ( (SELECT * FROM centers WHERE region = 'southwest') UNION (SELECT * FROM diseases WHERE region = 'southwest') );", "generated_sql": "SELECT 'Community Health Centers', COUNT(*) FROM centers WHERE region = 'southwest' UNION SELECT 'Infectious Disease Tracking Facilities', COUNT(*) FROM diseases WHERE region = 'southwest';", "raw_model_output": "\n\nSQL: SELECT 'Community Health Centers', COUNT(*) FROM centers WHERE region = 'southwest' UNION SELECT 'Infectious Disease Tracking Facilities', COUNT(*) FROM diseases WHERE region = 'southwest';", "latency_sec": 0.3896908760070801, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 921, "prompt_eval_sec": null, "tokens_completion": 45, "completion_eval_sec": null, "tokens_total": 966, "tokens_per_sec": 2478.8879069943873, "retrieval_latency_sec": 0.12173795700073242, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL counts all unique rows from both tables where region = 'southwest' as a single value, while the Generated SQL returns two separate rows with labels and counts for each table. The structure and output format differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL combines rows from both tables using UNION and counts them as a single value, which would return a total count of all records (centers + diseases) in the 'southwest' region. This fails to distinguish between the two facility types as required by the question. The Generated SQL correctly separates the counts into two distinct rows with explicit labels, matching the business requirement for dual metrics. While both queries are syntactically valid, only the Generated SQL addresses the dual-count requirement. The Reference SQL's approach would incorrectly aggregate data rather than providing separate counts.", "overall_assessment": "differently_correct"}}
{"example_id": 2838, "sql_complexity": "basic SQL", "prompt": "What is the minimum safety rating of electric vehicles in the 'green_cars' table?", "context": "CREATE TABLE green_cars (id INT, make VARCHAR(50), model VARCHAR(50), type VARCHAR(50), safety_rating INT);", "reference_sql": "SELECT MIN(safety_rating) FROM green_cars WHERE type = 'Electric';", "generated_sql": "SELECT MIN(safety_rating) FROM green_cars WHERE type = 'electric';", "raw_model_output": "\n\nSELECT MIN(safety_rating) FROM green_cars WHERE type = 'electric';", "latency_sec": 0.22153615951538086, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 608, "prompt_eval_sec": null, "tokens_completion": 21, "completion_eval_sec": null, "tokens_total": 629, "tokens_per_sec": 2839.265614137044, "retrieval_latency_sec": 0.1203298568725586, "match_exact": true, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the case of the string literal ('Electric' vs 'electric'). While some databases may handle case-insensitive comparisons, SQL is generally case-sensitive for string literals unless explicitly configured otherwise. This could lead to different results if the 'type' column values are stored with specific casing.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in the WHERE clause condition: 'Electric' (capitalized) vs 'electric' (lowercase). While both would return the minimum safety rating for electric vehicles in case-insensitive databases, the reference query uses the exact casing expected in the data (assuming 'Electric' is the stored value). The generated query might fail to match records if the database is case-sensitive, leading to incorrect results. Both queries technically fulfill the intent if the database is case-insensitive, but the reference query is more likely to be correct in a real-world scenario where 'Electric' would be stored with proper capitalization.", "overall_assessment": "differently_correct"}}
{"example_id": 1187, "sql_complexity": "multiple_joins", "prompt": "Who are the top 3 authors with the highest number of articles published in The Guardian?", "context": "CREATE TABLE authors (id INT, name VARCHAR(100), publisher VARCHAR(50)); CREATE TABLE articles_authors (article_id INT, author_id INT); INSERT INTO authors (id, name, publisher) VALUES (1, 'Author1', 'The Guardian'), (2, 'Author2', 'The Guardian'), (3, 'Author3', 'The Guardian'); INSERT INTO articles_authors (article_id, author_id) VALUES (1, 1), (2, 2), (3, 1), (3, 2), (3, 3); INSERT INTO articles (id, title, publication_date, publisher) VALUES (1, 'Article1', '2021-01-01', 'The Guardian'), (2, 'Article2', '2021-01-02', 'The Guardian'), (3, 'Article3', '2021-01-03', 'The Guardian');", "reference_sql": "SELECT a.name, COUNT(aa.article_id) AS articles_count FROM authors a JOIN articles_authors aa ON a.id = aa.author_id JOIN articles ar ON aa.article_id = ar.id WHERE ar.publisher = 'The Guardian' GROUP BY a.name ORDER BY articles_count DESC LIMIT 3;", "generated_sql": "SELECT a.name, COUNT(*) AS article_count\nFROM authors a\nJOIN articles_authors aa ON a.id = aa.author_id\nJOIN articles ar ON aa.article_id = ar.id\nWHERE ar.publisher = 'The Guardian'\nGROUP BY a.id, a.name\nORDER BY article_count DESC\nLIMIT 3;", "raw_model_output": "\n\nSELECT a.name, COUNT(*) AS article_count\nFROM authors a\nJOIN articles_authors aa ON a.id = aa.author_id\nJOIN articles ar ON aa.article_id = ar.id\nWHERE ar.publisher = 'The Guardian'\nGROUP BY a.id, a.name\nORDER BY article_count DESC\nLIMIT 3;", "latency_sec": 0.631206750869751, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1085, "prompt_eval_sec": null, "tokens_completion": 69, "completion_eval_sec": null, "tokens_total": 1154, "tokens_per_sec": 1828.24407123321, "retrieval_latency_sec": 0.12017512321472168, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their GROUP BY clauses. The Reference SQL groups by 'a.name' alone, which could combine authors with the same name but different IDs. The Generated SQL groups by both 'a.id' and 'a.name', ensuring each author is uniquely identified. This difference may lead to different results if there are authors with non-unique names, making the queries semantically inequivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify the top 3 authors by article count in The Guardian. The reference query groups by a.name, which works if names are unique. The generated query groups by a.id and a.name, which is more robust for databases where names might not be unique. Both use identical JOIN logic, filters, and ordering. The generated query's GROUP BY clause is technically superior as it avoids potential grouping issues with non-unique names while maintaining semantic equivalence. The COUNT(*) in the generated query is functionally equivalent to COUNT(aa.article_id) in the reference.", "overall_assessment": "correct"}}
{"example_id": 360, "sql_complexity": "window functions", "prompt": "What is the change in crime rate for each category, between this year and last year, for the same time period?", "context": "CREATE TABLE CrimeStatistics (ID INT, CrimeType VARCHAR(50), Date TIMESTAMP, Count INT); INSERT INTO CrimeStatistics (ID, CrimeType, Date, Count) VALUES (1, 'Theft', '2022-01-01 00:00:00', 100), (2, 'Vandalism', '2022-01-01 00:00:00', 50), (3, 'Theft', '2022-01-02 00:00:00', 120), (4, 'Vandalism', '2022-01-02 00:00:00', 60), (5, 'Theft', '2021-01-01 00:00:00', 80), (6, 'Vandalism', '2021-01-01 00:00:00', 40), (7, 'Theft', '2021-01-02 00:00:00', 90), (8, 'Vandalism', '2021-01-02 00:00:00', 45);", "reference_sql": "SELECT CrimeType, (SUM(Count) OVER (PARTITION BY CrimeType ORDER BY EXTRACT(YEAR FROM Date) ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)) - SUM(Count) OVER (PARTITION BY CrimeType ORDER BY EXTRACT(YEAR FROM Date)) AS CrimeRateChange FROM CrimeStatistics WHERE Date BETWEEN DATE_TRUNC('year', CURRENT_DATE - INTERVAL '1 year') AND CURRENT_DATE;", "generated_sql": "SELECT \n    cs1.CrimeType, \n    COALESCE(cs1.Count, 0) - COALESCE(cs2.Count, 0) AS ChangeInCrimeRate\nFROM \n    (SELECT CrimeType, SUM(Count) AS Count FROM CrimeStatistics WHERE Date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR) GROUP BY CrimeType) cs1\nFULL OUTER JOIN \n    (SELECT CrimeType, SUM(Count) AS Count FROM CrimeStatistics WHERE Date < DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR) GROUP BY CrimeType) cs2\nON \n    cs1.CrimeType = cs2.CrimeType;", "raw_model_output": "\n\n```sql\nSELECT \n    cs1.CrimeType, \n    COALESCE(cs1.Count, 0) - COALESCE(cs2.Count, 0) AS ChangeInCrimeRate\nFROM \n    (SELECT CrimeType, SUM(Count) AS Count FROM CrimeStatistics WHERE Date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR) GROUP BY CrimeType) cs1\nFULL OUTER JOIN \n    (SELECT CrimeType, SUM(Count) AS Count FROM CrimeStatistics WHERE Date < DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR) GROUP BY CrimeType) cs2\nON \n    cs1.CrimeType = cs2.CrimeType;\n```", "latency_sec": 1.0931410789489746, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 988, "prompt_eval_sec": null, "tokens_completion": 142, "completion_eval_sec": null, "tokens_total": 1130, "tokens_per_sec": 1033.7183569082083, "retrieval_latency_sec": 0.10816812515258789, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL uses window functions to calculate a difference between a single preceding row's sum and the cumulative sum, which does not correctly represent year-over-year changes. The Generated SQL properly computes the difference between aggregated sums for the last year and the year before using explicit grouping and a FULL OUTER JOIN. The Reference SQL's window function logic is flawed for this purpose, leading to incorrect results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference SQL uses window functions with incorrect ordering logic (EXTRACT(YEAR) without proper grouping) and may not correctly isolate year-over-year comparisons. The generated SQL uses a more straightforward approach with FULL OUTER JOIN and explicit date filtering, but its date conditions (DATE_SUB) may not align with the 'same time period' requirement. Neither query perfectly captures the same time period between years, but the generated SQL better addresses the business intent by explicitly comparing aggregated totals for distinct timeframes. The reference SQL's window function logic is flawed for this specific question.", "overall_assessment": "differently_correct"}}
{"example_id": 335, "sql_complexity": "single join", "prompt": "List the policy numbers, claim amounts, and claim dates for policies that have more than two claims and the total claim amount exceeds $5000", "context": "CREATE TABLE policies (policy_number INT);CREATE TABLE claims (claim_id INT, policy_number INT, claim_amount DECIMAL(10,2), claim_date DATE);", "reference_sql": "SELECT p.policy_number, c.claim_amount, c.claim_date FROM policies p INNER JOIN claims c ON p.policy_number = c.policy_number GROUP BY p.policy_number, c.claim_amount, c.claim_date HAVING COUNT(c.claim_id) > 2 AND SUM(c.claim_amount) > 5000;", "generated_sql": "SELECT p.policy_number, c.claim_amount, c.claim_date\nFROM policies p\nJOIN claims c ON p.policy_number = c.policy_number\nGROUP BY p.policy_number, c.claim_amount, c.claim_date\nHAVING COUNT(c.claim_id) > 2 AND SUM(c.claim_amount) > 5000;", "raw_model_output": "\n\n```sql\nSELECT p.policy_number, c.claim_amount, c.claim_date\nFROM policies p\nJOIN claims c ON p.policy_number = c.policy_number\nGROUP BY p.policy_number, c.claim_amount, c.claim_date\nHAVING COUNT(c.claim_id) > 2 AND SUM(c.claim_amount) > 5000;\n```", "latency_sec": 0.7049551010131836, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1097, "prompt_eval_sec": null, "tokens_completion": 81, "completion_eval_sec": null, "tokens_total": 1178, "tokens_per_sec": 1671.0284077765257, "retrieval_latency_sec": 0.1083059310913086, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The two queries are semantically equivalent. The only difference is the explicit use of 'INNER' in the Reference SQL versus the implicit INNER JOIN in the Generated SQL. Both queries perform the same inner join between 'policies' and 'claims', apply identical grouping on policy_number, claim_amount, and claim_date, and use the same HAVING clause conditions (COUNT(claim_id) > 2 and SUM(claim_amount) > 5000). The result set will be identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": false, "superiority": "equal", "explanation": "The queries are technically equivalent as they differ only in the JOIN syntax (INNER JOIN vs. JOIN) which are functionally identical. However, neither query correctly fulfills the business intent. The GROUP BY clause groups by individual claim details (policy_number, claim_amount, claim_date) rather than aggregating at the policy level. This causes the HAVING clause to evaluate per-claim groups instead of policy-wide totals. The correct approach would group by policy_number only, then calculate COUNT(*) and SUM(claim_amount) for each policy before filtering.", "overall_assessment": "incorrect"}}
{"example_id": 2866, "sql_complexity": "basic SQL", "prompt": "What is the number of hospitals in 'rural_healthcare' table?", "context": "CREATE TABLE rural_healthcare (name VARCHAR(255), type VARCHAR(255), location VARCHAR(255)); INSERT INTO rural_healthcare (name, type, location) VALUES ('Rural General Hospital', 'Hospital', 'Bushland'), ('Rural Community Hospital', 'Hospital', 'Forest Region');", "reference_sql": "SELECT COUNT(*) FROM rural_healthcare WHERE type = 'Hospital';", "generated_sql": "SELECT COUNT(*) FROM rural_healthcare;", "raw_model_output": "\n\nSELECT COUNT(*) FROM rural_healthcare;", "latency_sec": 0.17495989799499512, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 592, "prompt_eval_sec": null, "tokens_completion": 13, "completion_eval_sec": null, "tokens_total": 605, "tokens_per_sec": 3457.935257925828, "retrieval_latency_sec": 0.11085796356201172, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "In the provided context, the rural_healthcare table contains only 'Hospital' entries (as per the INSERT statements). Both queries count all rows, which in this case equals the count of 'Hospital' entries. However, this equivalence is data-dependent and not structural.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly filters for 'Hospital' type entries, while the generated query counts all rows. The original question specifically asks for hospitals, making the WHERE clause essential. The generated query would include non-hospital records (if any) and thus would not accurately answer the question. Although both queries are syntactically correct, they differ semantically and in business intent fulfillment.", "overall_assessment": "incorrect"}}
{"example_id": 4440, "sql_complexity": "multiple_joins", "prompt": "What is the average session length for each game genre in the last month, sorted by average session length.", "context": "CREATE TABLE game_sessions(id INT, user_id INT, game_name VARCHAR(50), start_time DATETIME, end_time DATETIME); CREATE TABLE games(id INT, name VARCHAR(50), genre VARCHAR(50));", "reference_sql": "SELECT genres.genre, AVG(TIMESTAMPDIFF(SECOND, start_time, end_time)) as avg_session_length FROM game_sessions JOIN games ON game_sessions.game_name = games.name JOIN (SELECT DISTINCT game_name, genre FROM game_sessions JOIN games ON game_sessions.game_name = games.name) genres ON games.name = genres.game_name WHERE start_time >= DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH) GROUP BY genres.genre ORDER BY avg_session_length DESC;", "generated_sql": "SELECT g.genre, AVG(TIMESTAMPDIFF(SECOND, gs.start_time, gs.end_time)) AS avg_session_length\nFROM game_sessions gs\nJOIN games g ON gs.game_name = g.name\nWHERE gs.start_time >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH)\nGROUP BY g.genre\nORDER BY avg_session_length DESC;", "raw_model_output": "\n\n```sql\nSELECT g.genre, AVG(TIMESTAMPDIFF(SECOND, gs.start_time, gs.end_time)) AS avg_session_length\nFROM game_sessions gs\nJOIN games g ON gs.game_name = g.name\nWHERE gs.start_time >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH)\nGROUP BY g.genre\nORDER BY avg_session_length DESC;\n```", "latency_sec": 0.5753600597381592, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 783, "prompt_eval_sec": null, "tokens_completion": 77, "completion_eval_sec": null, "tokens_total": 860, "tokens_per_sec": 1494.7161963091037, "retrieval_latency_sec": 0.11013197898864746, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a subquery that selects distinct (game_name, genre) pairs from a join between game_sessions and games, then joins this with the original tables. This could lead to different results if there are multiple genres for the same game_name in the games table. The Generated SQL directly joins game_sessions and games without this subquery, which may produce different aggregation results when there are duplicate game_name/genre relationships. Additionally, the Reference SQL's join condition on the subquery may introduce unnecessary complexity that alters the dataset being aggregated.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate average session length per genre for the last month. The reference query includes an unnecessary subquery with DISTINCT that doesn't add value, while the generated query simplifies the logic with direct joins and aliases. The generated version is more efficient by avoiding redundant joins and subqueries, and uses clearer aliases (gs/g) without changing the semantic meaning. Both handle date filtering correctly with DATE_SUB/CURDATE equivalence.", "overall_assessment": "correct"}}
{"example_id": 451, "sql_complexity": "single join", "prompt": "Which customers have made a transaction over 500 in the \"risk_management\" category?", "context": "CREATE TABLE customers (id INT, name VARCHAR(50), category VARCHAR(50)); INSERT INTO customers (id, name, category) VALUES (1, 'John Doe', 'risk_management'); INSERT INTO customers (id, name, category) VALUES (2, 'Jane Smith', 'compliance'); INSERT INTO customers (id, name, category) VALUES (3, 'Jim Brown', 'risk_management'); CREATE TABLE transactions (id INT, customer_id INT, amount DECIMAL(10, 2)); INSERT INTO transactions (id, customer_id, amount) VALUES (1, 1, 500.00); INSERT INTO transactions (id, customer_id, amount) VALUES (2, 1, 200.00); INSERT INTO transactions (id, customer_id, amount) VALUES (3, 2, 100.00); INSERT INTO transactions (id, customer_id, amount) VALUES (4, 3, 750.00);", "reference_sql": "SELECT c.name FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE c.category = 'risk_management' AND t.amount > 500;", "generated_sql": "SELECT c.name FROM customers c JOIN transactions t ON c.id = t.customer_id WHERE c.category = 'risk_management' AND t.amount > 500;", "raw_model_output": "\n\nSELECT c.name FROM customers c JOIN transactions t ON c.id = t.customer_id WHERE c.category = 'risk_management' AND t.amount > 500;", "latency_sec": 0.45627331733703613, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1298, "prompt_eval_sec": null, "tokens_completion": 38, "completion_eval_sec": null, "tokens_total": 1336, "tokens_per_sec": 2928.069534719548, "retrieval_latency_sec": 0.09062075614929199, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between customers and transactions tables with the same conditions. The only difference is the explicit 'INNER' keyword in the Reference SQL versus the implicit INNER JOIN in the Generated SQL, which are semantically equivalent in SQL syntax.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent as they produce identical results. The only difference is syntactic: 'INNER JOIN' vs 'JOIN' (which is shorthand for INNER JOIN in most SQL dialects). Both correctly filter customers in the 'risk_management' category with transactions exceeding 500. The business intent is fully addressed by both queries, as they retrieve the same customer names. The generated query is slightly more concise but offers no functional advantage over the reference. Neither query is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 2879, "sql_complexity": "basic SQL", "prompt": "Update the FoodSafetyRecords.OrganicFarms table to include a new record for a certified organic farm in Kenya.", "context": "CREATE TABLE FoodSafetyRecords.OrganicFarms (farmName TEXT, country TEXT, certified BOOLEAN);", "reference_sql": "INSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('Ngong Organic Farm', 'Kenya', TRUE);", "generated_sql": "INSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('New Organic Farm', 'Kenya', TRUE);", "raw_model_output": "\n\nINSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('New Organic Farm', 'Kenya', TRUE);", "latency_sec": 0.41784000396728516, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 582, "prompt_eval_sec": null, "tokens_completion": 35, "completion_eval_sec": null, "tokens_total": 617, "tokens_per_sec": 1476.641762736313, "retrieval_latency_sec": 0.10129094123840332, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The two queries differ in the farmName value inserted ('Ngong Organic Farm' vs 'New Organic Farm'). While the structure and other values are identical, the distinct farm names result in different data being inserted, making them semantically non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "equal", "explanation": "The queries differ in the farm name value ('Ngong Organic Farm' vs 'New Organic Farm'), making them technically non-equivalent. Both correctly fulfill the business intent of adding a certified organic farm record in Kenya. The reference query uses a specific example name, while the generated query uses a generic placeholder. Neither is more efficient or elegant than the other, as both are simple INSERT statements with identical structure. The difference in farm names does not affect the correctness of the operation, as the original question did not specify a particular farm name.", "overall_assessment": "differently_correct"}}
{"example_id": 5688, "sql_complexity": "single join", "prompt": "What is the total amount donated to a specific cause?", "context": "CREATE TABLE causes (id INT, name TEXT); CREATE TABLE donations (id INT, donor_id INT, cause_id INT, donation_amount DECIMAL(10,2)); INSERT INTO causes (id, name) VALUES (1, 'Cause A'), (2, 'Cause B'); INSERT INTO donations (id, donor_id, cause_id, donation_amount) VALUES (1, 1, 1, 50.00), (2, 2, 1, 100.00);", "reference_sql": "SELECT SUM(donation_amount) FROM donations JOIN causes ON donations.cause_id = causes.id WHERE causes.name = 'Cause A';", "generated_sql": "SELECT SUM(donation_amount) AS total_donation_amount FROM donations WHERE cause_id = ?;", "raw_model_output": "\n\nSELECT SUM(donation_amount) AS total_donation_amount FROM donations WHERE cause_id = ?;", "latency_sec": 0.24793291091918945, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 955, "prompt_eval_sec": null, "tokens_completion": 24, "completion_eval_sec": null, "tokens_total": 979, "tokens_per_sec": 3948.6488355678302, "retrieval_latency_sec": 0.10557198524475098, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The Reference SQL calculates the sum of donations for 'Cause A' by joining the donations table with the causes table on cause_id and filtering by the cause name. The Generated SQL directly filters donations by cause_id, which in the given data corresponds to the id of 'Cause A' (id=1). Since the cause_id in the donations table is a foreign key to the causes table, both queries effectively sum the same donations when the parameter in the Generated SQL is set to 1.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries calculate the total donations for a specific cause, but they differ in approach. The reference query explicitly joins the causes table to filter by cause name ('Cause A'), directly aligning with the business intent of identifying donations by cause name. The generated query uses a parameterized cause_id, which is technically valid but assumes prior knowledge of the cause's ID rather than its name. While both would produce equivalent results if the parameter is correctly set, the reference query better fulfills the business intent by using the human-readable cause name. The reference is more explicit and self-contained, whereas the generated query relies on external context for the parameter value. Both are syntactically correct, but the reference is more aligned with the original question's phrasing.", "overall_assessment": "correct"}}
{"example_id": 3273, "sql_complexity": "multiple_joins", "prompt": "List all departments, the number of chemicals they handle, and the number of machines used in their manufacturing processes.", "context": "CREATE TABLE Departments (DepartmentID INT, DepartmentName VARCHAR(20)); INSERT INTO Departments (DepartmentID, DepartmentName) VALUES (1, 'Manufacturing'), (2, 'Engineering'), (3, 'Chemical Safety'), (4, 'Product Development'); CREATE TABLE Chemicals (ChemicalID INT, ChemicalName VARCHAR(20), DepartmentID INT); INSERT INTO Chemicals (ChemicalID, ChemicalName, DepartmentID) VALUES (1, 'Hydrochloric Acid', 1), (2, 'Nitric Acid', 2), (3, 'Sodium Hydroxide', 3), (4, 'New Chemical', 4); CREATE TABLE Machinery (MachineID INT, MachineName VARCHAR(20), DepartmentID INT); INSERT INTO Machinery (MachineID, MachineName, DepartmentID) VALUES (1, 'Mixer 1', 1), (2, 'Cutter 2', 2), (3, 'Dispenser 3', 3), (4, 'Innovator 4', 4);", "reference_sql": "SELECT D.DepartmentName, COUNT(C.ChemicalID) AS ChemicalCount, COUNT(M.MachineID) AS MachineCount FROM Departments D LEFT JOIN Chemicals C ON D.DepartmentID = C.DepartmentID LEFT JOIN Machinery M ON D.DepartmentID = M.DepartmentID GROUP BY D.DepartmentName;", "generated_sql": "SELECT d.DepartmentName, COUNT(c.ChemicalID) AS NumberOfChemicals, COUNT(m.MachineID) AS NumberOfMachines  \nFROM Departments d  \nLEFT JOIN Chemicals c ON d.DepartmentID = c.DepartmentID  \nLEFT JOIN Machinery m ON d.DepartmentID = m.DepartmentID  \nGROUP BY d.DepartmentID, d.DepartmentName;", "raw_model_output": "\n\nSELECT d.DepartmentName, COUNT(c.ChemicalID) AS NumberOfChemicals, COUNT(m.MachineID) AS NumberOfMachines  \nFROM Departments d  \nLEFT JOIN Chemicals c ON d.DepartmentID = c.DepartmentID  \nLEFT JOIN Machinery m ON d.DepartmentID = m.DepartmentID  \nGROUP BY d.DepartmentID, d.DepartmentName;", "latency_sec": 0.6155362129211426, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1260, "prompt_eval_sec": null, "tokens_completion": 74, "completion_eval_sec": null, "tokens_total": 1334, "tokens_per_sec": 2167.2161149857498, "retrieval_latency_sec": 0.09015703201293945, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform the same LEFT JOINs between Departments and Chemicals/Machinery, and count the related records. The GROUP BY in the Reference SQL uses only DepartmentName, while the Generated SQL uses both DepartmentID and DepartmentName. Since DepartmentID and DepartmentName are functionally dependent (each DepartmentID maps to a unique DepartmentName), the grouping produces equivalent results. The different column aliases (ChemicalCount vs NumberOfChemicals, MachineCount vs NumberOfMachines) do not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count chemicals and machines per department. The reference query groups by DepartmentName, which could be problematic if multiple departments shared the same name (though not the case here). The generated query groups by both DepartmentID and DepartmentName, ensuring reliability through the primary key. While both produce identical results in this specific dataset, the generated query is more robust and technically superior due to proper grouping on the primary key. The business intent is fully met by both, but the generated version adheres to better SQL practices.", "overall_assessment": "differently_correct"}}
{"example_id": 1895, "sql_complexity": "window functions", "prompt": "What is the average safety score of chemical production sites in the United States, partitioned by state and ranked in descending order?", "context": "CREATE TABLE production_sites (site_id INT, site_name TEXT, country TEXT, state TEXT, safety_score FLOAT); INSERT INTO production_sites (site_id, site_name, country, state, safety_score) VALUES (1, 'Site A', 'USA', 'NY', 92.5), (2, 'Site B', 'USA', 'CA', 87.4), (3, 'Site C', 'USA', 'TX', 95.3), (4, 'Site D', 'USA', 'FL', 89.2);", "reference_sql": "SELECT state, AVG(safety_score) as avg_safety_score, ROW_NUMBER() OVER (ORDER BY AVG(safety_score) DESC) as rank FROM production_sites WHERE country = 'USA' GROUP BY state ORDER BY rank;", "generated_sql": "SELECT state, AVG(safety_score) AS avg_safety_score  \nFROM production_sites  \nWHERE country = 'USA'  \nGROUP BY state  \nORDER BY avg_safety_score DESC;", "raw_model_output": "\n\nSELECT state, AVG(safety_score) AS avg_safety_score  \nFROM production_sites  \nWHERE country = 'USA'  \nGROUP BY state  \nORDER BY avg_safety_score DESC;", "latency_sec": 0.3659968376159668, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 914, "prompt_eval_sec": null, "tokens_completion": 42, "completion_eval_sec": null, "tokens_total": 956, "tokens_per_sec": 2612.0444270152734, "retrieval_latency_sec": 0.10457873344421387, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a ROW_NUMBER() column for ranking and orders by that rank, while the Generated SQL only orders by the average safety score. The result sets differ in both structure (extra 'rank' column) and ordering logic, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL includes a ROW_NUMBER() ranking column that isn't explicitly requested in the original question, while the Generated SQL directly addresses the requirement to 'partition by state and rank in descending order' by ordering results by average safety score. Both queries correctly calculate averages by state for US sites, but the Generated SQL is more efficient and aligns better with the business intent of simply ordering results rather than adding a redundant rank column. The Reference SQL's ORDER BY rank would produce the same ordering as Generated SQL's ORDER BY avg_safety_score DESC, but the Generated SQL is simpler and avoids unnecessary complexity.", "overall_assessment": "differently_correct"}}
{"example_id": 4669, "sql_complexity": "set operations", "prompt": "Identify the number of IoT devices in each country and the total number of devices.", "context": "CREATE TABLE device_country (device_id INT, country TEXT); INSERT INTO device_country (device_id, country) VALUES (1, 'USA'), (2, 'Canada'), (3, 'Mexico'), (4, 'Brazil'); CREATE TABLE device_info (device_id INT, device_type TEXT); INSERT INTO device_info (device_id, device_type) VALUES (1, 'Soil Sensor'), (2, 'Temperature Sensor'), (3, 'Humidity Sensor'), (4, 'Precision Sprayer');", "reference_sql": "SELECT country, COUNT(*) AS device_count FROM device_country GROUP BY country UNION SELECT 'Total' AS country, COUNT(*) FROM device_country;", "generated_sql": "SELECT country, COUNT(*) AS num_devices FROM device_country GROUP BY country UNION ALL SELECT 'Total' AS country, COUNT(*) AS num_devices FROM device_country;", "raw_model_output": "\n\nSELECT country, COUNT(*) AS num_devices FROM device_country GROUP BY country UNION ALL SELECT 'Total' AS country, COUNT(*) AS num_devices FROM device_country;", "latency_sec": 0.32819104194641113, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 856, "prompt_eval_sec": null, "tokens_completion": 37, "completion_eval_sec": null, "tokens_total": 893, "tokens_per_sec": 2720.976156764858, "retrieval_latency_sec": 0.11092686653137207, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Reference SQL uses `UNION` (which removes duplicates) while the Generated SQL uses `UNION ALL` (which retains duplicates). However, in this specific case, since the two result sets (grouped countries and the total) have no overlapping rows, both would produce the same rows. The critical difference is the column alias: `device_count` vs `num_devices`. While the data values are identical, the column names differ, making the result sets structurally different. Semantic equivalence typically requires identical data and structure, so the queries are not fully equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries produce identical results by grouping devices by country and adding a total row. The reference query uses UNION (which removes duplicates) while the generated query uses UNION ALL (which preserves all rows). However, since the two result sets (country-specific counts and the total) are inherently non-overlapping, both achieve the same output. The generated query is more efficient because UNION ALL avoids the overhead of duplicate checking, making it technically superior despite equivalent results. Both fulfill the business intent of showing device counts per country and the total.", "overall_assessment": "correct"}}
{"example_id": 5302, "sql_complexity": "multiple_joins", "prompt": "Find the supplier with the lowest average delivery time for orders in the last month.", "context": "CREATE TABLE Suppliers (SupplierID int, SupplierName varchar(50)); CREATE TABLE Products (ProductID int, ProductName varchar(50), SupplierID int); CREATE TABLE Orders (OrderID int, ProductID int, OrderDate date, DeliveryTime int); INSERT INTO Suppliers VALUES (1, 'SupplierA'), (2, 'SupplierB'); INSERT INTO Products VALUES (1, 'Organic Apples', 1), (2, 'Bananas', 2); INSERT INTO Orders VALUES (1, 1, '2022-01-01', 2), (2, 2, '2022-01-03', 3);", "reference_sql": "SELECT SupplierName, AVG(DeliveryTime) as AvgDeliveryTime FROM Orders o JOIN Products p ON o.ProductID = p.ProductID JOIN Suppliers sp ON p.SupplierID = sp.SupplierID WHERE OrderDate >= DATEADD(month, -1, GETDATE()) GROUP BY SupplierName ORDER BY AvgDeliveryTime ASC;", "generated_sql": "SELECT s.SupplierName, AVG(o.DeliveryTime) AS avg_delivery_time\nFROM Orders o\nJOIN Products p ON o.ProductID = p.ProductID\nJOIN Suppliers s ON p.SupplierID = s.SupplierID\nWHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH)\nGROUP BY s.SupplierID, s.SupplierName\nORDER BY avg_delivery_time ASC\nLIMIT 1;", "raw_model_output": "\n\n```sql\nSELECT s.SupplierName, AVG(o.DeliveryTime) AS avg_delivery_time\nFROM Orders o\nJOIN Products p ON o.ProductID = p.ProductID\nJOIN Suppliers s ON p.SupplierID = s.SupplierID\nWHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH)\nGROUP BY s.SupplierID, s.SupplierName\nORDER BY avg_delivery_time ASC\nLIMIT 1;\n```", "latency_sec": 0.8013389110565186, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 907, "prompt_eval_sec": null, "tokens_completion": 95, "completion_eval_sec": null, "tokens_total": 1002, "tokens_per_sec": 1250.4072698515556, "retrieval_latency_sec": 0.09260225296020508, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in three key aspects: 1) The date calculation functions (GETDATE() vs CURDATE() with DATE_SUB) which may behave differently across databases, 2) The Generated query includes a LIMIT 1 clause which restricts output to a single row while the Reference query does not, and 3) The Generated query groups by both SupplierID and SupplierName (though this is technically correct, the Reference only groups by SupplierName). These differences ensure they do not produce identical results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in three key aspects: 1) The Generated SQL uses DATE_SUB/CURDATE() which is MySQL syntax vs Reference's DATEADD/GETDATE() (SQL Server), but both calculate the last month correctly. 2) The Generated SQL groups by both SupplierID and SupplierName (safer for unique identification) while Reference only groups by SupplierName. 3) The critical difference is that Generated includes LIMIT 1 to return only the top result, whereas Reference returns all suppliers sorted by average delivery time. The original question specifically asks for 'the supplier' (singular), making LIMIT 1 essential for fulfilling the business intent. While both queries correctly calculate averages, only Generated retrieves the single supplier with the lowest average.", "overall_assessment": "differently_correct"}}
{"example_id": 267, "sql_complexity": "subqueries", "prompt": "What is the total number of disability support programs offered in urban and rural areas, and the percentage of total programs for each area type?", "context": "CREATE TABLE programs (program_id INT, program_name VARCHAR(255), area_type VARCHAR(255));", "reference_sql": "SELECT area_type, COUNT(*) as total_programs, ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM programs) , 2) as percentage_of_total FROM programs WHERE area_type IN ('urban', 'rural') GROUP BY area_type;", "generated_sql": "SELECT \n    area_type, \n    COUNT(*) AS total_programs, \n    (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM programs)) AS percentage_of_total\nFROM programs\nWHERE area_type IN ('urban', 'rural')\nGROUP BY area_type;", "raw_model_output": "\n\nSELECT \n    area_type, \n    COUNT(*) AS total_programs, \n    (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM programs)) AS percentage_of_total\nFROM programs\nWHERE area_type IN ('urban', 'rural')\nGROUP BY area_type;", "latency_sec": 0.5002760887145996, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1035, "prompt_eval_sec": null, "tokens_completion": 64, "completion_eval_sec": null, "tokens_total": 1099, "tokens_per_sec": 2196.786983810781, "retrieval_latency_sec": 0.10614418983459473, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses ROUND() to format the percentage to 2 decimal places, while the Generated SQL calculates the exact value without rounding. This difference in precision makes the results non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are nearly identical but differ in the use of the ROUND function. The reference query rounds percentages to 2 decimal places, while the generated query calculates exact values. Both correctly count programs by area type and compute percentages relative to the total program count. The generated query is more elegant by avoiding unnecessary rounding, which aligns with the business intent of calculating percentages without artificial precision constraints. Both fulfill the intent of reporting counts and percentages for urban/rural areas.", "overall_assessment": "differently_correct"}}
{"example_id": 3028, "sql_complexity": "basic SQL", "prompt": "What is the number of startups founded by non-binary individuals in the technology industry?", "context": "CREATE TABLE company (id INT, name TEXT, founder_gender TEXT, industry TEXT); INSERT INTO company (id, name, founder_gender, industry) VALUES (1, 'CodeForAll', 'Non-binary', 'Technology'); INSERT INTO company (id, name, founder_gender, industry) VALUES (2, 'TechVillage', 'Male', 'Technology');", "reference_sql": "SELECT COUNT(*) FROM company WHERE founder_gender = 'Non-binary' AND industry = 'Technology';", "generated_sql": "SELECT COUNT(*) FROM company WHERE founder_gender = 'Non-binary' AND industry = 'Technology';", "raw_model_output": "\n\nSELECT COUNT(*) FROM company WHERE founder_gender = 'Non-binary' AND industry = 'Technology';", "latency_sec": 0.24591803550720215, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 771, "prompt_eval_sec": null, "tokens_completion": 24, "completion_eval_sec": null, "tokens_total": 795, "tokens_per_sec": 3232.784445273909, "retrieval_latency_sec": 0.10572314262390137, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They both count rows from the 'company' table where 'founder_gender' is 'Non-binary' and 'industry' is 'Technology'. The SQL syntax, table names, column names, and conditions are exactly the same in both queries.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic. They correctly count companies where founder_gender is 'Non-binary' and industry is 'Technology', directly addressing the business question. The queries are technically correct, semantically equivalent, and efficiently implement the required filter. Since the reference and generated queries are identical, neither is superior to the other.", "overall_assessment": "correct"}}
{"example_id": 3282, "sql_complexity": "aggregation", "prompt": "Which marine species have been observed in both the Arctic and Antarctic oceans?", "context": "CREATE TABLE marine_species (id INT, species_name VARCHAR(50), common_name VARCHAR(50), region VARCHAR(20));INSERT INTO marine_species (id, species_name, common_name, region) VALUES (1, 'Orcinus_orca', 'Killer Whale', 'Arctic');INSERT INTO marine_species (id, species_name, common_name, region) VALUES (2, 'Balaenoptera_bonaerensis', 'Antarctic Minke Whale', 'Antarctic');", "reference_sql": "SELECT species_name FROM marine_species WHERE region IN ('Arctic', 'Antarctic') GROUP BY species_name HAVING COUNT(DISTINCT region) = 2;", "generated_sql": "SELECT species_name \nFROM marine_species \nWHERE region IN ('Arctic', 'Antarctic') \nGROUP BY species_name \nHAVING COUNT(DISTINCT region) = 2;", "raw_model_output": "\n\nSELECT species_name \nFROM marine_species \nWHERE region IN ('Arctic', 'Antarctic') \nGROUP BY species_name \nHAVING COUNT(DISTINCT region) = 2;", "latency_sec": 0.36913585662841797, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 983, "prompt_eval_sec": null, "tokens_completion": 43, "completion_eval_sec": null, "tokens_total": 1026, "tokens_per_sec": 2779.4644751425462, "retrieval_latency_sec": 0.10750913619995117, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure, syntax, and logic. Both select species_name from marine_species where region is 'Arctic' or 'Antarctic', group by species_name, and filter with HAVING COUNT(DISTINCT region) = 2. The output will be the same for both.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "The reference and generated SQL queries are identical in structure, logic, and syntax. Both correctly filter marine species observed in either the Arctic or Antarctic, then use GROUP BY and HAVING COUNT(DISTINCT region) = 2 to ensure species appear in both regions. The queries are semantically equivalent, technically correct, and fully address the business intent of identifying species present in both oceans. Neither query demonstrates superior efficiency or elegance over the other as they are identical.", "overall_assessment": "correct"}}
{"example_id": 3474, "sql_complexity": "subqueries", "prompt": "What is the total transaction volume for the top 3 digital assets by market capitalization in the 'developed_markets' schema?", "context": "CREATE SCHEMA developed_markets; CREATE TABLE developed_markets.digital_assets (asset_name VARCHAR(10), market_cap BIGINT, daily_transaction_volume BIGINT); INSERT INTO developed_markets.digital_assets (asset_name, market_cap, daily_transaction_volume) VALUES ('AssetG', 30000000, 15000000), ('AssetH', 25000000, 12000000), ('AssetI', 20000000, 10000000), ('AssetJ', 15000000, 8000000), ('AssetK', 10000000, 6000000);", "reference_sql": "SELECT SUM(daily_transaction_volume) FROM (SELECT daily_transaction_volume FROM developed_markets.digital_assets ORDER BY market_cap DESC FETCH NEXT 3 ROWS ONLY) t;", "generated_sql": "SELECT SUM(daily_transaction_volume) \nFROM (\n    SELECT daily_transaction_volume \n    FROM developed_markets.digital_assets \n    ORDER BY market_cap DESC \n    FETCH NEXT 3 ROWS ONLY\n) t;", "raw_model_output": "\n\nSELECT SUM(daily_transaction_volume) \nFROM (\n    SELECT daily_transaction_volume \n    FROM developed_markets.digital_assets \n    ORDER BY market_cap DESC \n    FETCH NEXT 3 ROWS ONLY\n) t;", "latency_sec": 0.4053223133087158, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1138, "prompt_eval_sec": null, "tokens_completion": 48, "completion_eval_sec": null, "tokens_total": 1186, "tokens_per_sec": 2926.066394713081, "retrieval_latency_sec": 0.1097719669342041, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries perform the same operation: they select the top 3 rows from the digital_assets table ordered by market_cap in descending order, then calculate the sum of the daily_transaction_volume column for those rows. The syntax and logic are identical in both queries.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic. They correctly retrieve the top 3 digital assets by market capitalization using ORDER BY market_cap DESC FETCH NEXT 3 ROWS ONLY, then sum their daily_transaction_volume. The subquery structure ensures only the top 3 rows are aggregated. Both queries technically and semantically fulfill the business intent of calculating the total transaction volume for the top 3 assets in the schema. Since the queries are identical, neither is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 1626, "sql_complexity": "aggregation", "prompt": "Find the total value of social impact bonds issued by each organization.", "context": "CREATE TABLE social_impact_bonds (id INT, organization_name VARCHAR(255), issue_year INT, value FLOAT); INSERT INTO social_impact_bonds (id, organization_name, issue_year, value) VALUES (1, 'Acme Corp', 2018, 2000000), (2, 'XYZ Foundation', 2019, 3000000), (3, 'Global Giving', 2018, 1500000), (4, 'Acme Corp', 2019, 2500000), (5, 'XYZ Foundation', 2018, 1000000);", "reference_sql": "SELECT organization_name, SUM(value) as total_value FROM social_impact_bonds GROUP BY organization_name;", "generated_sql": "SELECT organization_name, SUM(value) as total_value FROM social_impact_bonds GROUP BY organization_name;", "raw_model_output": "\n\nSELECT organization_name, SUM(value) as total_value FROM social_impact_bonds GROUP BY organization_name;", "latency_sec": 0.263416051864624, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1148, "prompt_eval_sec": null, "tokens_completion": 26, "completion_eval_sec": null, "tokens_total": 1174, "tokens_per_sec": 4456.827864853685, "retrieval_latency_sec": 0.11241602897644043, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure and logic. Both queries select the same columns, apply the same aggregate function (SUM(value)), and group by the same column (organization_name). Since the queries are exactly the same, they will produce identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic. They correctly aggregate the total value of social impact bonds by organization using SUM(value) with GROUP BY organization_name. The queries are technically correct, produce identical results, and directly address the business requirement of calculating organization-specific totals. Since the reference and generated queries are exactly the same, neither is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 1315, "sql_complexity": "single join", "prompt": "List all the transactions made by clients living in New York with a transaction amount greater than $1000.", "context": "CREATE TABLE transactions (id INT, client_id INT, transaction_amount DECIMAL(10,2), transaction_date DATE); INSERT INTO transactions (id, client_id, transaction_amount, transaction_date) VALUES (1, 3, 1500.00, '2022-01-01'), (2, 4, 800.00, '2022-01-02'), (3, 3, 1200.00, '2022-01-03'); CREATE TABLE clients (id INT, name VARCHAR(255), state VARCHAR(255)); INSERT INTO clients (id, name, state) VALUES (3, 'Mike Johnson', 'New York'), (4, 'Sara Lee', 'California');", "reference_sql": "SELECT transactions.id, transactions.client_id, transactions.transaction_amount, transactions.transaction_date FROM transactions INNER JOIN clients ON transactions.client_id = clients.id WHERE clients.state = 'New York' AND transactions.transaction_amount > 1000.00;", "generated_sql": "SELECT t.* \nFROM transactions t \nJOIN clients c ON t.client_id = c.id \nWHERE c.state = 'New York' AND t.transaction_amount > 1000;", "raw_model_output": "\n\nSELECT t.* \nFROM transactions t \nJOIN clients c ON t.client_id = c.id \nWHERE c.state = 'New York' AND t.transaction_amount > 1000;", "latency_sec": 0.4333350658416748, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 967, "prompt_eval_sec": null, "tokens_completion": 43, "completion_eval_sec": null, "tokens_total": 1010, "tokens_per_sec": 2330.759912166947, "retrieval_latency_sec": 0.10815834999084473, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve transactions with client state 'New York' and transaction amount > 1000. The generated query uses table aliases and selects all columns from transactions (t.*), which is equivalent to explicitly listing the same columns. The JOIN conditions and WHERE filters are identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent as they produce identical results by joining the same tables on client_id, filtering for 'New York' clients and transactions > $1000. The reference explicitly lists columns while the generated uses SELECT *, but the transactions table has exactly four columns (id, client_id, transaction_amount, transaction_date) which match the reference's output. Both fulfill the business intent of listing qualifying transactions. The generated query is more concise with table aliases, but the reference's explicit column selection could be seen as clearer for documentation. Neither query is more efficient than the other in this context.", "overall_assessment": "correct"}}
{"example_id": 520, "sql_complexity": "multiple_joins", "prompt": "What is the total number of electric vehicles sold in 'California' in the 'sales' schema?", "context": "CREATE TABLE sales_regions (id INT, name VARCHAR(50));   CREATE TABLE sales (id INT, region_id INT, vehicle_count INT);   CREATE TABLE vehicles (id INT, type VARCHAR(50));   INSERT INTO sales_regions VALUES (1, 'California');   INSERT INTO sales VALUES (1, 1, 5000);   INSERT INTO vehicles VALUES (1, 'electric');", "reference_sql": "SELECT SUM(sales.vehicle_count) FROM sales INNER JOIN sales_regions ON sales.region_id = sales_regions.id INNER JOIN vehicles ON sales.id = vehicles.id WHERE vehicles.type = 'electric' AND sales_regions.name = 'California';", "generated_sql": "SELECT SUM(sales.vehicle_count)  \nFROM sales  \nINNER JOIN sales_regions ON sales.region_id = sales_regions.id  \nINNER JOIN vehicles ON sales.id = vehicles.id  \nWHERE vehicles.type = 'electric' AND sales_regions.name = 'California';", "raw_model_output": "\n\nSELECT SUM(sales.vehicle_count)  \nFROM sales  \nINNER JOIN sales_regions ON sales.region_id = sales_regions.id  \nINNER JOIN vehicles ON sales.id = vehicles.id  \nWHERE vehicles.type = 'electric' AND sales_regions.name = 'California';", "latency_sec": 0.44521474838256836, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 764, "prompt_eval_sec": null, "tokens_completion": 54, "completion_eval_sec": null, "tokens_total": 818, "tokens_per_sec": 1837.315594264863, "retrieval_latency_sec": 0.11577486991882324, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure, JOIN conditions, and WHERE clauses. The only difference is formatting (line breaks and indentation), which does not affect semantic meaning.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are syntactically identical in structure, logic, and semantic meaning. They perform the same three-table join (sales \u2194 sales_regions \u2194 vehicles), apply identical filters (vehicles.type = 'electric' and sales_regions.name = 'California'), and calculate the same aggregate (SUM(sales.vehicle_count)). The only difference is formatting/indentation, which does not affect execution. Both correctly address the business question by summing electric vehicle sales in California.", "overall_assessment": "correct"}}
{"example_id": 3999, "sql_complexity": "single join", "prompt": "What is the total number of tickets sold for performances with a rating of 5?", "context": "CREATE TABLE performance (id INT PRIMARY KEY, name VARCHAR(255), date DATE, artist_id INT, rating INT); INSERT INTO performance (id, name, date, artist_id, rating) VALUES (1, 'Dance Recital', '2022-03-01', 1, 5);", "reference_sql": "SELECT SUM(t.quantity) as total_tickets_sold FROM performance p INNER JOIN ticket t ON p.id = t.performance_id WHERE p.rating = 5;", "generated_sql": "The provided schema does not include a column or table that tracks the number of tickets sold for performances. Therefore, it is not possible to determine the total number of tickets sold for performances with a rating of 5 based on the given schema.", "raw_model_output": "\n\nThe provided schema does not include a column or table that tracks the number of tickets sold for performances. Therefore, it is not possible to determine the total number of tickets sold for performances with a rating of 5 based on the given schema.", "latency_sec": 0.4955027103424072, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 741, "prompt_eval_sec": null, "tokens_completion": 53, "completion_eval_sec": null, "tokens_total": 794, "tokens_per_sec": 1602.4130311039514, "retrieval_latency_sec": 0.1054542064666748, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL assumes the existence of a 'ticket' table with a 'quantity' column, which is not present in the provided schema. The Generated SQL correctly states that the necessary schema elements (ticket tracking) are missing, making the Reference SQL invalid. Since one is an invalid query and the other is an explanatory statement, they are not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference SQL assumes the existence of a 'ticket' table with a 'quantity' column and a 'performance_id' foreign key, but the provided schema only defines the 'performance' table. The generated SQL correctly identifies that the necessary data structure (ticket sales tracking) is missing from the schema. While the reference query technically addresses the business intent if the schema were complete, it's invalid given the actual schema. The generated query properly highlights the data deficiency rather than making unfounded assumptions.", "overall_assessment": "incorrect"}}
{"example_id": 2261, "sql_complexity": "multiple_joins", "prompt": "What is the total number of animals that have been released into 'protected' habitats, and the average weight of those animals?", "context": "CREATE TABLE habitats (habitat_id INT, habitat_name VARCHAR(50), habitat_status VARCHAR(50)); INSERT INTO habitats (habitat_id, habitat_name, habitat_status) VALUES (1, 'Habitat A', 'protected'), (2, 'Habitat B', 'unprotected'); CREATE TABLE animal_habitats (animal_id INT, habitat_id INT, animal_weight FLOAT); INSERT INTO animal_habitats (animal_id, habitat_id, animal_weight) VALUES (101, 1, 25.5), (102, 2, 15.2); CREATE TABLE animals (animal_id INT, animal_name VARCHAR(50)); INSERT INTO animals (animal_id, animal_name) VALUES (101, 'Dog'), (102, 'Cat');", "reference_sql": "SELECT COUNT(*), AVG(animal_habitats.animal_weight) FROM animal_habitats INNER JOIN animals ON animal_habitats.animal_id = animals.animal_id INNER JOIN habitats ON animal_habitats.habitat_id = habitats.habitat_id WHERE habitats.habitat_status = 'protected';", "generated_sql": "SELECT COUNT(*) AS total_animals, AVG(animal_weight) AS average_weight FROM animal_habitats ah JOIN habitats h ON ah.habitat_id = h.habitat_id WHERE h.habitat_status = 'protected';", "raw_model_output": "\n\nSELECT COUNT(*) AS total_animals, AVG(animal_weight) AS average_weight FROM animal_habitats ah JOIN habitats h ON ah.habitat_id = h.habitat_id WHERE h.habitat_status = 'protected';", "latency_sec": 0.42797398567199707, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1032, "prompt_eval_sec": null, "tokens_completion": 52, "completion_eval_sec": null, "tokens_total": 1084, "tokens_per_sec": 2532.8642307497325, "retrieval_latency_sec": 0.10939908027648926, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the count and average animal weight for protected habitats. The Reference SQL includes an unnecessary join with the animals table, but since no columns from animals are used and the animal_habitats table's animal_id is likely valid, the result remains the same. The Generated SQL simplifies the query by omitting the redundant join while maintaining identical output.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries produce identical results by counting animal_habitats entries and averaging animal_weight where habitat_status is 'protected'. The reference query includes an unnecessary INNER JOIN with the animals table, which doesn't affect the outcome since COUNT(*) and AVG() operate on the animal_habitats table. The generated query is more efficient with fewer joins and clearer aliases, achieving the same result with simpler syntax. Both correctly address the business intent of counting released animals and their average weight in protected habitats.", "overall_assessment": "correct"}}
{"example_id": 3439, "sql_complexity": "multiple_joins", "prompt": "How many menu items contain ingredients sourced from local suppliers for each restaurant?", "context": "CREATE TABLE restaurants (id INT, name VARCHAR(50), location VARCHAR(50)); INSERT INTO restaurants VALUES (1, 'Restaurant A', 'City A'); INSERT INTO restaurants VALUES (2, 'Restaurant B', 'City B'); CREATE TABLE menu_items (id INT, name VARCHAR(50), restaurant_id INT, price DECIMAL(5,2)); INSERT INTO menu_items VALUES (1, 'Item A', 1, 10.99); INSERT INTO menu_items VALUES (2, 'Item B', 1, 12.99); INSERT INTO menu_items VALUES (3, 'Item C', 2, 11.99); CREATE TABLE ingredients (id INT, name VARCHAR(50), local_source BOOLEAN, menu_item_id INT); INSERT INTO ingredients VALUES (1, 'Ingredient A', TRUE, 1); INSERT INTO ingredients VALUES (2, 'Ingredient B', FALSE, 1); INSERT INTO ingredients VALUES (3, 'Ingredient C', TRUE, 2); INSERT INTO ingredients VALUES (4, 'Ingredient D', FALSE, 2); INSERT INTO ingredients VALUES (5, 'Ingredient E', TRUE, 3);", "reference_sql": "SELECT r.name, COUNT(DISTINCT mi.id) as num_local_items FROM restaurants r JOIN menu_items mi ON r.id = mi.restaurant_id JOIN ingredients i ON mi.id = i.menu_item_id WHERE i.local_source = TRUE GROUP BY r.name;", "generated_sql": "SELECT r.name AS restaurant_name, COUNT(DISTINCT mi.id) AS local_ingredient_count\nFROM restaurants r\nJOIN menu_items mi ON r.id = mi.restaurant_id\nJOIN ingredients i ON mi.id = i.menu_item_id\nWHERE i.local_source = TRUE\nGROUP BY r.name;", "raw_model_output": "\n\nSELECT r.name AS restaurant_name, COUNT(DISTINCT mi.id) AS local_ingredient_count\nFROM restaurants r\nJOIN menu_items mi ON r.id = mi.restaurant_id\nJOIN ingredients i ON mi.id = i.menu_item_id\nWHERE i.local_source = TRUE\nGROUP BY r.name;", "latency_sec": 0.6150317192077637, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 928, "prompt_eval_sec": null, "tokens_completion": 65, "completion_eval_sec": null, "tokens_total": 993, "tokens_per_sec": 1614.5508743501975, "retrieval_latency_sec": 0.10494589805603027, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries perform the same operations: joining restaurants, menu_items, and ingredients tables; filtering on local_source = TRUE; grouping by restaurant name; and counting distinct menu item IDs. The only differences are in column aliases (e.g., 'num_local_items' vs 'local_ingredient_count' and 'r.name' vs 'restaurant_name'), which do not affect the semantic result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are structurally identical in logic, joins, and aggregation. The only difference is column aliasing: the reference query uses 'name' while the generated query uses 'restaurant_name'. The generated version has more descriptive column aliases (e.g., 'local_ingredient_count' vs 'num_local_items') which improves readability without altering functionality. Both correctly count distinct menu items per restaurant with at least one local ingredient, fulfilling the business intent. The generated query is slightly more elegant due to clearer naming conventions.", "overall_assessment": "correct"}}
{"example_id": 2265, "sql_complexity": "aggregation", "prompt": "Hourly revenue for a specific movie?", "context": "CREATE TABLE Movie_Revenue (id INT, movie_title VARCHAR(100), revenue_time TIME, revenue DECIMAL(10,2));", "reference_sql": "SELECT revenue_time, SUM(revenue) FROM Movie_Revenue WHERE movie_title = 'Spider-Man: No Way Home' GROUP BY revenue_time;", "generated_sql": "SELECT DATEPART(hh, revenue_time) AS Hour_of_Day, SUM(revenue) AS Total_Revenue \nFROM Movie_Revenue \nWHERE movie_title = 'Specific Movie' \nGROUP BY DATEPART(hh, revenue_time);", "raw_model_output": "\n\nSELECT DATEPART(hh, revenue_time) AS Hour_of_Day, SUM(revenue) AS Total_Revenue \nFROM Movie_Revenue \nWHERE movie_title = 'Specific Movie' \nGROUP BY DATEPART(hh, revenue_time);", "latency_sec": 0.42530202865600586, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 663, "prompt_eval_sec": null, "tokens_completion": 53, "completion_eval_sec": null, "tokens_total": 716, "tokens_per_sec": 1683.5094868054753, "retrieval_latency_sec": 0.10819101333618164, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in three key aspects: 1) The reference query groups by the full 'revenue_time' while the generated query groups by only the hour part using DATEPART(hh, ...). 2) The WHERE clauses filter different movie titles ('Spider-Man: No Way Home' vs 'Specific Movie'). 3) The selected columns differ (revenue_time vs Hour_of_Day). These differences ensure the result sets would have different structures and values.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "Evaluation error: 'NoneType' object has no attribute 'find'", "overall_assessment": "incorrect"}}
{"example_id": 1763, "sql_complexity": "multiple_joins", "prompt": "What is the total food and beverage revenue last month for hotels in 'Bangkok'?", "context": "CREATE TABLE revenue (hotel_id INT, revenue_source VARCHAR(50), revenue INT, revenue_date DATE); INSERT INTO revenue (hotel_id, revenue_source, revenue, revenue_date) VALUES (5, 'Room revenue', 12000, '2022-03-01'), (5, 'Food and beverage', 4000, '2022-03-02'), (5, 'Other revenue', 1000, '2022-03-03'); CREATE TABLE hotels (hotel_id INT, city VARCHAR(50)); INSERT INTO hotels (hotel_id, city) VALUES (5, 'Bangkok'); CREATE TABLE dates (date DATE); INSERT INTO dates (date) VALUES ('2022-03-01'), ('2022-03-02'), ('2022-03-03');", "reference_sql": "SELECT SUM(revenue) FROM revenue JOIN hotels ON revenue.hotel_id = hotels.hotel_id JOIN dates ON revenue.revenue_date = dates.date WHERE hotels.city = 'Bangkok' AND revenue_source = 'Food and beverage' AND dates.date >= DATEADD(month, -1, GETDATE());", "generated_sql": "SELECT SUM(r.revenue) \nFROM revenue r \nJOIN hotels h ON r.hotel_id = h.hotel_id \nWHERE h.city = 'Bangkok' \n  AND r.revenue_source = 'Food and beverage' \n  AND r.revenue_date >= DATEADD(MONTH, -1, CURRENT_DATE);", "raw_model_output": "\n\nSELECT SUM(r.revenue) \nFROM revenue r \nJOIN hotels h ON r.hotel_id = h.hotel_id \nWHERE h.city = 'Bangkok' \n  AND r.revenue_source = 'Food and beverage' \n  AND r.revenue_date >= DATEADD(MONTH, -1, CURRENT_DATE);", "latency_sec": 0.549422025680542, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1129, "prompt_eval_sec": null, "tokens_completion": 71, "completion_eval_sec": null, "tokens_total": 1200, "tokens_per_sec": 2184.1133844490837, "retrieval_latency_sec": 0.11290216445922852, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of 'Food and beverage' revenue for hotels in Bangkok where the revenue date is within the last month. The Reference SQL includes an unnecessary join with the 'dates' table, but since the condition 'revenue.revenue_date = dates.date' ensures the dates table only contains matching dates, the filter 'dates.date >= ...' is functionally equivalent to 'revenue.revenue_date >= ...'. The Generated SQL omits the redundant join, but the result remains the same. The date functions (GETDATE() vs CURRENT_DATE) are assumed equivalent in this context.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The Reference SQL includes an unnecessary JOIN with the 'dates' table, which is not required to filter by revenue_date. This join could lead to incorrect results if the 'dates' table lacks relevant dates (e.g., if the current date is beyond March 2022). The Generated SQL directly filters on revenue_date without the extra join, making it more efficient and accurate. Both queries correctly filter for 'Bangkok' hotels and 'Food and beverage' revenue, but the Generated version avoids potential pitfalls with the dates table and uses standard CURRENT_DATE instead of SQL Server-specific GETDATE().", "overall_assessment": "differently_correct"}}
{"example_id": 5499, "sql_complexity": "set operations", "prompt": "How many legal aid clinics and community mediation centers are there in total, and what is the sum of cases handled by each type of center, for centers located in the state of California?", "context": "CREATE TABLE LegalAidClinics (ClinicName text, State text, NumCases int); INSERT INTO LegalAidClinics VALUES ('Clinic1', 'CA', 30, '2022-01-01'), ('Clinic2', 'CA', 25, '2022-01-01'); CREATE TABLE CommunityMediationCenters (CenterName text, State text, NumCases int); INSERT INTO CommunityMediationCenters VALUES ('CM1', 'CA', 22, '2022-01-01'), ('CM2', 'CA', 28, '2022-01-01');", "reference_sql": "SELECT State, 'Legal Aid Clinics' AS CenterType, COUNT(*) AS NumCenters, SUM(NumCases) AS TotalCases FROM LegalAidClinics WHERE State = 'CA' UNION ALL SELECT State, 'Community Mediation Centers', COUNT(*), SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA';", "generated_sql": "SELECT \n    (SELECT COUNT(*) FROM LegalAidClinics WHERE State = 'CA') + (SELECT COUNT(*) FROM CommunityMediationCenters WHERE State = 'CA') AS TotalCenters,\n    (SELECT SUM(NumCases) FROM LegalAidClinics WHERE State = 'CA') AS TotalCasesByLegalAidClinics,\n    (SELECT SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA') AS TotalCasesByCommunityMediationCenters;", "raw_model_output": "\n\nSELECT \n    (SELECT COUNT(*) FROM LegalAidClinics WHERE State = 'CA') + (SELECT COUNT(*) FROM CommunityMediationCenters WHERE State = 'CA') AS TotalCenters,\n    (SELECT SUM(NumCases) FROM LegalAidClinics WHERE State = 'CA') AS TotalCasesByLegalAidClinics,\n    (SELECT SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA') AS TotalCasesByCommunityMediationCenters;", "latency_sec": 0.8824689388275146, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1185, "prompt_eval_sec": null, "tokens_completion": 106, "completion_eval_sec": null, "tokens_total": 1291, "tokens_per_sec": 1462.9410092498858, "retrieval_latency_sec": 0.10813212394714355, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL returns two rows with detailed breakdowns by center type (Legal Aid Clinics and Community Mediation Centers), including State, CenterType, NumCenters, and TotalCases. The Generated SQL returns a single row with aggregated totals (TotalCenters, TotalCasesByLegalAidClinics, and TotalCasesByCommunityMediationCenters). The structure, number of rows, and column semantics differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL produces two rows (one for each center type) with separate counts and case sums, but it does not calculate the total number of centers across both types as requested. The Generated SQL correctly computes the total centers (sum of both tables) and separate case sums for each type in a single row. While both queries are technically correct, the Generated SQL better fulfills the business intent by providing the required 'total' count and structuring the results in a way that directly answers the question. The Reference SQL's output format (two rows) does not align with the explicit request for a 'total' count.", "overall_assessment": "differently_correct"}}
{"example_id": 2408, "sql_complexity": "aggregation", "prompt": "What is the average number of victories for players from Japan and South Korea, partitioned by game mode?", "context": "CREATE TABLE PlayerVictories (PlayerID INT, GameMode VARCHAR(255), Victories INT, Country VARCHAR(255)); INSERT INTO PlayerVictories (PlayerID, GameMode, Victories, Country) VALUES (1, 'Battle Royale', 25, 'Japan'), (2, 'Team Deathmatch', 18, 'South Korea');", "reference_sql": "SELECT GameMode, AVG(Victories) as AvgVictories FROM PlayerVictories WHERE Country IN ('Japan', 'South Korea') GROUP BY GameMode, Country WITH ROLLUP;", "generated_sql": "SELECT GameMode, AVG(Victories) AS AverageVictories\nFROM PlayerVictories\nWHERE Country IN ('Japan', 'South Korea')\nGROUP BY GameMode;", "raw_model_output": "\n\n```sql\nSELECT GameMode, AVG(Victories) AS AverageVictories\nFROM PlayerVictories\nWHERE Country IN ('Japan', 'South Korea')\nGROUP BY GameMode;\n```", "latency_sec": 0.36743879318237305, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 878, "prompt_eval_sec": null, "tokens_completion": 43, "completion_eval_sec": null, "tokens_total": 921, "tokens_per_sec": 2506.5399111053434, "retrieval_latency_sec": 0.1102149486541748, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes GROUP BY GameMode, Country with WITH ROLLUP, which creates subtotals for each GameMode/Country combination and a grand total row. The Generated SQL only groups by GameMode, aggregating all countries together. This changes the grouping structure and excludes the rollup summary rows, leading to different result sets.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL groups by both GameMode and Country (with ROLLUP), which would produce separate averages for Japan and South Korea within each game mode, plus subtotals. The original question asks for the average victories for players from both countries combined, partitioned by game mode. The Generated SQL correctly groups by GameMode only, aggregating all players from Japan and South Korea. The ROLLUP in the Reference SQL introduces additional subtotal rows not requested in the question. While both queries are syntactically valid, the Generated SQL aligns better with the business intent of calculating a single average per game mode for the combined countries.", "overall_assessment": "correct"}}
{"example_id": 2729, "sql_complexity": "subqueries", "prompt": "Find the total number of trips made by shared autonomous vehicles in Seattle", "context": "CREATE TABLE shared_vehicles (id INT, vehicle_type VARCHAR(20), is_autonomous BOOLEAN, trip_count INT); INSERT INTO shared_vehicles (id, vehicle_type, is_autonomous, trip_count) VALUES (1, 'ebike', false, 1200), (2, 'escooter', false, 800), (3, 'car', true, 1500); CREATE TABLE city_data (city VARCHAR(20), has_autonomous_vehicles BOOLEAN); INSERT INTO city_data (city, has_autonomous_vehicles) VALUES ('Seattle', true), ('Denver', false), ('Portland', true);", "reference_sql": "SELECT SUM(trip_count) FROM shared_vehicles WHERE is_autonomous = true AND vehicle_type != 'ebike' AND vehicle_type != 'escooter' AND city IN (SELECT city FROM city_data WHERE has_autonomous_vehicles = true AND city = 'Seattle');", "generated_sql": "SELECT SUM(sv.trip_count) \nFROM shared_vehicles sv \nJOIN city_data cd \nON sv.vehicle_type = cd.city \nWHERE sv.is_autonomous = true AND cd.city = 'Seattle';", "raw_model_output": "\n\nSELECT SUM(sv.trip_count) \nFROM shared_vehicles sv \nJOIN city_data cd \nON sv.vehicle_type = cd.city \nWHERE sv.is_autonomous = true AND cd.city = 'Seattle';", "latency_sec": 0.3818540573120117, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 789, "prompt_eval_sec": null, "tokens_completion": 45, "completion_eval_sec": null, "tokens_total": 834, "tokens_per_sec": 2184.080498897361, "retrieval_latency_sec": 0.10578417778015137, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL references a 'city' column in shared_vehicles, which does not exist in the schema. The Generated SQL incorrectly joins shared_vehicles.vehicle_type with city_data.city (which are unrelated data types). Additionally, the Reference SQL's logic (filtering by city in a subquery) differs fundamentally from the Generated SQL's JOIN condition. Both queries are invalid under the given schema but for different reasons.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL attempts to filter autonomous vehicles while excluding ebikes/escooters and checking for Seattle's autonomous vehicle status, but it incorrectly references a non-existent 'city' column in the shared_vehicles table. The Generated SQL has a logical error in joining shared_vehicles.vehicle_type with city_data.city (comparing vehicle types to city names). Neither query is technically correct, but the Reference SQL better aligns with the business intent by focusing on autonomous vehicle types and trip counts, even though it contains a syntax error. The Generated SQL's join condition is fundamentally flawed and fails to address the question.", "overall_assessment": "incorrect"}}
{"example_id": 2952, "sql_complexity": "aggregation", "prompt": "Show the total budget allocated for each program category in 2023.", "context": "CREATE TABLE Budget (id INT, category TEXT, year INT, allocated_amount INT); INSERT INTO Budget (id, category, year, allocated_amount) VALUES (1, 'Education', 2023, 30000); INSERT INTO Budget (id, category, year, allocated_amount) VALUES (2, 'Healthcare', 2023, 50000);", "reference_sql": "SELECT category, SUM(allocated_amount) FROM Budget WHERE year = 2023 GROUP BY category;", "generated_sql": "SELECT category, SUM(allocated_amount) AS TotalBudget \nFROM Budget \nWHERE year = 2023 \nGROUP BY category;", "raw_model_output": "\n\nSELECT category, SUM(allocated_amount) AS TotalBudget \nFROM Budget \nWHERE year = 2023 \nGROUP BY category;", "latency_sec": 0.41065216064453125, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 823, "prompt_eval_sec": null, "tokens_completion": 33, "completion_eval_sec": null, "tokens_total": 856, "tokens_per_sec": 2084.489215048769, "retrieval_latency_sec": 0.09210801124572754, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (category and SUM(allocated_amount)) from the same table with the same WHERE and GROUP BY clauses. The only difference is the alias 'TotalBudget' applied to the aggregated column in the generated query, which does not affect the semantic result set.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the total allocated budget per category for 2023 using SUM and GROUP BY. The generated query adds an explicit column alias (TotalBudget) which improves readability without altering the result. The reference query is technically correct but less descriptive. Both satisfy the business requirement, but the generated version is more elegant and self-documenting.", "overall_assessment": "correct"}}
{"example_id": 4328, "sql_complexity": "aggregation", "prompt": "What is the average cargo handling time in hours for each port?", "context": "CREATE TABLE cargo_handling (id INT, port_id INT, time_in_hours DECIMAL(5,2)); INSERT INTO cargo_handling (id, port_id, time_in_hours) VALUES (1, 1, 20.5), (2, 1, 22.3), (3, 2, 18.7);", "reference_sql": "SELECT port_id, AVG(time_in_hours) FROM cargo_handling GROUP BY port_id;", "generated_sql": "SELECT port_id, AVG(time_in_hours) FROM cargo_handling GROUP BY port_id;", "raw_model_output": "\n\nSELECT port_id, AVG(time_in_hours) FROM cargo_handling GROUP BY port_id;", "latency_sec": 0.23535895347595215, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 766, "prompt_eval_sec": null, "tokens_completion": 22, "completion_eval_sec": null, "tokens_total": 788, "tokens_per_sec": 3348.0774296547597, "retrieval_latency_sec": 0.11424088478088379, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They select the same columns (port_id and AVG(time_in_hours)) from the same table (cargo_handling) and apply the same GROUP BY clause on port_id. The result will be the same average values for each port_id.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic. They correctly calculate the average cargo handling time per port by grouping on port_id. The queries are technically identical, so they produce the same results, fulfill the business intent of calculating average handling times per port, and have equal efficiency/elegance.", "overall_assessment": "correct"}}
{"example_id": 4915, "sql_complexity": "window functions", "prompt": "Calculate the percentage of total Europium production for each country.", "context": "CREATE TABLE europium_production (country VARCHAR(50), quantity INT);", "reference_sql": "SELECT country, quantity * 100.0 / SUM(quantity) OVER (PARTITION BY NULL) AS percentage FROM europium_production;", "generated_sql": "SELECT country, (quantity * 100.0 / SUM(quantity) OVER ()) AS percentage_of_total FROM europium_production;", "raw_model_output": "\n\nSELECT country, (quantity * 100.0 / SUM(quantity) OVER ()) AS percentage_of_total FROM europium_production;", "latency_sec": 0.2964138984680176, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 795, "prompt_eval_sec": null, "tokens_completion": 32, "completion_eval_sec": null, "tokens_total": 827, "tokens_per_sec": 2790.0176215564047, "retrieval_latency_sec": 0.10909891128540039, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the percentage of each country's production relative to the total production. The window function SUM(quantity) OVER () in the generated query is equivalent to SUM(quantity) OVER (PARTITION BY NULL) in the reference query, as both compute the total sum across all rows. The only difference is the column alias name ('percentage' vs 'percentage_of_total'), which does not affect the semantic result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the percentage of total Europium production per country by dividing each country's quantity by the total sum. The reference query uses `SUM(quantity) OVER (PARTITION BY NULL)`, while the generated query uses `SUM(quantity) OVER ()`. These are functionally identical because `PARTITION BY NULL` explicitly defines a single partition, and `OVER()` without arguments defaults to the entire result set. The generated query is more concise and elegant, achieving the same result with less syntax. Both fulfill the business intent, but the generated version is preferable for its brevity and standard usage of window functions.", "overall_assessment": "correct"}}
{"example_id": 5030, "sql_complexity": "subqueries", "prompt": "What is the success rate of diverse-led startups (at least 1 female or underrepresented racial or ethnic group executive) in the past 3 years?", "context": "CREATE TABLE DiverseStartups(id INT, name TEXT, country TEXT, year INT, success BOOLEAN);   INSERT INTO DiverseStartups VALUES (1, 'FemTech', 'USA', 2020, true), (2, 'GreenCity', 'Canada', 2019, false), (3, 'AI-Health', 'UK', 2021, true), (4, 'SolarEnergy', 'USA', 2020, false), (5, 'DataAnalytics', 'Germany', 2019, true), (6, 'SmartGrid', 'USA', 2021, true), (7, 'CloudServices', 'India', 2020, false), (8, 'RenewableEnergy', 'USA', 2019, true);", "reference_sql": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3) AS success_rate FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3 AND success = true;", "generated_sql": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3) AS success_rate FROM DiverseStartups WHERE success = true AND year >= YEAR(CURRENT_DATE) - 3;", "raw_model_output": "\n\nSELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3) AS success_rate FROM DiverseStartups WHERE success = true AND year >= YEAR(CURRENT_DATE) - 3;", "latency_sec": 0.4961709976196289, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1402, "prompt_eval_sec": null, "tokens_completion": 61, "completion_eval_sec": null, "tokens_total": 1463, "tokens_per_sec": 2948.5802415270446, "retrieval_latency_sec": 0.11578893661499023, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the success rate by dividing the count of successful startups (success = true) in the last 3 years by the total count of startups in the same period. The order of conditions in the WHERE clause does not affect the result since both use AND to combine the same filters.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries calculate the success rate of diverse-led startups in the past 3 years by counting successful entries (success = true) and dividing by total entries in the same period. The only difference is the order of conditions in the WHERE clause, which does not affect logical outcome or performance. Both correctly filter the 3-year window using YEAR(CURRENT_DATE) - 3 and address the business question about success rates.", "overall_assessment": "correct"}}
{"example_id": 4626, "sql_complexity": "aggregation", "prompt": "What was the maximum number of training hours for farmers in each country in 2020?", "context": "CREATE TABLE training (id INT, country_id INT, farmer_id INT, hours INT, date DATE);", "reference_sql": "SELECT country_id, MAX(hours) FROM training WHERE YEAR(date) = 2020 GROUP BY country_id;", "generated_sql": "SELECT country_id, MAX(hours) as max_hours FROM training WHERE date >= '2020-01-01' AND date < '2021-01-01' GROUP BY country_id;", "raw_model_output": "\n\nSQL: SELECT country_id, MAX(hours) as max_hours FROM training WHERE date >= '2020-01-01' AND date < '2021-01-01' GROUP BY country_id;", "latency_sec": 0.6965651512145996, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 665, "prompt_eval_sec": null, "tokens_completion": 54, "completion_eval_sec": null, "tokens_total": 719, "tokens_per_sec": 1032.2078254220453, "retrieval_latency_sec": 0.11105489730834961, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter records from the year 2020. The reference query uses YEAR(date) = 2020, while the generated query uses date between '2020-01-01' (inclusive) and '2021-01-01' (exclusive). These conditions are equivalent for date values. The GROUP BY and MAX(hours) logic is identical in both queries.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the maximum training hours per country for 2020. The reference query uses YEAR(date) = 2020, which is semantically correct but may have performance implications due to function-based filtering. The generated query uses a date range (>= '2020-01-01' AND < '2021-01-01'), which is more efficient for index utilization and avoids function calls on the date column. Both produce identical results, but the generated query demonstrates better technical practice for performance while fully addressing the business intent of identifying maximum hours per country in 2020.", "overall_assessment": "correct"}}
{"example_id": 2703, "sql_complexity": "set operations", "prompt": "Identify the species unique to 'MarineResearchAreaA' and 'MarineResearchAreaB'", "context": "CREATE TABLE ResearchAreaSpecies (area VARCHAR(255), species VARCHAR(255)); INSERT INTO ResearchAreaSpecies (area, species) VALUES ('MarineResearchAreaA', 'Coral'), ('MarineResearchAreaA', 'Starfish'), ('MarineResearchAreaB', 'Jellyfish');", "reference_sql": "(SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB') UNION (SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA');", "generated_sql": "SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB') UNION (SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA');", "raw_model_output": "\n\nSQL: (SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB') UNION (SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA');", "latency_sec": 0.6454718112945557, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 700, "prompt_eval_sec": null, "tokens_completion": 78, "completion_eval_sec": null, "tokens_total": 778, "tokens_per_sec": 1205.3198704985216, "retrieval_latency_sec": 0.10820674896240234, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries compute the symmetric difference between the species in 'MarineResearchAreaA' and 'MarineResearchAreaB'. The parentheses in the Reference SQL are redundant because EXCEPT has higher precedence than UNION, so the Generated SQL produces the same result despite missing parentheses.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query is technically correct and semantically equivalent, while the generated query contains a syntax error (extra closing parenthesis after the first EXCEPT clause) that would cause a query failure. Both queries aim to find species unique to each area, but the generated query's syntax error prevents it from fulfilling the business intent. The reference query properly uses parentheses around EXCEPT subqueries and combines results with UNION to show species unique to either area.", "overall_assessment": "incorrect"}}
{"example_id": 200, "sql_complexity": "window functions", "prompt": "List the top three categories of workforce development programs with the highest budget increases.", "context": "CREATE TABLE programs (program_id INT, program_name VARCHAR(50), budget DECIMAL(10, 2), category VARCHAR(50), budget_date DATE);", "reference_sql": "SELECT category, SUM(budget - LAG(budget) OVER (PARTITION BY category ORDER BY budget_date)) as total_budget_increase FROM programs GROUP BY category ORDER BY total_budget_increase DESC LIMIT 3;", "generated_sql": "To answer the question \"List the top three categories of workforce development programs with the highest budget increases,\" we need to calculate the budget increase for each category. However, the schema provided does not include historical budget data (e.g., budget from previous years), which is required to calculate the \"budget increase.\"\n\nAssuming that \"budget_date\" represents the most recent budget and that we are comparing it to a previous budget (which is not available in the schema), we cannot compute the budget increase.\n\nTherefore, based on the provided schema, it is **not possible** to determine the \"budget increases\" for categories.\n\n### Final Answer:\n**Not possible to answer with the given schema.**  \nThe schema lacks historical budget data needed to calculate budget increases.", "raw_model_output": "\n\nTo answer the question \"List the top three categories of workforce development programs with the highest budget increases,\" we need to calculate the budget increase for each category. However, the schema provided does not include historical budget data (e.g., budget from previous years), which is required to calculate the \"budget increase.\"\n\nAssuming that \"budget_date\" represents the most recent budget and that we are comparing it to a previous budget (which is not available in the schema), we cannot compute the budget increase.\n\nTherefore, based on the provided schema, it is **not possible** to determine the \"budget increases\" for categories.\n\n### Final Answer:\n**Not possible to answer with the given schema.**  \nThe schema lacks historical budget data needed to calculate budget increases.", "latency_sec": 1.1702680587768555, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 539, "prompt_eval_sec": null, "tokens_completion": 156, "completion_eval_sec": null, "tokens_total": 695, "tokens_per_sec": 593.8810298953235, "retrieval_latency_sec": 0.0911109447479248, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL is a valid query calculating budget increases using LAG(), while the Generated SQL is not a query but an explanatory note stating the schema lacks historical data. They are not semantically equivalent as one is a query and the other is a non-query explanation.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is technically flawed because it assumes historical budget data exists in the schema, which it does not. The LAG() function requires multiple budget entries per category over time to calculate increases, but the schema only provides a single 'budget' field per program. The Generated SQL correctly identifies this critical data limitation, stating the schema lacks historical budget data needed for the calculation. While both queries fail to answer the question due to schema constraints, the Generated SQL accurately explains why the task is impossible, whereas the Reference SQL makes invalid assumptions about the data structure.", "overall_assessment": "differently_correct"}}
{"example_id": 5131, "sql_complexity": "basic SQL", "prompt": "How many wells were drilled in the Eagle Ford Shale and Bakken Formation?", "context": "CREATE TABLE wells (id INT, region VARCHAR(255), well_type VARCHAR(255), num_drilled INT); INSERT INTO wells (id, region, well_type, num_drilled) VALUES (1, 'Eagle Ford Shale', 'Oil', 2000), (2, 'Eagle Ford Shale', 'Gas', 1500), (3, 'Bakken Formation', 'Oil', 1000), (4, 'Bakken Formation', 'Gas', 1200);", "reference_sql": "SELECT SUM(num_drilled) as total_wells FROM wells WHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "generated_sql": "SELECT SUM(num_drilled) AS total_wells FROM wells WHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "raw_model_output": "\n\nSELECT SUM(num_drilled) AS total_wells FROM wells WHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "latency_sec": 0.3054530620574951, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 826, "prompt_eval_sec": null, "tokens_completion": 33, "completion_eval_sec": null, "tokens_total": 859, "tokens_per_sec": 2812.216038084147, "retrieval_latency_sec": 0.10605907440185547, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the sum of num_drilled from the wells table with identical WHERE conditions (region IN ('Eagle Ford Shale', 'Bakken Formation')). The column aliases and syntax are identical, so they will produce the same result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "The reference and generated queries are identical in structure and logic. Both correctly sum the 'num_drilled' column for wells in 'Eagle Ford Shale' and 'Bakken Formation' regions. The queries are semantically equivalent, produce identical results, and directly address the business question by aggregating total wells drilled in the specified formations. Both are equally efficient and elegant, with no differences in syntax or performance.", "overall_assessment": "correct"}}
{"example_id": 1160, "sql_complexity": "subqueries", "prompt": "What is the total revenue generated from ads on Instagram in March 2021, for users in the 'brand' category who have posted more than 10 times?", "context": "CREATE TABLE ads (ad_id INT, user_id INT, platform VARCHAR(255), ad_revenue DECIMAL(10,2), post_count INT); INSERT INTO ads (ad_id, user_id, platform, ad_revenue, post_count) VALUES (1, 1, 'Instagram', 150.50, 12), (2, 2, 'Twitter', 80.00, 15), (3, 3, 'Instagram', 120.75, 8);", "reference_sql": "SELECT SUM(ad_revenue) FROM ads WHERE platform = 'Instagram' AND MONTH(ad_date) = 3 AND YEAR(ad_date) = 2021 AND user_id IN (SELECT user_id FROM users WHERE category = 'brand' AND post_count > 10);", "generated_sql": "SELECT SUM(ad_revenue) FROM ads WHERE platform = 'Instagram' AND post_count > 10;", "raw_model_output": "\n\nBased on the provided schema and question, there is no `ad_date` column or `users` table referenced in the schema. Therefore, the question cannot be fully answered with the given schema.\n\nHowever, assuming the question intends to ask for the total revenue from Instagram ads where `post_count > 10` (since the `users` table is not present and the `post_count` is in the `ads` table), the SQL would be:\n\n```sql\nSELECT SUM(ad_revenue) FROM ads WHERE platform = 'Instagram' AND post_count > 10;\n```", "latency_sec": 0.8781957626342773, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1086, "prompt_eval_sec": null, "tokens_completion": 123, "completion_eval_sec": null, "tokens_total": 1209, "tokens_per_sec": 1376.6862144420131, "retrieval_latency_sec": 0.11206507682800293, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes additional conditions not present in the Generated SQL: filtering by ad_date (MONTH(ad_date) = 3 and YEAR(ad_date) = 2021) and a subquery joining users table (category = 'brand' and post_count > 10). The Generated SQL only filters by platform and post_count, omitting these critical constraints. The post_count conditions also differ in their source (users table vs. ads table).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL contains a critical technical error by referencing 'ad_date' which does not exist in the ads table schema. The Generated SQL is technically valid (no syntax errors) but fails to fulfill the business intent by omitting key filters: 1) the date range (March 2021), 2) user category ('brand'), and 3) the user_id subquery. While the Generated SQL is more syntactically correct, neither query fully addresses the original question. However, the Generated SQL avoids the invalid column reference, making it technically superior in this context.", "overall_assessment": "incorrect"}}
{"example_id": 4708, "sql_complexity": "subqueries", "prompt": "What is the maximum number of high-level threats reported by a single agency in a month?", "context": "CREATE TABLE Threat_Intelligence (Threat_ID INT, Threat_Type VARCHAR(50), Threat_Level VARCHAR(50), Reported_Date DATE, Reporting_Agency VARCHAR(50)); CREATE VIEW High_Level_Threats AS SELECT Threat_Type, Threat_Level, Reported_Date FROM Threat_Intelligence WHERE Threat_Level = 'High';", "reference_sql": "SELECT Reporting_Agency, MAX(Number_of_High_Level_Threats) as Max_High_Level_Threats_in_a_Month FROM (SELECT Reporting_Agency, TO_CHAR(Reported_Date, 'YYYY-MM') as Month, COUNT(*) as Number_of_High_Level_Threats FROM High_Level_Threats GROUP BY Reporting_Agency, Month) GROUP BY Reporting_Agency;", "generated_sql": "SELECT MAX(incident_count) FROM (\n    SELECT COUNT(*) AS incident_count\n    FROM Threat_Intelligence\n    WHERE Threat_Level = 'High'\n    AND Reported_Date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH)\n    GROUP BY Reporting_Agency, DATE_FORMAT(Reported_Date, '%Y-%m')\n) AS agency_monthly_counts;", "raw_model_output": "\n\nSELECT MAX(incident_count) FROM (\n    SELECT COUNT(*) AS incident_count\n    FROM Threat_Intelligence\n    WHERE Threat_Level = 'High'\n    AND Reported_Date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH)\n    GROUP BY Reporting_Agency, DATE_FORMAT(Reported_Date, '%Y-%m')\n) AS agency_monthly_counts;", "latency_sec": 0.678199052810669, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 675, "prompt_eval_sec": null, "tokens_completion": 77, "completion_eval_sec": null, "tokens_total": 752, "tokens_per_sec": 1108.8190065784918, "retrieval_latency_sec": 0.10750818252563477, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates the maximum number of high-level threats per agency across all time, while the Generated SQL only considers threats from the last month and returns a single maximum value across all agencies. Additionally, the Generated SQL omits the 'Threat_Type' column and uses a different date filtering approach.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL incorrectly groups by Reporting_Agency twice, which would return the maximum per-agency monthly count but not the overall maximum across all agencies and months. The Generated SQL correctly groups by agency and month, then takes the MAX(incident_count), which aligns with the business intent. However, the Generated SQL includes a date filter (last month) that restricts results to a specific timeframe, while the original question does not specify a time constraint. The Reference SQL's structure is less efficient due to redundant grouping, but the Generated SQL's approach is more elegant despite the date limitation. The Generated SQL better addresses the intent but fails to account for all possible months.", "overall_assessment": "incorrect"}}
{"example_id": 5608, "sql_complexity": "set operations", "prompt": "List the suppliers that provide materials for both product A and product C.", "context": "CREATE TABLE products (product_id INT, product_name TEXT); CREATE TABLE materials (material_id INT, material_name TEXT, product_id INT, supplier_id INT); INSERT INTO products (product_id, product_name) VALUES (1, 'Product A'), (2, 'Product B'), (3, 'Product C'); INSERT INTO materials (material_id, material_name, product_id, supplier_id) VALUES (1, 'Material 1', 1, 101), (2, 'Material 2', 1, 102), (3, 'Material 3', 2, 103), (4, 'Material 4', 3, 101), (5, 'Material 5', 3, 102);", "reference_sql": "SELECT supplier_id FROM materials WHERE product_id = 1 INTERSECT SELECT supplier_id FROM materials WHERE product_id = 3;", "generated_sql": "SELECT supplier_id  \nFROM materials  \nWHERE product_id IN (SELECT product_id FROM products WHERE product_name = 'Product A')  \nAND supplier_id IN (SELECT supplier_id FROM materials WHERE product_id IN (SELECT product_id FROM products WHERE product_name = 'Product C'))  \nGROUP BY supplier_id;", "raw_model_output": "\n\nSELECT supplier_id  \nFROM materials  \nWHERE product_id IN (SELECT product_id FROM products WHERE product_name = 'Product A')  \nAND supplier_id IN (SELECT supplier_id FROM materials WHERE product_id IN (SELECT product_id FROM products WHERE product_name = 'Product C'))  \nGROUP BY supplier_id;", "latency_sec": 0.5148940086364746, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1319, "prompt_eval_sec": null, "tokens_completion": 65, "completion_eval_sec": null, "tokens_total": 1384, "tokens_per_sec": 2687.9318399238387, "retrieval_latency_sec": 0.11060190200805664, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve supplier_ids that supply materials for both product_id 1 (Product A) and product_id 3 (Product C). The Reference SQL uses INTERSECT to find common supplier_ids between the two product_id conditions, while the Generated SQL uses AND with IN clauses to achieve the same result. The GROUP BY supplier_id in the Generated SQL ensures uniqueness, matching the behavior of INTERSECT.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries correctly identify suppliers providing materials for both Product A and Product C. The Reference SQL uses INTERSECT, which directly computes the set intersection of suppliers for the two products. The Generated SQL achieves the same result through nested IN clauses and GROUP BY, which implicitly filters suppliers present in both product contexts. While both are technically correct, the Reference SQL is more efficient and elegant as INTERSECT explicitly conveys the intent of finding common elements, whereas the Generated SQL requires additional logical steps (subqueries and grouping) to achieve the same outcome.", "overall_assessment": "correct"}}
{"example_id": 1506, "sql_complexity": "basic SQL", "prompt": "How many habitats are in the 'animal_habitats' table?", "context": "CREATE TABLE animal_habitats (id INT PRIMARY KEY, habitat_name VARCHAR, num_animals INT);", "reference_sql": "SELECT COUNT(*) FROM animal_habitats;", "generated_sql": "SELECT COUNT(*) FROM animal_habitats;", "raw_model_output": "\n\nSELECT COUNT(*) FROM animal_habitats;", "latency_sec": 0.2947988510131836, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 638, "prompt_eval_sec": null, "tokens_completion": 14, "completion_eval_sec": null, "tokens_total": 652, "tokens_per_sec": 2211.677548128714, "retrieval_latency_sec": 0.1105201244354248, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical: they select the count of all rows from the 'animal_habitats' table using the same syntax. The result will be the same for both.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure, syntax, and logic. They both execute a COUNT(*) operation on the 'animal_habitats' table, which directly answers the question about the number of habitats. The queries are semantically equivalent, produce the same result, and fulfill the business intent of counting rows in the table. Neither query is more efficient or elegant than the other since they are identical.", "overall_assessment": "correct"}}
{"example_id": 3117, "sql_complexity": "aggregation", "prompt": "What is the percentage of the population that has access to clean water in each continent?", "context": "CREATE TABLE water_data (id INT, country VARCHAR(50), continent CHAR(2), access_to_clean_water BOOLEAN); INSERT INTO water_data VALUES (1, 'Canada', 'NA', true), (2, 'Mexico', 'NA', false), (3, 'Brazil', 'SA', true), (4, 'Russia', 'EU', true);", "reference_sql": "SELECT continent, COUNT(*) FILTER (WHERE access_to_clean_water) * 100.0 / COUNT(*) AS percentage FROM water_data GROUP BY continent;", "generated_sql": "SELECT continent, (SUM(CASE WHEN access_to_clean_water THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS CleanWaterPercentage FROM water_data GROUP BY continent;", "raw_model_output": "\n\nSELECT continent, (SUM(CASE WHEN access_to_clean_water THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS CleanWaterPercentage FROM water_data GROUP BY continent;", "latency_sec": 0.3905060291290283, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 802, "prompt_eval_sec": null, "tokens_completion": 47, "completion_eval_sec": null, "tokens_total": 849, "tokens_per_sec": 2174.1021563574354, "retrieval_latency_sec": 0.10511374473571777, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the percentage of countries with access to clean water per continent. The reference uses COUNT(*) FILTER (WHERE access_to_clean_water) to count qualifying rows, while the generated query uses SUM(CASE WHEN ... THEN 1 ELSE 0 END) which achieves the same result. Both divide by COUNT(*) to get the percentage, and the column aliases are irrelevant to semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the percentage of the population with access to clean water per continent. The reference query uses PostgreSQL's COUNT(*) FILTER syntax, while the generated query uses a SUM(CASE...) approach. Both methods accurately count true values in the access_to_clean_water column and divide by total records per continent. The mathematical logic and grouping are identical. The difference lies in syntax preference: the reference is more concise but PostgreSQL-specific, while the generated query uses standard SQL that works across databases. Neither query handles potential NULL values in access_to_clean_water (though the schema defines it as NOT NULL). Both fulfill the business intent of calculating continent-level percentages.", "overall_assessment": "correct"}}
{"example_id": 3542, "sql_complexity": "window functions", "prompt": "What is the average yield of crops for each country, ranked by average yield?", "context": "CREATE TABLE farming (id INT, name TEXT, country TEXT, crop TEXT, yield INT); INSERT INTO farming VALUES (1, 'Smith Farm', 'USA', 'Corn', 120), (2, 'Brown Farm', 'Canada', 'Soybeans', 45), (3, 'Jones Farm', 'Mexico', 'Wheat', 80);", "reference_sql": "SELECT country, AVG(yield) as avg_yield, ROW_NUMBER() OVER (ORDER BY AVG(yield) DESC) as rank FROM farming GROUP BY country;", "generated_sql": "SELECT country, AVG(yield) AS average_yield FROM farming GROUP BY country ORDER BY average_yield DESC;", "raw_model_output": "\n\n```sql\nSELECT country, AVG(yield) AS average_yield FROM farming GROUP BY country ORDER BY average_yield DESC;\n```", "latency_sec": 0.2956228256225586, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 677, "prompt_eval_sec": null, "tokens_completion": 30, "completion_eval_sec": null, "tokens_total": 707, "tokens_per_sec": 2391.560930760719, "retrieval_latency_sec": 0.10943102836608887, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a ROW_NUMBER() column for ranking, while the Generated SQL only orders results. The first query adds a 'rank' column based on average yield, whereas the second query simply sorts by average yield without including the rank. The result sets differ in structure and content.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL includes a ROW_NUMBER() window function to explicitly assign ranks based on average yield, directly addressing the 'ranked by average yield' requirement. The Generated SQL only orders results by average yield without adding a rank column. While both calculate average yields correctly, the Reference SQL better fulfills the business intent of providing explicit rankings. The Generated SQL is technically correct but incomplete for the specific request. The Reference SQL is more elegant in achieving the full requirement with a single query.", "overall_assessment": "differently_correct"}}
{"example_id": 2274, "sql_complexity": "subqueries", "prompt": "Add a new crop 'amaranth' to farm 'Nourishing Harvest' with yield 50 in 2023", "context": "CREATE TABLE farms (id INT, name TEXT, location TEXT, size FLOAT); INSERT INTO farms (id, name, location, size) VALUES (1, 'Nourishing Harvest', 'Mexico', 120.0); CREATE TABLE crops (id INT, farm_id INT, crop TEXT, yield INT, year INT);", "reference_sql": "INSERT INTO crops (id, farm_id, crop, yield, year) VALUES (5, (SELECT id FROM farms WHERE name = 'Nourishing Harvest'), 'amaranth', 50, 2023);", "generated_sql": "INSERT INTO crops (id, farm_id, crop, yield, year) VALUES (2, (SELECT id FROM farms WHERE name = 'Nourishing Harvest'), 'amaranth', 50, 2023);", "raw_model_output": "\n\nINSERT INTO crops (id, farm_id, crop, yield, year) VALUES (2, (SELECT id FROM farms WHERE name = 'Nourishing Harvest'), 'amaranth', 50, 2023);", "latency_sec": 0.49595212936401367, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1088, "prompt_eval_sec": null, "tokens_completion": 52, "completion_eval_sec": null, "tokens_total": 1140, "tokens_per_sec": 2298.608943290321, "retrieval_latency_sec": 0.1034543514251709, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the 'id' value being inserted (5 vs 2). While all other fields (farm_id, crop, yield, year) are identical, the distinct id values mean the inserted rows are different, making the queries not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "equal", "explanation": "The queries differ only in the hardcoded 'id' value (5 vs 2). Both correctly insert a new crop record with the specified parameters. The business intent to add 'amaranth' to 'Nourishing Harvest' with yield 50 in 2023 is fulfilled by both. However, the 'id' field is not explicitly required by the original question, and its value is arbitrary. Since the farm_id subquery correctly identifies the farm, both queries technically achieve the goal. The difference in 'id' values does not affect the business intent but makes them technically non-equivalent. Neither query is clearly superior as the 'id' is not specified in the original request.", "overall_assessment": "differently_correct"}}
{"example_id": 3705, "sql_complexity": "subqueries", "prompt": "What is the percentage of unions with collective bargaining agreements in the Midwest region?", "context": "CREATE TABLE collective_bargaining (bargaining_id INT, union_name VARCHAR(50), contract_start_date DATE, contract_end_date DATE, region VARCHAR(50));CREATE VIEW union_region AS SELECT DISTINCT union_name, region FROM collective_bargaining;", "reference_sql": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM union_region) as percentage FROM union_region ur WHERE ur.region = 'Midwest' AND EXISTS (SELECT 1 FROM collective_bargaining cb WHERE cb.union_name = ur.union_name);", "generated_sql": "SELECT (COUNT(DISTINCT ur.union_name) * 100.0 / (SELECT COUNT(DISTINCT union_name) FROM union_region)) AS percentage FROM union_region ur WHERE ur.region = 'Midwest';", "raw_model_output": "\n\nSELECT (COUNT(DISTINCT ur.union_name) * 100.0 / (SELECT COUNT(DISTINCT union_name) FROM union_region)) AS percentage FROM union_region ur WHERE ur.region = 'Midwest';", "latency_sec": 0.4225039482116699, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1160, "prompt_eval_sec": null, "tokens_completion": 50, "completion_eval_sec": null, "tokens_total": 1210, "tokens_per_sec": 2863.878562843164, "retrieval_latency_sec": 0.10665392875671387, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses COUNT(*) in both numerator and denominator, while the Generated SQL uses COUNT(DISTINCT ...) in the numerator and COUNT(DISTINCT union_name) in the denominator. The EXISTS clause in the Reference SQL is redundant (since union_region is derived from collective_bargaining) but doesn't affect the result. However, the denominator in the Reference SQL counts all rows in union_region, whereas the Generated SQL's denominator counts distinct union_names. This difference in aggregation leads to different results when union_names appear in multiple regions.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries calculate the percentage of unions with collective bargaining agreements in the Midwest region. The reference query uses COUNT(*) with an unnecessary EXISTS clause (since union_region is derived from collective_bargaining, all unions in it inherently have agreements). The generated query uses COUNT(DISTINCT) which is more precise and avoids potential overcounting if duplicates existed. The denominator in both queries effectively counts distinct unions (COUNT(*) vs COUNT(DISTINCT) in union_region, which is already deduplicated). The generated query is more efficient and elegant by directly leveraging COUNT(DISTINCT) and eliminating redundant logic.", "overall_assessment": "correct"}}
{"example_id": 240, "sql_complexity": "aggregation", "prompt": "What is the average capacity of renewable energy projects for each country?", "context": "CREATE TABLE projects (name TEXT, type TEXT, capacity INTEGER, country TEXT); INSERT INTO projects (name, type, capacity, country) VALUES ('Project 1', 'Wind', 100, 'USA'), ('Project 2', 'Solar', 200, 'Germany'), ('Project 3', 'Wind', 300, 'France');", "reference_sql": "SELECT country, AVG(capacity) FROM projects GROUP BY country", "generated_sql": "SELECT country, AVG(capacity) AS average_capacity FROM projects WHERE type IN ('Wind', 'Solar') GROUP BY country;", "raw_model_output": "\n\nSELECT country, AVG(capacity) AS average_capacity FROM projects WHERE type IN ('Wind', 'Solar') GROUP BY country;", "latency_sec": 0.32831311225891113, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 728, "prompt_eval_sec": null, "tokens_completion": 30, "completion_eval_sec": null, "tokens_total": 758, "tokens_per_sec": 2308.771632009121, "retrieval_latency_sec": 0.10310888290405273, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "In the given dataset, all projects have either 'Wind' or 'Solar' type. The WHERE clause in the Generated SQL does not exclude any rows, so both queries calculate the same average capacity per country.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries calculate the average capacity per country, but the generated query explicitly filters for 'Wind' and 'Solar' projects, which are renewable energy types. While the reference query would produce identical results in this specific context (since all projects are renewable), the generated query better aligns with the business intent of focusing on renewable energy projects. The reference query might include non-renewable projects if they existed in the dataset, making the generated query more precise for the stated question.", "overall_assessment": "differently_correct"}}
{"example_id": 2132, "sql_complexity": "set operations", "prompt": "What is the average caseload per attorney in community legal clinics in California, and how does it compare to the state average?", "context": "CREATE TABLE cali_community_legal_clinics(id INT, attorney_count INT, cases_handled INT, state VARCHAR(255));", "reference_sql": "SELECT state, AVG(cases_handled/attorney_count) AS avg_caseload FROM cali_community_legal_clinics WHERE state = 'California' GROUP BY state UNION ALL SELECT 'California', AVG(cases_handled/attorney_count) FROM cali_community_legal_clinics WHERE state = 'California';", "generated_sql": "SELECT \n    AVG(cases_handled / attorney_count) AS california_avg_caseload_per_attorney,\n    (SELECT AVG(cases_handled / attorney_count) FROM cali_community_legal_clinics) AS state_avg_caseload_per_attorney\nFROM cali_community_legal_clinics\nWHERE state = 'California';", "raw_model_output": "\n\nSELECT \n    AVG(cases_handled / attorney_count) AS california_avg_caseload_per_attorney,\n    (SELECT AVG(cases_handled / attorney_count) FROM cali_community_legal_clinics) AS state_avg_caseload_per_attorney\nFROM cali_community_legal_clinics\nWHERE state = 'California';", "latency_sec": 0.6121187210083008, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 764, "prompt_eval_sec": null, "tokens_completion": 73, "completion_eval_sec": null, "tokens_total": 837, "tokens_per_sec": 1367.3818023753101, "retrieval_latency_sec": 0.10587596893310547, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two rows with the same state and average value (due to UNION ALL), while the Generated SQL returns a single row with two different average values (California-specific and overall). The structure and content of the results differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL contains redundant logic with a UNION ALL that duplicates the same California average calculation, resulting in two identical rows. The Generated SQL uses a single query with a subquery to directly compare California's average caseload to the state average in one row. While both calculate the correct values, the Generated SQL is more efficient, avoids redundancy, and explicitly structures the comparison as requested. The Reference's structure could lead to confusion due to duplicate results, whereas the Generated SQL cleanly addresses the 'how does it compare' aspect of the question.", "overall_assessment": "differently_correct"}}
{"example_id": 3276, "sql_complexity": "basic SQL", "prompt": "What is the total energy consumption of the Chemical Plant B in the last quarter?", "context": "CREATE TABLE EnergyConsumption (EnergyID INT, Plant VARCHAR(255), EnergyQuantity DECIMAL(5,2), Timestamp DATETIME);", "reference_sql": "SELECT SUM(EnergyQuantity) FROM EnergyConsumption WHERE Plant = 'Chemical Plant B' AND Timestamp BETWEEN DATE_SUB(CURRENT_DATE(), INTERVAL 3 MONTH) AND CURRENT_DATE();", "generated_sql": "SELECT SUM(EnergyQuantity) AS total_energy_consumption\nFROM EnergyConsumption\nWHERE Plant = 'Chemical Plant B' AND Timestamp >= DATE_SUB(CURRENT_DATE, INTERVAL 3 MONTH);", "raw_model_output": "\n\n```sql\nSELECT SUM(EnergyQuantity) AS total_energy_consumption\nFROM EnergyConsumption\nWHERE Plant = 'Chemical Plant B' AND Timestamp >= DATE_SUB(CURRENT_DATE, INTERVAL 3 MONTH);\n```", "latency_sec": 0.40524792671203613, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 799, "prompt_eval_sec": null, "tokens_completion": 49, "completion_eval_sec": null, "tokens_total": 848, "tokens_per_sec": 2092.546177546709, "retrieval_latency_sec": 0.10675883293151855, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses BETWEEN with CURRENT_DATE() (which is a date, not datetime) as the upper bound, while the Generated SQL only has a lower bound. The Generated SQL's DATE_SUB(CURRENT_DATE, INTERVAL 3 MONTH) is missing parentheses around CURRENT_DATE (assuming it's a function), and the upper bound is not enforced. This means the Generated SQL could include records from the current day's datetime range, whereas the Reference SQL only includes up to the start of the current date.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query is technically correct and semantically precise. The generated query has two issues: 1) It uses CURRENT_DATE without parentheses (invalid syntax in MySQL) and 2) It uses a single comparison (>=) instead of BETWEEN, which might exclude records from the current day if Timestamp is a DATETIME type. The reference query correctly captures the full last quarter by including both endpoints of the date range. Both queries address the business intent, but the reference is more accurate in time range calculation.", "overall_assessment": "correct"}}
{"example_id": 3074, "sql_complexity": "multiple_joins", "prompt": "Find the top 5 players with the highest scores in the 'historical_tournaments' view, including their scores and the names of the tournaments they participated in.", "context": "CREATE VIEW historical_tournaments AS SELECT tournaments.tournament_name, players.player_name, players.score FROM tournaments JOIN players_scores ON tournaments.tournament_id = players_scores.tournament_id JOIN players ON players_scores.player_id = players.player_id;  CREATE TABLE tournaments (tournament_id INT, tournament_name TEXT);  CREATE TABLE players_scores (player_id INT, tournament_id INT, score INT);  CREATE TABLE players (player_id INT, player_name TEXT);", "reference_sql": "SELECT players.player_name, MAX(players_scores.score) as high_score, tournaments.tournament_name FROM historical_tournaments JOIN players ON historical_tournaments.player_id = players.player_id JOIN players_scores ON historical_tournaments.player_id = players_scores.player_id JOIN tournaments ON players_scores.tournament_id = tournaments.tournament_id GROUP BY players.player_id, tournaments.tournament_name ORDER BY high_score DESC LIMIT 5;", "generated_sql": "SELECT player_name, tournament_name, score\nFROM historical_tournaments\nORDER BY score DESC\nLIMIT 5;", "raw_model_output": "\n\n```sql\nSELECT player_name, tournament_name, score\nFROM historical_tournaments\nORDER BY score DESC\nLIMIT 5;\n```", "latency_sec": 0.3413667678833008, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 999, "prompt_eval_sec": null, "tokens_completion": 32, "completion_eval_sec": null, "tokens_total": 1031, "tokens_per_sec": 3020.211974331539, "retrieval_latency_sec": 0.11213397979736328, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the maximum score per player-tournament combination and orders by that maximum score, while the Generated SQL simply retrieves the top 5 scores from the view without aggregation. The Reference SQL groups by player_id and tournament_name to find individual high scores, whereas the Generated SQL returns raw score entries without grouping, leading to different result sets.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL contains logical errors: it redundantly joins tables already included in the view, groups by tournament_name (which could split a player's scores across tournaments), and uses MAX(score) unnecessarily since the view already contains per-tournament scores. The Generated SQL is syntactically correct and directly accesses the view, but it fails to aggregate players' highest scores (a player could appear multiple times if they have multiple high scores). Neither query fully meets the intent, but the Generated SQL is more efficient and elegant, while the Reference SQL's structure is flawed.", "overall_assessment": "differently_correct"}}
{"example_id": 2219, "sql_complexity": "window functions", "prompt": "What is the average population of cities with a UNESCO World Heritage designation, ordered by designation date?", "context": "CREATE TABLE cities (name VARCHAR(255), population INT, designation_date DATE); INSERT INTO cities (name, population, designation_date) VALUES ('Paris', 2141000, '1991-09-16'); INSERT INTO cities (name, population, designation_date) VALUES ('Rio de Janeiro', 6727000, '2012-07-01');", "reference_sql": "SELECT AVG(population) FROM (SELECT population, ROW_NUMBER() OVER (ORDER BY designation_date) rn FROM cities WHERE name IN (SELECT name FROM heritagesites)) t WHERE rn % 2 = 1;", "generated_sql": "SELECT AVG(population) AS average_population\nFROM cities\nORDER BY designation_date;", "raw_model_output": "\n\nTo answer the question \"What is the average population of cities with a UNESCO World Heritage designation, ordered by designation date?\" we need to assume that the `cities` table contains cities with UNESCO World Heritage designations. However, the schema provided does not include any explicit reference to UNESCO World Heritage designations.\n\nGiven the lack of a direct link between cities and UNESCO designations in the schema, we can only assume that the cities listed in the `cities` table are already UNESCO World Heritage sites. Based on this assumption, the SQL query would be:\n\n```sql\nSELECT AVG(population) AS average_population\nFROM cities\nORDER BY designation_date;\n```", "latency_sec": 0.9618549346923828, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 985, "prompt_eval_sec": null, "tokens_completion": 136, "completion_eval_sec": null, "tokens_total": 1121, "tokens_per_sec": 1165.4564109072378, "retrieval_latency_sec": 0.1094670295715332, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the average of populations from cities in heritagesites, filtered by odd row numbers ordered by designation_date. The Generated SQL computes the average of all cities' populations without any filtering or row-number logic. The presence of the heritagesites subquery and row-number filtering in the Reference SQL makes it fundamentally different from the Generated SQL, which lacks these conditions. Additionally, the Generated SQL's ORDER BY clause has no effect on the AVG calculation.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query attempts to filter cities with UNESCO designations (assuming 'heritagesites' exists) but introduces unnecessary complexity with ROW_NUMBER() and rn%2=1, which is unrelated to the original question. The generated query lacks any filtering for UNESCO designations entirely, making it fundamentally incorrect. While both queries fail to meet the requirements, the reference query at least addresses the filtering aspect (assuming 'heritagesites' is valid), whereas the generated query completely ignores the designation requirement. The reference query's row-number logic is irrelevant to the average calculation, but the generated query's absence of filtering makes it worse.", "overall_assessment": "incorrect"}}
{"example_id": 3786, "sql_complexity": "aggregation", "prompt": "Display the names and average co-owner percentages for all properties in the 'property_coownership' table where the co-owner percentage is greater than 60.", "context": "CREATE TABLE property_coownership (property_id INT, owner VARCHAR(255), percentage INT); INSERT INTO property_coownership (property_id, owner, percentage) VALUES (1, 'Mohammed', 70), (1, 'Fatima', 30), (2, 'Jamal', 65), (2, 'Aisha', 35), (3, 'Ali', 75), (3, 'Khadija', 25);", "reference_sql": "SELECT owner, AVG(percentage) FROM property_coownership WHERE percentage > 60 GROUP BY owner;", "generated_sql": "SELECT owner, AVG(percentage) FROM property_coownership WHERE percentage > 60 GROUP BY owner;", "raw_model_output": "\n\nSELECT owner, AVG(percentage) FROM property_coownership WHERE percentage > 60 GROUP BY owner;", "latency_sec": 0.3699760437011719, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 909, "prompt_eval_sec": null, "tokens_completion": 26, "completion_eval_sec": null, "tokens_total": 935, "tokens_per_sec": 2527.190654417602, "retrieval_latency_sec": 0.10626816749572754, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure and logic. Both queries select 'owner' and the average 'percentage' from the property_coownership table where 'percentage' > 60, grouped by 'owner'. Since they are exactly the same, they will produce identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": false, "superiority": "equal", "explanation": "The queries are technically identical and would produce the same results. However, they do not fully fulfill the business intent. The original question asks for 'average co-owner percentages for all properties' where percentages exceed 60, but the query groups by 'owner' instead of 'property_id'. This groups averages by individual owners (e.g., Mohammed's 70%) rather than calculating property-level averages (e.g., property 1's average of 50% if including both co-owners). The WHERE clause filters rows with percentages >60 but does not address the property-level aggregation required by the question.", "overall_assessment": "differently_correct"}}
{"example_id": 2357, "sql_complexity": "basic SQL", "prompt": "What is the total amount of climate finance invested in renewable energy projects by public and private sectors in Africa?", "context": "CREATE TABLE renewable_energy_projects (project_id INT, sector TEXT, investor_type TEXT, region TEXT, amount FLOAT); INSERT INTO renewable_energy_projects (project_id, sector, investor_type, region, amount) VALUES (1, 'Renewable Energy', 'Public', 'Africa', 5000000); INSERT INTO renewable_energy_projects (project_id, sector, investor_type, region, amount) VALUES (2, 'Renewable Energy', 'Private', 'Africa', 7000000);", "reference_sql": "SELECT SUM(amount) FROM renewable_energy_projects WHERE sector = 'Renewable Energy' AND region = 'Africa';", "generated_sql": "SELECT SUM(amount) FROM renewable_energy_projects WHERE region = 'Africa' AND investor_type IN ('Public', 'Private');", "raw_model_output": "\n\nSELECT SUM(amount) FROM renewable_energy_projects WHERE region = 'Africa' AND investor_type IN ('Public', 'Private');", "latency_sec": 0.27721190452575684, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 817, "prompt_eval_sec": null, "tokens_completion": 29, "completion_eval_sec": null, "tokens_total": 846, "tokens_per_sec": 3051.816989776479, "retrieval_latency_sec": 0.10309481620788574, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL filters by both 'sector = 'Renewable Energy'' and 'region = 'Africa'', while the Generated SQL filters by 'region = 'Africa'' and 'investor_type IN ('Public', 'Private')'. Although the sample data coincidentally produces the same result, the Generated SQL could include additional rows from other sectors in Africa with Public/Private investors, making them non-equivalent in general.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries are not technically equivalent. The Reference SQL filters on 'sector = 'Renewable Energy'' and 'region = 'Africa'', but omits the 'investor_type' condition. The Generated SQL filters on 'region = 'Africa'' and 'investor_type IN ('Public', 'Private')', but omits the 'sector' condition. While both queries include partial constraints from the original question, they miss one critical filter each. The Reference SQL risks including non-renewable energy projects (if any exist in the table), while the Generated SQL risks including projects outside the renewable energy sector (if any exist). However, the Generated SQL better addresses the 'public and private sectors' requirement, which is explicitly mentioned in the question. The Reference SQL's focus on the sector aligns with the 'renewable energy projects' part, but the question explicitly requires both sector and investor type constraints. Neither query fully satisfies the intent, but the Generated SQL is more aligned with the investor type requirement.", "overall_assessment": "differently_correct"}}
{"example_id": 1009, "sql_complexity": "multiple_joins", "prompt": "Find the number of IoT sensors installed in each farm that use Sprinkler irrigation.", "context": "CREATE TABLE IoT_Sensors (id INT, sensor_type VARCHAR(50), Farm_id INT); INSERT INTO IoT_Sensors (id, sensor_type, Farm_id) VALUES (1, 'Soil Moisture', 1), (2, 'Temperature', 1), (3, 'Humidity', 2); CREATE TABLE Irrigation (id INT, Farm_id INT, irrigation_type VARCHAR(50), duration INT); INSERT INTO Irrigation (id, Farm_id, irrigation_type, duration) VALUES (1, 1, 'Sprinkler', 30), (2, 2, 'Drip', 45);", "reference_sql": "SELECT f.id, COUNT(s.id) FROM Farmers f JOIN Irrigation i ON f.id = i.Farm_id JOIN IoT_Sensors s ON f.id = s.Farm_id WHERE i.irrigation_type = 'Sprinkler' GROUP BY f.id;", "generated_sql": "SELECT i.Farm_id, COUNT(ios.id) AS num_sensors\nFROM IoT_Sensors ios\nJOIN Irrigation i ON ios.Farm_id = i.Farm_id\nWHERE i.irrigation_type = 'Sprinkler'\nGROUP BY i.Farm_id;", "raw_model_output": "\n\nSELECT i.Farm_id, COUNT(ios.id) AS num_sensors\nFROM IoT_Sensors ios\nJOIN Irrigation i ON ios.Farm_id = i.Farm_id\nWHERE i.irrigation_type = 'Sprinkler'\nGROUP BY i.Farm_id;", "latency_sec": 0.5780019760131836, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 868, "prompt_eval_sec": null, "tokens_completion": 61, "completion_eval_sec": null, "tokens_total": 929, "tokens_per_sec": 1607.2609412304337, "retrieval_latency_sec": 0.10703587532043457, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of IoT sensors per Farm_id where irrigation_type is 'Sprinkler'. The Reference SQL uses Farmers.f.id and joins with Irrigation and IoT_Sensors, while the Generated SQL directly joins IoT_Sensors and Irrigation on Farm_id. Since Farm_id in both tables corresponds to Farmers.id, the grouping and counting logic are equivalent. The result sets will have the same Farm_id values and sensor counts, despite different column aliases.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query references a 'Farmers' table that does not exist in the provided schema, making it technically invalid. The generated query correctly uses the available tables (IoT_Sensors and Irrigation) and properly joins on Farm_id. Both queries aim to count IoT sensors per farm with Sprinkler irrigation, but the generated query is syntactically correct and aligns with the schema. The reference query would fail due to the non-existent table, while the generated query executes successfully.", "overall_assessment": "incorrect"}}
{"example_id": 4217, "sql_complexity": "subqueries", "prompt": "Show consumer preference data for foundations, excluding products from the USA.", "context": "CREATE TABLE cosmetics (product_id INT, product_name VARCHAR(100), product_type VARCHAR(50), is_cruelty_free BOOLEAN, consumer_preference_score INT); INSERT INTO cosmetics (product_id, product_name, product_type, is_cruelty_free, consumer_preference_score) VALUES (1, 'Lipstick A', 'Lipstick', TRUE, 80), (2, 'Foundation B', 'Foundation', FALSE, 90), (3, 'Mascara C', 'Mascara', TRUE, 85), (4, 'Eyeshadow D', 'Eyeshadow', TRUE, 70), (5, 'Blush E', 'Blush', FALSE, 95); CREATE TABLE ingredient_sourcing (ingredient_id INT, ingredient_name VARCHAR(100), sourcing_country VARCHAR(50), is_organic BOOLEAN); INSERT INTO ingredient_sourcing (ingredient_id, ingredient_name, sourcing_country, is_organic) VALUES (1, 'Rosehip Oil', 'Chile', TRUE), (2, 'Shea Butter', 'Ghana', TRUE), (3, 'Jojoba Oil', 'India', TRUE), (4, 'Coconut Oil', 'Philippines', FALSE), (5, 'Aloe Vera', 'USA', TRUE);", "reference_sql": "SELECT * FROM cosmetics WHERE product_type = 'Foundation' AND product_id NOT IN (SELECT cosmetics.product_id FROM cosmetics INNER JOIN ingredient_sourcing ON cosmetics.product_id = ingredient_sourcing.ingredient_id WHERE ingredient_sourcing.sourcing_country = 'USA');", "generated_sql": "SELECT product_name, consumer_preference_score \nFROM cosmetics \nWHERE product_type = 'Foundation' \nAND product_id NOT IN (SELECT product_id FROM cosmetics WHERE product_name IN (SELECT product_name FROM cosmetics WHERE sourcing_country = 'USA'));", "raw_model_output": "\n\nSELECT product_name, consumer_preference_score \nFROM cosmetics \nWHERE product_type = 'Foundation' \nAND product_id NOT IN (SELECT product_id FROM cosmetics WHERE product_name IN (SELECT product_name FROM cosmetics WHERE sourcing_country = 'USA'));", "latency_sec": 0.533789873123169, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 976, "prompt_eval_sec": null, "tokens_completion": 52, "completion_eval_sec": null, "tokens_total": 1028, "tokens_per_sec": 1925.851447846398, "retrieval_latency_sec": 0.10576915740966797, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL correctly joins cosmetics with ingredient_sourcing on product_id = ingredient_id to filter by sourcing_country = 'USA'. The Generated SQL incorrectly references sourcing_country in the cosmetics table (which doesn't exist) and uses a flawed subquery structure. The Generated SQL would either fail (due to invalid column) or return different results by mistakenly filtering on product_name instead of ingredient sourcing.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent. The Reference SQL is syntactically valid but contains a logical flaw: it incorrectly joins cosmetics.product_id with ingredient_sourcing.ingredient_id (which are unrelated entities). The Generated SQL contains a critical syntax error by referencing sourcing_country in the cosmetics table, which does not exist. Neither query properly addresses the business intent of excluding products with USA-sourced ingredients, as the schema lacks a direct product-ingredient relationship. However, the Reference SQL is syntactically correct while the Generated SQL is invalid.", "overall_assessment": "incorrect"}}
{"example_id": 5620, "sql_complexity": "basic SQL", "prompt": "What is the recycling rate of plastic in the residential sector in the state of New York?", "context": "CREATE TABLE recycling_rates_city (sector VARCHAR(20), city VARCHAR(20), material VARCHAR(20), recycling_rate DECIMAL(5,2)); INSERT INTO recycling_rates_city (sector, city, material, recycling_rate) VALUES ('residential', 'New York City', 'plastic', 0.25), ('commercial', 'New York City', 'plastic', 0.30), ('residential', 'New York City', 'paper', 0.45), ('commercial', 'New York City', 'paper', 0.50), ('residential', 'Los Angeles', 'plastic', 0.20), ('commercial', 'Los Angeles', 'plastic', 0.35), ('residential', 'Los Angeles', 'paper', 0.40), ('commercial', 'Los Angeles', 'paper', 0.50);", "reference_sql": "SELECT recycling_rate FROM recycling_rates_city WHERE sector = 'residential' AND material = 'plastic' AND city = 'New York City';", "generated_sql": "SELECT recycling_rate FROM recycling_rates_city WHERE sector = 'residential' AND city = 'New York City' AND material = 'plastic';", "raw_model_output": "\n\nSQL: SELECT recycling_rate FROM recycling_rates_city WHERE sector = 'residential' AND city = 'New York City' AND material = 'plastic';", "latency_sec": 0.4241459369659424, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1049, "prompt_eval_sec": null, "tokens_completion": 36, "completion_eval_sec": null, "tokens_total": 1085, "tokens_per_sec": 2558.081795528604, "retrieval_latency_sec": 0.10402679443359375, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The order of conditions in the WHERE clause does not affect the result. Both queries filter for 'residential' sector, 'plastic' material, and 'New York City' city, producing identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are syntactically correct and semantically equivalent. The WHERE clause conditions are logically identical despite different ordering. Both correctly filter for 'residential' sector, 'plastic' material, and 'New York City' as required by the business question. The queries would return the same result (0.25) from the sample data. Neither query is more efficient than the other since SQL query optimizers typically reorder conditions automatically. The generated query's condition ordering (city first) might be slightly more readable but this is subjective.", "overall_assessment": "correct"}}
{"example_id": 3151, "sql_complexity": "basic SQL", "prompt": "List all biotech startups that received funding in 2022 and their respective funding amounts.", "context": "CREATE TABLE biotech_startups (name TEXT, funding FLOAT, date DATE); INSERT INTO biotech_startups (name, funding, date) VALUES ('StartupA', 3500000, '2022-02-28'); INSERT INTO biotech_startups (name, funding, date) VALUES ('StartupB', 4500000, '2022-07-12');", "reference_sql": "SELECT name, funding FROM biotech_startups WHERE date BETWEEN '2022-01-01' AND '2022-12-31';", "generated_sql": "SELECT name, funding FROM biotech_startups WHERE date BETWEEN '2022-01-01' AND '2022-12-31';", "raw_model_output": "\n\nSELECT name, funding FROM biotech_startups WHERE date BETWEEN '2022-01-01' AND '2022-12-31';", "latency_sec": 0.3600180149078369, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 911, "prompt_eval_sec": null, "tokens_completion": 42, "completion_eval_sec": null, "tokens_total": 953, "tokens_per_sec": 2647.0897581165873, "retrieval_latency_sec": 0.10570502281188965, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure and logic. Both select the same columns (name, funding) from the biotech_startups table where the date falls between '2022-01-01' and '2022-12-31'. Since the queries are exactly the same, they will produce identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic. They correctly select name and funding from the biotech_startups table where the date falls within the 2022 range. The WHERE clause using BETWEEN '2022-01-01' AND '2022-12-31' accurately captures all funding events in 2022. The queries technically and semantically match, fulfilling the business intent of listing 2022 biotech startup funding. Since the reference and generated queries are identical, neither is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 2136, "sql_complexity": "window functions", "prompt": "What is the total military equipment sales revenue for each sales representative by fiscal year?", "context": "CREATE TABLE SalesReps (SalesRepID INT, SalesRepName VARCHAR(50), FiscalYear INT, Revenue DECIMAL(10,2)); INSERT INTO SalesReps (SalesRepID, SalesRepName, FiscalYear, Revenue) VALUES (1, 'John Doe', 2020, 150000.00), (2, 'Jane Smith', 2020, 200000.00), (1, 'John Doe', 2021, 180000.00), (2, 'Jane Smith', 2021, 250000.00);", "reference_sql": "SELECT SalesRepName, FiscalYear, SUM(Revenue) OVER (PARTITION BY SalesRepName ORDER BY FiscalYear) AS TotalRevenue FROM SalesReps;", "generated_sql": "SELECT SalesRepName, FiscalYear, SUM(Revenue) FROM SalesReps GROUP BY SalesRepName, FiscalYear;", "raw_model_output": "\n\nSQL: SELECT SalesRepName, FiscalYear, SUM(Revenue) FROM SalesReps GROUP BY SalesRepName, FiscalYear;", "latency_sec": 0.29699110984802246, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 814, "prompt_eval_sec": null, "tokens_completion": 32, "completion_eval_sec": null, "tokens_total": 846, "tokens_per_sec": 2848.5701152230404, "retrieval_latency_sec": 0.10533499717712402, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates a cumulative running total of Revenue per SalesRepName ordered by FiscalYear using a window function, while the Generated SQL aggregates Revenue by grouping exactly on SalesRepName and FiscalYear. The window function produces progressive sums (e.g., 2020: 150000, 2021: 150000+180000=330000 for John Doe), whereas the GROUP BY version returns individual year totals (e.g., 2020: 150000, 2021: 180000). The results differ in the calculated 'TotalRevenue' column.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL uses a window function to calculate a running total per sales representative across fiscal years (e.g., 2020: 150000, 2021: 150000+180000=330000), while the Generated SQL correctly aggregates revenue by SalesRepName and FiscalYear (e.g., 2020: 150000, 2021: 180000). The original question requires per-year totals, not cumulative sums. The Generated SQL is technically correct, while the Reference SQL misrepresents the data by showing running totals instead of standalone yearly revenues.", "overall_assessment": "incorrect"}}
{"example_id": 5452, "sql_complexity": "basic SQL", "prompt": "What is the name of the farms with a size greater than 150 acres located in 'Texas'?", "context": "CREATE TABLE farms (id INT PRIMARY KEY, name VARCHAR(50), size INT, location VARCHAR(50)); INSERT INTO farms (id, name, size, location) VALUES (1, 'Smith Farms', 200, 'Texas'), (2, 'Johnson Farms', 100, 'California');", "reference_sql": "SELECT name FROM farms WHERE size > 150 AND location = 'Texas'", "generated_sql": "SELECT name FROM farms WHERE size > 150 AND location = 'Texas';", "raw_model_output": "\n\nSELECT name FROM farms WHERE size > 150 AND location = 'Texas';", "latency_sec": 0.23452115058898926, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1033, "prompt_eval_sec": null, "tokens_completion": 22, "completion_eval_sec": null, "tokens_total": 1055, "tokens_per_sec": 4498.52815982872, "retrieval_latency_sec": 0.1115572452545166, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical except for the trailing semicolon in the generated SQL. Semicolons are statement terminators in SQL and do not affect the query's logic or result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic, with the only difference being the presence of a semicolon at the end of the generated SQL. The semicolon is a statement terminator in SQL and does not affect the query's execution or results. Both queries correctly filter farms with size > 150 acres in Texas, fulfilling the business intent. Neither query is more efficient or elegant than the other, as they perform the same operation with identical syntax except for the semicolon.", "overall_assessment": "correct"}}
{"example_id": 5152, "sql_complexity": "aggregation", "prompt": "How many international tourists visited Portugal in 2020, broken down by continent?", "context": "CREATE TABLE international_tourists(tourist_id INT, country TEXT, arrival_year INT, continent TEXT);INSERT INTO international_tourists (tourist_id, country, arrival_year, continent) VALUES (1, 'Spain', 2020, 'Europe'), (2, 'France', 2020, 'Europe'), (3, 'Brazil', 2020, 'South America'), (4, 'United States', 2020, 'North America'), (5, 'China', 2020, 'Asia');", "reference_sql": "SELECT continent, COUNT(*) FROM international_tourists WHERE arrival_year = 2020 GROUP BY continent;", "generated_sql": "SELECT continent, COUNT(*) AS num_tourists FROM international_tourists WHERE country = 'Portugal' AND arrival_year = 2020 GROUP BY continent;", "raw_model_output": "\n\nSQL: SELECT continent, COUNT(*) AS num_tourists FROM international_tourists WHERE country = 'Portugal' AND arrival_year = 2020 GROUP BY continent;", "latency_sec": 0.35784101486206055, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 930, "prompt_eval_sec": null, "tokens_completion": 42, "completion_eval_sec": null, "tokens_total": 972, "tokens_per_sec": 2716.290083110466, "retrieval_latency_sec": 0.10689687728881836, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query counts all tourists from 2020 grouped by continent, while the generated query adds a WHERE condition (country = 'Portugal') which filters out all rows (since no tourists from Portugal exist in the data). This makes the generated query return an empty result, whereas the reference query returns counts per continent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly addresses the question by counting all international tourists who arrived in 2020 (without filtering by country), grouping them by continent. The Generated SQL incorrectly filters for tourists from 'Portugal' (country = 'Portugal'), which would count domestic tourists rather than international visitors to Portugal. Since the question asks for international tourists visiting Portugal, the Generated SQL fails to fulfill the business intent by excluding all tourists except those from Portugal. The Reference SQL, while not explicitly filtering for Portugal, assumes the table contains only tourists visiting Portugal (as implied by the table name 'international_tourists').", "overall_assessment": "incorrect"}}
{"example_id": 2477, "sql_complexity": "set operations", "prompt": "What is the carbon price in Europe and Australia for the last quarter of 2020?", "context": "CREATE TABLE CarbonPrices (Country TEXT, Year INT, Quarter INT, CarbonPrice NUMBER); INSERT INTO CarbonPrices (Country, Year, Quarter, CarbonPrice) VALUES ('Europe', 2020, 4, 25), ('Australia', 2020, 4, 15); CREATE TABLE CarbonTaxes (Country TEXT, Year INT, Quarter INT, CarbonPrice NUMBER); INSERT INTO CarbonTaxes (Country, Year, Quarter, CarbonPrice) VALUES ('Europe', 2019, 4, 20), ('Australia', 2019, 4, 10);", "reference_sql": "SELECT Context.Country, Context.CarbonPrice FROM ( SELECT * FROM CarbonPrices WHERE CarbonPrices.Country IN ('Europe', 'Australia') AND CarbonPrices.Year = 2020 AND CarbonPrices.Quarter = 4 UNION SELECT * FROM CarbonTaxes WHERE CarbonTaxes.Country IN ('Europe', 'Australia') AND CarbonTaxes.Year = 2020 AND CarbonTaxes.Quarter = 4 ) AS Context;", "generated_sql": "SELECT Country, Year, Quarter, CarbonPrice \nFROM CarbonPrices \nWHERE Country IN ('Europe', 'Australia') AND Year = 2020 AND Quarter = 4;", "raw_model_output": "\n\nSELECT Country, Year, Quarter, CarbonPrice \nFROM CarbonPrices \nWHERE Country IN ('Europe', 'Australia') AND Year = 2020 AND Quarter = 4;", "latency_sec": 0.4192819595336914, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 827, "prompt_eval_sec": null, "tokens_completion": 42, "completion_eval_sec": null, "tokens_total": 869, "tokens_per_sec": 2072.5909623358634, "retrieval_latency_sec": 0.10756301879882812, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL combines data from both CarbonPrices and CarbonTaxes tables using UNION, but the Generated SQL only queries CarbonPrices. Although the CarbonTaxes part of the Reference SQL would return no rows (since its data is for 2019, not 2020), the Generated SQL includes additional columns (Year, Quarter) not present in the Reference SQL's output. The result sets have different structures, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query combines data from both CarbonPrices and CarbonTaxes tables using UNION, while the generated query only selects from CarbonPrices. Semantically, the original question asks for 'carbon price' which aligns with the CarbonPrices table. The reference query risks including carbon tax data (from CarbonTaxes) which is a different metric. The generated query directly addresses the business intent by retrieving the correct data from the appropriate table. The generated query is also more efficient as it avoids unnecessary UNION operations and explicitly selects only the required columns.", "overall_assessment": "correct"}}
{"example_id": 4573, "sql_complexity": "subqueries", "prompt": "Find the names of all the indigenous communities in the 'Arctic_Communities' table that have a population size greater than the average population size in the 'Antarctic_Communities' table.", "context": "CREATE TABLE Arctic_Communities (name TEXT, population INTEGER); CREATE TABLE Antarctic_Communities (name TEXT, population INTEGER);", "reference_sql": "SELECT name FROM Arctic_Communities WHERE Arctic_Communities.population > (SELECT AVG(population) FROM Antarctic_Communities)", "generated_sql": "SQL: SELECT name FROM Arctic_Communities WHERE Arctic_Communities.population > (SELECT AVG(population) FROM Antarctic_Communities)", "raw_model_output": "\n\nSQL: SELECT name FROM Arctic_Communities WHERE Arctic_Communities.population > (SELECT AVG(population) FROM Antarctic_Communities)", "latency_sec": 0.38866400718688965, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 648, "prompt_eval_sec": null, "tokens_completion": 30, "completion_eval_sec": null, "tokens_total": 678, "tokens_per_sec": 1744.4373223733649, "retrieval_latency_sec": 0.11101698875427246, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure, table names, conditions, and subquery logic. Both queries select names from Arctic_Communities where population exceeds the average population of Antarctic_Communities, producing the same result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic. They correctly calculate the average population from Antarctic_Communities using a subquery and compare it to Arctic_Communities' population. The syntax is valid, the semantics align with the business question, and both queries would produce identical results. Neither query demonstrates superior efficiency or elegance since they are functionally identical.", "overall_assessment": "correct"}}
{"example_id": 3596, "sql_complexity": "window functions", "prompt": "What is the total revenue for each game in the \"Gaming\" category?", "context": "CREATE TABLE Games (GameID int, GameName varchar(50), Category varchar(50), Revenue decimal(10,2));", "reference_sql": "SELECT Category, SUM(Revenue) OVER(PARTITION BY Category) as TotalRevenue FROM Games;", "generated_sql": "SELECT GameName, Revenue AS TotalRevenue FROM Games WHERE Category = 'Gaming';", "raw_model_output": "\n\nSELECT GameName, Revenue AS TotalRevenue FROM Games WHERE Category = 'Gaming';", "latency_sec": 0.23222708702087402, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 819, "prompt_eval_sec": null, "tokens_completion": 22, "completion_eval_sec": null, "tokens_total": 841, "tokens_per_sec": 3621.455234997654, "retrieval_latency_sec": 0.1048591136932373, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates total revenue per category using a window function, while the generated query selects individual game records from a specific category without aggregation. The output columns and semantics differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL calculates a window function that repeats the same category total for every row, which doesn't isolate individual game revenues. The Generated SQL correctly filters games in the 'Gaming' category but misrepresents 'TotalRevenue' as individual game revenue rather than aggregating it. Neither query properly addresses the ambiguous question: if the goal is per-game revenue, the Generated SQL is closer but mislabels the column. If the goal is total category revenue, both fail. However, the Generated SQL better aligns with the literal 'each game' phrasing by returning individual game records.", "overall_assessment": "differently_correct"}}
{"example_id": 5039, "sql_complexity": "subqueries", "prompt": "What is the total number of community policing events in 'City Park' in 2021?", "context": "CREATE TABLE locations (id INT, name VARCHAR(255)); CREATE TABLE community_policing (id INT, location_id INT, year INT, events INT); INSERT INTO locations (id, name) VALUES (1, 'City Park'); INSERT INTO community_policing (id, location_id, year, events) VALUES (1, 1, 2021, 5);", "reference_sql": "SELECT SUM(events) FROM community_policing WHERE location_id = (SELECT id FROM locations WHERE name = 'City Park') AND year = 2021;", "generated_sql": "SELECT SUM(cp.events) \nFROM community_policing cp \nJOIN locations l ON cp.location_id = l.id \nWHERE l.name = 'City Park' AND cp.year = 2021;", "raw_model_output": "\n\nSELECT SUM(cp.events) \nFROM community_policing cp \nJOIN locations l ON cp.location_id = l.id \nWHERE l.name = 'City Park' AND cp.year = 2021;", "latency_sec": 0.3926248550415039, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 801, "prompt_eval_sec": null, "tokens_completion": 47, "completion_eval_sec": null, "tokens_total": 848, "tokens_per_sec": 2159.8225102441843, "retrieval_latency_sec": 0.10580587387084961, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of events for 'City Park' in 2021. The reference uses a subquery to get the location_id, while the generated query uses a JOIN. Both filter the same conditions (location name and year) and aggregate the same column. Since the location name is unique, they produce identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the total community policing events in 'City Park' for 2021. The reference query uses a subquery to get location_id, while the generated query uses an explicit JOIN. Both produce identical results and address the business question. The generated query is more scalable and readable, as JOINs are generally preferred for clarity and performance with larger datasets. The reference query might fail if multiple locations had the same name, but the schema's primary key constraint on locations.id ensures uniqueness here. Both are correct, but the generated version demonstrates better SQL practices.", "overall_assessment": "correct"}}
{"example_id": 2724, "sql_complexity": "basic SQL", "prompt": "What is the earliest installation date for solar panels in Italy?", "context": "CREATE TABLE solar_panels_italy (id INT, installation_date DATE); INSERT INTO solar_panels_italy (id, installation_date) VALUES (1, '2018-01-01'), (2, '2019-01-01'), (3, '2020-01-01');", "reference_sql": "SELECT MIN(installation_date) as earliest_date FROM solar_panels_italy;", "generated_sql": "SELECT MIN(installation_date) FROM solar_panels_italy;", "raw_model_output": "\n\nSELECT MIN(installation_date) FROM solar_panels_italy;", "latency_sec": 0.21981310844421387, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 758, "prompt_eval_sec": null, "tokens_completion": 20, "completion_eval_sec": null, "tokens_total": 778, "tokens_per_sec": 3539.370356511053, "retrieval_latency_sec": 0.1086728572845459, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the minimum installation_date from the solar_panels_italy table. The only difference is the column alias ('earliest_date' vs. no alias), which does not affect the semantic result set. The actual data returned (the earliest date) remains identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly retrieve the earliest installation date using MIN(installation_date). The reference query adds an explicit alias (earliest_date) while the generated query omits it, but this doesn't affect the result. Both achieve the business goal of finding the minimum date. The queries are equally efficient and semantically identical, as the alias is purely cosmetic and doesn't impact the output values.", "overall_assessment": "correct"}}
{"example_id": 2200, "sql_complexity": "single join", "prompt": "Which diversity programs are currently being participated in by employees in the HR department?", "context": "CREATE TABLE Employees (Employee_ID INT, First_Name VARCHAR(20), Last_Name VARCHAR(20), Department VARCHAR(20), Salary DECIMAL(10,2), Date_Hired DATE); CREATE TABLE Diversity_Programs (Program_ID INT, Program_Name VARCHAR(50), Participant_ID INT, Date_Started DATE, Date_Ended DATE);", "reference_sql": "SELECT dp.Program_Name FROM Diversity_Programs dp JOIN Employees e ON dp.Participant_ID = e.Employee_ID WHERE e.Department = 'HR' AND dp.Date_Ended IS NULL;", "generated_sql": "SELECT DISTINCT Program_Name \nFROM Diversity_Programs \nWHERE Participant_ID IN (\n    SELECT Employee_ID \n    FROM Employees \n    WHERE Department = 'HR'\n);", "raw_model_output": "\n\nSELECT DISTINCT Program_Name \nFROM Diversity_Programs \nWHERE Participant_ID IN (\n    SELECT Employee_ID \n    FROM Employees \n    WHERE Department = 'HR'\n);", "latency_sec": 0.33024120330810547, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 910, "prompt_eval_sec": null, "tokens_completion": 37, "completion_eval_sec": null, "tokens_total": 947, "tokens_per_sec": 2867.6009853212545, "retrieval_latency_sec": 0.11188602447509766, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query includes a condition where dp.Date_Ended IS NULL, which ensures only active programs are selected. The generated query lacks this condition, potentially returning programs with ended dates. Additionally, the generated query uses DISTINCT, while the reference query does not, leading to possible duplicate Program_Name entries in the reference result.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in two critical aspects. 1) The reference query correctly filters for currently active programs using `Date_Ended IS NULL`, while the generated query lacks this condition, potentially including terminated programs. 2) The reference query uses a JOIN to ensure a direct relationship between HR employees and their program participation, whereas the generated query uses a subquery that could return programs associated with HR employees even if they're not currently participating. While both queries aim to identify HR employee participation in diversity programs, the reference query more accurately reflects the business intent of identifying *current* participation. The generated query could return programs that are no longer active, thus not fully fulfilling the original question's requirements.", "overall_assessment": "differently_correct"}}
{"example_id": 4359, "sql_complexity": "window functions", "prompt": "Which destinations have the least hotel awards?", "context": "CREATE TABLE Destinations (destination_id INT, destination_name TEXT, country TEXT, awards INT); INSERT INTO Destinations (destination_id, destination_name, country, awards) VALUES (1, 'City A', 'Germany', 3), (2, 'City B', 'Switzerland', 5), (3, 'City C', 'Norway', 2);", "reference_sql": "SELECT destination_name, country, awards, RANK() OVER (PARTITION BY country ORDER BY awards ASC) AS rank FROM Destinations;", "generated_sql": "SELECT destination_name, country, awards FROM Destinations WHERE awards = (SELECT MIN(awards) FROM Destinations);", "raw_model_output": "\n\nSQL: SELECT destination_name, country, awards FROM Destinations WHERE awards = (SELECT MIN(awards) FROM Destinations);", "latency_sec": 0.3941359519958496, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 820, "prompt_eval_sec": null, "tokens_completion": 31, "completion_eval_sec": null, "tokens_total": 851, "tokens_per_sec": 2159.153448678443, "retrieval_latency_sec": 0.10998392105102539, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates ranks within country partitions using RANK(), returning all rows with their respective ranks. The Generated SQL filters to only include rows where awards equal the global minimum awards value. They differ in both output structure (all rows vs. subset) and logic (ranking vs. filtering).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query ranks destinations by awards within each country but does not filter for the minimum awards, while the generated query explicitly selects destinations with the minimum awards. The original question asks for destinations with 'the least hotel awards,' which requires identifying the minimum value and filtering results. The reference query provides ranking information but doesn't directly answer the question. The generated query correctly identifies destinations with the minimum awards, fulfilling the business intent. The generated query is more efficient as it avoids unnecessary window function computation.", "overall_assessment": "differently_correct"}}
{"example_id": 1373, "sql_complexity": "subqueries", "prompt": "What is the total value of military equipment sales to Africa in the last 12 months?", "context": "CREATE TABLE Military_Equipment_Sales(sale_id INT, sale_date DATE, equipment_type VARCHAR(50), country VARCHAR(50), sale_value DECIMAL(10,2));", "reference_sql": "SELECT SUM(sale_value) FROM Military_Equipment_Sales WHERE country IN (SELECT country FROM World_Countries WHERE continent = 'Africa') AND sale_date >= DATE_SUB(CURRENT_DATE, INTERVAL 12 MONTH);", "generated_sql": "SELECT SUM(sale_value) FROM Military_Equipment_Sales WHERE country = 'Africa' AND sale_date >= CURRENT_DATE - INTERVAL '12 months';", "raw_model_output": "\n\nSELECT SUM(sale_value) FROM Military_Equipment_Sales WHERE country = 'Africa' AND sale_date >= CURRENT_DATE - INTERVAL '12 months';", "latency_sec": 0.318361759185791, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 617, "prompt_eval_sec": null, "tokens_completion": 36, "completion_eval_sec": null, "tokens_total": 653, "tokens_per_sec": 2051.1257434625472, "retrieval_latency_sec": 0.10510706901550293, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their country filtering logic. The Reference SQL uses a subquery to select countries in Africa from World_Countries, while the Generated SQL incorrectly checks for country = 'Africa' (a single value). This would only match if 'Africa' was a valid country name, which is unlikely. The date conditions are equivalent, but the country conditions are not.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly identifies African countries via a subquery on World_Countries, ensuring accurate continent-based filtering. The Generated SQL incorrectly assumes 'Africa' is a valid country value in the country column, which is likely a continent name rather than a country. Both queries filter the last 12 months correctly, but the Generated SQL's country filter is fundamentally flawed. The Reference SQL better fulfills the business intent of aggregating sales to the African continent.", "overall_assessment": "differently_correct"}}
{"example_id": 904, "sql_complexity": "basic SQL", "prompt": "What is the minimum Shariah-compliant loan amount issued in the last quarter of 2021?", "context": "CREATE TABLE loans (id INT, amount DECIMAL, date DATE, loan_type VARCHAR); INSERT INTO loans (id, amount, date, loan_type) VALUES (1, 5000, '2021-09-05', 'Shariah-compliant'), (2, 7000, '2021-10-07', 'socially responsible'), (3, 9000, '2021-11-03', 'Shariah-compliant'), (4, 11000, '2021-12-31', 'Shariah-compliant');", "reference_sql": "SELECT MIN(amount) FROM loans WHERE EXTRACT(YEAR FROM date) = 2021 AND EXTRACT(QUARTER FROM date) = 4 AND loan_type = 'Shariah-compliant';", "generated_sql": "SELECT MIN(amount) FROM loans WHERE loan_type = 'Shariah-compliant' AND date BETWEEN '2021-10-01' AND '2021-12-31';", "raw_model_output": "\n\nSQL: SELECT MIN(amount) FROM loans WHERE loan_type = 'Shariah-compliant' AND date BETWEEN '2021-10-01' AND '2021-12-31';", "latency_sec": 0.4237220287322998, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 901, "prompt_eval_sec": null, "tokens_completion": 52, "completion_eval_sec": null, "tokens_total": 953, "tokens_per_sec": 2249.1160132769232, "retrieval_latency_sec": 0.1060631275177002, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter loans with 'Shariah-compliant' type and dates in the 4th quarter of 2021. The reference uses EXTRACT(YEAR) = 2021 and EXTRACT(QUARTER) = 4, while the generated query uses date BETWEEN '2021-10-01' AND '2021-12-31'. Since the 4th quarter of 2021 corresponds exactly to October-December 2021, the date conditions are equivalent. Both queries will return the same MIN(amount) value (9000) from the sample data.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify the minimum Shariah-compliant loan amount in Q4 2021. The reference query uses EXTRACT() to explicitly target the 4th quarter, while the generated query uses a date range (2021-10-01 to 2021-12-31) which also captures Q4. The date range approach is more efficient as it allows for potential index usage on the 'date' column, whereas EXTRACT() may require full table scans. Both produce identical results with the sample data, but the generated query is more optimized for performance.", "overall_assessment": "correct"}}
{"example_id": 3299, "sql_complexity": "set operations", "prompt": "How many schools and hospitals are there in Colombia and which ones need repairs?", "context": "CREATE TABLE schools (id INT, country VARCHAR(20), name VARCHAR(50), needs_repair BOOLEAN); CREATE TABLE hospitals (id INT, country VARCHAR(20), name VARCHAR(50), needs_repair BOOLEAN);", "reference_sql": "SELECT 'Schools' as facility_type, COUNT(*) as total, SUM(needs_repair) as repairs_needed FROM schools WHERE country = 'Colombia' UNION ALL SELECT 'Hospitals' as facility_type, COUNT(*) as total, SUM(needs_repair) as repairs_needed FROM hospitals WHERE country = 'Colombia';", "generated_sql": "SELECT \n    SUM(CASE WHEN s.country = 'Colombia' THEN 1 ELSE 0 END) AS total_schools,\n    SUM(CASE WHEN h.country = 'Colombia' THEN 1 ELSE 0 END) AS total_hospitals,\n    SUM(CASE WHEN s.country = 'Colombia' AND s.needs_repair THEN 1 ELSE 0 END) AS schools_needing_repair,\n    SUM(CASE WHEN h.country = 'Colombia' AND h.needs_repair THEN 1 ELSE 0 END) AS hospitals_needing_repair\nFROM schools s, hospitals h;", "raw_model_output": "\n\nSELECT \n    SUM(CASE WHEN s.country = 'Colombia' THEN 1 ELSE 0 END) AS total_schools,\n    SUM(CASE WHEN h.country = 'Colombia' THEN 1 ELSE 0 END) AS total_hospitals,\n    SUM(CASE WHEN s.country = 'Colombia' AND s.needs_repair THEN 1 ELSE 0 END) AS schools_needing_repair,\n    SUM(CASE WHEN h.country = 'Colombia' AND h.needs_repair THEN 1 ELSE 0 END) AS hospitals_needing_repair\nFROM schools s, hospitals h;", "latency_sec": 0.9917092323303223, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1130, "prompt_eval_sec": null, "tokens_completion": 135, "completion_eval_sec": null, "tokens_total": 1265, "tokens_per_sec": 1275.5755001165996, "retrieval_latency_sec": 0.10401391983032227, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query correctly calculates separate counts for schools and hospitals in Colombia using two independent SELECT statements with UNION ALL. The generated query performs a Cartesian product (cross join) between schools and hospitals, leading to inflated counts because each row from schools is combined with every row from hospitals. This causes the SUM calculations to multiply the actual counts by the number of rows in the opposite table, resulting in incorrect totals.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly separates schools and hospitals into distinct rows with accurate counts and repair metrics using UNION ALL. The Generated SQL incorrectly performs a Cartesian product between schools and hospitals (due to the implicit JOIN), leading to massively inflated counts. For example, if there are 100 schools and 50 hospitals, the Generated SQL would calculate 100*50 = 5000 schools and 100*50 = 5000 hospitals. The repair counts would also be incorrect due to this join. While both queries attempt to address the question, only the Reference SQL properly handles the data structure and business requirements.", "overall_assessment": "incorrect"}}
{"example_id": 907, "sql_complexity": "set operations", "prompt": "What is the total quantity of items with type 'E' or type 'F' in warehouse O and warehouse P?", "context": "CREATE TABLE warehouse_o(item_id INT, item_type VARCHAR(10), quantity INT);CREATE TABLE warehouse_p(item_id INT, item_type VARCHAR(10), quantity INT);INSERT INTO warehouse_o(item_id, item_type, quantity) VALUES (1, 'E', 200), (2, 'F', 300), (3, 'E', 50), (4, 'F', 400);INSERT INTO warehouse_p(item_id, item_type, quantity) VALUES (1, 'E', 150), (2, 'F', 250), (3, 'E', 40), (4, 'F', 350);", "reference_sql": "SELECT quantity FROM warehouse_o WHERE item_type IN ('E', 'F') UNION ALL SELECT quantity FROM warehouse_p WHERE item_type IN ('E', 'F');", "generated_sql": "SELECT SUM(quantity) FROM warehouse_o WHERE item_type IN ('E', 'F') UNION ALL SELECT SUM(quantity) FROM warehouse_p WHERE item_type IN ('E', 'F');", "raw_model_output": "\n\nSELECT SUM(quantity) FROM warehouse_o WHERE item_type IN ('E', 'F') UNION ALL SELECT SUM(quantity) FROM warehouse_p WHERE item_type IN ('E', 'F');", "latency_sec": 0.35430097579956055, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1075, "prompt_eval_sec": null, "tokens_completion": 41, "completion_eval_sec": null, "tokens_total": 1116, "tokens_per_sec": 3149.8643137561016, "retrieval_latency_sec": 0.1099851131439209, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns individual quantities from both tables, while the Generated SQL returns summed totals for each table. The Reference SQL's UNION ALL combines all individual rows (resulting in 8 rows of quantities), whereas the Generated SQL's SUM aggregates quantities per table (resulting in 2 rows of summed values). The output structures and data types differ fundamentally.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL returns individual quantities from both warehouses without aggregation, while the Generated SQL correctly sums quantities per warehouse. However, neither query calculates the total across both warehouses as required. The Generated SQL is superior because it aggregates quantities (though not combining both warehouses' totals into a single value). The original question requires a single total, which neither query achieves.", "overall_assessment": "incorrect"}}
{"example_id": 1400, "sql_complexity": "single join", "prompt": "What is the maximum co-ownership duration for properties in the neighborhood of 'Chinatown' in San Francisco?'", "context": "CREATE TABLE sf_neighborhoods (neighborhood_id INT, name VARCHAR(255), city VARCHAR(255)); INSERT INTO sf_neighborhoods (neighborhood_id, name, city) VALUES (1, 'Chinatown', 'San Francisco'); CREATE TABLE co_ownership (co_ownership_id INT, property_id INT, co_owner_id INT, start_date DATE, end_date DATE); INSERT INTO co_ownership (co_ownership_id, property_id, co_owner_id, start_date, end_date) VALUES (1, 1, 2, '2010-01-01', '2020-01-01'), (2, 2, 3, '2015-01-01', '2022-01-01'); CREATE TABLE properties (property_id INT, city VARCHAR(255)); INSERT INTO properties (property_id, city) VALUES (1, 'San Francisco'), (2, 'San Francisco');", "reference_sql": "SELECT MAX(DATEDIFF(end_date, start_date)) as max_duration FROM co_ownership JOIN properties ON co_ownership.property_id = properties.property_id WHERE properties.city = 'San Francisco' AND name = 'Chinatown';", "generated_sql": "SELECT MAX(DATEDIFF(end_date, start_date)) AS max_co_ownership_duration\nFROM co_ownership\nJOIN properties ON co_ownership.property_id = properties.property_id\nJOIN sf_neighborhoods ON properties.city = sf_neighborhoods.city\nWHERE sf_neighborhoods.name = 'Chinatown' AND sf_neighborhoods.city = 'San Francisco';", "raw_model_output": "\n\nTo determine the maximum co-ownership duration for properties in the neighborhood of 'Chinatown' in San Francisco, we need to:\n\n1. Join the `sf_neighborhoods`, `properties`, and `co_ownership` tables.\n2. Filter for properties in the 'Chinatown' neighborhood in San Francisco.\n3. Calculate the duration of each co-ownership (end_date - start_date).\n4. Find the maximum duration.\n\nHere is the SQL query:\n\n```sql\nSELECT MAX(DATEDIFF(end_date, start_date)) AS max_co_ownership_duration\nFROM co_ownership\nJOIN properties ON co_ownership.property_id = properties.property_id\nJOIN sf_neighborhoods ON properties.city = sf_neighborhoods.city\nWHERE sf_neighborhoods.name = 'Chinatown' AND sf_neighborhoods.city = 'San Francisco';\n```", "latency_sec": 1.2197959423065186, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1009, "prompt_eval_sec": null, "tokens_completion": 178, "completion_eval_sec": null, "tokens_total": 1187, "tokens_per_sec": 973.1135830436486, "retrieval_latency_sec": 0.11082196235656738, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references a 'name' column in the WHERE clause, but this column exists only in the sf_neighborhoods table, which is not joined in the Reference SQL. The Generated SQL correctly joins sf_neighborhoods and filters on its 'name' column. The Reference SQL would result in an error due to the missing join, making the queries semantically different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query is technically incorrect because it references the 'name' column from sf_neighborhoods without joining that table, resulting in a syntax error. The generated query correctly joins sf_neighborhoods via properties.city = sf_neighborhoods.city (though this join condition is logically questionable given the schema). While both queries calculate DATEDIFF correctly, only the generated query properly filters for 'Chinatown' by joining the neighborhood table. The reference query would fail execution, making it unable to fulfill the business intent. The generated query, though potentially inefficient due to the city-based join, correctly addresses the neighborhood filter.", "overall_assessment": "differently_correct"}}
{"example_id": 5248, "sql_complexity": "window functions", "prompt": "Find the top 5 games by rating", "context": "CREATE TABLE games (game_id INT PRIMARY KEY, name VARCHAR(50), genre VARCHAR(50), rating DECIMAL(3,2));", "reference_sql": "SELECT * FROM (SELECT name, rating, ROW_NUMBER() OVER (ORDER BY rating DESC) as rn FROM games) t WHERE rn <= 5;", "generated_sql": "SELECT name, rating FROM games ORDER BY rating DESC LIMIT 5;", "raw_model_output": "\n\nSELECT name, rating FROM games ORDER BY rating DESC LIMIT 5;", "latency_sec": 0.32204389572143555, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 866, "prompt_eval_sec": null, "tokens_completion": 19, "completion_eval_sec": null, "tokens_total": 885, "tokens_per_sec": 2748.072581898945, "retrieval_latency_sec": 0.10603904724121094, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the top 5 games by rating in descending order. The reference query uses ROW_NUMBER() to assign ranks and filters for rn <= 5, while the generated query uses ORDER BY and LIMIT 5. Since the ordering logic (rating DESC) is identical, both produce the same result set. The ROW_NUMBER() approach is functionally equivalent to the LIMIT-based approach in this context.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly retrieve the top 5 games by rating. The reference query uses ROW_NUMBER() with a subquery to assign ranks, while the generated query uses ORDER BY and LIMIT. Semantically, they produce identical results because both sort by rating descending and return the first 5 rows. However, the generated query is more efficient and elegant, avoiding unnecessary complexity. The business intent of identifying the top 5 games is fulfilled by both, but the generated query does so with simpler syntax and better performance.", "overall_assessment": "correct"}}
{"example_id": 778, "sql_complexity": "single join", "prompt": "What is the maximum property price in wheelchair-accessible neighborhoods in Singapore?", "context": "CREATE TABLE Singapore_Neighborhoods (Neighborhood_Name TEXT, Wheelchair_Accessibility BOOLEAN); INSERT INTO Singapore_Neighborhoods (Neighborhood_Name, Wheelchair_Accessibility) VALUES ('Orchard', true), ('Marina Bay', true), ('Chinatown', false), ('Little India', false), ('Bugis', true); CREATE TABLE Singapore_Properties (Neighborhood_Name TEXT, Property_Price INTEGER); INSERT INTO Singapore_Properties (Neighborhood_Name, Property_Price) VALUES ('Orchard', 2000000), ('Marina Bay', 3000000), ('Chinatown', 1500000), ('Little India', 1200000), ('Bugis', 1800000);", "reference_sql": "SELECT MAX(Singapore_Properties.Property_Price) FROM Singapore_Properties INNER JOIN Singapore_Neighborhoods ON Singapore_Properties.Neighborhood_Name = Singapore_Neighborhoods.Neighborhood_Name WHERE Singapore_Neighborhoods.Wheelchair_Accessibility = true;", "generated_sql": "SELECT MAX(Property_Price) FROM Singapore_Properties WHERE Neighborhood_Name IN (SELECT Neighborhood_Name FROM Singapore_Neighborhoods WHERE Wheelchair_Accessibility = true);", "raw_model_output": "\n\n```sql\nSELECT MAX(Property_Price) FROM Singapore_Properties WHERE Neighborhood_Name IN (SELECT Neighborhood_Name FROM Singapore_Neighborhoods WHERE Wheelchair_Accessibility = true);\n```", "latency_sec": 0.4597640037536621, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 913, "prompt_eval_sec": null, "tokens_completion": 41, "completion_eval_sec": null, "tokens_total": 954, "tokens_per_sec": 2074.9775802612544, "retrieval_latency_sec": 0.09512805938720703, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the maximum property price from neighborhoods with wheelchair accessibility. The Reference SQL uses an INNER JOIN to combine tables and filter by accessibility, while the Generated SQL uses a subquery with IN to achieve the same filtering. Both approaches effectively restrict to the same set of neighborhoods (Orchard, Marina Bay, Bugis) and calculate the same MAX(Property_Price) of 3000000.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly identify the maximum property price in wheelchair-accessible neighborhoods. The reference query uses an INNER JOIN to combine tables and filter accessible neighborhoods, while the generated query uses a subquery with IN to achieve the same filtering. Both approaches logically ensure only properties in accessible neighborhoods are considered. The result set and business intent are identical. Efficiency is comparable for this dataset, and both queries are semantically clean. The choice between them depends on stylistic preference rather than functional superiority.", "overall_assessment": "correct"}}
{"example_id": 3859, "sql_complexity": "aggregation", "prompt": "What is the total number of mental health parity violations by month and year?", "context": "CREATE TABLE mental_health_parity_reports (report_id INT, violation_date DATE); INSERT INTO mental_health_parity_reports (report_id, violation_date) VALUES (1, '2022-01-01'), (2, '2022-02-15'), (3, '2022-03-05'), (4, '2022-04-20'), (5, '2021-06-12'), (6, '2021-07-28');", "reference_sql": "SELECT EXTRACT(MONTH FROM violation_date) AS month, EXTRACT(YEAR FROM violation_date) AS year, COUNT(*) FROM mental_health_parity_reports GROUP BY month, year;", "generated_sql": "SELECT DATE_FORMAT(violation_date, '%Y-%m') AS month_year, COUNT(*) AS total_violations FROM mental_health_parity_reports GROUP BY DATE_FORMAT(violation_date, '%Y-%m');", "raw_model_output": "\n\nSQL: SELECT DATE_FORMAT(violation_date, '%Y-%m') AS month_year, COUNT(*) AS total_violations FROM mental_health_parity_reports GROUP BY DATE_FORMAT(violation_date, '%Y-%m');", "latency_sec": 0.41211414337158203, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 702, "prompt_eval_sec": null, "tokens_completion": 51, "completion_eval_sec": null, "tokens_total": 753, "tokens_per_sec": 1827.1636926594358, "retrieval_latency_sec": 0.10730910301208496, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries group violations by year and month. The reference query uses EXTRACT(MONTH) and EXTRACT(YEAR) to separate the components, while the generated query uses DATE_FORMAT to combine them into a 'YYYY-MM' string. Since both approaches group by the same underlying year-month combination, the resulting counts will be identical. The difference in column naming/formatting does not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent because they structure results differently: the reference separates month/year into distinct columns while the generated query combines them into a single string. Both correctly count violations, but the reference better aligns with the business intent of analyzing 'by month and year' as separate dimensions. The generated query's 'month_year' format is less flexible for downstream analysis (e.g., filtering by specific months/years). Both are efficient, but the reference's explicit grouping on numeric month/year may have slight performance advantages in some databases.", "overall_assessment": "correct"}}
{"example_id": 3551, "sql_complexity": "multiple_joins", "prompt": "List all artists who have performed in New York and Chicago, along with their highest-earning performance.", "context": "CREATE TABLE artist_events (artist_id INT, event_id INT, earnings DECIMAL(5,2)); CREATE TABLE artists (id INT, name VARCHAR(50)); CREATE TABLE events (id INT, city VARCHAR(20));", "reference_sql": "SELECT artists.name, MAX(artist_events.earnings) FROM artists INNER JOIN artist_events ON artists.id = artist_events.artist_id INNER JOIN events ON artist_events.event_id = events.id WHERE city IN ('New York', 'Chicago') GROUP BY artists.name;", "generated_sql": "SELECT a.name, MAX(ae.earnings) AS highest_earning_performance\nFROM artists a\nJOIN artist_events ae ON a.id = ae.artist_id\nJOIN events e ON ae.event_id = e.id\nWHERE e.city IN ('New York', 'Chicago')\nGROUP BY a.id, a.name\nHAVING COUNT(DISTINCT e.city) = 2;", "raw_model_output": "\n\nTo answer the question \"List all artists who have performed in New York and Chicago, along with their highest-earning performance,\" we need to join the `artists`, `artist_events`, and `events` tables, filter for artists who have performed in both cities, and then find their highest-earning performance.\n\nHere is the SQL query:\n\n```sql\nSELECT a.name, MAX(ae.earnings) AS highest_earning_performance\nFROM artists a\nJOIN artist_events ae ON a.id = ae.artist_id\nJOIN events e ON ae.event_id = e.id\nWHERE e.city IN ('New York', 'Chicago')\nGROUP BY a.id, a.name\nHAVING COUNT(DISTINCT e.city) = 2;\n```", "latency_sec": 1.16615891456604, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 780, "prompt_eval_sec": null, "tokens_completion": 153, "completion_eval_sec": null, "tokens_total": 933, "tokens_per_sec": 800.0624857781027, "retrieval_latency_sec": 0.1087789535522461, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their grouping and filtering. The Generated SQL includes a HAVING clause that requires artists to have events in both cities (COUNT(DISTINCT e.city) = 2), while the Reference SQL only filters events in those cities without requiring multiple cities. Additionally, the Generated SQL groups by both a.id and a.name, whereas the Reference SQL groups only by name. This makes the Generated SQL more restrictive and semantically different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ fundamentally in their logic. The Reference SQL incorrectly includes artists who performed in either New York OR Chicago (not both), as it lacks a constraint to ensure performances in both cities. It also groups by name alone, which is risky if names aren't unique. The Generated SQL correctly enforces the 'performed in both cities' requirement via HAVING COUNT(DISTINCT e.city) = 2. It also groups by both a.id and a.name, ensuring proper aggregation. While both retrieve highest earnings, only the Generated SQL meets the business requirement of dual-city performances.", "overall_assessment": "differently_correct"}}
{"example_id": 5168, "sql_complexity": "aggregation", "prompt": "Get the number of renewable energy projects in Australia for each project type.", "context": "CREATE TABLE renewable_projects (id INT PRIMARY KEY, project_name VARCHAR(255), project_location VARCHAR(255), project_type VARCHAR(255), capacity_mw FLOAT);", "reference_sql": "SELECT project_type, COUNT(*) FROM renewable_projects WHERE project_location = 'Australia' GROUP BY project_type;", "generated_sql": "SELECT project_type, COUNT(*) FROM renewable_projects WHERE project_location = 'Australia' GROUP BY project_type;", "raw_model_output": "\n\nSELECT project_type, COUNT(*) FROM renewable_projects WHERE project_location = 'Australia' GROUP BY project_type;", "latency_sec": 0.2552988529205322, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 585, "prompt_eval_sec": null, "tokens_completion": 26, "completion_eval_sec": null, "tokens_total": 611, "tokens_per_sec": 2393.2735811789494, "retrieval_latency_sec": 0.11262893676757812, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure, conditions, and clauses. Both queries select project_type and count records from renewable_projects where project_location is 'Australia', grouped by project_type. Since they are exactly the same, they will produce identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic. They correctly filter for 'Australia' in the project_location column, group by project_type, and count the number of projects per type. The queries are syntactically correct, semantically equivalent, and directly address the business requirement. Since the reference and generated queries are exactly the same, neither is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 4916, "sql_complexity": "aggregation", "prompt": "What is the maximum revenue generated from selling Yttrium in India in the past 3 years?", "context": "CREATE TABLE Yttrium_Sales (id INT PRIMARY KEY, year INT, country VARCHAR(20), quantity INT, price PER_KG); INSERT INTO Yttrium_Sales (id, year, country, quantity, price) VALUES (1, 2019, 'India', 120, 40), (2, 2020, 'India', 130, 45), (3, 2021, 'India', 140, 50), (4, 2019, 'China', 150, 35), (5, 2020, 'China', 160, 40), (6, 2021, 'China', 170, 45);", "reference_sql": "SELECT MAX(quantity * price) FROM Yttrium_Sales WHERE country = 'India' GROUP BY year ORDER BY year DESC LIMIT 3;", "generated_sql": "SELECT MAX(quantity * price) AS max_revenue\nFROM Yttrium_Sales\nWHERE country = 'India'\n  AND year >= (SELECT MAX(year) - 2 FROM Yttrium_Sales);", "raw_model_output": "\n\nTo calculate the maximum revenue generated from selling Yttrium in India in the past 3 years, we need to:\n\n1. Identify the most recent 3 years from the data.\n2. Filter the records for India.\n3. Calculate the revenue for each record (quantity \u00d7 price).\n4. Find the maximum revenue.\n\nHere is the SQL query:\n\n```sql\nSELECT MAX(quantity * price) AS max_revenue\nFROM Yttrium_Sales\nWHERE country = 'India'\n  AND year >= (SELECT MAX(year) - 2 FROM Yttrium_Sales);\n```", "latency_sec": 0.8877732753753662, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 890, "prompt_eval_sec": null, "tokens_completion": 126, "completion_eval_sec": null, "tokens_total": 1016, "tokens_per_sec": 1144.436342229853, "retrieval_latency_sec": 0.11216497421264648, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns the maximum revenue (quantity*price) for each year in descending order, limited to 3 years, while the Generated SQL calculates the overall maximum revenue for India in the last three years (based on MAX(year)-2). The Reference SQL produces multiple rows (one per year) with ordered results, whereas the Generated SQL returns a single value. For the sample data, Reference SQL would return 3 values (7000, 5850, 4800) and Generated SQL would return 7000, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL groups by year and returns three separate maxima (one per year), but the question asks for a single maximum revenue value across the past three years. The Generated SQL correctly filters sales from the last three years (2019-2021) and returns the absolute maximum revenue from any single sale in that period. While both queries technically return the correct value (7000) in this dataset, the Generated SQL is more aligned with the business intent of retrieving a single maximum value. The Reference SQL's structure (grouping by year) is less efficient and less precise for this specific question.", "overall_assessment": "differently_correct"}}
{"example_id": 812, "sql_complexity": "multiple_joins", "prompt": "What is the average salary of 'engineer' workers in each factory?", "context": "CREATE TABLE factories (factory_id INT, factory_name VARCHAR(20)); INSERT INTO factories VALUES (1, 'Factory X'), (2, 'Factory Y'), (3, 'Factory Z'); CREATE TABLE roles (role_id INT, role_name VARCHAR(20)); INSERT INTO roles VALUES (1, 'engineer'), (2, 'manager'), (3, 'assistant'); CREATE TABLE workers (worker_id INT, factory_id INT, role_id INT, salary DECIMAL(5,2)); INSERT INTO workers VALUES (1, 1, 1, 50000.00), (2, 1, 2, 70000.00), (3, 2, 1, 55000.00), (4, 2, 3, 40000.00), (5, 3, 1, 60000.00);", "reference_sql": "SELECT f.factory_name, AVG(salary) FROM workers w INNER JOIN factories f ON w.factory_id = f.factory_id INNER JOIN roles r ON w.role_id = r.role_id WHERE r.role_name = 'engineer' GROUP BY f.factory_name;", "generated_sql": "SELECT f.factory_name, AVG(w.salary) AS avg_salary \nFROM factories f \nJOIN workers w ON f.factory_id = w.factory_id \nJOIN roles r ON w.role_id = r.role_id \nWHERE r.role_name = 'engineer' \nGROUP BY f.factory_name;", "raw_model_output": "\n\nSELECT f.factory_name, AVG(w.salary) AS avg_salary \nFROM factories f \nJOIN workers w ON f.factory_id = w.factory_id \nJOIN roles r ON w.role_id = r.role_id \nWHERE r.role_name = 'engineer' \nGROUP BY f.factory_name;", "latency_sec": 0.5861918926239014, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 857, "prompt_eval_sec": null, "tokens_completion": 62, "completion_eval_sec": null, "tokens_total": 919, "tokens_per_sec": 1567.7460087112245, "retrieval_latency_sec": 0.10517597198486328, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same data by joining the same tables (factories, workers, roles) with identical conditions. They filter for 'engineer' roles, group by factory name, and calculate the average salary. The only difference is the alias name for the average salary column ('avg_salary' vs. implicit name), which does not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent. They join the same tables (factories, workers, roles) with identical conditions, filter for 'engineer' roles, and group by factory name to calculate average salaries. The reference query uses explicit INNER JOIN syntax and omits an alias for the average salary, while the generated query uses shorthand JOIN syntax and adds an alias (avg_salary). These are stylistic differences with no impact on results. Both correctly address the business intent of calculating average engineer salaries per factory. The generated query's alias improves readability but doesn't alter functionality.", "overall_assessment": "correct"}}
{"example_id": 5784, "sql_complexity": "set operations", "prompt": "List the number of users who have completed a workout of a specific type (e.g. Running) and have a membership status of 'Active'.", "context": "CREATE TABLE workouts (id INT, user_id INT, workout_type VARCHAR(20)); CREATE TABLE members (id INT, name VARCHAR(50), membership_status VARCHAR(20), state VARCHAR(20)); INSERT INTO workouts (id, user_id, workout_type) VALUES (1, 1, 'Running'), (2, 1, 'Cycling'), (3, 2, 'Running'), (4, 3, 'Cycling'), (5, 3, 'Swimming'), (6, 4, 'Running'), (7, 4, 'Swimming'); INSERT INTO members (id, name, membership_status, state) VALUES (1, 'John Doe', 'Active', 'Texas'), (2, 'Jane Doe', 'Inactive', 'California'), (3, 'Bob Smith', 'Active', 'Texas'), (4, 'Alice Johnson', 'Active', 'California');", "reference_sql": "SELECT COUNT(*) FROM (SELECT user_id FROM workouts WHERE workout_type = 'Running' INTERSECT SELECT id FROM members WHERE membership_status = 'Active') AS user_set;", "generated_sql": "SELECT COUNT(DISTINCT w.user_id)\nFROM workouts w\nJOIN members m ON w.user_id = m.id\nWHERE w.workout_type = 'Running' AND m.membership_status = 'Active';", "raw_model_output": "\n\n```sql\nSELECT COUNT(DISTINCT w.user_id)\nFROM workouts w\nJOIN members m ON w.user_id = m.id\nWHERE w.workout_type = 'Running' AND m.membership_status = 'Active';\n```", "latency_sec": 0.4232308864593506, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1224, "prompt_eval_sec": null, "tokens_completion": 51, "completion_eval_sec": null, "tokens_total": 1275, "tokens_per_sec": 3012.540059791827, "retrieval_latency_sec": 0.10763907432556152, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of user_ids that appear in both the 'Running' workouts and active members. The Reference SQL uses INTERSECT to find common user_ids between the two subsets, while the Generated SQL achieves the same result through an INNER JOIN between workouts and members with appropriate filters. The final count of distinct user_ids in both cases matches.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count users with 'Running' workouts and active memberships. The Reference SQL uses INTERSECT to find overlapping user_ids between two subqueries, while the Generated SQL uses a JOIN with COUNT(DISTINCT) to achieve the same result. Both produce identical results in the sample data. However, the Generated SQL is more efficient and readable, as JOINs are generally more performant than INTERSECT for this use case and explicitly clarifies the relationship between tables.", "overall_assessment": "correct"}}
{"example_id": 3038, "sql_complexity": "subqueries", "prompt": "What is the total assets of clients who have invested in mutual funds but not in stocks?", "context": "CREATE TABLE clients (client_id INT, name TEXT, age INT, gender TEXT, total_assets DECIMAL(10,2)); INSERT INTO clients VALUES (1, 'John Doe', 35, 'Male', 250000.00), (2, 'Jane Smith', 45, 'Female', 500000.00); CREATE TABLE investments (client_id INT, investment_type TEXT); INSERT INTO investments VALUES (1, 'Stocks'), (1, 'Bonds'), (2, 'Stocks'), (3, 'Mutual Funds');", "reference_sql": "SELECT c.total_assets FROM clients c INNER JOIN investments i ON c.client_id = i.client_id WHERE i.investment_type = 'Mutual Funds' AND c.client_id NOT IN (SELECT client_id FROM investments WHERE investment_type = 'Stocks');", "generated_sql": "SELECT SUM(c.total_assets) \nFROM clients c \nWHERE c.client_id IN (\n    SELECT client_id \n    FROM investments \n    WHERE investment_type = 'Mutual Funds'\n) \nAND c.client_id NOT IN (\n    SELECT client_id \n    FROM investments \n    WHERE investment_type = 'Stocks'\n);", "raw_model_output": "\n\n```sql\nSELECT SUM(c.total_assets) \nFROM clients c \nWHERE c.client_id IN (\n    SELECT client_id \n    FROM investments \n    WHERE investment_type = 'Mutual Funds'\n) \nAND c.client_id NOT IN (\n    SELECT client_id \n    FROM investments \n    WHERE investment_type = 'Stocks'\n);\n```", "latency_sec": 0.6006710529327393, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1121, "prompt_eval_sec": null, "tokens_completion": 73, "completion_eval_sec": null, "tokens_total": 1194, "tokens_per_sec": 1987.776827550402, "retrieval_latency_sec": 0.10820198059082031, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL selects individual client.total_assets values, while the Generated SQL aggregates them with SUM(). The Reference SQL returns multiple rows (if any) matching the criteria, whereas the Generated SQL returns a single summed value. This difference in output structure makes them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in two critical aspects. 1) The reference query returns individual client asset values rather than a total, while the generated query correctly uses SUM() to aggregate the total assets. 2) The generated query's structure using IN and NOT IN clauses more clearly expresses the business logic of selecting clients with mutual fund investments but no stock investments. The reference query, while logically correct in filtering clients, fails to meet the explicit requirement for a total asset value. Both queries correctly identify the same set of clients, but only the generated query provides the requested aggregated result.", "overall_assessment": "differently_correct"}}
{"example_id": 1078, "sql_complexity": "basic SQL", "prompt": "What is the maximum and minimum temperature difference between any two Arctic research stations?", "context": "CREATE TABLE arctic_stations (id INT, name TEXT, location TEXT, temperature DECIMAL(5,2)); INSERT INTO arctic_stations (id, name, location, temperature) VALUES (1, 'Station A', 'Greenland', 2.3), (2, 'Station B', 'Canada', -5.2);", "reference_sql": "SELECT a.name as station1, b.name as station2, MAX(ABS(a.temperature - b.temperature)) as temp_diff FROM arctic_stations a, arctic_stations b ORDER BY temp_diff DESC LIMIT 1", "generated_sql": "SELECT MAX(temperature) - MIN(temperature) AS temperature_difference FROM arctic_stations;", "raw_model_output": "\n\nSELECT MAX(temperature) - MIN(temperature) AS temperature_difference FROM arctic_stations;", "latency_sec": 0.28926897048950195, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 814, "prompt_eval_sec": null, "tokens_completion": 24, "completion_eval_sec": null, "tokens_total": 838, "tokens_per_sec": 2896.9577987640137, "retrieval_latency_sec": 0.10828495025634766, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the maximum temperature difference between any two stations. The reference query computes the maximum absolute difference between all station pairs, while the generated query calculates MAX(temperature) - MIN(temperature). Since the maximum possible difference between any two values in a set is always equal to the global maximum minus the global minimum, the results are equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the maximum temperature difference between any two stations. The reference query uses a self-join to compare all pairs and returns the maximum absolute difference, while the generated query calculates MAX(temperature) - MIN(temperature), which mathematically equals the same value. However, the generated query is more efficient as it avoids a Cartesian product and uses simple aggregate functions. The original question's mention of 'minimum' might be a misstatement, as the phrasing 'maximum and minimum temperature difference between any two' is ambiguous. If the intent was to find the range (max - min), both queries fulfill this. If the question truly required both max and min differences, neither would fully satisfy it, but the generated query is still more efficient.", "overall_assessment": "correct"}}
{"example_id": 5015, "sql_complexity": "basic SQL", "prompt": "Calculate the average recycling rate", "context": "CREATE TABLE recycling_rates (id INT PRIMARY KEY, location VARCHAR(50), rate FLOAT);", "reference_sql": "SELECT AVG(rate) FROM recycling_rates;", "generated_sql": "SELECT AVG(rate) FROM recycling_rates;", "raw_model_output": "\n\nSELECT AVG(rate) FROM recycling_rates;", "latency_sec": 0.2427990436553955, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 736, "prompt_eval_sec": null, "tokens_completion": 13, "completion_eval_sec": null, "tokens_total": 749, "tokens_per_sec": 3084.855643266269, "retrieval_latency_sec": 0.1038820743560791, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and syntax. They both calculate the average of the 'rate' column from the 'recycling_rates' table without any differences in conditions, aliases, or additional clauses.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic. They correctly calculate the average recycling rate using the AVG() function on the 'rate' column from the recycling_rates table. The queries are technically identical, produce the same results, and directly address the business intent of calculating the average recycling rate. Since they are exactly the same, neither is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 1533, "sql_complexity": "subqueries", "prompt": "Which programs had the highest volunteer participation rate in the last quarter?", "context": "CREATE TABLE Programs (ProgramID INT, ProgramName TEXT, Budget DECIMAL(10,2), NumVolunteers INT); CREATE TABLE VolunteerEvents (EventID INT, ProgramID INT, EventDate DATE, NumVolunteers INT);", "reference_sql": "SELECT p.ProgramName, COUNT(v.EventID) / (SELECT COUNT(*) FROM VolunteerEvents WHERE EventDate >= DATEADD(quarter, -1, GETDATE())) * 100.0 AS VolunteerParticipationRate FROM Programs p INNER JOIN VolunteerEvents v ON p.ProgramID = v.ProgramID WHERE v.EventDate >= DATEADD(quarter, -1, GETDATE()) GROUP BY p.ProgramName ORDER BY VolunteerParticipationRate DESC;", "generated_sql": "SELECT p.ProgramID, p.ProgramName, SUM(ve.NumVolunteers) AS TotalVolunteers FROM Programs p JOIN VolunteerEvents ve ON p.ProgramID = ve.ProgramID WHERE ve.EventDate >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH) GROUP BY p.ProgramID, p.ProgramName ORDER BY TotalVolunteers DESC;", "raw_model_output": "\n\nSELECT p.ProgramID, p.ProgramName, SUM(ve.NumVolunteers) AS TotalVolunteers FROM Programs p JOIN VolunteerEvents ve ON p.ProgramID = ve.ProgramID WHERE ve.EventDate >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH) GROUP BY p.ProgramID, p.ProgramName ORDER BY TotalVolunteers DESC;", "latency_sec": 0.5482618808746338, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 798, "prompt_eval_sec": null, "tokens_completion": 72, "completion_eval_sec": null, "tokens_total": 870, "tokens_per_sec": 1586.8329175322244, "retrieval_latency_sec": 0.10734677314758301, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The reference query calculates a participation rate percentage by comparing program-specific event counts to total events in the last quarter, while the generated query sums volunteer numbers for programs. They differ in aggregation (count vs. sum), calculation (percentage vs. absolute value), and grouping (program name vs. program ID). Date functions are functionally similar but not identical.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent. The Reference SQL attempts to calculate a volunteer participation rate as a percentage of events (COUNT(v.EventID) / total events * 100), while the Generated SQL calculates total volunteers without any rate calculation. The original question asks for 'participation rate' (a ratio), but the Reference SQL's approach is flawed because it uses event counts instead of volunteer counts. However, the Generated SQL completely ignores the 'rate' requirement by only returning absolute volunteer numbers. Neither query correctly defines 'participation rate,' but the Reference SQL at least addresses the rate concept, making it more aligned with the business intent.", "overall_assessment": "differently_correct"}}
{"example_id": 4021, "sql_complexity": "subqueries", "prompt": "What is the percentage of energy efficiency improvement, per sector, compared to 2015 levels?", "context": "CREATE TABLE energy_efficiency (id INT, sector VARCHAR(50), year INT, efficiency FLOAT); INSERT INTO energy_efficiency (id, sector, year, efficiency) VALUES (1, 'Industry', 2015, 100.0), (2, 'Industry', 2020, 105.0), (3, 'Residential', 2015, 100.0), (4, 'Residential', 2020, 103.0);", "reference_sql": "SELECT sector, (SUM(efficiency) / (SELECT SUM(efficiency) FROM energy_efficiency WHERE year = 2015 AND sector = e.sector) * 100.0) - 100.0 AS improvement FROM energy_efficiency e WHERE year = 2020 GROUP BY sector;", "generated_sql": "SELECT \n    sector, \n    ((efficiency - (SELECT efficiency FROM energy_efficiency e2 WHERE e2.sector = e1.sector AND e2.year = 2015)) / (SELECT efficiency FROM energy_efficiency e2 WHERE e2.sector = e1.sector AND e2.year = 2015)) * 100 AS percentage_improvement\nFROM \n    energy_efficiency e1\nWHERE \n    e1.year = 2020\n    AND EXISTS (SELECT 1 FROM energy_efficiency e2 WHERE e2.sector = e1.sector AND e2.year = 2015);", "raw_model_output": "\n\nSELECT \n    sector, \n    ((efficiency - (SELECT efficiency FROM energy_efficiency e2 WHERE e2.sector = e1.sector AND e2.year = 2015)) / (SELECT efficiency FROM energy_efficiency e2 WHERE e2.sector = e1.sector AND e2.year = 2015)) * 100 AS percentage_improvement\nFROM \n    energy_efficiency e1\nWHERE \n    e1.year = 2020\n    AND EXISTS (SELECT 1 FROM energy_efficiency e2 WHERE e2.sector = e1.sector AND e2.year = 2015);", "latency_sec": 1.0046100616455078, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 868, "prompt_eval_sec": null, "tokens_completion": 144, "completion_eval_sec": null, "tokens_total": 1012, "tokens_per_sec": 1007.3560266183158, "retrieval_latency_sec": 0.1236429214477539, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the percentage improvement for each sector by comparing the sum of 2020 efficiencies to the sum of 2015 efficiencies, while the Generated SQL computes the percentage improvement for individual 2020 records relative to their corresponding 2015 records. The Reference SQL groups results by sector and uses aggregation, whereas the Generated SQL does not group and processes each row individually. This leads to different results when multiple entries exist per sector/year.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent. The reference query calculates sector-level improvement by summing 2020 efficiencies and comparing them to 2015 sector totals, which works correctly when there is one efficiency value per sector/year. The generated query calculates improvement per row (individual records) rather than per sector, which would produce multiple rows per sector if there are multiple entries in 2020. While both return correct results for the sample data (which has one entry per sector/year), the reference query better aligns with the business intent of calculating sector-wide improvement. The generated query's use of correlated subqueries is less efficient and would fail if multiple 2020 records exist per sector. The reference query's GROUP BY ensures a single result per sector, fulfilling the original question's requirements.", "overall_assessment": "correct"}}
{"example_id": 1551, "sql_complexity": "single join", "prompt": "How many unique donors made donations in the healthcare industry in Q3 2022?", "context": "CREATE TABLE donations (id INT, donor_id INT, amount FLOAT, donation_date DATE); INSERT INTO donations (id, donor_id, amount, donation_date) VALUES (1, 7, 100, '2022-07-01'); INSERT INTO donations (id, donor_id, amount, donation_date) VALUES (2, 8, 200, '2022-09-15'); INSERT INTO donors (id, name, industry, first_donation_date DATE) VALUES (7, 'Charlie Davis', 'Healthcare', '2022-07-01'); INSERT INTO donors (id, name, industry, first_donation_date DATE) VALUES (8, 'Dana Wilson', 'Healthcare', '2022-09-15');", "reference_sql": "SELECT COUNT(DISTINCT donor_id) FROM donations d JOIN donors don ON d.donor_id = don.id WHERE industry = 'Healthcare' AND donation_date BETWEEN '2022-07-01' AND '2022-09-30';", "generated_sql": "SELECT COUNT(DISTINCT d.donor_id) \nFROM donations d \nJOIN donors dr ON d.donor_id = dr.id \nWHERE dr.industry = 'Healthcare' \n  AND d.donation_date BETWEEN '2022-07-01' AND '2022-09-30';", "raw_model_output": "\n\nSELECT COUNT(DISTINCT d.donor_id) \nFROM donations d \nJOIN donors dr ON d.donor_id = dr.id \nWHERE dr.industry = 'Healthcare' \n  AND d.donation_date BETWEEN '2022-07-01' AND '2022-09-30';", "latency_sec": 0.6871979236602783, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1035, "prompt_eval_sec": null, "tokens_completion": 74, "completion_eval_sec": null, "tokens_total": 1109, "tokens_per_sec": 1613.7999866079963, "retrieval_latency_sec": 0.12214016914367676, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count distinct donor_ids from donations joined with donors where industry is 'Healthcare' and donation_date falls within the specified range. The only difference is the alias name for the donors table ('don' vs 'dr'), which does not affect semantic meaning.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly count unique donor_ids from donations where the donor's industry is Healthcare and the donation date falls in Q3 2022. The reference query uses 'don' as the donors table alias while the generated query uses 'dr', but this is purely syntactic. The JOIN conditions (d.donor_id = don.id vs d.donor_id = dr.id) are equivalent. The WHERE clause filters on industry and date range consistently. The date range '2022-07-01' to '2022-09-30' accurately captures Q3. Both queries use COUNT(DISTINCT) to ensure uniqueness. The only difference is table alias naming, which does not affect results.", "overall_assessment": "correct"}}
{"example_id": 2592, "sql_complexity": "window functions", "prompt": "What is the third highest account balance for Shariah-compliant finance customers?", "context": "CREATE TABLE shariah_compliant_finance(customer_id INT, account_balance DECIMAL(10, 2)); INSERT INTO shariah_compliant_finance VALUES (1, 5000), (2, 7000), (3, 6000), (4, 8000), (5, 9000);", "reference_sql": "SELECT account_balance FROM (SELECT account_balance, RANK() OVER (ORDER BY account_balance DESC) as rn FROM shariah_compliant_finance) t WHERE rn = 3;", "generated_sql": "SELECT account_balance FROM (SELECT account_balance, ROW_NUMBER() OVER (ORDER BY account_balance DESC) AS rn FROM shariah_compliant_finance) t WHERE rn = 3;", "raw_model_output": "\n\nSELECT account_balance FROM (SELECT account_balance, ROW_NUMBER() OVER (ORDER BY account_balance DESC) AS rn FROM shariah_compliant_finance) t WHERE rn = 3;", "latency_sec": 0.3671560287475586, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 896, "prompt_eval_sec": null, "tokens_completion": 43, "completion_eval_sec": null, "tokens_total": 939, "tokens_per_sec": 2557.495796005621, "retrieval_latency_sec": 0.11820816993713379, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the third highest account balance. Since all account_balance values are unique, RANK() and ROW_NUMBER() produce the same ordering in this specific case. The third-ranked value (7000) is identical in both results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly retrieve the third highest account balance in this specific dataset. The reference query uses RANK() while the generated query uses ROW_NUMBER(), but since all account balances are unique in the sample data, both produce the same result (7000). The business intent of finding the third highest value is fulfilled by both approaches. However, ROW_NUMBER() is generally more appropriate for this use case as it avoids potential issues with ties (though not present here). The efficiency is comparable in this simple scenario.", "overall_assessment": "correct"}}
{"example_id": 3795, "sql_complexity": "single join", "prompt": "What is the total quantity of unsold garments for each manufacturer based in 'Italy' or 'Spain'?", "context": "CREATE TABLE manufacturers (id INT PRIMARY KEY, name VARCHAR(255), country VARCHAR(255)); CREATE TABLE garments (id INT PRIMARY KEY, manufacturer_id INT, quantity_manufactured INT, quantity_sold INT);", "reference_sql": "SELECT m.name, SUM(g.quantity_manufactured - g.quantity_sold) as total_unsold_quantity FROM manufacturers m JOIN garments g ON m.id = g.manufacturer_id WHERE m.country IN ('Italy', 'Spain') GROUP BY m.name;", "generated_sql": "SELECT m.name, SUM(g.quantity_manufactured - g.quantity_sold) AS total_unsold_quantity\nFROM manufacturers m\nJOIN garments g ON m.id = g.manufacturer_id\nWHERE m.country IN ('Italy', 'Spain')\nGROUP BY m.name;", "raw_model_output": "\n\n```sql\nSELECT m.name, SUM(g.quantity_manufactured - g.quantity_sold) AS total_unsold_quantity\nFROM manufacturers m\nJOIN garments g ON m.id = g.manufacturer_id\nWHERE m.country IN ('Italy', 'Spain')\nGROUP BY m.name;\n```", "latency_sec": 0.4822690486907959, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 941, "prompt_eval_sec": null, "tokens_completion": 61, "completion_eval_sec": null, "tokens_total": 1002, "tokens_per_sec": 2077.6784301628004, "retrieval_latency_sec": 0.12798690795898438, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure, logic, and syntax. The only differences are whitespace and formatting (e.g., line breaks after AS), which do not affect semantic meaning. Both perform the same join, filtering, aggregation, and grouping.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "The reference and generated SQL queries are identical in structure, logic, and syntax. Both correctly calculate the total unsold garments (quantity_manufactured - quantity_sold) for manufacturers in Italy/Spain, using an INNER JOIN, appropriate WHERE filtering, and GROUP BY. The semantic equivalence is absolute, as both queries would produce identical results. The business intent is fully addressed by measuring unsold inventory per manufacturer in the specified countries. Neither query demonstrates superior efficiency or elegance over the other since they are functionally identical.", "overall_assessment": "correct"}}
{"example_id": 4138, "sql_complexity": "window functions", "prompt": "How many lifelong learning courses has a student with ID '2' completed, in chronological order?", "context": "CREATE TABLE lifelong_learning (student_id INT, course_id INT, completion_date DATE); INSERT INTO lifelong_learning VALUES (2, 1001, '2015-01-01'), (2, 1002, '2016-01-01');", "reference_sql": "SELECT student_id, course_id, COUNT(course_id) OVER (PARTITION BY student_id ORDER BY completion_date) as completed_courses FROM lifelong_learning WHERE student_id = 2;", "generated_sql": "SELECT COUNT(course_id) AS completed_courses FROM lifelong_learning WHERE student_id = 2 ORDER BY completion_date;", "raw_model_output": "\n\nSELECT COUNT(course_id) AS completed_courses FROM lifelong_learning WHERE student_id = 2 ORDER BY completion_date;", "latency_sec": 0.26906299591064453, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 982, "prompt_eval_sec": null, "tokens_completion": 27, "completion_eval_sec": null, "tokens_total": 1009, "tokens_per_sec": 3750.051160268384, "retrieval_latency_sec": 0.13357114791870117, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns multiple rows with a running count of courses per student, while the Generated SQL returns a single row with the total count. The first includes course_id and student_id with cumulative counts, the second only provides a total count without per-row details.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query uses a window function to show cumulative counts per row, which would return two rows with counts 1 and 2 for the two courses. The generated query correctly returns a single count of 2, which directly answers 'how many' courses were completed. While the reference query is technically valid, it doesn't align with the business intent of providing a simple count. The generated query is more efficient and directly addresses the question, even though the ORDER BY clause is redundant in this context. The original question's mention of 'chronological order' likely refers to the completion dates of the courses, which the generated query achieves by ordering the result (though it only returns a single value).", "overall_assessment": "correct"}}
{"example_id": 312, "sql_complexity": "aggregation", "prompt": "List the top 3 most represented ethnicities in movies produced in the USA.", "context": "CREATE TABLE movies (title VARCHAR(255), production_country VARCHAR(64), lead_actor_ethnicity VARCHAR(64));", "reference_sql": "SELECT lead_actor_ethnicity, COUNT(*) AS count FROM movies WHERE production_country = 'USA' GROUP BY lead_actor_ethnicity ORDER BY count DESC LIMIT 3;", "generated_sql": "SELECT lead_actor_ethnicity, COUNT(*) AS count \nFROM movies \nWHERE production_country = 'USA' \nGROUP BY lead_actor_ethnicity \nORDER BY count DESC \nLIMIT 3;", "raw_model_output": "\n\nSELECT lead_actor_ethnicity, COUNT(*) AS count \nFROM movies \nWHERE production_country = 'USA' \nGROUP BY lead_actor_ethnicity \nORDER BY count DESC \nLIMIT 3;", "latency_sec": 0.380587100982666, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 837, "prompt_eval_sec": null, "tokens_completion": 45, "completion_eval_sec": null, "tokens_total": 882, "tokens_per_sec": 2317.472131143433, "retrieval_latency_sec": 0.12418627738952637, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select the lead_actor_ethnicity and count of movies from the USA, group by ethnicity, order by count descending, and limit to 3 results. The formatting differences (e.g., line breaks) do not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "The reference and generated queries are identical in structure, logic, and syntax. Both correctly filter USA-produced movies, group by lead actor ethnicity, count occurrences, order by descending count, and limit to top 3 results. They perfectly address the business intent of identifying the most represented ethnicities in US movies. Since the queries are identical, neither is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 4298, "sql_complexity": "single join", "prompt": "How many users joined the gym in Q1 2023?", "context": "CREATE TABLE memberships (id INT, user_id INT, join_date DATE); INSERT INTO memberships (id, user_id, join_date) VALUES (1, 5, '2023-01-15'), (2, 6, '2023-02-03'), (3, 7, '2023-03-20'), (4, 8, '2022-12-31');", "reference_sql": "SELECT COUNT(*) FROM memberships WHERE join_date BETWEEN '2023-01-01' AND '2023-03-31';", "generated_sql": "SELECT COUNT(*) FROM memberships WHERE join_date >= '2023-01-01' AND join_date <= '2023-03-31';", "raw_model_output": "\n\nSELECT COUNT(*) FROM memberships WHERE join_date >= '2023-01-01' AND join_date <= '2023-03-31';", "latency_sec": 0.36650824546813965, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1267, "prompt_eval_sec": null, "tokens_completion": 42, "completion_eval_sec": null, "tokens_total": 1309, "tokens_per_sec": 3571.543113110645, "retrieval_latency_sec": 0.12334299087524414, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter records where join_date is between '2023-01-01' and '2023-03-31' inclusive. The BETWEEN operator and the combination of >=/<= conditions are semantically equivalent for date comparisons in this context.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly count users who joined in Q1 2023 (January 1 - March 31). The reference uses BETWEEN which includes both endpoints, while the generated version uses explicit >= and <= conditions. Since the date ranges are identical and the sample data shows 3 users in Q1, both would produce the same result. The business intent is fully addressed by both queries. Neither query is more efficient or elegant than the other - they are functionally identical.", "overall_assessment": "correct"}}
{"example_id": 5211, "sql_complexity": "multiple_joins", "prompt": "What is the average transaction value in the last week, split by product category and customer demographics?", "context": "CREATE TABLE transactions (transaction_id INT, customer_id INT, product_id INT, category_id INT, transaction_date DATE, amount DECIMAL(10,2)); CREATE TABLE customers (customer_id INT, age INT, gender VARCHAR(10), location VARCHAR(255)); CREATE TABLE products (product_id INT, name VARCHAR(255), category_id INT);", "reference_sql": "SELECT c.age, c.gender, p.category_id, AVG(t.amount) as avg_transaction_value FROM transactions t INNER JOIN customers c ON t.customer_id = c.customer_id INNER JOIN products p ON t.product_id = p.product_id WHERE t.transaction_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 WEEK) GROUP BY c.age, c.gender, p.category_id;", "generated_sql": "SELECT p.category_id, c.gender, c.age, AVG(t.amount) AS average_transaction_value\nFROM transactions t\nINNER JOIN customers c ON t.customer_id = c.customer_id\nINNER JOIN products p ON t.product_id = p.product_id\nWHERE t.transaction_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 WEEK)\nGROUP BY p.category_id, c.gender, c.age;", "raw_model_output": "\n\n```sql\nSELECT p.category_id, c.gender, c.age, AVG(t.amount) AS average_transaction_value\nFROM transactions t\nINNER JOIN customers c ON t.customer_id = c.customer_id\nINNER JOIN products p ON t.product_id = p.product_id\nWHERE t.transaction_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 WEEK)\nGROUP BY p.category_id, c.gender, c.age;\n```", "latency_sec": 0.6428191661834717, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 879, "prompt_eval_sec": null, "tokens_completion": 87, "completion_eval_sec": null, "tokens_total": 966, "tokens_per_sec": 1502.7554416824698, "retrieval_latency_sec": 0.13010692596435547, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same data by joining the same tables with identical conditions. The SELECT clause columns are the same, just ordered differently. The GROUP BY clause contains the same expressions in a different order. The only difference is the alias name for the aggregated column, which does not affect semantic equivalence as the underlying data and structure remain identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent as they produce identical results. They correctly join the required tables (transactions, customers, products), filter transactions from the last week using DATE_SUB, and group by product category_id and customer demographics (age, gender). The only differences are the order of columns in SELECT and GROUP BY clauses, which does not affect semantic or technical correctness. Both queries fully address the business intent of calculating average transaction value split by category and demographics. Neither query includes location (a potential demographic factor) but the original question did not explicitly require it. The structure and logic of both are equally efficient and elegant.", "overall_assessment": "correct"}}
{"example_id": 382, "sql_complexity": "window functions", "prompt": "What is the average annual precipitation in the past 10 years for each weather station?", "context": "CREATE TABLE WeatherStation (ID INT, Name VARCHAR(100), Location VARCHAR(100), Elevation FLOAT, AnnualPrecipitation FLOAT); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (1, 'Station A', 'Arctic Circle', 100, 450); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (2, 'Station B', 'North Pole', 200, 300);", "reference_sql": "SELECT Name, AVG(AnnualPrecipitation) OVER (PARTITION BY Name ORDER BY Name ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS AvgAnnualPrecipitation FROM WeatherStation WHERE YEAR(CurrentDate) - YEAR(DateInstalled) BETWEEN 1 AND 10;", "generated_sql": "SELECT Name, AnnualPrecipitation FROM WeatherStation;", "raw_model_output": "\n\nThe question asks for the \"average annual precipitation in the past 10 years for each weather station,\" but the provided schema only contains a `WeatherStation` table with a single `AnnualPrecipitation` column. There is no historical or time-based data available to calculate a 10-year average.\n\nTherefore, based on the given schema, the best interpretation is to return the `AnnualPrecipitation` for each weather station, as that is the only available precipitation data.\n\nSQL:  \n```sql\nSELECT Name, AnnualPrecipitation FROM WeatherStation;\n```", "latency_sec": 1.0026829242706299, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1122, "prompt_eval_sec": null, "tokens_completion": 120, "completion_eval_sec": null, "tokens_total": 1242, "tokens_per_sec": 1238.6767241533048, "retrieval_latency_sec": 0.1282360553741455, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL includes a window function to calculate an average precipitation value and references a non-existent 'DateInstalled' column in the WHERE clause. The Generated SQL simply retrieves raw Name and AnnualPrecipitation values without any aggregation or filtering. Additionally, the window function's logic (PARTITION BY Name) would produce identical values to the original AnnualPrecipitation column in this dataset, but the queries still differ in structure and intended output.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "equal", "explanation": "Neither query correctly addresses the question. The reference query contains a critical error by referencing a non-existent 'DateInstalled' column and incorrectly uses a window function on a single value (AnnualPrecipitation) that doesn't represent multiple years of data. The generated query simply returns raw precipitation values without calculating any average or considering the 10-year timeframe. Both queries fail due to schema limitations (missing year/date fields) and incorrect logic for the business requirement.", "overall_assessment": "incorrect"}}
{"example_id": 2190, "sql_complexity": "single join", "prompt": "What is the total number of humanitarian assistance events by each country in the last 3 years?", "context": "CREATE TABLE Humanitarian_Assistance (id INT, country VARCHAR(50), year INT, events INT); CREATE TABLE Countries (id INT, name VARCHAR(50), region VARCHAR(50));", "reference_sql": "SELECT co.name, SUM(ha.events) FROM Humanitarian_Assistance ha INNER JOIN Countries co ON ha.country = co.name WHERE ha.year BETWEEN (YEAR(CURRENT_DATE) - 3) AND YEAR(CURRENT_DATE) GROUP BY co.name;", "generated_sql": "SELECT h.country, SUM(h.events) AS total_events  \nFROM Humanitarian_Assistance h  \nWHERE h.year >= EXTRACT(YEAR FROM CURRENT_DATE) - 2  \nGROUP BY h.country;", "raw_model_output": "\n\nSELECT h.country, SUM(h.events) AS total_events  \nFROM Humanitarian_Assistance h  \nWHERE h.year >= EXTRACT(YEAR FROM CURRENT_DATE) - 2  \nGROUP BY h.country;", "latency_sec": 0.38510799407958984, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1046, "prompt_eval_sec": null, "tokens_completion": 45, "completion_eval_sec": null, "tokens_total": 1091, "tokens_per_sec": 2832.9715736166313, "retrieval_latency_sec": 0.1182870864868164, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their year range filters. The Reference SQL uses BETWEEN (YEAR(CURRENT_DATE) - 3) AND YEAR(CURRENT_DATE) (4 years: e.g., 2020-2023 if current year is 2023), while the Generated SQL uses EXTRACT(YEAR FROM CURRENT_DATE) - 2 (3 years: e.g., 2021-2023). Additionally, the Reference SQL joins with the Countries table and groups by co.name, whereas the Generated SQL does not join and groups by h.country. These differences in filtering and joining logic make them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries differ in three key aspects:\n1. The reference query incorrectly includes 4 years (e.g., 2020-2023 when current year is 2023) due to BETWEEN's inclusive range, while the generated query correctly uses >= EXTRACT(YEAR FROM CURRENT_DATE) - 2 to capture exactly 3 years (2021-2023).\n2. The reference query joins with the Countries table unnecessarily since the Humanitarian_Assistance table already contains country names, which could introduce potential data discrepancies if country names differ between tables.\n3. The generated query is more efficient by avoiding an unnecessary join and directly grouping by h.country. While both queries address the business intent of counting events by country, the reference query's year filter is technically incorrect for the 'last 3 years' requirement.", "overall_assessment": "differently_correct"}}
{"example_id": 1852, "sql_complexity": "set operations", "prompt": "Compare coal production and employment rates in China and India between 2018 and 2020.", "context": "CREATE TABLE china_coal_production (year INT, production FLOAT); INSERT INTO china_coal_production (year, production) VALUES (2018, 3500.0), (2019, 3600.0), (2020, 3700.0); CREATE TABLE china_employment (year INT, employment FLOAT); INSERT INTO china_employment (year, employment) VALUES (2018, 8000000.0), (2019, 8100000.0), (2020, 8200000.0); CREATE TABLE india_coal_production (year INT, production FLOAT); INSERT INTO india_coal_production (year, production) VALUES (2018, 700.0), (2019, 750.0), (2020, 800.0); CREATE TABLE india_employment (year INT, employment FLOAT); INSERT INTO india_employment (year, employment) VALUES (2018, 1000000.0), (2019, 1050000.0), (2020, 1100000.0);", "reference_sql": "SELECT 'China' AS country, china_coal_production.production, china_employment.employment FROM china_coal_production INNER JOIN china_employment ON china_coal_production.year = china_employment.year WHERE china_coal_production.year BETWEEN 2018 AND 2020 UNION ALL SELECT 'India', india_coal_production.production, india_employment.employment FROM india_coal_production INNER JOIN india_employment ON india_coal_production.year = india_employment.year WHERE india_coal_production.year BETWEEN 2018 AND 2020;", "generated_sql": "SELECT china_coal_production.year, china_coal_production.production AS china_coal_production, china_employment.employment AS china_employment, india_coal_production.production AS india_coal_production, india_employment.employment AS india_employment FROM china_coal_production JOIN china_employment ON china_coal_production.year = china_employment.year JOIN india_coal_production ON china_coal_production.year = india_coal_production.year JOIN india_employment ON china_coal_production.year = india_employment.year WHERE china_coal_production.year BETWEEN 2018 AND 2020;", "raw_model_output": "\n\nSELECT china_coal_production.year, china_coal_production.production AS china_coal_production, china_employment.employment AS china_employment, india_coal_production.production AS india_coal_production, india_employment.employment AS india_employment FROM china_coal_production JOIN china_employment ON china_coal_production.year = china_employment.year JOIN india_coal_production ON china_coal_production.year = india_coal_production.year JOIN india_employment ON china_coal_production.year = india_employment.year WHERE china_coal_production.year BETWEEN 2018 AND 2020;", "latency_sec": 0.9973559379577637, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1286, "prompt_eval_sec": null, "tokens_completion": 124, "completion_eval_sec": null, "tokens_total": 1410, "tokens_per_sec": 1413.738011012585, "retrieval_latency_sec": 0.1327037811279297, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two rows per year (China and India) with columns 'country', 'production', 'employment', while the Generated SQL returns one row per year with all four tables' columns (year, china_coal_production, china_employment, india_coal_production, india_employment). The structure and content of the results differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query correctly structures data for direct comparison by returning separate rows for China and India with aligned year, production, and employment metrics. The generated query combines all data into single rows with columns for both countries, which requires additional processing to compare metrics side-by-side. While both queries are technically correct, the reference better fulfills the business intent of comparing metrics between countries. The generated query's multiple joins may introduce unnecessary complexity and could fail if tables have mismatched years, whereas the reference's UNION ALL approach is more robust for this specific comparison.", "overall_assessment": "differently_correct"}}
{"example_id": 2535, "sql_complexity": "subqueries", "prompt": "What is the maximum safety rating for vehicles in the vehiclesafety schema?", "context": "CREATE TABLE VehicleSafety (id INT, vehicle_id INT, safetyrating INT, PRIMARY KEY (id)); CREATE TABLE Vehicles (id INT, make VARCHAR(50), model VARCHAR(50), PRIMARY KEY (id)); CREATE TABLE LuxuryVehicles (id INT, vehicle_id INT, PRIMARY KEY (id), FOREIGN KEY (vehicle_id) REFERENCES Vehicles(id));", "reference_sql": "SELECT MAX(safetyrating) FROM vehicleSafety JOIN Vehicles ON vehicleSafety.vehicle_id = Vehicles.id WHERE EXISTS (SELECT * FROM LuxuryVehicles WHERE Vehicles.id = LuxuryVehicles.vehicle_id);", "generated_sql": "SELECT MAX(safetyrating) FROM VehicleSafety;", "raw_model_output": "\n\nSQL: SELECT MAX(safetyrating) FROM VehicleSafety;", "latency_sec": 0.20356297492980957, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 758, "prompt_eval_sec": null, "tokens_completion": 17, "completion_eval_sec": null, "tokens_total": 775, "tokens_per_sec": 3807.175643150368, "retrieval_latency_sec": 0.12003898620605469, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters vehicles using an EXISTS clause with LuxuryVehicles, while the Generated SQL queries all records in VehicleSafety without filtering. The Reference SQL's result is the maximum safetyrating only for vehicles linked to luxury vehicles, whereas the Generated SQL returns the maximum safetyrating across all vehicles. These differ unless all vehicles in VehicleSafety are guaranteed to be luxury vehicles, which is not enforced by the schema.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query incorrectly filters results to only luxury vehicles via the EXISTS clause, while the generated query directly retrieves the maximum safety rating from all vehicles in the VehicleSafety table. The original question makes no mention of luxury vehicles, making the reference query's additional filter irrelevant. The generated query is technically correct, more efficient (no unnecessary joins/subqueries), and directly addresses the business intent of finding the overall maximum safety rating.", "overall_assessment": "differently_correct"}}
{"example_id": 2140, "sql_complexity": "aggregation", "prompt": "What was the total amount of minerals extracted in the 'north' region for each month in 2020?", "context": "CREATE TABLE extraction(id INT, location TEXT, month INT, year INT, minerals_extracted FLOAT);INSERT INTO extraction(id, location, month, year, minerals_extracted) VALUES (1, 'north', 1, 2020, 1500), (2, 'north', 2, 2020, 1800), (3, 'south', 1, 2020, 1200);", "reference_sql": "SELECT month, SUM(minerals_extracted) FROM extraction WHERE location = 'north' AND year = 2020 GROUP BY month;", "generated_sql": "SELECT month, SUM(minerals_extracted) FROM extraction WHERE location = 'north' AND year = 2020 GROUP BY month;", "raw_model_output": "\n\nSELECT month, SUM(minerals_extracted) FROM extraction WHERE location = 'north' AND year = 2020 GROUP BY month;", "latency_sec": 0.31367921829223633, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 962, "prompt_eval_sec": null, "tokens_completion": 34, "completion_eval_sec": null, "tokens_total": 996, "tokens_per_sec": 3175.2183183269917, "retrieval_latency_sec": 0.12379097938537598, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure, conditions, and aggregation. Both queries select the same columns, apply the same WHERE clause filters (location = 'north' and year = 2020), and group by the same column (month).", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic. They correctly filter for 'north' location and 2020 year, group by month, and calculate the sum of minerals extracted. The queries are technically correct, semantically equivalent, and fully address the business requirement of showing monthly totals for the north region in 2020. Neither query demonstrates any efficiency advantages over the other since they are identical.", "overall_assessment": "correct"}}
{"example_id": 4779, "sql_complexity": "window functions", "prompt": "What is the average CO2 emission for the top 3 highest emitting countries since 2015?", "context": "CREATE TABLE emissions (country VARCHAR(50), year INT, co2_emission INT); INSERT INTO emissions (country, year, co2_emission) VALUES ('USA', 2015, 5373978000); INSERT INTO emissions (country, year, co2_emission) VALUES ('China', 2015, 10498600000); INSERT INTO emissions (country, year, co2_emission) VALUES ('India', 2015, 2633830000); INSERT INTO emissions (country, year, co2_emission) VALUES ('USA', 2016, 5518004000); INSERT INTO emissions (country, year, co2_emission) VALUES ('China', 2016, 10813000000); INSERT INTO emissions (country, year, co2_emission) VALUES ('India', 2016, 2799280000);", "reference_sql": "SELECT AVG(co2_emission) as avg_emission FROM (SELECT country, year, co2_emission, ROW_NUMBER() OVER (ORDER BY co2_emission DESC) as rn FROM emissions WHERE year >= 2015) t WHERE rn <= 3 GROUP BY country;", "generated_sql": "SELECT AVG(total_emission) AS average_co2_emission\nFROM (\n    SELECT country, SUM(co2_emission) AS total_emission\n    FROM emissions\n    WHERE year >= 2015\n    GROUP BY country\n    ORDER BY total_emission DESC\n    LIMIT 3\n) AS top_countries;", "raw_model_output": "\n\nTo calculate the average CO2 emission for the top 3 highest emitting countries since 2015, we need to:\n\n1. Identify the top 3 countries with the highest total CO2 emissions from 2015 onwards.\n2. Calculate the average CO2 emission for these countries.\n\nHere is the SQL query:\n\n```sql\nSELECT AVG(total_emission) AS average_co2_emission\nFROM (\n    SELECT country, SUM(co2_emission) AS total_emission\n    FROM emissions\n    WHERE year >= 2015\n    GROUP BY country\n    ORDER BY total_emission DESC\n    LIMIT 3\n) AS top_countries;\n```", "latency_sec": 1.002746820449829, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1084, "prompt_eval_sec": null, "tokens_completion": 143, "completion_eval_sec": null, "tokens_total": 1227, "tokens_per_sec": 1223.6388836910712, "retrieval_latency_sec": 0.12038707733154297, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL calculates the average of co2_emission for the top 3 rows (by co2_emission) per country, while the Generated SQL calculates the average of total emissions (summed per country) for the top 3 countries. The Reference SQL groups by country and averages individual row values, whereas the Generated SQL aggregates emissions per country first, then averages the top 3 totals. The result structures and calculations differ fundamentally.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is technically incorrect because it groups by country after selecting top 3 entries by co2_emission, which would return multiple rows (one per country) with individual averages rather than a single average of the top 3 countries. It also uses ROW_NUMBER() on all entries (not per-country), potentially selecting multiple entries from the same country. The Generated SQL correctly aggregates emissions per country (summing all years >=2015), selects the top 3 by total emissions, and calculates their average. This aligns with the business intent of finding the average CO2 emission of the top 3 countries (not individual years). The Reference SQL fails to address the question's requirement for country-level aggregation before averaging.", "overall_assessment": "differently_correct"}}
{"example_id": 1015, "sql_complexity": "subqueries", "prompt": "List the top 3 most expensive eco-friendly products in Europe and their suppliers.", "context": "CREATE TABLE Suppliers (supplierID INT, supplierName VARCHAR(50), country VARCHAR(50)); CREATE TABLE Products (productID INT, productName VARCHAR(50), price DECIMAL(10,2), ecoFriendly BOOLEAN, supplierID INT);", "reference_sql": "SELECT P.productName, P.price, S.supplierName FROM (SELECT * FROM Products WHERE ecoFriendly = TRUE ORDER BY price DESC LIMIT 3) P JOIN Suppliers S ON P.supplierID = S.supplierID;", "generated_sql": "SELECT p.productName, s.supplierName \nFROM Products p \nJOIN Suppliers s ON p.supplierID = s.supplierID \nWHERE p.ecoFriendly = TRUE AND s.country IN ('Europe') \nORDER BY p.price DESC \nLIMIT 3;", "raw_model_output": "\n\n```sql\nSELECT p.productName, s.supplierName \nFROM Products p \nJOIN Suppliers s ON p.supplierID = s.supplierID \nWHERE p.ecoFriendly = TRUE AND s.country IN ('Europe') \nORDER BY p.price DESC \nLIMIT 3;\n```", "latency_sec": 0.5854952335357666, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 872, "prompt_eval_sec": null, "tokens_completion": 62, "completion_eval_sec": null, "tokens_total": 934, "tokens_per_sec": 1595.2307491209388, "retrieval_latency_sec": 0.13204193115234375, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their filtering conditions. The Generated SQL includes an additional WHERE condition 's.country IN ('Europe')' that is not present in the Reference SQL. This restricts results to suppliers in Europe, while the Reference SQL has no such restriction. Additionally, the Reference SQL applies ORDER BY and LIMIT within a subquery before joining, whereas the Generated SQL applies these after the join, which could affect result ordering but the country filter is the critical difference.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in critical aspects. The Reference SQL incorrectly omits the 'country = Europe' filter entirely, potentially returning eco-friendly products from non-European suppliers. The Generated SQL properly filters suppliers in Europe via 's.country IN ('Europe')'. Both correctly identify eco-friendly products and order by price, but only the Generated SQL enforces the European location requirement. The Reference SQL's subquery structure also risks including non-European suppliers since the country filter is applied after the initial eco-friendly selection. The Generated SQL's approach is more logically structured for the business requirement.", "overall_assessment": "differently_correct"}}
{"example_id": 3715, "sql_complexity": "aggregation", "prompt": "What is the average age of engines still in service for each engine type?", "context": "CREATE TABLE Engine (id INT, aircraft_id INT, engine_type VARCHAR(255), hours_since_last_service INT, manufacture_year INT); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (1, 1, 'GE90-115B', 500, 2000); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (2, 2, 'CFM56-5B', 1000, 1995); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (3, 1, 'GE90-115B', 700, 2002);", "reference_sql": "SELECT engine_type, AVG(YEAR(CURRENT_DATE) - manufacture_year) as avg_age FROM Engine GROUP BY engine_type;", "generated_sql": "SELECT engine_type, AVG(2023 - manufacture_year) AS average_age FROM Engine GROUP BY engine_type;", "raw_model_output": "\n\nSELECT engine_type, AVG(2023 - manufacture_year) AS average_age FROM Engine GROUP BY engine_type;", "latency_sec": 0.2770099639892578, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 702, "prompt_eval_sec": null, "tokens_completion": 29, "completion_eval_sec": null, "tokens_total": 731, "tokens_per_sec": 2638.894245798131, "retrieval_latency_sec": 0.12154912948608398, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses YEAR(CURRENT_DATE) which depends on the actual current year when the query is executed, while the Generated SQL hardcodes 2023. If the current year is not 2023, the calculated ages will differ. For example, if today's year is 2024, the Reference SQL would compute 2024 - manufacture_year, whereas the Generated SQL would use 2023, leading to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent because the reference uses dynamic CURRENT_DATE to calculate age while the generated query uses a fixed year (2023). The reference correctly adapts to the current date, ensuring accuracy regardless of when the query is executed. Both fulfill the business intent of calculating average engine age by type, but the reference is more robust. The generated query would produce incorrect results if executed in a year other than 2023. Neither query explicitly filters for 'still in service' engines, but the context implies all engines in the table are active (no status field exists). The reference is more elegant and future-proof.", "overall_assessment": "differently_correct"}}
{"example_id": 1957, "sql_complexity": "set operations", "prompt": "What is the average temperature recorded for the 'polar_bear' species in the 'Arctic_Animals' table compared to the 'penguin' species in the 'Antarctic_Animals' table?", "context": "CREATE TABLE Arctic_Animals (species TEXT, avg_temp FLOAT); CREATE TABLE Antarctic_Animals (species TEXT, avg_temp FLOAT);", "reference_sql": "SELECT AVG(Arctic_Animals.avg_temp) FROM Arctic_Animals WHERE Arctic_Animals.species = 'polar_bear' INTERSECT SELECT AVG(Antarctic_Animals.avg_temp) FROM Antarctic_Animals WHERE Antarctic_Animals.species = 'penguin'", "generated_sql": "SELECT \n    (SELECT AVG(avg_temp) FROM Arctic_Animals WHERE species = 'polar_bear') AS avg_temp_polar_bear,\n    (SELECT AVG(avg_temp) FROM Antarctic_Animals WHERE species = 'penguin') AS avg_temp_penguin;", "raw_model_output": "\n\nSELECT \n    (SELECT AVG(avg_temp) FROM Arctic_Animals WHERE species = 'polar_bear') AS avg_temp_polar_bear,\n    (SELECT AVG(avg_temp) FROM Antarctic_Animals WHERE species = 'penguin') AS avg_temp_penguin;", "latency_sec": 0.5643777847290039, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 674, "prompt_eval_sec": null, "tokens_completion": 59, "completion_eval_sec": null, "tokens_total": 733, "tokens_per_sec": 1298.775429922287, "retrieval_latency_sec": 0.12817096710205078, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses INTERSECT to find common values between two aggregated results, returning a single row if the averages match. The Generated SQL returns both averages as separate columns in a single row, without comparing them. The first query checks for equality between the two averages, while the second simply retrieves both values independently.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL is technically incorrect because it uses INTERSECT, which returns only common rows between two result sets. Since each subquery returns a single value (average temperature), INTERSECT would only return a result if the two averages were identical. This fundamentally misrepresents the comparison request. The Generated SQL correctly uses two independent subqueries to calculate and return both averages as separate columns, enabling direct comparison. While both queries are syntactically valid, only the Generated SQL fulfills the business intent of comparing the two averages. The Generated version is also more efficient and semantically clear.", "overall_assessment": "differently_correct"}}
{"example_id": 1311, "sql_complexity": "basic SQL", "prompt": "What is the total number of veteran job applications in Texas in the last year?", "context": "CREATE TABLE veteran_jobs (id INT, state VARCHAR(50), application_date DATE); INSERT INTO veteran_jobs (id, state, application_date) VALUES (1, 'Texas', '2021-02-15'), (2, 'California', '2021-04-10'), (3, 'Texas', '2022-01-05');", "reference_sql": "SELECT COUNT(*) FROM veteran_jobs WHERE state = 'Texas' AND application_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR);", "generated_sql": "SELECT COUNT(*) FROM veteran_jobs WHERE state = 'Texas' AND application_date >= CURRENT_DATE - INTERVAL '1 year';", "raw_model_output": "\n\nSQL: SELECT COUNT(*) FROM veteran_jobs WHERE state = 'Texas' AND application_date >= CURRENT_DATE - INTERVAL '1 year';", "latency_sec": 0.28708505630493164, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 813, "prompt_eval_sec": null, "tokens_completion": 31, "completion_eval_sec": null, "tokens_total": 844, "tokens_per_sec": 2939.8952730703368, "retrieval_latency_sec": 0.12024784088134766, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the same date one year prior to the current date using different syntax. DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR) and CURRENT_DATE - INTERVAL '1 year' produce identical date values, so the WHERE clause conditions are semantically equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly count veteran job applications in Texas within the last year. The reference query uses MySQL's DATE_SUB function, while the generated query uses PostgreSQL-style interval subtraction (CURRENT_DATE - INTERVAL '1 year'). Both calculate the same date range for 'last year' and apply the same filters. The difference is syntactic and depends on the DBMS, but they produce identical results when valid in the same environment. Both fulfill the business intent of counting Texas veteran applications in the past year. Neither query is more efficient or elegant than the other; they are functionally equivalent.", "overall_assessment": "correct"}}
{"example_id": 2997, "sql_complexity": "window functions", "prompt": "What is the earliest capture time for each satellite image in the 'satellite_images' table?", "context": "CREATE TABLE satellite_images (image_id INT, image_url TEXT, capture_time TIMESTAMP); INSERT INTO satellite_images (image_id, image_url, capture_time) VALUES (1, 'image1.jpg', '2022-01-01 10:00:00'), (2, 'image2.jpg', '2021-05-01 10:00:00');", "reference_sql": "SELECT image_id, MIN(capture_time) OVER (PARTITION BY image_id) FROM satellite_images;", "generated_sql": "SELECT MIN(capture_time) FROM satellite_images;", "raw_model_output": "\n\nSELECT MIN(capture_time) FROM satellite_images;", "latency_sec": 0.2936520576477051, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 736, "prompt_eval_sec": null, "tokens_completion": 15, "completion_eval_sec": null, "tokens_total": 751, "tokens_per_sec": 2557.448451122301, "retrieval_latency_sec": 0.12844109535217285, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns each image_id with its own capture_time (since MIN() over a single-row partition equals the original value), producing two rows. The Generated SQL returns a single row with the absolute minimum capture_time across all images. The result sets differ in both structure (multiple rows vs. single value) and content.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL uses a window function to calculate the minimum capture_time per image_id, which aligns with the requirement to find the earliest capture time for each satellite image. However, since each image_id appears only once in the sample data, the MIN() over a single row returns the same value as the original capture_time. The Generated SQL incorrectly returns a single global minimum value instead of per-image results. While both queries are technically valid, the Reference SQL better addresses the business intent of retrieving per-image earliest capture times, even if the sample data doesn't fully demonstrate its utility.", "overall_assessment": "differently_correct"}}
{"example_id": 3743, "sql_complexity": "aggregation", "prompt": "What is the maximum budget spent on peacekeeping operations by each department?", "context": "CREATE TABLE DepartmentPeacekeeping (id INT, department VARCHAR(50), budget INT);", "reference_sql": "SELECT department, MAX(budget) FROM DepartmentPeacekeeping GROUP BY department;", "generated_sql": "SELECT department, MAX(budget) FROM DepartmentPeacekeeping GROUP BY department;", "raw_model_output": "\n\nSELECT department, MAX(budget) FROM DepartmentPeacekeeping GROUP BY department;", "latency_sec": 0.2144787311553955, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 571, "prompt_eval_sec": null, "tokens_completion": 20, "completion_eval_sec": null, "tokens_total": 591, "tokens_per_sec": 2755.5179798774775, "retrieval_latency_sec": 0.12433171272277832, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select the department and maximum budget from the DepartmentPeacekeeping table, grouping by department. Since the SQL statements are exactly the same, they will produce identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic. They correctly group by department and calculate the maximum budget for each department, which directly answers the question. The syntax is valid, the aggregation is properly used with GROUP BY, and the result will exactly match the business requirement. Since the queries are identical, neither is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 4664, "sql_complexity": "multiple_joins", "prompt": "Calculate the total number of volunteer hours contributed by volunteers from 'California' in 'Health' projects in 2021.", "context": "CREATE TABLE volunteers (volunteer_id INT, name VARCHAR(255), state VARCHAR(255));", "reference_sql": "SELECT SUM(vh.hours) as total_hours FROM volunteer_projects vp JOIN volunteer_hours vh ON vp.project_id = vh.project_id JOIN volunteers vol ON vh.volunteer_id = vol.volunteer_id WHERE vp.cause = 'Health' AND vol.state = 'California' AND vh.volunteer_date BETWEEN '2021-01-01' AND '2021-12-31';", "generated_sql": "Based on the provided schema, there is no table or column that contains information about \"projects\" or \"volunteer hours contributed by volunteers from 'California' in 'Health' projects in 2021.\" The only table available is `volunteers`, which contains `volunteer_id`, `name`, and `state`.\n\nSince the question involves \"volunteer hours\" and \"projects,\" but no such table or columns exist in the provided schema, it is not possible to construct a valid SQL query.\n\n**Answer:**  \nThe question cannot be answered with the provided schema because there is no table or column that contains information about volunteer hours or projects.", "raw_model_output": "\n\nBased on the provided schema, there is no table or column that contains information about \"projects\" or \"volunteer hours contributed by volunteers from 'California' in 'Health' projects in 2021.\" The only table available is `volunteers`, which contains `volunteer_id`, `name`, and `state`.\n\nSince the question involves \"volunteer hours\" and \"projects,\" but no such table or columns exist in the provided schema, it is not possible to construct a valid SQL query.\n\n**Answer:**  \nThe question cannot be answered with the provided schema because there is no table or column that contains information about volunteer hours or projects.", "latency_sec": 0.9597458839416504, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 950, "prompt_eval_sec": null, "tokens_completion": 136, "completion_eval_sec": null, "tokens_total": 1086, "tokens_per_sec": 1131.5495259430834, "retrieval_latency_sec": 0.12426400184631348, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL queries multiple tables (volunteer_projects, volunteer_hours, volunteers) to calculate total hours for California volunteers in Health projects, while the Generated 'SQL' is not a valid query but an explanation stating the schema lacks required tables/columns. The Generated content cannot be semantically equivalent to the Reference SQL as it does not represent a valid SQL query.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is technically invalid because it references tables ('volunteer_projects', 'volunteer_hours') and columns not present in the provided schema. The Generated SQL correctly identifies that the necessary data structures (projects, hours, and date fields) are missing from the schema. While both queries fail to fulfill the business intent due to schema limitations, the Generated SQL accurately explains the root cause rather than attempting to execute an invalid query. The Reference SQL would fail at runtime due to missing tables, whereas the Generated SQL properly acknowledges the constraints of the available data.", "overall_assessment": "incorrect"}}
{"example_id": 251, "sql_complexity": "set operations", "prompt": "Compare the number of economic diversification projects in two regions, one in Europe and one in Oceania, by showing the project type and the number of projects in each region.", "context": "CREATE TABLE economic_diversification (region VARCHAR(50), project_type VARCHAR(50), project_start_date DATE);", "reference_sql": "SELECT 'Europe' as region, project_type, COUNT(*) as project_count FROM economic_diversification WHERE region = 'Europe' UNION ALL SELECT 'Oceania' as region, project_type, COUNT(*) as project_count FROM economic_diversification WHERE region = 'Oceania';", "generated_sql": "SELECT 'Europe' AS region, project_type, COUNT(*) AS project_count \nFROM economic_diversification \nWHERE region = 'Europe' \nGROUP BY project_type \nUNION ALL \nSELECT 'Oceania' AS region, project_type, COUNT(*) AS project_count \nFROM economic_diversification \nWHERE region = 'Oceania' \nGROUP BY project_type;", "raw_model_output": "\n\n```sql\nSELECT 'Europe' AS region, project_type, COUNT(*) AS project_count \nFROM economic_diversification \nWHERE region = 'Europe' \nGROUP BY project_type \nUNION ALL \nSELECT 'Oceania' AS region, project_type, COUNT(*) AS project_count \nFROM economic_diversification \nWHERE region = 'Oceania' \nGROUP BY project_type;\n```", "latency_sec": 0.6314079761505127, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 749, "prompt_eval_sec": null, "tokens_completion": 85, "completion_eval_sec": null, "tokens_total": 834, "tokens_per_sec": 1320.8575619912572, "retrieval_latency_sec": 0.12632513046264648, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL lacks GROUP BY clauses, which would cause it to return incorrect aggregated results (e.g., counting all rows for each project_type instead of per-group counts). The Generated SQL properly groups by project_type, making them semantically different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL is technically incorrect because it lacks GROUP BY clauses, which would cause SQL syntax errors or return ambiguous results (e.g., a single arbitrary project_type per region). The Generated SQL correctly groups by project_type for each region, ensuring accurate counts per project type. While both queries use UNION ALL to separate regions, the Generated SQL properly structures the aggregation to answer the business question. The Reference fails to fulfill the intent as it would return only one row per region (with incomplete/incorrect project_type data), whereas the Generated SQL provides the required breakdown by project type.", "overall_assessment": "differently_correct"}}
{"example_id": 610, "sql_complexity": "subqueries", "prompt": "What is the percentage of community development projects completed in 'Caribbean' in 2020?", "context": "CREATE TABLE community_projects (project_id INT, project_name TEXT, location TEXT, completion_year INT); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (1, 'Community Center', 'Southern Region, Caribbean', 2020); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (2, 'Park Renovation', 'Northern Region, Caribbean', 2019); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (3, 'Library Construction', 'Caribbean', 2020);", "reference_sql": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM community_projects WHERE location = 'Caribbean')) FROM community_projects WHERE completion_year = 2020 AND location = 'Caribbean';", "generated_sql": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM community_projects WHERE location = 'Caribbean')) FROM community_projects WHERE completion_year = 2020 AND location = 'Caribbean';", "raw_model_output": "\n\nSELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM community_projects WHERE location = 'Caribbean')) FROM community_projects WHERE completion_year = 2020 AND location = 'Caribbean';", "latency_sec": 0.4563558101654053, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1010, "prompt_eval_sec": null, "tokens_completion": 50, "completion_eval_sec": null, "tokens_total": 1060, "tokens_per_sec": 2322.748996261941, "retrieval_latency_sec": 0.12763023376464844, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure, conditions, and subquery. Both queries calculate the percentage of projects completed in 2020 within the Caribbean region by using the same COUNT(*) logic and subquery for the denominator.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": false, "superiority": "equal", "explanation": "The reference and generated SQL queries are identical, so they are technically equivalent. However, they do not fully fulfill the business intent. The query filters for projects where location = 'Caribbean', but the sample data includes projects with locations like 'Southern Region, Caribbean' and 'Northern Region, Caribbean'. These would not be counted due to the exact string match, leading to an incomplete result. The business intent requires identifying all Caribbean projects regardless of regional subcategories, which the current query fails to address.", "overall_assessment": "differently_correct"}}
{"example_id": 421, "sql_complexity": "set operations", "prompt": "What is the combined landfill capacity for 'City A' and 'City B'?", "context": "CREATE TABLE landfill_capacity (city VARCHAR(255), capacity INT); INSERT INTO landfill_capacity (city, capacity) VALUES ('City A', 500000), ('City B', 600000);", "reference_sql": "SELECT SUM(capacity) FROM (SELECT capacity FROM landfill_capacity WHERE city = 'City A' UNION ALL SELECT capacity FROM landfill_capacity WHERE city = 'City B') AS combined_capacity;", "generated_sql": "SELECT SUM(capacity) AS combined_landfill_capacity FROM landfill_capacity WHERE city IN ('City A', 'City B');", "raw_model_output": "\n\nSELECT SUM(capacity) AS combined_landfill_capacity FROM landfill_capacity WHERE city IN ('City A', 'City B');", "latency_sec": 0.2746403217315674, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 821, "prompt_eval_sec": null, "tokens_completion": 29, "completion_eval_sec": null, "tokens_total": 850, "tokens_per_sec": 3094.9570501551752, "retrieval_latency_sec": 0.10134506225585938, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the total capacity of 'City A' and 'City B'. The reference query uses a subquery with UNION ALL to combine the capacities of each city before summing, while the generated query directly sums the capacities where the city is in the specified list. Since both approaches aggregate the same set of values, they produce identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the combined landfill capacity for 'City A' and 'City B'. The Reference SQL uses a subquery with UNION ALL to combine individual capacities before summing, while the Generated SQL directly sums capacities where city matches either value. Both produce identical numerical results. However, the Generated SQL is more efficient as it avoids unnecessary subquery complexity and performs a single table scan with a WHERE clause. The business intent of summing specific city capacities is equally fulfilled by both, but the Generated version is more elegant and optimized.", "overall_assessment": "correct"}}
{"example_id": 880, "sql_complexity": "aggregation", "prompt": "Show veteran employment statistics for each state in the 'veteran_employment' table", "context": "CREATE TABLE veteran_employment (employee_id INT, state VARCHAR(2), job_title VARCHAR(50), employment_date DATE);", "reference_sql": "SELECT state, COUNT(*) as veteran_employees FROM veteran_employment WHERE state IN ('CA', 'NY', 'TX', 'FL', 'PA') GROUP BY state;", "generated_sql": "SELECT state, COUNT(*) AS veteran_employees FROM veteran_employment GROUP BY state;", "raw_model_output": "\n\nSELECT state, COUNT(*) AS veteran_employees FROM veteran_employment GROUP BY state;", "latency_sec": 0.22996091842651367, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 628, "prompt_eval_sec": null, "tokens_completion": 22, "completion_eval_sec": null, "tokens_total": 650, "tokens_per_sec": 2826.567246502427, "retrieval_latency_sec": 0.1300978660583496, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters results to only include records where the state is in ('CA', 'NY', 'TX', 'FL', 'PA'), while the Generated SQL includes all states. This means the Generated SQL may return additional states not present in the Reference SQL's result set, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because the Reference SQL explicitly filters for specific states ('CA', 'NY', 'TX', 'FL', 'PA'), while the Generated SQL includes all states. The original question asks for statistics for 'each state' without restricting to specific states, making the Generated SQL more aligned with the business intent. The Reference SQL could be incorrect if the goal is to analyze all states, though it might be valid if the question implicitly referred to those specific states. However, since the question doesn't mention state restrictions, the Generated SQL better fulfills the intent by providing comprehensive data.", "overall_assessment": "correct"}}
{"example_id": 454, "sql_complexity": "single join", "prompt": "Which excavation sites have more than 10 artifacts?", "context": "CREATE TABLE ExcavationSite (SiteID INT, SiteName VARCHAR(50)); INSERT INTO ExcavationSite (SiteID, SiteName) VALUES (1, 'Site A'), (2, 'Site B'), (3, 'Site C'); CREATE TABLE Artifact (ArtifactID INT, SiteID INT, ObjectType VARCHAR(50)); INSERT INTO Artifact (ArtifactID, SiteID, ObjectType) VALUES (1, 1, 'Pottery'), (2, 1, 'Tool'), (3, 2, 'Statue'), (4, 2, 'Bead'), (5, 3, 'Bead'), (6, 3, 'Bead'), (7, 3, 'Bead'), (8, 3, 'Bead'), (9, 3, 'Bead'), (10, 3, 'Bead'), (11, 3, 'Bead');", "reference_sql": "SELECT e.SiteName FROM ExcavationSite e JOIN Artifact a ON e.SiteID = a.SiteID GROUP BY e.SiteName HAVING COUNT(a.ArtifactID) > 10;", "generated_sql": "SELECT SiteName \nFROM ExcavationSite \nWHERE SiteID IN (\n    SELECT SiteID \n    FROM Artifact \n    GROUP BY SiteID \n    HAVING COUNT(ArtifactID) > 10\n);", "raw_model_output": "\n\nSELECT SiteName \nFROM ExcavationSite \nWHERE SiteID IN (\n    SELECT SiteID \n    FROM Artifact \n    GROUP BY SiteID \n    HAVING COUNT(ArtifactID) > 10\n);", "latency_sec": 0.40877294540405273, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1135, "prompt_eval_sec": null, "tokens_completion": 49, "completion_eval_sec": null, "tokens_total": 1184, "tokens_per_sec": 2896.4734905087025, "retrieval_latency_sec": 0.12158608436584473, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in how they handle grouping and filtering. The reference query groups by SiteName (which may not be unique) and counts artifacts per group, while the generated query filters SiteIDs with more than 10 artifacts first. If multiple sites shared the same SiteName, the reference query would aggregate their artifact counts, potentially meeting the HAVING condition even if individual sites didn't. The generated query would not. Since the schema doesn't enforce SiteName uniqueness, the queries are not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify excavation sites with more than 10 artifacts. The reference query uses a JOIN and groups by SiteName, which could be problematic if multiple sites share the same name (though the sample data shows unique names). The generated query uses a subquery with SiteID, which is the primary key and ensures accurate grouping. While both produce identical results in the given schema, the generated query is more efficient and robust for real-world scenarios with potential name duplicates. The business intent is fully addressed by both, but the generated version better aligns with relational integrity principles.", "overall_assessment": "correct"}}
{"example_id": 1086, "sql_complexity": "aggregation", "prompt": "What is the total CO2 emission for each equipment type, excluding equipment that is older than 8 years?", "context": "CREATE TABLE EmissionData (EquipmentID INT, EquipmentType VARCHAR(50), CO2Emission INT, Age INT); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (1, 'Excavator', 50, 8); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (2, 'Haul Truck', 70, 7); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (3, 'Shovel', 30, 6); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (4, 'Drilling Rig', 40, 3);", "reference_sql": "SELECT EquipmentType, SUM(CO2Emission) as TotalCO2Emission FROM EmissionData WHERE Age <= 8 GROUP BY EquipmentType;", "generated_sql": "SELECT EquipmentType, SUM(CO2Emission) AS TotalCO2Emission \nFROM EmissionData \nWHERE Age <= 8 \nGROUP BY EquipmentType;", "raw_model_output": "\n\n```sql\nSELECT EquipmentType, SUM(CO2Emission) AS TotalCO2Emission \nFROM EmissionData \nWHERE Age <= 8 \nGROUP BY EquipmentType;\n```", "latency_sec": 0.47507500648498535, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 872, "prompt_eval_sec": null, "tokens_completion": 43, "completion_eval_sec": null, "tokens_total": 915, "tokens_per_sec": 1926.0116560750253, "retrieval_latency_sec": 0.1166679859161377, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select EquipmentType and sum CO2Emission with the same WHERE condition (Age <= 8) and GROUP BY clause. The only difference is formatting (line breaks), which does not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure, logic, and output. They correctly filter equipment with Age <= 8, group by EquipmentType, and calculate the sum of CO2Emission. The WHERE condition explicitly excludes equipment older than 8 years as required. The formatting differences (e.g., line breaks, capitalization) do not affect functionality. Neither query is more efficient or elegant than the other since they are functionally identical.", "overall_assessment": "correct"}}
{"example_id": 3455, "sql_complexity": "basic SQL", "prompt": "What are the names of all innovation projects in the 'rural_infrastructure' table, excluding those with a budget over 50000?", "context": "CREATE TABLE rural_infrastructure (name VARCHAR(255), budget INT); INSERT INTO rural_infrastructure (name, budget) VALUES ('Dam Construction', 40000), ('Well Digging', 30000), ('Irrigation System', 70000);", "reference_sql": "SELECT name FROM rural_infrastructure WHERE budget <= 50000;", "generated_sql": "SELECT name FROM rural_infrastructure WHERE budget <= 50000;", "raw_model_output": "\n\nSELECT name FROM rural_infrastructure WHERE budget <= 50000;", "latency_sec": 0.2336561679840088, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 961, "prompt_eval_sec": null, "tokens_completion": 21, "completion_eval_sec": null, "tokens_total": 982, "tokens_per_sec": 4202.756590903294, "retrieval_latency_sec": 0.12989211082458496, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They select the 'name' column from the 'rural_infrastructure' table where the 'budget' is less than or equal to 50000. The result set will contain the same rows ('Dam Construction' and 'Well Digging') as both queries apply the exact same filter condition.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic. They correctly select project names from the rural_infrastructure table where budget is less than or equal to 50000, which directly addresses the requirement to exclude projects with budgets over 50000. The queries are syntactically correct, semantically equivalent, and efficiently achieve the business goal. Since the reference and generated queries are exactly the same, neither is superior to the other.", "overall_assessment": "correct"}}
{"example_id": 3936, "sql_complexity": "window functions", "prompt": "What is the total investment per client for each investment type?", "context": "CREATE TABLE clients (client_id INT, name TEXT, investment_type TEXT, investment FLOAT); INSERT INTO clients (client_id, name, investment_type, investment) VALUES (1, 'John Doe', 'Stocks', 3000.00), (1, 'John Doe', 'Bonds', 2000.00), (2, 'Jane Smith', 'Stocks', 5000.00);", "reference_sql": "SELECT client_id, name, investment_type, SUM(investment) OVER (PARTITION BY client_id, investment_type ORDER BY client_id) as total_investment FROM clients;", "generated_sql": "SELECT client_id, investment_type, SUM(investment) AS total_investment FROM clients GROUP BY client_id, investment_type;", "raw_model_output": "\n\nSELECT client_id, investment_type, SUM(investment) AS total_investment FROM clients GROUP BY client_id, investment_type;", "latency_sec": 0.2805178165435791, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 810, "prompt_eval_sec": null, "tokens_completion": 30, "completion_eval_sec": null, "tokens_total": 840, "tokens_per_sec": 2994.4622068933863, "retrieval_latency_sec": 0.12256383895874023, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL uses a window function to retain individual rows with a calculated total_investment, including the 'name' column. The Generated SQL aggregates rows using GROUP BY, omitting the 'name' column and reducing the result set to one row per client_id/investment_type combination. While both calculate sums, their output structures and row counts differ.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query uses a window function that calculates a running total within partitions, but the ORDER BY client_id is unnecessary and could produce misleading results if there are multiple entries per client. It also includes the 'name' column which isn't required. The generated query correctly groups by client_id and investment_type, aggregating investments with SUM, which directly answers the question. While both queries could return similar numerical results in this specific dataset, the generated query is semantically and technically superior for the business intent.", "overall_assessment": "correct"}}
{"example_id": 1838, "sql_complexity": "window functions", "prompt": "What are the top 3 species with the most sightings across all arctic research stations?", "context": "CREATE TABLE research_station (id INT, name TEXT); INSERT INTO research_station (id, name) VALUES (1, 'Station A'); INSERT INTO research_station (id, name) VALUES (2, 'Station B'); CREATE TABLE species_observations (station_id INT, species_name TEXT, sightings INT); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (1, 'Species 1', 10); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (1, 'Species 2', 5); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (2, 'Species 1', 8); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (2, 'Species 3', 15);", "reference_sql": "SELECT species_name, SUM(sightings) as total_sightings, RANK() OVER (ORDER BY SUM(sightings) DESC) as rank FROM species_observations GROUP BY species_name HAVING rank <= 3;", "generated_sql": "SELECT species_name, SUM(sightings) AS total_sightings FROM species_observations GROUP BY species_name ORDER BY total_sightings DESC LIMIT 3;", "raw_model_output": "\n\nSELECT species_name, SUM(sightings) AS total_sightings FROM species_observations GROUP BY species_name ORDER BY total_sightings DESC LIMIT 3;", "latency_sec": 0.4447910785675049, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1120, "prompt_eval_sec": null, "tokens_completion": 38, "completion_eval_sec": null, "tokens_total": 1158, "tokens_per_sec": 2603.4694844362825, "retrieval_latency_sec": 0.12327289581298828, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a RANK() window function and HAVING rank <= 3, which is invalid syntax because window functions cannot be used in HAVING clauses. The Generated SQL correctly uses ORDER BY and LIMIT to get top 3 results. Even if the Reference SQL were valid, it would return an extra 'rank' column not present in the Generated SQL, making their output structures different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL contains a critical technical error: the HAVING clause references 'rank' which is an alias from the SELECT list, but HAVING cannot use column aliases. This would cause a syntax error. The Generated SQL correctly groups, sums, orders, and limits without syntax issues. Both queries aim to find top species by sightings, but only the Generated SQL executes properly. The Reference SQL's use of RANK() is unnecessary for this simple top-3 requirement and introduces logical flaws (e.g., rank filtering in HAVING). The Generated SQL is more efficient and directly addresses the business question.", "overall_assessment": "incorrect"}}
{"example_id": 3091, "sql_complexity": "single join", "prompt": "Find the number of hybrid vehicles sold in the US, Germany, and Japan.", "context": "CREATE TABLE vehicle_sales (sale_id INT, vehicle_id INT, country VARCHAR(20), quantity INT); CREATE TABLE vehicles (vehicle_id INT, model VARCHAR(20), manufacture VARCHAR(20), vehicle_type VARCHAR(20));", "reference_sql": "SELECT SUM(vs.quantity) FROM vehicle_sales vs JOIN vehicles v ON vs.vehicle_id = v.vehicle_id WHERE v.vehicle_type = 'hybrid' AND vs.country IN ('US', 'Germany', 'Japan');", "generated_sql": "SELECT SUM(vs.quantity) \nFROM vehicle_sales vs \nJOIN vehicles v ON vs.vehicle_id = v.vehicle_id \nWHERE v.vehicle_type = 'hybrid' \nAND vs.country IN ('US', 'Germany', 'Japan');", "raw_model_output": "\n\nSELECT SUM(vs.quantity) \nFROM vehicle_sales vs \nJOIN vehicles v ON vs.vehicle_id = v.vehicle_id \nWHERE v.vehicle_type = 'hybrid' \nAND vs.country IN ('US', 'Germany', 'Japan');", "latency_sec": 0.5114068984985352, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 828, "prompt_eval_sec": null, "tokens_completion": 51, "completion_eval_sec": null, "tokens_total": 879, "tokens_per_sec": 1718.7879212828368, "retrieval_latency_sec": 0.12127184867858887, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure, conditions, and logic. Both perform a JOIN between vehicle_sales and vehicles on vehicle_id, filter for hybrid vehicle_type and countries in ('US', 'Germany', 'Japan'), and calculate the sum of quantity. No semantic differences exist.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are syntactically identical, with the same JOIN logic, WHERE conditions, and aggregation. They correctly filter for hybrid vehicles ('hybrid' in vehicle_type) and sales in the specified countries (US, Germany, Japan). The SUM(vs.quantity) accurately calculates total units sold. No differences exist in logic, efficiency, or structure. Both queries perfectly address the business requirement by combining vehicle type and geographic filters.", "overall_assessment": "correct"}}
{"example_id": 2399, "sql_complexity": "set operations", "prompt": "What is the average duration of criminal trials for Indigenous defendants compared to non-Indigenous defendants in Canada and New Zealand?", "context": "CREATE TABLE canada_criminal_trials (id INT, defendant_type VARCHAR(255), days_to_completion INT); INSERT INTO canada_criminal_trials (id, defendant_type, days_to_completion) VALUES (1, 'Indigenous', 60), (2, 'Non-Indigenous', 45);CREATE TABLE nz_criminal_trials (id INT, defendant_type VARCHAR(255), days_to_completion INT); INSERT INTO nz_criminal_trials (id, defendant_type, days_to_completion) VALUES (1, 'Indigenous', 70), (2, 'Non-Indigenous', 50);", "reference_sql": "SELECT AVG(days_to_completion) AS avg_duration FROM canada_criminal_trials WHERE defendant_type = 'Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM canada_criminal_trials WHERE defendant_type = 'Non-Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM nz_criminal_trials WHERE defendant_type = 'Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM nz_criminal_trials WHERE defendant_type = 'Non-Indigenous';", "generated_sql": "SELECT \n  'Canada' AS country, \n  defendant_type, \n  AVG(days_to_completion) AS average_duration \nFROM canada_criminal_trials \nGROUP BY defendant_type \nUNION ALL \nSELECT \n  'New Zealand' AS country, \n  defendant_type, \n  AVG(days_to_completion) AS average_duration \nFROM nz_criminal_trials \nGROUP BY defendant_type;", "raw_model_output": "\n\nSELECT \n  'Canada' AS country, \n  defendant_type, \n  AVG(days_to_completion) AS average_duration \nFROM canada_criminal_trials \nGROUP BY defendant_type \nUNION ALL \nSELECT \n  'New Zealand' AS country, \n  defendant_type, \n  AVG(days_to_completion) AS average_duration \nFROM nz_criminal_trials \nGROUP BY defendant_type;", "latency_sec": 0.6123721599578857, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 944, "prompt_eval_sec": null, "tokens_completion": 82, "completion_eval_sec": null, "tokens_total": 1026, "tokens_per_sec": 1675.451738482952, "retrieval_latency_sec": 0.12072300910949707, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL returns four rows with only average durations (no country or defendant_type columns), while the Generated SQL returns four rows with country, defendant_type, and average_duration. The Generated SQL includes additional contextual information (country) and structures the output differently, leading to different result set schemas despite identical numerical averages.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the average trial durations for Indigenous and non-Indigenous defendants in Canada and New Zealand. The reference query uses four separate SELECT statements with UNION ALL, while the generated query uses GROUP BY to organize results by country and defendant type. The generated query is more efficient and elegant, as it avoids repetitive subqueries and structures the output to explicitly show country and defendant type relationships. Both produce identical numerical results, but the generated query better supports comparative analysis by contextualizing averages within their respective countries.", "overall_assessment": "correct"}}
{"example_id": 2972, "sql_complexity": "set operations", "prompt": "How many indigenous communities are in the Arctic Research Station 13 and 14?", "context": "CREATE TABLE Arctic_Research_Station_13 (id INT, community TEXT); CREATE TABLE Arctic_Research_Station_14 (id INT, community TEXT);", "reference_sql": "SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_13; SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_14; SELECT COUNT(DISTINCT community) FROM (SELECT * FROM Arctic_Research_Station_13 UNION ALL SELECT * FROM Arctic_Research_Station_14) AS Arctic_Communities;", "generated_sql": "SELECT COUNT(DISTINCT community) FROM (SELECT community FROM Arctic_Research_Station_13 UNION ALL SELECT community FROM Arctic_Research_Station_14) AS All_Communities;", "raw_model_output": "\n\nSELECT COUNT(DISTINCT community) FROM (SELECT community FROM Arctic_Research_Station_13 UNION ALL SELECT community FROM Arctic_Research_Station_14) AS All_Communities;", "latency_sec": 0.3703608512878418, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 697, "prompt_eval_sec": null, "tokens_completion": 44, "completion_eval_sec": null, "tokens_total": 741, "tokens_per_sec": 2000.7514223583532, "retrieval_latency_sec": 0.12629199028015137, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count distinct 'community' values from both tables. The Reference's third query uses SELECT * in the subquery (including id and community) but only counts 'community' in the outer query. The Generated SQL directly selects only 'community' in the subquery, achieving the same result with less data processing.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count distinct indigenous communities across stations 13 and 14. The Reference SQL achieves this via three separate queries (including two station-specific counts and a combined count), while the Generated SQL directly combines both tables using UNION ALL and counts distinct communities in a single query. The generated version is more efficient as it avoids redundant table scans and explicitly selects only the 'community' column, reducing data processing overhead. Both produce identical results, but the generated query is more elegant and optimized.", "overall_assessment": "correct"}}
{"example_id": 5576, "sql_complexity": "window functions", "prompt": "Who are the top 5 users with the most followers, and what is their location?", "context": "CREATE TABLE user_data (user_id INT, name VARCHAR(50), followers INT, location VARCHAR(50)); INSERT INTO user_data (user_id, name, followers, location) VALUES (1, 'Alice', 10000, 'New York'), (2, 'Bob', 15000, 'California'), (3, 'Charlie', 12000, 'Texas'), (4, 'David', 8000, 'Florida'), (5, 'Eve', 9000, 'Illinois');", "reference_sql": "SELECT name, location FROM (SELECT name, location, ROW_NUMBER() OVER (ORDER BY followers DESC) AS rank FROM user_data) AS user_ranks WHERE rank <= 5;", "generated_sql": "SELECT name, followers, location FROM user_data ORDER BY followers DESC LIMIT 5;", "raw_model_output": "\n\nSELECT name, followers, location FROM user_data ORDER BY followers DESC LIMIT 5;", "latency_sec": 0.27805423736572266, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 940, "prompt_eval_sec": null, "tokens_completion": 22, "completion_eval_sec": null, "tokens_total": 962, "tokens_per_sec": 3459.7566615562437, "retrieval_latency_sec": 0.11601495742797852, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL returns only 'name' and 'location' columns, while the Generated SQL includes 'followers' as well. Additionally, the Reference SQL uses a window function to assign ranks, which could behave differently in edge cases with tied followers counts (though both would return top 5 by followers DESC). The column differences make their result sets structurally distinct.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent. The Reference SQL correctly returns only 'name' and 'location' as requested, while the Generated SQL includes an extra 'followers' column not required by the question. Both identify the top 5 users by followers, but the Reference explicitly ranks users using ROW_NUMBER() which ensures deterministic ordering (critical for ties). The Generated SQL is more efficient but fails to match the exact output structure. The Reference better fulfills the business intent by returning precisely the requested fields.", "overall_assessment": "differently_correct"}}
{"example_id": 1560, "sql_complexity": "basic SQL", "prompt": "What is the average media literacy score for users in the 'Young Adult' age group who have completed at least one disinformation detection course?", "context": "CREATE TABLE users (id INT, age VARCHAR(20), media_literacy_score INT, courses_completed INT);", "reference_sql": "SELECT AVG(media_literacy_score) FROM users WHERE age = 'Young Adult' AND courses_completed > 0;", "generated_sql": "SELECT AVG(media_literacy_score) FROM users WHERE age = 'Young Adult' AND courses_completed > 0;", "raw_model_output": "\n\nSELECT AVG(media_literacy_score) FROM users WHERE age = 'Young Adult' AND courses_completed > 0;", "latency_sec": 0.2689080238342285, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 568, "prompt_eval_sec": null, "tokens_completion": 29, "completion_eval_sec": null, "tokens_total": 597, "tokens_per_sec": 2220.0899455794133, "retrieval_latency_sec": 0.12859392166137695, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure, conditions, and target columns. Both queries select the average media_literacy_score from the users table where age equals 'Young Adult' and courses_completed is greater than 0. Since the queries are exactly the same, they will produce identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic. They correctly calculate the average media literacy score for 'Young Adult' users with courses_completed > 0, which directly addresses the requirement of 'completed at least one disinformation detection course'. The queries are technically correct, semantically equivalent, and fulfill the business intent equally well. Since they are identical, neither is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 1201, "sql_complexity": "basic SQL", "prompt": "What is the maximum energy efficiency rating of hydroelectric dams in Canada?", "context": "CREATE TABLE hydro_dams (id INT, name TEXT, country TEXT, energy_efficiency_rating FLOAT); INSERT INTO hydro_dams (id, name, country, energy_efficiency_rating) VALUES (1, 'Robert-Bourassa', 'Canada', 0.94), (2, 'Churchill Falls', 'Canada', 0.92);", "reference_sql": "SELECT MAX(energy_efficiency_rating) FROM hydro_dams WHERE country = 'Canada';", "generated_sql": "SELECT MAX(energy_efficiency_rating) FROM hydro_dams WHERE country = 'Canada';", "raw_model_output": "\n\nSELECT MAX(energy_efficiency_rating) FROM hydro_dams WHERE country = 'Canada';", "latency_sec": 0.2364940643310547, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 651, "prompt_eval_sec": null, "tokens_completion": 23, "completion_eval_sec": null, "tokens_total": 674, "tokens_per_sec": 2849.965820099846, "retrieval_latency_sec": 0.1252152919769287, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They select the maximum energy_efficiency_rating from the hydro_dams table where the country is 'Canada'. The SQL syntax, table name, column names, and WHERE condition are exactly the same in both queries.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic. They correctly filter for Canadian hydroelectric dams and calculate the maximum energy efficiency rating. The queries are technically identical, so they produce the same results, fulfill the business intent of finding the maximum rating for Canadian dams, and neither is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 4243, "sql_complexity": "single join", "prompt": "How many orders were placed by new and returning customers in each month of the year 2021?'", "context": "CREATE TABLE customer (id INT, first_order_date DATE, last_order_date DATE);", "reference_sql": "INSERT INTO customer (id, first_order_date, last_order_date) SELECT customer_id, MIN(order_date) AS first_order_date, MAX(order_date) AS last_order_date FROM orders GROUP BY customer_id; SELECT YEAR(order_date) AS year, MONTH(order_date) AS month, CASE WHEN DATEDIFF(last_order_date, first_order_date) > 30 THEN 'returning' ELSE 'new' END AS customer_type, COUNT(DISTINCT id) AS num_orders FROM orders JOIN customer ON orders.customer_id = customer.id WHERE YEAR(order_date) = 2021 GROUP BY year, month, customer_type;", "generated_sql": "To answer the question \"How many orders were placed by new and returning customers in each month of the year 2021?\" we need to determine whether a customer is \"new\" or \"returning\" based on their first and last order dates. However, the provided schema only contains the `customer` table with `id`, `first_order_date`, and `last_order_date`. There is no table that contains actual order data (e.g., `order_date`, `customer_id`, etc.).\n\nGiven this limitation, we cannot directly determine how many orders were placed by new and returning customers in each month of 2021, as we lack the necessary data about individual orders.\n\n### Final Answer:\nThe question cannot be answered with the provided schema because there is no table containing order data (e.g., `order_date`, `customer_id`). The `customer` table only contains `first_order_date` and `last_order_date`, which are not sufficient to determine the number of orders placed by each customer in each month.", "raw_model_output": "\n\nTo answer the question \"How many orders were placed by new and returning customers in each month of the year 2021?\" we need to determine whether a customer is \"new\" or \"returning\" based on their first and last order dates. However, the provided schema only contains the `customer` table with `id`, `first_order_date`, and `last_order_date`. There is no table that contains actual order data (e.g., `order_date`, `customer_id`, etc.).\n\nGiven this limitation, we cannot directly determine how many orders were placed by new and returning customers in each month of 2021, as we lack the necessary data about individual orders.\n\n### Final Answer:\nThe question cannot be answered with the provided schema because there is no table containing order data (e.g., `order_date`, `customer_id`). The `customer` table only contains `first_order_date` and `last_order_date`, which are not sufficient to determine the number of orders placed by each customer in each month.", "latency_sec": 1.4356169700622559, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 790, "prompt_eval_sec": null, "tokens_completion": 214, "completion_eval_sec": null, "tokens_total": 1004, "tokens_per_sec": 699.350886021124, "retrieval_latency_sec": 0.12552905082702637, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL assumes the existence of an 'orders' table with 'customer_id' and 'order_date' columns, but the provided schema only includes a 'customer' table with 'id', 'first_order_date', and 'last_order_date'. The Generated SQL correctly identifies that the necessary order data is missing, making the Reference SQL invalid. The queries cannot be semantically equivalent due to this fundamental schema discrepancy.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL assumes the existence of an 'orders' table with customer_id and order_date columns, which is not part of the provided schema. The context only includes a 'customer' table with id, first_order_date, and last_order_date. The Generated SQL correctly identifies this critical schema mismatch: the question requires order-level data (e.g., order_date, customer_id) to count monthly orders, but the available schema only contains customer-level metadata (first/last order dates). Neither query is technically valid given the constraints, but the Generated SQL properly highlights the fundamental data deficiency.", "overall_assessment": "incorrect"}}
{"example_id": 2321, "sql_complexity": "subqueries", "prompt": "What are the names and types of vessels used in research expeditions in the regions with the lowest ocean acidification levels?", "context": "CREATE TABLE ocean_acidification (id INT PRIMARY KEY, region VARCHAR(255), year INT, acidification_level INT); INSERT INTO ocean_acidification (id, region, year, acidification_level) VALUES (1, 'Arctic Ocean', 2018, 20), (2, 'Southern Ocean', 2019, 22); CREATE TABLE expedition_vessels (id INT PRIMARY KEY, name VARCHAR(255), type VARCHAR(255), region VARCHAR(255)); INSERT INTO expedition_vessels (id, name, type, region) VALUES (1, 'Sea Researcher', 'Research Vessel', 'Arctic Ocean');", "reference_sql": "SELECT v.name, v.type FROM expedition_vessels v INNER JOIN ocean_acidification oa ON v.region = oa.region WHERE oa.acidification_level = (SELECT MIN(acidification_level) FROM ocean_acidification);", "generated_sql": "SELECT ev.name, ev.type\nFROM expedition_vessels ev\nWHERE ev.region IN (\n    SELECT oa.region\n    FROM ocean_acidification oa\n    ORDER BY oa.acidification_level ASC\n    LIMIT 1\n);", "raw_model_output": "\n\nTo answer the question, we need to find the regions with the lowest ocean acidification levels from the `ocean_acidification` table, and then get the names and types of vessels from the `expedition_vessels` table that operate in those regions.\n\nHere is the SQL query:\n\n```sql\nSELECT ev.name, ev.type\nFROM expedition_vessels ev\nWHERE ev.region IN (\n    SELECT oa.region\n    FROM ocean_acidification oa\n    ORDER BY oa.acidification_level ASC\n    LIMIT 1\n);\n```", "latency_sec": 0.8338449001312256, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 906, "prompt_eval_sec": null, "tokens_completion": 117, "completion_eval_sec": null, "tokens_total": 1023, "tokens_per_sec": 1226.8468630545156, "retrieval_latency_sec": 0.11721086502075195, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL finds all regions with the minimum acidification_level and joins with vessels in those regions. The Generated SQL selects only one region (the first in order by acidification_level) and retrieves vessels in that single region. If multiple regions share the minimum acidification_level, the Generated SQL would miss some, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query correctly identifies all regions with the absolute minimum acidification level using = (SELECT MIN(...)), ensuring all relevant vessels are included. The generated query uses LIMIT 1, which would only return a single region even if multiple regions share the lowest acidification level (e.g., if two regions have the same minimum value). This makes the generated query technically incorrect in cases of ties. While both queries aim to find low acidification regions, the reference properly addresses the business intent of capturing all such regions. The reference is more elegant and precise for this specific question.", "overall_assessment": "correct"}}
{"example_id": 4349, "sql_complexity": "multiple_joins", "prompt": "Show the research grants awarded to professors in the Computer Science department.", "context": "CREATE TABLE departments (id INT, name VARCHAR(50)); INSERT INTO departments (id, name) VALUES (1, 'Computer Science'), (2, 'Mathematics'); CREATE TABLE professors (id INT, name VARCHAR(50), department_id INT); INSERT INTO professors (id, name, department_id) VALUES (1, 'John Smith', 1), (2, 'Jane Doe', 2); CREATE TABLE grants (id INT, professor_id INT, year INT, amount FLOAT); INSERT INTO grants (id, professor_id, year, amount) VALUES (1, 1, 2021, 5000.0), (2, 2, 2020, 7000.0);", "reference_sql": "SELECT professors.name, grants.amount FROM professors INNER JOIN grants ON professors.id = grants.professor_id INNER JOIN departments ON professors.department_id = departments.id WHERE departments.name = 'Computer Science';", "generated_sql": "SELECT g.amount FROM grants g JOIN professors p ON g.professor_id = p.id JOIN departments d ON p.department_id = d.id WHERE d.name = 'Computer Science';", "raw_model_output": "\n\nSELECT g.amount FROM grants g JOIN professors p ON g.professor_id = p.id JOIN departments d ON p.department_id = d.id WHERE d.name = 'Computer Science';", "latency_sec": 0.4489099979400635, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 883, "prompt_eval_sec": null, "tokens_completion": 40, "completion_eval_sec": null, "tokens_total": 923, "tokens_per_sec": 2056.091430877944, "retrieval_latency_sec": 0.12275028228759766, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL selects both professors.name and grants.amount, while the Generated SQL only selects grants.amount. Although both queries join the same tables and apply the same WHERE condition, the difference in selected columns makes their result sets non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because the reference query includes professor names while the generated query only returns grant amounts. However, the original question asks to 'show the research grants' without explicitly requiring professor names. The generated query is more focused on the grants themselves (aligning with the phrasing 'research grants awarded to professors') and uses concise aliases. Both queries correctly join the necessary tables and filter by the Computer Science department. The generated query is more efficient as it avoids unnecessary columns while still fulfilling the business intent.", "overall_assessment": "differently_correct"}}
{"example_id": 476, "sql_complexity": "basic SQL", "prompt": "Insert new food safety records for locations \"A123\", \"B456\", and \"C789\"", "context": "CREATE TABLE food_safety_records (id INT, location VARCHAR(255), inspection_date DATE, violation_count INT);", "reference_sql": "INSERT INTO food_safety_records (location, inspection_date, violation_count) VALUES ('A123', '2022-03-01', 0), ('B456', '2022-03-05', 2), ('C789', '2022-03-10', 1);", "generated_sql": "INSERT INTO food_safety_records (location) VALUES ('A123'), ('B456'), ('C789');", "raw_model_output": "\n\nINSERT INTO food_safety_records (location) VALUES ('A123'), ('B456'), ('C789');", "latency_sec": 0.2967689037322998, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 645, "prompt_eval_sec": null, "tokens_completion": 33, "completion_eval_sec": null, "tokens_total": 678, "tokens_per_sec": 2284.605939076385, "retrieval_latency_sec": 0.11611628532409668, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL inserts values for all three columns (location, inspection_date, violation_count), while the Generated SQL only inserts values for the location column. The other columns (inspection_date and violation_count) would either be NULL or use default values, leading to different data being inserted into the table.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference SQL correctly inserts complete records with all required fields (location, inspection_date, violation_count) for each specified location. The generated SQL only inserts the 'location' field, leaving other columns as NULL. While both are syntactically valid, they produce different data outcomes. The original question implies inserting full records, not just location identifiers. The reference SQL better fulfills the business intent by providing complete data, whereas the generated SQL lacks critical information (dates and violation counts) that would make the records meaningful for food safety tracking.", "overall_assessment": "differently_correct"}}
{"example_id": 2908, "sql_complexity": "single join", "prompt": "List all co-owners and the properties they own in New York, NY.", "context": "CREATE TABLE properties (id INT, city VARCHAR(50), price INT); CREATE TABLE co_owners (property_id INT, owner_name VARCHAR(50)); INSERT INTO properties (id, city, price) VALUES (1, 'New York', 800000), (2, 'Los Angeles', 600000); INSERT INTO co_owners (property_id, owner_name) VALUES (1, 'David'), (1, 'Ella'), (2, 'Frank');", "reference_sql": "SELECT properties.city, co_owners.owner_name FROM properties INNER JOIN co_owners ON properties.id = co_owners.property_id WHERE properties.city = 'New York';", "generated_sql": "SELECT co.owner_name, p.id, p.city, p.price FROM co_owners co INNER JOIN properties p ON co.property_id = p.id WHERE p.city = 'New York';", "raw_model_output": "\n\nSQL: SELECT co.owner_name, p.id, p.city, p.price FROM co_owners co INNER JOIN properties p ON co.property_id = p.id WHERE p.city = 'New York';", "latency_sec": 0.3682129383087158, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 762, "prompt_eval_sec": null, "tokens_completion": 44, "completion_eval_sec": null, "tokens_total": 806, "tokens_per_sec": 2188.950784027682, "retrieval_latency_sec": 0.1202230453491211, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects only 'city' and 'owner_name', while the Generated SQL selects 'owner_name', 'id', 'city', and 'price'. The additional columns in the Generated SQL (id, price) and the different column order change the result set structure, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because they return different columns. The reference query only returns 'city' and 'owner_name', while the generated query returns 'owner_name', 'id', 'city', and 'price'. Both correctly identify co-owners in New York, NY, but the generated query provides more comprehensive property details (ID, price) that better align with the business intent of 'listing properties they own'. The generated query is more elegant with explicit aliases and includes all property attributes, making it more informative for business analysis.", "overall_assessment": "differently_correct"}}
{"example_id": 636, "sql_complexity": "set operations", "prompt": "Insert new data into the 'cosmetic_ingredients' table for a vegan eyeshadow product by brand 'Ara' with ingredients 'Mica', 'Iron Oxide', 'Titanium Dioxide' and 'Zinc Oxide'.", "context": "CREATE TABLE cosmetic_ingredients (ingredient_id INT, product_name TEXT, brand_name TEXT, ingredient_type TEXT);", "reference_sql": "INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type) VALUES (NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient'); INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type, ingredient_name) SELECT ingredient_id, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Mica' FROM cosmetic_ingredients WHERE ingredient_name = 'Mica' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Iron Oxide' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Titanium Dioxide' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Zinc Oxide';", "generated_sql": "INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type) VALUES ((SELECT MAX(ingredient_id) FROM cosmetic_ingredients)+1, 'Vegan Eyeshadow', 'Ara', 'Mica'), ((SELECT MAX(ingredient_id) FROM cosmetic_ingredients)+1, 'Vegan Eyeshadow', 'Ara', 'Iron Oxide'), ((SELECT MAX(ingredient_id) FROM cosmetic_ingredients)+1, 'Vegan Eyeshadow', 'Ara', 'Titanium Dioxide'), ((SELECT MAX(ingredient_id) FROM cosmetic_ingredients)+1, 'Vegan Eyeshadow', 'Ara', 'Zinc Oxide');", "raw_model_output": "\n\nINSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type) VALUES ((SELECT MAX(ingredient_id) FROM cosmetic_ingredients)+1, 'Vegan Eyeshadow', 'Ara', 'Mica'), ((SELECT MAX(ingredient_id) FROM cosmetic_ingredients)+1, 'Vegan Eyeshadow', 'Ara', 'Iron Oxide'), ((SELECT MAX(ingredient_id) FROM cosmetic_ingredients)+1, 'Vegan Eyeshadow', 'Ara', 'Titanium Dioxide'), ((SELECT MAX(ingredient_id) FROM cosmetic_ingredients)+1, 'Vegan Eyeshadow', 'Ara', 'Zinc Oxide');", "latency_sec": 1.0056350231170654, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 760, "prompt_eval_sec": null, "tokens_completion": 145, "completion_eval_sec": null, "tokens_total": 905, "tokens_per_sec": 899.9288799577234, "retrieval_latency_sec": 0.13939309120178223, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL attempts to insert rows with a fixed 'Ingredient' type and includes an invalid 'ingredient_name' column (not present in the schema). The Generated SQL inserts multiple rows with ingredient names directly into the 'ingredient_type' column, which changes the data semantics. Additionally, the Reference SQL includes an initial INSERT with NULL ingredient_id, while the Generated SQL uses MAX(ingredient_id)+1 for all inserts, leading to different data structures and values.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries are not technically equivalent. The Reference SQL contains critical errors: it references an 'ingredient_name' column not present in the schema, and the first INSERT statement incorrectly uses 'Ingredient' as the ingredient_type without associating it with specific ingredients. The Generated SQL attempts to insert all four ingredients in a single statement but has a logical flaw: using (SELECT MAX(ingredient_id) + 1) for all rows would produce duplicate ingredient_ids if executed concurrently or if the table is empty (MAX returns NULL). While both queries fail to properly handle ingredient_id generation, the Generated SQL more directly addresses the business intent of inserting multiple ingredients for the product, whereas the Reference SQL's structure is fundamentally flawed due to schema mismatches and redundant operations.", "overall_assessment": "differently_correct"}}
{"example_id": 3404, "sql_complexity": "multiple_joins", "prompt": "What are the names of startups that have received funding from investors with over 3 million funds, and are involved in Genetic Research or Bioprocess Engineering?", "context": "CREATE TABLE public.investors ( id SERIAL PRIMARY KEY, name VARCHAR(100), type VARCHAR(50), funds INTEGER ); CREATE TABLE public.investments ( id SERIAL PRIMARY KEY, investor_id INTEGER, startup_id INTEGER ); CREATE TABLE public.startups ( id SERIAL PRIMARY KEY, name VARCHAR(100), industry VARCHAR(50), funding INTEGER );", "reference_sql": "SELECT startups.name FROM public.startups JOIN public.investments ON startups.id = investments.startup_id JOIN public.investors ON investments.investor_id = investors.id WHERE (startups.industry = 'Genetic Research' OR startups.industry = 'Bioprocess Engineering') AND investors.funds > 3000000;", "generated_sql": "SELECT DISTINCT s.name\nFROM public.startups s\nJOIN public.investments i ON s.id = i.startup_id\nJOIN public.investors inv ON i.investor_id = inv.id\nWHERE inv.funds > 3000000\nAND s.industry IN ('Genetic Research', 'Bioprocess Engineering');", "raw_model_output": "\n\n```sql\nSELECT DISTINCT s.name\nFROM public.startups s\nJOIN public.investments i ON s.id = i.startup_id\nJOIN public.investors inv ON i.investor_id = inv.id\nWHERE inv.funds > 3000000\nAND s.industry IN ('Genetic Research', 'Bioprocess Engineering');\n```", "latency_sec": 0.7121121883392334, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 935, "prompt_eval_sec": null, "tokens_completion": 81, "completion_eval_sec": null, "tokens_total": 1016, "tokens_per_sec": 1426.7414834865901, "retrieval_latency_sec": 0.10695505142211914, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the use of DISTINCT. The Generated SQL includes DISTINCT to eliminate duplicate startup names, while the Reference SQL does not. If a startup is invested in by multiple investors meeting the criteria, the Reference SQL could return duplicate names, whereas the Generated SQL would not. This makes them non-equivalent in edge cases involving duplicates.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically correct and produce equivalent results. The reference query uses explicit OR conditions for industry matching, while the generated query uses the more concise IN clause. The generated query adds DISTINCT which prevents duplicate startup names that could occur if a startup has multiple qualifying investors - this is more accurate for the business intent of listing unique startup names. The generated query also uses table aliases which improves readability without affecting functionality. Both satisfy the requirement for investors with >3M funds and startups in the specified industries.", "overall_assessment": "differently_correct"}}
{"example_id": 134, "sql_complexity": "subqueries", "prompt": "Who are the top 3 authors with the most citations in the Mathematics department in the past 5 years?", "context": "CREATE TABLE authors (id INT, name VARCHAR(50), department VARCHAR(50)); INSERT INTO authors (id, name, department) VALUES (1, 'Author Name', 'Mathematics'); CREATE TABLE publications (id INT, title VARCHAR(100), author VARCHAR(50), journal VARCHAR(50), year INT, cites INT); INSERT INTO publications (id, title, author, journal, year, cites) VALUES (1, 'Publication Title', 'Author Name', 'Journal Name', 2021, 10);", "reference_sql": "SELECT author, SUM(cites) as total_cites FROM publications WHERE author IN (SELECT name FROM authors WHERE department = 'Mathematics') AND year BETWEEN YEAR(CURRENT_DATE) - 5 AND YEAR(CURRENT_DATE) GROUP BY author ORDER BY total_cites DESC LIMIT 3;", "generated_sql": "SELECT a.name, SUM(p.cites) AS total_citations \nFROM authors a \nJOIN publications p ON a.name = p.author \nWHERE a.department = 'Mathematics' AND p.year >= EXTRACT(YEAR FROM CURRENT_DATE) - 5 \nGROUP BY a.name \nORDER BY total_citations DESC \nLIMIT 3;", "raw_model_output": "\n\nSELECT a.name, SUM(p.cites) AS total_citations \nFROM authors a \nJOIN publications p ON a.name = p.author \nWHERE a.department = 'Mathematics' AND p.year >= EXTRACT(YEAR FROM CURRENT_DATE) - 5 \nGROUP BY a.name \nORDER BY total_citations DESC \nLIMIT 3;", "latency_sec": 0.659019947052002, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1063, "prompt_eval_sec": null, "tokens_completion": 73, "completion_eval_sec": null, "tokens_total": 1136, "tokens_per_sec": 1723.7717994450334, "retrieval_latency_sec": 0.1129310131072998, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their year filtering logic. The Reference SQL uses `BETWEEN YEAR(CURRENT_DATE) - 5 AND YEAR(CURRENT_DATE)` which explicitly includes both lower and upper bounds (e.g., 2018-2023 if current year is 2023). The Generated SQL uses `p.year >= EXTRACT(YEAR FROM CURRENT_DATE) - 5` which only enforces the lower bound but allows years beyond the current year (e.g., 2024+ if they exist). This makes the Generated SQL potentially include more years than the Reference SQL, leading to different results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify the top 3 Mathematics authors by citation count over the past 5 years. The reference query uses a subquery to filter authors, while the generated query uses an explicit JOIN. The year condition in both cases correctly captures the last 5 years (e.g., 2018-2023 for 2023). The generated query is more efficient due to the JOIN, which avoids potential subquery overhead and explicitly links authors to their publications. Both handle edge cases like duplicate names (assuming data consistency), but the generated query's structure is more elegant and scalable.", "overall_assessment": "correct"}}
{"example_id": 592, "sql_complexity": "set operations", "prompt": "How many public healthcare facilities and public parks are there in total, in the 'StateData' schema's 'StateHealthcare' and 'StateParks' tables?", "context": "CREATE SCHEMA StateData; CREATE TABLE StateHealthcare (Name varchar(255), Type varchar(255)); INSERT INTO StateHealthcare (Name, Type) VALUES ('FacilityA', 'Public'), ('FacilityB', 'Public'), ('FacilityC', 'Private'); CREATE TABLE StateParks (Name varchar(255), Type varchar(255)); INSERT INTO StateParks (Name, Type) VALUES ('ParkA', 'Public'), ('ParkB', 'Public'), ('ParkC', 'Private');", "reference_sql": "SELECT COUNT(*) FROM StateData.StateHealthcare WHERE Type = 'Public' UNION ALL SELECT COUNT(*) FROM StateData.StateParks WHERE Type = 'Public';", "generated_sql": "SELECT \n  (SELECT COUNT(*) FROM StateData.StateHealthcare WHERE Type = 'Public') + \n  (SELECT COUNT(*) FROM StateData.StateParks WHERE Type = 'Public') AS Total_Public_Facilities_And_Parks;", "raw_model_output": "\n\n```sql\nSELECT \n  (SELECT COUNT(*) FROM StateData.StateHealthcare WHERE Type = 'Public') + \n  (SELECT COUNT(*) FROM StateData.StateParks WHERE Type = 'Public') AS Total_Public_Facilities_And_Parks;\n```", "latency_sec": 0.5123498439788818, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 763, "prompt_eval_sec": null, "tokens_completion": 57, "completion_eval_sec": null, "tokens_total": 820, "tokens_per_sec": 1600.4689171600469, "retrieval_latency_sec": 0.13031387329101562, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate counts (one from StateHealthcare, one from StateParks) as two rows via UNION ALL, while the Generated SQL returns a single row with the summed total of both counts. The result structures differ (two rows vs. one row) even if the numerical values might match.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query returns two separate counts (one for healthcare, one for parks) as two rows, while the generated query correctly combines them into a single total value. Both queries accurately filter public facilities (Type = 'Public'), but the original question explicitly asks for a 'total' count. The generated query achieves this through arithmetic addition, whereas the reference query requires manual summation of its two-row result. The generated query is more efficient as it executes two independent subqueries once rather than returning separate result sets.", "overall_assessment": "differently_correct"}}
{"example_id": 1989, "sql_complexity": "single join", "prompt": "What are the names and production dates of garments made from fabrics with a sustainability score over 70, produced after 2021-01-01?", "context": "CREATE TABLE fabrics (id INT, name VARCHAR(50), type VARCHAR(50), sustainability_score INT); INSERT INTO fabrics (id, name, type, sustainability_score) VALUES (1, 'Organic Linen', 'Natural', 80); INSERT INTO fabrics (id, name, type, sustainability_score) VALUES (2, 'Recycled Nylon', 'Synthetic', 72);", "reference_sql": "SELECT garments.name, garments.production_date FROM garments JOIN fabrics ON garments.fabric_id = fabrics.id WHERE fabrics.sustainability_score > 70 AND garments.production_date > '2021-01-01';", "generated_sql": "Based on the provided schema, there is no `garments` table or a `production_date` column in the schema. Therefore, it is not possible to answer the question as it requires data that is not present in the given database schema.\n\n**Answer:**  \nThe question cannot be answered with the provided schema because there is no `garments` table or `production_date` column available.", "raw_model_output": "\n\nBased on the provided schema, there is no `garments` table or a `production_date` column in the schema. Therefore, it is not possible to answer the question as it requires data that is not present in the given database schema.\n\n**Answer:**  \nThe question cannot be answered with the provided schema because there is no `garments` table or `production_date` column available.", "latency_sec": 0.676008939743042, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 714, "prompt_eval_sec": null, "tokens_completion": 84, "completion_eval_sec": null, "tokens_total": 798, "tokens_per_sec": 1180.4577618504986, "retrieval_latency_sec": 0.12513422966003418, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references a 'garments' table and 'production_date' column which do not exist in the provided schema. The Generated SQL's explanation correctly states these elements are missing, making it impossible for the queries to be semantically equivalent. The Reference SQL assumes a schema that isn't present, while the Generated SQL acknowledges the schema limitations.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is technically incorrect because it assumes the existence of a 'garments' table and 'production_date' column not present in the provided schema. The Generated SQL correctly identifies this schema mismatch. While both queries fail to produce results, the Generated SQL accurately addresses the root cause (missing data structures) rather than attempting invalid operations. The business intent (filtering garments by sustainability and date) cannot be fulfilled due to schema limitations, but the Generated SQL properly communicates this constraint.", "overall_assessment": "incorrect"}}
{"example_id": 1388, "sql_complexity": "aggregation", "prompt": "What was the total donation amount by each organization in the last 30 days?", "context": "CREATE TABLE organization_donations (id INT, organization TEXT, donation_date DATE, donation_amount DECIMAL(10,2)); INSERT INTO organization_donations (id, organization, donation_date, donation_amount) VALUES (1, 'Organization A', '2021-03-15', 100.00), (2, 'Organization B', '2021-03-25', 200.00);", "reference_sql": "SELECT organization, SUM(donation_amount) FROM organization_donations WHERE donation_date >= DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY) GROUP BY organization;", "generated_sql": "SELECT organization, SUM(donation_amount) AS total_donation \nFROM organization_donations \nWHERE donation_date >= DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY) \nGROUP BY organization;", "raw_model_output": "\n\n```sql\nSELECT organization, SUM(donation_amount) AS total_donation \nFROM organization_donations \nWHERE donation_date >= DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY) \nGROUP BY organization;\n```", "latency_sec": 0.40125274658203125, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 985, "prompt_eval_sec": null, "tokens_completion": 48, "completion_eval_sec": null, "tokens_total": 1033, "tokens_per_sec": 2574.4372064723443, "retrieval_latency_sec": 0.13572192192077637, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (organization and summed donation_amount), apply identical filtering (donation_date within last 30 days), and group by organization. The only difference is the alias 'total_donation' in the generated query, which does not affect the semantic result set (column names are not considered in semantic equivalence unless explicitly required).", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically equivalent as they produce identical result sets (same grouping, filtering, and aggregation logic). The generated query improves upon the reference by adding an explicit alias ('total_donation') for the aggregated column, enhancing readability and clarity without altering the semantic meaning. Both fulfill the business intent of calculating total donations per organization in the last 30 days. The generated query is slightly more elegant due to the alias, making it better suited for practical use cases where column naming matters.", "overall_assessment": "correct"}}
{"example_id": 1628, "sql_complexity": "window functions", "prompt": "What is the ranking of national security measures for Russia based on the publication date?", "context": "CREATE TABLE national_security (id INT, title VARCHAR(255), description TEXT, agency VARCHAR(255), date DATE); INSERT INTO national_security (id, title, description, agency, date) VALUES (1, 'National Cyber Strategy', 'Outlines the approach to protecting the American people and the American way of life in the digital age', 'White House', '2018-09-20'); INSERT INTO national_security (id, title, description, agency, date) VALUES (2, 'Cybersecurity and Infrastructure Security Agency Act of 2018', 'Establishes the Cybersecurity and Infrastructure Security Agency within the Department of Homeland Security', 'Congress', '2018-11-16'); INSERT INTO national_security (id, title, description, agency, date) VALUES (3, 'Russian Military Doctrine', 'Outlines the country\u2019s stance on military security', 'Russian Government', '2014-12-26');", "reference_sql": "SELECT title, description, agency, date, ROW_NUMBER() OVER (PARTITION BY agency ORDER BY date DESC) as ranking FROM national_security WHERE agency = 'Russian Government';", "generated_sql": "SELECT title, date, RANK() OVER(ORDER BY date ASC) as ranking FROM national_security WHERE agency = 'Russian Government';", "raw_model_output": "\n\nSELECT title, date, RANK() OVER(ORDER BY date ASC) as ranking FROM national_security WHERE agency = 'Russian Government';", "latency_sec": 0.31096816062927246, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1308, "prompt_eval_sec": null, "tokens_completion": 32, "completion_eval_sec": null, "tokens_total": 1340, "tokens_per_sec": 4309.1228288079, "retrieval_latency_sec": 0.12108111381530762, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in several key aspects.  The Reference SQL uses ROW_NUMBER() with a DESC order, while the Generated SQL uses RANK() with an ASC order.  Additionally, the Reference SQL selects more columns (title, description, agency, date) compared to the Generated SQL (title, date).  These differences in ranking function, ordering, and selected columns make the queries not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent. The Reference SQL uses ROW_NUMBER() with PARTITION BY agency and ORDER BY date DESC, which correctly ranks Russian Government measures by descending date. The Generated SQL uses RANK() with ORDER BY date ASC, which would rank the oldest document first and uses a different ranking function. While both filter for 'Russian Government', the Reference SQL better aligns with typical ranking expectations (most recent first) and uses a more appropriate ranking function. The Generated SQL's ascending order and RANK() function could produce misleading results if multiple documents existed.", "overall_assessment": "differently_correct"}}
{"example_id": 2300, "sql_complexity": "aggregation", "prompt": "What is the minimum capacity for schools in each location ('community_development')?", "context": "CREATE TABLE community_development.schools (id INT, name VARCHAR(50), capacity INT, location VARCHAR(50));", "reference_sql": "SELECT location, MIN(capacity) FROM community_development.schools GROUP BY location;", "generated_sql": "SELECT location, MIN(capacity) FROM community_development.schools GROUP BY location;", "raw_model_output": "\n\nSELECT location, MIN(capacity) FROM community_development.schools GROUP BY location;", "latency_sec": 0.34104180335998535, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 488, "prompt_eval_sec": null, "tokens_completion": 22, "completion_eval_sec": null, "tokens_total": 510, "tokens_per_sec": 1495.417849000967, "retrieval_latency_sec": 0.10758233070373535, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure and logic. Both queries select the 'location' column and the minimum 'capacity' from the 'community_development.schools' table, grouping results by 'location'. Since the queries are exactly the same, they will produce identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic. They correctly group schools by location and calculate the minimum capacity for each group, which directly addresses the business question. The queries are technically identical, so they produce the same results, fulfill the same business intent, and have equal efficiency/elegance.", "overall_assessment": "correct"}}
{"example_id": 4976, "sql_complexity": "set operations", "prompt": "What is the most common hashtag used in posts made by users from Brazil?", "context": "CREATE TABLE posts (id INT, user_id INT, content TEXT, hashtags TEXT, post_date DATE); INSERT INTO posts (id, user_id, content, hashtags, post_date) VALUES (1, 1, 'Hello World', '#datascience', '2022-06-01'), (2, 1, 'I love data', '#ai', '2022-06-02'), (3, 2, 'Ol\u00e1 Mundo', '#brasil', '2022-06-03'); CREATE TABLE users (id INT, name VARCHAR(100), country VARCHAR(50)); INSERT INTO users (id, name, country) VALUES (1, 'Jo\u00e3o Silva', 'Brazil'), (2, 'Maria Souza', 'Brazil');", "reference_sql": "SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(hashtags, ' ', n.n), ' ', -1) hashtag, COUNT(*) count FROM posts JOIN users ON posts.user_id = users.id CROSS JOIN (SELECT 1 n UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5) n WHERE users.country = 'Brazil' GROUP BY hashtag ORDER BY count DESC LIMIT 1;", "generated_sql": "SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(hashtags, ' ', n.n), ' ', -1) hashtag, COUNT(*) count \nFROM posts \nJOIN users ON posts.user_id = users.id \nCROSS JOIN (SELECT 1 n UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5) n \nWHERE users.country = 'Brazil' \nGROUP BY hashtag \nORDER BY count DESC \nLIMIT 1;", "raw_model_output": "\n\nSELECT SUBSTRING_INDEX(SUBSTRING_INDEX(hashtags, ' ', n.n), ' ', -1) hashtag, COUNT(*) count \nFROM posts \nJOIN users ON posts.user_id = users.id \nCROSS JOIN (SELECT 1 n UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5) n \nWHERE users.country = 'Brazil' \nGROUP BY hashtag \nORDER BY count DESC \nLIMIT 1;", "latency_sec": 0.6962931156158447, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1402, "prompt_eval_sec": null, "tokens_completion": 93, "completion_eval_sec": null, "tokens_total": 1495, "tokens_per_sec": 2147.084275962903, "retrieval_latency_sec": 0.10888123512268066, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure, logic, and syntax. Both queries perform the same operations: extracting hashtags from the 'posts' table, joining with 'users' to filter Brazilian users, cross-joining with a numbers table to split multi-hashtag entries, grouping by hashtag, counting occurrences, and returning the most frequent hashtag. Since the queries are exactly the same, they will produce identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure, logic, and syntax. They correctly join the posts and users tables, split space-separated hashtags using SUBSTRING_INDEX, filter for Brazilian users, count hashtag occurrences, and return the most frequent one. The minor formatting differences (line breaks, spacing) do not affect functionality. Both queries accurately address the business intent of identifying the most common hashtag from Brazilian users.", "overall_assessment": "correct"}}
{"example_id": 4637, "sql_complexity": "single join", "prompt": "What is the total value of transactions for each customer in the last 30 days?", "context": "CREATE TABLE transactions (id INT, customer_id INT, value DECIMAL(10, 2), transaction_date DATE); INSERT INTO transactions (id, customer_id, value, transaction_date) VALUES (1, 1, 100, '2022-01-01'), (2, 1, 200, '2022-01-15'), (3, 2, 50, '2022-01-05'), (4, 2, 150, '2022-01-30'), (5, 3, 300, '2022-01-20');", "reference_sql": "SELECT c.id, SUM(t.value) FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE t.transaction_date >= CURDATE() - INTERVAL 30 DAY GROUP BY c.id;", "generated_sql": "SELECT customer_id, SUM(value) \nFROM transactions \nWHERE transaction_date >= CURRENT_DATE - INTERVAL '30 days' \nGROUP BY customer_id;", "raw_model_output": "\n\nSELECT customer_id, SUM(value) \nFROM transactions \nWHERE transaction_date >= CURRENT_DATE - INTERVAL '30 days' \nGROUP BY customer_id;", "latency_sec": 0.32337474822998047, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1070, "prompt_eval_sec": null, "tokens_completion": 35, "completion_eval_sec": null, "tokens_total": 1105, "tokens_per_sec": 3417.088087577378, "retrieval_latency_sec": 0.10785627365112305, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the total transaction value per customer for the last 30 days. The Reference SQL uses an INNER JOIN with customers (which implicitly filters customers with transactions in the date range) and groups by c.id. The Generated SQL directly filters transactions in the date range and groups by customer_id. Since customer_id in transactions corresponds to c.id in customers, and both aggregate values for the same date window, the results are equivalent. The date functions (CURDATE() vs CURRENT_DATE) and interval syntax (INTERVAL 30 DAY vs INTERVAL '30 days') are functionally equivalent in this context.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries differ in two key aspects. 1) The Reference SQL uses a JOIN with the customers table, ensuring all customers are included in the result, even those without recent transactions (though their total would be NULL). The Generated SQL only returns customers with transactions in the last 30 days. 2) The date calculation syntax differs: the Reference SQL uses MySQL's CURDATE() function, while the Generated SQL uses PostgreSQL-style INTERVAL '30 days'. This makes them technically non-equivalent.  Both queries correctly calculate the sum of transaction values for customers with recent transactions. However, the Reference SQL better fulfills the business intent of 'each customer' by including all customers, even those without recent transactions. The Generated SQL is more efficient but may not fully address the question's intent.", "overall_assessment": "differently_correct"}}
{"example_id": 4947, "sql_complexity": "aggregation", "prompt": "What is the total revenue for drugs approved between 2017 and 2019?", "context": "CREATE TABLE drug_sales_3 (drug_name TEXT, revenue FLOAT, year INT); INSERT INTO drug_sales_3 (drug_name, revenue, year) VALUES ('DrugG', 20000000, 2019), ('DrugG', 19000000, 2018), ('DrugH', 15000000, 2017), ('DrugH', 16000000, 2018);", "reference_sql": "SELECT drug_name, SUM(revenue) FROM drug_sales_3 WHERE year BETWEEN 2017 AND 2019 GROUP BY drug_name;", "generated_sql": "The question asks for the total revenue for drugs approved between 2017 and 2019. However, the provided schema does **not** include a table that contains information about drug approvals (such as `drug_approval` or `drug_approvals`). Therefore, it is **not possible** to determine which drugs were approved between 2017 and 2019 based on the given schema.\n\n**Final Answer:**  \nThe question cannot be answered with the provided schema because there is no table containing drug approval information.", "raw_model_output": "\n\nThe question asks for the total revenue for drugs approved between 2017 and 2019. However, the provided schema does **not** include a table that contains information about drug approvals (such as `drug_approval` or `drug_approvals`). Therefore, it is **not possible** to determine which drugs were approved between 2017 and 2019 based on the given schema.\n\n**Final Answer:**  \nThe question cannot be answered with the provided schema because there is no table containing drug approval information.", "latency_sec": 0.9288921356201172, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 993, "prompt_eval_sec": null, "tokens_completion": 115, "completion_eval_sec": null, "tokens_total": 1108, "tokens_per_sec": 1192.8187972657477, "retrieval_latency_sec": 0.10733199119567871, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL is a valid query that calculates total revenue per drug for years 2017-2019. The 'Generated SQL' section contains a textual explanation about missing schema elements (drug approval data) rather than an actual SQL query. Since one is a query and the other is not an SQL statement, they cannot be semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference SQL calculates total revenue for sales occurring between 2017-2019, but the original question specifically asks for drugs 'approved' during that period. The schema lacks any approval-related data (e.g., approval_year, approval_status), making it impossible to determine approval dates. The generated SQL correctly identifies this schema limitation, while the reference SQL addresses a different business question (sales revenue vs. drug approvals).", "overall_assessment": "incorrect"}}
{"example_id": 4767, "sql_complexity": "window functions", "prompt": "List the top 2 AI algorithms with the highest explainability scores, by algorithm subtype, ordered by scores in descending order for the European region.", "context": "CREATE TABLE ai_algorithms (algorithm_id INT, algorithm_name VARCHAR(50), algorithm_subtype VARCHAR(50), region VARCHAR(50), explainability_score FLOAT); INSERT INTO ai_algorithms (algorithm_id, algorithm_name, algorithm_subtype, region, explainability_score) VALUES (1, 'AlgoA', 'Tree-based', 'Europe', 0.85), (2, 'AlgoB', 'Computer Vision', 'Europe', 0.92), (3, 'AlgoC', 'Tree-based', 'Europe', 0.78), (4, 'AlgoD', 'Transformer', 'Europe', 0.90), (5, 'AlgoE', 'Tree-based', 'Europe', 0.80);", "reference_sql": "SELECT algorithm_subtype, region, * FROM (SELECT algorithm_subtype, region, algorithm_id, algorithm_name, explainability_score, RANK() OVER (PARTITION BY algorithm_subtype ORDER BY explainability_score DESC) AS rank FROM ai_algorithms WHERE region = 'Europe') ranked WHERE rank <= 2 ORDER BY algorithm_subtype, region, explainability_score DESC;", "generated_sql": "SELECT algorithm_name, explainability_score FROM ai_algorithms WHERE region = 'Europe' ORDER BY explainability_score DESC LIMIT 2;", "raw_model_output": "\n\nSQL: SELECT algorithm_name, explainability_score FROM ai_algorithms WHERE region = 'Europe' ORDER BY explainability_score DESC LIMIT 2;", "latency_sec": 0.41440415382385254, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 996, "prompt_eval_sec": null, "tokens_completion": 34, "completion_eval_sec": null, "tokens_total": 1030, "tokens_per_sec": 2485.4963216363267, "retrieval_latency_sec": 0.10440206527709961, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL selects top 2 algorithms per subtype in Europe with additional columns, while the Generated SQL returns only top 2 overall algorithms in Europe. The Reference query groups by algorithm_subtype and ranks within each group, potentially returning multiple rows (e.g., 4 rows in the sample data), whereas the Generated SQL returns exactly 2 rows. Column selections also differ.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference query correctly addresses the business intent by ranking algorithms within each algorithm_subtype partition (as required by the question) and selecting the top 2 per subtype in Europe. It uses RANK() with PARTITION BY algorithm_subtype and filters rank <= 2. The Generated query fails to account for algorithm_subtype grouping entirely, instead returning the top 2 algorithms globally in Europe without considering subtypes. While the Generated query is more efficient, it does not fulfill the requirement to group by algorithm_subtype. The Reference query is technically correct and aligns with the business question, though it includes unnecessary columns (e.g., *).", "overall_assessment": "differently_correct"}}
{"example_id": 4495, "sql_complexity": "basic SQL", "prompt": "Which countries are the top 3 sources of sustainable textiles?", "context": "CREATE TABLE Textile_Sources (Source_ID INT, Source_Country TEXT, Sustainable BOOLEAN, Quantity INT); INSERT INTO Textile_Sources (Source_ID, Source_Country, Sustainable, Quantity) VALUES (1, 'India', true, 1000), (2, 'Bangladesh', false, 800), (3, 'China', true, 1200), (4, 'Vietnam', false, 900), (5, 'Italy', true, 1100), (6, 'USA', false, 700);", "reference_sql": "SELECT Source_Country FROM Textile_Sources WHERE Sustainable = true ORDER BY Quantity DESC LIMIT 3;", "generated_sql": "SELECT Source_Country FROM Textile_Sources WHERE Sustainable = TRUE ORDER BY Quantity DESC LIMIT 3;", "raw_model_output": "\n\n```sql\nSELECT Source_Country FROM Textile_Sources WHERE Sustainable = TRUE ORDER BY Quantity DESC LIMIT 3;\n```", "latency_sec": 0.39225196838378906, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 814, "prompt_eval_sec": null, "tokens_completion": 30, "completion_eval_sec": null, "tokens_total": 844, "tokens_per_sec": 2151.678176345592, "retrieval_latency_sec": 0.10698080062866211, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. The only difference is the case of the boolean value ('true' vs 'TRUE'), which is irrelevant in SQL. Both queries select the same columns, apply the same filter (Sustainable = true/TRUE), order by Quantity descending, and limit to 3 results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent as they differ only in the case of the boolean literal ('true' vs 'TRUE'), which is irrelevant in SQL. They both correctly filter sustainable sources (Sustainable = true), order by Quantity descending, and limit to 3 results. The business intent is fully fulfilled by identifying the top 3 countries by sustainable textile quantity. Neither query is more efficient or elegant than the other, as the syntax difference has no impact on performance or clarity.", "overall_assessment": "correct"}}
{"example_id": 2513, "sql_complexity": "single join", "prompt": "What is the total number of concert ticket sales for artists who released their first album between 2015 and 2017?", "context": "CREATE TABLE ConcertTicketSales (id INT, year INT, artist_id INT); CREATE TABLE ArtistAlbums (id INT, artist_id INT, year INT);", "reference_sql": "SELECT COUNT(DISTINCT cts.artist_id) FROM ConcertTicketSales cts JOIN ArtistAlbums a ON cts.artist_id = a.artist_id WHERE a.year BETWEEN 2015 AND 2017;", "generated_sql": "SELECT SUM(cts.id) AS total_concert_ticket_sales\nFROM ConcertTicketSales cts\nWHERE cts.artist_id IN (\n    SELECT a.artist_id\n    FROM ArtistAlbums a\n    WHERE a.year BETWEEN 2015 AND 2017\n    GROUP BY a.artist_id\n    HAVING MIN(a.year) BETWEEN 2015 AND 2017\n);", "raw_model_output": "\n\nTo answer the question, we need to:\n\n1. Identify artists who released their first album between 2015 and 2017 using the `ArtistAlbums` table.\n2. Use the `artist_id` from those artists to find their concert ticket sales from the `ConcertTicketSales` table.\n3. Sum the total number of concert ticket sales.\n\nHere is the SQL query:\n\n```sql\nSELECT SUM(cts.id) AS total_concert_ticket_sales\nFROM ConcertTicketSales cts\nWHERE cts.artist_id IN (\n    SELECT a.artist_id\n    FROM ArtistAlbums a\n    WHERE a.year BETWEEN 2015 AND 2017\n    GROUP BY a.artist_id\n    HAVING MIN(a.year) BETWEEN 2015 AND 2017\n);\n```", "latency_sec": 1.2076847553253174, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 801, "prompt_eval_sec": null, "tokens_completion": 177, "completion_eval_sec": null, "tokens_total": 978, "tokens_per_sec": 809.8139814115261, "retrieval_latency_sec": 0.10808205604553223, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query counts distinct artist_ids from ConcertTicketSales joined with ArtistAlbums where ArtistAlbums.year is between 2015-2017. The generated query sums ConcertTicketSales.id where artist_id exists in a subquery that filters ArtistAlbums.year between 2015-2017 (redundantly checked via HAVING MIN(year)). The key difference is that the first counts unique artists, while the second sums ticket IDs, which are fundamentally different operations. Additionally, the generated query's subquery logic is redundant but doesn't change the semantic outcome of filtering artist_ids.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL incorrectly counts distinct artists instead of total ticket sales. The Generated SQL attempts to filter artists with first albums between 2015-2017 using HAVING MIN(year), which is correct for business intent, but incorrectly sums 'cts.id' (ticket IDs) instead of counting actual sales. While the Generated SQL better addresses the artist filtering requirement, both queries fail to accurately calculate total ticket sales. The Reference SQL's logic is fundamentally flawed for the question's requirements.", "overall_assessment": "incorrect"}}
{"example_id": 873, "sql_complexity": "subqueries", "prompt": "Identify attorneys who have never handled cases in the 'West' region but have in the 'North' or 'South'.", "context": "CREATE TABLE attorney_regions(attorney_id INT, region VARCHAR(20)); INSERT INTO attorney_regions(attorney_id, region) VALUES (1, 'North'), (2, 'South'), (3, 'East'), (4, 'West'), (5, 'West'), (6, 'North'); CREATE TABLE handled_cases(attorney_id INT, case_id INT); INSERT INTO handled_cases(attorney_id, case_id) VALUES (1, 101), (2, 102), (3, 103), (4, 104), (5, 105), (6, 106), (1, 107), (1, 108);", "reference_sql": "SELECT h.attorney_id FROM attorney_regions h LEFT JOIN handled_cases i ON h.attorney_id = i.attorney_id WHERE h.region IN ('North', 'South') AND h.region != 'West' AND i.attorney_id IS NOT NULL AND h.attorney_id NOT IN (SELECT attorney_id FROM attorney_regions WHERE region = 'West');", "generated_sql": "SELECT a.attorney_id\nFROM attorney_regions a\nWHERE a.region IN ('North', 'South')\n  AND a.attorney_id NOT IN (\n    SELECT h.attorney_id\n    FROM attorney_regions h\n    JOIN handled_cases c ON h.attorney_id = c.attorney_id\n    WHERE h.region = 'West'\n  );", "raw_model_output": "\n\n```sql\nSELECT a.attorney_id\nFROM attorney_regions a\nWHERE a.region IN ('North', 'South')\n  AND a.attorney_id NOT IN (\n    SELECT h.attorney_id\n    FROM attorney_regions h\n    JOIN handled_cases c ON h.attorney_id = c.attorney_id\n    WHERE h.region = 'West'\n  );\n```", "latency_sec": 0.5903279781341553, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1107, "prompt_eval_sec": null, "tokens_completion": 78, "completion_eval_sec": null, "tokens_total": 1185, "tokens_per_sec": 2007.3586953229283, "retrieval_latency_sec": 0.1088109016418457, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a LEFT JOIN with handled_cases and checks for i.attorney_id IS NOT NULL, ensuring only attorneys with cases are selected. The Generated SQL lacks this condition, instead using a subquery that filters West region attorneys with cases. The Generated SQL's NOT IN clause is ineffective because it excludes West region attorneys (who are not in the North/South region), making it select all North/South attorneys regardless of case ownership. Thus, the Generated SQL may include attorneys without cases, while the Reference SQL excludes them.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The Reference SQL correctly ensures attorneys have handled cases in North/South (via LEFT JOIN + i.attorney_id IS NOT NULL) and explicitly excludes those in West (via subquery). The Generated SQL lacks the case-handling verification for North/South regions, potentially including attorneys with no cases. While both address the intent, the Reference's explicit case-handling check makes it more precise. The subquery in Reference (selecting all West region attorneys) is broader than Generated's (West region + cases), but the LEFT JOIN in Reference ensures case-handling validity.", "overall_assessment": "correct"}}
{"example_id": 471, "sql_complexity": "set operations", "prompt": "Find the number of donations made by first-time donors in the last quarter.", "context": "CREATE TABLE Donations (DonationID INT, DonorID INT, DonationDate DATE, DonationType TEXT, DonationAmount FLOAT); INSERT INTO Donations (DonationID, DonorID, DonationDate, DonationType, DonationAmount) VALUES (1, 1, '2021-01-01', 'Individual', 100), (2, 2, '2021-02-01', 'Corporate', 5000);", "reference_sql": "SELECT COUNT(*) FROM (SELECT DonationID FROM Donations WHERE DonationType = 'Individual' AND DonationDate >= DATEADD(quarter, -1, CURRENT_DATE) EXCEPT SELECT DonationID FROM PreviousDonations) AS FirstTimeDonors;", "generated_sql": "SELECT COUNT(*) AS num_first_time_donations\nFROM Donations d\nWHERE d.DonationDate = (\n    SELECT MIN(DonationDate)\n    FROM Donations d2\n    WHERE d2.DonorID = d.DonorID\n)\nAND d.DonationDate >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH);", "raw_model_output": "\n\nTo find the number of donations made by first-time donors in the last quarter, we need to identify donors who made their **first** donation in the last quarter. This means we should:\n\n1. Identify the most recent donation date for each donor.\n2. Check if that most recent donation occurred in the last quarter.\n3. Count the number of such donations.\n\nHere is the SQL query:\n\n```sql\nSELECT COUNT(*) AS num_first_time_donations\nFROM Donations d\nWHERE d.DonationDate = (\n    SELECT MIN(DonationDate)\n    FROM Donations d2\n    WHERE d2.DonorID = d.DonorID\n)\nAND d.DonationDate >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH);\n```\n\n### Explanation:\n- The subquery finds the **first** donation date for each donor (`MIN(DonationDate)`).\n- The outer query checks if that first donation occurred in the last 3 months (`DATE_SUB(CURDATE(), INTERVAL 3 MONTH)`).\n- `COUNT(*)` gives the number of such first-time donations in the last quarter.", "latency_sec": 1.6400442123413086, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1030, "prompt_eval_sec": null, "tokens_completion": 227, "completion_eval_sec": null, "tokens_total": 1257, "tokens_per_sec": 766.4427522996597, "retrieval_latency_sec": 0.0979769229888916, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL counts 'Individual' donations in the last quarter that are not in PreviousDonations (using EXCEPT), while the Generated SQL counts all first-time donations (any type) within the last 3 months. Key differences: 1) DonationType filter in Reference vs. no type filter in Generated, 2) EXCEPT logic in Reference vs. first-donation date logic in Generated, 3) Quarter vs. 3-month time frame (though similar, they may differ in edge cases).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query references a 'PreviousDonations' table that doesn't exist in the provided schema, making it technically invalid. The generated query correctly identifies first-time donors by finding their earliest donation date and checking if it falls within the last 3 months (quarter). It properly counts donations made by donors who had their first donation in the last quarter. The generated query is both syntactically correct and semantically aligned with the business intent, while the reference query contains a critical schema inconsistency.", "overall_assessment": "differently_correct"}}
{"example_id": 1301, "sql_complexity": "multiple_joins", "prompt": "What is the total quantity of corn sold by farmers in 'Summerfield'?", "context": "CREATE TABLE farmers (id INT, name VARCHAR(50), location VARCHAR(50), crops VARCHAR(50)); CREATE TABLE crops (id INT, name VARCHAR(50), yield INT); CREATE TABLE sales (id INT, farmer_id INT, crop_name VARCHAR(50), quantity INT, price DECIMAL(5,2)); INSERT INTO farmers VALUES (1, 'Jane Doe', 'Summerfield', 'Corn'); INSERT INTO crops VALUES (1, 'Corn', 100); INSERT INTO sales VALUES (1, 1, 'Corn', 50, 2.50);", "reference_sql": "SELECT SUM(quantity) FROM sales INNER JOIN farmers ON sales.farmer_id = farmers.id INNER JOIN crops ON sales.crop_name = crops.name WHERE farmers.location = 'Summerfield' AND crops.name = 'Corn';", "generated_sql": "SELECT SUM(s.quantity) \nFROM sales s \nJOIN farmers f ON s.farmer_id = f.id \nWHERE f.location = 'Summerfield' AND s.crop_name = 'Corn';", "raw_model_output": "\n\nSELECT SUM(s.quantity) \nFROM sales s \nJOIN farmers f ON s.farmer_id = f.id \nWHERE f.location = 'Summerfield' AND s.crop_name = 'Corn';", "latency_sec": 0.37906599044799805, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 922, "prompt_eval_sec": null, "tokens_completion": 44, "completion_eval_sec": null, "tokens_total": 966, "tokens_per_sec": 2548.3689498452122, "retrieval_latency_sec": 0.10954165458679199, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes an explicit JOIN with the 'crops' table on sales.crop_name = crops.name, ensuring that only sales records with valid crop entries in the crops table are considered. The Generated SQL omits this join and relies solely on the WHERE clause to filter sales.crop_name = 'Corn'. While the sample data may produce the same result, the Reference SQL enforces a relationship between sales and crops that the Generated SQL does not. This makes them non-equivalent in general cases where sales.crop_name might not correspond to existing crops.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the total corn quantity sold by Summerfield farmers. The reference query includes an unnecessary join to the 'crops' table, which doesn't affect the result but reduces efficiency. The generated query achieves the same result with a simpler, more efficient structure by directly filtering on sales.crop_name = 'Corn' without the extra join. While both are technically correct, the generated query better fulfills the business intent through improved efficiency and clarity.", "overall_assessment": "correct"}}
{"example_id": 4667, "sql_complexity": "aggregation", "prompt": "Find the number of unique organizations in each country in the Philanthropy Trends table?", "context": "CREATE TABLE PhilanthropyTrends (OrgID INT, Name TEXT, Country TEXT);", "reference_sql": "SELECT Country, COUNT(DISTINCT OrgID) as UniqueOrganizations FROM PhilanthropyTrends GROUP BY Country;", "generated_sql": "SELECT Country, COUNT(DISTINCT OrgID) AS UniqueOrganizations FROM PhilanthropyTrends GROUP BY Country;", "raw_model_output": "\n\nSELECT Country, COUNT(DISTINCT OrgID) AS UniqueOrganizations FROM PhilanthropyTrends GROUP BY Country;", "latency_sec": 0.38234806060791016, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 810, "prompt_eval_sec": null, "tokens_completion": 29, "completion_eval_sec": null, "tokens_total": 839, "tokens_per_sec": 2194.335702046039, "retrieval_latency_sec": 0.11107087135314941, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select the 'Country' column and count distinct 'OrgID' values, grouping by 'Country'. The only difference is the case of the alias keyword ('as' vs 'AS') and the alias name casing, which does not affect semantic equivalence in SQL.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "The reference and generated queries are identical in structure, syntax, and logic. Both correctly count distinct OrgID values per Country, achieving the business goal of determining unique organizations per country. The queries are semantically equivalent, use the same aggregation function (COUNT(DISTINCT)), and apply the same grouping. There is no difference in efficiency or elegance between them.", "overall_assessment": "correct"}}
{"example_id": 1006, "sql_complexity": "subqueries", "prompt": "What is the average word count of news articles written by investigative journalists?", "context": "CREATE TABLE reporters (id INT, name VARCHAR(50), gender VARCHAR(10), age INT, position VARCHAR(20), country VARCHAR(50)); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (1, 'Anna Smith', 'Female', 35, 'News Reporter', 'USA'); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (2, 'Mike Johnson', 'Male', 40, 'Investigative Journalist', 'Canada'); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (3, 'Sofia Rodriguez', 'Female', 32, 'Investigative Journalist', 'Mexico'); CREATE TABLE news_articles (id INT, title VARCHAR(100), content TEXT, publication_date DATE, reporter_id INT); INSERT INTO news_articles (id, title, content, publication_date, reporter_id) VALUES (1, 'News Article 1', 'Content of News Article 1', '2021-01-01', 2); INSERT INTO news_articles (id, title, content, publication_date, reporter_id) VALUES (2, 'News Article 2', 'Content of News Article 2', '2021-02-01', 3);", "reference_sql": "SELECT AVG(LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1) AS avg_word_count FROM news_articles WHERE reporter_id IN (SELECT id FROM reporters WHERE position = 'Investigative Journalist');", "generated_sql": "SELECT AVG(LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1) AS average_word_count\nFROM news_articles\nWHERE reporter_id IN (\n    SELECT id\n    FROM reporters\n    WHERE position = 'Investigative Journalist'\n);", "raw_model_output": "\n\nTo calculate the average word count of news articles written by investigative journalists, we need to:\n\n1. Join the `reporters` and `news_articles` tables on `reporter_id`.\n2. Filter for reporters whose `position` is 'Investigative Journalist'.\n3. Calculate the average word count of the `content` field for these articles.\n\nSince the `news_articles` table does not have a `word_count` column, we will calculate the word count by counting the number of spaces in the `content` field and adding 1 (to account for the last word).\n\nHere is the SQL query:\n\n```sql\nSELECT AVG(LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1) AS average_word_count\nFROM news_articles\nWHERE reporter_id IN (\n    SELECT id\n    FROM reporters\n    WHERE position = 'Investigative Journalist'\n);\n```", "latency_sec": 1.2854621410369873, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1034, "prompt_eval_sec": null, "tokens_completion": 188, "completion_eval_sec": null, "tokens_total": 1222, "tokens_per_sec": 950.6308750673962, "retrieval_latency_sec": 0.1127171516418457, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. Both calculate the average word count of news articles by: 1) Using the same formula (LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1) to estimate word count, and 2) Filtering articles by reporters with 'Investigative Journalist' position via an identical subquery. The only difference is the column alias name ('avg_word_count' vs 'average_word_count'), which doesn't affect the result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically identical except for the column alias name ('avg_word_count' vs 'average_word_count'). The core logic for calculating word count (LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1) is the same, and both correctly filter articles by investigative journalists through the subquery. The business intent is fully addressed by calculating the average word count for the specified reporter group. The difference in column naming has no impact on result accuracy or performance.", "overall_assessment": "correct"}}
{"example_id": 3635, "sql_complexity": "set operations", "prompt": "Which brands have certifications related to cruelty-free, vegan, or organic products?", "context": "CREATE TABLE brands (brand_name VARCHAR(50), is_cruelty_free BOOLEAN, is_vegan BOOLEAN, is_organic BOOLEAN); INSERT INTO brands (brand_name, is_cruelty_free, is_vegan, is_organic) VALUES ('Lush', TRUE, TRUE, FALSE), ('The Body Shop', TRUE, FALSE, FALSE), ('Est\u00e9e Lauder', FALSE, FALSE, FALSE), ('Urban Decay', TRUE, TRUE, FALSE), ('Maybelline', FALSE, FALSE, FALSE), ('Kat Von D', TRUE, TRUE, FALSE), ('Tarte', TRUE, TRUE, TRUE);", "reference_sql": "SELECT brand_name, 'Cruelty-free' as certification FROM brands WHERE is_cruelty_free = TRUE UNION SELECT brand_name, 'Vegan' as certification FROM brands WHERE is_vegan = TRUE UNION SELECT brand_name, 'Organic' as certification FROM brands WHERE is_organic = TRUE;", "generated_sql": "SELECT brand_name FROM brands WHERE is_cruelty_free = TRUE OR is_vegan = TRUE OR is_organic = TRUE;", "raw_model_output": "\n\nSELECT brand_name FROM brands WHERE is_cruelty_free = TRUE OR is_vegan = TRUE OR is_organic = TRUE;", "latency_sec": 0.30068397521972656, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 989, "prompt_eval_sec": null, "tokens_completion": 32, "completion_eval_sec": null, "tokens_total": 1021, "tokens_per_sec": 3395.591664816518, "retrieval_latency_sec": 0.11810183525085449, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns brand names with their corresponding certification type (Cruelty-free/Vegan/Organic) as separate rows, allowing duplicates if a brand meets multiple criteria. The Generated SQL returns only brand names that meet any of the conditions, without certification types and with duplicates removed (since OR combines conditions into a single row per brand). The output structures and row counts differ.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent because the reference query returns each certification type separately (with duplicates for brands having multiple certifications), while the generated query returns a single list of brands with any certification. Both fulfill the business intent of identifying brands with at least one certification, but the reference query provides more detailed information about which specific certifications each brand holds. The generated query is more efficient but sacrifices granularity. The reference query better aligns with the question's implicit need to surface certification types, making it superior for business intent.", "overall_assessment": "differently_correct"}}
{"example_id": 4932, "sql_complexity": "basic SQL", "prompt": "Delete the workout row with the id of 2.", "context": "CREATE TABLE Workouts (id INT, user_id INT, workout_name TEXT, calories INT); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (1, 1, 'Running', 300); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (2, 1, 'Cycling', 400); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (3, 2, 'Yoga', 200);", "reference_sql": "DELETE FROM Workouts WHERE id = 2;", "generated_sql": "DELETE FROM Workouts WHERE id = 2;", "raw_model_output": "\n\nDELETE FROM Workouts WHERE id = 2;", "latency_sec": 0.18837189674377441, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 805, "prompt_eval_sec": null, "tokens_completion": 15, "completion_eval_sec": null, "tokens_total": 820, "tokens_per_sec": 4353.090955575891, "retrieval_latency_sec": 0.10595202445983887, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They both delete the record from the Workouts table where the id is 2. The DELETE statements are exactly the same, so they will produce the same result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in syntax, logic, and effect. They both correctly delete the row with id=2 from the Workouts table, matching the business requirement. The queries are equally efficient, semantically equivalent, and fulfill the intent of removing the specified workout record.", "overall_assessment": "correct"}}
{"example_id": 365, "sql_complexity": "aggregation", "prompt": "Identify the total number of military personnel and their corresponding rank for each branch and country in the 'military_personnel' table, sorted by the total number of personnel in descending order.", "context": "CREATE TABLE military_personnel (id INT, branch VARCHAR(255), rank VARCHAR(255), country VARCHAR(255), personnel INT);", "reference_sql": "SELECT branch, country, SUM(personnel) as total_personnel FROM military_personnel GROUP BY branch, country ORDER BY total_personnel DESC;", "generated_sql": "SELECT branch, country, SUM(personnel) AS total_personnel \nFROM military_personnel \nGROUP BY branch, country \nORDER BY total_personnel DESC;", "raw_model_output": "\n\n```sql\nSELECT branch, country, SUM(personnel) AS total_personnel \nFROM military_personnel \nGROUP BY branch, country \nORDER BY total_personnel DESC;\n```", "latency_sec": 0.35141706466674805, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 751, "prompt_eval_sec": null, "tokens_completion": 41, "completion_eval_sec": null, "tokens_total": 792, "tokens_per_sec": 2253.7323301333154, "retrieval_latency_sec": 0.11715483665466309, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select the same columns (branch, country, SUM(personnel) as total_personnel), group by the same columns (branch, country), and order by the same expression (total_personnel DESC). The only difference is formatting (line breaks), which does not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are syntactically identical, with the same SELECT, GROUP BY, and ORDER BY clauses. They correctly aggregate personnel counts by branch and country, which aligns with the business intent of summarizing totals per branch-country combination. The mention of 'corresponding rank' in the question is ambiguous\u2014since the queries aggregate across all ranks (not grouping by rank), they would return total personnel per branch-country without rank-specific breakdowns. However, given the schema and the phrasing of the question, the queries fulfill the stated intent of aggregating totals by branch and country. Both are equally efficient and elegant.", "overall_assessment": "correct"}}
{"example_id": 521, "sql_complexity": "subqueries", "prompt": "How many vessels have not had an inspection in the past year?", "context": "CREATE TABLE safety_records(id INT, vessel_name VARCHAR(50), inspection_date DATE); CREATE TABLE vessels(id INT, name VARCHAR(50), country VARCHAR(50)); INSERT INTO vessels(id, name, country) VALUES (1, 'Vessel A', 'Philippines'), (2, 'Vessel B', 'Philippines'); INSERT INTO safety_records(id, vessel_name, inspection_date) VALUES (1, 'Vessel A', '2022-01-01');", "reference_sql": "SELECT COUNT(*) FROM vessels WHERE name NOT IN (SELECT vessel_name FROM safety_records WHERE inspection_date BETWEEN DATE_SUB(NOW(), INTERVAL 1 YEAR) AND NOW());", "generated_sql": "SELECT COUNT(DISTINCT sr.vessel_name)\nFROM safety_records sr\nWHERE sr.inspection_date < CURRENT_DATE - INTERVAL 1 YEAR;", "raw_model_output": "\n\nTo determine how many vessels have not had an inspection in the past year, we need to compare the `inspection_date` in the `safety_records` table with the current date. We will count the number of vessels where the last inspection is older than one year.\n\nHere is the SQL query:\n\n```sql\nSELECT COUNT(DISTINCT sr.vessel_name)\nFROM safety_records sr\nWHERE sr.inspection_date < CURRENT_DATE - INTERVAL 1 YEAR;\n```", "latency_sec": 0.7125108242034912, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 813, "prompt_eval_sec": null, "tokens_completion": 98, "completion_eval_sec": null, "tokens_total": 911, "tokens_per_sec": 1278.5770672584488, "retrieval_latency_sec": 0.10751581192016602, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL counts vessels not present in safety_records with inspections in the last year (including vessels with no inspections), while the Generated SQL counts distinct vessels with at least one inspection older than a year. The logic differs: the first excludes vessels with recent inspections, the second focuses on older inspections, and they handle vessels with no records differently.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly identifies vessels without any inspections in the past year by using NOT IN with a subquery that filters recent inspections. The generated query incorrectly counts vessels with inspections older than a year (not recent) and excludes vessels with no inspection records at all. The reference query addresses the full scope of the question, while the generated query misinterprets the requirement by focusing on outdated inspections rather than absence of recent ones.", "overall_assessment": "incorrect"}}
{"example_id": 5687, "sql_complexity": "multiple_joins", "prompt": "List organizations with more than 200 volunteers, and their average donation amounts, excluding donations less than $10.", "context": "CREATE TABLE organizations (org_id INT, org_name TEXT, social_impact_score INT);CREATE TABLE volunteers (vol_id INT, org_id INT, vol_country TEXT);CREATE TABLE donations (donation_id INT, donor_id INT, donation_amount INT, donation_date DATE);", "reference_sql": "SELECT o.org_name, AVG(donation_amount) AS avg_donation_amount FROM organizations o JOIN volunteers v ON o.org_id = v.org_id JOIN donations don ON o.org_id = don.org_id WHERE donation_amount >= 10 GROUP BY o.org_name HAVING COUNT(v.vol_id) > 200;", "generated_sql": "SELECT o.org_id, COUNT(v.vol_id) AS total_volunteers, AVG(d.donation_amount) AS average_donation_amount  \nFROM organizations o  \nJOIN volunteers v ON o.org_id = v.org_id  \nJOIN donations d ON o.org_id = d.donor_id  \nWHERE d.donation_amount >= 10  \nGROUP BY o.org_id  \nHAVING COUNT(v.vol_id) > 200;", "raw_model_output": "\n\nSELECT o.org_id, COUNT(v.vol_id) AS total_volunteers, AVG(d.donation_amount) AS average_donation_amount  \nFROM organizations o  \nJOIN volunteers v ON o.org_id = v.org_id  \nJOIN donations d ON o.org_id = d.donor_id  \nWHERE d.donation_amount >= 10  \nGROUP BY o.org_id  \nHAVING COUNT(v.vol_id) > 200;", "latency_sec": 0.7725729942321777, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 995, "prompt_eval_sec": null, "tokens_completion": 90, "completion_eval_sec": null, "tokens_total": 1085, "tokens_per_sec": 1404.3980414799873, "retrieval_latency_sec": 0.09663200378417969, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in several key aspects. 1) The Reference SQL joins the 'donations' table on 'org_id', while the Generated SQL joins on 'donor_id', which is a different column. 2) The Reference SQL selects 'org_name' and groups by it, while the Generated SQL selects 'org_id' and groups by it. 3) The Generated SQL includes 'org_id' in the output and uses a different column name for the average donation amount. These differences in join conditions, grouping columns, and selected columns mean the queries will not produce the same results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The Reference SQL is closer to fulfilling the business intent but has critical technical issues. Both queries incorrectly join donations to organizations: the Reference uses 'don.org_id' (missing from schema) and the Generated uses 'd.donor_id' (donor_id links to donors, not organizations). The Reference correctly selects 'org_name' as required, while the Generated selects 'org_id' instead. The Reference's HAVING clause counts volunteers correctly, but both queries fail to properly link donations to organizations due to schema limitations. The Generated SQL's join condition is more fundamentally flawed.", "overall_assessment": "differently_correct"}}
{"example_id": 1281, "sql_complexity": "subqueries", "prompt": "Find the top 3 contributors with the lowest recycling rate in the 'waste_contributors' table.", "context": "CREATE TABLE waste_contributors (contributor VARCHAR(20), recycling_rate FLOAT); INSERT INTO waste_contributors (contributor, recycling_rate) VALUES ('Manufacturing', 0.4), ('Commercial', 0.38), ('Residential', 0.35), ('Institutional', 0.32), ('Agricultural', 0.2), ('Industrial', 0.15);", "reference_sql": "SELECT contributor FROM waste_contributors WHERE recycling_rate IN (SELECT MIN(recycling_rate) FROM waste_contributors) LIMIT 3;", "generated_sql": "SELECT contributor FROM waste_contributors ORDER BY recycling_rate ASC LIMIT 3;", "raw_model_output": "\n\nSQL: SELECT contributor FROM waste_contributors ORDER BY recycling_rate ASC LIMIT 3;", "latency_sec": 0.23334622383117676, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 852, "prompt_eval_sec": null, "tokens_completion": 22, "completion_eval_sec": null, "tokens_total": 874, "tokens_per_sec": 3745.507365194513, "retrieval_latency_sec": 0.10720515251159668, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query selects contributors with the minimum recycling rate (0.15, which is 'Industrial') and limits to 3 rows. The generated query orders all contributors by ascending recycling rate and returns the top 3, which would be 'Industrial', 'Agricultural', and 'Institutional'. The first query returns only the absolute minimum, while the second returns the three lowest values, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query incorrectly uses a subquery to find only the absolute minimum recycling rate (which would return only 'Industrial' in the sample data) and then applies LIMIT 3. This approach fails to retrieve the *top 3 lowest* rates when there are multiple distinct values. The generated query correctly sorts contributors by recycling_rate in ascending order and limits to 3, which accurately identifies the three contributors with the lowest rates (Industrial, Agricultural, Institutional). The business intent to find the 'top 3 contributors with the lowest recycling rate' is only fulfilled by the generated query.", "overall_assessment": "differently_correct"}}
{"example_id": 5669, "sql_complexity": "window functions", "prompt": "What is the total number of new and returning volunteers in each program in each month?", "context": "CREATE TABLE Volunteers (VolunteerID INT, VolunteerName TEXT, ProgramID INT, VolunteerDate DATE, IsReturning BOOLEAN); INSERT INTO Volunteers (VolunteerID, VolunteerName, ProgramID, VolunteerDate, IsReturning) VALUES (6, 'David Kim', 1, '2022-03-01', FALSE), (7, 'Emily Chen', 2, '2022-03-15', TRUE), (8, 'James Lee', 2, '2022-04-01', FALSE), (9, 'Grace Park', 3, '2022-04-15', TRUE), (10, 'Daniel Kim', 1, '2022-04-01', FALSE);", "reference_sql": "SELECT ProgramID, EXTRACT(MONTH FROM VolunteerDate) AS Month, SUM(CASE WHEN IsReturning THEN 1 ELSE 0 END) OVER (PARTITION BY ProgramID, EXTRACT(MONTH FROM VolunteerDate) ORDER BY ProgramID, EXTRACT(MONTH FROM VolunteerDate)) + COUNT(DISTINCT VolunteerID) OVER (PARTITION BY ProgramID, EXTRACT(MONTH FROM VolunteerDate) ORDER BY ProgramID, EXTRACT(MONTH FROM VolunteerDate)) AS TotalVolunteers FROM Volunteers;", "generated_sql": "SELECT \n    ProgramID, \n    EXTRACT(MONTH FROM VolunteerDate) AS Month, \n    SUM(CASE WHEN IsReturning = FALSE THEN 1 ELSE 0 END) AS NewVolunteers, \n    SUM(CASE WHEN IsReturning = TRUE THEN 1 ELSE 0 END) AS ReturningVolunteers\nFROM Volunteers\nGROUP BY ProgramID, EXTRACT(MONTH FROM VolunteerDate)\nORDER BY ProgramID, Month;", "raw_model_output": "\n\n```sql\nSELECT \n    ProgramID, \n    EXTRACT(MONTH FROM VolunteerDate) AS Month, \n    SUM(CASE WHEN IsReturning = FALSE THEN 1 ELSE 0 END) AS NewVolunteers, \n    SUM(CASE WHEN IsReturning = TRUE THEN 1 ELSE 0 END) AS ReturningVolunteers\nFROM Volunteers\nGROUP BY ProgramID, EXTRACT(MONTH FROM VolunteerDate)\nORDER BY ProgramID, Month;\n```", "latency_sec": 0.729931116104126, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1168, "prompt_eval_sec": null, "tokens_completion": 99, "completion_eval_sec": null, "tokens_total": 1267, "tokens_per_sec": 1735.7802291843389, "retrieval_latency_sec": 0.10926103591918945, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL calculates a cumulative total combining returning volunteers and distinct volunteer counts using window functions, while the Generated SQL aggregates data into separate counts of new and returning volunteers per group. The output structure and calculation logic differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL is technically incorrect because it incorrectly combines window functions to calculate 'TotalVolunteers' by summing returning volunteers and counting distinct volunteers, which would produce inflated and nonsensical totals. The Generated SQL correctly separates new and returning volunteers using conditional aggregation with GROUP BY, directly answering the question. While both queries group by ProgramID and Month, the Reference SQL's logic violates basic arithmetic principles (e.g., counting returning volunteers + total volunteers = double-counting). The Generated SQL properly fulfills the business intent by explicitly reporting new and returning counts.", "overall_assessment": "differently_correct"}}
{"example_id": 3576, "sql_complexity": "window functions", "prompt": "What is the difference in the number of eco-friendly hotels between the top 2 countries?", "context": "CREATE TABLE eco_hotel_count (country TEXT, num_hotels INT); INSERT INTO eco_hotel_count (country, num_hotels) VALUES ('France', 100), ('Italy', 120), ('Germany', 150), ('Spain', 110), ('UK', 160);", "reference_sql": "SELECT (MAX(num_hotels) OVER (PARTITION BY num_hotels <= 2) - MIN(num_hotels) OVER (PARTITION BY num_hotels <= 2)) AS hotel_difference FROM eco_hotel_count WHERE country IN ('France', 'Italy');", "generated_sql": "SELECT (MAX(num_hotels) - MIN(num_hotels)) AS difference\nFROM (\n    SELECT num_hotels\n    FROM eco_hotel_count\n    ORDER BY num_hotels DESC\n    LIMIT 2\n) AS top_two;", "raw_model_output": "\n\nTo find the difference in the number of eco-friendly hotels between the top 2 countries, we need to:\n\n1. Identify the top 2 countries with the highest number of eco-friendly hotels.\n2. Calculate the difference between their counts.\n\nHere is the SQL query:\n\n```sql\nSELECT (MAX(num_hotels) - MIN(num_hotels)) AS difference\nFROM (\n    SELECT num_hotels\n    FROM eco_hotel_count\n    ORDER BY num_hotels DESC\n    LIMIT 2\n) AS top_two;\n```", "latency_sec": 0.8576912879943848, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 703, "prompt_eval_sec": null, "tokens_completion": 112, "completion_eval_sec": null, "tokens_total": 815, "tokens_per_sec": 950.2253449557433, "retrieval_latency_sec": 0.09401416778564453, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters to only France and Italy (num_hotels 100 and 120) and calculates MAX-MIN over those two values (20). The Generated SQL selects top 2 hotels from the entire table (UK 160 and Germany 150) and calculates MAX-MIN (10). The different data subsets and calculation logic make them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is incorrect because it filters for specific countries (France, Italy) instead of identifying the actual top 2 countries by num_hotels. The WHERE clause restricts results to only France and Italy, which are not the top 2 countries in the dataset (UK and Germany have higher counts). The Generated SQL correctly identifies the top 2 countries by ordering and limiting to 2 rows, then calculates their difference. While both queries compute a difference, they target different subsets of data, leading to different results (20 vs. 10). The Generated SQL better fulfills the business intent of comparing the top 2 countries.", "overall_assessment": "differently_correct"}}
{"example_id": 1970, "sql_complexity": "multiple_joins", "prompt": "List all players who have played a specific VR game, 'CyberSphere', and their ages.", "context": "CREATE TABLE Players (PlayerID INT, Age INT, Gender VARCHAR(10), Country VARCHAR(50)); CREATE TABLE VRPlayers (PlayerID INT, VRGameID INT); CREATE TABLE VRGames (VRGameID INT, Title VARCHAR(50)); INSERT INTO Players (PlayerID, Age, Gender, Country) VALUES (1, 25, 'Male', 'USA'); INSERT INTO Players (PlayerID, Age, Gender, Country) VALUES (2, 28, 'Female', 'Canada'); INSERT INTO VRPlayers (PlayerID, VRGameID) VALUES (1, 1); INSERT INTO VRPlayers (PlayerID, VRGameID) VALUES (2, 1); INSERT INTO VRGames (VRGameID, Title) VALUES (1, 'CyberSphere');", "reference_sql": "SELECT Players.Age, Players.PlayerID FROM Players INNER JOIN VRPlayers ON Players.PlayerID = VRPlayers.PlayerID INNER JOIN VRGames ON VRPlayers.VRGameID = VRGames.VRGameID WHERE VRGames.Title = 'CyberSphere';", "generated_sql": "SELECT Players.PlayerID, Players.Age FROM Players INNER JOIN VRPlayers ON Players.PlayerID = VRPlayers.PlayerID INNER JOIN VRGames ON VRPlayers.VRGameID = VRGames.VRGameID WHERE VRGames.Title = 'CyberSphere';", "raw_model_output": "\n\nSELECT Players.PlayerID, Players.Age FROM Players INNER JOIN VRPlayers ON Players.PlayerID = VRPlayers.PlayerID INNER JOIN VRGames ON VRPlayers.VRGameID = VRGames.VRGameID WHERE VRGames.Title = 'CyberSphere';", "latency_sec": 0.5506300926208496, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1000, "prompt_eval_sec": null, "tokens_completion": 55, "completion_eval_sec": null, "tokens_total": 1055, "tokens_per_sec": 1915.9868197150045, "retrieval_latency_sec": 0.11024188995361328, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The two queries differ only in the order of columns in the SELECT clause (Age first vs. PlayerID first). Since SQL result sets are not dependent on column order for semantic equivalence, both queries retrieve the same data.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly retrieve players who have played 'CyberSphere' by joining the three tables with appropriate conditions. The only difference is the column order in the SELECT clause (Age first vs. PlayerID first), which does not affect the semantic equivalence or business intent fulfillment. Both queries are equally efficient and elegant, as column ordering in SELECT has no impact on query performance or logical correctness.", "overall_assessment": "correct"}}
{"example_id": 2414, "sql_complexity": "window functions", "prompt": "List the policy areas with the lowest citizen satisfaction scores.", "context": "CREATE TABLE Policy (Area VARCHAR(20), Score INT); INSERT INTO Policy (Area, Score) VALUES ('Transportation', 70), ('Education', 85), ('Healthcare', 75), ('PublicSafety', 80);", "reference_sql": "SELECT Area, Score FROM (SELECT Area, Score, ROW_NUMBER() OVER (ORDER BY Score) AS RN FROM Policy) X WHERE RN IN (1, 2);", "generated_sql": "SELECT Area FROM Policy ORDER BY Score ASC LIMIT 1;", "raw_model_output": "\n\nSELECT Area FROM Policy ORDER BY Score ASC LIMIT 1;", "latency_sec": 0.20721197128295898, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 818, "prompt_eval_sec": null, "tokens_completion": 17, "completion_eval_sec": null, "tokens_total": 835, "tokens_per_sec": 4029.689958693376, "retrieval_latency_sec": 0.12682008743286133, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL retrieves the top 2 rows ordered by Score (using ROW_NUMBER()), while the Generated SQL only retrieves the top 1 row. The first query returns two records (Transportation and Healthcare), whereas the second returns only one (Transportation).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL retrieves the two lowest scores using ROW_NUMBER(), which may not align with the business intent of identifying the absolute lowest scores (plural). The Generated SQL correctly identifies the single lowest score (as per the data provided), which matches the explicit requirement for 'lowest citizen satisfaction scores' in the context of the given dataset. While the original question is slightly ambiguous about whether to return one or multiple entries, the Generated SQL is technically accurate for the provided data and directly addresses the minimum value. The Reference SQL's use of ROW_NUMBER() could lead to incorrect results if multiple policies share the same minimum score, as it would only return the first two rows rather than all policies with the minimum score.", "overall_assessment": "correct"}}
{"example_id": 1898, "sql_complexity": "single join", "prompt": "What are the total sales for each drug in Q2 2020?", "context": "CREATE TABLE drugs (drug_id INT, drug_name TEXT); INSERT INTO drugs (drug_id, drug_name) VALUES (1001, 'Ibuprofen'), (1002, 'Paracetamol'), (1003, 'Aspirin'); CREATE TABLE sales (sale_id INT, drug_id INT, sale_date DATE, revenue FLOAT); INSERT INTO sales (sale_id, drug_id, sale_date, revenue) VALUES (1, 1001, '2020-04-05', 1800.0), (2, 1002, '2020-04-10', 2300.0), (3, 1003, '2020-04-15', 1400.0), (4, 1001, '2020-05-20', 1900.0), (5, 1002, '2020-06-25', 2400.0);", "reference_sql": "SELECT drug_name, SUM(revenue) as total_sales FROM sales JOIN drugs ON sales.drug_id = drugs.drug_id WHERE sale_date BETWEEN '2020-04-01' AND '2020-06-30' GROUP BY drug_name;", "generated_sql": "SELECT drugs.drug_name, SUM(sales.revenue) AS total_sales \nFROM sales \nJOIN drugs ON sales.drug_id = drugs.drug_id \nWHERE sales.sale_date BETWEEN '2020-04-01' AND '2020-06-30' \nGROUP BY drugs.drug_name;", "raw_model_output": "\n\nSELECT drugs.drug_name, SUM(sales.revenue) AS total_sales \nFROM sales \nJOIN drugs ON sales.drug_id = drugs.drug_id \nWHERE sales.sale_date BETWEEN '2020-04-01' AND '2020-06-30' \nGROUP BY drugs.drug_name;", "latency_sec": 0.5772030353546143, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1295, "prompt_eval_sec": null, "tokens_completion": 75, "completion_eval_sec": null, "tokens_total": 1370, "tokens_per_sec": 2373.514891789018, "retrieval_latency_sec": 0.12135481834411621, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate total sales per drug within the same date range. The reference query uses implicit column naming (drug_name) while the generated query uses explicit table aliases (drugs.drug_name). The JOIN condition, WHERE clause, and GROUP BY logic are identical. Since the drug_name is unique per drug_id and the date filter is the same, both queries produce equivalent results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate total sales per drug for Q2 2020 by joining the sales and drugs tables, filtering dates between '2020-04-01' and '2020-06-30', and grouping by drug name. The Reference SQL uses implicit column naming (drug_name) while the Generated SQL explicitly qualifies it with the table alias (drugs.drug_name). However, since the JOIN ensures unambiguous context for drug_name, both produce identical results. The Generated SQL demonstrates better practice with table aliases but does not alter the output. Both fulfill the business intent of aggregating sales by drug for the specified quarter.", "overall_assessment": "correct"}}
{"example_id": 2403, "sql_complexity": "multiple_joins", "prompt": "Who is the most frequent customer ordering vegetarian items?", "context": "CREATE TABLE customers (customer_id INT, customer_name VARCHAR(50)); INSERT INTO customers VALUES (1, 'John Doe'), (2, 'Jane Smith'), (3, 'Alice Johnson'); CREATE TABLE orders (order_id INT, customer_id INT, menu_id INT, order_date DATE); INSERT INTO orders VALUES (1, 1, 1, '2022-01-01'), (2, 2, 3, '2022-01-02'), (3, 3, 2, '2022-01-03'); CREATE TABLE menu (menu_id INT, item_name VARCHAR(50), is_vegetarian BOOLEAN, price DECIMAL(5,2)); INSERT INTO menu VALUES (1, 'Veggie Burger', true, 8.99), (2, 'Cheeseburger', false, 7.99), (3, 'Tofu Stir Fry', true, 11.99);", "reference_sql": "SELECT customers.customer_name, COUNT(orders.order_id) as order_count FROM customers INNER JOIN orders ON customers.customer_id = orders.customer_id INNER JOIN menu ON orders.menu_id = menu.menu_id WHERE menu.is_vegetarian = true GROUP BY customers.customer_name ORDER BY order_count DESC LIMIT 1;", "generated_sql": "SELECT c.customer_name, COUNT(*) AS vegetarian_order_count\nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nJOIN menu m ON o.menu_id = m.menu_id\nWHERE m.is_vegetarian = TRUE\nGROUP BY c.customer_id, c.customer_name\nORDER BY vegetarian_order_count DESC\nLIMIT 1;", "raw_model_output": "\n\nTo find the most frequent customer ordering vegetarian items, we need to:\n\n1. Join the `orders` table with the `menu` table to identify which items are vegetarian.\n2. Group by `customer_id` to count how many vegetarian items each customer has ordered.\n3. Order by the count in descending order and limit to the top result.\n\nHere is the SQL query:\n\n```sql\nSELECT c.customer_name, COUNT(*) AS vegetarian_order_count\nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nJOIN menu m ON o.menu_id = m.menu_id\nWHERE m.is_vegetarian = TRUE\nGROUP BY c.customer_id, c.customer_name\nORDER BY vegetarian_order_count DESC\nLIMIT 1;\n```", "latency_sec": 1.0837271213531494, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1092, "prompt_eval_sec": null, "tokens_completion": 155, "completion_eval_sec": null, "tokens_total": 1247, "tokens_per_sec": 1150.658662526584, "retrieval_latency_sec": 0.12910079956054688, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their GROUP BY clauses. The Reference SQL groups by customer_name alone, which could combine multiple customers with the same name. The Generated SQL groups by both customer_id and customer_name, ensuring accurate aggregation per customer. While the sample data may produce the same result, the queries are not semantically equivalent in general cases where customer names are not unique.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify the most frequent customer for vegetarian items by joining customers, orders, and menu tables with a vegetarian filter. The key difference lies in the GROUP BY clause: the reference query groups by customer_name (risking aggregation errors if names are duplicated), while the generated query groups by both customer_id and customer_name (ensuring accuracy via the primary key). Though the sample data makes them equivalent, the generated query is technically superior for production environments. Both fulfill the business intent, but the generated version is more robust.", "overall_assessment": "differently_correct"}}
{"example_id": 124, "sql_complexity": "set operations", "prompt": "Find the intersection of AI and accessibility research projects in the EU and those in Africa.", "context": "CREATE SCHEMA if not exists accessibility; CREATE TABLE if not exists accessibility.research (id INT PRIMARY KEY, project_name VARCHAR(255), region VARCHAR(255)); INSERT INTO accessibility.research (id, project_name, region) VALUES (1, 'AI for Accessibility EU', 'EU'), (2, 'Accessibility Africa', 'Africa'), (3, 'AI for Accessibility Africa', 'Africa'), (4, 'Accessibility EU', 'EU');", "reference_sql": "SELECT project_name FROM accessibility.research WHERE region = 'EU' INTERSECT SELECT project_name FROM accessibility.research WHERE region = 'Africa';", "generated_sql": "SELECT project_name FROM accessibility.research WHERE region = 'EU' AND project_name LIKE '%AI%' AND project_name LIKE '%Accessibility%' INTERSECT SELECT project_name FROM accessibility.research WHERE region = 'Africa' AND project_name LIKE '%AI%' AND project_name LIKE '%Accessibility%';", "raw_model_output": "\n\nSELECT project_name FROM accessibility.research WHERE region = 'EU' AND project_name LIKE '%AI%' AND project_name LIKE '%Accessibility%' INTERSECT SELECT project_name FROM accessibility.research WHERE region = 'Africa' AND project_name LIKE '%AI%' AND project_name LIKE '%Accessibility%';", "latency_sec": 0.5981650352478027, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 852, "prompt_eval_sec": null, "tokens_completion": 63, "completion_eval_sec": null, "tokens_total": 915, "tokens_per_sec": 1529.6781758916109, "retrieval_latency_sec": 0.12042689323425293, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The reference query finds project names present in both 'EU' and 'Africa' regions without additional filters. The generated query adds constraints that project_name must contain both 'AI' and 'Accessibility' in both regions. While both return empty sets for the given data, the generated query is more restrictive and would exclude results that meet the region criteria but not the LIKE conditions, making them non-equivalent in general.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL is technically incorrect for the business question because it only filters by region without considering the 'AI' and 'accessibility' criteria. The Generated SQL properly applies both region and keyword filters (using LIKE '%AI%' AND LIKE '%Accessibility%') in both subqueries before performing the INTERSECT. This ensures the intersection contains projects explicitly related to both AI and accessibility in each region. While both queries use INTERSECT, the Generated SQL's additional constraints align with the business requirement to identify projects that are specifically about AI and accessibility. The Reference SQL would return projects in both regions regardless of their thematic focus, making it less precise.", "overall_assessment": "differently_correct"}}
{"example_id": 1231, "sql_complexity": "basic SQL", "prompt": "What is the average ticket price for performances at the 'Downtown Theater'?", "context": "CREATE TABLE DowntownTheater (show_name TEXT, date DATE, ticket_price FLOAT); INSERT INTO DowntownTheater (show_name, date, ticket_price) VALUES ('Play 1', '2022-01-01', 30.0), ('Play 2', '2022-01-02', 40.0), ('Concert 1', '2022-01-03', 50.0);", "reference_sql": "SELECT AVG(ticket_price) FROM DowntownTheater WHERE show_name = 'Downtown Theater'", "generated_sql": "SELECT AVG(ticket_price) FROM DowntownTheater;", "raw_model_output": "\n\nSELECT AVG(ticket_price) FROM DowntownTheater;", "latency_sec": 0.29335880279541016, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 831, "prompt_eval_sec": null, "tokens_completion": 15, "completion_eval_sec": null, "tokens_total": 846, "tokens_per_sec": 2883.8405118185747, "retrieval_latency_sec": 0.12553071975708008, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters for show_name = 'Downtown Theater' which doesn't exist in the data (the actual show names are 'Play 1', 'Play 2', 'Concert 1'), resulting in NULL. The Generated SQL averages all ticket prices (30, 40, 50) which equals 40. The WHERE clause in Reference SQL changes the dataset being aggregated, making the results different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query incorrectly filters for shows named 'Downtown Theater' (a theater name) in the show_name column (which stores show titles, not venue names). The generated query correctly calculates the average ticket price for all performances in the DowntownTheater table. Since the table name itself indicates the venue, the generated query properly addresses the business intent of averaging all performances at the Downtown Theater. The reference query would return no results (as no show_name matches 'Downtown Theater') and thus fails to fulfill the intent.", "overall_assessment": "incorrect"}}
{"example_id": 1485, "sql_complexity": "set operations", "prompt": "How many public schools and public libraries exist in total, in the 'CityData' schema's 'CityEducation' and 'CityLibrary' tables?", "context": "CREATE SCHEMA CityData; CREATE TABLE CityEducation (Name varchar(255), Type varchar(255)); INSERT INTO CityEducation (Name, Type) VALUES ('SchoolA', 'Public'), ('SchoolB', 'Public'), ('SchoolC', 'Private'); CREATE TABLE CityLibrary (Name varchar(255), Type varchar(255)); INSERT INTO CityLibrary (Name, Type) VALUES ('LibraryA', 'Public'), ('LibraryB', 'Public'), ('LibraryC', 'Private');", "reference_sql": "SELECT COUNT(*) FROM CityData.CityEducation WHERE Type = 'Public' UNION ALL SELECT COUNT(*) FROM CityData.CityLibrary WHERE Type = 'Public';", "generated_sql": "SELECT (SELECT COUNT(*) FROM CityData.CityEducation WHERE Type = 'Public') + (SELECT COUNT(*) FROM CityData.CityLibrary WHERE Type = 'Public') AS TotalPublicInstitutions;", "raw_model_output": "\n\nSELECT (SELECT COUNT(*) FROM CityData.CityEducation WHERE Type = 'Public') + (SELECT COUNT(*) FROM CityData.CityLibrary WHERE Type = 'Public') AS TotalPublicInstitutions;", "latency_sec": 0.36876392364501953, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 773, "prompt_eval_sec": null, "tokens_completion": 43, "completion_eval_sec": null, "tokens_total": 816, "tokens_per_sec": 2212.7978028173384, "retrieval_latency_sec": 0.13054275512695312, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query returns two separate counts (one for CityEducation and one for CityLibrary) as two rows, while the generated query returns a single row with the sum of both counts. The output structure and values differ.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL uses UNION ALL to return two separate counts (schools and libraries) as individual rows, while the Generated SQL correctly calculates a single total by summing the counts. Although both queries correctly filter public institutions, the original question explicitly asks for a 'total' which requires aggregation. The Generated SQL directly addresses this by returning a single numeric value, whereas the Reference SQL returns two rows that would need additional processing to combine. Both are technically correct but differ in semantic alignment with the business intent.", "overall_assessment": "differently_correct"}}
{"example_id": 5806, "sql_complexity": "single join", "prompt": "List the top 3 countries with the most veteran employment in the IT industry", "context": "CREATE TABLE veteran_employment (employee_id INT, industry VARCHAR(255), salary DECIMAL(10,2), state VARCHAR(2), country VARCHAR(255)); CREATE TABLE countries (country_id INT, country VARCHAR(255));", "reference_sql": "SELECT country, COUNT(*) as num_veterans FROM veteran_employment JOIN countries ON veteran_employment.country = countries.country WHERE industry = 'IT' GROUP BY country ORDER BY num_veterans DESC LIMIT 3;", "generated_sql": "SELECT country, COUNT(*) AS veteran_count  \nFROM veteran_employment  \nWHERE industry = 'IT'  \nGROUP BY country  \nORDER BY veteran_count DESC  \nLIMIT 3;", "raw_model_output": "\n\nSELECT country, COUNT(*) AS veteran_count  \nFROM veteran_employment  \nWHERE industry = 'IT'  \nGROUP BY country  \nORDER BY veteran_count DESC  \nLIMIT 3;", "latency_sec": 0.39591002464294434, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1015, "prompt_eval_sec": null, "tokens_completion": 40, "completion_eval_sec": null, "tokens_total": 1055, "tokens_per_sec": 2664.7468726043576, "retrieval_latency_sec": 0.14191079139709473, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a JOIN with the countries table, while the Generated SQL does not. This could lead to different results if there are countries in veteran_employment that do not exist in the countries table. The JOIN ensures only countries present in both tables are considered, whereas the Generated SQL would include all countries from veteran_employment where industry = 'IT'.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count IT industry veterans per country and return the top 3. The Reference SQL includes an unnecessary JOIN with the countries table, which doesn't affect the result since the country names are already present in veteran_employment. The Generated SQL is more efficient by avoiding the redundant join while maintaining identical semantic output. Both fulfill the business intent, but the Generated SQL is simpler and more performant.", "overall_assessment": "correct"}}
{"example_id": 4126, "sql_complexity": "window functions", "prompt": "What is the average crime rate per capita in each neighborhood?", "context": "CREATE TABLE neighborhoods (name VARCHAR(255), population INT, crime_count INT); INSERT INTO neighborhoods (name, population, crime_count) VALUES ('Central Park', 1000, 25), ('Harlem', 2500, 75), ('Brooklyn', 5000, 120);", "reference_sql": "SELECT name, AVG(crime_count/population) OVER (PARTITION BY name) FROM neighborhoods;", "generated_sql": "SELECT name, (crime_count * 1.0 / population) AS crime_rate_per_capita FROM neighborhoods;", "raw_model_output": "\n\nSELECT name, (crime_count * 1.0 / population) AS crime_rate_per_capita FROM neighborhoods;", "latency_sec": 0.2738351821899414, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 787, "prompt_eval_sec": null, "tokens_completion": 28, "completion_eval_sec": null, "tokens_total": 815, "tokens_per_sec": 2976.2428387842738, "retrieval_latency_sec": 0.14010882377624512, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the crime rate per capita (crime_count/population) for each neighborhood. The Reference SQL uses AVG() with a window partitioned by name, but since each name is unique, the average of a single row equals the value itself. The Generated SQL directly computes the ratio, equivalent to the Reference SQL's result. Both produce identical numerical values for the crime rate.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query incorrectly uses an unnecessary window function. The AVG(crime_count/population) OVER (PARTITION BY name) returns the same value as crime_count/population for each row (since each neighborhood is partitioned individually), but adds unnecessary complexity. The generated query directly calculates the per capita crime rate (crime_count * 1.0 / population) which accurately answers the question. While both queries return similar numerical results, the generated version is technically correct, efficient, and directly addresses the business intent of calculating per capita crime rates.", "overall_assessment": "differently_correct"}}
{"example_id": 4559, "sql_complexity": "basic SQL", "prompt": "List the top 3 energy efficient appliances in the US by energy star rating?", "context": "CREATE TABLE appliances (id INT, name VARCHAR(255), country VARCHAR(255), energy_star_rating INT); INSERT INTO appliances (id, name, country, energy_star_rating) VALUES (1, 'Fridge A', 'USA', 5), (2, 'TV B', 'USA', 4), (3, 'Laptop C', 'USA', 5), (4, 'Microwave D', 'USA', 3);", "reference_sql": "SELECT name, energy_star_rating FROM appliances WHERE country = 'USA' ORDER BY energy_star_rating DESC LIMIT 3;", "generated_sql": "SELECT name, energy_star_rating FROM appliances WHERE country = 'USA' ORDER BY energy_star_rating DESC LIMIT 3;", "raw_model_output": "\n\n```sql\nSELECT name, energy_star_rating FROM appliances WHERE country = 'USA' ORDER BY energy_star_rating DESC LIMIT 3;\n```", "latency_sec": 0.42508888244628906, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 771, "prompt_eval_sec": null, "tokens_completion": 33, "completion_eval_sec": null, "tokens_total": 804, "tokens_per_sec": 1891.3691540770587, "retrieval_latency_sec": 0.12564992904663086, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure and logic. Both select the same columns, apply the same WHERE condition, use the same ORDER BY clause, and enforce the same LIMIT. The result sets will be exactly the same.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic. They correctly filter US appliances, order by energy_star_rating descending (which aligns with 'energy efficiency' as higher ratings indicate more efficiency), and limit to 3 results. The queries are semantically equivalent, technically correct, and fully address the business intent of identifying top energy-efficient appliances. Neither query is more efficient or elegant than the other as they are identical.", "overall_assessment": "correct"}}
{"example_id": 456, "sql_complexity": "window functions", "prompt": "List the intelligence operations and their corresponding threat levels, and rank them based on their threat level and budget.", "context": "CREATE TABLE intel_ops_threat (id INT, operation VARCHAR, threat VARCHAR, budget INT); INSERT INTO intel_ops_threat (id, operation, threat, budget) VALUES (1, 'Operation Red Folder', 'High', 5000000), (2, 'Operation Black Vault', 'Medium', 7000000), (3, 'Operation Blue Sail', 'Low', 6000000);", "reference_sql": "SELECT operation, threat, budget, ROW_NUMBER() OVER (PARTITION BY threat ORDER BY budget DESC) as rank FROM intel_ops_threat;", "generated_sql": "SELECT operation, threat, budget, \n       ROW_NUMBER() OVER (ORDER BY threat DESC, budget DESC) AS rank \nFROM intel_ops_threat;", "raw_model_output": "\n\nSELECT operation, threat, budget, \n       ROW_NUMBER() OVER (ORDER BY threat DESC, budget DESC) AS rank \nFROM intel_ops_threat;", "latency_sec": 0.32227015495300293, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 801, "prompt_eval_sec": null, "tokens_completion": 36, "completion_eval_sec": null, "tokens_total": 837, "tokens_per_sec": 2597.199855885075, "retrieval_latency_sec": 0.11394715309143066, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their window function definitions. The reference query partitions by 'threat' and orders by 'budget DESC', restarting the row number for each threat level. The generated query orders by 'threat DESC, budget DESC' without partitioning, resulting in a single sequence of ranks across all rows. This leads to different ranking values and ordering logic, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query ranks operations within each threat level (partitioned by threat) based on budget, while the generated query applies a global ranking ordered by threat (descending) and budget (descending). The original question asks to 'rank them based on their threat level and budget' without specifying per-group ranking. The generated query better aligns with a global ranking approach, though both have issues: (1) The generated query's ORDER BY threat DESC does not correctly prioritize threat levels (High > Medium > Low) as string comparisons would order 'Medium' > 'Low' > 'High'. (2) The reference query ignores the threat level in the global ranking, focusing only on budget within groups. Neither query fully addresses the business intent of properly ordering threat levels, but the generated query's global ranking approach is more aligned with the phrasing of the question.", "overall_assessment": "differently_correct"}}
{"example_id": 459, "sql_complexity": "set operations", "prompt": "What is the total installed capacity of hydroelectric power plants in Brazil and Canada?", "context": "CREATE TABLE hydroelectric_power (country TEXT, capacity INTEGER); INSERT INTO hydroelectric_power (country, capacity) VALUES ('Brazil', 104000), ('Canada', 78000), ('China', 350000), ('United States', 100000), ('Russia', 45000);", "reference_sql": "(SELECT capacity FROM hydroelectric_power WHERE country = 'Brazil') UNION (SELECT capacity FROM hydroelectric_power WHERE country = 'Canada');", "generated_sql": "SELECT SUM(capacity) FROM hydroelectric_power WHERE country IN ('Brazil', 'Canada');", "raw_model_output": "\n\nSELECT SUM(capacity) FROM hydroelectric_power WHERE country IN ('Brazil', 'Canada');", "latency_sec": 0.2376570701599121, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 889, "prompt_eval_sec": null, "tokens_completion": 23, "completion_eval_sec": null, "tokens_total": 912, "tokens_per_sec": 3837.46210195364, "retrieval_latency_sec": 0.12090206146240234, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate capacity values (Brazil and Canada) as individual rows, while the Generated SQL returns a single summed value of both countries' capacities. The first query retrieves distinct values, the second aggregates them, resulting in different output structures and values.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query uses UNION to combine separate capacity values for Brazil and Canada, returning two rows of individual capacities rather than a single total. The generated query correctly uses SUM() to calculate the combined capacity. While both queries retrieve data about the specified countries, only the generated query performs the required aggregation to answer the 'total installed capacity' question. The reference query would require additional processing (e.g., manual summation) to achieve the same result, making it less efficient and technically incorrect for the task.", "overall_assessment": "differently_correct"}}
{"example_id": 2356, "sql_complexity": "window functions", "prompt": "Find the total billing amount for attorneys in the 'Criminal Law' practice area, for the year 2020, partitioned by attorney's last name and ordered by the total billing amount in descending order.", "context": "CREATE TABLE Attorneys (AttorneyID INT, FirstName VARCHAR(50), LastName VARCHAR(50), PracticeArea VARCHAR(50), TotalBilling FLOAT, BillingYear INT); INSERT INTO Attorneys (AttorneyID, FirstName, LastName, PracticeArea, TotalBilling, BillingYear) VALUES (1, 'Clara', 'Rivera', 'Personal Injury', 8000.00, 2020), (2, 'Jamal', 'Lee', 'Personal Injury', 6000.00, 2019), (3, 'Sophia', 'Gomez', 'Criminal Law', 9000.00, 2020);", "reference_sql": "SELECT LastName, SUM(TotalBilling) OVER (PARTITION BY PracticeArea, LastName, BillingYear) AS TotalBilling FROM Attorneys WHERE PracticeArea = 'Criminal Law' AND BillingYear = 2020 ORDER BY TotalBilling DESC;", "generated_sql": "SELECT LastName, SUM(TotalBilling) OVER (PARTITION BY LastName) AS TotalBilling \nFROM Attorneys \nWHERE PracticeArea = 'Criminal Law' \nORDER BY TotalBilling DESC;", "raw_model_output": "\n\n```sql\nSELECT LastName, SUM(TotalBilling) OVER (PARTITION BY LastName) AS TotalBilling \nFROM Attorneys \nWHERE PracticeArea = 'Criminal Law' \nORDER BY TotalBilling DESC;\n```", "latency_sec": 0.3979218006134033, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 983, "prompt_eval_sec": null, "tokens_completion": 48, "completion_eval_sec": null, "tokens_total": 1031, "tokens_per_sec": 2590.9613356460886, "retrieval_latency_sec": 0.12363290786743164, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL filters for BillingYear = 2020 and partitions by PracticeArea, LastName, and BillingYear, while the Generated SQL omits the BillingYear filter and partitions only by LastName. This leads to different results when there are multiple BillingYears for the same LastName in the 'Criminal Law' practice area. The Generated SQL would sum TotalBilling across all years for each LastName, whereas the Reference SQL sums only within the specified year.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly filters for 'Criminal Law' practice area and 2020 billing year, and partitions by LastName (via redundant PracticeArea/BillingYear partitioning). The Generated SQL lacks the BillingYear filter, leading to incorrect results for all years. Both use window functions instead of GROUP BY, but the Reference's filtering aligns with the business intent. The Generated SQL's partitioning by LastName alone would sum all billing across all years for each attorney, violating the 2020 requirement.", "overall_assessment": "differently_correct"}}
