{"example_id": 2656, "sql_complexity": "multiple_joins", "prompt": "Find the drugs and their respective total sales for rare diseases indication with sales greater than the average sales for infectious diseases.", "context": "CREATE TABLE sales (id INT, drug_id INT, quarter INT, year INT, revenue FLOAT); INSERT INTO sales (id, drug_id, quarter, year, revenue) VALUES (1, 1, 1, 2022, 1500000); CREATE TABLE drugs (id INT, name VARCHAR(50), company VARCHAR(50), indication VARCHAR(50)); INSERT INTO drugs (id, name, company, indication) VALUES (1, 'DrugA', 'ABC Corp', 'Rare_Diseases');", "reference_sql": "SELECT s.drug_id, d.name, SUM(s.revenue) as total_sales FROM sales s JOIN drugs d ON s.drug_id = d.id WHERE d.indication = 'Rare_Diseases' GROUP BY s.drug_id HAVING total_sales > (SELECT AVG(s2.revenue) FROM sales s2 JOIN drugs d2 ON s2.drug_id = d2.id WHERE d2.indication = 'Infectious_Diseases')", "generated_sql": "SELECT d.name AS drug_name, SUM(s.revenue) AS total_sales FROM sales s JOIN drugs d ON s.drug_id = d.id WHERE d.indication ilike '%Rare%Diseases%' AND s.year = 2022 GROUP BY d.name HAVING SUM(s.revenue) > (SELECT AVG(revenue) FROM sales WHERE indication ilike '%Infectious%Diseases%');", "raw_model_output": " Code\n<s> SELECT d.name AS drug_name, SUM(s.revenue) AS total_sales FROM sales s JOIN drugs d ON s.drug_id = d.id WHERE d.indication ilike '%Rare%Diseases%' AND s.year = 2022 GROUP BY d.name HAVING SUM(s.revenue) > (SELECT AVG(revenue) FROM sales WHERE indication ilike '%Infectious%Diseases%');", "latency_sec": 4.103288173675537, "total_duration_sec": 4.093268324, "load_duration_sec": 2.770018496, "tokens_prompt": 178, "prompt_eval_sec": 0.133932093, "tokens_completion": 114, "completion_eval_sec": 1.18631327, "tokens_total": 292, "tokens_per_sec": 71.16244037484694, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. Key differences: 1) Reference uses exact 'Rare_Diseases' match while Generated uses case-insensitive LIKE with wildcards. 2) Generated includes a year=2022 filter not in Reference. 3) Generated's subquery references 'indication' column in sales (which doesn't exist) instead of joining with drugs table. 4) Reference groups by drug_id while Generated groups by name. 5) Generated's subquery logic is invalid due to incorrect column reference.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL is technically correct and aligns with the business intent. It properly calculates the average sales for infectious diseases by joining the sales and drugs tables, ensuring accurate aggregation. The Generated SQL has multiple issues: 1) The subquery references 'indication' from the sales table (which doesn't exist), 2) It adds an unintended year filter (2022) not in the original question, 3) Uses a case-insensitive LIKE with wildcards that could mismatch the exact 'Rare_Diseases' indication. While the Reference SQL groups by drug_id (correctly ensuring unique aggregation), the Generated SQL groups by name (which may not be unique). The Reference SQL also correctly compares total_sales against the infectious diseases average, while the Generated SQL's subquery is fundamentally flawed.", "overall_assessment": "incorrect"}}
{"example_id": 3008, "sql_complexity": "multiple_joins", "prompt": "Who are the users who used electric vehicles and their trip details?", "context": "CREATE TABLE users (id INT, name VARCHAR(50), age INT, gender VARCHAR(10), city VARCHAR(50));CREATE TABLE vehicles (id INT, vehicle_type VARCHAR(20), is_electric BOOLEAN);CREATE TABLE trips (id INT, user_id INT, vehicle_id INT, trip_distance FLOAT, trip_duration INT, departure_time TIMESTAMP, arrival_time TIMESTAMP);INSERT INTO users (id, name, age, gender, city) VALUES (3, 'Alex', 30, 'Female', 'New York');INSERT INTO vehicles (id, vehicle_type, is_electric) VALUES (1, 'Tesla', true), (2, 'Bike', false);INSERT INTO trips (id, user_id, vehicle_id, trip_distance, trip_duration, departure_time, arrival_time) VALUES (3, 3, 1, 15.3, 25, '2022-01-03 12:00:00', '2022-01-03 12:25:00');", "reference_sql": "SELECT u.name, v.vehicle_type, t.trip_distance, t.trip_duration FROM users u JOIN trips t ON u.id = t.user_id JOIN vehicles v ON t.vehicle_id = v.id WHERE v.is_electric = true;", "generated_sql": "SELECT u.name, v.vehicle_type, d.departure_time, d.arrival_time, d.trip_distance, d.trip_duration FROM users AS u JOIN trips AS d ON u.id = d.user_id JOIN vehicles AS v ON d.vehicle_id = v.id WHERE v.is_electric = TRUE;", "raw_model_output": " Code\n<s> SELECT u.name, v.vehicle_type, d.departure_time, d.arrival_time, d.trip_distance, d.trip_duration FROM users AS u JOIN trips AS d ON u.id = d.user_id JOIN vehicles AS v ON d.vehicle_id = v.id WHERE v.is_electric = TRUE;", "latency_sec": 1.131260871887207, "total_duration_sec": 1.058173458, "load_duration_sec": 0.00898648, "tokens_prompt": 295, "prompt_eval_sec": 0.020660487, "tokens_completion": 91, "completion_eval_sec": 1.027361256, "tokens_total": 386, "tokens_per_sec": 341.21219039076453, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL selects (name, vehicle_type, trip_distance, trip_duration), while the Generated SQL selects (name, vehicle_type, departure_time, arrival_time, trip_distance, trip_duration). The Generated SQL includes additional columns (departure_time, arrival_time) not present in the Reference SQL, resulting in different output structures.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because the generated query includes additional columns (departure_time, arrival_time) that the reference query omits. Both correctly join users, vehicles, and trips tables with the same WHERE condition (v.is_electric = true). The generated query better fulfills the business intent by providing more comprehensive trip details (time information) which is part of 'trip details' in the original question. The reference query is correct but less complete. Both are efficient and well-structured, but the generated query's additional fields make it more aligned with the request for 'trip details'.", "overall_assessment": "differently_correct"}}
{"example_id": 2531, "sql_complexity": "basic SQL", "prompt": "Who is the top customer by sales in 2022?", "context": "CREATE TABLE customers (customer_id INT, total_sales_2022 FLOAT); INSERT INTO customers (customer_id, total_sales_2022) VALUES (1, 25000.0), (2, 30000.0), (3, 22000.0), (4, 35000.0);", "reference_sql": "SELECT customer_id, total_sales_2022 FROM customers ORDER BY total_sales_2022 DESC LIMIT 1;", "generated_sql": "SELECT customers.customer_id FROM customers WHERE customers.total_sales_2022 = (SELECT MAX(customers.total_sales_2022) FROM customers);", "raw_model_output": " Code\nSELECT customers.customer_id FROM customers WHERE customers.total_sales_2022 = (SELECT MAX(customers.total_sales_2022) FROM customers);", "latency_sec": 0.5877549648284912, "total_duration_sec": 0.493853061, "load_duration_sec": 0.008712614, "tokens_prompt": 124, "prompt_eval_sec": 0.009290381, "tokens_completion": 44, "completion_eval_sec": 0.475137165, "tokens_total": 168, "tokens_per_sec": 285.8334000615766, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The reference query returns both customer_id and total_sales_2022 columns, sorted in descending order with a LIMIT 1, while the generated query only returns customer_id and uses a subquery to find the maximum sales value. Although both identify the customer with the highest sales, the generated query omits the total_sales_2022 column and may return multiple customers if there are ties, whereas the reference query explicitly limits to one row.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "While both queries aim to find the top customer by sales, they differ in behavior. The reference query (ORDER BY + LIMIT 1) returns exactly one customer (the first in sorted order) even if multiple customers have the same maximum sales. The generated query (subquery with MAX) returns all customers tied for the maximum sales. In the provided context, both return the same result (customer 4 with 35000.0), but the reference query is more efficient for single-result scenarios. The generated query is technically more precise for cases with ties but may not align with the business intent of selecting 'the' top customer (implying a single entity). The reference query better fulfills the original question's intent.", "overall_assessment": "differently_correct"}}
{"example_id": 3792, "sql_complexity": "single join", "prompt": "What is the maximum distance traveled by an electric vehicle in a single trip, grouped by vehicle model?", "context": "CREATE TABLE Trips (trip_id INT, vehicle_id INT, distance FLOAT); CREATE TABLE ElectricVehicleModels (vehicle_id INT, vehicle_model TEXT);", "reference_sql": "SELECT evm.vehicle_model, MAX(trips.distance) AS max_distance_traveled FROM Trips trips INNER JOIN ElectricVehicleModels evm ON trips.vehicle_id = evm.vehicle_id GROUP BY 1;", "generated_sql": "SELECT MAX(trip_id) FROM Trips WHERE vehicle_id IN (SELECT vehicle_id FROM ElectricVehicleModels));", "raw_model_output": " Code\n<s> #_of_trips = (SELECT MAX(trip_id) FROM Trips WHERE vehicle_id IN (SELECT vehicle_id FROM ElectricVehicleModels));", "latency_sec": 0.6456809043884277, "total_duration_sec": 0.436093894, "load_duration_sec": 0.012099471, "tokens_prompt": 79, "prompt_eval_sec": 0.00984897, "tokens_completion": 39, "completion_eval_sec": 0.412452129, "tokens_total": 118, "tokens_per_sec": 182.75281055704528, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query groups trips by vehicle model and returns the maximum distance traveled per model, while the generated query returns the maximum trip_id for vehicles in ElectricVehicleModels. The output structures and semantics differ: the first has (vehicle_model, max_distance) rows, the second is a single value (max trip_id).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly joins Trips with ElectricVehicleModels, groups by vehicle_model, and calculates MAX(distance) to answer the question. The generated query incorrectly uses MAX(trip_id) instead of distance, ignores grouping by model, and focuses on trip_id rather than distance traveled. While the generated query identifies electric vehicles via the subquery, it fails to address the core requirement of measuring distance per model. The reference query is both technically correct and semantically aligned with the business intent.", "overall_assessment": "incorrect"}}
{"example_id": 2311, "sql_complexity": "subqueries", "prompt": "Determine the percentage of sales from each ingredient category", "context": "CREATE TABLE Sales_Details (sale_id INT, ingredient_id INT, quantity INT); INSERT INTO Sales_Details (sale_id, ingredient_id, quantity) VALUES (1, 1, 2), (1, 2, 8), (2, 1, 3), (2, 2, 7); CREATE TABLE Ingredient_Categories (ingredient_id INT, ingredient_category VARCHAR(255)); INSERT INTO Ingredient_Categories (ingredient_id, ingredient_category) VALUES (1, 'Legumes'), (2, 'Poultry');", "reference_sql": "SELECT ingredient_category, SUM(quantity) AS total_quantity, SUM(quantity) * 100.0 / (SELECT SUM(quantity) FROM Sales_Details) AS percentage_of_sales FROM Sales_Details, Ingredient_Categories WHERE Sales_Details.ingredient_id = Ingredient_Categories.ingredient_id GROUP BY ingredient_category;", "generated_sql": "SELECT i.ingredient_category, SUM(s.quantity) AS total_quantity_sold, round((SUM(s.quantity) / NULLIF((SELECT SUM(quantity) FROM Sales_Details), 0)) * 100, 2) AS percentage_of_total_sales FROM Sales_Details s JOIN Ingredient_Categories i ON s.ingredpoint_id = i.ingredpoint_id GROUP BY i.ingredpoint_category;", "raw_model_output": " Code\n<s> SELECT i.ingredient_category, SUM(s.quantity) AS total_quantity_sold, round((SUM(s.quantity) / NULLIF((SELECT SUM(quantity) FROM Sales_Details), 0)) * 100, 2) AS percentage_of_total_sales FROM Sales_Details s JOIN Ingredient_Categories i ON s.ingredpoint_id = i.ingredpoint_id GROUP BY i.ingredpoint_category;", "latency_sec": 1.6520371437072754, "total_duration_sec": 1.334810722, "load_duration_sec": 0.008575705, "tokens_prompt": 177, "prompt_eval_sec": 0.01484244, "tokens_completion": 120, "completion_eval_sec": 1.310556875, "tokens_total": 297, "tokens_per_sec": 179.77804017984323, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Generated SQL contains a critical typo in the JOIN condition (using 'ingredpoint_id' instead of 'ingredient_id'), which would cause a syntax error or incorrect results. Additionally, the Generated SQL uses 'round()' for percentage formatting and different column aliases, but the primary issue is the invalid JOIN condition.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query is technically correct and fulfills the business intent. It properly joins Sales_Details with Ingredient_Categories using explicit JOIN logic (though using implicit join syntax), calculates total quantities per category, and computes percentages using a correlated subquery for total sales. The generated query contains critical errors: 1) Typo in column names ('ingredpoint_id' instead of 'ingredient_id') causing join failure, 2) Typo in GROUP BY clause ('ingredpoint_category' instead of 'ingredient_category'), 3) Missing table aliases in the subquery. While the generated query attempts to handle division by zero with NULLIF, its syntax errors prevent it from executing correctly. The reference query's logic is mathematically sound and would produce accurate percentage calculations.", "overall_assessment": "incorrect"}}
{"example_id": 3329, "sql_complexity": "set operations", "prompt": "Which causes received funding from donors in both the United States and Canada?", "context": "CREATE TABLE donor_location (donor_id INT, country VARCHAR(50), cause VARCHAR(50), donation DECIMAL(10,2)); INSERT INTO donor_location (donor_id, country, cause, donation) VALUES (1, 'United States', 'Global Health', 1000.00), (2, 'Canada', 'Education', 2000.00), (3, 'United States', 'Environment', 1500.00), (4, 'Canada', 'Animal Welfare', 2500.00);", "reference_sql": "SELECT cause FROM donor_location WHERE country = 'United States' INTERSECT SELECT cause FROM donor_location WHERE country = 'Canada';", "generated_sql": "SELECT cause FROM donor_location WHERE country IN ('United States', 'Canada') GROUP BY cause HAVING COUNT(DISTINCT donor_id) > 1;", "raw_model_output": " Code\n<s> SELECT cause FROM donor_location WHERE country IN ('United States', 'Canada') GROUP BY cause HAVING COUNT(DISTINCT donor_id) > 1;", "latency_sec": 0.7825741767883301, "total_duration_sec": 0.556254317, "load_duration_sec": 0.010102428, "tokens_prompt": 179, "prompt_eval_sec": 0.013788602, "tokens_completion": 48, "completion_eval_sec": 0.531528403, "tokens_total": 227, "tokens_per_sec": 290.06834972705565, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query finds causes present in both 'United States' and 'Canada' using INTERSECT, while the generated query identifies causes with more than one distinct donor across both countries. The generated query could include causes appearing multiple times in a single country, which the reference query would exclude.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The Reference SQL correctly identifies causes present in both countries using INTERSECT, ensuring semantic alignment with the business question. The Generated SQL incorrectly uses COUNT(DISTINCT donor_id) > 1, which would exclude cases where a single donor contributed to both countries (e.g., one donor giving to the same cause in both nations). While both queries might return identical results in the sample data (no overlapping causes), the Reference SQL is technically and semantically precise for the question. The Generated SQL's logic is flawed as it focuses on donor count rather than country presence.", "overall_assessment": "correct"}}
{"example_id": 2912, "sql_complexity": "single join", "prompt": "Which company has manufactured the most satellites?", "context": "CREATE TABLE manufacturers (id INT, name TEXT); CREATE TABLE satellites (id INT, manufacturer_id INT, name TEXT, launch_date DATE); INSERT INTO manufacturers (id, name) VALUES (1, 'SpaceX'), (2, 'Blue Origin'), (3, 'ISRO'), (4, 'CAST'); INSERT INTO satellites (id, manufacturer_id, name, launch_date) VALUES (1, 1, 'StarDragon', '2012-05-25'), (2, 1, 'Falcon', '2015-12-21'), (3, 2, 'New Glenn', '2022-01-11'), (4, 3, 'ChinaSat 1E', '2000-12-05'), (5, 3, 'ChinaSat 2A', '2003-08-13'), (6, 4, 'Shijian 9', '2017-11-19'), (7, 1, 'StarLink', '2020-05-24'), (8, 1, 'StarLink', '2020-06-13');", "reference_sql": "SELECT m.name, COUNT(s.id) FROM manufacturers m JOIN satellites s ON m.id = s.manufacturer_id GROUP BY m.name ORDER BY COUNT(s.id) DESC;", "generated_sql": "SELECT manufacturers.name FROM manufacturers JOIN satellites ON manufacturers.id = satellites.manufacturer_id GROUP BY manufacturers.name ORDER BY COUNT(satellites.id) DESC LIMIT 1;", "raw_model_output": " Code\n<s> SELECT manufacturers.name FROM manufacturers JOIN satellites ON manufacturers.id = satellites.manufacturer_id GROUP BY manufacturers.name ORDER BY COUNT(satellites.id) DESC LIMIT 1;", "latency_sec": 0.8588800430297852, "total_duration_sec": 0.654677323, "load_duration_sec": 0.008536713, "tokens_prompt": 314, "prompt_eval_sec": 0.023636659, "tokens_completion": 53, "completion_eval_sec": 0.621738218, "tokens_total": 367, "tokens_per_sec": 427.30064923312324, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns all manufacturers with their satellite counts sorted descending, while the Generated SQL only returns the top manufacturer (due to LIMIT 1). The presence of LIMIT 1 in the Generated query restricts the result to a single row, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify the manufacturer with the most satellites by joining manufacturers and satellites tables, grouping by manufacturer, and ordering by count. The reference query returns all manufacturers ordered by count (requires manual inspection of the top row), while the generated query directly retrieves only the top result using LIMIT 1. The generated query is more efficient as it avoids unnecessary data processing and explicitly returns the desired single answer. Both satisfy the business intent, but the generated query is more elegant and efficient.", "overall_assessment": "correct"}}
{"example_id": 3170, "sql_complexity": "aggregation", "prompt": "Determine the total production quantity of silver for mining sites in Mexico, between the dates '2017-05-01' and '2017-09-30', having less than 40 employees.", "context": "CREATE TABLE silver_mine_2 (site_id INT, country VARCHAR(50), num_employees INT, extraction_date DATE, quantity INT); INSERT INTO silver_mine_2 (site_id, country, num_employees, extraction_date, quantity) VALUES (1, 'Mexico', 35, '2017-05-02', 1200), (2, 'Mexico', 30, '2017-08-31', 1800), (3, 'Mexico', 37, '2017-07-04', 2200);", "reference_sql": "SELECT country, SUM(quantity) as total_silver_prod FROM silver_mine_2 WHERE num_employees < 40 AND country = 'Mexico' AND extraction_date >= '2017-05-01' AND extraction_date <= '2017-09-30' GROUP BY country;", "generated_sql": "SELECT SUM(quantity) AS total_production FROM silver_mine_2 WHERE country = 'Mexico' AND extraction_date BETWEEN '2017-05-01' AND '2017-09-30' AND num_employees < 40;", "raw_model_output": " Code\n<s> SELECT SUM(quantity) AS total_production FROM silver_mine_2 WHERE country = 'Mexico' AND extraction_date BETWEEN '2017-05-01' AND '2017-09-30' AND num_employees < 40;", "latency_sec": 0.9532487392425537, "total_duration_sec": 0.85583015, "load_duration_sec": 0.008890117, "tokens_prompt": 226, "prompt_eval_sec": 0.015389204, "tokens_completion": 75, "completion_eval_sec": 0.830739554, "tokens_total": 301, "tokens_per_sec": 315.76228491964537, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of quantities for Mexican silver mines with fewer than 40 employees and extraction dates between 2017-05-01 and 2017-09-30. The Reference SQL includes an unnecessary GROUP BY country (which only contains 'Mexico' due to the WHERE clause) and uses explicit >=/<= operators, while the Generated SQL uses BETWEEN and omits the GROUP BY. The final result set (a single row with the total) is identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly filter for Mexican silver mines with <40 employees between the specified dates. The reference query includes redundant GROUP BY country (since country is fixed to 'Mexico') and returns an extra column, while the generated query directly computes the total without unnecessary elements. Both produce the same numerical result (1200+1800+2200=5200), but the generated query is more efficient and directly addresses the business intent of retrieving a single total value.", "overall_assessment": "correct"}}
{"example_id": 3518, "sql_complexity": "basic SQL", "prompt": "Insert new records of ticket sales for a new event, including event and salesperson information.", "context": "CREATE TABLE salesperson (salesperson_id INT, name VARCHAR(50), position VARCHAR(50)); CREATE TABLE tickets (ticket_id INT, salesperson_id INT, event_id INT, price DECIMAL(5,2), quantity INT); CREATE TABLE events (event_id INT, name VARCHAR(50), date DATE); INSERT INTO salesperson VALUES (1, 'John Doe', 'Senior Salesperson'); INSERT INTO events VALUES (2, 'New Event', '2023-04-15');", "reference_sql": "INSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity) VALUES (2, 1, 2, 75, 50), (3, 2, 2, 65, 75); INSERT INTO events (event_id, name, date) VALUES (2, 'New Event', '2023-04-15');", "generated_sql": "SELECT 10001, 1, 3, 100.00, 10;", "raw_model_output": " Code\n<s> CREATE TABLE tickets (ticket_id INT, salesperson_id INT, event_id INT, price DECIMAL(5,2), quantity INT) AS SELECT 10001, 1, 3, 100.00, 10;", "latency_sec": 0.8310518264770508, "total_duration_sec": 0.762317343, "load_duration_sec": 0.008375857, "tokens_prompt": 170, "prompt_eval_sec": 0.013954831, "tokens_completion": 68, "completion_eval_sec": 0.739159142, "tokens_total": 238, "tokens_per_sec": 286.3840646484305, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL contains INSERT statements that add data to the 'tickets' and 'events' tables, while the Generated SQL is a SELECT query that retrieves a single row of values. INSERT and SELECT operations are fundamentally different in purpose and effect: INSERT modifies database content whereas SELECT queries data. The generated query does not produce the same result as the reference query.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL attempts to insert ticket sales data and event information, aligning with the business intent. However, it redundantly inserts an existing event (event_id=2) that was already added in the context, which could cause a primary key violation. The Generated SQL is a SELECT statement that does not perform any insertion, failing to address the requirement. While the Reference has a minor flaw with the event insertion, it at least attempts to fulfill the business intent, whereas the Generated SQL completely misses the mark.", "overall_assessment": "differently_correct"}}
{"example_id": 3925, "sql_complexity": "set operations", "prompt": "What is the total number of students and staff with accommodations in the \"disability_services\" schema, excluding the \"accessibility_parking\" type?", "context": "CREATE SCHEMA disability_services; CREATE TABLE staff (id INT, name VARCHAR(50), accommodation VARCHAR(50)); CREATE TABLE students (id INT, name VARCHAR(50), accommodation VARCHAR(50));", "reference_sql": "SELECT COUNT(*) FROM disability_services.staff WHERE accommodation != 'accessibility_parking' UNION SELECT COUNT(*) FROM disability_services.students WHERE accommodation != 'accessibility_parking';", "generated_sql": "SELECT COUNT(*) FROM disability_services.students WHERE accommodation != 'accessibility_parking') + (SELECT COUNT(*) FROM disability_services.staff WHERE accommodation != 'accessibility_parking');", "raw_model_output": " Code\n<s> #_of_students_and_staff = (SELECT COUNT(*) FROM disability_services.students WHERE accommodation != 'accessibility_parking') + (SELECT COUNT(*) FROM disability_services.staff WHERE accommodation != 'accessibility_parking');", "latency_sec": 0.7657577991485596, "total_duration_sec": 0.670736555, "load_duration_sec": 0.008712973, "tokens_prompt": 105, "prompt_eval_sec": 0.00723875, "tokens_completion": 61, "completion_eval_sec": 0.65424799, "tokens_total": 166, "tokens_per_sec": 216.77872583808374, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses UNION to combine two separate counts (staff and students) into a two-row result set, while the Generated SQL sums the counts into a single numeric value. The output structure differs: the first returns multiple rows with individual counts, the second returns a single row with the total. Semantically, they produce different result formats.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query uses UNION to combine two separate counts, resulting in two rows of output (e.g., [120, 80]) rather than a single total. The generated query correctly uses arithmetic addition to produce a single numeric result. Both queries exclude 'accessibility_parking' properly, but only the generated query satisfies the business requirement for a combined total. The generated query is also more efficient as it avoids the overhead of UNION and returns a single value.", "overall_assessment": "differently_correct"}}
{"example_id": 3340, "sql_complexity": "subqueries", "prompt": "Calculate the total revenue for garments manufactured in the US and sold in California.", "context": "CREATE TABLE garment_manufacturing(id INT PRIMARY KEY, garment_id INT, country VARCHAR(50), material VARCHAR(50), manufacturing_date DATE, quantity INT); CREATE TABLE garment_sales(id INT PRIMARY KEY, garment_id INT, store_id INT, sale_date DATE, units INT, revenue DECIMAL(10,2));", "reference_sql": "SELECT SUM(gs.revenue) FROM garment_manufacturing gm JOIN garment_sales gs ON gm.garment_id = gs.garment_id WHERE gm.country = 'United States' AND gs.store_id IN (SELECT id FROM stores WHERE region = 'California');", "generated_sql": "Code\n<s> # of lines: 5\n number of bytes: 376", "raw_model_output": " Code\n<s> # of lines: 5\n number of bytes: 376", "latency_sec": 0.4328467845916748, "total_duration_sec": 0.232338382, "load_duration_sec": 0.009360552, "tokens_prompt": 127, "prompt_eval_sec": 0.009725153, "tokens_completion": 19, "completion_eval_sec": 0.212599471, "tokens_total": 146, "tokens_per_sec": 337.3018010003905, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Generated SQL is not provided in the input, making it impossible to compare with the Reference SQL. Without the actual query text, semantic equivalence cannot be determined.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference SQL is incomplete because it references a 'stores' table that does not exist in the provided schema. The generated SQL is missing entirely, making it impossible to evaluate. The original question requires filtering garments manufactured in the US (using garment_manufacturing.country) and sold in California (which would require a stores table with region information). Since the reference query incorrectly assumes a 'stores' table exists, it would fail due to a missing table. The generated SQL's absence prevents any comparison.", "overall_assessment": "incorrect"}}
{"example_id": 596, "sql_complexity": "basic SQL", "prompt": "What is the minimum energy production cost of wind farms in Spain?", "context": "CREATE TABLE wind_farm_costs (id INT, name TEXT, country TEXT, energy_production_cost FLOAT); INSERT INTO wind_farm_costs (id, name, country, energy_production_cost) VALUES (1, 'Las Tiesas', 'Spain', 0.045), (2, 'Eolo', 'Spain', 0.050);", "reference_sql": "SELECT MIN(energy_production_cost) FROM wind_farm_costs WHERE country = 'Spain';", "generated_sql": "SELECT MIN(energy_production_cost) AS min_cost FROM wind_farm_costs WHERE country = 'Spain';", "raw_model_output": " code to solve problem\nSELECT MIN(energy_production_cost) AS min_cost FROM wind_farm_costs WHERE country = 'Spain';", "latency_sec": 1.3103258609771729, "total_duration_sec": 0.389028073, "load_duration_sec": 0.010088377, "tokens_prompt": 124, "prompt_eval_sec": 0.00981847, "tokens_completion": 34, "completion_eval_sec": 0.368383605, "tokens_total": 158, "tokens_per_sec": 120.58069271575837, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the minimum energy_production_cost for wind farms in Spain. The generated query adds an alias (min_cost) to the result column, but this does not affect the semantic value of the output. The core logic (aggregation and filter) remains identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly retrieve the minimum energy production cost for wind farms in Spain. The reference query returns the raw minimum value, while the generated query adds an alias ('min_cost') for clarity. Since the original question does not require a column name, both produce identical results. The generated query is slightly more readable due to the alias, but neither is technically superior. Both fulfill the business intent of identifying the minimum cost.", "overall_assessment": "correct"}}
{"example_id": 2604, "sql_complexity": "subqueries", "prompt": "What is the maximum number of virtual tours taken by a single user in the UK?", "context": "CREATE TABLE virtual_tour_data (user_id INT, hotel_id INT, tour_date DATE); INSERT INTO virtual_tour_data (user_id, hotel_id, tour_date) VALUES (1, 10, '2022-01-01'), (2, 11, '2022-01-03'), (3, 12, '2022-01-05'), (4, 10, '2022-01-07'), (5, 10, '2022-01-09'); CREATE TABLE hotels (hotel_id INT, hotel_name TEXT, country TEXT); INSERT INTO hotels (hotel_id, hotel_name, country) VALUES (10, 'Royal Park Hotel', 'UK'), (11, 'The Ritz London', 'UK'), (12, 'Hotel de Crillon', 'France');", "reference_sql": "SELECT MAX(vt.user_tours) FROM (SELECT user_id, COUNT(DISTINCT hotel_id) as user_tours FROM virtual_tour_data WHERE country = 'UK' GROUP BY user_id) as vt;", "generated_sql": "SELECT MAX(user_id) AS max_virtual_tours FROM virtual_tour_data WHERE country = 'uk';", "raw_model_output": " Code\n<s> SELECT MAX(user_id) AS max_virtual_tours FROM virtual_tour_data WHERE country = 'uk';", "latency_sec": 0.7075178623199463, "total_duration_sec": 0.406367742, "load_duration_sec": 0.010178802, "tokens_prompt": 261, "prompt_eval_sec": 0.01467425, "tokens_completion": 32, "completion_eval_sec": 0.380545237, "tokens_total": 293, "tokens_per_sec": 414.1238201948075, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates the maximum number of distinct hotels toured by any user in the UK, while the Generated SQL incorrectly returns the maximum user_id where the country is 'uk' (case-sensitive). Additionally, the Generated SQL lacks the grouping and counting logic present in the Reference SQL.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly calculates the maximum number of virtual tours per user by first grouping by user_id, counting distinct hotel_id values (representing unique tours), and then selecting the maximum value. The generated query is fundamentally flawed: it selects MAX(user_id) which returns the highest user ID rather than counting tours, and incorrectly references 'country = 'uk'' (lowercase) when the schema uses 'UK'. The generated query neither addresses the business intent nor produces valid results.", "overall_assessment": "incorrect"}}
{"example_id": 5812, "sql_complexity": "single join", "prompt": "Calculate the percentage of Shariah-compliant investments held by each investor in the top 5 countries with the highest percentage?", "context": "CREATE TABLE investors (investor_id INT, investor_name TEXT, country TEXT); INSERT INTO investors (investor_id, investor_name, country) VALUES (1, 'Al Thani', 'Qatar'), (2, 'Saudi Investment Group', 'Saudi Arabia'), (3, 'Temasek Holdings', 'Singapore'); CREATE TABLE investments (investment_id INT, investor_id INT, investment_type TEXT, investment_value DECIMAL, is_shariah_compliant BOOLEAN); INSERT INTO investments (investment_id, investor_id, investment_type, investment_value, is_shariah_compliant) VALUES (1, 1, 'Real Estate', 15000000, true), (2, 2, 'Stocks', 20000000, false);", "reference_sql": "SELECT investor_name, ROUND((SUM(CASE WHEN is_shariah_compliant THEN investment_value ELSE 0 END) / SUM(investment_value)) * 100, 2) AS percentage FROM investments JOIN investors ON investments.investor_id = investors.investor_id GROUP BY investor_name ORDER BY percentage DESC LIMIT 5;", "generated_sql": "SELECT i.investor_name, c.country_name, CAST(SUM(CASE WHEN i.is_shariah_compliant THEN 1 ELSE 0 END) AS FLOAT) / NULLIF(COUNT(*), 0) AS proportion_compliant FROM investors i JOIN countries c ON i.country = c.country_name GROUP BY i.investor_name, c.country_name HAVING CAST(SUM(CASE WHEN i.is_shariah_compliant THEN 1 ELSE 0 END) AS FLOAT) / NULLIF(COUNT(*), 0) > 0.5 ORDER BY proportion_compliant DESC LIMIT 5;", "raw_model_output": " Code\n<s> SELECT i.investor_name, c.country_name, CAST(SUM(CASE WHEN i.is_shariah_compliant THEN 1 ELSE 0 END) AS FLOAT) / NULLIF(COUNT(*), 0) AS proportion_compliant FROM investors i JOIN countries c ON i.country = c.country_name GROUP BY i.investor_name, c.country_name HAVING CAST(SUM(CASE WHEN i.is_shariah_compliant THEN 1 ELSE 0 END) AS FLOAT) / NULLIF(COUNT(*), 0) > 0.5 ORDER BY proportion_compliant DESC LIMIT 5;", "latency_sec": 2.0176119804382324, "total_duration_sec": 1.921488536, "load_duration_sec": 0.008166417, "tokens_prompt": 259, "prompt_eval_sec": 0.015142175, "tokens_completion": 172, "completion_eval_sec": 1.897353568, "tokens_total": 431, "tokens_per_sec": 213.61887428245012, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates the percentage of investment value that is shariah-compliant, while the Generated SQL calculates the proportion of compliant investments (count-based) and incorrectly joins with a 'countries' table (not in the original schema). Additionally, the Generated SQL includes a HAVING clause filtering for >50% compliance and groups by country_name, which the Reference SQL does not.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query is technically correct in its structure and calculation logic, using SUM with CASE to calculate the percentage of Shariah-compliant investments by value. However, it groups by investor_name rather than country, which fails to address the 'top 5 countries' requirement. The generated query has multiple issues: it references a non-existent 'countries' table, uses COUNT(*) instead of SUM(investment_value) for percentage calculation (incorrectly counting investments instead of values), and includes a HAVING clause that filters for proportions >0.5, which is not part of the original question. While the generated query attempts to incorporate country data, its technical errors and incorrect logic make it invalid. The reference query, though incomplete in addressing countries, is more aligned with the business intent of calculating investment percentages.", "overall_assessment": "differently_correct"}}
{"example_id": 4706, "sql_complexity": "multiple_joins", "prompt": "Who are the top 3 customers by total spend on makeup products from Italy and Spain?", "context": "CREATE TABLE customers (customer_id INT, customer_name TEXT, country TEXT); INSERT INTO customers (customer_id, customer_name, country) VALUES (1, 'Alessandro Martini', 'IT'), (2, 'Laura Rossi', 'ES'), (3, 'Daniela Gonzalez', 'MX'), (4, 'Jose Hernandez', 'ES'), (5, 'Sophia Rodriguez', 'IT'); CREATE TABLE sales (sale_id INT, customer_id INT, product_id INT, sale_quantity INT, sale_country TEXT); INSERT INTO sales (sale_id, customer_id, product_id, sale_quantity, sale_country) VALUES (1, 1, 1, 100, 'IT'), (2, 2, 2, 150, 'ES'), (3, 3, 3, 200, 'MX'), (4, 4, 4, 250, 'ES'), (5, 5, 5, 300, 'IT'); CREATE TABLE products (product_id INT, product_name TEXT, category TEXT); INSERT INTO products (product_id, product_name, category) VALUES (1, 'Eyeshadow Palette', 'makeup'), (2, 'Liquid Lipstick', 'makeup'), (3, 'BB Cream', 'makeup'), (4, 'Volumizing Mascara', 'makeup'), (5, 'Nourishing Lip Balm', 'makeup');", "reference_sql": "SELECT c.customer_name, SUM(s.sale_quantity) as total_spent_on_makeup FROM sales s JOIN customers c ON s.customer_id = c.customer_id JOIN products p ON s.product_id = p.product_id WHERE c.country IN ('IT', 'ES') AND p.category = 'makeup' GROUP BY c.customer_name ORDER BY total_spent_on_makeup DESC LIMIT 3;", "generated_sql": "SELECT c.customer_name, SUM(s.sale_quantity) AS total_spend FROM sales s JOIN customers c ON s.customer_id = c.customer_id WHERE sale_country IN ('it', 'ES') AND product_category = 'makeup' GROUP BY c.customer_name ORDER BY total_spend DESC NULLS LAST LIMIT 3;", "raw_model_output": " Code\n<s> SELECT c.customer_name, SUM(s.sale_quantity) AS total_spend FROM sales s JOIN customers c ON s.customer_id = c.customer_id WHERE sale_country IN ('it', 'ES') AND product_category = 'makeup' GROUP BY c.customer_name ORDER BY total_spend DESC NULLS LAST LIMIT 3;", "latency_sec": 1.4094469547271729, "total_duration_sec": 1.127053819, "load_duration_sec": 0.009103562, "tokens_prompt": 396, "prompt_eval_sec": 0.028924179, "tokens_completion": 93, "completion_eval_sec": 1.08802308, "tokens_total": 489, "tokens_per_sec": 346.9445929553666, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in several key aspects. 1) The Generated SQL lacks a join with the products table, which is necessary to access the 'category' column. 2) The Generated SQL incorrectly references 'product_category' (a non-existent column) instead of 'p.category'. 3) The 'sale_country' condition in the Generated SQL uses lowercase 'it' which won't match the uppercase 'IT' values in the data. These differences will result in different query results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL is technically correct and semantically aligned with the business intent. It properly joins all three tables (customers, sales, products), filters customers from Italy (IT) and Spain (ES) using the customers.country column, and ensures only makeup products are considered via products.category. The Generated SQL has multiple issues: 1) It references 'product_category' which doesn't exist in the sales table (should join with products.category instead), 2) It uses 'sale_country' which refers to the sale's country rather than the customer's country (misaligns with the question's focus on customer origin), 3) It lacks the products table join entirely. While both queries aim to rank customers by makeup spend, the Generated SQL's structural errors and misaligned filters prevent it from fulfilling the business intent correctly.", "overall_assessment": "incorrect"}}
{"example_id": 1515, "sql_complexity": "multiple_joins", "prompt": "What is the average age of clients who lost cases in the 'personal injury' category?", "context": "CREATE TABLE Cases (CaseID int, ClientID int, Category varchar(50)); INSERT INTO Cases (CaseID, ClientID, Category) VALUES (701, 7, 'Personal Injury'); CREATE TABLE Clients (ClientID int, Age int, Gender varchar(10)); INSERT INTO Clients (ClientID, Age, Gender) VALUES (7, 45, 'Male'); CREATE TABLE CaseOutcomes (CaseID int, Outcome varchar(50)); INSERT INTO CaseOutcomes (CaseID, Outcome) VALUES (701, 'Lost');", "reference_sql": "SELECT AVG(C.Age) as AvgAge FROM Clients C INNER JOIN Cases CA ON C.ClientID = CA.ClientID INNER JOIN CaseOutcomes CO ON CA.CaseID = CO.CaseID WHERE CA.Category = 'Personal Injury' AND CO.Outcome = 'Lost';", "generated_sql": "SELECT AVG(Clients.Age) FROM Cases JOIN Clients ON Cases.ClientID = Clients.ClientID WHERE Cases.Category = 'Personal Injury' AND CaseOutcomes.Outcome = 'Lost';", "raw_model_output": " Code\n<s> SELECT AVG(Clients.Age) FROM Cases JOIN Clients ON Cases.ClientID = Clients.ClientID WHERE Cases.Category = 'Personal Injury' AND CaseOutcomes.Outcome = 'Lost';", "latency_sec": 0.9075429439544678, "total_duration_sec": 0.673339516, "load_duration_sec": 0.009048927, "tokens_prompt": 185, "prompt_eval_sec": 0.012201594, "tokens_completion": 59, "completion_eval_sec": 0.651345974, "tokens_total": 244, "tokens_per_sec": 268.8578007524476, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Generated SQL is missing a required JOIN with the CaseOutcomes table. The Reference SQL explicitly joins Cases, Clients, and CaseOutcomes tables, while the Generated SQL only joins Cases and Clients. The WHERE clause in the Generated SQL references CaseOutcomes.Outcome, which is unavailable without the corresponding JOIN. This makes the Generated SQL invalid and semantically different from the Reference SQL.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly joins all three tables (Clients, Cases, CaseOutcomes) and properly filters on both 'Personal Injury' category and 'Lost' outcome. The Generated SQL missing the CaseOutcomes table join, which is critical to filter on the outcome. While both queries attempt to calculate the average age, the Generated SQL would fail due to an invalid reference to CaseOutcomes.Outcome without a corresponding JOIN. The Reference SQL is technically correct, semantically accurate, and fulfills the business intent. The Generated SQL is incomplete and would produce an error.", "overall_assessment": "incorrect"}}
{"example_id": 4388, "sql_complexity": "subqueries", "prompt": "Insert a new drug with a price 10% higher than the average price", "context": "CREATE TABLE drugs (drug_id INT, drug_name VARCHAR(50), price DECIMAL(10, 2)); INSERT INTO drugs (drug_id, drug_name, price) VALUES (1, 'DrugA', 50), (2, 'DrugB', 75), (3, 'DrugC', 100)", "reference_sql": "INSERT INTO drugs (drug_id, drug_name, price) VALUES ((SELECT MAX(drug_id) FROM drugs) + 1, 'DrugD', (SELECT AVG(price) * 1.1 FROM drugs))", "generated_sql": "INSERT INTO drugs (drug_id, drug_name, price) VALUES ((SELECT MAX(drug_id)+1 FROM drugs), 'DrugD', (SELECT number * 1.10 FROM generate_series(1, (SELECT COUNT(*) FROM drugs)) AS num) * AVG(price));", "raw_model_output": " code to solve the question\n<s> #_avg = AVG(price) FROM drugs; INSERT INTO drugs (drug_id, drug_name, price) VALUES ((SELECT MAX(drug_id)+1 FROM drugs), 'DrugD', (SELECT number * 1.10 FROM generate_series(1, (SELECT COUNT(*) FROM drugs)) AS num) * AVG(price));", "latency_sec": 1.0904266834259033, "total_duration_sec": 0.996260612, "load_duration_sec": 0.008600575, "tokens_prompt": 121, "prompt_eval_sec": 0.008505279, "tokens_completion": 92, "completion_eval_sec": 0.97846516, "tokens_total": 213, "tokens_per_sec": 195.33637908675937, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates the price as AVG(price) * 1.1, while the Generated SQL attempts to use a generate_series subquery that returns multiple rows, leading to a syntax error. The Generated SQL's price calculation is invalid and would not produce the same result as the Reference SQL.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query correctly calculates the average price using (SELECT AVG(price) * 1.1 FROM drugs) and assigns it to the new drug. The generated query contains multiple critical issues: 1) The generate_series function creates a set of numbers that would cause the subquery to return multiple rows, violating the single value requirement for the price column. 2) The expression (SELECT number * 1.10 FROM generate_series...) * AVG(price) incorrectly combines a set of values with a scalar average. 3) The generated query would fail with a 'subquery returns more than one row' error. While both queries attempt to create a new drug with a 10% higher price, only the reference query technically and semantically fulfills the business intent.", "overall_assessment": "differently_correct"}}
{"example_id": 5431, "sql_complexity": "basic SQL", "prompt": "What is the average CO2 emission of ride-hailing vehicles in San Francisco?", "context": "CREATE TABLE SFRideHailing (id INT, company VARCHAR(20), co2_emission DECIMAL(5,2));", "reference_sql": "SELECT AVG(co2_emission) FROM SFRideHailing WHERE company = 'Uber';", "generated_sql": "SELECT AVG(SFRidehailing.co2_emission) AS average_co2_emission FROM SFRidehailing WHERE SFRidehailing.company = 'San Francisco';", "raw_model_output": " Code\nSELECT AVG(SFRidehailing.co2_emission) AS average_co2_emission FROM SFRidehailing WHERE SFRidehailing.company = 'San Francisco';", "latency_sec": 0.7983958721160889, "total_duration_sec": 0.497277636, "load_duration_sec": 0.007528407, "tokens_prompt": 66, "prompt_eval_sec": 0.007283986, "tokens_completion": 46, "completion_eval_sec": 0.481582462, "tokens_total": 112, "tokens_per_sec": 140.28128640388925, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query filters for 'Uber' company, while the generated query filters for 'San Francisco' company. The WHERE clause conditions differ, leading to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent. The reference query correctly calculates the average CO2 emission for Uber vehicles (assuming 'Uber' is a valid company value), while the generated query incorrectly filters for 'San Francisco' as a company name (which is likely a city, not a company). The original question asks for ride-hailing vehicles in San Francisco, but neither query properly addresses this: the reference focuses on a single company, and the generated query uses invalid logic (filtering by city as a company). The reference query is more aligned with typical schema design (companies like Uber/Lyft) but still fails to account for all San Francisco vehicles. The generated query's WHERE clause is fundamentally flawed.", "overall_assessment": "incorrect"}}
{"example_id": 3531, "sql_complexity": "single join", "prompt": "What is the total number of workouts and total workout time per user for users with a membership type of 'Basic'?", "context": "CREATE TABLE Members (id INT, user_name VARCHAR, membership_type VARCHAR, signup_date DATE); CREATE TABLE Workouts (id INT, user_id INT, workout_date DATE, workout_duration INT); INSERT INTO Members (id, user_name, membership_type, signup_date) VALUES (1, 'John Doe', 'Premium', '2020-01-01'), (2, 'Jane Smith', 'Basic', '2019-06-15'), (3, 'Alice Johnson', 'Premium', '2020-03-20'); INSERT INTO Workouts (id, user_id, workout_date, workout_duration) VALUES (1, 1, '2020-01-01', 60), (2, 1, '2020-01-02', 70), (3, 2, '2019-06-15', 90), (4, 3, '2020-03-20', 65), (5, 3, '2020-03-21', 70);", "reference_sql": "SELECT Members.user_name, SUM(Workouts.workout_duration) AS total_workout_time, COUNT(Workouts.id) AS total_workouts FROM Members JOIN Workouts ON Members.id = Workouts.user_id WHERE Members.membership_type = 'Basic' GROUP BY Members.user_name;", "generated_sql": "SELECT m.user_name, COUNT(w.id) AS total_workouts, SUM(w.workout_duration) AS total_workout_time FROM members m JOIN workouts w ON m.id = w.user_id WHERE membership_type = 'Basic' GROUP BY m.user_name;", "raw_model_output": " Code\n<s> SELECT m.user_name, COUNT(w.id) AS total_workouts, SUM(w.workout_duration) AS total_workout_time FROM members m JOIN workouts w ON m.id = w.user_id WHERE membership_type = 'Basic' GROUP BY m.user_name;", "latency_sec": 1.2192680835723877, "total_duration_sec": 0.92938632, "load_duration_sec": 0.008112874, "tokens_prompt": 325, "prompt_eval_sec": 0.02355851, "tokens_completion": 78, "completion_eval_sec": 0.896686246, "tokens_total": 403, "tokens_per_sec": 330.5261619079148, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same data by joining Members and Workouts tables on user_id, filtering for 'Basic' membership, and grouping by user_name. The column aliases and aggregation order differ but do not affect the result. Table aliases (Members/Memberships, Workouts/Workouts) and case sensitivity of table names are consistent in logic.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically equivalent as they produce the same result set by joining Members and Workouts tables on user_id, filtering for 'Basic' membership, and grouping by user_name. The Reference SQL uses full table names while the Generated SQL uses aliases (m/w), which is a stylistic preference. Both correctly calculate total_workouts (COUNT) and total_workout_time (SUM). The Generated SQL is more concise with shorter aliases, making it slightly more elegant. However, both queries have a potential flaw: grouping by user_name (which may not be unique) instead of Members.id (the true user identifier). This could lead to incorrect aggregation if multiple users share the same name, but the sample data and question context imply user_name is unique. The business intent is fulfilled as both answer the question as posed.", "overall_assessment": "correct"}}
{"example_id": 5678, "sql_complexity": "set operations", "prompt": "How many public works projects are there in 'Sydney' and 'Melbourne' combined?", "context": "CREATE TABLE PublicWorksC(id INT, city VARCHAR(20), project VARCHAR(30)); INSERT INTO PublicWorksC(id, city, project) VALUES (1, 'Sydney', 'Park Renovation'), (2, 'Melbourne', 'Sidewalk Repair');", "reference_sql": "SELECT COUNT(*) FROM (SELECT city FROM PublicWorksC WHERE city = 'Sydney' UNION ALL SELECT city FROM PublicWorksC WHERE city = 'Melbourne') AS Total;", "generated_sql": "SELECT COUNT(*) FROM PublicWorksC WHERE city IN ('Sydney','Melbourne'));", "raw_model_output": " Code\n<s> # of projects = (SELECT COUNT(*) FROM PublicWorksC WHERE city IN ('Sydney','Melbourne'));", "latency_sec": 0.5125131607055664, "total_duration_sec": 0.352127735, "load_duration_sec": 0.008431464, "tokens_prompt": 109, "prompt_eval_sec": 0.007815774, "tokens_completion": 31, "completion_eval_sec": 0.335167097, "tokens_total": 140, "tokens_per_sec": 273.1637170199978, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of rows where the city is either 'Sydney' or 'Melbourne'. The Reference SQL uses a UNION ALL to combine results from two separate selects, while the Generated SQL uses IN to filter directly. Since UNION ALL preserves all rows (including duplicates) and the IN clause achieves the same filtering, the final count will be identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count projects in Sydney and Melbourne. The reference query uses UNION ALL to combine results from two subqueries, while the generated query uses a simpler IN clause. Both produce identical counts because they aggregate all rows where city is Sydney or Melbourne. The generated query is more efficient as it requires a single table scan instead of two subqueries with union operations.", "overall_assessment": "correct"}}
{"example_id": 5792, "sql_complexity": "multiple_joins", "prompt": "How many cases were handled by attorneys in the 'Los Angeles' office?", "context": "CREATE TABLE offices (office_id INT, office_name VARCHAR(20), city VARCHAR(20), state VARCHAR(20)); INSERT INTO offices (office_id, office_name, city, state) VALUES (1, 'Boston', 'Boston', 'MA'), (2, 'New York', 'New York', 'NY'), (3, 'Los Angeles', 'Los Angeles', 'CA'); CREATE TABLE attorneys (attorney_id INT, office_id INT); INSERT INTO attorneys (attorney_id, office_id) VALUES (1, 1), (2, 2), (3, 3); CREATE TABLE cases (case_id INT, attorney_id INT); INSERT INTO cases (case_id, attorney_id) VALUES (1, 1), (2, 2), (3, 3);", "reference_sql": "SELECT COUNT(*) FROM cases JOIN attorneys ON cases.attorney_id = attorneys.attorney_id JOIN offices ON attorneys.office_id = offices.office_id WHERE offices.city = 'Los Angeles';", "generated_sql": "SELECT COUNT(*) AS total_cases FROM cases JOIN attorneys ON cases.attorney_id = attorneys.attorney_id JOIN offices ON attorneys.office_id = offices.office_id WHERE offices.office_name ILIKE '%Los%Angeles%';", "raw_model_output": " Code\n<s> SELECT COUNT(*) AS total_cases FROM cases JOIN attorneys ON cases.attorney_id = attorneys.attorney_id JOIN offices ON attorneys.office_id = offices.office_id WHERE offices.office_name ILIKE '%Los%Angeles%';", "latency_sec": 0.960076093673706, "total_duration_sec": 0.807463934, "load_duration_sec": 0.008668524, "tokens_prompt": 236, "prompt_eval_sec": 0.015900699, "tokens_completion": 70, "completion_eval_sec": 0.782096891, "tokens_total": 306, "tokens_per_sec": 318.72473652489253, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters on `offices.city = 'Los Angeles'` (exact match on city column), while the Generated SQL filters on `offices.office_name ILIKE '%Los%Angeles%'` (case-insensitive partial match on office_name column). These conditions target different columns and use different comparison logic (exact vs. pattern match), leading to potentially different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent. The reference query correctly filters by `offices.city = 'Los Angeles'`, which aligns with the business intent of identifying cases handled by attorneys in the Los Angeles office (based on location). The generated query uses `offices.office_name ILIKE '%Los%Angeles%'`, which is less precise and could match unintended office names (e.g., 'Los Angeles Office' vs. 'Los Angeles'). While both might return the same result in this specific dataset, the reference query is semantically correct for the question. The generated query's use of `ILIKE` with wildcards introduces ambiguity and potential overmatching. The reference query better fulfills the business intent by directly targeting the city, which is the logical identifier for an office's location.", "overall_assessment": "differently_correct"}}
{"example_id": 5148, "sql_complexity": "window functions", "prompt": "List the unique types of smart city technologies that have been implemented in the top 3 most populous countries in the world.", "context": "CREATE TABLE smart_city_tech (tech_type VARCHAR(255), country VARCHAR(255)); CREATE TABLE country_populations (country VARCHAR(255), population INT);", "reference_sql": "SELECT DISTINCT tech_type FROM smart_city_tech SCT WHERE country IN (SELECT country FROM (SELECT country, ROW_NUMBER() OVER (ORDER BY population DESC) as rank FROM country_populations) CP WHERE rank <= 3);", "generated_sql": "Code\n<s> #_rank, tech_type FROM smart_city_tech JOIN country_populations ON smart_city_tech.country = country_populations.country ORDER BY number_of_people DESC LIMIT 3;", "raw_model_output": " Code\n<s> #_rank, tech_type FROM smart_city_tech JOIN country_populations ON smart_city_tech.country = country_populations.country ORDER BY number_of_people DESC LIMIT 3;", "latency_sec": 0.8506050109863281, "total_duration_sec": 0.566099266, "load_duration_sec": 0.008431408, "tokens_prompt": 88, "prompt_eval_sec": 0.007514244, "tokens_completion": 52, "completion_eval_sec": 0.549581648, "tokens_total": 140, "tokens_per_sec": 164.58873177535307, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query retrieves distinct tech_types from the top 3 most populous countries using a ranked subquery. The generated query attempts a join but has syntax errors (e.g., undefined '#_rank') and would return top 3 rows from a joined dataset without ensuring country ranking or distinct tech_types. The generated query also references 'number_of_people' which doesn't exist in the schema.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly identifies the top 3 most populous countries using ROW_NUMBER() and selects distinct tech_types from those countries. The Generated SQL has multiple issues: 1) It references a non-existent column 'number_of_people' instead of 'population', causing a syntax error. 2) It lacks DISTINCT to ensure unique tech types. 3) The LIMIT 3 clause may not reliably capture the top 3 countries due to potential duplicate country entries in the join. The Reference SQL properly addresses both the technical requirements and business intent.", "overall_assessment": "incorrect"}}
{"example_id": 5547, "sql_complexity": "multiple_joins", "prompt": "Which species have a population growth rate higher than the average for protected areas?", "context": "CREATE TABLE species (id INT, name VARCHAR(50), population DECIMAL(5,2), protected_area_id INT, growth_rate DECIMAL(5,2)); INSERT INTO species (id, name, population, protected_area_id, growth_rate) VALUES (1, 'Species 1', 500.00, 1, 0.05), (2, 'Species 2', 800.00, 1, 0.03), (3, 'Species 3', 1200.00, 2, 0.07), (4, 'Species 4', 700.00, 2, 0.02); CREATE TABLE protected_areas (id INT, name VARCHAR(50)); INSERT INTO protected_areas (id, name) VALUES (1, 'Area 1'), (2, 'Area 2');", "reference_sql": "SELECT s.name, s.growth_rate FROM species s INNER JOIN protected_areas pa ON s.protected_area_id = pa.id GROUP BY s.name, s.growth_rate HAVING s.growth_rate > (SELECT AVG(s.growth_rate) FROM species s INNER JOIN protected_areas pa ON s.protected_area_id = pa.id);", "generated_sql": "SELECT s.name FROM species AS s JOIN protected_areas AS p ON s.protected_area_id = p.id WHERE s.growth_rate > (SELECT AVG(s.growth_rate) FROM species AS s JOIN protected_areas AS p ON s.protected_area_id = p.id);", "raw_model_output": " Code\n<s> SELECT s.name FROM species AS s JOIN protected_areas AS p ON s.protected_area_id = p.id WHERE s.growth_rate > (SELECT AVG(s.growth_rate) FROM species AS s JOIN protected_areas AS p ON s.protected_area_id = p.id);", "latency_sec": 0.9908730983734131, "total_duration_sec": 0.89603732, "load_duration_sec": 0.008751552, "tokens_prompt": 256, "prompt_eval_sec": 0.015229472, "tokens_completion": 78, "completion_eval_sec": 0.871314968, "tokens_total": 334, "tokens_per_sec": 337.0764637250564, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL selects both 'name' and 'growth_rate' columns, while the Generated SQL only selects 'name'. Additionally, the Reference SQL uses a GROUP BY with a HAVING clause, which is unnecessary here and could affect results if there were duplicate combinations of name/growth_rate. The Generated SQL directly filters with WHERE, which is more efficient but the column mismatch makes them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL contains a technical flaw by using HAVING without an aggregate function, which is unnecessary given the GROUP BY clause. The Generated SQL correctly uses WHERE to filter rows based on the subquery result. Both queries calculate the average growth rate correctly, but the Generated version avoids redundant grouping and uses the appropriate filter clause. The Reference's GROUP BY and HAVING combination is logically equivalent to the Generated's WHERE clause in this specific case, but the Generated query is more efficient and semantically correct.", "overall_assessment": "differently_correct"}}
{"example_id": 5498, "sql_complexity": "aggregation", "prompt": "Identify the destinations with the highest number of repeat visitors from the US.", "context": "CREATE TABLE RepeatTravelers (Visitor VARCHAR(20), Destination VARCHAR(20), VisitCount INT); INSERT INTO RepeatTravelers (Visitor, Destination, VisitCount) VALUES ('David', 'Paris', 3), ('Ella', 'London', 4), ('Fiona', 'Paris', 2);", "reference_sql": "SELECT Destination, AVG(VisitCount) AS AvgVisitCount FROM RepeatTravelers WHERE Visitor LIKE '%USA%' GROUP BY Destination ORDER BY AvgVisitCount DESC;", "generated_sql": "SELECT DISTINCT RepeatTravelers.Destination FROM RepeatTravelers WHERE RepeatTravelers.Visitor ILIKE '%USA%' ORDER BY VisitCount DESC NULLS LAST LIMIT 1;", "raw_model_output": " Code\nSELECT DISTINCT RepeatTravelers.Destination FROM RepeatTravelers WHERE RepeatTravelers.Visitor ILIKE '%USA%' ORDER BY VisitCount DESC NULLS LAST LIMIT 1;", "latency_sec": 0.67600417137146, "total_duration_sec": 0.577012067, "load_duration_sec": 0.009245426, "tokens_prompt": 112, "prompt_eval_sec": 0.007904339, "tokens_completion": 52, "completion_eval_sec": 0.559151456, "tokens_total": 164, "tokens_per_sec": 242.60205327916987, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates average visit counts per destination for USA visitors and sorts by that average. The generated query selects a single destination with the highest visit count from USA visitors, ignoring averages and using a different sorting/limiting approach. Additionally, the generated query uses ILIKE (case-insensitive) while the reference uses LIKE.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent. The Reference SQL calculates the average VisitCount per destination for US visitors, while the Generated SQL selects a single destination with the highest VisitCount for a US visitor. Neither query correctly addresses the business intent of identifying destinations with the highest number of repeat visitors (which likely requires counting distinct US visitors with multiple visits). The Reference SQL is more aligned with the intent by grouping destinations, but both fail to accurately measure 'repeat visitors' as defined by the question. The Generated SQL is less comprehensive and technically flawed (e.g., using DISTINCT on a single row result).", "overall_assessment": "differently_correct"}}
{"example_id": 3546, "sql_complexity": "window functions", "prompt": "What are the cryptocurrency exchanges with their corresponding blockchain companies, ranked by exchange ID in ascending order, for the Bitcoin platform?", "context": "CREATE TABLE cryptocurrency_exchanges (exchange_id INT, exchange_name VARCHAR(50), company_id INT); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (1, 'Binance', 1); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (2, 'Coinbase', 2); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (3, 'Kraken', 3); CREATE TABLE blockchain_companies (company_id INT, company_name VARCHAR(50), platform VARCHAR(50)); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (1, 'Binance', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (2, 'Blockstream', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (3, 'Blockchair', 'Bitcoin');", "reference_sql": "SELECT ce.exchange_name, bc.company_name, ce.exchange_id, ROW_NUMBER() OVER (PARTITION BY bc.platform ORDER BY ce.exchange_id ASC) as rank FROM cryptocurrency_exchanges ce JOIN blockchain_companies bc ON ce.company_id = bc.company_id WHERE bc.platform = 'Bitcoin';", "generated_sql": "SELECT c.exchange_id, b.company_name FROM cryptocurrency_exchanges AS c JOIN blockchain_companies AS b ON c.company_id = b.company_id WHERE b.platform = 'Bitcoin' ORDER BY c.exchange_id ASC;", "raw_model_output": " Code\n<s> SELECT c.exchange_id, b.company_name FROM cryptocurrency_exchanges AS c JOIN blockchain_companies AS b ON c.company_id = b.company_id WHERE b.platform = 'Bitcoin' ORDER BY c.exchange_id ASC;", "latency_sec": 0.9305529594421387, "total_duration_sec": 0.837927596, "load_duration_sec": 0.007925178, "tokens_prompt": 325, "prompt_eval_sec": 0.020095123, "tokens_completion": 70, "completion_eval_sec": 0.808972052, "tokens_total": 395, "tokens_per_sec": 424.4787961738366, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL includes additional columns (exchange_name, company_name, exchange_id) and calculates a ROW_NUMBER() ranking, while the Generated SQL selects different columns (exchange_id, company_name) and lacks the ranking logic. The output structures and computed values differ, leading to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL includes the required columns (exchange_name, company_name) and correctly joins the tables, but lacks an explicit ORDER BY clause, which is needed to ensure the results are sorted by exchange_id. The Generated SQL omits exchange_name (a critical column per the question) and includes only exchange_id and company_name, failing to fully address the business intent. While the Generated SQL has proper ordering, it misses essential data. The Reference SQL better fulfills the intent by including the required fields, even though it lacks explicit ordering. The Generated SQL is technically correct but incomplete in data coverage.", "overall_assessment": "differently_correct"}}
{"example_id": 486, "sql_complexity": "single join", "prompt": "What is the average price of paintings from African artists in our collection?", "context": "CREATE TABLE Artworks (id INT, title VARCHAR(50), price DECIMAL(10,2), medium VARCHAR(50), artist_nationality VARCHAR(50)); CREATE TABLE Collections (id INT, name VARCHAR(50), continent VARCHAR(50));", "reference_sql": "SELECT AVG(Artworks.price) FROM Artworks INNER JOIN Collections ON Artworks.artist_nationality = Collections.continent WHERE Artworks.medium = 'Painting' AND Collections.continent = 'Africa';", "generated_sql": "SELECT AVG(Artworks.price) FROM Artworks JOIN Collections ON Artworks.artist_nationality = Collections.name WHERE Collections.continent = 'African';", "raw_model_output": " Code\nSELECT AVG(Artworks.price) FROM Artworks JOIN Collections ON Artworks.artist_nationality = Collections.name WHERE Collections.continent = 'African';", "latency_sec": 0.7919437885284424, "total_duration_sec": 0.474266801, "load_duration_sec": 0.007905599, "tokens_prompt": 98, "prompt_eval_sec": 0.009522171, "tokens_completion": 43, "completion_eval_sec": 0.456025025, "tokens_total": 141, "tokens_per_sec": 178.0429394641764, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in three key aspects: 1) The join condition uses 'Collections.continent' vs. 'Collections.name' 2) The continent filter is 'Africa' vs. 'African' 3) The Reference SQL includes a medium filter ('Painting') that's missing in the Generated SQL. These differences would produce different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent. The reference query incorrectly joins Artworks.artist_nationality with Collections.continent (which would only match if an artist's nationality is the same as a continent name, e.g., 'Africa' instead of 'Kenyan'), while the generated query joins on Artworks.artist_nationality = Collections.name (which would require artist nationalities to match collection names, likely unrelated). Both have logical flaws: the reference uses 'Africa' in WHERE (correct continent name) but wrong join logic, while the generated uses 'African' (typo) and incorrect join. Neither properly links artist nationalities to continents. The reference is slightly better due to correct continent name but still fails to address the actual business intent of identifying African artists.", "overall_assessment": "incorrect"}}
{"example_id": 794, "sql_complexity": "multiple_joins", "prompt": "Which suppliers have provided raw materials for the production of chemicals with high environmental impact?", "context": "CREATE TABLE suppliers (id INT, name TEXT); INSERT INTO suppliers (id, name) VALUES (1, 'Supplier1'), (2, 'Supplier2'), (3, 'Supplier3'); CREATE TABLE chemicals (id INT, name TEXT, environmental_impact INT); INSERT INTO chemicals (id, name, environmental_impact) VALUES (1, 'ChemA', 10), (2, 'ChemB', 20), (3, 'ChemC', 15); CREATE TABLE raw_materials (chemical_id INT, supplier_id INT); INSERT INTO raw_materials (chemical_id, supplier_id) VALUES (1, 1), (1, 2), (2, 3), (3, 1);", "reference_sql": "SELECT s.name FROM suppliers s INNER JOIN raw_materials rm ON s.id = rm.supplier_id INNER JOIN chemicals c ON rm.chemical_id = c.id WHERE c.environmental_impact > 10;", "generated_sql": "SELECT s.name AS supplier_name, c.name AS chemical_name FROM suppliers AS s JOIN raw_materials AS rm ON s.id = rm.supplier_id JOIN chemicals AS c ON rm.chemical_id = c.id WHERE c.environmental_impact > 15;", "raw_model_output": " Code\n<s> SELECT s.name AS supplier_name, c.name AS chemical_name FROM suppliers AS s JOIN raw_materials AS rm ON s.id = rm.supplier_id JOIN chemicals AS c ON rm.chemical_id = c.id WHERE c.environmental_impact > 15;", "latency_sec": 1.0082449913024902, "total_duration_sec": 0.833288146, "load_duration_sec": 0.007615105, "tokens_prompt": 217, "prompt_eval_sec": 0.013410689, "tokens_completion": 73, "completion_eval_sec": 0.811422315, "tokens_total": 290, "tokens_per_sec": 287.6285054740184, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects: 1) The Reference SQL selects only supplier names, while the Generated SQL selects both supplier and chemical names. 2) The WHERE clause filters environmental_impact > 10 in the Reference vs. > 15 in the Generated. This would produce different results as the filtering criteria are not equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in two key aspects: 1) The reference uses 'environmental_impact > 10' while the generated uses 'environmental_impact > 15', altering the threshold for 'high environmental impact'. 2) The generated query includes 'chemical_name' in the output, which isn't required by the original question. The reference correctly identifies suppliers for chemicals with environmental impact above 10 (including ChemB and ChemC), while the generated query only captures ChemB. The original question lacks a defined threshold, but the reference's lower threshold better aligns with the intent to identify suppliers for chemicals with 'high' impact, assuming 'high' is relative to the dataset. The generated query's stricter condition may exclude valid suppliers.", "overall_assessment": "differently_correct"}}
{"example_id": 3164, "sql_complexity": "set operations", "prompt": "What is the average age of patients who received therapy in 'clinic_a' and 'clinic_b'?", "context": "CREATE TABLE clinic_a (patient_id INT, age INT, therapy_received BOOLEAN); INSERT INTO clinic_a (patient_id, age, therapy_received) VALUES (1, 35, true), (2, 42, true), (3, 28, false); CREATE TABLE clinic_b (patient_id INT, age INT, therapy_received BOOLEAN); INSERT INTO clinic_b (patient_id, age, therapy_received) VALUES (4, 50, true), (5, 32, false), (6, 45, true);", "reference_sql": "SELECT AVG(age) FROM (SELECT age FROM clinic_a WHERE therapy_received = true UNION ALL SELECT age FROM clinic_b WHERE therapy_received = true) AS combined_clinics;", "generated_sql": "SELECT AVG(age) FROM clinic_a JOIN clinic_b ON clinic_a.patient_id = clinic_b.patient_id WHERE therapy_received IS TRUE;", "raw_model_output": " Code\n<s> Question: SELECT AVG(age) FROM clinic_a JOIN clinic_b ON clinic_a.patient_id = clinic_b.patient_id WHERE therapy_received IS TRUE;", "latency_sec": 0.8349268436431885, "total_duration_sec": 0.54169193, "load_duration_sec": 0.009302006, "tokens_prompt": 188, "prompt_eval_sec": 0.014731487, "tokens_completion": 46, "completion_eval_sec": 0.51687745, "tokens_total": 234, "tokens_per_sec": 280.26407556732175, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query calculates the average age of patients who received therapy from both clinics combined using UNION ALL. The generated query attempts to join clinic_a and clinic_b on patient_id, but since there are no matching patient_ids between the two tables, it returns no rows. This results in a different output (likely NULL or 0) compared to the reference query's correct average calculation.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly combines patients from both clinics using UNION ALL and calculates the average age of those who received therapy. The generated query uses a JOIN between clinic_a and clinic_b on patient_id, which fails because there are no overlapping patient_ids between the two tables (clinic_a has patients 1-3, clinic_b has 4-6). This results in an empty dataset, making the generated query return NULL instead of the correct average. The original question likely intended 'or' (patients in either clinic), but the generated query incorrectly implements 'and' (patients in both clinics). The reference query properly addresses the business intent of aggregating therapy recipients across both clinics.", "overall_assessment": "incorrect"}}
{"example_id": 3704, "sql_complexity": "aggregation", "prompt": "What is the total sales revenue for each category of garments in the South America region in Q1 2022?", "context": "CREATE TABLE sales_category (sale_id INT, garment_category VARCHAR(50), sale_date DATE, total_sales DECIMAL(10, 2), region VARCHAR(50));", "reference_sql": "SELECT garment_category, SUM(total_sales) FROM sales_category WHERE sale_date BETWEEN '2022-01-01' AND '2022-03-31' AND region = 'South America' GROUP BY garment_category;", "generated_sql": "SELECT sale_category.garment_category, SUM(sale_category.total_sales) AS total_revenue FROM sale_category WHERE sale_category.region = 'South America' AND EXTRACT(QUARTER FROM sale_category.sale_date) = 1 AND EXTRACT(YEAR FROM sale_category.sale_date) = 2022 GROUP BY sale_category.garment_category;", "raw_model_output": " Code\n<s> # SELECT sale_category.garment_category, SUM(sale_category.total_sales) AS total_revenue FROM sale_category WHERE sale_category.region = 'South America' AND EXTRACT(QUARTER FROM sale_category.sale_date) = 1 AND EXTRACT(YEAR FROM sale_category.sale_date) = 2022 GROUP BY sale_category.garment_category;", "latency_sec": 1.4528169631958008, "total_duration_sec": 1.155896438, "load_duration_sec": 0.003336306, "tokens_prompt": 93, "prompt_eval_sec": 0.006525633, "tokens_completion": 106, "completion_eval_sec": 1.14548898, "tokens_total": 199, "tokens_per_sec": 136.9752728948417, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries aggregate total_sales by garment_category for records in 'South America' during Q1 2022. The reference uses a date range (BETWEEN '2022-01-01' AND '2022-03-31') while the generated query uses EXTRACT(QUARTER) = 1 and EXTRACT(YEAR) = 2022. Since Q1 2022 corresponds to January-March 2022, the date filters are equivalent. Both queries group by garment_category and sum total_sales, producing identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries correctly calculate total sales revenue per garment category in South America for Q1 2022. The Reference SQL uses a date range ('2022-01-01' to '2022-03-31') which explicitly captures Q1 2022, while the Generated SQL uses EXTRACT(QUARTER) = 1 and EXTRACT(YEAR) = 2022. Both approaches are logically equivalent for this specific quarter/year combination. However, the Reference query is more efficient as date ranges can leverage indexes on sale_date, whereas EXTRACT may require full table scans. The Reference also has cleaner syntax without unnecessary column aliases. Both fulfill the business intent of aggregating sales by category in the specified region and time frame.", "overall_assessment": "correct"}}
{"example_id": 2851, "sql_complexity": "single join", "prompt": "How many cases were handled by attorneys who joined the firm in 2015 or later?", "context": "CREATE TABLE attorneys (attorney_id INT, join_year INT); CREATE TABLE cases (case_id INT, attorney_id INT, billing_amount INT);", "reference_sql": "SELECT COUNT(DISTINCT cases.case_id) FROM cases INNER JOIN attorneys ON cases.attorney_id = attorneys.attorney_id WHERE attorneys.join_year >= 2015;", "generated_sql": "SELECT COUNT(*) FROM cases AS c JOIN attorneys AS a ON c.attorney_id = a.attorney_id WHERE a.join_year >= 2015);", "raw_model_output": " Code\n<s> # of cases = (SELECT COUNT(*) FROM cases AS c JOIN attorneys AS a ON c.attorney_id = a.attorney_id WHERE a.join_year >= 2015);", "latency_sec": 0.6387741565704346, "total_duration_sec": 0.56359451, "load_duration_sec": 0.008736564, "tokens_prompt": 76, "prompt_eval_sec": 0.007305908, "tokens_completion": 51, "completion_eval_sec": 0.546895542, "tokens_total": 127, "tokens_per_sec": 198.81831269107758, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query uses COUNT(DISTINCT cases.case_id) while the generated query uses COUNT(*). The former counts unique case IDs, whereas the latter counts all rows in the result set. If there are multiple entries in 'cases' for the same case_id, the generated query would return a higher count than the reference query.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in their aggregation approach. The reference query uses COUNT(DISTINCT cases.case_id) which ensures each case is counted once, even if multiple attorneys from 2015+ handle it. The generated query uses COUNT(*) which would overcount cases handled by multiple qualifying attorneys. While both filter attorneys joining in 2015+, the reference correctly addresses the business intent of counting unique cases. The generated query's approach would produce inflated numbers in scenarios with multi-attorney cases.", "overall_assessment": "differently_correct"}}
{"example_id": 3246, "sql_complexity": "single join", "prompt": "What is the average eco-friendliness score of accommodations in Oceania by year?", "context": "CREATE TABLE Accommodations (Accommodation_ID INT, Accommodation_Name VARCHAR(50), City VARCHAR(30), Country VARCHAR(50), Eco_Friendliness_Score INT, Visit_Year INT); INSERT INTO Accommodations (Accommodation_ID, Accommodation_Name, City, Country, Eco_Friendliness_Score, Visit_Year) VALUES (1, 'EcoLodge', 'Sydney', 'Australia', 85, 2019), (2, 'GreenHotel', 'Melbourne', 'Australia', 90, 2019), (3, 'SustainableResort', 'Auckland', 'New Zealand', 80, 2019), (4, 'EcoVilla', 'Wellington', 'New Zealand', 88, 2019); CREATE TABLE Countries (Country VARCHAR(50), Continent VARCHAR(30)); INSERT INTO Countries (Country, Continent) VALUES ('Australia', 'Oceania'), ('New Zealand', 'Oceania');", "reference_sql": "SELECT C.Continent, V.Visit_Year, AVG(A.Eco_Friendliness_Score) AS Avg_Eco_Score  FROM Accommodations A  JOIN Countries C  ON A.Country = C.Country  WHERE C.Continent = 'Oceania'  GROUP BY C.Continent, V.Visit_Year  ORDER BY V.Visit_Year;", "generated_sql": "SELECT COUNT.Continent, YEAR, AVG(Accommodations.Eco_Friendliness_Score) AS average_eco_friendliness_score FROM Accommodations JOIN Countries ON Accommodations.country = Countries.Country GROUP BY COUNT.Continent, YEAR ORDER BY COUNT.Continent, YEAR NULLS LAST;", "raw_model_output": " Code\n<s> SELECT COUNT.Continent, YEAR, AVG(Accommodations.Eco_Friendliness_Score) AS average_eco_friendliness_score FROM Accommodations JOIN Countries ON Accommodations.country = Countries.Country GROUP BY COUNT.Continent, YEAR ORDER BY COUNT.Continent, YEAR NULLS LAST;", "latency_sec": 1.1190690994262695, "total_duration_sec": 1.09686171, "load_duration_sec": 0.011949905, "tokens_prompt": 304, "prompt_eval_sec": 0.024367314, "tokens_completion": 92, "completion_eval_sec": 1.057952893, "tokens_total": 396, "tokens_per_sec": 353.8655478942484, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Generated SQL contains invalid column references (e.g., 'YEAR' instead of 'Visit_Year', 'COUNT.Continent' which is undefined) and lacks the WHERE clause filtering for 'Oceania'. Additionally, the ORDER BY clause in the Generated SQL has syntax errors ('NULLS LAST' without proper context). The Reference SQL correctly uses 'Visit_Year' and filters by continent, while the Generated SQL would produce incorrect results or errors due to these issues.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The Reference SQL is technically correct and fulfills the business intent. It properly joins the Accommodations and Countries tables, filters for Oceania, groups by Continent and Visit_Year, and calculates the average eco-score. The Generated SQL has multiple issues: 1) Uses 'COUNT.Continent' which is invalid syntax (COUNT is an aggregate function, not a column alias), 2) References 'YEAR' as a column (missing proper alias/field name), 3) Lacks the WHERE clause to filter for Oceania, 4) Uses 'NULLS LAST' in ORDER BY which is invalid syntax in standard SQL. The Generated query would fail or return incorrect results. The Reference query directly addresses the business question by year and continent.", "overall_assessment": "correct"}}
{"example_id": 3056, "sql_complexity": "multiple_joins", "prompt": "Identify all suppliers who provide non-GMO ingredients to restaurants with Michelin stars.", "context": "CREATE TABLE Suppliers (id INT, name VARCHAR(50), isNonGMO BOOLEAN); CREATE TABLE Restaurants (id INT, name VARCHAR(50), numStars INT); CREATE TABLE Ingredients (supplierId INT, restaurantId INT, isNonGMO BOOLEAN);", "reference_sql": "SELECT Suppliers.name FROM Suppliers INNER JOIN Ingredients ON Suppliers.id = Ingredients.supplierId INNER JOIN Restaurants ON Ingredients.restaurantId = Restaurants.id WHERE Restaurants.numStars > 2 AND Ingredients.isNonGMO = TRUE;", "generated_sql": "SELECT COUNT(DISTINCT s.id) FROM Suppliers AS s JOIN Ingredients AS i ON s.id = i.supplierId JOIN Restaurants AS r ON i.restaurantId = r.id WHERE isNonGMO = TRUE AND numStars > 0);", "raw_model_output": " Code\n<s> # of suppliers = (SELECT COUNT(DISTINCT s.id) FROM Suppliers AS s JOIN Ingredients AS i ON s.id = i.supplierId JOIN Restaurants AS r ON i.restaurantId = r.id WHERE isNonGMO = TRUE AND numStars > 0);", "latency_sec": 1.0310540199279785, "total_duration_sec": 0.828112381, "load_duration_sec": 0.008620326, "tokens_prompt": 105, "prompt_eval_sec": 0.009153105, "tokens_completion": 75, "completion_eval_sec": 0.80954342, "tokens_total": 180, "tokens_per_sec": 174.57863169242424, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in multiple ways. 1) The Reference SQL returns supplier names, while the Generated SQL returns a count of distinct supplier IDs. 2) The WHERE clause in the Generated SQL uses 'numStars > 0' instead of 'numStars > 2' from the Reference SQL. 3) The Generated SQL's WHERE clause references 'isNonGMO' without a table alias, which could lead to ambiguity given that both Suppliers and Ingredients tables have an 'isNonGMO' column.  These differences ensure the queries will not produce the same results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly identifies suppliers by selecting their names through proper joins and filtering for restaurants with >2 Michelin stars (assuming 3-star is required) and non-GMO ingredients. The Generated SQL has multiple issues: 1) It counts distinct supplier IDs instead of listing names, 2) It uses 'numStars > 0' which would include all restaurants with any stars (not just Michelin-recognized ones), 3) It references 'isNonGMO' without a table alias (could cause ambiguity). While both queries join the same tables, their output structures and filtering criteria differ significantly. The Reference directly addresses the business intent of 'identifying suppliers', while the Generated SQL answers a different question (counting suppliers).", "overall_assessment": "incorrect"}}
{"example_id": 264, "sql_complexity": "set operations", "prompt": "List the number of community health centers and infectious disease tracking facilities in 'southwest' regions.", "context": "CREATE TABLE centers (id INT, name TEXT, region TEXT); INSERT INTO centers (id, name, region) VALUES (1, 'Center A', 'southwest'); INSERT INTO centers (id, name, region) VALUES (2, 'Center B', 'northeast'); INSERT INTO centers (id, name, region) VALUES (3, 'Center C', 'northwest'); CREATE TABLE diseases (id INT, name TEXT, region TEXT); INSERT INTO diseases (id, name, region) VALUES (1, 'Disease A', 'southwest'); INSERT INTO diseases (id, name, region) VALUES (2, 'Disease B', 'southeast');", "reference_sql": "SELECT COUNT(*) FROM ( (SELECT * FROM centers WHERE region = 'southwest') UNION (SELECT * FROM diseases WHERE region = 'southwest') );", "generated_sql": "SELECT COUNT(DISTINCT c.id) AS total_centers, COUNT(DISTINCT d.id) AS total_diseases FROM centers c JOIN diseases d ON c.region = d.region WHERE c.region = 'southwest';", "raw_model_output": " Code\n<s> SELECT COUNT(DISTINCT c.id) AS total_centers, COUNT(DISTINCT d.id) AS total_diseases FROM centers c JOIN diseases d ON c.region = d.region WHERE c.region = 'southwest';", "latency_sec": 1.0598828792572021, "total_duration_sec": 0.756727437, "load_duration_sec": 0.011377586, "tokens_prompt": 205, "prompt_eval_sec": 0.013115905, "tokens_completion": 65, "completion_eval_sec": 0.731478102, "tokens_total": 270, "tokens_per_sec": 254.74512824400384, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL counts all rows from both tables (centers and diseases) where region is 'southwest' using UNION, resulting in 2 rows (1 from centers, 1 from diseases). The Generated SQL performs a JOIN between centers and diseases on region, then counts distinct ids from each table. This returns two separate counts (1 for centers, 1 for diseases) but in separate columns. The output structure and logic differ: the Reference SQL returns a single count of combined rows, while the Generated SQL returns two separate counts. Additionally, the Generated SQL's JOIN may not correctly represent the original intent of combining rows from both tables.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference SQL combines centers and diseases into a single count using UNION, which incorrectly aggregates both types of facilities into one total rather than providing separate counts. The generated SQL correctly separates the counts using COUNT(DISTINCT) on joined tables, though it uses an unnecessary JOIN. However, the WHERE clause ensures only southwest regions are considered, and the COUNT(DISTINCT) properly captures unique facilities. While the generated SQL could be more efficient without the JOIN, it technically fulfills the intent of counting both facility types in the southwest. The reference SQL fails to address the dual-count requirement.", "overall_assessment": "differently_correct"}}
{"example_id": 2838, "sql_complexity": "basic SQL", "prompt": "What is the minimum safety rating of electric vehicles in the 'green_cars' table?", "context": "CREATE TABLE green_cars (id INT, make VARCHAR(50), model VARCHAR(50), type VARCHAR(50), safety_rating INT);", "reference_sql": "SELECT MIN(safety_rating) FROM green_cars WHERE type = 'Electric';", "generated_sql": "SELECT MIN(safety_rating) AS min_safety_rating FROM green_cars WHERE type ILIKE '%electric%';", "raw_model_output": " Code\nSELECT MIN(safety_rating) AS min_safety_rating FROM green_cars WHERE type ILIKE '%electric%';", "latency_sec": 0.4973011016845703, "total_duration_sec": 0.393700398, "load_duration_sec": 0.011804448, "tokens_prompt": 72, "prompt_eval_sec": 0.007210476, "tokens_completion": 35, "completion_eval_sec": 0.374170962, "tokens_total": 107, "tokens_per_sec": 215.1613974663348, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query uses exact case-sensitive matching (= 'Electric') while the generated query uses case-insensitive partial matching (ILIKE '%electric%'). This means the generated query could include rows where type is 'electric', 'ELECTRIC', or other case variations, potentially returning a different MIN(safety_rating) result.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent. The reference query uses exact string matching ('Electric') while the generated query uses case-insensitive partial matching ('%electric%'). This means the generated query could include non-exact matches (e.g., 'ElectricCar', 'ELECTRIC') and might miss entries with different capitalization. However, both queries correctly identify the minimum safety rating for electric vehicles when the data follows standard capitalization. The reference query better fulfills the business intent by precisely matching the 'Electric' type as likely intended by the data schema. The generated query introduces broader matching that could include unintended records.", "overall_assessment": "correct"}}
{"example_id": 1187, "sql_complexity": "multiple_joins", "prompt": "Who are the top 3 authors with the highest number of articles published in The Guardian?", "context": "CREATE TABLE authors (id INT, name VARCHAR(100), publisher VARCHAR(50)); CREATE TABLE articles_authors (article_id INT, author_id INT); INSERT INTO authors (id, name, publisher) VALUES (1, 'Author1', 'The Guardian'), (2, 'Author2', 'The Guardian'), (3, 'Author3', 'The Guardian'); INSERT INTO articles_authors (article_id, author_id) VALUES (1, 1), (2, 2), (3, 1), (3, 2), (3, 3); INSERT INTO articles (id, title, publication_date, publisher) VALUES (1, 'Article1', '2021-01-01', 'The Guardian'), (2, 'Article2', '2021-01-02', 'The Guardian'), (3, 'Article3', '2021-01-03', 'The Guardian');", "reference_sql": "SELECT a.name, COUNT(aa.article_id) AS articles_count FROM authors a JOIN articles_authors aa ON a.id = aa.author_id JOIN articles ar ON aa.article_id = ar.id WHERE ar.publisher = 'The Guardian' GROUP BY a.name ORDER BY articles_count DESC LIMIT 3;", "generated_sql": "SELECT a.name AS author_name, COUNT(*) AS article_count FROM authors a JOIN articles_authors b ON a.id = b.author_id JOIN articles c ON b.article_id = c.id WHERE publisher = 'The Guardian' GROUP BY a.name ORDER BY article_count DESC NULLS LAST LIMIT 3;", "raw_model_output": " Code\n<s> SELECT a.name AS author_name, COUNT(*) AS article_count FROM authors a JOIN articles_authors b ON a.id = b.author_id JOIN articles c ON b.article_id = c.id WHERE publisher = 'The Guardian' GROUP BY a.name ORDER BY article_count DESC NULLS LAST LIMIT 3;", "latency_sec": 1.2278470993041992, "total_duration_sec": 1.031657172, "load_duration_sec": 0.013988708, "tokens_prompt": 272, "prompt_eval_sec": 0.020844383, "tokens_completion": 87, "completion_eval_sec": 0.994502228, "tokens_total": 359, "tokens_per_sec": 292.38168189136854, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve author names and their article counts from 'The Guardian', using similar joins and filters. The differences (column aliases, NULLS LAST in ORDER BY) do not affect the result since COUNT(*) ensures non-null values and the WHERE clause implicitly references the correct publisher column. The semantic outcome remains identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries correctly identify the top 3 authors with the most articles in The Guardian by joining authors, articles_authors, and articles tables, filtering on 'The Guardian' publisher, grouping by author, and ordering by article count. The Reference SQL is more technically precise with explicit table aliases (ar.publisher) and avoids the unnecessary 'NULLS LAST' clause in the ORDER BY. The Generated SQL uses COUNT(*) instead of COUNT(aa.article_id), which is functionally equivalent here but less explicit. The WHERE clause in Generated SQL omits the table alias for 'publisher' which could cause ambiguity in complex schemas, though it works in this specific context. Both queries fulfill the business intent, but the Reference SQL demonstrates better syntax and clarity.", "overall_assessment": "correct"}}
{"example_id": 360, "sql_complexity": "window functions", "prompt": "What is the change in crime rate for each category, between this year and last year, for the same time period?", "context": "CREATE TABLE CrimeStatistics (ID INT, CrimeType VARCHAR(50), Date TIMESTAMP, Count INT); INSERT INTO CrimeStatistics (ID, CrimeType, Date, Count) VALUES (1, 'Theft', '2022-01-01 00:00:00', 100), (2, 'Vandalism', '2022-01-01 00:00:00', 50), (3, 'Theft', '2022-01-02 00:00:00', 120), (4, 'Vandalism', '2022-01-02 00:00:00', 60), (5, 'Theft', '2021-01-01 00:00:00', 80), (6, 'Vandalism', '2021-01-01 00:00:00', 40), (7, 'Theft', '2021-01-02 00:00:00', 90), (8, 'Vandalism', '2021-01-02 00:00:00', 45);", "reference_sql": "SELECT CrimeType, (SUM(Count) OVER (PARTITION BY CrimeType ORDER BY EXTRACT(YEAR FROM Date) ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)) - SUM(Count) OVER (PARTITION BY CrimeType ORDER BY EXTRACT(YEAR FROM Date)) AS CrimeRateChange FROM CrimeStatistics WHERE Date BETWEEN DATE_TRUNC('year', CURRENT_DATE - INTERVAL '1 year') AND CURRENT_DATE;", "generated_sql": "SELECT CrimeType, date_trunc('month', Date) AS MONTH, COUNT(*) AS total_crimes_this_year, lag(COUNT(*)) OVER (PARTITION BY CrimeType ORDER BY date_trunc('month', Date)) AS total_crimes_last_year FROM CrimeStatistics WHERE date_part('year', Date) = EXTRACT(YEAR FROM CURRENT_DATE) GROUP BY CrimeType, MONTH;", "raw_model_output": " Code\n<s> SELECT CrimeType, date_trunc('month', Date) AS MONTH, COUNT(*) AS total_crimes_this_year, lag(COUNT(*)) OVER (PARTITION BY CrimeType ORDER BY date_trunc('month', Date)) AS total_crimes_last_year FROM CrimeStatistics WHERE date_part('year', Date) = EXTRACT(YEAR FROM CURRENT_DATE) GROUP BY CrimeType, MONTH;", "latency_sec": 1.454805850982666, "total_duration_sec": 1.254456529, "load_duration_sec": 0.010783144, "tokens_prompt": 346, "prompt_eval_sec": 0.020530325, "tokens_completion": 106, "completion_eval_sec": 1.222603425, "tokens_total": 452, "tokens_per_sec": 310.69437869987337, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL calculates year-over-year crime rate changes by comparing sums of counts between consecutive years for each CrimeType, while the Generated SQL focuses on month-over-month comparisons within the current year. The Reference SQL uses window functions with year-based ordering and filters data from the previous year to current date, whereas the Generated SQL groups by month and uses lag to compare adjacent months in the same year. The output structures and analytical goals differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "equal", "explanation": "Neither query correctly addresses the original question. The Reference SQL attempts to compare year-over-year sums but uses a flawed WHERE clause that may not align time periods (e.g., comparing full years instead of same calendar periods). The Generated SQL incorrectly filters only current-year data and uses lag() to compare months within the same year, not across years. Both fail to properly align time periods (e.g., January 2022 vs. January 2021) and misinterpret the 'crime rate' metric (using COUNT(*) instead of the provided Count column). The Reference SQL's window functions are technically more aligned with the intent but still lack proper time-period alignment, while the Generated SQL's approach is fundamentally flawed in its logic.", "overall_assessment": "differently_correct"}}
{"example_id": 335, "sql_complexity": "single join", "prompt": "List the policy numbers, claim amounts, and claim dates for policies that have more than two claims and the total claim amount exceeds $5000", "context": "CREATE TABLE policies (policy_number INT);CREATE TABLE claims (claim_id INT, policy_number INT, claim_amount DECIMAL(10,2), claim_date DATE);", "reference_sql": "SELECT p.policy_number, c.claim_amount, c.claim_date FROM policies p INNER JOIN claims c ON p.policy_number = c.policy_number GROUP BY p.policy_number, c.claim_amount, c.claim_date HAVING COUNT(c.claim_id) > 2 AND SUM(c.claim_amount) > 5000;", "generated_sql": "SELECT COUNT(*) FROM claims WHERE policy_number = c.policy_number) GROUP BY c.policy_number HAVING COUNT(*) > 2 AND SUM(claim_amount) > 5000;", "raw_model_output": " Code\n<s> #_of_claims = (SELECT COUNT(*) FROM claims WHERE policy_number = c.policy_number) GROUP BY c.policy_number HAVING COUNT(*) > 2 AND SUM(claim_amount) > 5000;", "latency_sec": 0.783776044845581, "total_duration_sec": 0.685308064, "load_duration_sec": 0.008989961, "tokens_prompt": 90, "prompt_eval_sec": 0.00664994, "tokens_completion": 64, "completion_eval_sec": 0.669129958, "tokens_total": 154, "tokens_per_sec": 196.48469867478656, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL joins policies and claims tables, groups by policy_number, claim_amount, and claim_date, and selects those columns. The Generated SQL references an undefined alias 'c' in the WHERE clause, only queries the claims table, groups by policy_number, and selects COUNT(*). The column selections, table joins, and grouping columns differ significantly, leading to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL has logical flaws in grouping (grouping by claim_amount and claim_date instead of just policy_number) which would incorrectly filter claims. The Generated SQL is syntactically invalid (missing table alias, incomplete subquery) and omits required columns. Neither query correctly addresses the business intent, but the Reference query at least attempts to retrieve the required fields and structure. The Generated SQL fails to meet basic syntax requirements and doesn't fulfill the output requirements.", "overall_assessment": "incorrect"}}
{"example_id": 2866, "sql_complexity": "basic SQL", "prompt": "What is the number of hospitals in 'rural_healthcare' table?", "context": "CREATE TABLE rural_healthcare (name VARCHAR(255), type VARCHAR(255), location VARCHAR(255)); INSERT INTO rural_healthcare (name, type, location) VALUES ('Rural General Hospital', 'Hospital', 'Bushland'), ('Rural Community Hospital', 'Hospital', 'Forest Region');", "reference_sql": "SELECT COUNT(*) FROM rural_healthcare WHERE type = 'Hospital';", "generated_sql": "code to be tested\n<s> # of hospitals\n<s> QUERY", "raw_model_output": " code to be tested\n<s> # of hospitals\n<s> QUERY", "latency_sec": 0.22895407676696777, "total_duration_sec": 0.186647623, "load_duration_sec": 0.009267708, "tokens_prompt": 112, "prompt_eval_sec": 0.009769626, "tokens_completion": 15, "completion_eval_sec": 0.166832433, "tokens_total": 127, "tokens_per_sec": 554.6963906183778, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The Reference SQL counts all rows in the rural_healthcare table where type is 'Hospital'. The Generated SQL, though not fully visible, appears to target the same metric ('# of hospitals') and likely uses an equivalent query structure. Assuming the Generated SQL correctly implements the same logic, both queries would produce identical results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly counts hospitals by filtering on 'type = 'Hospital''. The generated SQL is missing, so its technical validity and intent fulfillment cannot be confirmed. Without the generated query, we cannot determine equivalence, but the reference query is the only valid one provided. The original question requires counting hospitals, which the reference query addresses directly.", "overall_assessment": "incorrect"}}
{"example_id": 4440, "sql_complexity": "multiple_joins", "prompt": "What is the average session length for each game genre in the last month, sorted by average session length.", "context": "CREATE TABLE game_sessions(id INT, user_id INT, game_name VARCHAR(50), start_time DATETIME, end_time DATETIME); CREATE TABLE games(id INT, name VARCHAR(50), genre VARCHAR(50));", "reference_sql": "SELECT genres.genre, AVG(TIMESTAMPDIFF(SECOND, start_time, end_time)) as avg_session_length FROM game_sessions JOIN games ON game_sessions.game_name = games.name JOIN (SELECT DISTINCT game_name, genre FROM game_sessions JOIN games ON game_sessions.game_name = games.name) genres ON games.name = genres.game_name WHERE start_time >= DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH) GROUP BY genres.genre ORDER BY avg_session_length DESC;", "generated_sql": "SELECT g.name AS game_genre, AVG(gs.end_time - gs.start_time) AS average_session_length FROM game_sessions gs JOIN games g ON gs.game_id = g.id WHERE gs.start_time > (CURRENT_DATE - interval '1 month') AND g.name IN %(number_of_games) GROUP BY game_genre ORDER BY average_session_length NULLS LAST;", "raw_model_output": " Code\n<s> #_of_games = '''Action'', 'Adventure''; SELECT g.name AS game_genre, AVG(gs.end_time - gs.start_time) AS average_session_length FROM game_sessions gs JOIN games g ON gs.game_id = g.id WHERE gs.start_time > (CURRENT_DATE - interval '1 month') AND g.name IN %(number_of_games) GROUP BY game_genre ORDER BY average_session_length NULLS LAST;", "latency_sec": 1.4177649021148682, "total_duration_sec": 1.365600384, "load_duration_sec": 0.010178845, "tokens_prompt": 101, "prompt_eval_sec": 0.006875541, "tokens_completion": 129, "completion_eval_sec": 1.347922188, "tokens_total": 230, "tokens_per_sec": 162.2271786083228, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in several key aspects. 1) The join conditions are different: the Reference SQL joins on game_name, while the Generated SQL joins on game_id (which doesn't exist in the schema). 2) The calculation of session length differs: TIMESTAMPDIFF(SECOND, ...) vs end_time - start_time. 3) The WHERE clause uses different date conditions. 4) The Generated SQL includes an IN clause with a parameter not present in the Reference SQL. 5) The grouping and ordering differ. These differences ensure the queries will not produce the same results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly addresses the business intent by grouping by genre and calculating average session length. It uses proper JOINs between game_sessions and games tables, filters sessions from the last month, and sorts by average session length. The generated query has multiple issues: 1) It incorrectly joins on game_id (which doesn't exist in the schema) instead of game_name 2) It groups by game name (g.name) instead of genre 3) The WHERE clause uses an undefined placeholder %(number_of_games) 4) The date filter uses interval '1 month' which is invalid syntax in MySQL 5) The ORDER BY clause uses NULLS LAST which is not standard SQL. The reference query is technically correct and semantically aligned with the business question.", "overall_assessment": "incorrect"}}
{"example_id": 451, "sql_complexity": "single join", "prompt": "Which customers have made a transaction over 500 in the \"risk_management\" category?", "context": "CREATE TABLE customers (id INT, name VARCHAR(50), category VARCHAR(50)); INSERT INTO customers (id, name, category) VALUES (1, 'John Doe', 'risk_management'); INSERT INTO customers (id, name, category) VALUES (2, 'Jane Smith', 'compliance'); INSERT INTO customers (id, name, category) VALUES (3, 'Jim Brown', 'risk_management'); CREATE TABLE transactions (id INT, customer_id INT, amount DECIMAL(10, 2)); INSERT INTO transactions (id, customer_id, amount) VALUES (1, 1, 500.00); INSERT INTO transactions (id, customer_id, amount) VALUES (2, 1, 200.00); INSERT INTO transactions (id, customer_id, amount) VALUES (3, 2, 100.00); INSERT INTO transactions (id, customer_id, amount) VALUES (4, 3, 750.00);", "reference_sql": "SELECT c.name FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE c.category = 'risk_management' AND t.amount > 500;", "generated_sql": "SELECT c.name FROM customers AS c JOIN transactions AS t ON c.id = t.customer_id WHERE category = 'risk_management' AND amount > 500;", "raw_model_output": " Code\nSELECT c.name FROM customers AS c JOIN transactions AS t ON c.id = t.customer_id WHERE category = 'risk_management' AND amount > 500;", "latency_sec": 0.8345270156860352, "total_duration_sec": 0.533285155, "load_duration_sec": 0.008454848, "tokens_prompt": 295, "prompt_eval_sec": 0.018219538, "tokens_completion": 43, "completion_eval_sec": 0.505960665, "tokens_total": 338, "tokens_per_sec": 405.01984195459767, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between customers and transactions on customer_id. The WHERE clause filters for 'risk_management' category and amount > 500. The generated query omits table aliases in the WHERE clause, but since 'category' exists only in customers and 'amount' exists only in transactions, the column references are unambiguous. The semantic result (Jim Brown) remains the same.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries correctly identify customers in the 'risk_management' category with transactions over 500. The Reference SQL explicitly qualifies columns with table aliases (c.category, t.amount), which improves clarity and avoids potential ambiguity if columns with the same name exist in multiple tables. The Generated SQL omits table aliases for columns in the WHERE clause, which works in this specific case due to unique column names but is less robust in general. Both produce identical results, but the Reference version is more technically precise and maintainable.", "overall_assessment": "correct"}}
{"example_id": 2879, "sql_complexity": "basic SQL", "prompt": "Update the FoodSafetyRecords.OrganicFarms table to include a new record for a certified organic farm in Kenya.", "context": "CREATE TABLE FoodSafetyRecords.OrganicFarms (farmName TEXT, country TEXT, certified BOOLEAN);", "reference_sql": "INSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('Ngong Organic Farm', 'Kenya', TRUE);", "generated_sql": "SELECT COUNT(*) FROM FoodSafetyRecords.OrganicFarms WHERE certified = TRUE AND farmName ILIKE '%organic%' AND country ILIKE '%kenya%');", "raw_model_output": " Code\n<s> #_of_certified_organic_farms_in_kenya = (SELECT COUNT(*) FROM FoodSafetyRecords.OrganicFarms WHERE certified = TRUE AND farmName ILIKE '%organic%' AND country ILIKE '%kenya%');", "latency_sec": 1.5042810440063477, "total_duration_sec": 0.689871213, "load_duration_sec": 0.014398818, "tokens_prompt": 69, "prompt_eval_sec": 0.008136968, "tokens_completion": 64, "completion_eval_sec": 0.665714853, "tokens_total": 133, "tokens_per_sec": 88.41432957619506, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL inserts a new record into the OrganicFarms table, while the Generated SQL counts existing records matching specific criteria. They perform opposite operations (insert vs. select) and have different purposes. The INSERT does not produce a result set, whereas the SELECT returns a count. Even if the conditions in the SELECT matched the inserted data, the queries themselves are not semantically equivalent due to their distinct functionalities.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly uses an INSERT statement to add a new certified organic farm record to the table, while the Generated SQL is a SELECT query that only counts existing records. The Reference directly addresses the business intent of adding new data, whereas the Generated SQL serves a completely different purpose (data inspection). The Generated query neither modifies the database nor attempts to insert the required record, making it irrelevant to the original request.", "overall_assessment": "incorrect"}}
{"example_id": 5688, "sql_complexity": "single join", "prompt": "What is the total amount donated to a specific cause?", "context": "CREATE TABLE causes (id INT, name TEXT); CREATE TABLE donations (id INT, donor_id INT, cause_id INT, donation_amount DECIMAL(10,2)); INSERT INTO causes (id, name) VALUES (1, 'Cause A'), (2, 'Cause B'); INSERT INTO donations (id, donor_id, cause_id, donation_amount) VALUES (1, 1, 1, 50.00), (2, 2, 1, 100.00);", "reference_sql": "SELECT SUM(donation_amount) FROM donations JOIN causes ON donations.cause_id = causes.id WHERE causes.name = 'Cause A';", "generated_sql": "SELECT SUM(donations.donation_amount) AS total_donation_amount FROM donations WHERE donations.cause_id = 1;", "raw_model_output": " Code\n<s> QUERY SELECT SUM(donations.donation_amount) AS total_donation_amount FROM donations WHERE donations.cause_id = 1;", "latency_sec": 0.5614521503448486, "total_duration_sec": 0.477056251, "load_duration_sec": 0.008162267, "tokens_prompt": 162, "prompt_eval_sec": 0.010149483, "tokens_completion": 42, "completion_eval_sec": 0.458137518, "tokens_total": 204, "tokens_per_sec": 363.34351889952063, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses a JOIN with a condition on causes.name='Cause A', which could match multiple cause IDs if names were duplicated. The Generated SQL directly filters on cause_id=1, which is specific to the sample data. While they produce the same result in the given context, they are not semantically equivalent in general cases where cause names might not uniquely map to IDs.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the total donations for a specific cause. The reference query uses a JOIN with the causes table to filter by cause name, while the generated query directly filters by cause_id. In the provided dataset, both approaches yield the same result (150.00) because cause_id=1 corresponds to 'Cause A'. However, the generated query is more efficient as it avoids an unnecessary JOIN, directly filtering on the known cause_id. The reference query is more flexible if the cause name might change or if the ID is unknown, but the original question implies a specific cause (likely identified by ID). Both fulfill the business intent, but the generated query is technically superior due to its simplicity and performance.", "overall_assessment": "correct"}}
{"example_id": 3273, "sql_complexity": "multiple_joins", "prompt": "List all departments, the number of chemicals they handle, and the number of machines used in their manufacturing processes.", "context": "CREATE TABLE Departments (DepartmentID INT, DepartmentName VARCHAR(20)); INSERT INTO Departments (DepartmentID, DepartmentName) VALUES (1, 'Manufacturing'), (2, 'Engineering'), (3, 'Chemical Safety'), (4, 'Product Development'); CREATE TABLE Chemicals (ChemicalID INT, ChemicalName VARCHAR(20), DepartmentID INT); INSERT INTO Chemicals (ChemicalID, ChemicalName, DepartmentID) VALUES (1, 'Hydrochloric Acid', 1), (2, 'Nitric Acid', 2), (3, 'Sodium Hydroxide', 3), (4, 'New Chemical', 4); CREATE TABLE Machinery (MachineID INT, MachineName VARCHAR(20), DepartmentID INT); INSERT INTO Machinery (MachineID, MachineName, DepartmentID) VALUES (1, 'Mixer 1', 1), (2, 'Cutter 2', 2), (3, 'Dispenser 3', 3), (4, 'Innovator 4', 4);", "reference_sql": "SELECT D.DepartmentName, COUNT(C.ChemicalID) AS ChemicalCount, COUNT(M.MachineID) AS MachineCount FROM Departments D LEFT JOIN Chemicals C ON D.DepartmentID = C.DepartmentID LEFT JOIN Machinery M ON D.DepartmentID = M.DepartmentID GROUP BY D.DepartmentName;", "generated_sql": "SELECT d.departmentid, d.departmentname, COUNT(c.chemicalid) AS num_chemicals, COUNT(m.machineid) AS num_machines FROM departments d LEFT JOIN chemicals c ON d.departmentid = c.departmentid LEFT JOIN machinery m ON d.departmentid = m.departmentid GROUP BY d.departmentid, d.departmentname;", "raw_model_output": " Code\n<s> SELECT d.departmentid, d.departmentname, COUNT(c.chemicalid) AS num_chemicals, COUNT(m.machineid) AS num_machines FROM departments d LEFT JOIN chemicals c ON d.departmentid = c.departmentid LEFT JOIN machinery m ON d.departmentid = m.departmentid GROUP BY d.departmentid, d.departmentname;", "latency_sec": 1.3547279834747314, "total_duration_sec": 1.255618538, "load_duration_sec": 0.01069227, "tokens_prompt": 301, "prompt_eval_sec": 0.019071328, "tokens_completion": 110, "completion_eval_sec": 1.224903618, "tokens_total": 411, "tokens_per_sec": 303.38193719585627, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects DepartmentName and groups by it, while the Generated SQL selects DepartmentID and DepartmentName and groups by both. Although the data may overlap, the output columns differ (DepartmentName vs. DepartmentID + DepartmentName) and the grouping strategy varies, leading to different result structures.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries correctly count chemicals and machines per department using LEFT JOINs. The Reference query groups by DepartmentName (which is unique in the sample data) and returns DepartmentName as requested. The Generated query groups by DepartmentID and DepartmentName (redundant but technically valid) and includes DepartmentID in the output, which was not requested. While both would produce identical results in this specific dataset, the Reference better aligns with the business intent by returning the exact columns specified (DepartmentName instead of DepartmentID). The Generated query's inclusion of DepartmentID introduces unnecessary data and slightly reduces clarity.", "overall_assessment": "correct"}}
{"example_id": 1895, "sql_complexity": "window functions", "prompt": "What is the average safety score of chemical production sites in the United States, partitioned by state and ranked in descending order?", "context": "CREATE TABLE production_sites (site_id INT, site_name TEXT, country TEXT, state TEXT, safety_score FLOAT); INSERT INTO production_sites (site_id, site_name, country, state, safety_score) VALUES (1, 'Site A', 'USA', 'NY', 92.5), (2, 'Site B', 'USA', 'CA', 87.4), (3, 'Site C', 'USA', 'TX', 95.3), (4, 'Site D', 'USA', 'FL', 89.2);", "reference_sql": "SELECT state, AVG(safety_score) as avg_safety_score, ROW_NUMBER() OVER (ORDER BY AVG(safety_score) DESC) as rank FROM production_sites WHERE country = 'USA' GROUP BY state ORDER BY rank;", "generated_sql": "SELECT state, AVG(safety_score) AS avg_safety_score FROM production_sites WHERE country = 'USA' GROUP BY state ORDER BY avg_safety_score DESC NULLS LAST;", "raw_model_output": " Code\n<s> SELECT state, AVG(safety_score) AS avg_safety_score FROM production_sites WHERE country = 'USA' GROUP BY state ORDER BY avg_safety_score DESC NULLS LAST;", "latency_sec": 0.6862976551055908, "total_duration_sec": 0.679917281, "load_duration_sec": 0.009474765, "tokens_prompt": 177, "prompt_eval_sec": 0.011449614, "tokens_completion": 60, "completion_eval_sec": 0.658296441, "tokens_total": 237, "tokens_per_sec": 345.3312104986519, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL includes a ROW_NUMBER() column as 'rank' which the Generated SQL lacks. Additionally, the Reference SQL orders by 'rank' (which is derived from the average safety score) while the Generated SQL orders directly by 'avg_safety_score DESC'. Although the ordering logic might produce similar row sequences, the presence of an extra column in the Reference SQL makes the result sets structurally different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL contains a critical technical error: it attempts to use the aggregate function AVG(safety_score) directly in the ROW_NUMBER() window function's ORDER BY clause, which is invalid syntax in standard SQL (aliases/aggregate functions cannot be referenced in window function ORDER BY). Additionally, the final ORDER BY rank would produce sequential row numbers rather than correctly ordering the states by their average safety scores. The Generated SQL correctly calculates the average per state, orders results by the average in descending order, and avoids unnecessary complexity. While neither query includes an explicit 'rank' column (which might be required for true ranking), the Generated SQL directly addresses the business intent of ordering by average score. The Reference SQL's approach is both syntactically incorrect and semantically flawed for the requested ranking.", "overall_assessment": "differently_correct"}}
{"example_id": 4669, "sql_complexity": "set operations", "prompt": "Identify the number of IoT devices in each country and the total number of devices.", "context": "CREATE TABLE device_country (device_id INT, country TEXT); INSERT INTO device_country (device_id, country) VALUES (1, 'USA'), (2, 'Canada'), (3, 'Mexico'), (4, 'Brazil'); CREATE TABLE device_info (device_id INT, device_type TEXT); INSERT INTO device_info (device_id, device_type) VALUES (1, 'Soil Sensor'), (2, 'Temperature Sensor'), (3, 'Humidity Sensor'), (4, 'Precision Sprayer');", "reference_sql": "SELECT country, COUNT(*) AS device_count FROM device_country GROUP BY country UNION SELECT 'Total' AS country, COUNT(*) FROM device_country;", "generated_sql": "SELECT device_country.country, COUNT(device_info.device_id) AS device_count FROM device_country JOIN device_info ON device_country.device_id = device_info.device_id GROUP BY device_country.country ORDER BY device_country.country NULLS LAST;", "raw_model_output": " Code\n<s> SELECT device_country.country, COUNT(device_info.device_id) AS device_count FROM device_country JOIN device_info ON device_country.device_id = device_info.device_id GROUP BY device_country.country ORDER BY device_country.country NULLS LAST;", "latency_sec": 0.8286821842193604, "total_duration_sec": 0.821524142, "load_duration_sec": 0.008163175, "tokens_prompt": 170, "prompt_eval_sec": 0.010403643, "tokens_completion": 74, "completion_eval_sec": 0.802278169, "tokens_total": 244, "tokens_per_sec": 294.44340019190133, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a 'Total' row in its result set via a UNION, while the Generated SQL does not. The Generated SQL also performs a JOIN with device_info, which is unnecessary since device_country already contains all required device data. Additionally, the Generated SQL adds an ORDER BY clause not present in the Reference SQL, though this affects ordering rather than content. The core discrepancy is the missing 'Total' row in the Generated SQL.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly addresses both parts of the business question by using GROUP BY to count devices per country and a UNION to add a 'Total' row. The generated query only provides per-country counts without the total, failing to fulfill the requirement for the overall device count. While the generated query is technically correct in its syntax and logic for per-country counts, it omits the critical 'Total' row. The reference query is more elegant and directly aligns with the business intent of reporting both per-country and total device counts.", "overall_assessment": "incorrect"}}
{"example_id": 5302, "sql_complexity": "multiple_joins", "prompt": "Find the supplier with the lowest average delivery time for orders in the last month.", "context": "CREATE TABLE Suppliers (SupplierID int, SupplierName varchar(50)); CREATE TABLE Products (ProductID int, ProductName varchar(50), SupplierID int); CREATE TABLE Orders (OrderID int, ProductID int, OrderDate date, DeliveryTime int); INSERT INTO Suppliers VALUES (1, 'SupplierA'), (2, 'SupplierB'); INSERT INTO Products VALUES (1, 'Organic Apples', 1), (2, 'Bananas', 2); INSERT INTO Orders VALUES (1, 1, '2022-01-01', 2), (2, 2, '2022-01-03', 3);", "reference_sql": "SELECT SupplierName, AVG(DeliveryTime) as AvgDeliveryTime FROM Orders o JOIN Products p ON o.ProductID = p.ProductID JOIN Suppliers sp ON p.SupplierID = sp.SupplierID WHERE OrderDate >= DATEADD(month, -1, GETDATE()) GROUP BY SupplierName ORDER BY AvgDeliveryTime ASC;", "generated_sql": "SELECT s.suppliername, AVG(o.deliverytime) AS average_delivery_time FROM orders o JOIN products p ON o.productid = p.productid JOIN suppliers s ON p.supplierid = s.supplierid WHERE o.orderdate >= (CURRENT_DATE - interval '1 month') GROUP BY s.suppliername ORDER BY average_delivery_time ASC LIMIT 1;", "raw_model_output": " Code\n<s> SELECT s.suppliername, AVG(o.deliverytime) AS average_delivery_time FROM orders o JOIN products p ON o.productid = p.productid JOIN suppliers s ON p.supplierid = s.supplierid WHERE o.orderdate >= (CURRENT_DATE - interval '1 month') GROUP BY s.suppliername ORDER BY average_delivery_time ASC LIMIT 1;", "latency_sec": 1.1735351085662842, "total_duration_sec": 1.128439971, "load_duration_sec": 0.008371864, "tokens_prompt": 206, "prompt_eval_sec": 0.014417739, "tokens_completion": 101, "completion_eval_sec": 1.104739015, "tokens_total": 307, "tokens_per_sec": 261.6027400961732, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The generated query includes a LIMIT 1 clause which restricts the result to a single row, while the reference query does not have this limitation. This makes their result sets semantically different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in two key aspects. 1) The generated query uses LIMIT 1 to directly retrieve the supplier with the lowest average delivery time, while the reference query returns all suppliers sorted by average delivery time. 2) The date calculation syntax differs (DATEADD vs CURRENT_DATE - interval), but both correctly identify orders from the last month. The generated query better fulfills the business intent by directly answering the question of 'which supplier' rather than just providing a sorted list. However, neither query handles potential ties in average delivery time. The generated query is more efficient and elegant by using LIMIT 1.", "overall_assessment": "differently_correct"}}
{"example_id": 267, "sql_complexity": "subqueries", "prompt": "What is the total number of disability support programs offered in urban and rural areas, and the percentage of total programs for each area type?", "context": "CREATE TABLE programs (program_id INT, program_name VARCHAR(255), area_type VARCHAR(255));", "reference_sql": "SELECT area_type, COUNT(*) as total_programs, ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM programs) , 2) as percentage_of_total FROM programs WHERE area_type IN ('urban', 'rural') GROUP BY area_type;", "generated_sql": "SELECT COUNT(*) FROM programs WHERE area_type ILIKE '%urban%' OR area_type ILIKE '%rural%');", "raw_model_output": " Code\n<s> #_of_programs = (SELECT COUNT(*) FROM programs WHERE area_type ILIKE '%urban%' OR area_type ILIKE '%rural%'); SELECT CAST(COUNT(*) filter (WHERE area_type ILIKE '%urban%') AS FLOAT) / NULLIF(cast(count(*) filter (WHERE area_type ILIKE '%rural%') AS FLOAT), 0) AS urban_to_rural_ratio, CAST(COUNT(*) filter (WHERE area_type ILIKE '%rural%') AS FLOAT) / NULLIF(cast(count(*) filter (WHERE area_type ILIKE '%urban%') AS FLOAT), 0) AS rural_to_urban_ratio FROM programs;", "latency_sec": 2.1419429779052734, "total_duration_sec": 1.942290997, "load_duration_sec": 0.008395647, "tokens_prompt": 73, "prompt_eval_sec": 0.005552258, "tokens_completion": 183, "completion_eval_sec": 1.927759498, "tokens_total": 256, "tokens_per_sec": 119.51765413024991, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates counts and percentages for exact 'urban'/'rural' area_types, while the Generated SQL counts programs with area_type containing 'urban' or 'rural' as substrings (case-insensitive). The Generated SQL also lacks grouping, percentages, and the exact 'IN' filter.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference SQL correctly addresses the business question by: 1) Grouping programs by area_type ('urban'/'rural'), 2) Calculating both absolute counts and percentages relative to total programs. The generated SQL only counts programs matching 'urban'/'rural' patterns (without grouping) and completely omits percentage calculations. The reference query uses a subquery for accurate percentage calculation, while the generated query returns a single total count instead of separate metrics for each area type.", "overall_assessment": "incorrect"}}
{"example_id": 3028, "sql_complexity": "basic SQL", "prompt": "What is the number of startups founded by non-binary individuals in the technology industry?", "context": "CREATE TABLE company (id INT, name TEXT, founder_gender TEXT, industry TEXT); INSERT INTO company (id, name, founder_gender, industry) VALUES (1, 'CodeForAll', 'Non-binary', 'Technology'); INSERT INTO company (id, name, founder_gender, industry) VALUES (2, 'TechVillage', 'Male', 'Technology');", "reference_sql": "SELECT COUNT(*) FROM company WHERE founder_gender = 'Non-binary' AND industry = 'Technology';", "generated_sql": "SELECT COUNT(*) FROM company WHERE founder_gender = 'Non-binary' AND industry = 'Technology';", "raw_model_output": " Code\n<s> # of startups founded by non-binary individuals in the technology industry SELECT COUNT(*) FROM company WHERE founder_gender = 'Non-binary' AND industry = 'Technology';", "latency_sec": 0.5312981605529785, "total_duration_sec": 0.503481705, "load_duration_sec": 0.010066824, "tokens_prompt": 128, "prompt_eval_sec": 0.012409663, "tokens_completion": 44, "completion_eval_sec": 0.479462439, "tokens_total": 172, "tokens_per_sec": 323.735357602182, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure and logic. Both queries count rows from the 'company' table where 'founder_gender' is 'Non-binary' and 'industry' is 'Technology'. Since the SQL statements are exactly the same, they will produce identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure, logic, and conditions. They correctly count companies where founder_gender is 'Non-binary' and industry is 'Technology', matching the business requirement. The sample data would return 1, which is accurate. Neither query demonstrates superior efficiency or elegance since they are functionally identical.", "overall_assessment": "correct"}}
{"example_id": 3282, "sql_complexity": "aggregation", "prompt": "Which marine species have been observed in both the Arctic and Antarctic oceans?", "context": "CREATE TABLE marine_species (id INT, species_name VARCHAR(50), common_name VARCHAR(50), region VARCHAR(20));INSERT INTO marine_species (id, species_name, common_name, region) VALUES (1, 'Orcinus_orca', 'Killer Whale', 'Arctic');INSERT INTO marine_species (id, species_name, common_name, region) VALUES (2, 'Balaenoptera_bonaerensis', 'Antarctic Minke Whale', 'Antarctic');", "reference_sql": "SELECT species_name FROM marine_species WHERE region IN ('Arctic', 'Antarctic') GROUP BY species_name HAVING COUNT(DISTINCT region) = 2;", "generated_sql": "SELECT marine_species.species_name, marine_species.common_name FROM marine_species WHERE region ILIKE '%Arctic%' AND region ILIKE '%Antarctic%';", "raw_model_output": " Code\nSELECT marine_species.species_name, marine_species.common_name FROM marine_species WHERE region ILIKE '%Arctic%' AND region ILIKE '%Antarctic%';", "latency_sec": 0.842418909072876, "total_duration_sec": 0.545913395, "load_duration_sec": 0.008731792, "tokens_prompt": 165, "prompt_eval_sec": 0.010402422, "tokens_completion": 48, "completion_eval_sec": 0.526104814, "tokens_total": 213, "tokens_per_sec": 252.8433273588518, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query selects species present in both 'Arctic' and 'Antarctic' regions (via GROUP BY/HAVING), while the generated query incorrectly uses ILIKE to search for regions containing both substrings (which is impossible since regions are single values). Additionally, the generated query selects an extra column (common_name) not present in the reference.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly identifies species present in both regions by grouping by species_name and checking for two distinct regions. The generated query uses ILIKE with '%Arctic%' and '%Antarctic%' on the same region field, which is impossible since each record has a single region value. This makes the generated query logically flawed and guaranteed to return no results. While the reference query is efficient and semantically correct, the generated query fails to meet the business intent entirely.", "overall_assessment": "incorrect"}}
{"example_id": 3474, "sql_complexity": "subqueries", "prompt": "What is the total transaction volume for the top 3 digital assets by market capitalization in the 'developed_markets' schema?", "context": "CREATE SCHEMA developed_markets; CREATE TABLE developed_markets.digital_assets (asset_name VARCHAR(10), market_cap BIGINT, daily_transaction_volume BIGINT); INSERT INTO developed_markets.digital_assets (asset_name, market_cap, daily_transaction_volume) VALUES ('AssetG', 30000000, 15000000), ('AssetH', 25000000, 12000000), ('AssetI', 20000000, 10000000), ('AssetJ', 15000000, 8000000), ('AssetK', 10000000, 6000000);", "reference_sql": "SELECT SUM(daily_transaction_volume) FROM (SELECT daily_transaction_volume FROM developed_markets.digital_assets ORDER BY market_cap DESC FETCH NEXT 3 ROWS ONLY) t;", "generated_sql": "SELECT developed_markets.digital_assets.asset_name, SUM(daily_transaction_volume) AS total_daily_transaction_volume FROM developed_markets.digital_assets GROUP BY developed_markets.digital_assets.asset_name ORDER BY market_cap DESC NULLS LAST LIMIT 3;", "raw_model_output": " Code\n<s> SELECT developed_markets.digital_assets.asset_name, SUM(daily_transaction_volume) AS total_daily_transaction_volume FROM developed_markets.digital_assets GROUP BY developed_markets.digital_assets.asset_name ORDER BY market_cap DESC NULLS LAST LIMIT 3;", "latency_sec": 1.0644500255584717, "total_duration_sec": 0.935518417, "load_duration_sec": 0.008339988, "tokens_prompt": 242, "prompt_eval_sec": 0.015264741, "tokens_completion": 82, "completion_eval_sec": 0.910998803, "tokens_total": 324, "tokens_per_sec": 304.3825376677604, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns a single aggregated sum of the top 3 daily_transaction_volume values, while the Generated SQL returns 3 rows of individual asset details with their daily_transaction_volume. The output structure and purpose differ: one is a scalar sum, the other is a set of rows. Additionally, the Generated SQL's GROUP BY and ORDER BY combination may not behave as intended due to non-aggregated columns in ORDER BY.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly calculates the total transaction volume for the top 3 assets by market cap. It uses a subquery to select the top 3 assets (ordered by market_cap DESC) and sums their daily_transaction_volume. The Generated SQL has multiple issues: 1) It groups by asset_name but doesn't need to since each row represents a unique asset, 2) The ORDER BY market_cap DESC is invalid in this context (market_cap isn't in GROUP BY or aggregate), 3) It returns individual asset volumes instead of a total sum, 4) The NULLS LAST clause is unnecessary. The Reference SQL is both technically correct and directly addresses the business intent of calculating a total volume.", "overall_assessment": "incorrect"}}
{"example_id": 1626, "sql_complexity": "aggregation", "prompt": "Find the total value of social impact bonds issued by each organization.", "context": "CREATE TABLE social_impact_bonds (id INT, organization_name VARCHAR(255), issue_year INT, value FLOAT); INSERT INTO social_impact_bonds (id, organization_name, issue_year, value) VALUES (1, 'Acme Corp', 2018, 2000000), (2, 'XYZ Foundation', 2019, 3000000), (3, 'Global Giving', 2018, 1500000), (4, 'Acme Corp', 2019, 2500000), (5, 'XYZ Foundation', 2018, 1000000);", "reference_sql": "SELECT organization_name, SUM(value) as total_value FROM social_impact_bonds GROUP BY organization_name;", "generated_sql": "SELECT acme_corp.id, SUM(acme_corp.value) AS total_value FROM social_impact_bonds AS acme_corp GROUP BY acme_corp.id;", "raw_model_output": " Code\n<s> SELECT acme_corp.id, SUM(acme_corp.value) AS total_value FROM social_impact_bonds AS acme_corp GROUP BY acme_corp.id;", "latency_sec": 0.9337868690490723, "total_duration_sec": 0.63399733, "load_duration_sec": 0.008619263, "tokens_prompt": 207, "prompt_eval_sec": 0.012727678, "tokens_completion": 55, "completion_eval_sec": 0.611942397, "tokens_total": 262, "tokens_per_sec": 280.57794415850947, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL groups by organization_name to aggregate total values per organization, while the Generated SQL groups by id (a unique identifier) which prevents true aggregation. The Generated SQL also selects id instead of organization_name, leading to different result structures and values.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly groups by organization_name and sums values, fulfilling the business intent of aggregating bonds per organization. The generated query groups by id (a unique identifier), resulting in individual bond values rather than aggregated totals. While both are syntactically valid, they produce fundamentally different results. The reference query is semantically correct and efficient, while the generated query fails to address the actual business question.", "overall_assessment": "incorrect"}}
{"example_id": 1315, "sql_complexity": "single join", "prompt": "List all the transactions made by clients living in New York with a transaction amount greater than $1000.", "context": "CREATE TABLE transactions (id INT, client_id INT, transaction_amount DECIMAL(10,2), transaction_date DATE); INSERT INTO transactions (id, client_id, transaction_amount, transaction_date) VALUES (1, 3, 1500.00, '2022-01-01'), (2, 4, 800.00, '2022-01-02'), (3, 3, 1200.00, '2022-01-03'); CREATE TABLE clients (id INT, name VARCHAR(255), state VARCHAR(255)); INSERT INTO clients (id, name, state) VALUES (3, 'Mike Johnson', 'New York'), (4, 'Sara Lee', 'California');", "reference_sql": "SELECT transactions.id, transactions.client_id, transactions.transaction_amount, transactions.transaction_date FROM transactions INNER JOIN clients ON transactions.client_id = clients.id WHERE clients.state = 'New York' AND transactions.transaction_amount > 1000.00;", "generated_sql": "SELECT t.id, t.client_id, t.transaction_amount, t.transaction_date FROM transactions AS t JOIN clients AS c ON t.client_id = c.id WHERE c.state = 'New York' AND transaction_amount > 1000;", "raw_model_output": " Code\n<s> SELECT t.id, t.client_id, t.transaction_amount, t.transaction_date FROM transactions AS t JOIN clients AS c ON t.client_id = c.id WHERE c.state = 'New York' AND transaction_amount > 1000;", "latency_sec": 0.9542129039764404, "total_duration_sec": 0.760125876, "load_duration_sec": 0.008069012, "tokens_prompt": 238, "prompt_eval_sec": 0.013719307, "tokens_completion": 66, "completion_eval_sec": 0.737699544, "tokens_total": 304, "tokens_per_sec": 318.58718188902816, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an INNER JOIN between transactions and clients on client_id, filter for clients in 'New York' and transactions over 1000. The generated query uses table aliases (t/c) but retains the same logical structure, column selections, and WHERE conditions. The transaction_amount condition is unambiguous in both cases as it originates from the transactions table.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries correctly retrieve transactions meeting the criteria. The reference query uses explicit table qualifiers for all columns, ensuring clarity and avoiding potential ambiguity. The generated query uses aliases but omits table qualifiers for 'transaction_amount'\u2014this works in this specific schema (since the column exists only in 'transactions') but is less robust in general cases. While both produce identical results, the reference query is more explicit and adheres to best practices for readability and maintainability.", "overall_assessment": "correct"}}
{"example_id": 520, "sql_complexity": "multiple_joins", "prompt": "What is the total number of electric vehicles sold in 'California' in the 'sales' schema?", "context": "CREATE TABLE sales_regions (id INT, name VARCHAR(50));   CREATE TABLE sales (id INT, region_id INT, vehicle_count INT);   CREATE TABLE vehicles (id INT, type VARCHAR(50));   INSERT INTO sales_regions VALUES (1, 'California');   INSERT INTO sales VALUES (1, 1, 5000);   INSERT INTO vehicles VALUES (1, 'electric');", "reference_sql": "SELECT SUM(sales.vehicle_count) FROM sales INNER JOIN sales_regions ON sales.region_id = sales_regions.id INNER JOIN vehicles ON sales.id = vehicles.id WHERE vehicles.type = 'electric' AND sales_regions.name = 'California';", "generated_sql": "SELECT SUM(s.vehicle_count) AS total_vehicles FROM sales s JOIN sales_regions r ON s.region_id = r.id WHERE r.name ilike '%California%');", "raw_model_output": " Code\n<s> # of electric vehicles sold = (SELECT SUM(s.vehicle_count) AS total_vehicles FROM sales s JOIN sales_regions r ON s.region_id = r.id WHERE r.name ilike '%California%');", "latency_sec": 0.8471601009368896, "total_duration_sec": 0.65029763, "load_duration_sec": 0.009137664, "tokens_prompt": 149, "prompt_eval_sec": 0.010040704, "tokens_completion": 58, "completion_eval_sec": 0.630510913, "tokens_total": 207, "tokens_per_sec": 244.34578513680586, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL joins with the 'vehicles' table and filters by 'vehicles.type = 'electric'', while the Generated SQL omits this join and filter. Additionally, the Generated SQL uses a case-insensitive partial match ('ilike '%California%'') instead of an exact match ('= 'California''). These differences would produce different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly joins all three tables (sales, sales_regions, vehicles) and filters for 'electric' vehicles in 'California' using exact string matching. The generated query lacks the vehicles table join, omitting the critical 'electric' type filter. It also uses 'ilike' with wildcards, which would match any region name containing 'California' (e.g., 'california', 'CALIFORNIA', or 'California City') rather than exact matches. This makes the generated query both logically incomplete and semantically inaccurate for the original question.", "overall_assessment": "incorrect"}}
{"example_id": 3999, "sql_complexity": "single join", "prompt": "What is the total number of tickets sold for performances with a rating of 5?", "context": "CREATE TABLE performance (id INT PRIMARY KEY, name VARCHAR(255), date DATE, artist_id INT, rating INT); INSERT INTO performance (id, name, date, artist_id, rating) VALUES (1, 'Dance Recital', '2022-03-01', 1, 5);", "reference_sql": "SELECT SUM(t.quantity) as total_tickets_sold FROM performance p INNER JOIN ticket t ON p.id = t.performance_id WHERE p.rating = 5;", "generated_sql": "SELECT COUNT(*) AS total_tickets FROM performance WHERE rating = 5);", "raw_model_output": " Code\n<s> #_of_tickets = (SELECT COUNT(*) AS total_tickets FROM performance WHERE rating = 5);", "latency_sec": 0.5396542549133301, "total_duration_sec": 0.342764848, "load_duration_sec": 0.008582129, "tokens_prompt": 113, "prompt_eval_sec": 0.008584462, "tokens_completion": 30, "completion_eval_sec": 0.324890292, "tokens_total": 143, "tokens_per_sec": 264.9844760752719, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the total tickets sold (sum of ticket quantities) for performances with a rating of 5, requiring a join with the ticket table. The Generated SQL simply counts the number of performances with a rating of 5, without considering ticket data. They differ in both the calculation (SUM vs COUNT) and the tables involved (requires join vs single table).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly joins the performance and ticket tables to sum ticket quantities for 5-star performances, while the generated query only counts the number of 5-rated performances without accessing ticket data. The original question requires aggregating ticket quantities (SUM(t.quantity)), but the generated query uses COUNT(*) which measures performance count instead. This fundamental difference in data source and aggregation method makes them non-equivalent. The reference query technically and semantically addresses the business intent of measuring ticket sales volume.", "overall_assessment": "incorrect"}}
{"example_id": 2261, "sql_complexity": "multiple_joins", "prompt": "What is the total number of animals that have been released into 'protected' habitats, and the average weight of those animals?", "context": "CREATE TABLE habitats (habitat_id INT, habitat_name VARCHAR(50), habitat_status VARCHAR(50)); INSERT INTO habitats (habitat_id, habitat_name, habitat_status) VALUES (1, 'Habitat A', 'protected'), (2, 'Habitat B', 'unprotected'); CREATE TABLE animal_habitats (animal_id INT, habitat_id INT, animal_weight FLOAT); INSERT INTO animal_habitats (animal_id, habitat_id, animal_weight) VALUES (101, 1, 25.5), (102, 2, 15.2); CREATE TABLE animals (animal_id INT, animal_name VARCHAR(50)); INSERT INTO animals (animal_id, animal_name) VALUES (101, 'Dog'), (102, 'Cat');", "reference_sql": "SELECT COUNT(*), AVG(animal_habitats.animal_weight) FROM animal_habitats INNER JOIN animals ON animal_habitats.animal_id = animals.animal_id INNER JOIN habitats ON animal_habitats.habitat_id = habitats.habitat_id WHERE habitats.habitat_status = 'protected';", "generated_sql": "SELECT COUNT(DISTINCT a.animal_id) AS total_animals_released_into_protected_habitats, AVG(ah.animal_weight) AS average_weight_of_animals_released_into_protected_habitats FROM animals a JOIN animal_habitats ah ON a.animal_id = ah.animal_id JOIN habitats h ON ah.habitat_id = h.habitat_id WHERE h.habitat_status = 'protected';", "raw_model_output": " Code\n<s> SELECT COUNT(DISTINCT a.animal_id) AS total_animals_released_into_protected_habitats, AVG(ah.animal_weight) AS average_weight_of_animals_released_into_protected_habitats FROM animals a JOIN animal_habitats ah ON a.animal_id = ah.animal_id JOIN habitats h ON ah.habitat_id = h.habitat_id WHERE h.habitat_status = 'protected';", "latency_sec": 1.5841710567474365, "total_duration_sec": 1.372015874, "load_duration_sec": 0.008218896, "tokens_prompt": 258, "prompt_eval_sec": 0.014701974, "tokens_completion": 122, "completion_eval_sec": 1.348290854, "tokens_total": 380, "tokens_per_sec": 239.87308591548341, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses COUNT(*) which counts all rows in the result set, while the Generated SQL uses COUNT(DISTINCT a.animal_id) which counts unique animal IDs. If any animal_id appears multiple times in the animal_habitats table for protected habitats, the two queries would produce different counts. The AVG calculation is equivalent since both use the same animal_weight column.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in their handling of animal counting. The reference query uses COUNT(*), which counts all rows in the joined result set, potentially overcounting animals that may appear multiple times in the animal_habitats table (e.g., if an animal was released into multiple protected habitats). The generated query uses COUNT(DISTINCT a.animal_id), which correctly counts unique animals, aligning with the business intent of 'total number of animals'. Both calculate the same average weight, but the generated query's approach is more precise for the count metric. The generated query better fulfills the business intent by ensuring accurate animal counts while maintaining equivalent average weight calculation.", "overall_assessment": "differently_correct"}}
{"example_id": 3439, "sql_complexity": "multiple_joins", "prompt": "How many menu items contain ingredients sourced from local suppliers for each restaurant?", "context": "CREATE TABLE restaurants (id INT, name VARCHAR(50), location VARCHAR(50)); INSERT INTO restaurants VALUES (1, 'Restaurant A', 'City A'); INSERT INTO restaurants VALUES (2, 'Restaurant B', 'City B'); CREATE TABLE menu_items (id INT, name VARCHAR(50), restaurant_id INT, price DECIMAL(5,2)); INSERT INTO menu_items VALUES (1, 'Item A', 1, 10.99); INSERT INTO menu_items VALUES (2, 'Item B', 1, 12.99); INSERT INTO menu_items VALUES (3, 'Item C', 2, 11.99); CREATE TABLE ingredients (id INT, name VARCHAR(50), local_source BOOLEAN, menu_item_id INT); INSERT INTO ingredients VALUES (1, 'Ingredient A', TRUE, 1); INSERT INTO ingredients VALUES (2, 'Ingredient B', FALSE, 1); INSERT INTO ingredients VALUES (3, 'Ingredient C', TRUE, 2); INSERT INTO ingredients VALUES (4, 'Ingredient D', FALSE, 2); INSERT INTO ingredients VALUES (5, 'Ingredient E', TRUE, 3);", "reference_sql": "SELECT r.name, COUNT(DISTINCT mi.id) as num_local_items FROM restaurants r JOIN menu_items mi ON r.id = mi.restaurant_id JOIN ingredients i ON mi.id = i.menu_item_id WHERE i.local_source = TRUE GROUP BY r.name;", "generated_sql": "SELECT r.name AS restaurant_name, COUNT(mi.id) AS total_menu_items FROM restaurants r JOIN menu_items mi ON r.id = mi.restaurant_id JOIN ingredients i ON mi.id = i.menu_item_id WHERE local_source = TRUE GROUP BY r.name;", "raw_model_output": " Code\n<s> SELECT r.name AS restaurant_name, COUNT(mi.id) AS total_menu_items FROM restaurants r JOIN menu_items mi ON r.id = mi.restaurant_id JOIN ingredients i ON mi.id = i.menu_item_id WHERE local_source = TRUE GROUP BY r.name;", "latency_sec": 1.7585253715515137, "total_duration_sec": 0.94151852, "load_duration_sec": 0.008611562, "tokens_prompt": 354, "prompt_eval_sec": 0.025503398, "tokens_completion": 78, "completion_eval_sec": 0.906373631, "tokens_total": 432, "tokens_per_sec": 245.66037373623706, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the aggregation function: the Reference SQL uses COUNT(DISTINCT mi.id) while the Generated SQL uses COUNT(mi.id). This means the Generated SQL may count multiple ingredients from the same menu item multiple times, whereas the Reference SQL counts each menu item once. For example, if a menu item has multiple local ingredients, the Generated query would overcount it.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in two critical aspects: 1) The reference uses COUNT(DISTINCT mi.id) while the generated query uses COUNT(mi.id). This means the generated query would count each local ingredient entry rather than unique menu items, potentially overcounting. 2) The generated query omits the DISTINCT keyword which is necessary to ensure each menu item is counted only once per restaurant, even if it has multiple local ingredients. Both queries join the same tables and filter on local_source = TRUE, but the reference correctly addresses the business intent of counting menu items rather than ingredients.", "overall_assessment": "differently_correct"}}
{"example_id": 2265, "sql_complexity": "aggregation", "prompt": "Hourly revenue for a specific movie?", "context": "CREATE TABLE Movie_Revenue (id INT, movie_title VARCHAR(100), revenue_time TIME, revenue DECIMAL(10,2));", "reference_sql": "SELECT revenue_time, SUM(revenue) FROM Movie_Revenue WHERE movie_title = 'Spider-Man: No Way Home' GROUP BY revenue_time;", "generated_sql": "code (Haskell)\n<s> #_of_revenue = SELECT SUM(revenue) FROM Movie_Revenue WHERE movie_title ILIKE '%The%Matrix%Rel%'", "raw_model_output": " code (Haskell)\n<s> #_of_revenue = SELECT SUM(revenue) FROM Movie_Revenue WHERE movie_title ILIKE '%The%Matrix%Rel%'", "latency_sec": 0.6871087551116943, "total_duration_sec": 0.487607925, "load_duration_sec": 0.007465407, "tokens_prompt": 63, "prompt_eval_sec": 0.005839438, "tokens_completion": 45, "completion_eval_sec": 0.473549007, "tokens_total": 108, "tokens_per_sec": 157.18035783497453, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in multiple aspects.  The reference query filters for a specific movie title ('Spider-Man: No Way Home') and groups by revenue_time, while the generated query uses a case-insensitive LIKE pattern ('%The%Matrix%Rel%') and lacks a GROUP BY clause. Additionally, the reference query selects both revenue_time and the sum of revenue, whereas the generated query only selects the sum of revenue. These differences in filtering, grouping, and selected columns make the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly groups by revenue_time and filters for a specific movie title, producing hourly revenue data. The generated query lacks a GROUP BY clause, sums revenue without time segmentation, and uses a pattern-matching filter ('ILIKE') that doesn't align with the 'specific movie' requirement. The generated query's Haskell syntax is also invalid SQL. While both queries involve revenue aggregation, their structural and semantic differences make them non-equivalent. The reference directly addresses the business intent of hourly revenue tracking, whereas the generated query fails to segment by time and uses an ambiguous filter.", "overall_assessment": "incorrect"}}
{"example_id": 1763, "sql_complexity": "multiple_joins", "prompt": "What is the total food and beverage revenue last month for hotels in 'Bangkok'?", "context": "CREATE TABLE revenue (hotel_id INT, revenue_source VARCHAR(50), revenue INT, revenue_date DATE); INSERT INTO revenue (hotel_id, revenue_source, revenue, revenue_date) VALUES (5, 'Room revenue', 12000, '2022-03-01'), (5, 'Food and beverage', 4000, '2022-03-02'), (5, 'Other revenue', 1000, '2022-03-03'); CREATE TABLE hotels (hotel_id INT, city VARCHAR(50)); INSERT INTO hotels (hotel_id, city) VALUES (5, 'Bangkok'); CREATE TABLE dates (date DATE); INSERT INTO dates (date) VALUES ('2022-03-01'), ('2022-03-02'), ('2022-03-03');", "reference_sql": "SELECT SUM(revenue) FROM revenue JOIN hotels ON revenue.hotel_id = hotels.hotel_id JOIN dates ON revenue.revenue_date = dates.date WHERE hotels.city = 'Bangkok' AND revenue_source = 'Food and beverage' AND dates.date >= DATEADD(month, -1, GETDATE());", "generated_sql": "SELECT SUM(revenue) AS total_revenue FROM revenue r JOIN hotels h ON r.hotel_id = h.hotel_id WHERE revenue_source ilike '%Food%and%beverage%' AND city ILIKE '%Bangkok%' AND revenue_date >= (CURRENT_DATE - interval '1 month');", "raw_model_output": " Code\n<s> SELECT SUM(revenue) AS total_revenue FROM revenue r JOIN hotels h ON r.hotel_id = h.hotel_id WHERE revenue_source ilike '%Food%and%beverage%' AND city ILIKE '%Bangkok%' AND revenue_date >= (CURRENT_DATE - interval '1 month');", "latency_sec": 1.2443149089813232, "total_duration_sec": 0.938981291, "load_duration_sec": 0.007771845, "tokens_prompt": 270, "prompt_eval_sec": 0.01771327, "tokens_completion": 81, "completion_eval_sec": 0.912957807, "tokens_total": 351, "tokens_per_sec": 282.08293372242184, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in several key aspects. 1) The Reference query joins with the 'dates' table, which is not present in the Generated query. 2) The revenue_source condition in the Reference is an exact match, while the Generated uses a case-insensitive pattern match. 3) The city condition in the Reference is an exact match, while the Generated uses a case-insensitive substring match. 4) The date condition in the Reference uses DATEADD, while the Generated uses CURRENT_DATE - interval. These differences mean the queries may return different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The Reference SQL is more technically precise for the business intent. It uses exact matches for 'Food and beverage' and 'Bangkok', ensuring accurate filtering. The Generated SQL's pattern matching ('%Food%and%beverage%') risks including unintended revenue sources (e.g., 'Food & Beverage' or 'Food and Beverage Revenue') and cities with partial matches. While the Generated SQL uses a more dynamic date calculation (CURRENT_DATE - interval '1 month'), the Reference's join with the dates table may be unnecessary but doesn't harm correctness. However, the Reference's exact filtering aligns better with the business requirement for 'Food and beverage' revenue. The Generated SQL's broader pattern matching could lead to over-inclusion, making it less precise for the specific question.", "overall_assessment": "correct"}}
{"example_id": 5499, "sql_complexity": "set operations", "prompt": "How many legal aid clinics and community mediation centers are there in total, and what is the sum of cases handled by each type of center, for centers located in the state of California?", "context": "CREATE TABLE LegalAidClinics (ClinicName text, State text, NumCases int); INSERT INTO LegalAidClinics VALUES ('Clinic1', 'CA', 30, '2022-01-01'), ('Clinic2', 'CA', 25, '2022-01-01'); CREATE TABLE CommunityMediationCenters (CenterName text, State text, NumCases int); INSERT INTO CommunityMediationCenters VALUES ('CM1', 'CA', 22, '2022-01-01'), ('CM2', 'CA', 28, '2022-01-01');", "reference_sql": "SELECT State, 'Legal Aid Clinics' AS CenterType, COUNT(*) AS NumCenters, SUM(NumCases) AS TotalCases FROM LegalAidClinics WHERE State = 'CA' UNION ALL SELECT State, 'Community Mediation Centers', COUNT(*), SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA';", "generated_sql": "SELECT coalesce(SUM(legal_aid_clinics.numcases), 0) AS total_legal_aid_clinics_cases, coalesce(SUM(community_medication_centers.numcases), 0) AS total_community_medication_center_cases FROM legal_aid_clinics JOIN community_medication_centers ON legal_aid_clinics.state = community_medication_centers.state WHERE legal_aid_clinics.state = 'CA' AND community_medication_centers.state = 'CA';", "raw_model_output": " Code\n<s> SELECT coalesce(SUM(legal_aid_clinics.numcases), 0) AS total_legal_aid_clinics_cases, coalesce(SUM(community_medication_centers.numcases), 0) AS total_community_medication_center_cases FROM legal_aid_clinics JOIN community_medication_centers ON legal_aid_clinics.state = community_medication_centers.state WHERE legal_aid_clinics.state = 'CA' AND community_medication_centers.state = 'CA';", "latency_sec": 1.6756699085235596, "total_duration_sec": 1.560725954, "load_duration_sec": 0.009622585, "tokens_prompt": 222, "prompt_eval_sec": 0.014609164, "tokens_completion": 139, "completion_eval_sec": 1.53568242, "tokens_total": 361, "tokens_per_sec": 215.43622533514298, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL returns two rows with separate counts and totals for each center type (Legal Aid Clinics and Community Mediation Centers), while the Generated SQL performs a JOIN between the tables, leading to a Cartesian product (4 rows in this case) and sums the cases across all combinations. This results in inflated totals (e.g., 110 vs. 55 for Legal Aid Clinics) and a different output structure (single row vs. two rows). The JOIN logic and aggregation approach differ fundamentally.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly addresses the question by separately aggregating data from each table (LegalAidClinics and CommunityMediationCenters) with proper filtering for California. It returns two rows showing counts and case totals for each center type. The Generated SQL incorrectly joins the two tables on State, leading to a Cartesian product (e.g., 2 clinics \u00d7 2 centers = 4 rows) and miscounts centers. It also combines results into a single row with ambiguous column names, failing to distinguish between the two center types. While the Generated SQL attempts to sum cases, its approach is fundamentally flawed for this query's requirements.", "overall_assessment": "incorrect"}}
{"example_id": 2408, "sql_complexity": "aggregation", "prompt": "What is the average number of victories for players from Japan and South Korea, partitioned by game mode?", "context": "CREATE TABLE PlayerVictories (PlayerID INT, GameMode VARCHAR(255), Victories INT, Country VARCHAR(255)); INSERT INTO PlayerVictories (PlayerID, GameMode, Victories, Country) VALUES (1, 'Battle Royale', 25, 'Japan'), (2, 'Team Deathmatch', 18, 'South Korea');", "reference_sql": "SELECT GameMode, AVG(Victories) as AvgVictories FROM PlayerVictories WHERE Country IN ('Japan', 'South Korea') GROUP BY GameMode, Country WITH ROLLUP;", "generated_sql": "SELECT PlayerVictories.GameMode, COUNT(PlayerVictories.Victories) AS total_victories FROM PlayerVictors WHERE PlayerVictors.country IN ('Japan', 'South Korea') GROUP BY PlayerVictors.GameMode);", "raw_model_output": " Code\n<s> #_of_victories = (SELECT PlayerVictories.GameMode, COUNT(PlayerVictories.Victories) AS total_victories FROM PlayerVictors WHERE PlayerVictors.country IN ('Japan', 'South Korea') GROUP BY PlayerVictors.GameMode); SELECT AVG(total_victories) AS average_victories FROM number_of_victories;", "latency_sec": 1.127023696899414, "total_duration_sec": 1.071183186, "load_duration_sec": 0.008371255, "tokens_prompt": 126, "prompt_eval_sec": 0.008031608, "tokens_completion": 99, "completion_eval_sec": 1.054150651, "tokens_total": 225, "tokens_per_sec": 199.64087766655103, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in aggregation functions (AVG vs COUNT), grouping columns (GameMode+Country vs GameMode), and include ROLLUP in the reference query. The generated query also references a different table name (PlayerVictors vs PlayerVictories). These differences ensure distinct results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query is technically correct but semantically flawed. It groups by both GameMode and Country, which would calculate averages per country within each game mode rather than the combined average for Japan/South Korea. The generated query contains a typo (PlayerVictors instead of PlayerVictories) and uses COUNT instead of AVG, making it technically incorrect. Neither query fully addresses the business intent of calculating the average victories for players from both countries partitioned by game mode. The reference query is closer to the intent but has a logical grouping error, while the generated query fails on multiple fronts.", "overall_assessment": "incorrect"}}
{"example_id": 2729, "sql_complexity": "subqueries", "prompt": "Find the total number of trips made by shared autonomous vehicles in Seattle", "context": "CREATE TABLE shared_vehicles (id INT, vehicle_type VARCHAR(20), is_autonomous BOOLEAN, trip_count INT); INSERT INTO shared_vehicles (id, vehicle_type, is_autonomous, trip_count) VALUES (1, 'ebike', false, 1200), (2, 'escooter', false, 800), (3, 'car', true, 1500); CREATE TABLE city_data (city VARCHAR(20), has_autonomous_vehicles BOOLEAN); INSERT INTO city_data (city, has_autonomous_vehicles) VALUES ('Seattle', true), ('Denver', false), ('Portland', true);", "reference_sql": "SELECT SUM(trip_count) FROM shared_vehicles WHERE is_autonomous = true AND vehicle_type != 'ebike' AND vehicle_type != 'escooter' AND city IN (SELECT city FROM city_data WHERE has_autonomous_vehicles = true AND city = 'Seattle');", "generated_sql": "SELECT SUM(shared_vehicles.ride_count) AS total_trips FROM shared_vehicles JOIN city_data ON shared_vehicles.id = city_data.city WHERE city_data.city ILIKE '%Seattle%' AND shared_vehicles.is_autonomous = TRUE;", "raw_model_output": " Code\n<s> QUERY SELECT SUM(shared_vehicles.ride_count) AS total_trips FROM shared_vehicles JOIN city_data ON shared_vehicles.id = city_data.city WHERE city_data.city ILIKE '%Seattle%' AND shared_vehicles.is_autonomous = TRUE;", "latency_sec": 0.9598138332366943, "total_duration_sec": 0.869256283, "load_duration_sec": 0.008758214, "tokens_prompt": 203, "prompt_eval_sec": 0.012973552, "tokens_completion": 77, "completion_eval_sec": 0.84669722, "tokens_total": 280, "tokens_per_sec": 291.72323871993075, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL references a 'city' column in shared_vehicles, which does not exist in the schema. The Generated SQL incorrectly joins shared_vehicles.id with city_data.city (type mismatch) and uses 'ride_count' instead of 'trip_count'. Additionally, the Generated SQL uses a partial match for 'Seattle' with ILIKE, while the Reference SQL explicitly checks for exact 'Seattle' in a subquery. The vehicle_type filters also differ (Reference excludes ebike/escooter, Generated does not).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL attempts to filter autonomous vehicles (is_autonomous = true) and exclude non-car types (ebike/escooter), which aligns with the business intent. However, it incorrectly references a 'city' column in shared_vehicles that doesn't exist, making it syntactically invalid. The Generated SQL has multiple errors: it uses a non-existent 'ride_count' column instead of 'trip_count', joins on a mismatched id-city relationship, and uses a partial match for 'Seattle' that could include unintended cities. While both queries fail technically, the Reference SQL's logic for filtering vehicle types is closer to the correct approach, even though it contains a critical schema error.", "overall_assessment": "incorrect"}}
{"example_id": 2952, "sql_complexity": "aggregation", "prompt": "Show the total budget allocated for each program category in 2023.", "context": "CREATE TABLE Budget (id INT, category TEXT, year INT, allocated_amount INT); INSERT INTO Budget (id, category, year, allocated_amount) VALUES (1, 'Education', 2023, 30000); INSERT INTO Budget (id, category, year, allocated_amount) VALUES (2, 'Healthcare', 2023, 50000);", "reference_sql": "SELECT category, SUM(allocated_amount) FROM Budget WHERE year = 2023 GROUP BY category;", "generated_sql": "Code\n<s> QUERY", "raw_model_output": " Code\n<s> QUERY", "latency_sec": 0.3910942077636719, "total_duration_sec": 0.104248036, "load_duration_sec": 0.008625844, "tokens_prompt": 133, "prompt_eval_sec": 0.008259275, "tokens_completion": 7, "completion_eval_sec": 0.086791871, "tokens_total": 140, "tokens_per_sec": 357.970016484106, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The generated SQL is not properly provided (marked as <s> QUERY). Without seeing the actual query, it's impossible to determine semantic equivalence. The reference query groups by category and sums allocated_amount for 2023, but the generated SQL's contents are unknown.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query is technically correct and fulfills the business intent. It properly filters for 2023, groups by category, and sums allocated amounts. The generated SQL is missing, so its technical equivalence cannot be determined. Without the generated query, we cannot confirm equivalence, but the reference query is valid and directly addresses the requirement.", "overall_assessment": "correct"}}
{"example_id": 4328, "sql_complexity": "aggregation", "prompt": "What is the average cargo handling time in hours for each port?", "context": "CREATE TABLE cargo_handling (id INT, port_id INT, time_in_hours DECIMAL(5,2)); INSERT INTO cargo_handling (id, port_id, time_in_hours) VALUES (1, 1, 20.5), (2, 1, 22.3), (3, 2, 18.7);", "reference_sql": "SELECT port_id, AVG(time_in_hours) FROM cargo_handling GROUP BY port_id;", "generated_sql": "SELECT p.port_name, AVG(ch.time_in_hours) AS avg_time_in_hours FROM cargo_handling ch JOIN ports p ON ch.port_id = p.port_id GROUP BY p.port_name;", "raw_model_output": " Code\n<s> #_of_cargo_handling = SELECT p.port_name, AVG(ch.time_in_hours) AS avg_time_in_hours FROM cargo_handling ch JOIN ports p ON ch.port_id = p.port_id GROUP BY p.port_name;", "latency_sec": 1.0637481212615967, "total_duration_sec": 0.832691497, "load_duration_sec": 0.008827238, "tokens_prompt": 121, "prompt_eval_sec": 0.007610181, "tokens_completion": 76, "completion_eval_sec": 0.815552819, "tokens_total": 197, "tokens_per_sec": 185.19421662184428, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The reference query returns 'port_id' and the generated query returns 'port_name'. While both calculate the average 'time_in_hours' per group, the output columns differ. Additionally, the generated query requires a 'ports' table (not defined in the provided schema) to retrieve 'port_name', which is not present in the original schema. This makes the generated query invalid in the given context and alters the result structure.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query is technically correct and directly addresses the question by calculating the average cargo handling time per port_id. The generated query assumes the existence of a 'ports' table with 'port_name' that is not mentioned in the provided schema, making it invalid. While both queries aim to calculate averages, the generated query introduces an unnecessary join to a non-existent table, leading to potential runtime errors. The reference query is more efficient, elegant, and aligned with the given schema.", "overall_assessment": "correct"}}
{"example_id": 4915, "sql_complexity": "window functions", "prompt": "Calculate the percentage of total Europium production for each country.", "context": "CREATE TABLE europium_production (country VARCHAR(50), quantity INT);", "reference_sql": "SELECT country, quantity * 100.0 / SUM(quantity) OVER (PARTITION BY NULL) AS percentage FROM europium_production;", "generated_sql": "SELECT country, CAST(quantity AS FLOAT) / SUM(quantity) OVER () AS proportion FROM europium_production;", "raw_model_output": " Code\n<s> # 1\n<s> # 2\n SELECT country, CAST(quantity AS FLOAT) / SUM(quantity) OVER () AS proportion FROM europium_production;", "latency_sec": 0.6909730434417725, "total_duration_sec": 0.491015666, "load_duration_sec": 0.0096518, "tokens_prompt": 47, "prompt_eval_sec": 0.009577662, "tokens_completion": 45, "completion_eval_sec": 0.471109491, "tokens_total": 92, "tokens_per_sec": 133.145570399886, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query calculates a percentage (multiplied by 100.0) while the generated query calculates a proportion (without multiplying by 100). The column names also differ (percentage vs. proportion), and the numerical results would differ by a factor of 100.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly calculates the percentage by multiplying by 100.0, ensuring the result is a percentage (e.g., 25% vs. 0.25). The generated query computes a proportion (e.g., 0.25) instead of a percentage, which directly contradicts the business requirement. While both use window functions correctly, the reference explicitly addresses the 'percentage' requirement through the 100.0 multiplier. The generated query's column name 'proportion' further misaligns with the question's terminology. Both queries are syntactically valid, but only the reference fulfills the business intent.", "overall_assessment": "differently_correct"}}
{"example_id": 5030, "sql_complexity": "subqueries", "prompt": "What is the success rate of diverse-led startups (at least 1 female or underrepresented racial or ethnic group executive) in the past 3 years?", "context": "CREATE TABLE DiverseStartups(id INT, name TEXT, country TEXT, year INT, success BOOLEAN);   INSERT INTO DiverseStartups VALUES (1, 'FemTech', 'USA', 2020, true), (2, 'GreenCity', 'Canada', 2019, false), (3, 'AI-Health', 'UK', 2021, true), (4, 'SolarEnergy', 'USA', 2020, false), (5, 'DataAnalytics', 'Germany', 2019, true), (6, 'SmartGrid', 'USA', 2021, true), (7, 'CloudServices', 'India', 2020, false), (8, 'RenewableEnergy', 'USA', 2019, true);", "reference_sql": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3) AS success_rate FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3 AND success = true;", "generated_sql": "SELECT CAST(SUM(CASE WHEN DiverseStartups.success THEN 1 ELSE 0 END) AS FLOAT) / NULLIF(COUNT(*), 0) AS success_rate FROM DiverseRollups WHERE year >= EXTRACT(YEAR FROM CURRENT_DATE) - 3 AND (name ilike '%female%' OR country ilike 'underrepresented%');", "raw_model_output": " code (HINT to solve the question)\nSELECT CAST(SUM(CASE WHEN DiverseStartups.success THEN 1 ELSE 0 END) AS FLOAT) / NULLIF(COUNT(*), 0) AS success_rate FROM DiverseRollups WHERE year >= EXTRACT(YEAR FROM CURRENT_DATE) - 3 AND (name ilike '%female%' OR country ilike 'underrepresented%');", "latency_sec": 1.4438807964324951, "total_duration_sec": 1.141969954, "load_duration_sec": 0.008799946, "tokens_prompt": 247, "prompt_eval_sec": 0.014039683, "tokens_completion": 101, "completion_eval_sec": 1.118327034, "tokens_total": 348, "tokens_per_sec": 241.01712610890718, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL queries the 'DiverseStartups' table with conditions on 'year' and 'success', while the Generated SQL queries a different table 'DiverseRollups' with additional filters on 'name' and 'country' (using ilike). The tables, column names, and filtering conditions differ, leading to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL is technically correct and aligns with the schema, calculating success rate as (successful diverse startups) / (total diverse startups) for the past 3 years. However, it assumes all entries in DiverseStartups are already diverse-led (which isn't explicitly validated by the schema). The Generated SQL has critical issues: 1) References DiverseRollups (non-existent table), 2) Uses incorrect filters (name/country instead of executive diversity), 3) Uses ilike which may not match the actual data. While the Reference SQL doesn't explicitly validate the 'diverse-led' criteria (as the schema lacks relevant fields), it at least operates on the correct table. The Generated SQL fails to address the business intent due to table/condition errors.", "overall_assessment": "differently_correct"}}
{"example_id": 4626, "sql_complexity": "aggregation", "prompt": "What was the maximum number of training hours for farmers in each country in 2020?", "context": "CREATE TABLE training (id INT, country_id INT, farmer_id INT, hours INT, date DATE);", "reference_sql": "SELECT country_id, MAX(hours) FROM training WHERE YEAR(date) = 2020 GROUP BY country_id;", "generated_sql": "SELECT COUNT(training.hours) FROM training JOIN farmer ON training.farmer_id = farmer.id WHERE EXTRACT(YEAR FROM training.date) = 2020 AND country_id = 1707071);", "raw_model_output": " Code\n<s> #_of_hours = (SELECT COUNT(training.hours) FROM training JOIN farmer ON training.farmer_id = farmer.id WHERE EXTRACT(YEAR FROM training.date) = 2020 AND country_id = 1707071);", "latency_sec": 0.8264482021331787, "total_duration_sec": 0.736126681, "load_duration_sec": 0.007753675, "tokens_prompt": 61, "prompt_eval_sec": 0.005410452, "tokens_completion": 69, "completion_eval_sec": 0.722302726, "tokens_total": 130, "tokens_per_sec": 157.2996343442357, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in multiple aspects. The reference query groups by country_id and returns MAX(hours) per country, while the generated query counts hours for a specific country (1707071) and includes an unnecessary JOIN with a non-existent farmer table. The aggregate functions (MAX vs COUNT) and filtering/grouping logic also differ.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly calculates the maximum training hours per country for 2020 using GROUP BY and MAX(). The generated query contains multiple issues: 1) It uses COUNT() instead of MAX() 2) It includes an unnecessary JOIN with the farmer table 3) It filters for a single country (country_id = 1707071) instead of analyzing all countries. While both queries filter by 2020, their fundamental differences in aggregation method, table usage, and scope make them non-equivalent. The reference query directly addresses the business intent of finding maximum hours per country, while the generated query answers a different question about count of hours for a specific country.", "overall_assessment": "incorrect"}}
{"example_id": 2703, "sql_complexity": "set operations", "prompt": "Identify the species unique to 'MarineResearchAreaA' and 'MarineResearchAreaB'", "context": "CREATE TABLE ResearchAreaSpecies (area VARCHAR(255), species VARCHAR(255)); INSERT INTO ResearchAreaSpecies (area, species) VALUES ('MarineResearchAreaA', 'Coral'), ('MarineResearchAreaA', 'Starfish'), ('MarineResearchAreaB', 'Jellyfish');", "reference_sql": "(SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB') UNION (SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA');", "generated_sql": "SELECT DISTINCT ResearchAreaSpecies.species FROM ResearchareaSpecies WHERE ResearchareaSpecies.area IN ('MarineResearchAreaA', 'MarineResearchAreaB');", "raw_model_output": " Code\nSELECT DISTINCT ResearchAreaSpecies.species FROM ResearchareaSpecies WHERE ResearchareaSpecies.area IN ('MarineResearchAreaA', 'MarineResearchAreaB');", "latency_sec": 0.6940469741821289, "total_duration_sec": 0.490871194, "load_duration_sec": 0.008458276, "tokens_prompt": 116, "prompt_eval_sec": 0.007474356, "tokens_completion": 44, "completion_eval_sec": 0.47418159, "tokens_total": 160, "tokens_per_sec": 230.5319466143418, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns species that are unique to each area (Coral and Starfish from A, Jellyfish from B), while the Generated SQL returns all species present in either area (Coral, Starfish, Jellyfish). The Generated SQL lacks the exclusion logic of the Reference SQL, leading to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly identifies species unique to each area using EXCEPT (which finds set differences) and UNION to combine results. It returns species present in one area but not the other. The Generated SQL simply retrieves all distinct species from both areas without checking for uniqueness across areas. For example, if a species existed in both areas, it would still appear in the Generated SQL result but should be excluded per the question's requirement. The Reference SQL explicitly enforces the 'unique to' condition through set operations, while the Generated SQL fails to address this requirement.", "overall_assessment": "incorrect"}}
{"example_id": 200, "sql_complexity": "window functions", "prompt": "List the top three categories of workforce development programs with the highest budget increases.", "context": "CREATE TABLE programs (program_id INT, program_name VARCHAR(50), budget DECIMAL(10, 2), category VARCHAR(50), budget_date DATE);", "reference_sql": "SELECT category, SUM(budget - LAG(budget) OVER (PARTITION BY category ORDER BY budget_date)) as total_budget_increase FROM programs GROUP BY category ORDER BY total_budget_increase DESC LIMIT 3;", "generated_sql": "Code\n<s> # of lines to be inserted into the database: 1", "raw_model_output": " Code\n<s> # of lines to be inserted into the database: 1", "latency_sec": 0.39008212089538574, "total_duration_sec": 0.190709467, "load_duration_sec": 0.00856321, "tokens_prompt": 76, "prompt_eval_sec": 0.006691791, "tokens_completion": 16, "completion_eval_sec": 0.1746923, "tokens_total": 92, "tokens_per_sec": 235.847774281029, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference SQL is a SELECT query that calculates budget changes across time periods within categories, while the generated SQL appears to be an INSERT statement (based on the context about inserting rows). They perform entirely different operations (analysis vs. data insertion) and cannot be semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference SQL correctly calculates the total budget increase per category by using the LAG function to compare consecutive budgets within the same category, then sums these differences. However, the generated SQL is incomplete/invalid (appears to be a placeholder about database inserts rather than a query). The reference query addresses the business intent by identifying categories with the largest cumulative budget growth. The generated SQL cannot be evaluated due to missing/incorrect content.", "overall_assessment": "correct"}}
{"example_id": 5131, "sql_complexity": "basic SQL", "prompt": "How many wells were drilled in the Eagle Ford Shale and Bakken Formation?", "context": "CREATE TABLE wells (id INT, region VARCHAR(255), well_type VARCHAR(255), num_drilled INT); INSERT INTO wells (id, region, well_type, num_drilled) VALUES (1, 'Eagle Ford Shale', 'Oil', 2000), (2, 'Eagle Ford Shale', 'Gas', 1500), (3, 'Bakken Formation', 'Oil', 1000), (4, 'Bakken Formation', 'Gas', 1200);", "reference_sql": "SELECT SUM(num_drilled) as total_wells FROM wells WHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "generated_sql": "SELECT SUM(num_drilled) FROM wellsw WHERE region IN ('Eagle Ford Shale', 'Bakken Formation'));", "raw_model_output": " Code\n<s> # of wells drilled in the Eagle Ford Shale and Bakken Formation = (SELECT SUM(num_drilled) FROM wellsw WHERE region IN ('Eagle Ford Shale', 'Bakken Formation'));", "latency_sec": 0.901939868927002, "total_duration_sec": 0.603194742, "load_duration_sec": 0.008396168, "tokens_prompt": 172, "prompt_eval_sec": 0.011007458, "tokens_completion": 53, "completion_eval_sec": 0.583231328, "tokens_total": 225, "tokens_per_sec": 249.46230647024458, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries reference different table names ('wells' vs 'wellsw'), which would result in different results or errors. The generated SQL contains a typo in the table name, making it semantically incorrect compared to the reference query.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query is technically correct and semantically equivalent to the intended question. It properly sums num_drilled for the specified regions. The generated query contains a critical syntax error: the table name is misspelled as 'wellsw' instead of 'wells', which would cause a runtime error. While both queries target the same business intent, the generated query fails to execute due to this typo. The reference query efficiently addresses the question by directly aggregating the required data.", "overall_assessment": "incorrect"}}
{"example_id": 1160, "sql_complexity": "subqueries", "prompt": "What is the total revenue generated from ads on Instagram in March 2021, for users in the 'brand' category who have posted more than 10 times?", "context": "CREATE TABLE ads (ad_id INT, user_id INT, platform VARCHAR(255), ad_revenue DECIMAL(10,2), post_count INT); INSERT INTO ads (ad_id, user_id, platform, ad_revenue, post_count) VALUES (1, 1, 'Instagram', 150.50, 12), (2, 2, 'Twitter', 80.00, 15), (3, 3, 'Instagram', 120.75, 8);", "reference_sql": "SELECT SUM(ad_revenue) FROM ads WHERE platform = 'Instagram' AND MONTH(ad_date) = 3 AND YEAR(ad_date) = 2021 AND user_id IN (SELECT user_id FROM users WHERE category = 'brand' AND post_count > 10);", "generated_sql": "Code\n<s> # of rows: 3", "raw_model_output": " Code\n<s> # of rows: 3", "latency_sec": 0.17400789260864258, "total_duration_sec": 0.150592539, "load_duration_sec": 0.007661708, "tokens_prompt": 186, "prompt_eval_sec": 0.0122959, "tokens_completion": 10, "completion_eval_sec": 0.129877898, "tokens_total": 196, "tokens_per_sec": 1126.385688957336, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references a 'users' table in a subquery, but the provided database schema only includes an 'ads' table. The Generated SQL is incomplete (empty code block) and cannot be evaluated. Without the actual Generated SQL code, semantic equivalence cannot be determined, but the Reference SQL contains invalid schema elements.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference SQL contains critical errors: 1) It references a 'users' table that doesn't exist in the provided schema, 2) It uses 'ad_date' column which isn't present in the 'ads' table schema. The generated SQL is incomplete (only shows row count). Neither query properly addresses the business intent due to schema mismatches. The reference query attempts to meet the intent but fails technically, while the generated query is non-functional.", "overall_assessment": "incorrect"}}
{"example_id": 4708, "sql_complexity": "subqueries", "prompt": "What is the maximum number of high-level threats reported by a single agency in a month?", "context": "CREATE TABLE Threat_Intelligence (Threat_ID INT, Threat_Type VARCHAR(50), Threat_Level VARCHAR(50), Reported_Date DATE, Reporting_Agency VARCHAR(50)); CREATE VIEW High_Level_Threats AS SELECT Threat_Type, Threat_Level, Reported_Date FROM Threat_Intelligence WHERE Threat_Level = 'High';", "reference_sql": "SELECT Reporting_Agency, MAX(Number_of_High_Level_Threats) as Max_High_Level_Threats_in_a_Month FROM (SELECT Reporting_Agency, TO_CHAR(Reported_Date, 'YYYY-MM') as Month, COUNT(*) as Number_of_High_Level_Threats FROM High_Level_Threats GROUP BY Reporting_Agency, Month) GROUP BY Reporting_Agency;", "generated_sql": "SELECT Reporting_Agency, Date_Trunc('month', Reported_Date) AS MONTH, COUNT(*) AS Threat_Count FROM Threat_Intelligence WHERE Threat_Level = 'High' GROUP BY Reporting_Agency, MONTH;", "raw_model_output": " Code\n<s> CREATE OR REPLACE VIEW Monthly_Threats AS SELECT Reporting_Agency, Date_Trunc('month', Reported_Date) AS MONTH, COUNT(*) AS Threat_Count FROM Threat_Intelligence WHERE Threat_Level = 'High' GROUP BY Reporting_Agency, MONTH;", "latency_sec": 1.1767230033874512, "total_duration_sec": 0.885769504, "load_duration_sec": 0.010185534, "tokens_prompt": 132, "prompt_eval_sec": 0.008419533, "tokens_completion": 81, "completion_eval_sec": 0.866438618, "tokens_total": 213, "tokens_per_sec": 181.01116353367235, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates the maximum number of high-level threats per agency across months, while the Generated SQL returns counts of high-level threats per agency and month without aggregating to a maximum. The Reference SQL's outer GROUP BY and MAX() creates a per-agency summary of peak monthly counts, whereas the Generated SQL provides detailed monthly counts per agency.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL calculates the maximum high-level threats per agency across months but does not identify the absolute maximum across all agencies. The Generated SQL correctly groups by agency and month to count threats but also fails to aggregate across all agencies to find the global maximum. Both queries miss the final step of selecting the overall maximum value. However, the Generated SQL is more efficient as it avoids the unnecessary view and simplifies the logic, directly working with the base table.", "overall_assessment": "incorrect"}}
{"example_id": 5608, "sql_complexity": "set operations", "prompt": "List the suppliers that provide materials for both product A and product C.", "context": "CREATE TABLE products (product_id INT, product_name TEXT); CREATE TABLE materials (material_id INT, material_name TEXT, product_id INT, supplier_id INT); INSERT INTO products (product_id, product_name) VALUES (1, 'Product A'), (2, 'Product B'), (3, 'Product C'); INSERT INTO materials (material_id, material_name, product_id, supplier_id) VALUES (1, 'Material 1', 1, 101), (2, 'Material 2', 1, 102), (3, 'Material 3', 2, 103), (4, 'Material 4', 3, 101), (5, 'Material 5', 3, 102);", "reference_sql": "SELECT supplier_id FROM materials WHERE product_id = 1 INTERSECT SELECT supplier_id FROM materials WHERE product_id = 3;", "generated_sql": "SELECT DISTINCT m.supplier_id FROM materials m JOIN products p ON m.product_id = p.product_id WHERE p.product_name IN ('Product A', 'Product C');", "raw_model_output": " Code\n<s> SELECT DISTINCT m.supplier_id FROM materials m JOIN products p ON m.product_id = p.product_id WHERE p.product_name IN ('Product A', 'Product C');", "latency_sec": 0.6851649284362793, "total_duration_sec": 0.586133257, "load_duration_sec": 0.009224417, "tokens_prompt": 214, "prompt_eval_sec": 0.015324288, "tokens_completion": 50, "completion_eval_sec": 0.560790404, "tokens_total": 264, "tokens_per_sec": 385.3086885263015, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL finds suppliers common to both product_id=1 and product_id=3 (intersection), while the Generated SQL retrieves all distinct suppliers for products named 'Product A' or 'Product C' (union). Although their results may coincide in this specific dataset, their logical operations differ. The Reference uses INTERSECT, whereas the Generated SQL uses a JOIN with IN, making them semantically non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly uses INTERSECT to find suppliers present in both product A (product_id=1) and product C (product_id=3) material records. The generated query returns all suppliers for either product A or C (due to IN clause) but lacks logic to ensure suppliers exist for *both* products. While both queries reference the materials table, the generated version fails to enforce the 'both' condition required by the business question. The reference query is more efficient and semantically precise.", "overall_assessment": "incorrect"}}
{"example_id": 1506, "sql_complexity": "basic SQL", "prompt": "How many habitats are in the 'animal_habitats' table?", "context": "CREATE TABLE animal_habitats (id INT PRIMARY KEY, habitat_name VARCHAR, num_animals INT);", "reference_sql": "SELECT COUNT(*) FROM animal_habitats;", "generated_sql": "SELECT COUNT(id) FROM animal_habitats);", "raw_model_output": " code to solve problem\n<s> # of habitats = (SELECT COUNT(id) FROM animal_habitats);", "latency_sec": 0.3987751007080078, "total_duration_sec": 0.294124836, "load_duration_sec": 0.009746509, "tokens_prompt": 61, "prompt_eval_sec": 0.007174597, "tokens_completion": 26, "completion_eval_sec": 0.275905548, "tokens_total": 87, "tokens_per_sec": 218.16808483161384, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The queries are equivalent because the 'id' column is a PRIMARY KEY (which cannot contain NULL values). COUNT(id) will count all rows (since no id is NULL), just like COUNT(*).", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries correctly count the number of habitats in the table. The reference query uses COUNT(*) which is semantically explicit for counting all rows, while the generated query uses COUNT(id) which achieves the same result because the id column (primary key) cannot contain null values. Both are technically correct and produce identical results. However, COUNT(*) is more idiomatic for this specific use case and demonstrates clearer intent to count all records without referencing a specific column.", "overall_assessment": "correct"}}
{"example_id": 3117, "sql_complexity": "aggregation", "prompt": "What is the percentage of the population that has access to clean water in each continent?", "context": "CREATE TABLE water_data (id INT, country VARCHAR(50), continent CHAR(2), access_to_clean_water BOOLEAN); INSERT INTO water_data VALUES (1, 'Canada', 'NA', true), (2, 'Mexico', 'NA', false), (3, 'Brazil', 'SA', true), (4, 'Russia', 'EU', true);", "reference_sql": "SELECT continent, COUNT(*) FILTER (WHERE access_to_clean_water) * 100.0 / COUNT(*) AS percentage FROM water_data GROUP BY continent;", "generated_sql": "SELECT continent, CAST(SUM(CASE WHEN access_to_clean_water THEN 1 ELSE 0 END) AS FLOAT) / NULLIF(COUNT(*), 0) AS proportion_with_access_to_clean_water FROM water_data GROUP BY continent;", "raw_model_output": " Code\n<s> # SELECT continent, CAST(SUM(CASE WHEN access_to_clean_water THEN 1 ELSE 0 END) AS FLOAT) / NULLIF(COUNT(*), 0) AS proportion_with_access_to_clean_water FROM water_data GROUP BY continent;", "latency_sec": 0.8924736976623535, "total_duration_sec": 0.79409371, "load_duration_sec": 0.0083625, "tokens_prompt": 128, "prompt_eval_sec": 0.007918614, "tokens_completion": 72, "completion_eval_sec": 0.777034374, "tokens_total": 200, "tokens_per_sec": 224.09624006159262, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates a percentage (multiplied by 100.0) while the Generated SQL calculates a proportion (without multiplying by 100). The column names also differ (percentage vs proportion_with_access_to_clean_water), and the Generated SQL uses NULLIF to handle division by zero, which the Reference SQL does not. These differences in output values and edge-case handling make them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent. The reference query explicitly calculates a percentage by multiplying by 100.0, while the generated query calculates a proportion (0-1 range) without this conversion. Although both correctly count access rates, the reference query directly addresses the 'percentage' requirement in the question. The generated query's column name ('proportion') also misaligns with the business intent. Both are logically correct but differ in output format. The reference query better fulfills the intent of reporting percentages.", "overall_assessment": "differently_correct"}}
{"example_id": 3542, "sql_complexity": "window functions", "prompt": "What is the average yield of crops for each country, ranked by average yield?", "context": "CREATE TABLE farming (id INT, name TEXT, country TEXT, crop TEXT, yield INT); INSERT INTO farming VALUES (1, 'Smith Farm', 'USA', 'Corn', 120), (2, 'Brown Farm', 'Canada', 'Soybeans', 45), (3, 'Jones Farm', 'Mexico', 'Wheat', 80);", "reference_sql": "SELECT country, AVG(yield) as avg_yield, ROW_NUMBER() OVER (ORDER BY AVG(yield) DESC) as rank FROM farming GROUP BY country;", "generated_sql": "Code\n<s> QUERY", "raw_model_output": " Code\n<s> QUERY", "latency_sec": 0.3049590587615967, "total_duration_sec": 0.101771536, "load_duration_sec": 0.008013119, "tokens_prompt": 122, "prompt_eval_sec": 0.007685302, "tokens_completion": 7, "completion_eval_sec": 0.085377974, "tokens_total": 129, "tokens_per_sec": 423.00760149199704, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The generated SQL is not provided, making it impossible to determine semantic equivalence. The reference query includes a ROW_NUMBER() window function to rank countries by average yield, but without the actual generated query, no comparison can be made.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query correctly calculates average yield per country and assigns ranks using ROW_NUMBER(). The generated SQL is missing, so technical equivalence cannot be confirmed. However, the reference query properly addresses the business intent by grouping by country, calculating averages, and ranking results in descending order of yield. The generated query's absence prevents a full comparison, but the reference is valid and efficient.", "overall_assessment": "correct"}}
{"example_id": 2274, "sql_complexity": "subqueries", "prompt": "Add a new crop 'amaranth' to farm 'Nourishing Harvest' with yield 50 in 2023", "context": "CREATE TABLE farms (id INT, name TEXT, location TEXT, size FLOAT); INSERT INTO farms (id, name, location, size) VALUES (1, 'Nourishing Harvest', 'Mexico', 120.0); CREATE TABLE crops (id INT, farm_id INT, crop TEXT, yield INT, year INT);", "reference_sql": "INSERT INTO crops (id, farm_id, crop, yield, year) VALUES (5, (SELECT id FROM farms WHERE name = 'Nourishing Harvest'), 'amaranth', 50, 2023);", "generated_sql": "INSERT INTO crops (farm_id, crop, yield, year) VALUES ((SELECT id FROM farms WHERE name ILIKE '%Nourishing%Harvest%'), 'amaranth', 50, 2023);", "raw_model_output": " code (NO QUERY)\nINSERT INTO crops (farm_id, crop, yield, year) VALUES ((SELECT id FROM farms WHERE name ILIKE '%Nourishing%Harvest%'), 'amaranth', 50, 2023);", "latency_sec": 0.7579729557037354, "total_duration_sec": 0.66077045, "load_duration_sec": 0.008878517, "tokens_prompt": 125, "prompt_eval_sec": 0.007861317, "tokens_completion": 60, "completion_eval_sec": 0.643329169, "tokens_total": 185, "tokens_per_sec": 244.07203266010708, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. 1) The Reference SQL explicitly sets the 'id' column to 5, while the Generated SQL omits this column, potentially allowing the database to auto-generate a value. 2) The farm_id subquery in the Reference uses an exact match ('Nourishing Harvest'), while the Generated uses a case-insensitive partial match ('%Nourishing%Harvest%'). These differences would result in different data being inserted into the 'crops' table.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries differ in two key technical aspects. 1) The reference query explicitly specifies all columns in the INSERT statement, while the generated query omits the 'id' column. This could be a problem if the 'id' column is required (e.g., it's a primary key with no default value). 2) The generated query uses a case-insensitive LIKE operator with wildcards, which might match more rows than intended. While both queries would insert the correct data into the 'crops' table, the reference query is more precise and less likely to cause issues. The generated query is more concise but less robust. Both queries fulfill the business intent of adding the 'amaranth' crop to the 'Nourishing Harvest' farm with the specified yield and year.", "overall_assessment": "differently_correct"}}
{"example_id": 3705, "sql_complexity": "subqueries", "prompt": "What is the percentage of unions with collective bargaining agreements in the Midwest region?", "context": "CREATE TABLE collective_bargaining (bargaining_id INT, union_name VARCHAR(50), contract_start_date DATE, contract_end_date DATE, region VARCHAR(50));CREATE VIEW union_region AS SELECT DISTINCT union_name, region FROM collective_bargaining;", "reference_sql": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM union_region) as percentage FROM union_region ur WHERE ur.region = 'Midwest' AND EXISTS (SELECT 1 FROM collective_bargaining cb WHERE cb.union_name = ur.union_name);", "generated_sql": "SELECT COUNT(*) FROM collective_bargaining WHERE region ilike '%Midwest%')::FLOAT / NULLIF((SELECT COUNT(*) FROM union_region), 0) * 100;", "raw_model_output": " Code\n<s> #_of_unions_with_cbas = (SELECT COUNT(*) FROM collective_bargaining WHERE region ilike '%Midwest%')::FLOAT / NULLIF((SELECT COUNT(*) FROM union_region), 0) * 100;", "latency_sec": 1.5251457691192627, "total_duration_sec": 0.69684164, "load_duration_sec": 0.008234989, "tokens_prompt": 107, "prompt_eval_sec": 0.010543151, "tokens_completion": 63, "completion_eval_sec": 0.677263721, "tokens_total": 170, "tokens_per_sec": 111.46475533166326, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in logic and data sources. The reference query counts distinct union-region pairs in 'union_region' where the region is 'Midwest' and the union exists in 'collective_bargaining', then calculates a percentage relative to all 'union_region' rows. The generated query counts all 'collective_bargaining' rows with a region containing 'Midwest' (case-insensitive) and divides by the total 'union_region' count. Key differences: 1) The reference uses a correlated subquery with EXISTS, while the generated query uses a direct WHERE condition. 2) The generated query uses 'ilike' (case-insensitive) vs. exact match. 3) The generated query counts 'collective_bargaining' rows directly instead of using the view. 4) The generated query's numerator may include multiple entries per union, while the reference counts distinct unions.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly calculates the percentage of unique unions with collective bargaining agreements in the Midwest by using the union_region view (which contains distinct union-region pairs) and verifying existence in collective_bargaining. The Generated SQL incorrectly counts all records in collective_bargaining where region contains 'Midwest' (potentially duplicating unions with multiple contracts) and divides by total union_region records (which may include non-Midwest unions). The Generated SQL also lacks the EXISTS clause to ensure unions actually have CB agreements. While both handle division by zero with NULLIF, the Reference SQL's logic aligns with the business intent of counting unique unions.", "overall_assessment": "differently_correct"}}
{"example_id": 240, "sql_complexity": "aggregation", "prompt": "What is the average capacity of renewable energy projects for each country?", "context": "CREATE TABLE projects (name TEXT, type TEXT, capacity INTEGER, country TEXT); INSERT INTO projects (name, type, capacity, country) VALUES ('Project 1', 'Wind', 100, 'USA'), ('Project 2', 'Solar', 200, 'Germany'), ('Project 3', 'Wind', 300, 'France');", "reference_sql": "SELECT country, AVG(capacity) FROM projects GROUP BY country", "generated_sql": "SELECT COUNT(*) FROM projects WHERE type IN ('Wind', 'Solar'));", "raw_model_output": " Code\n<s> #_of_renewable_projects = (SELECT COUNT(*) FROM projects WHERE type IN ('Wind', 'Solar')); SELECT country, AVG(capacity) AS average_capacity FROM projects WHERE type IN ('Wind', 'Solar') GROUP BY country;", "latency_sec": 0.9148519039154053, "total_duration_sec": 0.713156518, "load_duration_sec": 0.008840411, "tokens_prompt": 120, "prompt_eval_sec": 0.009055104, "tokens_completion": 65, "completion_eval_sec": 0.694460785, "tokens_total": 185, "tokens_per_sec": 202.21852215449576, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the average capacity per country, while the Generated SQL counts projects with types 'Wind' or 'Solar'. They return different data structures (country-average pairs vs. a single count) and different values (100, 200, 300 vs. 3).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly calculates the average capacity per country using AVG(capacity) with GROUP BY country, directly addressing the business question. The generated query incorrectly counts projects with type 'Wind' or 'Solar' without considering capacity or grouping by country. While both queries are syntactically valid, they produce entirely different results: the reference returns average capacity metrics while the generated query returns project counts. The generated query fails to address the core requirement of calculating averages and omits the critical 'capacity' field entirely.", "overall_assessment": "incorrect"}}
{"example_id": 2132, "sql_complexity": "set operations", "prompt": "What is the average caseload per attorney in community legal clinics in California, and how does it compare to the state average?", "context": "CREATE TABLE cali_community_legal_clinics(id INT, attorney_count INT, cases_handled INT, state VARCHAR(255));", "reference_sql": "SELECT state, AVG(cases_handled/attorney_count) AS avg_caseload FROM cali_community_legal_clinics WHERE state = 'California' GROUP BY state UNION ALL SELECT 'California', AVG(cases_handled/attorney_count) FROM cali_community_legal_clinics WHERE state = 'California';", "generated_sql": "SELECT AVG(CASES_HANDLED) / NULLIF(ATTORNEY_COUNT, 0) AS avg_cases_per_attorney FROM cali_community_legal_clinics WHERE state = 'California');", "raw_model_output": " Code\n<s> #_of_cases_per_attorney = (SELECT AVG(CASES_HANDLED) / NULLIF(ATTORNEY_COUNT, 0) AS avg_cases_per_attorney FROM cali_community_legal_clinics WHERE state = 'California');\n### Hint\nAVG()", "latency_sec": 0.9471077919006348, "total_duration_sec": 0.832312187, "load_duration_sec": 0.007610693, "tokens_prompt": 80, "prompt_eval_sec": 0.007642987, "tokens_completion": 77, "completion_eval_sec": 0.816337086, "tokens_total": 157, "tokens_per_sec": 165.76782636846002, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two rows (due to UNION ALL) with the same average value, while the Generated SQL returns a single row. Additionally, the Reference SQL calculates the average of (cases_handled / attorney_count) per row, whereas the Generated SQL computes (AVG(cases_handled) / attorney_count), which is mathematically different. The Generated SQL also lacks a GROUP BY clause, making it invalid unless the table has exactly one row.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL contains logical flaws: it calculates the same value twice via UNION ALL (producing redundant rows) and doesn't actually compare to a 'state average' as requested. The Generated SQL correctly calculates the average caseload per attorney for California clinics using NULLIF to avoid division by zero, but neither query properly addresses the 'state average' comparison. However, the Generated SQL is technically correct for the first part of the question and more efficient. The Reference SQL's structure is invalid for comparison purposes, while the Generated SQL better fulfills the core calculation requirement.", "overall_assessment": "differently_correct"}}
{"example_id": 3276, "sql_complexity": "basic SQL", "prompt": "What is the total energy consumption of the Chemical Plant B in the last quarter?", "context": "CREATE TABLE EnergyConsumption (EnergyID INT, Plant VARCHAR(255), EnergyQuantity DECIMAL(5,2), Timestamp DATETIME);", "reference_sql": "SELECT SUM(EnergyQuantity) FROM EnergyConsumption WHERE Plant = 'Chemical Plant B' AND Timestamp BETWEEN DATE_SUB(CURRENT_DATE(), INTERVAL 3 MONTH) AND CURRENT_DATE();", "generated_sql": "SELECT SUM(EnergyQuantity) AS Total_Energy_Consumption FROM EnergyConsumption WHERE Plant = 'Chemical Plant B' AND EXTRACT(QUARTER FROM timestamp) = 4;", "raw_model_output": " Code\nSELECT SUM(EnergyQuantity) AS Total_Energy_Consumption FROM EnergyConsumption WHERE Plant = 'Chemical Plant B' AND EXTRACT(QUARTER FROM timestamp) = 4;", "latency_sec": 0.7200949192047119, "total_duration_sec": 0.535456629, "load_duration_sec": 0.009911297, "tokens_prompt": 72, "prompt_eval_sec": 0.005597935, "tokens_completion": 49, "completion_eval_sec": 0.519373275, "tokens_total": 121, "tokens_per_sec": 168.03340333748633, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query sums EnergyQuantity for the last 3 months from the current date, while the generated query sums EnergyQuantity for all records where the timestamp's quarter is 4 (October-December). The date ranges are not equivalent: the reference uses a dynamic 3-month window, while the generated query captures all entries in the 4th quarter of any year, leading to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query calculates energy consumption for the last 3 months using DATE_SUB, which may not align with calendar quarters. The generated query uses EXTRACT(QUARTER) = 4 to target Q4 data, but it lacks year filtering, potentially including multiple years' Q4 data. Neither fully fulfills the intent: the reference captures a 3-month window (not necessarily the 'last quarter'), while the generated query captures all Q4 data regardless of year. However, the generated query better aligns with the business intent of 'last quarter' as a calendar quarter, assuming the user means the most recent Q4. The reference's approach is more about time duration than calendar quarters.", "overall_assessment": "differently_correct"}}
{"example_id": 3074, "sql_complexity": "multiple_joins", "prompt": "Find the top 5 players with the highest scores in the 'historical_tournaments' view, including their scores and the names of the tournaments they participated in.", "context": "CREATE VIEW historical_tournaments AS SELECT tournaments.tournament_name, players.player_name, players.score FROM tournaments JOIN players_scores ON tournaments.tournament_id = players_scores.tournament_id JOIN players ON players_scores.player_id = players.player_id;  CREATE TABLE tournaments (tournament_id INT, tournament_name TEXT);  CREATE TABLE players_scores (player_id INT, tournament_id INT, score INT);  CREATE TABLE players (player_id INT, player_name TEXT);", "reference_sql": "SELECT players.player_name, MAX(players_scores.score) as high_score, tournaments.tournament_name FROM historical_tournaments JOIN players ON historical_tournaments.player_id = players.player_id JOIN players_scores ON historical_tournaments.player_id = players_scores.player_id JOIN tournaments ON players_scores.tournament_id = tournaments.tournament_id GROUP BY players.player_id, tournaments.tournament_name ORDER BY high_score DESC LIMIT 5;", "generated_sql": "SELECT p.player_name, t.tournament_name, ps.score FROM historical_tournaments ht JOIN players_scores ps ON ht.tournament_id = ps.tournament_id JOIN players p ON ps.player_id = p.player_id JOIN tournaments t ON ht.tournament_id = t.tournament_id ORDER BY score DESC NULLS LAST LIMIT 5;", "raw_model_output": " Code\n<s> SELECT p.player_name, t.tournament_name, ps.score FROM historical_tournaments ht JOIN players_scores ps ON ht.tournament_id = ps.tournament_id JOIN players p ON ps.player_id = p.player_id JOIN tournaments t ON ht.tournament_id = t.tournament_id ORDER BY score DESC NULLS LAST LIMIT 5;", "latency_sec": 1.4868450164794922, "total_duration_sec": 1.185488468, "load_duration_sec": 0.009677001, "tokens_prompt": 191, "prompt_eval_sec": 0.013032746, "tokens_completion": 107, "completion_eval_sec": 1.162097882, "tokens_total": 298, "tokens_per_sec": 200.42438633287793, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL uses aggregation (MAX(players_scores.score)) and groups by player_id and tournament_name to find each player's highest score per tournament, while the Generated SQL selects raw scores without aggregation. Additionally, the Generated SQL lacks the GROUP BY clause and orders by 'score' instead of 'high_score'. The result sets would differ in both structure and content.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is technically flawed: it groups by player_id and tournament_name but uses MAX(score) without proper aggregation logic for per-player maximums. This would return per-tournament max scores rather than overall player scores. The Generated SQL avoids aggregation but incorrectly assumes the view already contains the highest scores, failing to identify the top 5 players based on their maximum scores across all tournaments. Neither query fully addresses the intent, but the Generated SQL is simpler and avoids unnecessary joins/groupings, making it more efficient despite not fulfilling the business requirement.", "overall_assessment": "differently_correct"}}
{"example_id": 2219, "sql_complexity": "window functions", "prompt": "What is the average population of cities with a UNESCO World Heritage designation, ordered by designation date?", "context": "CREATE TABLE cities (name VARCHAR(255), population INT, designation_date DATE); INSERT INTO cities (name, population, designation_date) VALUES ('Paris', 2141000, '1991-09-16'); INSERT INTO cities (name, population, designation_date) VALUES ('Rio de Janeiro', 6727000, '2012-07-01');", "reference_sql": "SELECT AVG(population) FROM (SELECT population, ROW_NUMBER() OVER (ORDER BY designation_date) rn FROM cities WHERE name IN (SELECT name FROM heritagesites)) t WHERE rn % 2 = 1;", "generated_sql": "SELECT AVG(cities.population) FROM cities WHERE cities.name IN (SELECT DISTINCT cities_with_world_heritage_site.city_name FROM cities_with_world_heritage_site);", "raw_model_output": " Code\n<s> SELECT AVG(cities.population) FROM cities WHERE cities.name IN (SELECT DISTINCT cities_with_world_heritage_site.city_name FROM cities_with_world_heritage_site);", "latency_sec": 0.7098312377929688, "total_duration_sec": 0.614171337, "load_duration_sec": 0.008457121, "tokens_prompt": 151, "prompt_eval_sec": 0.01017471, "tokens_completion": 54, "completion_eval_sec": 0.594738743, "tokens_total": 205, "tokens_per_sec": 288.80104042390826, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Reference SQL uses ROW_NUMBER() with ordering by designation_date and filters odd-numbered rows, while the Generated SQL simply averages all cities from a different table (cities_with_world_heritage_site). Second, the Reference SQL's subquery references 'heritagesites' table, whereas the Generated SQL uses 'cities_with_world_heritage_site'\u2014these may contain different data. The row-numbering logic and table differences ensure they produce different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query is incorrect because it uses a ROW_NUMBER() filter (rn % 2 = 1) that arbitrarily selects every other row based on designation date ordering, which is unrelated to the original question's requirement for an average. The generated query correctly calculates the average population of cities with UNESCO designations (assuming the cities_with_world_heritage_site table exists) but fails to address the 'ordered by designation date' requirement. However, the generated query is more aligned with the business intent of averaging designated cities, while the reference query introduces irrelevant logic. Both queries reference non-existent tables (heritagesites and cities_with_world_heritage_site) in the provided schema, making them technically invalid. The generated query is superior because it focuses on the core calculation, even though it lacks the ordering component.", "overall_assessment": "incorrect"}}
{"example_id": 3786, "sql_complexity": "aggregation", "prompt": "Display the names and average co-owner percentages for all properties in the 'property_coownership' table where the co-owner percentage is greater than 60.", "context": "CREATE TABLE property_coownership (property_id INT, owner VARCHAR(255), percentage INT); INSERT INTO property_coownership (property_id, owner, percentage) VALUES (1, 'Mohammed', 70), (1, 'Fatima', 30), (2, 'Jamal', 65), (2, 'Aisha', 35), (3, 'Ali', 75), (3, 'Khadija', 25);", "reference_sql": "SELECT owner, AVG(percentage) FROM property_coownership WHERE percentage > 60 GROUP BY owner;", "generated_sql": "Code\n<s> QUERY", "raw_model_output": " Code\n<s> QUERY", "latency_sec": 0.12206912040710449, "total_duration_sec": 0.115533418, "load_duration_sec": 0.008920804, "tokens_prompt": 166, "prompt_eval_sec": 0.010479151, "tokens_completion": 7, "completion_eval_sec": 0.09527666, "tokens_total": 173, "tokens_per_sec": 1417.2298401351575, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Generated SQL is not provided, making it impossible to determine semantic equivalence. The Reference SQL filters rows where percentage > 60 and groups by owner to calculate average percentages. Without the actual Generated SQL, no comparison can be made.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL is not technically equivalent to the original question's intent. While it correctly filters rows where percentage > 60 and groups by owner, it misinterprets the business requirement. The original question asks for 'average co-owner percentages for all properties' where co-owner percentages exceed 60, implying property-level aggregation. However, the Reference SQL groups by owner, which aggregates across all properties an owner is associated with, not per property. This leads to incorrect results for properties with multiple owners. For example, property 1 (Mohammed 70%, Fatima 30%) would have an average of 50% if grouped by property, but the Reference SQL would show Mohammed's 70% as a separate row. The generated SQL (not provided) might address this, but based on the given Reference SQL, it fails to meet the business intent.", "overall_assessment": "incorrect"}}
{"example_id": 2357, "sql_complexity": "basic SQL", "prompt": "What is the total amount of climate finance invested in renewable energy projects by public and private sectors in Africa?", "context": "CREATE TABLE renewable_energy_projects (project_id INT, sector TEXT, investor_type TEXT, region TEXT, amount FLOAT); INSERT INTO renewable_energy_projects (project_id, sector, investor_type, region, amount) VALUES (1, 'Renewable Energy', 'Public', 'Africa', 5000000); INSERT INTO renewable_energy_projects (project_id, sector, investor_type, region, amount) VALUES (2, 'Renewable Energy', 'Private', 'Africa', 7000000);", "reference_sql": "SELECT SUM(amount) FROM renewable_energy_projects WHERE sector = 'Renewable Energy' AND region = 'Africa';", "generated_sql": "SELECT SUM(CASE WHEN investor_type = 'Public' THEN amount ELSE 0 END) AS public_sector_amount, SUM(CASE WHEN investor_type = 'Private' THEN amount ELSE 0 END) AS private_sector_amount FROM renewable_energy_projects WHERE region = 'Africa';", "raw_model_output": " Code\n<s> QUERY SELECT SUM(CASE WHEN investor_type = 'Public' THEN amount ELSE 0 END) AS public_sector_amount, SUM(CASE WHEN investor_type = 'Private' THEN amount ELSE 0 END) AS private_sector_amount FROM renewable_energy_projects WHERE region = 'Africa';", "latency_sec": 1.8327710628509521, "total_duration_sec": 0.935681817, "load_duration_sec": 0.009832924, "tokens_prompt": 180, "prompt_eval_sec": 0.011191926, "tokens_completion": 84, "completion_eval_sec": 0.913977193, "tokens_total": 264, "tokens_per_sec": 144.04417733949649, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters by both sector = 'Renewable Energy' and region = 'Africa', while the Generated SQL only filters by region = 'Africa' and splits the sum by investor_type. This means the Generated SQL would include projects from other sectors in Africa, leading to different results if such projects exist.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The Reference SQL directly answers the question by summing all investments in 'Renewable Energy' projects in Africa, regardless of investor type. The Generated SQL splits public and private amounts but fails to combine them into a total, which is the core requirement of the question. While both are technically correct, the Reference is more efficient and directly addresses the business intent. The Generated query would require additional computation (summing its two columns) to answer the original question, making it less elegant and efficient.", "overall_assessment": "correct"}}
{"example_id": 1009, "sql_complexity": "multiple_joins", "prompt": "Find the number of IoT sensors installed in each farm that use Sprinkler irrigation.", "context": "CREATE TABLE IoT_Sensors (id INT, sensor_type VARCHAR(50), Farm_id INT); INSERT INTO IoT_Sensors (id, sensor_type, Farm_id) VALUES (1, 'Soil Moisture', 1), (2, 'Temperature', 1), (3, 'Humidity', 2); CREATE TABLE Irrigation (id INT, Farm_id INT, irrigation_type VARCHAR(50), duration INT); INSERT INTO Irrigation (id, Farm_id, irrigation_type, duration) VALUES (1, 1, 'Sprinkler', 30), (2, 2, 'Drip', 45);", "reference_sql": "SELECT f.id, COUNT(s.id) FROM Farmers f JOIN Irrigation i ON f.id = i.Farm_id JOIN IoT_Sensors s ON f.id = s.Farm_id WHERE i.irrigation_type = 'Sprinkler' GROUP BY f.id;", "generated_sql": "SELECT i.farm_id, COUNT(s.sensor_type) AS total_sensors FROM irrigation i JOIN iot_sensors s ON i.farm_id = s.farm_id WHERE i.irrigation_type ILIKE '%sprinkler%' GROUP BY i.farm_id;", "raw_model_output": " Code\n<s> SELECT i.farm_id, COUNT(s.sensor_type) AS total_sensors FROM irrigation i JOIN iot_sensors s ON i.farm_id = s.farm_id WHERE i.irrigation_type ILIKE '%sprinkler%' GROUP BY i.farm_id;", "latency_sec": 1.209671974182129, "total_duration_sec": 0.910921354, "load_duration_sec": 0.008904809, "tokens_prompt": 201, "prompt_eval_sec": 0.015189584, "tokens_completion": 81, "completion_eval_sec": 0.886095599, "tokens_total": 282, "tokens_per_sec": 233.12104935775085, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their WHERE conditions. The Reference SQL uses an exact match ('Sprinkler'), while the Generated SQL uses a case-insensitive partial match ('%sprinkler%'). This makes the Generated SQL more inclusive, potentially returning different results for variations in casing or additional text in irrigation_type. Additionally, the Generated SQL uses ILIKE (PostgreSQL-specific) instead of =, further affecting semantic equivalence.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query references a 'Farmers' table not present in the schema, making it technically invalid. The generated query correctly joins 'Irrigation' and 'IoT_Sensors' tables on Farm_id, filters for 'Sprinkler' irrigation (case-insensitive with ILIKE), and groups by farm_id. While the generated query uses 'iot_sensors' (lowercase) instead of 'IoT_Sensors' (as per schema), this may be a minor case-sensitivity issue. The reference query's logic is correct but fails due to schema mismatch. The generated query better fulfills the business intent by directly addressing the required tables and filtering criteria.", "overall_assessment": "differently_correct"}}
{"example_id": 4217, "sql_complexity": "subqueries", "prompt": "Show consumer preference data for foundations, excluding products from the USA.", "context": "CREATE TABLE cosmetics (product_id INT, product_name VARCHAR(100), product_type VARCHAR(50), is_cruelty_free BOOLEAN, consumer_preference_score INT); INSERT INTO cosmetics (product_id, product_name, product_type, is_cruelty_free, consumer_preference_score) VALUES (1, 'Lipstick A', 'Lipstick', TRUE, 80), (2, 'Foundation B', 'Foundation', FALSE, 90), (3, 'Mascara C', 'Mascara', TRUE, 85), (4, 'Eyeshadow D', 'Eyeshadow', TRUE, 70), (5, 'Blush E', 'Blush', FALSE, 95); CREATE TABLE ingredient_sourcing (ingredient_id INT, ingredient_name VARCHAR(100), sourcing_country VARCHAR(50), is_organic BOOLEAN); INSERT INTO ingredient_sourcing (ingredient_id, ingredient_name, sourcing_country, is_organic) VALUES (1, 'Rosehip Oil', 'Chile', TRUE), (2, 'Shea Butter', 'Ghana', TRUE), (3, 'Jojoba Oil', 'India', TRUE), (4, 'Coconut Oil', 'Philippines', FALSE), (5, 'Aloe Vera', 'USA', TRUE);", "reference_sql": "SELECT * FROM cosmetics WHERE product_type = 'Foundation' AND product_id NOT IN (SELECT cosmetics.product_id FROM cosmetics INNER JOIN ingredient_sourcing ON cosmetics.product_id = ingredient_sourcing.ingredient_id WHERE ingredient_sourcing.sourcing_country = 'USA');", "generated_sql": "SELECT cosmetics.product_id, cosmetics.product_name, cosmetcos.consumer_preference_score FROM cosmetcos WHERE product_type = 'Foundation' AND is_cruelty_free = TRUE AND consumer_preference_score > 75 EXCEPT ingredient_sourcing.ingredient_id, ingredient_sourcing.ingredent_name, ingredient_sourcing.sourcing_country FROM ingredient_sourcing WHERE is_organic = TRUE AND sourcing_country != 'USA';", "raw_model_output": " Code\n<s> SELECT cosmetics.product_id, cosmetics.product_name, cosmetcos.consumer_preference_score FROM cosmetcos WHERE product_type = 'Foundation' AND is_cruelty_free = TRUE AND consumer_preference_score > 75 EXCEPT ingredient_sourcing.ingredient_id, ingredient_sourcing.ingredent_name, ingredient_sourcing.sourcing_country FROM ingredient_sourcing WHERE is_organic = TRUE AND sourcing_country != 'USA';", "latency_sec": 1.6990821361541748, "total_duration_sec": 1.515351099, "load_duration_sec": 0.010365586, "tokens_prompt": 374, "prompt_eval_sec": 0.024495094, "tokens_completion": 130, "completion_eval_sec": 1.479496058, "tokens_total": 504, "tokens_per_sec": 296.6307450802761, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL filters 'cosmetics' rows where product_type is 'Foundation' and excludes those linked to ingredients sourced from 'USA'. The Generated SQL has multiple issues: 1) Typos (cosmetcos, ingredent_name) 2) Uses EXCEPT to compare unrelated result sets (cosmetics vs ingredient_sourcing) 3) Different filtering conditions (cruelty_free, preference score vs sourcing_country). The logical purpose and structure differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL attempts to filter foundations by excluding products linked to USA-sourced ingredients, but contains a critical technical error: it incorrectly joins cosmetics.product_id (product identifier) with ingredient_sourcing.ingredient_id (ingredient identifier), which are unrelated fields. The Generated SQL has severe syntax errors (e.g., 'cosmetcos' typo, invalid EXCEPT clause structure) and fails to properly connect the tables. Neither query correctly addresses the business intent, but the Reference SQL at least attempts to implement the exclusion logic, while the Generated SQL is non-functional. The original question requires excluding products based on ingredient sourcing, which neither query properly achieves due to schema limitations (no product-ingredient relationship table).", "overall_assessment": "incorrect"}}
{"example_id": 5620, "sql_complexity": "basic SQL", "prompt": "What is the recycling rate of plastic in the residential sector in the state of New York?", "context": "CREATE TABLE recycling_rates_city (sector VARCHAR(20), city VARCHAR(20), material VARCHAR(20), recycling_rate DECIMAL(5,2)); INSERT INTO recycling_rates_city (sector, city, material, recycling_rate) VALUES ('residential', 'New York City', 'plastic', 0.25), ('commercial', 'New York City', 'plastic', 0.30), ('residential', 'New York City', 'paper', 0.45), ('commercial', 'New York City', 'paper', 0.50), ('residential', 'Los Angeles', 'plastic', 0.20), ('commercial', 'Los Angeles', 'plastic', 0.35), ('residential', 'Los Angeles', 'paper', 0.40), ('commercial', 'Los Angeles', 'paper', 0.50);", "reference_sql": "SELECT recycling_rate FROM recycling_rates_city WHERE sector = 'residential' AND material = 'plastic' AND city = 'New York City';", "generated_sql": "SELECT recycling_rate FROM recycling_rates_city WHERE \"sector\" ILIKE '%residential%' AND \"material\" ILIKE '%plastic%' AND \"state\" ILIKE '%New York%';", "raw_model_output": " Code\nSELECT recycling_rate FROM recycling_rates_city WHERE \"sector\" ILIKE '%residential%' AND \"material\" ILIKE '%plastic%' AND \"state\" ILIKE '%New York%';", "latency_sec": 0.9367601871490479, "total_duration_sec": 0.63462155, "load_duration_sec": 0.009186016, "tokens_prompt": 252, "prompt_eval_sec": 0.015715767, "tokens_completion": 53, "completion_eval_sec": 0.608726695, "tokens_total": 305, "tokens_per_sec": 325.59026758838064, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL uses exact matches (=) for sector, material, and city, while the Generated SQL uses case-insensitive partial matches (ILIKE with %) for sector, material, and an incorrect 'state' column (which doesn't exist in the schema). The Generated SQL would return more rows due to wildcards and would fail due to the non-existent 'state' column.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query is technically correct and directly addresses the question by filtering exactly on 'residential' sector, 'plastic' material, and 'New York City' (which is the only city in the dataset for New York). The generated query contains multiple issues: 1) It references a non-existent 'state' column in the table 2) It uses ILIKE with wildcards which would match partial values (e.g., 'residential' could match 'residential-commercial') 3) It would fail to find any results because the table lacks state information. While the generated query attempts to account for case insensitivity and potential data variations, it fundamentally misunderstands the schema and would not return valid results.", "overall_assessment": "incorrect"}}
{"example_id": 3151, "sql_complexity": "basic SQL", "prompt": "List all biotech startups that received funding in 2022 and their respective funding amounts.", "context": "CREATE TABLE biotech_startups (name TEXT, funding FLOAT, date DATE); INSERT INTO biotech_startups (name, funding, date) VALUES ('StartupA', 3500000, '2022-02-28'); INSERT INTO biotech_startups (name, funding, date) VALUES ('StartupB', 4500000, '2022-07-12');", "reference_sql": "SELECT name, funding FROM biotech_startups WHERE date BETWEEN '2022-01-01' AND '2022-12-31';", "generated_sql": "SELECT name, to_char(date,'YYYY-MM-DD') AS date, funding FROM biotech_startups WHERE to_number(to_char(date,'YYYY'),'9999') = 2022;", "raw_model_output": " Code\n<s> #_of_biotech_startups = SELECT name, to_char(date,'YYYY-MM-DD') AS date, funding FROM biotech_startups WHERE to_number(to_char(date,'YYYY'),'9999') = 2022;", "latency_sec": 1.0030357837677002, "total_duration_sec": 0.785512764, "load_duration_sec": 0.0081409, "tokens_prompt": 152, "prompt_eval_sec": 0.011057548, "tokens_completion": 70, "completion_eval_sec": 0.765529386, "tokens_total": 222, "tokens_per_sec": 221.32809575955713, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects only 'name' and 'funding' columns, while the Generated SQL adds a formatted 'date' column. Additionally, the WHERE clause in the Generated SQL uses a year-based filter (extracting the year via to_char and to_number) which may behave differently than the BETWEEN date range in the Reference SQL, especially with time components or edge cases. The column structure difference also makes the result sets non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent because the generated query adds an extra 'date' column (via to_char) that the original question did not request. While both retrieve the correct startups and funding amounts, the reference query strictly adheres to the required output columns (name, funding). The generated query's use of date functions (to_char/to_number) is less efficient and could fail if date formats vary. Both fulfill the business intent of identifying 2022-funded startups, but the reference query is more efficient, elegant, and precisely matches the required output.", "overall_assessment": "differently_correct"}}
{"example_id": 2136, "sql_complexity": "window functions", "prompt": "What is the total military equipment sales revenue for each sales representative by fiscal year?", "context": "CREATE TABLE SalesReps (SalesRepID INT, SalesRepName VARCHAR(50), FiscalYear INT, Revenue DECIMAL(10,2)); INSERT INTO SalesReps (SalesRepID, SalesRepName, FiscalYear, Revenue) VALUES (1, 'John Doe', 2020, 150000.00), (2, 'Jane Smith', 2020, 200000.00), (1, 'John Doe', 2021, 180000.00), (2, 'Jane Smith', 2021, 250000.00);", "reference_sql": "SELECT SalesRepName, FiscalYear, SUM(Revenue) OVER (PARTITION BY SalesRepName ORDER BY FiscalYear) AS TotalRevenue FROM SalesReps;", "generated_sql": "SELECT SalesReps.SalesRepName, SalesReps.FiscalYear, SUM(SalesReps.Revenue) AS Total_Revenue FROM SalesReps GROUP BY SalesReps.SalesRepName, SalesReps.FiscalYear ORDER BY SalesReps.SalesRepName NULLS LAST, SalesReps.FiscalYear NULLS LAST;", "raw_model_output": " Code\n<s> SELECT SalesReps.SalesRepName, SalesReps.FiscalYear, SUM(SalesReps.Revenue) AS Total_Revenue FROM SalesReps GROUP BY SalesReps.SalesRepName, SalesReps.FiscalYear ORDER BY SalesReps.SalesRepName NULLS LAST, SalesReps.FiscalYear NULLS LAST;", "latency_sec": 1.3392589092254639, "total_duration_sec": 1.067820444, "load_duration_sec": 0.00867575, "tokens_prompt": 200, "prompt_eval_sec": 0.011608324, "tokens_completion": 96, "completion_eval_sec": 1.046801587, "tokens_total": 296, "tokens_per_sec": 221.01775688106957, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates a running total (cumulative sum) of Revenue for each SalesRepName ordered by FiscalYear using a window function. The Generated SQL aggregates Revenue by SalesRepName and FiscalYear, returning only the individual year's revenue instead of a cumulative sum. The window function preserves all rows with calculated totals, while the GROUP BY collapses rows and sums values per group, leading to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL uses a window function to create a running total per sales representative across fiscal years, which does not match the requirement for 'total revenue for each sales representative by fiscal year.' The Generated SQL correctly groups by SalesRepName and FiscalYear, then sums revenue, which accurately calculates the total revenue per rep per year. While both queries are syntactically correct, their semantic outputs differ: the Reference provides cumulative sums while the Generated provides discrete yearly totals. The Generated SQL directly addresses the business intent of isolating revenue by specific fiscal years.", "overall_assessment": "differently_correct"}}
{"example_id": 5452, "sql_complexity": "basic SQL", "prompt": "What is the name of the farms with a size greater than 150 acres located in 'Texas'?", "context": "CREATE TABLE farms (id INT PRIMARY KEY, name VARCHAR(50), size INT, location VARCHAR(50)); INSERT INTO farms (id, name, size, location) VALUES (1, 'Smith Farms', 200, 'Texas'), (2, 'Johnson Farms', 100, 'California');", "reference_sql": "SELECT name FROM farms WHERE size > 150 AND location = 'Texas'", "generated_sql": "SELECT farms.name FROM farms WHERE farms.size > 150 AND farms.location ILIKE '%Texas%';", "raw_model_output": " Code\nSELECT farms.name FROM farms WHERE farms.size > 150 AND farms.location ILIKE '%Texas%';", "latency_sec": 0.46482086181640625, "total_duration_sec": 0.345562482, "load_duration_sec": 0.008441617, "tokens_prompt": 122, "prompt_eval_sec": 0.007495451, "tokens_completion": 30, "completion_eval_sec": 0.328941258, "tokens_total": 152, "tokens_per_sec": 327.0076979893311, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their location condition. The reference uses exact string matching (= 'Texas') while the generated uses case-insensitive partial matching (ILIKE '%Texas%'). This means the generated query would match locations containing 'Texas' in any case (e.g., 'texas', 'TEXAS', 'South Texas') whereas the reference only matches exact 'Texas' values. Additionally, the generated query explicitly qualifies the column with table name (farms.name) but this doesn't affect the result.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly filters for exact matches of 'Texas' in the location column using strict equality, while the Generated SQL uses ILIKE with a wildcard (%), which would match any location containing 'Texas' (e.g., 'Texas City', 'North Texas'). This makes them technically non-equivalent. The Reference directly addresses the business intent of finding farms *located in* Texas, whereas the Generated query would return unintended results. The Reference is also more efficient as it avoids wildcard-based pattern matching.", "overall_assessment": "differently_correct"}}
{"example_id": 5152, "sql_complexity": "aggregation", "prompt": "How many international tourists visited Portugal in 2020, broken down by continent?", "context": "CREATE TABLE international_tourists(tourist_id INT, country TEXT, arrival_year INT, continent TEXT);INSERT INTO international_tourists (tourist_id, country, arrival_year, continent) VALUES (1, 'Spain', 2020, 'Europe'), (2, 'France', 2020, 'Europe'), (3, 'Brazil', 2020, 'South America'), (4, 'United States', 2020, 'North America'), (5, 'China', 2020, 'Asia');", "reference_sql": "SELECT continent, COUNT(*) FROM international_tourists WHERE arrival_year = 2020 GROUP BY continent;", "generated_sql": "SELECT international_tourists.continent, COUNT(*) AS number_of_tourists FROM international_tourists WHERE international_tourists.country ilike '%Port%' AND international_tourists.arrival_year = 2020 GROUP BY international_tourists.continent ORDER BY number_of_tourists DESC NULLS LAST;", "raw_model_output": " Code\n<s> SELECT international_tourists.continent, COUNT(*) AS number_of_tourists FROM international_tourists WHERE international_tourists.country ilike '%Port%' AND international_tourists.arrival_year = 2020 GROUP BY international_tourists.continent ORDER BY number_of_tourists DESC NULLS LAST;", "latency_sec": 1.14650297164917, "total_duration_sec": 1.048488195, "load_duration_sec": 0.008187159, "tokens_prompt": 172, "prompt_eval_sec": 0.01204639, "tokens_completion": 94, "completion_eval_sec": 1.027505161, "tokens_total": 266, "tokens_per_sec": 232.0098652839742, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL counts all tourists from 2020 grouped by continent, while the Generated SQL adds a filter for countries containing 'Port' (which excludes all sample data) and includes an ORDER BY clause not present in the Reference. This makes their results fundamentally different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is technically incorrect for the question because it lacks a filter for Portugal in the 'country' column. It counts all international tourists in 2020 without restricting to those visiting Portugal. The Generated SQL includes a filter for 'country ilike '%Port%'', which would capture tourists from Portugal (assuming 'country' refers to origin) but has two issues: 1) 'ilike' is case-insensitive, which may not align with data consistency, and 2) 'country ilike '%Port%'' is overly broad (e.g., matching 'Porto' or 'Portugal'). However, it at least attempts to address the destination requirement. Neither query is perfect due to ambiguous schema (e.g., 'country' vs. 'destination'), but the Generated SQL better aligns with the intent by including a country filter.", "overall_assessment": "differently_correct"}}
{"example_id": 2477, "sql_complexity": "set operations", "prompt": "What is the carbon price in Europe and Australia for the last quarter of 2020?", "context": "CREATE TABLE CarbonPrices (Country TEXT, Year INT, Quarter INT, CarbonPrice NUMBER); INSERT INTO CarbonPrices (Country, Year, Quarter, CarbonPrice) VALUES ('Europe', 2020, 4, 25), ('Australia', 2020, 4, 15); CREATE TABLE CarbonTaxes (Country TEXT, Year INT, Quarter INT, CarbonPrice NUMBER); INSERT INTO CarbonTaxes (Country, Year, Quarter, CarbonPrice) VALUES ('Europe', 2019, 4, 20), ('Australia', 2019, 4, 10);", "reference_sql": "SELECT Context.Country, Context.CarbonPrice FROM ( SELECT * FROM CarbonPrices WHERE CarbonPrices.Country IN ('Europe', 'Australia') AND CarbonPrices.Year = 2020 AND CarbonPrices.Quarter = 4 UNION SELECT * FROM CarbonTaxes WHERE CarbonTaxes.Country IN ('Europe', 'Australia') AND CarbonTaxes.Year = 2020 AND CarbonTaxes.Quarter = 4 ) AS Context;", "generated_sql": "SELECT CarbonPrices.Country, CarbonPrices.Year, CarbonPrices.Quarter, CarbonTaxes.CarbonTaxed FROM CarbonPrices JOIN CarbonTaxes ON CarbonPrices.Country = CarbonTaxes.Country AND CarbonPrices.Year = CarbonTaxes.Year AND CarbonPrices.Quarter = CarbonTaxes.Quarter WHERE CarbonPrices.Country IN ('Europe', 'Australia') AND CarbonPrices.Year = 2020 AND CarbonPrices.Quarter = 4;", "raw_model_output": " code (Haskell)\n<s> SELECT CarbonPrices.Country, CarbonPrices.Year, CarbonPrices.Quarter, CarbonTaxes.CarbonTaxed FROM CarbonPrices JOIN CarbonTaxes ON CarbonPrices.Country = CarbonTaxes.Country AND CarbonPrices.Year = CarbonTaxes.Year AND CarbonPrices.Quarter = CarbonTaxes.Quarter WHERE CarbonPrices.Country IN ('Europe', 'Australia') AND CarbonPrices.Year = 2020 AND CarbonPrices.Quarter = 4;", "latency_sec": 1.7075238227844238, "total_duration_sec": 1.506091639, "load_duration_sec": 0.0095989, "tokens_prompt": 195, "prompt_eval_sec": 0.011517227, "tokens_completion": 137, "completion_eval_sec": 1.48443004, "tokens_total": 332, "tokens_per_sec": 194.4335976868624, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL combines (UNION) rows from CarbonPrices and CarbonTaxes where Year=2020 and Quarter=4, returning Country and CarbonPrice. The Generated SQL performs a JOIN between CarbonPrices and CarbonTaxes on all three columns (Country, Year, Quarter), but since CarbonTaxes has no data for 2020, it returns no rows. Additionally, the Generated SQL selects different columns (Year, Quarter, CarbonTaxed) compared to the Reference SQL's Country and CarbonPrice.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The Reference SQL correctly retrieves carbon prices from the CarbonPrices table for Europe and Australia in Q4 2020 by using a UNION to combine results from both tables (though only CarbonPrices has relevant data here). The Generated SQL incorrectly uses a JOIN between CarbonPrices and CarbonTaxes, which would return no results because CarbonTaxes lacks 2020 Q4 data. While both queries filter for the correct countries and time frame, the Generated SQL's JOIN logic fails to account for potential data absence in one table. The Reference SQL better fulfills the business intent by directly accessing the relevant table and ensuring data availability.", "overall_assessment": "differently_correct"}}
{"example_id": 4573, "sql_complexity": "subqueries", "prompt": "Find the names of all the indigenous communities in the 'Arctic_Communities' table that have a population size greater than the average population size in the 'Antarctic_Communities' table.", "context": "CREATE TABLE Arctic_Communities (name TEXT, population INTEGER); CREATE TABLE Antarctic_Communities (name TEXT, population INTEGER);", "reference_sql": "SELECT name FROM Arctic_Communities WHERE Arctic_Communities.population > (SELECT AVG(population) FROM Antarctic_Communities)", "generated_sql": "SELECT name FROM ArCTIC_COMMUNITIES WHERE population > (SELECT AVG(population) FROM ANTARCTIC_COMMUNITIES));", "raw_model_output": " Code\n<s> #_of_communities_with_larger_population = (SELECT name FROM ArCTIC_COMMUNITIES WHERE population > (SELECT AVG(population) FROM ANTARCTIC_COMMUNITIES));", "latency_sec": 0.870502233505249, "total_duration_sec": 0.57238376, "load_duration_sec": 0.007869942, "tokens_prompt": 98, "prompt_eval_sec": 0.008346597, "tokens_completion": 52, "completion_eval_sec": 0.555476352, "tokens_total": 150, "tokens_per_sec": 172.3143195118471, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in table name casing. The Reference SQL uses 'Arctic_Communities' and 'Antarctic_Communities', while the Generated SQL uses 'ArCTIC_COMMUNITIES' and 'ANTARCTIC_COMMUNITIES'. SQL is typically case-sensitive for identifiers, so these would reference different tables unless the database is explicitly case-insensitive, which is not indicated here.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in table name casing and syntax. The reference query uses exact table names ('Arctic_Communities' and 'Antarctic_Communities') matching the schema, while the generated query uses incorrect casing ('ArCTIC_COMMUNITIES' and 'ANTARCTIC_COMMUNITIES') which would fail in case-sensitive databases. Additionally, the generated query contains a syntax error with an extra closing parenthesis and semicolon. Although the logical structure is identical, the technical implementation flaws in the generated query prevent it from executing correctly. Both queries aim to fulfill the business intent, but only the reference query does so technically correctly.", "overall_assessment": "incorrect"}}
{"example_id": 3596, "sql_complexity": "window functions", "prompt": "What is the total revenue for each game in the \"Gaming\" category?", "context": "CREATE TABLE Games (GameID int, GameName varchar(50), Category varchar(50), Revenue decimal(10,2));", "reference_sql": "SELECT Category, SUM(Revenue) OVER(PARTITION BY Category) as TotalRevenue FROM Games;", "generated_sql": "SELECT g.GameID, SUM(g.Revenue) AS total_revenue FROM Games g WHERE g.Category = 'Gaming' GROUP BY g.GameID;", "raw_model_output": " Code\nSELECT g.GameID, SUM(g.Revenue) AS total_revenue FROM Games g WHERE g.Category = 'Gaming' GROUP BY g.GameID;", "latency_sec": 0.5783839225769043, "total_duration_sec": 0.479302809, "load_duration_sec": 0.010121855, "tokens_prompt": 65, "prompt_eval_sec": 0.006978734, "tokens_completion": 44, "completion_eval_sec": 0.461641461, "tokens_total": 109, "tokens_per_sec": 188.45613742921236, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates total revenue per category using a window function, returning Category and TotalRevenue for all categories. The generated query filters only 'Gaming' category, groups by GameID, and returns individual game revenues instead of category totals. The output structure and logic differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL calculates total revenue per category (not per game) using a window function, which does not align with the original question's focus on individual games. The Generated SQL groups by GameID and sums Revenue, which would correctly aggregate revenue per game if multiple entries exist per game. However, if each GameID is unique, the SUM is redundant but still returns the correct per-game revenue. While neither query is perfect, the Generated SQL better addresses the intent of analyzing revenue per game in the Gaming category.", "overall_assessment": "differently_correct"}}
{"example_id": 5039, "sql_complexity": "subqueries", "prompt": "What is the total number of community policing events in 'City Park' in 2021?", "context": "CREATE TABLE locations (id INT, name VARCHAR(255)); CREATE TABLE community_policing (id INT, location_id INT, year INT, events INT); INSERT INTO locations (id, name) VALUES (1, 'City Park'); INSERT INTO community_policing (id, location_id, year, events) VALUES (1, 1, 2021, 5);", "reference_sql": "SELECT SUM(events) FROM community_policing WHERE location_id = (SELECT id FROM locations WHERE name = 'City Park') AND year = 2021;", "generated_sql": "SELECT SUM(events) AS total_events FROM community_policing WHERE location_id = 1 AND year = 2021;", "raw_model_output": " Code\n<s> QUERY SELECT SUM(events) AS total_events FROM community_policing WHERE location_id = 1 AND year = 2021;", "latency_sec": 0.6419782638549805, "total_duration_sec": 0.441267737, "load_duration_sec": 0.00882359, "tokens_prompt": 134, "prompt_eval_sec": 0.008115284, "tokens_completion": 39, "completion_eval_sec": 0.423674535, "tokens_total": 173, "tokens_per_sec": 269.4795287322684, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of 'events' for the location with ID 1 (City Park) in 2021. The Reference SQL uses a subquery to dynamically get the location_id from the locations table, but since the sample data explicitly inserts location_id=1 for 'City Park', the Generated SQL hardcodes this value. The WHERE conditions (location_id = 1 AND year = 2021) are logically identical in both queries.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries produce identical results in this context. The reference query correctly uses a subquery to dynamically retrieve the location_id based on the name 'City Park', which aligns with the business intent of querying by location name rather than ID. The generated query hardcodes the location_id=1, which works for the given data but lacks flexibility if the location ID changes. While both are technically correct, the reference query better fulfills the business intent by using the named location, making it more maintainable and semantically aligned with the original question.", "overall_assessment": "correct"}}
{"example_id": 2724, "sql_complexity": "basic SQL", "prompt": "What is the earliest installation date for solar panels in Italy?", "context": "CREATE TABLE solar_panels_italy (id INT, installation_date DATE); INSERT INTO solar_panels_italy (id, installation_date) VALUES (1, '2018-01-01'), (2, '2019-01-01'), (3, '2020-01-01');", "reference_sql": "SELECT MIN(installation_date) as earliest_date FROM solar_panels_italy;", "generated_sql": "SELECT MIN(solar_panels_italy.installation_date) AS earliest_installation_date FROM solar_panels_italy WHERE country_code = 'ITaly';", "raw_model_output": " code to solve problem\nSELECT MIN(solar_panels_italy.installation_date) AS earliest_installation_date FROM solar_panels_italy WHERE country_code = 'ITaly';", "latency_sec": 0.6120476722717285, "total_duration_sec": 0.519573771, "load_duration_sec": 0.008548728, "tokens_prompt": 114, "prompt_eval_sec": 0.007523804, "tokens_completion": 47, "completion_eval_sec": 0.50286655, "tokens_total": 161, "tokens_per_sec": 263.05140480711026, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The generated query references a non-existent 'country_code' column (schema only has 'id' and 'installation_date'). The reference query correctly uses the existing column. Additionally, the generated query would fail due to invalid column reference, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query is technically correct and directly addresses the question by finding the minimum installation date in the solar_panels_italy table. The generated query contains two critical issues: 1) It references a 'country_code' column that doesn't exist in the schema, causing a syntax error, and 2) It unnecessarily filters data when the table name itself ('solar_panels_italy') already implies the dataset is specific to Italy. While both queries aim to find the earliest installation date, the generated query fails due to invalid column reference and adds redundant filtering. The reference query is more efficient and semantically aligned with the schema.", "overall_assessment": "incorrect"}}
{"example_id": 2200, "sql_complexity": "single join", "prompt": "Which diversity programs are currently being participated in by employees in the HR department?", "context": "CREATE TABLE Employees (Employee_ID INT, First_Name VARCHAR(20), Last_Name VARCHAR(20), Department VARCHAR(20), Salary DECIMAL(10,2), Date_Hired DATE); CREATE TABLE Diversity_Programs (Program_ID INT, Program_Name VARCHAR(50), Participant_ID INT, Date_Started DATE, Date_Ended DATE);", "reference_sql": "SELECT dp.Program_Name FROM Diversity_Programs dp JOIN Employees e ON dp.Participant_ID = e.Employee_ID WHERE e.Department = 'HR' AND dp.Date_Ended IS NULL;", "generated_sql": "SELECT dp.program_name FROM diversity_programs dp JOIN employees e ON dp.participant_id = e.employee_id WHERE e.department ilike '%HR%' AND dp.date_started <= CURRENT_DATE AND (dp.date_ended >= CURRENT_DATE OR dp.date_ended IS NULL);", "raw_model_output": " Code\nSELECT dp.program_name FROM diversity_programs dp JOIN employees e ON dp.participant_id = e.employee_id WHERE e.department ilike '%HR%' AND dp.date_started <= CURRENT_DATE AND (dp.date_ended >= CURRENT_DATE OR dp.date_ended IS NULL);", "latency_sec": 1.1902520656585693, "total_duration_sec": 0.891153226, "load_duration_sec": 0.008627586, "tokens_prompt": 133, "prompt_eval_sec": 0.008081249, "tokens_completion": 81, "completion_eval_sec": 0.873652081, "tokens_total": 214, "tokens_per_sec": 179.7938488614118, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in several key aspects.  The Reference query uses an exact match for 'HR' in the Department column, while the Generated query uses a case-insensitive partial match ('%HR%').  Additionally, the Generated query includes additional date constraints: it requires that the program has started (Date_Started <= CURRENT_DATE) and that the program is either still ongoing (Date_Ended >= CURRENT_DATE) or has no end date (Date_Ended IS NULL).  The Reference query only checks for the absence of an end date. These differences in filtering conditions will result in different result sets.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries differ in three key aspects:\n1. Department filtering: Reference uses exact match 'HR' while Generated uses case-insensitive partial match '%HR%', which could include non-HR departments like 'Human Resources'.\n2. Date logic: Reference checks for Date_Ended IS NULL (assuming programs without end dates are active), while Generated uses a more complex condition (Date_Started <= current date AND (Date_Ended >= current date OR Date_Ended IS NULL)) which better captures active programs.\n3. Case sensitivity: Generated uses ilike (case-insensitive) while Reference uses standard = operator.\nWhile Generated's date logic is more comprehensive, the department filter in Generated could return incorrect results. The Reference accurately targets HR department employees but may miss programs with future end dates. The original question's intent to find HR employees in active programs is better fulfilled by the Reference due to precise department filtering, despite its simpler date logic.", "overall_assessment": "correct"}}
{"example_id": 4359, "sql_complexity": "window functions", "prompt": "Which destinations have the least hotel awards?", "context": "CREATE TABLE Destinations (destination_id INT, destination_name TEXT, country TEXT, awards INT); INSERT INTO Destinations (destination_id, destination_name, country, awards) VALUES (1, 'City A', 'Germany', 3), (2, 'City B', 'Switzerland', 5), (3, 'City C', 'Norway', 2);", "reference_sql": "SELECT destination_name, country, awards, RANK() OVER (PARTITION BY country ORDER BY awards ASC) AS rank FROM Destinations;", "generated_sql": "SELECT Destinations.destination_id, Destinations.destination_name, Destinations.country, MIN(Destinations.awards) AS min_awards FROM Destinations GROUP BY Destinations.destination_id, Destinations.destination_name, Destinations.country ORDER BY min_awards ASC NULLS LAST;", "raw_model_output": " Code\nSELECT Destinations.destination_id, Destinations.destination_name, Destinations.country, MIN(Destinations.awards) AS min_awards FROM Destinations GROUP BY Destinations.destination_id, Destinations.destination_name, Destinations.country ORDER BY min_awards ASC NULLS LAST;", "latency_sec": 0.914201021194458, "total_duration_sec": 0.82173474, "load_duration_sec": 0.009359246, "tokens_prompt": 113, "prompt_eval_sec": 0.007555826, "tokens_completion": 75, "completion_eval_sec": 0.804165527, "tokens_total": 188, "tokens_per_sec": 205.64404943933098, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates a rank within each country based on awards, while the Generated SQL groups by destination and calculates a redundant MIN(awards) column. The selected columns differ (destination_id vs. rank), and the Generated SQL's grouping/aggregate logic fundamentally changes the data structure and purpose. The order by in the Generated SQL also doesn't affect semantic equivalence since it's not part of the result set's content.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL calculates ranks within countries but doesn't filter for minimum awards, while the Generated SQL orders destinations by awards but uses unnecessary grouping. Neither query directly identifies destinations with the least awards. The Reference SQL's partitioning by country is irrelevant to the question, which doesn't mention country-based comparisons. The Generated SQL's MIN() function is redundant since it's applied to individual rows (due to grouping by unique destination_id). However, the Generated SQL's ordering by awards brings it closer to the intent than the Reference SQL's ranking approach.", "overall_assessment": "differently_correct"}}
{"example_id": 1373, "sql_complexity": "subqueries", "prompt": "What is the total value of military equipment sales to Africa in the last 12 months?", "context": "CREATE TABLE Military_Equipment_Sales(sale_id INT, sale_date DATE, equipment_type VARCHAR(50), country VARCHAR(50), sale_value DECIMAL(10,2));", "reference_sql": "SELECT SUM(sale_value) FROM Military_Equipment_Sales WHERE country IN (SELECT country FROM World_Countries WHERE continent = 'Africa') AND sale_date >= DATE_SUB(CURRENT_DATE, INTERVAL 12 MONTH);", "generated_sql": "SELECT SUM(sale_value) AS total_sales FROM Military_Equipment_Sales WHERE country = 'Africa' AND sale_date >= (CURRENT_DATE - interval '12 months');", "raw_model_output": " Code\nSELECT SUM(sale_value) AS total_sales FROM Military_Equipment_Sales WHERE country = 'Africa' AND sale_date >= (CURRENT_DATE - interval '12 months');", "latency_sec": 0.7356216907501221, "total_duration_sec": 0.53932989, "load_duration_sec": 0.00856787, "tokens_prompt": 88, "prompt_eval_sec": 0.006613354, "tokens_completion": 49, "completion_eval_sec": 0.523559264, "tokens_total": 137, "tokens_per_sec": 186.23703151044865, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their country filtering logic. The Reference SQL uses a subquery to select countries in Africa from World_Countries, while the Generated SQL incorrectly filters for a country named 'Africa' (a continent, not a country). This would produce different results unless 'Africa' is explicitly listed as a country in the Military_Equipment_Sales table, which is unlikely. The date calculations are equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries differ fundamentally in how they identify African countries. The reference query correctly uses a subquery to find all countries in Africa from the World_Countries table, ensuring it captures all relevant sales. The generated query incorrectly assumes 'Africa' is a valid country value in the country column, which likely contains specific country names rather than continent names. Both handle the 12-month date filter correctly, but the generated query's approach to country identification fails to meet the business intent of aggregating sales to the African continent.", "overall_assessment": "differently_correct"}}
{"example_id": 904, "sql_complexity": "basic SQL", "prompt": "What is the minimum Shariah-compliant loan amount issued in the last quarter of 2021?", "context": "CREATE TABLE loans (id INT, amount DECIMAL, date DATE, loan_type VARCHAR); INSERT INTO loans (id, amount, date, loan_type) VALUES (1, 5000, '2021-09-05', 'Shariah-compliant'), (2, 7000, '2021-10-07', 'socially responsible'), (3, 9000, '2021-11-03', 'Shariah-compliant'), (4, 11000, '2021-12-31', 'Shariah-compliant');", "reference_sql": "SELECT MIN(amount) FROM loans WHERE EXTRACT(YEAR FROM date) = 2021 AND EXTRACT(QUARTER FROM date) = 4 AND loan_type = 'Shariah-compliant';", "generated_sql": "SELECT MIN(amount) AS min_loan_amount FROM loans WHERE loan_type = 'Shariah-compliant' AND date >= '2021-10-01';", "raw_model_output": " Code\nSELECT MIN(amount) AS min_loan_amount FROM loans WHERE loan_type = 'Shariah-compliant' AND date >= '2021-10-01';", "latency_sec": 0.8358008861541748, "total_duration_sec": 0.535113487, "load_duration_sec": 0.011728243, "tokens_prompt": 201, "prompt_eval_sec": 0.01445902, "tokens_completion": 46, "completion_eval_sec": 0.507052781, "tokens_total": 247, "tokens_per_sec": 295.52493194466115, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query explicitly filters for dates in the 4th quarter of 2021 using EXTRACT(QUARTER FROM date) = 4 and EXTRACT(YEAR FROM date) = 2021. The generated query uses date >= '2021-10-01', which includes all dates from October 1, 2021, onward. However, this condition does not restrict the year, so it could include dates in 2022 or later (if present) that the reference query would exclude. Thus, the queries are not semantically equivalent in all cases.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly identifies the last quarter of 2021 by explicitly checking both the year (EXTRACT(YEAR) = 2021) and quarter (EXTRACT(QUARTER) = 4). The Generated SQL uses a date range (date >= '2021-10-01') which implicitly captures Q4 2021 but lacks an explicit year check. While this works for the sample data, it could include loans from future years (e.g., 2022-10-01) if they exist, violating the 2021 constraint. The Reference SQL is more precise and technically correct for the business intent, which requires strict adherence to the 2021 timeframe.", "overall_assessment": "correct"}}
{"example_id": 3299, "sql_complexity": "set operations", "prompt": "How many schools and hospitals are there in Colombia and which ones need repairs?", "context": "CREATE TABLE schools (id INT, country VARCHAR(20), name VARCHAR(50), needs_repair BOOLEAN); CREATE TABLE hospitals (id INT, country VARCHAR(20), name VARCHAR(50), needs_repair BOOLEAN);", "reference_sql": "SELECT 'Schools' as facility_type, COUNT(*) as total, SUM(needs_repair) as repairs_needed FROM schools WHERE country = 'Colombia' UNION ALL SELECT 'Hospitals' as facility_type, COUNT(*) as total, SUM(needs_repair) as repairs_needed FROM hospitals WHERE country = 'Colombia';", "generated_sql": "SELECT COUNT(*) FROM schools WHERE country = 'Colombia';", "raw_model_output": " Code\n<s> # of schools: SELECT COUNT(*) FROM schools WHERE country = 'Colombia'; number of hospitals: SELECT COUNT(*) FROM hospitals WHERE country = 'Colombia'; schools that need repairs: SELECT COUNT(*) FROM schools WHERE needs_repair = TRUE AND country = 'Colombia'; hospitals that need repairs: SELECT COUNT(*) FROM hospitals WHERE needs_repair = TRUE AND country = 'colombia';", "latency_sec": 1.1627819538116455, "total_duration_sec": 1.085185546, "load_duration_sec": 0.008527633, "tokens_prompt": 92, "prompt_eval_sec": 0.008207017, "tokens_completion": 100, "completion_eval_sec": 1.067855275, "tokens_total": 192, "tokens_per_sec": 165.12124166583112, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL combines data from both 'schools' and 'hospitals' tables with facility type categorization, while the Generated SQL only queries the 'schools' table and returns a single count. The Reference SQL provides aggregated metrics for both facility types with separate rows, whereas the Generated SQL returns a single numeric value without any categorization. The two queries differ in both structure and output semantics.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly addresses both parts of the question by counting schools and hospitals in Colombia and calculating repairs needed for each. The generated query only counts schools and ignores hospitals entirely. While both are technically valid SQL, they produce fundamentally different results. The reference query uses UNION ALL to combine separate counts for each facility type, while the generated query provides only a partial answer. The reference better fulfills the business intent of identifying both facility types and their repair needs.", "overall_assessment": "incorrect"}}
{"example_id": 907, "sql_complexity": "set operations", "prompt": "What is the total quantity of items with type 'E' or type 'F' in warehouse O and warehouse P?", "context": "CREATE TABLE warehouse_o(item_id INT, item_type VARCHAR(10), quantity INT);CREATE TABLE warehouse_p(item_id INT, item_type VARCHAR(10), quantity INT);INSERT INTO warehouse_o(item_id, item_type, quantity) VALUES (1, 'E', 200), (2, 'F', 300), (3, 'E', 50), (4, 'F', 400);INSERT INTO warehouse_p(item_id, item_type, quantity) VALUES (1, 'E', 150), (2, 'F', 250), (3, 'E', 40), (4, 'F', 350);", "reference_sql": "SELECT quantity FROM warehouse_o WHERE item_type IN ('E', 'F') UNION ALL SELECT quantity FROM warehouse_p WHERE item_type IN ('E', 'F');", "generated_sql": "SELECT SUM(quantity) AS total_quantity FROM warehouse_o WHERE item_type IN ('E', 'F') UNION ALL SELECT SUM(quantity) AS total_quantity FROM warehouse_p WHERE item_type IN ('E', 'F');", "raw_model_output": " Code\nSELECT SUM(quantity) AS total_quantity FROM warehouse_o WHERE item_type IN ('E', 'F') UNION ALL SELECT SUM(quantity) AS total_quantity FROM warehouse_p WHERE item_type IN ('E', 'F');", "latency_sec": 0.9121949672698975, "total_duration_sec": 0.713107889, "load_duration_sec": 0.009135201, "tokens_prompt": 211, "prompt_eval_sec": 0.015856226, "tokens_completion": 61, "completion_eval_sec": 0.685922917, "tokens_total": 272, "tokens_per_sec": 298.18186874464686, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns individual quantity values from both tables, while the Generated SQL returns summed totals for each table. The Reference produces a list of raw quantities (e.g., 200, 300, 50, 400, 150, 250, 40, 350), whereas the Generated query aggregates quantities per table (e.g., 950 for warehouse_o and 790 for warehouse_p). The result structures and values differ fundamentally.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference SQL returns individual quantities from both warehouses without aggregation, which does not answer the question for a total. The generated SQL correctly sums quantities per warehouse but uses UNION ALL to produce two separate totals instead of combining them into a single total. While neither query fully meets the intent, the generated SQL better addresses the business need by summing quantities rather than listing them. The reference SQL fails to aggregate at all, making it less aligned with the goal of calculating a total.", "overall_assessment": "incorrect"}}
{"example_id": 1400, "sql_complexity": "single join", "prompt": "What is the maximum co-ownership duration for properties in the neighborhood of 'Chinatown' in San Francisco?'", "context": "CREATE TABLE sf_neighborhoods (neighborhood_id INT, name VARCHAR(255), city VARCHAR(255)); INSERT INTO sf_neighborhoods (neighborhood_id, name, city) VALUES (1, 'Chinatown', 'San Francisco'); CREATE TABLE co_ownership (co_ownership_id INT, property_id INT, co_owner_id INT, start_date DATE, end_date DATE); INSERT INTO co_ownership (co_ownership_id, property_id, co_owner_id, start_date, end_date) VALUES (1, 1, 2, '2010-01-01', '2020-01-01'), (2, 2, 3, '2015-01-01', '2022-01-01'); CREATE TABLE properties (property_id INT, city VARCHAR(255)); INSERT INTO properties (property_id, city) VALUES (1, 'San Francisco'), (2, 'San Francisco');", "reference_sql": "SELECT MAX(DATEDIFF(end_date, start_date)) as max_duration FROM co_ownership JOIN properties ON co_ownership.property_id = properties.property_id WHERE properties.city = 'San Francisco' AND name = 'Chinatown';", "generated_sql": "Code\n<s> SELECT MAX(end_date - start_date) AS max_duration FROM co_ownership JOIN properties ON co_ownership.property_id = properties.property_id WHERE neighborhood_id = (SELECT neighborhood_id FROM sf_neighborhoods WHERE name ilike '%Chinatown%' AND city ilike '%San Francisco%')", "raw_model_output": " Code\n<s> SELECT MAX(end_date - start_date) AS max_duration FROM co_ownership JOIN properties ON co_ownership.property_id = properties.property_id WHERE neighborhood_id = (SELECT neighborhood_id FROM sf_neighborhoods WHERE name ilike '%Chinatown%' AND city ilike '%San Francisco%')", "latency_sec": 1.1464087963104248, "total_duration_sec": 0.954206721, "load_duration_sec": 0.008126814, "tokens_prompt": 303, "prompt_eval_sec": 0.020228796, "tokens_completion": 80, "completion_eval_sec": 0.925201304, "tokens_total": 383, "tokens_per_sec": 334.0867596555768, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL references 'name' in the WHERE clause, which is not present in the joined tables (co_ownership and properties). The Generated SQL incorrectly references 'neighborhood_id' in the WHERE clause, which does not exist in the co_ownership or properties tables. Both queries contain invalid column references, but they differ in their structure and errors.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query incorrectly references 'name' from sf_neighborhoods without joining that table, causing a syntax error. The generated query uses a subquery to get neighborhood_id but incorrectly filters on neighborhood_id (which doesn't exist in the properties table). Both queries fail to properly link properties to neighborhoods due to schema limitations, but the generated query better addresses the business intent by explicitly targeting the neighborhood_id via a subquery. However, neither query is fully correct due to the missing property-neighborhood relationship in the schema.", "overall_assessment": "differently_correct"}}
{"example_id": 5248, "sql_complexity": "window functions", "prompt": "Find the top 5 games by rating", "context": "CREATE TABLE games (game_id INT PRIMARY KEY, name VARCHAR(50), genre VARCHAR(50), rating DECIMAL(3,2));", "reference_sql": "SELECT * FROM (SELECT name, rating, ROW_NUMBER() OVER (ORDER BY rating DESC) as rn FROM games) t WHERE rn <= 5;", "generated_sql": "SELECT name, genre, rating FROM games ORDER BY rating DESC NULLS LAST LIMIT 5;", "raw_model_output": " Code\nSELECT name, genre, rating FROM games ORDER BY rating DESC NULLS LAST LIMIT 5;", "latency_sec": 1.0827240943908691, "total_duration_sec": 0.280860968, "load_duration_sec": 0.010640561, "tokens_prompt": 62, "prompt_eval_sec": 0.009816484, "tokens_completion": 25, "completion_eval_sec": 0.259724726, "tokens_total": 87, "tokens_per_sec": 80.35288071144794, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in selected columns (reference includes 'name, rating', generated includes 'name, genre, rating') and handling of NULLs in ordering (generated explicitly uses NULLS LAST). Additionally, the generated query omits the row numbering logic present in the reference query.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in column selection and implementation. The reference query returns name, rating, and row_number, while the generated query returns name, genre, and rating. Both correctly identify top 5 games by rating, but the generated query is more efficient (no subquery) and returns business-relevant columns (genre). The reference query's row_number is unnecessary for the original question. Both handle ordering correctly, but the generated query is simpler and directly addresses the business intent.", "overall_assessment": "differently_correct"}}
{"example_id": 778, "sql_complexity": "single join", "prompt": "What is the maximum property price in wheelchair-accessible neighborhoods in Singapore?", "context": "CREATE TABLE Singapore_Neighborhoods (Neighborhood_Name TEXT, Wheelchair_Accessibility BOOLEAN); INSERT INTO Singapore_Neighborhoods (Neighborhood_Name, Wheelchair_Accessibility) VALUES ('Orchard', true), ('Marina Bay', true), ('Chinatown', false), ('Little India', false), ('Bugis', true); CREATE TABLE Singapore_Properties (Neighborhood_Name TEXT, Property_Price INTEGER); INSERT INTO Singapore_Properties (Neighborhood_Name, Property_Price) VALUES ('Orchard', 2000000), ('Marina Bay', 3000000), ('Chinatown', 1500000), ('Little India', 1200000), ('Bugis', 1800000);", "reference_sql": "SELECT MAX(Singapore_Properties.Property_Price) FROM Singapore_Properties INNER JOIN Singapore_Neighborhoods ON Singapore_Properties.Neighborhood_Name = Singapore_Neighborhoods.Neighborhood_Name WHERE Singapore_Neighborhoods.Wheelchair_Accessibility = true;", "generated_sql": "SELECT MAX(Property_Price) FROM Singapore_Properties WHERE Wheelchair_Accessibility = TRUE;", "raw_model_output": " Code\nSELECT MAX(Property_Price) FROM Singapore_Properties WHERE Wheelchair_Accessibility = TRUE;", "latency_sec": 0.33597803115844727, "total_duration_sec": 0.309505156, "load_duration_sec": 0.008680369, "tokens_prompt": 237, "prompt_eval_sec": 0.01556888, "tokens_completion": 24, "completion_eval_sec": 0.284384276, "tokens_total": 261, "tokens_per_sec": 776.8365065420375, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Generated SQL references a column 'Wheelchair_Accessibility' in the 'Singapore_Properties' table, which does not exist. The correct column exists in 'Singapore_Neighborhoods'. The Reference SQL properly joins the two tables to filter by accessibility, while the Generated SQL would throw an error due to invalid column reference.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL is technically correct and fulfills the business intent. It properly joins the Singapore_Properties and Singapore_Neighborhoods tables on Neighborhood_Name, then filters for wheelchair-accessible neighborhoods (Wheelchair_Accessibility = true) before calculating the maximum property price. The Generated SQL is technically incorrect because it references a column (Wheelchair_Accessibility) that does not exist in the Singapore_Properties table. This would result in a syntax error. While both queries aim to find the maximum property price, only the Reference SQL correctly addresses the data schema and business requirements.", "overall_assessment": "incorrect"}}
{"example_id": 3859, "sql_complexity": "aggregation", "prompt": "What is the total number of mental health parity violations by month and year?", "context": "CREATE TABLE mental_health_parity_reports (report_id INT, violation_date DATE); INSERT INTO mental_health_parity_reports (report_id, violation_date) VALUES (1, '2022-01-01'), (2, '2022-02-15'), (3, '2022-03-05'), (4, '2022-04-20'), (5, '2021-06-12'), (6, '2021-07-28');", "reference_sql": "SELECT EXTRACT(MONTH FROM violation_date) AS month, EXTRACT(YEAR FROM violation_date) AS year, COUNT(*) FROM mental_health_parity_reports GROUP BY month, year;", "generated_sql": "SELECT date_trunc('month', violation_date) AS MONTH, date_part('year', violation_date) AS YEAR, COUNT(*) AS total_violations FROM mental_health_parity_reports GROUP BY MONTH, YEAR ORDER BY YEAR NULLS LAST, MONTH NULLS LAST;", "raw_model_output": " Code\n<s> SELECT date_trunc('month', violation_date) AS MONTH, date_part('year', violation_date) AS YEAR, COUNT(*) AS total_violations FROM mental_health_parity_reports GROUP BY MONTH, YEAR ORDER BY YEAR NULLS LAST, MONTH NULLS LAST;", "latency_sec": 1.0199530124664307, "total_duration_sec": 0.896573768, "load_duration_sec": 0.008633512, "tokens_prompt": 172, "prompt_eval_sec": 0.01110126, "tokens_completion": 81, "completion_eval_sec": 0.876125562, "tokens_total": 253, "tokens_per_sec": 248.05064243910638, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL extracts month and year as integers, while the Generated SQL uses date_trunc('month', ...) (a date type) and date_part('year', ...) (an integer). The grouping logic is functionally similar but the output column types differ (date vs. integer), leading to different result structures. Additionally, the Generated SQL includes an ORDER BY clause not present in the Reference SQL.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent because they produce different output structures. The reference query returns month as an integer (1-12) and year as an integer, while the generated query returns a date-truncated month (e.g., '2022-01-01') and year as an integer. Both correctly group by month/year and count violations, so they fulfill the business intent. The reference query is more standard and portable (uses basic EXTRACT function), while the generated query relies on PostgreSQL-specific functions (date_trunc, date_part) and adds an unnecessary ORDER BY clause. The reference's simpler structure better matches the question's requirement for 'month and year' without date formatting.", "overall_assessment": "differently_correct"}}
{"example_id": 3551, "sql_complexity": "multiple_joins", "prompt": "List all artists who have performed in New York and Chicago, along with their highest-earning performance.", "context": "CREATE TABLE artist_events (artist_id INT, event_id INT, earnings DECIMAL(5,2)); CREATE TABLE artists (id INT, name VARCHAR(50)); CREATE TABLE events (id INT, city VARCHAR(20));", "reference_sql": "SELECT artists.name, MAX(artist_events.earnings) FROM artists INNER JOIN artist_events ON artists.id = artist_events.artist_id INNER JOIN events ON artist_events.event_id = events.id WHERE city IN ('New York', 'Chicago') GROUP BY artists.name;", "generated_sql": "SELECT COUNT(event_id) FROM artist_events WHERE city ILIKE '%New%York%' AND artist_id = 757071);", "raw_model_output": " Code\n<s> #_of_events = (SELECT COUNT(event_id) FROM artist_events WHERE city ILIKE '%New%York%' AND artist_id = 757071); SELECT a.name, c.city, b.event_id, MAX(b.earnings) AS max_earnings FROM artists AS a JOIN artist_events AS b ON a.id = b.artist_id JOIN events AS c ON b.event_id = c.id WHERE c.city ILIKE '%Chicago%' GROUP BY a.name, c.city HAVING COUNT(b.event_id) >= 2;", "latency_sec": 1.7889289855957031, "total_duration_sec": 1.604928974, "load_duration_sec": 0.008791079, "tokens_prompt": 97, "prompt_eval_sec": 0.00718435, "tokens_completion": 152, "completion_eval_sec": 1.588289771, "tokens_total": 249, "tokens_per_sec": 139.18942674914757, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL retrieves artist names and their maximum earnings from events in 'New York' or 'Chicago', while the Generated SQL counts event_ids for a specific artist (id=757071) in cities matching '%New%York%' (case-insensitive). They differ in: 1) Aggregation type (MAX vs COUNT), 2) Grouping (by name vs specific artist_id), 3) City filtering logic (exact match vs pattern match), and 4) Selected columns (name/earnings vs event_id count).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly joins artists, artist_events, and events tables to identify artists performing in New York/Chicago and their maximum earnings. It uses proper aggregation (MAX) and grouping. The generated query is fundamentally different: it counts events for a specific artist (id 757071) in a city match, lacks joins, and focuses on counting rather than retrieving earnings or artist names. The generated query does not address the original question's requirements of listing all qualifying artists and their highest earnings.", "overall_assessment": "incorrect"}}
{"example_id": 5168, "sql_complexity": "aggregation", "prompt": "Get the number of renewable energy projects in Australia for each project type.", "context": "CREATE TABLE renewable_projects (id INT PRIMARY KEY, project_name VARCHAR(255), project_location VARCHAR(255), project_type VARCHAR(255), capacity_mw FLOAT);", "reference_sql": "SELECT project_type, COUNT(*) FROM renewable_projects WHERE project_location = 'Australia' GROUP BY project_type;", "generated_sql": "SELECT p.project_type, COUNT(*) AS num_projects FROM renewable_projects r JOIN projects p ON r.id = p.id WHERE p.project_location ILIKE '%Australia%' GROUP BY p.project_type;", "raw_model_output": " Code\n<s> #_of_projects = '''SELECT p.project_type, COUNT(*) AS num_projects FROM renewable_projects r JOIN projects p ON r.id = p.id WHERE p.project_location ILIKE '%Australia%' GROUP BY p.project_type;'''", "latency_sec": 0.7900240421295166, "total_duration_sec": 0.741756285, "load_duration_sec": 0.008536793, "tokens_prompt": 84, "prompt_eval_sec": 0.006203568, "tokens_completion": 69, "completion_eval_sec": 0.726506676, "tokens_total": 153, "tokens_per_sec": 193.66499225464986, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in several key aspects.  The generated query incorrectly references a 'projects' table (not present in the schema) and performs a JOIN with 'renewable_projects' that is unnecessary and potentially erroneous.  Additionally, the WHERE clause uses a case-insensitive partial match ('ILIKE '%Australia%'') instead of an exact match ('= 'Australia'').  These differences would result in different query results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query is technically correct and directly addresses the business intent. It correctly counts projects in Australia using exact matching on project_location. The generated query has multiple issues: 1) It references a non-existent 'projects' table (schema only includes 'renewable_projects') 2) Uses ILIKE with partial matching (%Australia%) which would include locations with 'Australia' in any position 3) Adds an unnecessary JOIN that corrupts the data model. While both aim to count project types, the generated query would produce incorrect results due to schema violations and flawed filtering logic.", "overall_assessment": "incorrect"}}
{"example_id": 4916, "sql_complexity": "aggregation", "prompt": "What is the maximum revenue generated from selling Yttrium in India in the past 3 years?", "context": "CREATE TABLE Yttrium_Sales (id INT PRIMARY KEY, year INT, country VARCHAR(20), quantity INT, price PER_KG); INSERT INTO Yttrium_Sales (id, year, country, quantity, price) VALUES (1, 2019, 'India', 120, 40), (2, 2020, 'India', 130, 45), (3, 2021, 'India', 140, 50), (4, 2019, 'China', 150, 35), (5, 2020, 'China', 160, 40), (6, 2021, 'China', 170, 45);", "reference_sql": "SELECT MAX(quantity * price) FROM Yttrium_Sales WHERE country = 'India' GROUP BY year ORDER BY year DESC LIMIT 3;", "generated_sql": "SELECT SUM(price * quantity) AS total_revenue FROM Yttrium_Sales WHERE country = 'India' AND year IN (EXTRACT(YEAR FROM CURRENT_DATE) - 1, EXTRACT(YEAR FROM CURRENT_DATE), EXTRACT(YEAR FROM CURRENT_DATE) - 2);", "raw_model_output": " Code\n<s> SELECT SUM(price * quantity) AS total_revenue FROM Yttrium_Sales WHERE country = 'India' AND year IN (EXTRACT(YEAR FROM CURRENT_DATE) - 1, EXTRACT(YEAR FROM CURRENT_DATE), EXTRACT(YEAR FROM CURRENT_DATE) - 2);", "latency_sec": 1.0497429370880127, "total_duration_sec": 0.952699584, "load_duration_sec": 0.016474351, "tokens_prompt": 228, "prompt_eval_sec": 0.017015855, "tokens_completion": 83, "completion_eval_sec": 0.917217915, "tokens_total": 311, "tokens_per_sec": 296.2630078395327, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates the maximum (quantity * price) per year for India, returns up to 3 years ordered descending, and groups by year. The Generated SQL sums (price * quantity) for India across the last three calendar years (based on current date) and returns a single total. The Reference SQL returns multiple rows (one per year) with individual values, while the Generated SQL returns a single aggregated total. Additionally, the Generated SQL's year filtering depends on the current date, which may not align with the fixed data in the table.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is incorrect because it uses MAX(quantity * price) instead of SUM(quantity * price) to calculate revenue, and it groups by year to return multiple rows rather than a single maximum value. The Generated SQL correctly sums revenue for the last three years but fails to identify the maximum revenue across those years. Neither query fully addresses the question, but the Generated SQL better aligns with the intent of calculating total revenue over a period, while the Reference SQL's logic is fundamentally flawed for the task.", "overall_assessment": "differently_correct"}}
{"example_id": 812, "sql_complexity": "multiple_joins", "prompt": "What is the average salary of 'engineer' workers in each factory?", "context": "CREATE TABLE factories (factory_id INT, factory_name VARCHAR(20)); INSERT INTO factories VALUES (1, 'Factory X'), (2, 'Factory Y'), (3, 'Factory Z'); CREATE TABLE roles (role_id INT, role_name VARCHAR(20)); INSERT INTO roles VALUES (1, 'engineer'), (2, 'manager'), (3, 'assistant'); CREATE TABLE workers (worker_id INT, factory_id INT, role_id INT, salary DECIMAL(5,2)); INSERT INTO workers VALUES (1, 1, 1, 50000.00), (2, 1, 2, 70000.00), (3, 2, 1, 55000.00), (4, 2, 3, 40000.00), (5, 3, 1, 60000.00);", "reference_sql": "SELECT f.factory_name, AVG(salary) FROM workers w INNER JOIN factories f ON w.factory_id = f.factory_id INNER JOIN roles r ON w.role_id = r.role_id WHERE r.role_name = 'engineer' GROUP BY f.factory_name;", "generated_sql": "SELECT f.factory_name, r.role_name, AVG(w.salary) AS average_salary FROM workers w JOIN factories f ON w.factory_id = f.factory_id JOIN roles r ON w.role_id = r.role_id WHERE r.role_name = 'engineer' GROUP BY f.factory_name, r.role_name;", "raw_model_output": " Code\n<s> SELECT f.factory_name, r.role_name, AVG(w.salary) AS average_salary FROM workers w JOIN factories f ON w.factory_id = f.factory_id JOIN roles r ON w.role_id = r.role_id WHERE r.role_name = 'engineer' GROUP BY f.factory_name, r.role_name;", "latency_sec": 1.382171869277954, "total_duration_sec": 1.076041756, "load_duration_sec": 0.01418705, "tokens_prompt": 263, "prompt_eval_sec": 0.014570247, "tokens_completion": 94, "completion_eval_sec": 1.046529833, "tokens_total": 357, "tokens_per_sec": 258.28915197535935, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL returns only 'factory_name' and 'AVG(salary)', while the Generated SQL includes an additional 'role_name' column. Although the WHERE clause restricts role_name to 'engineer', the presence of this extra column in the SELECT and GROUP BY clauses changes the result set structure, making them semantically different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The Reference SQL correctly answers the question by returning only the factory name and average salary for engineers, while the Generated SQL includes an unnecessary 'role_name' column in both SELECT and GROUP BY clauses. Although both queries filter for 'engineer' roles, the Reference SQL is more precise and aligns directly with the business requirement. The Generated SQL is technically correct but less efficient due to redundant grouping and output. The original question didn't request role information, making the Reference SQL more appropriate.", "overall_assessment": "correct"}}
{"example_id": 5784, "sql_complexity": "set operations", "prompt": "List the number of users who have completed a workout of a specific type (e.g. Running) and have a membership status of 'Active'.", "context": "CREATE TABLE workouts (id INT, user_id INT, workout_type VARCHAR(20)); CREATE TABLE members (id INT, name VARCHAR(50), membership_status VARCHAR(20), state VARCHAR(20)); INSERT INTO workouts (id, user_id, workout_type) VALUES (1, 1, 'Running'), (2, 1, 'Cycling'), (3, 2, 'Running'), (4, 3, 'Cycling'), (5, 3, 'Swimming'), (6, 4, 'Running'), (7, 4, 'Swimming'); INSERT INTO members (id, name, membership_status, state) VALUES (1, 'John Doe', 'Active', 'Texas'), (2, 'Jane Doe', 'Inactive', 'California'), (3, 'Bob Smith', 'Active', 'Texas'), (4, 'Alice Johnson', 'Active', 'California');", "reference_sql": "SELECT COUNT(*) FROM (SELECT user_id FROM workouts WHERE workout_type = 'Running' INTERSECT SELECT id FROM members WHERE membership_status = 'Active') AS user_set;", "generated_sql": "SELECT COUNT(DISTINCT workouts.user_id) AS total_users FROM workouts JOIN members ON workouts.user_id = members.id WHERE workout_type ilike '%Running%' AND membership_status ilike '%Active%';", "raw_model_output": " Code\n<s> SELECT COUNT(DISTINCT workouts.user_id) AS total_users FROM workouts JOIN members ON workouts.user_id = members.id WHERE workout_type ilike '%Running%' AND membership_status ilike '%Active%';", "latency_sec": 0.8286490440368652, "total_duration_sec": 0.724976733, "load_duration_sec": 0.008872694, "tokens_prompt": 273, "prompt_eval_sec": 0.017414054, "tokens_completion": 61, "completion_eval_sec": 0.697935466, "tokens_total": 334, "tokens_per_sec": 403.0656915657298, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their filtering logic. The Reference SQL uses exact matches ('Running' and 'Active') with INTERSECT, while the Generated SQL uses case-insensitive wildcards ('%Running%' and '%Active%') with a JOIN. This makes the Generated SQL more permissive, potentially including additional rows with case variations or partial matches. Additionally, INTERSECT ensures unique user_ids from both sets, but the Generated SQL's COUNT(DISTINCT) achieves a similar result. However, the differing conditions make them non-equivalent in general cases.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query correctly uses INTERSECT to find users who both (1) have a 'Running' workout and (2) are Active members, ensuring exact matches. The generated query uses ILIKE with wildcards, which would match any case variation of 'Running' (e.g., 'running', 'RUNNING') and 'Active' (e.g., 'active', 'ACTIVE'), potentially including unintended records. While both count distinct users, the generated query's pattern matching deviates from the explicit 'specific type' requirement in the original question. The reference query better preserves the exact business criteria.", "overall_assessment": "differently_correct"}}
{"example_id": 3038, "sql_complexity": "subqueries", "prompt": "What is the total assets of clients who have invested in mutual funds but not in stocks?", "context": "CREATE TABLE clients (client_id INT, name TEXT, age INT, gender TEXT, total_assets DECIMAL(10,2)); INSERT INTO clients VALUES (1, 'John Doe', 35, 'Male', 250000.00), (2, 'Jane Smith', 45, 'Female', 500000.00); CREATE TABLE investments (client_id INT, investment_type TEXT); INSERT INTO investments VALUES (1, 'Stocks'), (1, 'Bonds'), (2, 'Stocks'), (3, 'Mutual Funds');", "reference_sql": "SELECT c.total_assets FROM clients c INNER JOIN investments i ON c.client_id = i.client_id WHERE i.investment_type = 'Mutual Funds' AND c.client_id NOT IN (SELECT client_id FROM investments WHERE investment_type = 'Stocks');", "generated_sql": "SELECT SUM(clients.total_assets) AS total_assets FROM clients JOIN investments ON clients.client_id = investments.client_id WHERE investments.investment_type ilike '%Mutual%Funds%' AND investments.investment_type not ilike '%Stocks%';", "raw_model_output": " Code\n<s> SELECT SUM(clients.total_assets) AS total_assets FROM clients JOIN investments ON clients.client_id = investments.client_id WHERE investments.investment_type ilike '%Mutual%Funds%' AND investments.investment_type not ilike '%Stocks%';", "latency_sec": 0.940087080001831, "total_duration_sec": 0.807801752, "load_duration_sec": 0.009853403, "tokens_prompt": 183, "prompt_eval_sec": 0.01143222, "tokens_completion": 72, "completion_eval_sec": 0.785720847, "tokens_total": 255, "tokens_per_sec": 271.25146746991066, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their logic and conditions. The Reference SQL selects clients with 'Mutual Funds' investments and explicitly excludes clients with any 'Stocks' investments using a NOT IN subquery. The Generated SQL uses case-insensitive LIKE patterns to filter investment types, which may match partial or differently cased values (e.g., 'mutual funds' or 'Mutual Funds'). Additionally, the Generated SQL sums total_assets, while the Reference SQL returns individual client assets. The Generated SQL could include clients with mixed investments (e.g., 'Mutual Funds' and 'Stocks') if the specific investment row meets the LIKE conditions, whereas the Reference SQL strictly excludes such clients.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference SQL correctly identifies clients with mutual fund investments and excludes those with stock investments using a NOT IN subquery. However, it returns individual client assets without aggregation, which may not align with the 'total assets' requirement. The generated SQL incorrectly checks investment_type at the row level rather than client level, allowing clients with both mutual funds and stocks. While it uses SUM, its logic is flawed. The reference SQL better fulfills the business intent despite missing aggregation, as its logic is fundamentally correct.", "overall_assessment": "differently_correct"}}
{"example_id": 1078, "sql_complexity": "basic SQL", "prompt": "What is the maximum and minimum temperature difference between any two Arctic research stations?", "context": "CREATE TABLE arctic_stations (id INT, name TEXT, location TEXT, temperature DECIMAL(5,2)); INSERT INTO arctic_stations (id, name, location, temperature) VALUES (1, 'Station A', 'Greenland', 2.3), (2, 'Station B', 'Canada', -5.2);", "reference_sql": "SELECT a.name as station1, b.name as station2, MAX(ABS(a.temperature - b.temperature)) as temp_diff FROM arctic_stations a, arctic_stations b ORDER BY temp_diff DESC LIMIT 1", "generated_sql": "SELECT COUNT(id) FROM arctic_stations);", "raw_model_output": " Code\n<s> #_of_stations = (SELECT COUNT(id) FROM arctic_stations); SELECT MAX(temperature)-MIN(temperature) AS temperature_difference FROM arctic_stations;", "latency_sec": 0.622650146484375, "total_duration_sec": 0.544513645, "load_duration_sec": 0.008668327, "tokens_prompt": 113, "prompt_eval_sec": 0.010916247, "tokens_completion": 49, "completion_eval_sec": 0.524121297, "tokens_total": 162, "tokens_per_sec": 260.17820908689896, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the maximum temperature difference between pairs of stations, while the Generated SQL counts the number of stations. They return entirely different results (a temperature difference value vs. a count) and have different query structures.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query attempts to calculate temperature differences between all station pairs using a self-join, but has three critical issues: 1) It only returns the maximum difference (not both max and min as requested) 2) It lacks a WHERE clause to exclude same-station comparisons (a.temperature = b.temperature) 3) The ORDER BY and LIMIT 1 would only return the single largest difference. The generated query is completely unrelated, counting stations instead of analyzing temperature differences. Neither query fully fulfills the business intent, but the reference query at least addresses the temperature analysis aspect.", "overall_assessment": "differently_correct"}}
{"example_id": 5015, "sql_complexity": "basic SQL", "prompt": "Calculate the average recycling rate", "context": "CREATE TABLE recycling_rates (id INT PRIMARY KEY, location VARCHAR(50), rate FLOAT);", "reference_sql": "SELECT AVG(rate) FROM recycling_rates;", "generated_sql": "SELECT AVG(rate) FROM recycling_rates;", "raw_model_output": " Code\nSELECT AVG(rate) FROM recycling_rates;", "latency_sec": 0.2832319736480713, "total_duration_sec": 0.189490523, "load_duration_sec": 0.009282345, "tokens_prompt": 51, "prompt_eval_sec": 0.009059295, "tokens_completion": 16, "completion_eval_sec": 0.170557027, "tokens_total": 67, "tokens_per_sec": 236.55521351290153, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and syntax, both calculating the average of the 'rate' column from the 'recycling_rates' table. They will produce the same result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic, using the AVG() function on the 'rate' column from the 'recycling_rates' table. They would produce the same numerical result. The query correctly addresses the business intent of calculating the average recycling rate. Since the reference and generated queries are exactly the same, neither is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 1533, "sql_complexity": "subqueries", "prompt": "Which programs had the highest volunteer participation rate in the last quarter?", "context": "CREATE TABLE Programs (ProgramID INT, ProgramName TEXT, Budget DECIMAL(10,2), NumVolunteers INT); CREATE TABLE VolunteerEvents (EventID INT, ProgramID INT, EventDate DATE, NumVolunteers INT);", "reference_sql": "SELECT p.ProgramName, COUNT(v.EventID) / (SELECT COUNT(*) FROM VolunteerEvents WHERE EventDate >= DATEADD(quarter, -1, GETDATE())) * 100.0 AS VolunteerParticipationRate FROM Programs p INNER JOIN VolunteerEvents v ON p.ProgramID = v.ProgramID WHERE v.EventDate >= DATEADD(quarter, -1, GETDATE()) GROUP BY p.ProgramName ORDER BY VolunteerParticipationRate DESC;", "generated_sql": "SELECT ProgramID FROM VolunteerEvents WHERE EventDate BETWEEN (CURRENT_DATE - interval '3 months') AND CURRENT_DATE GROUP BY ProgramID ORDER BY percentage_of_volunteers DESC NULLS LAST LIMIT 1);", "raw_model_output": " Code\n<s> #_of_volunteers / total_programs * 100 AS percentage_of_volunteers FROM Programs WHERE ProgramID IN (SELECT ProgramID FROM VolunteerEvents WHERE EventDate BETWEEN (CURRENT_DATE - interval '3 months') AND CURRENT_DATE GROUP BY ProgramID ORDER BY percentage_of_volunteers DESC NULLS LAST LIMIT 1);", "latency_sec": 1.203402042388916, "total_duration_sec": 1.005063727, "load_duration_sec": 0.008221139, "tokens_prompt": 89, "prompt_eval_sec": 0.006816778, "tokens_completion": 94, "completion_eval_sec": 0.989389158, "tokens_total": 183, "tokens_per_sec": 152.06887935533183, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates a participation rate (count of events in last quarter / total events in same period) per program, while the generated query focuses on counting events in the last 3 months without calculating a rate. The generated query also lacks the JOIN with Programs, groups by ProgramID instead of ProgramName, and includes a LIMIT 1 clause not present in the reference. Additionally, the generated query references an undefined 'percentage_of_volunteers' column.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly calculates volunteer participation rate as (program-specific events / total quarter events) * 100, while the Generated SQL contains multiple critical issues: 1) References undefined column 'percentage_of_volunteers', 2) Uses incorrect date range (BETWEEN with CURRENT_DATE - 3 months may exclude events on the exact start date), 3) Returns only one ProgramID instead of all top programs, 4) Doesn't calculate actual participation rate. The Reference properly joins programs with events, filters by quarter, and ranks by participation rate, directly addressing the business intent of identifying programs with the highest rate.", "overall_assessment": "incorrect"}}
{"example_id": 4021, "sql_complexity": "subqueries", "prompt": "What is the percentage of energy efficiency improvement, per sector, compared to 2015 levels?", "context": "CREATE TABLE energy_efficiency (id INT, sector VARCHAR(50), year INT, efficiency FLOAT); INSERT INTO energy_efficiency (id, sector, year, efficiency) VALUES (1, 'Industry', 2015, 100.0), (2, 'Industry', 2020, 105.0), (3, 'Residential', 2015, 100.0), (4, 'Residential', 2020, 103.0);", "reference_sql": "SELECT sector, (SUM(efficiency) / (SELECT SUM(efficiency) FROM energy_efficiency WHERE year = 2015 AND sector = e.sector) * 100.0) - 100.0 AS improvement FROM energy_efficiency e WHERE year = 2020 GROUP BY sector;", "generated_sql": "SELECT sector, year, efficiency - lag(efficiency) OVER (PARTITION BY sector ORDER BY year) AS change_in_efficiency FROM energy_efficiency;", "raw_model_output": " Code\n<s> SELECT sector, year, efficiency - lag(efficiency) OVER (PARTITION BY sector ORDER BY year) AS change_in_efficiency FROM energy_efficiency;", "latency_sec": 0.7865610122680664, "total_duration_sec": 0.488790975, "load_duration_sec": 0.008920753, "tokens_prompt": 165, "prompt_eval_sec": 0.011151699, "tokens_completion": 42, "completion_eval_sec": 0.467953227, "tokens_total": 207, "tokens_per_sec": 263.1709387719471, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates percentage improvement from 2015 to 2020 for each sector, while the Generated SQL shows absolute efficiency changes between consecutive years. The Reference SQL returns percentage values (e.g., 5% for Industry) whereas the Generated SQL returns absolute differences (e.g., 5 for Industry). Additionally, the Generated SQL includes the 'year' column which the Reference SQL excludes.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query correctly calculates percentage improvement by comparing 2020 efficiency to 2015 levels for each sector using a subquery. It handles the percentage calculation explicitly. The generated query uses LAG to compare to the previous year (not 2015 specifically) and only returns absolute efficiency changes, not percentages. The reference query is technically correct, while the generated query fails to meet the business requirement of comparing to 2015 and calculating percentages.", "overall_assessment": "correct"}}
{"example_id": 1551, "sql_complexity": "single join", "prompt": "How many unique donors made donations in the healthcare industry in Q3 2022?", "context": "CREATE TABLE donations (id INT, donor_id INT, amount FLOAT, donation_date DATE); INSERT INTO donations (id, donor_id, amount, donation_date) VALUES (1, 7, 100, '2022-07-01'); INSERT INTO donations (id, donor_id, amount, donation_date) VALUES (2, 8, 200, '2022-09-15'); INSERT INTO donors (id, name, industry, first_donation_date DATE) VALUES (7, 'Charlie Davis', 'Healthcare', '2022-07-01'); INSERT INTO donors (id, name, industry, first_donation_date DATE) VALUES (8, 'Dana Wilson', 'Healthcare', '2022-09-15');", "reference_sql": "SELECT COUNT(DISTINCT donor_id) FROM donations d JOIN donors don ON d.donor_id = don.id WHERE industry = 'Healthcare' AND donation_date BETWEEN '2022-07-01' AND '2022-09-30';", "generated_sql": "SELECT COUNT(DISTINCT d.donor_id) AS number_of_donors FROM donations d JOIN donors o ON d.donor_id = o.id WHERE d.amount IS NOT NULL AND o.industry = 'Healthcare' AND EXTRACT(QUARTER FROM d.donation_date) = 3 AND EXTRACT(YEAR FROM d.donation_date) = 2022;", "raw_model_output": " Code\n<s> SELECT COUNT(DISTINCT d.donor_id) AS number_of_donors FROM donations d JOIN donors o ON d.donor_id = o.id WHERE d.amount IS NOT NULL AND o.industry = 'Healthcare' AND EXTRACT(QUARTER FROM d.donation_date) = 3 AND EXTRACT(YEAR FROM d.donation_date) = 2022;", "latency_sec": 1.2978489398956299, "total_duration_sec": 1.199075287, "load_duration_sec": 0.008493666, "tokens_prompt": 257, "prompt_eval_sec": 0.015418997, "tokens_completion": 105, "completion_eval_sec": 1.174439786, "tokens_total": 362, "tokens_per_sec": 278.9230617463934, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the generated query includes an explicit 'd.amount IS NOT NULL' condition not present in the reference query. Second, the date filter uses EXTRACT(QUARTER) and EXTRACT(YEAR) instead of BETWEEN. While the date logic might appear equivalent (Q3 2022 = July-September), the 'amount IS NOT NULL' condition could exclude rows present in the reference query's result set, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent. The reference query uses a simple date range filter (BETWEEN '2022-07-01' AND '2022-09-30') which accurately captures Q3 2022 donations. The generated query uses EXTRACT(QUARTER) = 3 and EXTRACT(YEAR) = 2022, which is logically equivalent but less efficient. However, the generated query adds an unnecessary condition WHERE d.amount IS NOT NULL, which could exclude valid donations with NULL amounts (though the sample data doesn't include such cases). Both queries count distinct donor_ids correctly, but the reference is more direct and avoids potential over-filtering. Both fulfill the business intent of counting unique healthcare donors in Q3 2022, but the reference is technically superior due to its simplicity and precision.", "overall_assessment": "differently_correct"}}
{"example_id": 2592, "sql_complexity": "window functions", "prompt": "What is the third highest account balance for Shariah-compliant finance customers?", "context": "CREATE TABLE shariah_compliant_finance(customer_id INT, account_balance DECIMAL(10, 2)); INSERT INTO shariah_compliant_finance VALUES (1, 5000), (2, 7000), (3, 6000), (4, 8000), (5, 9000);", "reference_sql": "SELECT account_balance FROM (SELECT account_balance, RANK() OVER (ORDER BY account_balance DESC) as rn FROM shariah_compliant_finance) t WHERE rn = 3;", "generated_sql": "SELECT account_balance FROM shariah_compliant_finance ORDER BY account_balance DESC LIMIT 1, 3);", "raw_model_output": " Code\n<s> #_three_highest_account_balance = (SELECT account_balance FROM shariah_compliant_finance ORDER BY account_balance DESC LIMIT 1, 3);", "latency_sec": 0.8236849308013916, "total_duration_sec": 0.523091671, "load_duration_sec": 0.008548352, "tokens_prompt": 129, "prompt_eval_sec": 0.007955407, "tokens_completion": 47, "completion_eval_sec": 0.506075103, "tokens_total": 176, "tokens_per_sec": 213.67393455743266, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query retrieves the account_balance with rank 3 (third highest value) using RANK(), while the generated query returns a range of values (rows 2-4 in descending order) via LIMIT 1,3. The reference query returns a single value (7000), whereas the generated query returns three values (8000, 7000, 6000).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly identifies the third highest account balance using RANK() to handle potential ties and explicitly filters for rank=3. The generated query uses LIMIT 1,3 which returns three rows starting from the second highest balance (8000, 7000, 6000) rather than selecting the third highest specifically. This makes the generated query technically incorrect for the business question. While both queries order by descending balance, the generated query's LIMIT clause misaligns with the requirement to find the 'third highest' value. The reference query better fulfills the business intent by precisely targeting the third rank.", "overall_assessment": "incorrect"}}
{"example_id": 3795, "sql_complexity": "single join", "prompt": "What is the total quantity of unsold garments for each manufacturer based in 'Italy' or 'Spain'?", "context": "CREATE TABLE manufacturers (id INT PRIMARY KEY, name VARCHAR(255), country VARCHAR(255)); CREATE TABLE garments (id INT PRIMARY KEY, manufacturer_id INT, quantity_manufactured INT, quantity_sold INT);", "reference_sql": "SELECT m.name, SUM(g.quantity_manufactured - g.quantity_sold) as total_unsold_quantity FROM manufacturers m JOIN garments g ON m.id = g.manufacturer_id WHERE m.country IN ('Italy', 'Spain') GROUP BY m.name;", "generated_sql": "SELECT m.name, SUM(g.quantity_sold) AS total_unsold FROM manufacturers m JOIN garments g ON m.id = g.manufacturer_id WHERE m.country IN ('Italy', 'Spain') GROUP BY m.name;", "raw_model_output": " Code\n<s> # SELECT m.name, SUM(g.quantity_sold) AS total_unsold FROM manufacturers m JOIN garments g ON m.id = g.manufacturer_id WHERE m.country IN ('Italy', 'Spain') GROUP BY m.name;", "latency_sec": 1.0276799201965332, "total_duration_sec": 0.736743353, "load_duration_sec": 0.008578579, "tokens_prompt": 101, "prompt_eval_sec": 0.007935124, "tokens_completion": 68, "completion_eval_sec": 0.719628666, "tokens_total": 169, "tokens_per_sec": 164.44808999253434, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates the total unsold quantity as (quantity_manufactured - quantity_sold) per garment, while the generated query only sums quantity_sold. This results in different calculations: the first represents net unsold stock, while the second represents total sales. The aggregation logic differs fundamentally.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly calculates unsold quantity as (quantity_manufactured - quantity_sold) per garment, then sums it. The generated query incorrectly sums quantity_sold instead of calculating the difference. While both queries join manufacturers with garments and filter by country, their core calculations are opposite in meaning. The reference accurately addresses the business intent of measuring unsold inventory, whereas the generated query measures total sales, which directly contradicts the question.", "overall_assessment": "incorrect"}}
{"example_id": 4138, "sql_complexity": "window functions", "prompt": "How many lifelong learning courses has a student with ID '2' completed, in chronological order?", "context": "CREATE TABLE lifelong_learning (student_id INT, course_id INT, completion_date DATE); INSERT INTO lifelong_learning VALUES (2, 1001, '2015-01-01'), (2, 1002, '2016-01-01');", "reference_sql": "SELECT student_id, course_id, COUNT(course_id) OVER (PARTITION BY student_id ORDER BY completion_date) as completed_courses FROM lifelong_learning WHERE student_id = 2;", "generated_sql": "Code\n<s> QUERY", "raw_model_output": " Code\n<s> QUERY", "latency_sec": 0.29826807975769043, "total_duration_sec": 0.102010291, "load_duration_sec": 0.008604166, "tokens_prompt": 117, "prompt_eval_sec": 0.009819942, "tokens_completion": 7, "completion_eval_sec": 0.082968229, "tokens_total": 124, "tokens_per_sec": 415.73339024657344, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The generated SQL query is missing from the input, making it impossible to compare with the reference query. Without the actual generated SQL, semantic equivalence cannot be determined.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference SQL uses a window function to create a running total of courses per completion date, returning two rows with counts 1 and 2. However, the original question asks for the total number of completed courses (a single value), not a chronological breakdown. While the query is technically correct in syntax, it fails to fulfill the business intent by returning multiple rows instead of a single count. The generated SQL (missing in input) would need to use COUNT(*) with appropriate filtering to correctly answer the question.", "overall_assessment": "differently_correct"}}
{"example_id": 312, "sql_complexity": "aggregation", "prompt": "List the top 3 most represented ethnicities in movies produced in the USA.", "context": "CREATE TABLE movies (title VARCHAR(255), production_country VARCHAR(64), lead_actor_ethnicity VARCHAR(64));", "reference_sql": "SELECT lead_actor_ethnicity, COUNT(*) AS count FROM movies WHERE production_country = 'USA' GROUP BY lead_actor_ethnicity ORDER BY count DESC LIMIT 3;", "generated_sql": "SELECT lead_actor_ethnicity, COUNT(*) AS frequency FROM movies WHERE production_country = 'USA' GROUP BY lead_actor_ethnicity ORDER BY frequency DESC NULLS LAST LIMIT 3;", "raw_model_output": " Code\nSELECT lead_actor_ethnicity, COUNT(*) AS frequency FROM movies WHERE production_country = 'USA' GROUP BY lead_actor_ethnicity ORDER BY frequency DESC NULLS LAST LIMIT 3;", "latency_sec": 0.7595438957214355, "total_duration_sec": 0.571129125, "load_duration_sec": 0.009241161, "tokens_prompt": 67, "prompt_eval_sec": 0.007636438, "tokens_completion": 53, "completion_eval_sec": 0.55363238, "tokens_total": 120, "tokens_per_sec": 157.98955225098706, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the ORDER BY clause: the Generated SQL includes 'NULLS LAST' which affects sorting behavior when there are NULL values in 'lead_actor_ethnicity'. The Reference SQL does not handle NULLs explicitly, potentially ordering them differently. Additionally, the column alias differs ('count' vs 'frequency'), but this does not affect semantic equivalence. The presence of 'NULLS LAST' makes them non-equivalent in cases where NULL values exist.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent due to the 'NULLS LAST' clause in the generated query, which affects sorting behavior when NULL values exist. The reference query uses standard SQL without this clause. Both fulfill the business intent of identifying top ethnicities in USA-produced movies, but the reference query is more straightforward. The generated query's 'NULLS LAST' could be problematic if lead_actor_ethnicity contains NULLs (which the original question doesn't address), but since the question focuses on 'most represented' ethnicities, NULLs would likely be excluded anyway. The reference query is simpler and more standard for this specific use case.", "overall_assessment": "differently_correct"}}
{"example_id": 4298, "sql_complexity": "single join", "prompt": "How many users joined the gym in Q1 2023?", "context": "CREATE TABLE memberships (id INT, user_id INT, join_date DATE); INSERT INTO memberships (id, user_id, join_date) VALUES (1, 5, '2023-01-15'), (2, 6, '2023-02-03'), (3, 7, '2023-03-20'), (4, 8, '2022-12-31');", "reference_sql": "SELECT COUNT(*) FROM memberships WHERE join_date BETWEEN '2023-01-01' AND '2023-03-31';", "generated_sql": "SELECT COUNT(*) FROM memberships WHERE date_part('year', join_date) = 2023 AND date_part('quarter', join_date) = 1;", "raw_model_output": " Code\n<s> SELECT COUNT(*) FROM memberships WHERE date_part('year', join_date) = 2023 AND date_part('quarter', join_date) = 1;", "latency_sec": 0.6503517627716064, "total_duration_sec": 0.52375121, "load_duration_sec": 0.00932142, "tokens_prompt": 143, "prompt_eval_sec": 0.011375517, "tokens_completion": 46, "completion_eval_sec": 0.502383662, "tokens_total": 189, "tokens_per_sec": 290.6119592796028, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count memberships with join dates in the first quarter of 2023. The reference query uses a date range (BETWEEN '2023-01-01' AND '2023-03-31'), while the generated query checks for year=2023 and quarter=1. Since Q1 spans Jan-Mar, both conditions capture the same date range.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries correctly count users who joined in Q1 2023. The reference query uses a date range (BETWEEN) which is semantically precise for calendar quarters. The generated query uses date_part() functions to extract year and quarter, which also correctly identifies Q1 2023. However, the reference query is more efficient as it allows for index utilization on join_date, while the generated query requires function-based evaluation. Both fulfill the business intent, but the reference is technically superior.", "overall_assessment": "correct"}}
{"example_id": 5211, "sql_complexity": "multiple_joins", "prompt": "What is the average transaction value in the last week, split by product category and customer demographics?", "context": "CREATE TABLE transactions (transaction_id INT, customer_id INT, product_id INT, category_id INT, transaction_date DATE, amount DECIMAL(10,2)); CREATE TABLE customers (customer_id INT, age INT, gender VARCHAR(10), location VARCHAR(255)); CREATE TABLE products (product_id INT, name VARCHAR(255), category_id INT);", "reference_sql": "SELECT c.age, c.gender, p.category_id, AVG(t.amount) as avg_transaction_value FROM transactions t INNER JOIN customers c ON t.customer_id = c.customer_id INNER JOIN products p ON t.product_id = p.product_id WHERE t.transaction_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 WEEK) GROUP BY c.age, c.gender, p.category_id;", "generated_sql": "SELECT c.gender, c.location, p.category_id, AVG(t.amount) AS avg_transaction_value FROM transactions t JOIN customers c ON t.customer_id = c.customer_id JOIN products p ON t.product_id = p.product_id WHERE transaction_date >= (CURRENT_DATE - interval '7 days') GROUP BY c.gender, c.location, p.category_id;", "raw_model_output": " Code\n<s> #_of_transactions = 0; SELECT c.gender, c.location, p.category_id, AVG(t.amount) AS avg_transaction_value FROM transactions t JOIN customers c ON t.customer_id = c.customer_id JOIN products p ON t.product_id = p.product_id WHERE transaction_date >= (CURRENT_DATE - interval '7 days') GROUP BY c.gender, c.location, p.category_id;", "latency_sec": 1.5285601615905762, "total_duration_sec": 1.22586677, "load_duration_sec": 0.009786901, "tokens_prompt": 132, "prompt_eval_sec": 0.010075415, "tokens_completion": 112, "completion_eval_sec": 1.205129974, "tokens_total": 244, "tokens_per_sec": 159.62734482501529, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in selected columns and grouping. Reference includes 'age' and 'gender', while generated includes 'gender' and 'location'. Grouping columns also differ (age vs location), leading to different aggregation results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent due to differences in grouping columns and date calculation syntax. The Reference SQL groups by age and gender (core demographics) with category_id, directly addressing the 'customer demographics' requirement. The Generated SQL replaces age with location, which is less central to traditional demographic analysis. While both calculate average transaction value for the last week (using slightly different date syntax), the Reference better aligns with standard demographic variables (age/gender) whereas the Generated query prioritizes location. The original question's emphasis on 'demographics' makes the Reference more appropriate despite both being technically valid.", "overall_assessment": "differently_correct"}}
{"example_id": 382, "sql_complexity": "window functions", "prompt": "What is the average annual precipitation in the past 10 years for each weather station?", "context": "CREATE TABLE WeatherStation (ID INT, Name VARCHAR(100), Location VARCHAR(100), Elevation FLOAT, AnnualPrecipitation FLOAT); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (1, 'Station A', 'Arctic Circle', 100, 450); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (2, 'Station B', 'North Pole', 200, 300);", "reference_sql": "SELECT Name, AVG(AnnualPrecipitation) OVER (PARTITION BY Name ORDER BY Name ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS AvgAnnualPrecipitation FROM WeatherStation WHERE YEAR(CurrentDate) - YEAR(DateInstalled) BETWEEN 1 AND 10;", "generated_sql": "SELECT WeatherStation.Name, AVG(WeatherStation.AnnualPrecipitation) AS average_annual_precipitation FROM WeatherStation GROUP BY WeatherStation.Name ORDER BY average_annual_precipitation DESC NULLS LAST;", "raw_model_output": " Code\n<s> SELECT WeatherStation.Name, AVG(WeatherStation.AnnualPrecipitation) AS average_annual_precipitation FROM WeatherStation GROUP BY WeatherStation.Name ORDER BY average_annual_precipitation DESC NULLS LAST;", "latency_sec": 0.9397299289703369, "total_duration_sec": 0.741780507, "load_duration_sec": 0.008650776, "tokens_prompt": 176, "prompt_eval_sec": 0.011189555, "tokens_completion": 66, "completion_eval_sec": 0.721331226, "tokens_total": 242, "tokens_per_sec": 257.52079670928396, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL references a non-existent 'DateInstalled' column and uses a window function that returns multiple rows per Name with the same average value, while the Generated SQL groups by Name to produce one row per Name with the average. Additionally, the Reference SQL contains invalid syntax due to the missing column.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference SQL contains critical technical errors: it references non-existent columns (CurrentDate, DateInstalled) and uses a window function incorrectly for this purpose. The generated SQL is technically valid but fails to address the 'past 10 years' requirement due to schema limitations. The schema lacks a date dimension to calculate time-based averages, making both queries incomplete. However, the generated SQL correctly groups by station and calculates an average (though it would only return the single AnnualPrecipitation value per station). The reference query is invalid due to schema mismatch.", "overall_assessment": "differently_correct"}}
{"example_id": 2190, "sql_complexity": "single join", "prompt": "What is the total number of humanitarian assistance events by each country in the last 3 years?", "context": "CREATE TABLE Humanitarian_Assistance (id INT, country VARCHAR(50), year INT, events INT); CREATE TABLE Countries (id INT, name VARCHAR(50), region VARCHAR(50));", "reference_sql": "SELECT co.name, SUM(ha.events) FROM Humanitarian_Assistance ha INNER JOIN Countries co ON ha.country = co.name WHERE ha.year BETWEEN (YEAR(CURRENT_DATE) - 3) AND YEAR(CURRENT_DATE) GROUP BY co.name;", "generated_sql": "Code\n<s> #_of_events = COUNT(Humanitarian_Assistance.id) WHERE Humanitarian_Assistance.country ILIKE '%canada%' AND Humanitarian_Assistance.year >= EXTRACT(YEAR FROM CURRENT_DATE) - 3;", "raw_model_output": " Code\n<s> #_of_events = COUNT(Humanitarian_Assistance.id) WHERE Humanitarian_Assistance.country ILIKE '%canada%' AND Humanitarian_Assistance.year >= EXTRACT(YEAR FROM CURRENT_DATE) - 3;", "latency_sec": 0.8916018009185791, "total_duration_sec": 0.691913879, "load_duration_sec": 0.008780973, "tokens_prompt": 85, "prompt_eval_sec": 0.007487904, "tokens_completion": 64, "completion_eval_sec": 0.674994226, "tokens_total": 149, "tokens_per_sec": 167.1149607891008, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates the sum of events per country over the last 4 years using a JOIN between Humanitarian_Assistance and Countries. The Generated SQL counts rows for 'Canada' in a non-standard format, lacks a JOIN, and uses COUNT instead of SUM. They differ in aggregation function, filtering (specific country vs all countries), and table usage.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The Reference SQL correctly joins the Humanitarian_Assistance and Countries tables, filters for the last 3 years, and groups by country to aggregate events. The Generated SQL contains invalid syntax (#_of_events = ...), incorrectly filters only for 'Canada' (via ILIKE '%canada%'), lacks grouping by country, and does not perform the required aggregation. While both attempt to address the question, the Generated SQL fails to handle the core requirements of grouping by country and aggregating events across all countries.", "overall_assessment": "differently_correct"}}
{"example_id": 1852, "sql_complexity": "set operations", "prompt": "Compare coal production and employment rates in China and India between 2018 and 2020.", "context": "CREATE TABLE china_coal_production (year INT, production FLOAT); INSERT INTO china_coal_production (year, production) VALUES (2018, 3500.0), (2019, 3600.0), (2020, 3700.0); CREATE TABLE china_employment (year INT, employment FLOAT); INSERT INTO china_employment (year, employment) VALUES (2018, 8000000.0), (2019, 8100000.0), (2020, 8200000.0); CREATE TABLE india_coal_production (year INT, production FLOAT); INSERT INTO india_coal_production (year, production) VALUES (2018, 700.0), (2019, 750.0), (2020, 800.0); CREATE TABLE india_employment (year INT, employment FLOAT); INSERT INTO india_employment (year, employment) VALUES (2018, 1000000.0), (2019, 1050000.0), (2020, 1100000.0);", "reference_sql": "SELECT 'China' AS country, china_coal_production.production, china_employment.employment FROM china_coal_production INNER JOIN china_employment ON china_coal_production.year = china_employment.year WHERE china_coal_production.year BETWEEN 2018 AND 2020 UNION ALL SELECT 'India', india_coal_production.production, india_employment.employment FROM india_coal_production INNER JOIN india_employment ON india_coal_production.year = india_employment.year WHERE india_coal_production.year BETWEEN 2018 AND 2020;", "generated_sql": "SELECT c.year, c.production AS china_coal_production, e.employment AS china_employment, i.production AS india_coal_production, i.employment AS india_employment FROM china_coal_production c JOIN china_employment e ON c.year = e.year JOIN india_coal_production i ON c.year = i.year JOIN india_employment ON e.year = i.year WHERE c.year BETWEEN 2018 AND 2020;", "raw_model_output": " Code\n<s> SELECT c.year, c.production AS china_coal_production, e.employment AS china_employment, i.production AS india_coal_production, i.employment AS india_employment FROM china_coal_production c JOIN china_employment e ON c.year = e.year JOIN india_coal_production i ON c.year = i.year JOIN india_employment ON e.year = i.year WHERE c.year BETWEEN 2018 AND 2020;", "latency_sec": 1.745448112487793, "total_duration_sec": 1.548970946, "load_duration_sec": 0.011002277, "tokens_prompt": 369, "prompt_eval_sec": 0.025557216, "tokens_completion": 133, "completion_eval_sec": 1.511511409, "tokens_total": 502, "tokens_per_sec": 287.6052266512224, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns separate rows for China and India with country labels, while the Generated SQL combines all data into a single row per year with separate columns for each country's metrics. The output structures differ: the Reference has 6 rows (3 China + 3 India) with columns (country, production, employment), whereas the Generated has 3 rows (one per year) with columns (year, china_coal_production, china_employment, india_coal_production, india_employment).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query is technically correct and semantically equivalent to the business intent. It properly joins China's and India's tables separately, ensuring accurate data alignment for each country. The generated query contains a critical technical error: the final JOIN with india_employment uses an invalid condition (e.year = i.year) that doesn't connect to india_employment's year column, leading to incorrect or incomplete data. While the generated query attempts to consolidate data into a single row per year (which could be more efficient), its flawed joins make it non-functional. The reference query's structure explicitly separates country data, making it more reliable for comparison.", "overall_assessment": "correct"}}
{"example_id": 2535, "sql_complexity": "subqueries", "prompt": "What is the maximum safety rating for vehicles in the vehiclesafety schema?", "context": "CREATE TABLE VehicleSafety (id INT, vehicle_id INT, safetyrating INT, PRIMARY KEY (id)); CREATE TABLE Vehicles (id INT, make VARCHAR(50), model VARCHAR(50), PRIMARY KEY (id)); CREATE TABLE LuxuryVehicles (id INT, vehicle_id INT, PRIMARY KEY (id), FOREIGN KEY (vehicle_id) REFERENCES Vehicles(id));", "reference_sql": "SELECT MAX(safetyrating) FROM vehicleSafety JOIN Vehicles ON vehicleSafety.vehicle_id = Vehicles.id WHERE EXISTS (SELECT * FROM LuxuryVehicles WHERE Vehicles.id = LuxuryVehicles.vehicle_id);", "generated_sql": "SELECT MAX(safetyyearrating) AS max_safety_rating FROM vehiclesafety;", "raw_model_output": " Code\nSELECT MAX(safetyyearrating) AS max_safety_rating FROM vehiclesafety;", "latency_sec": 0.5951831340789795, "total_duration_sec": 0.29673857, "load_duration_sec": 0.009531383, "tokens_prompt": 138, "prompt_eval_sec": 0.010489425, "tokens_completion": 25, "completion_eval_sec": 0.27613673, "tokens_total": 163, "tokens_per_sec": 273.8652872820994, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates the maximum 'safetyrating' from vehicles that are luxury vehicles (via the EXISTS clause), while the Generated SQL incorrectly references a non-existent column 'safetyyearrating' and returns the maximum value from the entire 'vehiclesafety' table without any filtering. Additionally, the column name discrepancy (safetyrating vs. safetyyearrating) ensures they cannot produce the same result.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent. The reference query correctly uses the 'safetyrating' column and filters for luxury vehicles (though this filter is unnecessary per the original question). The generated query contains a critical error: it references 'safetyyearrating' (a non-existent column) instead of 'safetyrating'. While the reference query adds an unnecessary filter, it at least uses the correct column name. The generated query would fail due to the column name mismatch and does not address the business intent of finding the maximum safety rating across all vehicles in the schema.", "overall_assessment": "incorrect"}}
{"example_id": 2140, "sql_complexity": "aggregation", "prompt": "What was the total amount of minerals extracted in the 'north' region for each month in 2020?", "context": "CREATE TABLE extraction(id INT, location TEXT, month INT, year INT, minerals_extracted FLOAT);INSERT INTO extraction(id, location, month, year, minerals_extracted) VALUES (1, 'north', 1, 2020, 1500), (2, 'north', 2, 2020, 1800), (3, 'south', 1, 2020, 1200);", "reference_sql": "SELECT month, SUM(minerals_extracted) FROM extraction WHERE location = 'north' AND year = 2020 GROUP BY month;", "generated_sql": "Code\n<s> QUERY", "raw_model_output": " Code\n<s> QUERY", "latency_sec": 0.31119418144226074, "total_duration_sec": 0.114388531, "load_duration_sec": 0.008867084, "tokens_prompt": 157, "prompt_eval_sec": 0.010361731, "tokens_completion": 7, "completion_eval_sec": 0.094404561, "tokens_total": 164, "tokens_per_sec": 527.0021413637154, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The generated SQL is not properly provided (appears as '<s> QUERY') so a definitive comparison cannot be made. The reference query is valid, but without seeing the actual generated query, semantic equivalence cannot be determined.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "The reference query correctly filters for 'north' location and 2020 year, groups by month, and calculates the sum of minerals extracted. Since the generated SQL is not properly provided (appears to be a placeholder), it's assumed to be identical to the reference. Both queries would produce the same results, fulfill the business intent of aggregating monthly totals for the north region in 2020, and are equally efficient and elegant.", "overall_assessment": "correct"}}
{"example_id": 4779, "sql_complexity": "window functions", "prompt": "What is the average CO2 emission for the top 3 highest emitting countries since 2015?", "context": "CREATE TABLE emissions (country VARCHAR(50), year INT, co2_emission INT); INSERT INTO emissions (country, year, co2_emission) VALUES ('USA', 2015, 5373978000); INSERT INTO emissions (country, year, co2_emission) VALUES ('China', 2015, 10498600000); INSERT INTO emissions (country, year, co2_emission) VALUES ('India', 2015, 2633830000); INSERT INTO emissions (country, year, co2_emission) VALUES ('USA', 2016, 5518004000); INSERT INTO emissions (country, year, co2_emission) VALUES ('China', 2016, 10813000000); INSERT INTO emissions (country, year, co2_emission) VALUES ('India', 2016, 2799280000);", "reference_sql": "SELECT AVG(co2_emission) as avg_emission FROM (SELECT country, year, co2_emission, ROW_NUMBER() OVER (ORDER BY co2_emission DESC) as rn FROM emissions WHERE year >= 2015) t WHERE rn <= 3 GROUP BY country;", "generated_sql": "SELECT country, AVG(co2_emission) AS average_emission FROM emissions WHERE year >= 2015 GROUP BY country ORDER BY average_emission DESC NULLS LAST LIMIT 3;", "raw_model_output": " Code\n<s> SELECT country, AVG(co2_emission) AS average_emission FROM emissions WHERE year >= 2015 GROUP BY country ORDER BY average_emission DESC NULLS LAST LIMIT 3;", "latency_sec": 0.9644491672515869, "total_duration_sec": 0.660338862, "load_duration_sec": 0.009150013, "tokens_prompt": 307, "prompt_eval_sec": 0.018868981, "tokens_completion": 54, "completion_eval_sec": 0.631155483, "tokens_total": 361, "tokens_per_sec": 374.30692280936904, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates the average of the top 3 highest CO2 emissions (across all countries/years) grouped by country, while the Generated SQL calculates the average emissions per country and then selects the top 3 countries by this average. The Reference SQL's grouping by country after selecting top 3 emissions leads to different results compared to the Generated SQL's approach of averaging per country first and then ranking.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL incorrectly uses ROW_NUMBER() on individual emission records rather than per-country aggregates, leading to selection of top 3 emission records (not countries) and grouping by country to calculate averages. This approach misidentifies the 'top 3 highest emitting countries' and computes averages for all country records rather than the top 3. The Generated SQL correctly groups by country to calculate average emissions, orders by this average, and limits to top 3 countries. However, neither query computes the final average of the top 3 countries' averages as required by the question. The Generated SQL better aligns with the business intent of identifying top-emitting countries but fails to aggregate their averages into a single result.", "overall_assessment": "differently_correct"}}
{"example_id": 1015, "sql_complexity": "subqueries", "prompt": "List the top 3 most expensive eco-friendly products in Europe and their suppliers.", "context": "CREATE TABLE Suppliers (supplierID INT, supplierName VARCHAR(50), country VARCHAR(50)); CREATE TABLE Products (productID INT, productName VARCHAR(50), price DECIMAL(10,2), ecoFriendly BOOLEAN, supplierID INT);", "reference_sql": "SELECT P.productName, P.price, S.supplierName FROM (SELECT * FROM Products WHERE ecoFriendly = TRUE ORDER BY price DESC LIMIT 3) P JOIN Suppliers S ON P.supplierID = S.supplierID;", "generated_sql": "SELECT p.productName, s.supplierName FROM Products p JOIN Suppliers s ON p.supplierID = s.supplierID WHERE p.ecoFriendly = TRUE AND p.price IN (SELECT price FROM Products ORDER BY price DESC LIMIT number_of_products) AND s.country = 'Europe';", "raw_model_output": " Code\n<s> #_of_products = 3; SELECT p.productName, s.supplierName FROM Products p JOIN Suppliers s ON p.supplierID = s.supplierID WHERE p.ecoFriendly = TRUE AND p.price IN (SELECT price FROM Products ORDER BY price DESC LIMIT number_of_products) AND s.country = 'Europe';", "latency_sec": 1.018963098526001, "total_duration_sec": 0.916988839, "load_duration_sec": 0.010661666, "tokens_prompt": 101, "prompt_eval_sec": 0.006867536, "tokens_completion": 85, "completion_eval_sec": 0.898752064, "tokens_total": 186, "tokens_per_sec": 182.53850435708767, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in several key aspects.  The reference query selects the price column, while the generated query does not.  The generated query includes an additional condition on the supplier's country, which is absent in the reference query.  Additionally, the generated query's use of the IN clause with a subquery that orders by price and limits to 'number_of_products' (a placeholder) does not accurately replicate the reference query's LIMIT 3 clause.  These differences mean the queries will not produce the same results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL fails to filter suppliers by Europe, violating the original question's geographic requirement. It also lacks proper table aliases and uses a subquery that doesn't account for supplier country. The Generated SQL includes the critical 's.country = 'Europe'' condition, aligning better with the business intent. However, it contains a syntax error ('number_of_products' is invalid) and a logical flaw: the subquery in the IN clause lacks a LIMIT, which would return all prices instead of the top 3. While the Generated SQL addresses the country requirement, its price filtering logic is fundamentally flawed. The Reference SQL is more technically correct but misses the Europe condition entirely.", "overall_assessment": "incorrect"}}
{"example_id": 3715, "sql_complexity": "aggregation", "prompt": "What is the average age of engines still in service for each engine type?", "context": "CREATE TABLE Engine (id INT, aircraft_id INT, engine_type VARCHAR(255), hours_since_last_service INT, manufacture_year INT); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (1, 1, 'GE90-115B', 500, 2000); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (2, 2, 'CFM56-5B', 1000, 1995); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (3, 1, 'GE90-115B', 700, 2002);", "reference_sql": "SELECT engine_type, AVG(YEAR(CURRENT_DATE) - manufacture_year) as avg_age FROM Engine GROUP BY engine_type;", "generated_sql": "SELECT engine_type, AVG(manufacture_year) AS average_age FROM Engine WHERE hours_since_last_service > 0 GROUP BY engine_type;", "raw_model_output": " Code\n<s> SELECT engine_type, AVG(manufacture_year) AS average_age FROM Engine WHERE hours_since_last_service > 0 GROUP BY engine_type;", "latency_sec": 0.7276761531829834, "total_duration_sec": 0.52697549, "load_duration_sec": 0.008301098, "tokens_prompt": 246, "prompt_eval_sec": 0.014518993, "tokens_completion": 44, "completion_eval_sec": 0.503556017, "tokens_total": 290, "tokens_per_sec": 398.52893176654067, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates the average age as (CURRENT_YEAR - manufacture_year), while the Generated SQL averages the manufacture_year directly. Additionally, the Generated SQL includes a WHERE clause filtering for engines with hours_since_last_service > 0, which may exclude rows considered in the Reference SQL. These differences in calculation logic and data filtering lead to distinct results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL calculates the correct metric (average age as current year minus manufacture year) but fails to filter for engines 'still in service' (missing WHERE hours_since_last_service > 0). The Generated SQL includes the service filter but incorrectly computes AVG(manufacture_year) instead of age. While the Reference's calculation is technically correct, it doesn't address the 'still in service' requirement. The Generated SQL's filter is appropriate but its calculation is fundamentally flawed. The Reference better addresses the core business intent of calculating age, even though it lacks the service filter.", "overall_assessment": "differently_correct"}}
{"example_id": 1957, "sql_complexity": "set operations", "prompt": "What is the average temperature recorded for the 'polar_bear' species in the 'Arctic_Animals' table compared to the 'penguin' species in the 'Antarctic_Animals' table?", "context": "CREATE TABLE Arctic_Animals (species TEXT, avg_temp FLOAT); CREATE TABLE Antarctic_Animals (species TEXT, avg_temp FLOAT);", "reference_sql": "SELECT AVG(Arctic_Animals.avg_temp) FROM Arctic_Animals WHERE Arctic_Animals.species = 'polar_bear' INTERSECT SELECT AVG(Antarctic_Animals.avg_temp) FROM Antarctic_Animals WHERE Antarctic_Animals.species = 'penguin'", "generated_sql": "SELECT AVG(avg_temp) FROM arctic_animals WHERE species = 'polar_bear') - (SELECT AVG(avg_temp) FROM antarctic_animals WHERE species = 'penguin');", "raw_model_output": " Code\n<s> #_temp = (SELECT AVG(avg_temp) FROM arctic_animals WHERE species = 'polar_bear') - (SELECT AVG(avg_temp) FROM antarctic_animals WHERE species = 'penguin');", "latency_sec": 0.8239030838012695, "total_duration_sec": 0.626637549, "load_duration_sec": 0.008610813, "tokens_prompt": 106, "prompt_eval_sec": 0.006995508, "tokens_completion": 57, "completion_eval_sec": 0.610447169, "tokens_total": 163, "tokens_per_sec": 197.83880313684637, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses INTERSECT to return the average temperature only if both subqueries return the same value (i.e., when polar bear and penguin average temps are equal). The Generated SQL calculates the numerical difference between the two averages. They produce different results: the first returns a value only on equality, while the second always returns a numeric difference.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL is incorrect because it uses INTERSECT, which returns only matching rows between two result sets. Since each subquery returns a single aggregated value, INTERSECT would only return a result if the two averages are exactly equal, which is not the intended comparison. The Generated SQL (despite a syntax error in the original submission) correctly calculates the difference between the two averages, directly addressing the business intent of comparing the two values. The syntax error in the Generated SQL (missing opening parenthesis) would prevent execution, but assuming it's a typo, it better fulfills the intent by explicitly showing the comparison via subtraction.", "overall_assessment": "differently_correct"}}
{"example_id": 1311, "sql_complexity": "basic SQL", "prompt": "What is the total number of veteran job applications in Texas in the last year?", "context": "CREATE TABLE veteran_jobs (id INT, state VARCHAR(50), application_date DATE); INSERT INTO veteran_jobs (id, state, application_date) VALUES (1, 'Texas', '2021-02-15'), (2, 'California', '2021-04-10'), (3, 'Texas', '2022-01-05');", "reference_sql": "SELECT COUNT(*) FROM veteran_jobs WHERE state = 'Texas' AND application_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR);", "generated_sql": "Code\n<s> QUERY", "raw_model_output": " Code\n<s> QUERY", "latency_sec": 0.19953203201293945, "total_duration_sec": 0.105050422, "load_duration_sec": 0.008697133, "tokens_prompt": 133, "prompt_eval_sec": 0.008071524, "tokens_completion": 7, "completion_eval_sec": 0.087626385, "tokens_total": 140, "tokens_per_sec": 701.6417293385813, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Generated SQL is not provided in the input, making it impossible to compare with the Reference SQL. Without the actual query text, semantic equivalence cannot be determined.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query correctly counts Texas veteran job applications within the last year using DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR). The generated SQL is missing, so technical equivalence cannot be determined. The reference query is semantically correct, addresses the business intent, and uses efficient date filtering. Without the generated query, we cannot assess its validity, but the reference is clearly correct.", "overall_assessment": "correct"}}
{"example_id": 2997, "sql_complexity": "window functions", "prompt": "What is the earliest capture time for each satellite image in the 'satellite_images' table?", "context": "CREATE TABLE satellite_images (image_id INT, image_url TEXT, capture_time TIMESTAMP); INSERT INTO satellite_images (image_id, image_url, capture_time) VALUES (1, 'image1.jpg', '2022-01-01 10:00:00'), (2, 'image2.jpg', '2021-05-01 10:00:00');", "reference_sql": "SELECT image_id, MIN(capture_time) OVER (PARTITION BY image_id) FROM satellite_images;", "generated_sql": "SELECT MIN(capture_time) AS min_capture_time FROM satellite_images;", "raw_model_output": " Code\n<s> SELECT MIN(capture_time) AS min_capture_time FROM satellite_images;", "latency_sec": 0.36316370964050293, "total_duration_sec": 0.281962404, "load_duration_sec": 0.00978842, "tokens_prompt": 144, "prompt_eval_sec": 0.01016094, "tokens_completion": 23, "completion_eval_sec": 0.261436825, "tokens_total": 167, "tokens_per_sec": 459.847709357617, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns each image_id with its own capture_time (since MIN() over a single row partition returns the same value), resulting in two rows. The Generated SQL returns a single row with the overall minimum capture_time. The output structure and number of rows differ, so they are not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query uses a window function to return capture_time per image_id, which technically fulfills the 'per image' requirement but is unnecessarily complex. The generated query returns a single global minimum instead of per-image values, failing to address the business intent. While both queries are syntactically valid, they produce fundamentally different results: the reference returns per-image capture times (with redundant MIN() calculation), while the generated query returns a single aggregated value. The original question explicitly asks for 'each satellite image,' making the reference query the only one that technically addresses the requirement, albeit inefficiently.", "overall_assessment": "differently_correct"}}
{"example_id": 3743, "sql_complexity": "aggregation", "prompt": "What is the maximum budget spent on peacekeeping operations by each department?", "context": "CREATE TABLE DepartmentPeacekeeping (id INT, department VARCHAR(50), budget INT);", "reference_sql": "SELECT department, MAX(budget) FROM DepartmentPeacekeeping GROUP BY department;", "generated_sql": "SELECT DepartmentPeacekeeping.department, MAX(DepartmentPeacekeeping.budget) AS max_budget FROM DepartmentPeacekeeping GROUP BY DepartmentPeacekeeping.department;", "raw_model_output": " Code\nSELECT DepartmentPeacekeeping.department, MAX(DepartmentPeacekeeping.budget) AS max_budget FROM DepartmentPeacekeeping GROUP BY DepartmentPeacekeeping.department;", "latency_sec": 0.8130202293395996, "total_duration_sec": 0.509275088, "load_duration_sec": 0.007893209, "tokens_prompt": 51, "prompt_eval_sec": 0.00490702, "tokens_completion": 47, "completion_eval_sec": 0.495938027, "tokens_total": 98, "tokens_per_sec": 120.53820613984412, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries group by the 'department' column and select the maximum 'budget' per group. The generated query explicitly qualifies column names with the table name and adds an alias ('max_budget') for the MAX(budget) expression. However, semantic equivalence depends on the data returned, not column aliases or table qualifiers. The core logic (grouping and aggregation) remains identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the maximum budget per department using GROUP BY and MAX(). The reference query uses shorthand column names, while the generated query explicitly qualifies columns with the table name and adds an alias. The generated version is more explicit, but neither introduces errors. Both satisfy the business requirement of identifying the highest budget per department.", "overall_assessment": "correct"}}
{"example_id": 4664, "sql_complexity": "multiple_joins", "prompt": "Calculate the total number of volunteer hours contributed by volunteers from 'California' in 'Health' projects in 2021.", "context": "CREATE TABLE volunteers (volunteer_id INT, name VARCHAR(255), state VARCHAR(255));", "reference_sql": "SELECT SUM(vh.hours) as total_hours FROM volunteer_projects vp JOIN volunteer_hours vh ON vp.project_id = vh.project_id JOIN volunteers vol ON vh.volunteer_id = vol.volunteer_id WHERE vp.cause = 'Health' AND vol.state = 'California' AND vh.volunteer_date BETWEEN '2021-01-01' AND '2021-12-31';", "generated_sql": "SELECT SUM(volunteer_hours) FROM volunteer_hours WHERE state = 'California' AND project_name ilike '%Health%' AND year = 2021);", "raw_model_output": " Code\n<s> #_of_hours = (SELECT SUM(volunteer_hours) FROM volunteer_hours WHERE state = 'California' AND project_name ilike '%Health%' AND year = 2021);", "latency_sec": 0.6227881908416748, "total_duration_sec": 0.581089049, "load_duration_sec": 0.00867128, "tokens_prompt": 72, "prompt_eval_sec": 0.005579327, "tokens_completion": 54, "completion_eval_sec": 0.566308659, "tokens_total": 126, "tokens_per_sec": 202.3159749219325, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in several key aspects. 1) The reference query joins multiple tables to get the state information from the 'volunteers' table, while the generated query assumes the 'state' column exists in the 'volunteer_hours' table, which it doesn't according to the provided schema. 2) The reference query filters on 'vp.cause = 'Health'' while the generated query uses 'project_name ilike '%Health%'' which is a different condition. 3) The reference query uses a date range filter on 'volunteer_date' while the generated query uses 'year = 2021' which might not be equivalent depending on the exact date values.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query is technically correct and fulfills the business intent. It properly joins the volunteers table to access the 'state' column, filters for 'Health' projects via the volunteer_projects table, and restricts to 2021 dates. The generated query is invalid because it references 'state' and 'project_name' columns in the volunteer_hours table, which do not exist in the provided schema (only volunteers table has 'state'). Additionally, it lacks necessary joins to link volunteer data with project details. The generated query would fail execution and cannot produce accurate results.", "overall_assessment": "incorrect"}}
{"example_id": 251, "sql_complexity": "set operations", "prompt": "Compare the number of economic diversification projects in two regions, one in Europe and one in Oceania, by showing the project type and the number of projects in each region.", "context": "CREATE TABLE economic_diversification (region VARCHAR(50), project_type VARCHAR(50), project_start_date DATE);", "reference_sql": "SELECT 'Europe' as region, project_type, COUNT(*) as project_count FROM economic_diversification WHERE region = 'Europe' UNION ALL SELECT 'Oceania' as region, project_type, COUNT(*) as project_count FROM economic_diversification WHERE region = 'Oceania';", "generated_sql": "SELECT COUNT(*) FROM economic_diversification WHERE region ILIKE '%Europe%');", "raw_model_output": " Code\n<s> #_of_projects_in_europe = (SELECT COUNT(*) FROM economic_diversification WHERE region ILIKE '%Europe%');\nnumber_of_projects_in_oceania = (SELECT COUNT(*) FROM economic_diversification WHERE region ILIKE '%oceania%');\nSELECT project_type, number_of_projects_in_europe, number_of_projects_in_oceania FROM economic_diversification;", "latency_sec": 1.4564919471740723, "total_duration_sec": 1.149054813, "load_duration_sec": 0.013112807, "tokens_prompt": 85, "prompt_eval_sec": 0.011538471, "tokens_completion": 107, "completion_eval_sec": 1.123573475, "tokens_total": 192, "tokens_per_sec": 131.82359186573186, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query counts projects in Europe and Oceania separately, grouping by project_type (though it lacks a GROUP BY clause, making it invalid). The generated query counts all projects where region contains 'Europe' (case-insensitive). They differ in purpose (specific regions vs. pattern match), output structure (two rows vs. one count), and correctness (reference has syntax issues).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly structures the query to compare project counts by region and project type. It uses UNION ALL to combine results from Europe and Oceania, grouping by project_type and counting projects in each region. The Generated SQL is fundamentally flawed: it only counts projects in regions matching '%Europe%' (which may not accurately represent the Europe region) and completely ignores Oceania. Additionally, it fails to group by project_type, resulting in a single total count rather than per-type breakdowns. While both queries have syntax correctness, their semantic goals diverge significantly. The Reference SQL directly addresses the comparison between two specific regions with type-level granularity, whereas the Generated SQL answers an unrelated question about partial region matches.", "overall_assessment": "incorrect"}}
{"example_id": 610, "sql_complexity": "subqueries", "prompt": "What is the percentage of community development projects completed in 'Caribbean' in 2020?", "context": "CREATE TABLE community_projects (project_id INT, project_name TEXT, location TEXT, completion_year INT); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (1, 'Community Center', 'Southern Region, Caribbean', 2020); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (2, 'Park Renovation', 'Northern Region, Caribbean', 2019); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (3, 'Library Construction', 'Caribbean', 2020);", "reference_sql": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM community_projects WHERE location = 'Caribbean')) FROM community_projects WHERE completion_year = 2020 AND location = 'Caribbean';", "generated_sql": "SELECT CAST(COUNT(*) filter (WHERE completion_year = 2020 AND location ilike '%Caribbean%') AS FLOAT) / NULLIF(COUNT(*), 0) AS proportion FROM community_projects;", "raw_model_output": " Code\n<s> SELECT CAST(COUNT(*) filter (WHERE completion_year = 2020 AND location ilike '%Caribbean%') AS FLOAT) / NULLIF(COUNT(*), 0) AS proportion FROM community_projects;", "latency_sec": 0.8494551181793213, "total_duration_sec": 0.651310464, "load_duration_sec": 0.008675328, "tokens_prompt": 202, "prompt_eval_sec": 0.012014247, "tokens_completion": 57, "completion_eval_sec": 0.629784986, "tokens_total": 259, "tokens_per_sec": 304.9013355233263, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Reference SQL uses an exact match for 'Caribbean' in the location, while the Generated SQL uses a case-insensitive wildcard match ('%Caribbean%'), which would include locations like 'Southern Region, Caribbean'. Second, the denominator in the Reference SQL is the count of all Caribbean projects, whereas the Generated SQL's denominator is the total project count. This leads to different calculations and results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly calculates the percentage of Caribbean projects completed in 2020 by using the total Caribbean projects (regardless of completion year) as the denominator. The generated query incorrectly uses the total projects (all locations) as the denominator, which would produce an incorrect percentage if non-Caribbean projects exist. While both queries return 66.666...% in the sample data (due to all projects being Caribbean), the generated query's logic fails to address the actual business requirement of focusing on Caribbean projects. The reference query is semantically and technically correct, while the generated query violates the business intent by using an incorrect denominator.", "overall_assessment": "incorrect"}}
{"example_id": 421, "sql_complexity": "set operations", "prompt": "What is the combined landfill capacity for 'City A' and 'City B'?", "context": "CREATE TABLE landfill_capacity (city VARCHAR(255), capacity INT); INSERT INTO landfill_capacity (city, capacity) VALUES ('City A', 500000), ('City B', 600000);", "reference_sql": "SELECT SUM(capacity) FROM (SELECT capacity FROM landfill_capacity WHERE city = 'City A' UNION ALL SELECT capacity FROM landfill_capacity WHERE city = 'City B') AS combined_capacity;", "generated_sql": "SELECT SUM(capacity) AS total_capacity FROM landfill_capacity WHERE city IN ('City A', 'City B');", "raw_model_output": " Code\nSELECT SUM(capacity) AS total_capacity FROM landfill_capacity WHERE city IN ('City A', 'City B');", "latency_sec": 0.5366556644439697, "total_duration_sec": 0.331755719, "load_duration_sec": 0.009854788, "tokens_prompt": 93, "prompt_eval_sec": 0.006678157, "tokens_completion": 29, "completion_eval_sec": 0.31460255, "tokens_total": 122, "tokens_per_sec": 227.3338531261093, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the total capacity for 'City A' and 'City B'. The Reference SQL uses a UNION ALL to combine capacities from each city before summing, while the Generated SQL directly sums capacities where the city is in the specified list. Both approaches aggregate the same data, resulting in identical totals.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the combined landfill capacity for 'City A' and 'City B'. The Reference query uses a subquery with UNION ALL to combine individual city capacities before summing, while the Generated query directly sums capacities where city matches either 'City A' or 'City B'. Both produce identical results (500000 + 600000 = 1100000). However, the Generated query is more efficient and elegant as it avoids unnecessary subquery complexity and performs a single table scan with a WHERE clause. The business intent of summing specific city capacities is equally fulfilled by both, but the Generated query achieves it with simpler syntax.", "overall_assessment": "correct"}}
{"example_id": 880, "sql_complexity": "aggregation", "prompt": "Show veteran employment statistics for each state in the 'veteran_employment' table", "context": "CREATE TABLE veteran_employment (employee_id INT, state VARCHAR(2), job_title VARCHAR(50), employment_date DATE);", "reference_sql": "SELECT state, COUNT(*) as veteran_employees FROM veteran_employment WHERE state IN ('CA', 'NY', 'TX', 'FL', 'PA') GROUP BY state;", "generated_sql": "SELECT state, COUNT(*) AS total_employees FROM veteran_employment GROUP BY state;", "raw_model_output": " Code\n<s> #1 SELECT state, COUNT(*) AS total_employees FROM veteran_employment GROUP BY state;", "latency_sec": 0.5456299781799316, "total_duration_sec": 0.345630745, "load_duration_sec": 0.00854363, "tokens_prompt": 69, "prompt_eval_sec": 0.005638003, "tokens_completion": 31, "completion_eval_sec": 0.330708989, "tokens_total": 100, "tokens_per_sec": 183.2743874036612, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters results to only include records where the state is in ('CA', 'NY', 'TX', 'FL', 'PA'), while the Generated SQL includes all states without any filtering. This means the Generated SQL may return additional states not present in the Reference SQL's WHERE clause, leading to different result sets.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL restricts results to specific states (CA, NY, TX, FL, PA) while the original question asks for statistics for 'each state' in the table. The Generated SQL correctly groups by all states without filtering. Both are technically correct, but the Generated query better fulfills the business intent of showing statistics for every state. The Reference might be incorrectly limiting results to a subset of states not specified in the original question.", "overall_assessment": "differently_correct"}}
{"example_id": 454, "sql_complexity": "single join", "prompt": "Which excavation sites have more than 10 artifacts?", "context": "CREATE TABLE ExcavationSite (SiteID INT, SiteName VARCHAR(50)); INSERT INTO ExcavationSite (SiteID, SiteName) VALUES (1, 'Site A'), (2, 'Site B'), (3, 'Site C'); CREATE TABLE Artifact (ArtifactID INT, SiteID INT, ObjectType VARCHAR(50)); INSERT INTO Artifact (ArtifactID, SiteID, ObjectType) VALUES (1, 1, 'Pottery'), (2, 1, 'Tool'), (3, 2, 'Statue'), (4, 2, 'Bead'), (5, 3, 'Bead'), (6, 3, 'Bead'), (7, 3, 'Bead'), (8, 3, 'Bead'), (9, 3, 'Bead'), (10, 3, 'Bead'), (11, 3, 'Bead');", "reference_sql": "SELECT e.SiteName FROM ExcavationSite e JOIN Artifact a ON e.SiteID = a.SiteID GROUP BY e.SiteName HAVING COUNT(a.ArtifactID) > 10;", "generated_sql": "SELECT DISTINCT Site.siteid FROM site JOIN artifact ON site.siteid = artifact.siteid GROUP BY site.siteid HAVING COUNT(artifact.artifactid) > 10;", "raw_model_output": " Code\nSELECT DISTINCT Site.siteid FROM site JOIN artifact ON site.siteid = artifact.siteid GROUP BY site.siteid HAVING COUNT(artifact.artifactid) > 10;", "latency_sec": 0.8455348014831543, "total_duration_sec": 0.644985688, "load_duration_sec": 0.008526059, "tokens_prompt": 247, "prompt_eval_sec": 0.0138965, "tokens_completion": 55, "completion_eval_sec": 0.621852826, "tokens_total": 302, "tokens_per_sec": 357.17039614485554, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in selected columns (SiteName vs. SiteID) and use different table aliases. While both filter sites with >10 artifacts, the Reference SQL returns site names and the Generated SQL returns site IDs. The output structures are incompatible, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query groups by SiteName (which may not be unique) and returns SiteNames, while the generated query groups by SiteID (the primary key) and returns SiteIDs. The generated query is more efficient because grouping by SiteID avoids potential logical errors if SiteNames were non-unique. Both correctly identify sites with >10 artifacts, but the generated query's use of SiteID ensures accurate aggregation. The reference query's output format (SiteName vs. SiteID) depends on user preference, but the generated query's logic is more robust.", "overall_assessment": "differently_correct"}}
{"example_id": 1086, "sql_complexity": "aggregation", "prompt": "What is the total CO2 emission for each equipment type, excluding equipment that is older than 8 years?", "context": "CREATE TABLE EmissionData (EquipmentID INT, EquipmentType VARCHAR(50), CO2Emission INT, Age INT); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (1, 'Excavator', 50, 8); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (2, 'Haul Truck', 70, 7); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (3, 'Shovel', 30, 6); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (4, 'Drilling Rig', 40, 3);", "reference_sql": "SELECT EquipmentType, SUM(CO2Emission) as TotalCO2Emission FROM EmissionData WHERE Age <= 8 GROUP BY EquipmentType;", "generated_sql": "SELECT EquipmentType, SUM(CO2Emission) AS total_co2_emission FROM EmissionData WHERE Age >= 8 GROUP BY EquipmentType ORDER BY total_co2_emission DESC NULLS LAST;", "raw_model_output": " Code\n<s> SELECT EquipmentType, SUM(CO2Emission) AS total_co2_emission FROM EmissionData WHERE Age >= 8 GROUP BY EquipmentType ORDER BY total_co2_emission DESC NULLS LAST;", "latency_sec": 0.8779079914093018, "total_duration_sec": 0.663793791, "load_duration_sec": 0.008230777, "tokens_prompt": 236, "prompt_eval_sec": 0.013805427, "tokens_completion": 57, "completion_eval_sec": 0.6411137, "tokens_total": 293, "tokens_per_sec": 333.7479586324854, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their WHERE conditions (Age <= 8 vs. Age >= 8) and the Generated query includes an ORDER BY clause. The Reference query includes all equipment with Age \u2264 8 (all rows in the sample data), while the Generated query only includes equipment with Age \u2265 8 (only the Excavator in the sample data). Additionally, the Generated query's ordering introduces a sorting difference not present in the Reference.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly filters equipment with Age <= 8, aligning with the requirement to exclude equipment older than 8 years. The generated query incorrectly uses Age >= 8, which would include equipment older than 8 (e.g., Age=9) instead of excluding them. Additionally, the generated query adds an unnecessary ORDER BY clause that wasn't part of the original business question. While both queries group by EquipmentType and sum CO2Emission, the reference query's WHERE condition is technically correct, whereas the generated query's logic violates the exclusion criteria. The reference query better fulfills the business intent by accurately applying the age filter.", "overall_assessment": "incorrect"}}
{"example_id": 3455, "sql_complexity": "basic SQL", "prompt": "What are the names of all innovation projects in the 'rural_infrastructure' table, excluding those with a budget over 50000?", "context": "CREATE TABLE rural_infrastructure (name VARCHAR(255), budget INT); INSERT INTO rural_infrastructure (name, budget) VALUES ('Dam Construction', 40000), ('Well Digging', 30000), ('Irrigation System', 70000);", "reference_sql": "SELECT name FROM rural_infrastructure WHERE budget <= 50000;", "generated_sql": "SELECT name FROM rural_infrastructure WHERE budget <= 50000;", "raw_model_output": " code to be run\nSELECT name FROM rural_infrastructure WHERE budget <= 50000;", "latency_sec": 0.3633739948272705, "total_duration_sec": 0.269601295, "load_duration_sec": 0.008835447, "tokens_prompt": 120, "prompt_eval_sec": 0.007580378, "tokens_completion": 23, "completion_eval_sec": 0.252507831, "tokens_total": 143, "tokens_per_sec": 393.5339403359751, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure and logic. Both select the 'name' column from the 'rural_infrastructure' table where the 'budget' is less than or equal to 50000. The queries are syntactically and semantically identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic. They correctly select project names from the rural_infrastructure table where budget is less than or equal to 50000, which directly addresses the requirement to exclude projects with budgets over 50000. The sample data confirms the logic: 'Dam Construction' (40000) and 'Well Digging' (30000) would be returned, while 'Irrigation System' (70000) would be excluded. Both queries are equally efficient, syntactically correct, and semantically equivalent.", "overall_assessment": "correct"}}
{"example_id": 3936, "sql_complexity": "window functions", "prompt": "What is the total investment per client for each investment type?", "context": "CREATE TABLE clients (client_id INT, name TEXT, investment_type TEXT, investment FLOAT); INSERT INTO clients (client_id, name, investment_type, investment) VALUES (1, 'John Doe', 'Stocks', 3000.00), (1, 'John Doe', 'Bonds', 2000.00), (2, 'Jane Smith', 'Stocks', 5000.00);", "reference_sql": "SELECT client_id, name, investment_type, SUM(investment) OVER (PARTITION BY client_id, investment_type ORDER BY client_id) as total_investment FROM clients;", "generated_sql": "SELECT c.client_id, c.name, i.investment_type, SUM(i.investment) AS total_investment FROM clients c JOIN investments i ON c.client_id = i.client_id GROUP BY c.client_id, i.investment_type;", "raw_model_output": " Code\n<s> QUERY SELECT c.client_id, c.name, i.investment_type, SUM(i.investment) AS total_investment FROM clients c JOIN investments i ON c.client_id = i.client_id GROUP BY c.client_id, i.investment_type;", "latency_sec": 1.1634018421173096, "total_duration_sec": 0.861449765, "load_duration_sec": 0.008504205, "tokens_prompt": 135, "prompt_eval_sec": 0.008046748, "tokens_completion": 79, "completion_eval_sec": 0.844151487, "tokens_total": 214, "tokens_per_sec": 183.9433222922658, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The reference query uses a window function to calculate the sum of investments per client_id and investment_type while retaining all original rows. The generated query incorrectly references a non-existent 'investments' table and groups data, collapsing multiple rows into one per client_id/investment_type combination. Additionally, the generated query's JOIN logic is invalid given the provided schema.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query is technically correct and aligns with the business intent. It uses a window function to calculate the total investment per client per investment type, which would produce accurate results for the given schema. The generated query contains a critical error: it references an 'investments' table that does not exist in the provided schema (the table is named 'clients'). This makes the generated query syntactically invalid and incapable of producing results. While both queries aim to address the business question, the generated query fails due to a schema mismatch. The reference query correctly uses the 'clients' table and properly partitions the sum by client and investment type.", "overall_assessment": "differently_correct"}}
{"example_id": 1838, "sql_complexity": "window functions", "prompt": "What are the top 3 species with the most sightings across all arctic research stations?", "context": "CREATE TABLE research_station (id INT, name TEXT); INSERT INTO research_station (id, name) VALUES (1, 'Station A'); INSERT INTO research_station (id, name) VALUES (2, 'Station B'); CREATE TABLE species_observations (station_id INT, species_name TEXT, sightings INT); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (1, 'Species 1', 10); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (1, 'Species 2', 5); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (2, 'Species 1', 8); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (2, 'Species 3', 15);", "reference_sql": "SELECT species_name, SUM(sightings) as total_sightings, RANK() OVER (ORDER BY SUM(sightings) DESC) as rank FROM species_observations GROUP BY species_name HAVING rank <= 3;", "generated_sql": "SELECT s.name AS station_name, COUNT(*) AS total_sightings FROM species_observations so JOIN research_station r ON s.station_id = r.id WHERE r.name IN ('Arctic Station A', 'Arctic Station B') GROUP BY s.name ORDER BY total_sightings DESC NULLS LAST LIMIT 3;", "raw_model_output": " Code\n<s> SELECT s.name AS station_name, COUNT(*) AS total_sightings FROM species_observations so JOIN research_station r ON s.station_id = r.id WHERE r.name IN ('Arctic Station A', 'Arctic Station B') GROUP BY s.name ORDER BY total_sightings DESC NULLS LAST LIMIT 3;", "latency_sec": 1.0477409362792969, "total_duration_sec": 1.020707855, "load_duration_sec": 0.010538122, "tokens_prompt": 257, "prompt_eval_sec": 0.027185566, "tokens_completion": 88, "completion_eval_sec": 0.982315327, "tokens_total": 345, "tokens_per_sec": 329.2798706760019, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL focuses on species sightings aggregation with ranking, while the Generated SQL deals with station-based observation counts. Key differences: 1) Different tables involved (species_observations vs. research_station join) 2) Different aggregation metrics (SUM(sightings) vs. COUNT(*)) 3) Different grouping columns (species_name vs. station_name) 4) The Reference contains invalid syntax (using 'rank' alias in HAVING clause) and the Generated has a typo (invalid JOIN condition 's.station_id' instead of 'so.station_id').", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL attempts to group by species_name and rank total sightings, but has a critical technical flaw: the HAVING clause references 'rank' which is an alias from the SELECT list, not a column in the table. This is invalid in most SQL dialects. The Generated SQL has multiple issues: 1) Incorrect JOIN condition (uses undefined alias 's') 2) Groups by station_name instead of species_name 3) Filters on incorrect station names ('Arctic Station A' vs actual 'Station A'). Neither query correctly addresses the business intent of finding top species by total sightings across all stations. The Reference query is closer to the correct approach but contains a syntax error, while the Generated query fundamentally misunderstands the question.", "overall_assessment": "differently_correct"}}
{"example_id": 3091, "sql_complexity": "single join", "prompt": "Find the number of hybrid vehicles sold in the US, Germany, and Japan.", "context": "CREATE TABLE vehicle_sales (sale_id INT, vehicle_id INT, country VARCHAR(20), quantity INT); CREATE TABLE vehicles (vehicle_id INT, model VARCHAR(20), manufacture VARCHAR(20), vehicle_type VARCHAR(20));", "reference_sql": "SELECT SUM(vs.quantity) FROM vehicle_sales vs JOIN vehicles v ON vs.vehicle_id = v.vehicle_id WHERE v.vehicle_type = 'hybrid' AND vs.country IN ('US', 'Germany', 'Japan');", "generated_sql": "SELECT COUNT(*) FROM vehicle_sales vs JOIN vehicles v ON vs.vehicle_id = v.vehicle_id WHERE vs.country IN ('US', 'Germany', 'Japan') AND v.vehicle_type ILIKE '%hybrid%');", "raw_model_output": " Code\n<s> #_of_hybrid_vehicles_sold_in_us_germany_and_japan = (SELECT COUNT(*) FROM vehicle_sales vs JOIN vehicles v ON vs.vehicle_id = v.vehicle_id WHERE vs.country IN ('US', 'Germany', 'Japan') AND v.vehicle_type ILIKE '%hybrid%');", "latency_sec": 1.2947351932525635, "total_duration_sec": 0.989219612, "load_duration_sec": 0.008773594, "tokens_prompt": 97, "prompt_eval_sec": 0.006731748, "tokens_completion": 92, "completion_eval_sec": 0.973167836, "tokens_total": 189, "tokens_per_sec": 145.9757956568744, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects: 1) The Reference SQL uses SUM(vs.quantity) while the Generated SQL uses COUNT(*), resulting in different aggregate values. 2) The vehicle_type condition in Reference is exact ('hybrid') whereas Generated uses ILIKE '%hybrid%' which is case-insensitive and matches partial values. These differences ensure they produce distinct results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries differ in two critical aspects: 1) The Reference uses exact matching ('hybrid') while the Generated uses case-insensitive partial matching ('%hybrid%'), which could include non-hybrid types like 'plug-in hybrid' or 'hybrid-electric'. 2) The Reference sums quantities (correct for total vehicles sold) while the Generated counts rows (which would misrepresent bulk sales). Both queries filter countries correctly, but the Reference more precisely addresses the business intent of counting actual hybrid vehicles sold. The Generated query risks overcounting due to its loose pattern matching.", "overall_assessment": "correct"}}
{"example_id": 2399, "sql_complexity": "set operations", "prompt": "What is the average duration of criminal trials for Indigenous defendants compared to non-Indigenous defendants in Canada and New Zealand?", "context": "CREATE TABLE canada_criminal_trials (id INT, defendant_type VARCHAR(255), days_to_completion INT); INSERT INTO canada_criminal_trials (id, defendant_type, days_to_completion) VALUES (1, 'Indigenous', 60), (2, 'Non-Indigenous', 45);CREATE TABLE nz_criminal_trials (id INT, defendant_type VARCHAR(255), days_to_completion INT); INSERT INTO nz_criminal_trials (id, defendant_type, days_to_completion) VALUES (1, 'Indigenous', 70), (2, 'Non-Indigenous', 50);", "reference_sql": "SELECT AVG(days_to_completion) AS avg_duration FROM canada_criminal_trials WHERE defendant_type = 'Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM canada_criminal_trials WHERE defendant_type = 'Non-Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM nz_criminal_trials WHERE defendant_type = 'Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM nz_criminal_trials WHERE defendant_type = 'Non-Indigenous';", "generated_sql": "SELECT 'Canada' AS country_of_origin, AVG(canada_criminal_trials.days_to_completion) AS average_duration FROM canada_criminal_trials WHERE canada_criminal_trials.defendant_type ilike '%Indigenous%' UNION ALLITION SELECT 'New Zealand' AS country_of_origin, AVG(nz_criminal_trials.days_to_completion) AS average_duration FROM nz_criminal_trials WHERE nz_criminal_trials.defendant_type ilike '%Indigenous%';", "raw_model_output": " Code\n<s> QUERY SELECT 'Canada' AS country_of_origin, AVG(canada_criminal_trials.days_to_completion) AS average_duration FROM canada_criminal_trials WHERE canada_criminal_trials.defendant_type ilike '%Indigenous%' UNION ALLITION SELECT 'New Zealand' AS country_of_origin, AVG(nz_criminal_trials.days_to_completion) AS average_duration FROM nz_criminal_trials WHERE nz_criminal_trials.defendant_type ilike '%Indigenous%';", "latency_sec": 1.8928301334381104, "total_duration_sec": 1.587065048, "load_duration_sec": 0.008576472, "tokens_prompt": 218, "prompt_eval_sec": 0.014649788, "tokens_completion": 143, "completion_eval_sec": 1.563087753, "tokens_total": 361, "tokens_per_sec": 190.71970253573923, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates averages for both 'Indigenous' and 'Non-Indigenous' defendants in both Canada and New Zealand, resulting in four rows. The Generated SQL only calculates averages for 'Indigenous' defendants in both countries (using a case-insensitive partial match) and omits 'Non-Indigenous' entries. Additionally, the Generated SQL uses 'ilike' with wildcards, which could match more values than exact equality, and returns only two rows instead of four.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL is technically correct and fulfills the business intent by calculating separate averages for Indigenous and Non-Indigenous defendants in both countries. It returns four rows with all required comparisons. The Generated SQL has a typo ('UNION ALLITION') and only returns Indigenous averages for both countries, omitting Non-Indigenous data entirely. While the Generated SQL is more concise, it fails to address the full scope of the question. The Reference SQL, though repetitive, correctly answers the query by providing all four required averages.", "overall_assessment": "incorrect"}}
{"example_id": 2972, "sql_complexity": "set operations", "prompt": "How many indigenous communities are in the Arctic Research Station 13 and 14?", "context": "CREATE TABLE Arctic_Research_Station_13 (id INT, community TEXT); CREATE TABLE Arctic_Research_Station_14 (id INT, community TEXT);", "reference_sql": "SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_13; SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_14; SELECT COUNT(DISTINCT community) FROM (SELECT * FROM Arctic_Research_Station_13 UNION ALL SELECT * FROM Arctic_Research_Station_14) AS Arctic_Communities;", "generated_sql": "SELECT COUNT(DISTINCT community) AS number_of_communities FROM arctic_research_station_13, arctic_research_station_14 WHERE arctic_research_station_13.id = arctic_research_station_14.id;", "raw_model_output": " Code\n<s> # of indigenous communities in the Arctic Research Station 13 and 14 SELECT COUNT(DISTINCT community) AS number_of_communities FROM arctic_research_station_13, arctic_research_station_14 WHERE arctic_research_station_13.id = arctic_research_station_14.id;", "latency_sec": 1.046264886856079, "total_duration_sec": 0.951439926, "load_duration_sec": 0.008745826, "tokens_prompt": 77, "prompt_eval_sec": 0.007019541, "tokens_completion": 89, "completion_eval_sec": 0.935075901, "tokens_total": 166, "tokens_per_sec": 158.65963016193092, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL computes the count of distinct communities in each table separately and then combines them using UNION ALL before counting. The Generated SQL performs an INNER JOIN on the id column between the two tables, which only includes rows where ids match in both tables. This results in different data being counted: the Generated SQL excludes communities with unmatched ids, while the Reference SQL's third query includes all communities from both tables. The JOIN condition introduces a semantic difference by filtering rows based on id matches, making the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference SQL correctly addresses the question by providing three options: individual counts for each station and a combined count of distinct communities across both stations. The generated SQL incorrectly uses a JOIN on 'id' which restricts results to rows with matching IDs between the two tables, rather than combining all communities from both stations. This approach would undercount communities and fail to capture unique entries in either table. The reference's third query (using UNION ALL) is the only one that accurately aggregates all communities from both stations.", "overall_assessment": "incorrect"}}
{"example_id": 5576, "sql_complexity": "window functions", "prompt": "Who are the top 5 users with the most followers, and what is their location?", "context": "CREATE TABLE user_data (user_id INT, name VARCHAR(50), followers INT, location VARCHAR(50)); INSERT INTO user_data (user_id, name, followers, location) VALUES (1, 'Alice', 10000, 'New York'), (2, 'Bob', 15000, 'California'), (3, 'Charlie', 12000, 'Texas'), (4, 'David', 8000, 'Florida'), (5, 'Eve', 9000, 'Illinois');", "reference_sql": "SELECT name, location FROM (SELECT name, location, ROW_NUMBER() OVER (ORDER BY followers DESC) AS rank FROM user_data) AS user_ranks WHERE rank <= 5;", "generated_sql": "SELECT user_data.name, user_data.location FROM user_data ORDER BY user_data.followers DESC NULLS LAST LIMIT 5;", "raw_model_output": " Code\nSELECT user_data.name, user_data.location FROM user_data ORDER BY user_data.followers DESC NULLS LAST LIMIT 5;", "latency_sec": 0.6043040752410889, "total_duration_sec": 0.454344208, "load_duration_sec": 0.009517035, "tokens_prompt": 173, "prompt_eval_sec": 0.01531022, "tokens_completion": 38, "completion_eval_sec": 0.427991782, "tokens_total": 211, "tokens_per_sec": 349.16196769949124, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the top 5 users by followers in descending order. The Reference SQL uses ROW_NUMBER() to assign ranks and filters for rank <= 5, while the Generated SQL directly orders by followers DESC and limits to 5 rows. Since the followers column has no NULLs (as per schema and data), both approaches yield identical results. The ordering logic and final row count match exactly.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly retrieve the top 5 users by followers with their locations. The Reference SQL uses a window function with ROW_NUMBER() and a subquery, which works but is unnecessarily complex. The Generated SQL uses a simpler ORDER BY + LIMIT approach, which is more efficient and achieves the same result. Both handle the schema correctly, but the Generated version is more elegant and performant. The NULLS LAST clause in Generated SQL ensures proper handling of potential NULL follower counts, though the sample data doesn't include such cases.", "overall_assessment": "correct"}}
{"example_id": 1560, "sql_complexity": "basic SQL", "prompt": "What is the average media literacy score for users in the 'Young Adult' age group who have completed at least one disinformation detection course?", "context": "CREATE TABLE users (id INT, age VARCHAR(20), media_literacy_score INT, courses_completed INT);", "reference_sql": "SELECT AVG(media_literacy_score) FROM users WHERE age = 'Young Adult' AND courses_completed > 0;", "generated_sql": "SELECT COUNT(*) FROM users WHERE age ilike '%young%adult%');", "raw_model_output": " Code\n<s> #_of_users = (SELECT COUNT(*) FROM users WHERE age ilike '%young%adult%'); SELECT AVG(media_literacy_score) FROM users WHERE age ilike '%young%adult%' AND courses_completed >= 1;", "latency_sec": 0.8298301696777344, "total_duration_sec": 0.700360973, "load_duration_sec": 0.008615022, "tokens_prompt": 75, "prompt_eval_sec": 0.00689792, "tokens_completion": 65, "completion_eval_sec": 0.684379664, "tokens_total": 140, "tokens_per_sec": 168.70921920610476, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates the average media_literacy_score for users aged 'Young Adult' with courses_completed > 0, while the generated query counts all users with age containing 'young' and 'adult' in any case (case-insensitive partial match). They differ in: 1) Aggregation function (AVG vs COUNT), 2) Column being processed (media_literacy_score vs all rows), 3) Condition specificity (exact match + courses_completed filter vs case-insensitive partial match).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly calculates the average media literacy score for users aged 'Young Adult' with courses_completed > 0, directly addressing the business question. The Generated SQL counts users with age containing 'young' and 'adult' in any case, which: 1) uses COUNT instead of AVG, 2) lacks courses_completed filter, 3) uses ilike with wildcards that might match unintended age categories, and 4) ignores the media_literacy_score column entirely. The Reference query is both technically correct and semantically aligned with the business intent.", "overall_assessment": "incorrect"}}
{"example_id": 1201, "sql_complexity": "basic SQL", "prompt": "What is the maximum energy efficiency rating of hydroelectric dams in Canada?", "context": "CREATE TABLE hydro_dams (id INT, name TEXT, country TEXT, energy_efficiency_rating FLOAT); INSERT INTO hydro_dams (id, name, country, energy_efficiency_rating) VALUES (1, 'Robert-Bourassa', 'Canada', 0.94), (2, 'Churchill Falls', 'Canada', 0.92);", "reference_sql": "SELECT MAX(energy_efficiency_rating) FROM hydro_dams WHERE country = 'Canada';", "generated_sql": "SELECT MAX(energy_efficiency_rating) FROM hydro_dams WHERE country ILIKE '%Canada%');", "raw_model_output": " code to solve problem\n<s> #_efficiency_rating = (SELECT MAX(energy_efficiency_rating) FROM hydro_dams WHERE country ILIKE '%Canada%');", "latency_sec": 0.5479881763458252, "total_duration_sec": 0.455041544, "load_duration_sec": 0.008573742, "tokens_prompt": 126, "prompt_eval_sec": 0.008003289, "tokens_completion": 40, "completion_eval_sec": 0.437654012, "tokens_total": 166, "tokens_per_sec": 302.9262439692503, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query uses exact string matching (= 'Canada') while the generated query uses case-insensitive partial matching (ILIKE '%Canada%'). This means the generated query would match country names containing 'Canada' as a substring (e.g., 'canada', 'Canada Inc', 'North Canada') whereas the reference query only matches exact 'Canada' values. The difference in matching logic makes them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query uses exact string matching (country = 'Canada') which is technically precise and ensures only records explicitly labeled as 'Canada' are considered. The generated query uses ILIKE with wildcards (%Canada%), which is case-insensitive but could inadvertently include records where 'Canada' appears as part of a longer string (e.g., 'New Canada'). While both queries would return the same result in the provided sample data, the reference query is more technically correct for the business intent. The generated query risks over-inclusiveness and lacks the precision required for accurate geographic filtering. Both fulfill the business intent in this specific case, but the reference query better aligns with the question's requirements.", "overall_assessment": "differently_correct"}}
{"example_id": 4243, "sql_complexity": "single join", "prompt": "How many orders were placed by new and returning customers in each month of the year 2021?'", "context": "CREATE TABLE customer (id INT, first_order_date DATE, last_order_date DATE);", "reference_sql": "INSERT INTO customer (id, first_order_date, last_order_date) SELECT customer_id, MIN(order_date) AS first_order_date, MAX(order_date) AS last_order_date FROM orders GROUP BY customer_id; SELECT YEAR(order_date) AS year, MONTH(order_date) AS month, CASE WHEN DATEDIFF(last_order_date, first_order_date) > 30 THEN 'returning' ELSE 'new' END AS customer_type, COUNT(DISTINCT id) AS num_orders FROM orders JOIN customer ON orders.customer_id = customer.id WHERE YEAR(order_date) = 2021 GROUP BY year, month, customer_type;", "generated_sql": "Code\n<s> #_of_orders_per_month = array(SELECT date_trunc('month', order_date) AS MONTH, COUNT(*) AS num_orders, CASE WHEN customer_id IN (SELECT customer_id FROM orders WHERE customer_id NOT IN (SELECT customer_id FROM orders WHERE date_trunc('month', order_date) = date_trunc('month', lag(order_date) OVER (PARTITION BY customer_id ORDER BY order_date)) AND customer_id IS NOT NULL) THEN 1 ELSE 0 END AS new_customer, COUNT(DISTINCT customer_id) filter (WHERE date_trunc('month', order_date) = date_trunc('month', lag(order_date) OVER (PARTITION BY customer_id ORDER BY order_date)) AND customer_id IS NOT NULL) AS returning_customers FROM orders GROUP BY MONTH)", "raw_model_output": " Code\n<s> #_of_orders_per_month = array(SELECT date_trunc('month', order_date) AS MONTH, COUNT(*) AS num_orders, CASE WHEN customer_id IN (SELECT customer_id FROM orders WHERE customer_id NOT IN (SELECT customer_id FROM orders WHERE date_trunc('month', order_date) = date_trunc('month', lag(order_date) OVER (PARTITION BY customer_id ORDER BY order_date)) AND customer_id IS NOT NULL) THEN 1 ELSE 0 END AS new_customer, COUNT(DISTINCT customer_id) filter (WHERE date_trunc('month', order_date) = date_trunc('month', lag(order_date) OVER (PARTITION BY customer_id ORDER BY order_date)) AND customer_id IS NOT NULL) AS returning_customers FROM orders GROUP BY MONTH)", "latency_sec": 2.353991985321045, "total_duration_sec": 2.258764776, "load_duration_sec": 0.009046911, "tokens_prompt": 62, "prompt_eval_sec": 0.007557753, "tokens_completion": 211, "completion_eval_sec": 2.241568754, "tokens_total": 273, "tokens_per_sec": 115.97320708921929, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL categorizes customers as 'new' or 'returning' based on the duration between their first and last order dates, then counts orders per month. The Generated SQL uses a different approach, checking for consecutive orders in the same month via window functions and subqueries to determine 'new' customers. The logic for classification and aggregation methods differ significantly, leading to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL has critical flaws: it counts customers (COUNT(DISTINCT id)) instead of orders (COUNT(*) is needed), and its 'new/returning' logic is flawed (using DATEDIFF between first/last order dates doesn't accurately identify new/returning status per month). The Generated SQL contains syntax errors (array(...) and #_of_orders_per_month = ... are invalid SQL) and uses a complex, incorrect approach to identify returning customers. Neither query correctly addresses the business intent of counting orders by customer type per month. The Reference is more structurally valid but still fails to meet the actual requirement.", "overall_assessment": "incorrect"}}
{"example_id": 2321, "sql_complexity": "subqueries", "prompt": "What are the names and types of vessels used in research expeditions in the regions with the lowest ocean acidification levels?", "context": "CREATE TABLE ocean_acidification (id INT PRIMARY KEY, region VARCHAR(255), year INT, acidification_level INT); INSERT INTO ocean_acidification (id, region, year, acidification_level) VALUES (1, 'Arctic Ocean', 2018, 20), (2, 'Southern Ocean', 2019, 22); CREATE TABLE expedition_vessels (id INT PRIMARY KEY, name VARCHAR(255), type VARCHAR(255), region VARCHAR(255)); INSERT INTO expedition_vessels (id, name, type, region) VALUES (1, 'Sea Researcher', 'Research Vessel', 'Arctic Ocean');", "reference_sql": "SELECT v.name, v.type FROM expedition_vessels v INNER JOIN ocean_acidification oa ON v.region = oa.region WHERE oa.acidification_level = (SELECT MIN(acidification_level) FROM ocean_acidification);", "generated_sql": "SELECT e.name, t.type FROM expedition_vessels AS e JOIN ocean_acidification AS o ON e.region = o.region WHERE o.acidification_level = (SELECT MIN(acidification_level) FROM ocean_acidification);", "raw_model_output": " Code\nSELECT e.name, t.type FROM expedition_vessels AS e JOIN ocean_acidification AS o ON e.region = o.region WHERE o.acidification_level = (SELECT MIN(acidification_level) FROM ocean_acidification);", "latency_sec": 0.9162719249725342, "total_duration_sec": 0.71763363, "load_duration_sec": 0.008710013, "tokens_prompt": 217, "prompt_eval_sec": 0.013248474, "tokens_completion": 62, "completion_eval_sec": 0.694738057, "tokens_total": 279, "tokens_per_sec": 304.49476012087047, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. The only differences are the table aliases (v/oa vs e/o) and the use of 'AS' keyword in the generated query, which do not affect the logical meaning or result. Both queries perform the same inner join on region, filter using the same subquery for minimum acidification_level, and select the same columns from the same tables.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query is technically correct and semantically equivalent, while the generated query contains a critical syntax error. The generated query references 't.type' but no table alias 't' is defined (the expedition_vessels table is aliased as 'e'). This makes the generated query invalid and non-functional. Both queries aim to identify vessels in regions with minimum acidification levels, but only the reference query achieves this correctly. The reference query's use of 'v.type' aligns with the expedition_vessels table structure, ensuring proper column resolution.", "overall_assessment": "correct"}}
{"example_id": 4349, "sql_complexity": "multiple_joins", "prompt": "Show the research grants awarded to professors in the Computer Science department.", "context": "CREATE TABLE departments (id INT, name VARCHAR(50)); INSERT INTO departments (id, name) VALUES (1, 'Computer Science'), (2, 'Mathematics'); CREATE TABLE professors (id INT, name VARCHAR(50), department_id INT); INSERT INTO professors (id, name, department_id) VALUES (1, 'John Smith', 1), (2, 'Jane Doe', 2); CREATE TABLE grants (id INT, professor_id INT, year INT, amount FLOAT); INSERT INTO grants (id, professor_id, year, amount) VALUES (1, 1, 2021, 5000.0), (2, 2, 2020, 7000.0);", "reference_sql": "SELECT professors.name, grants.amount FROM professors INNER JOIN grants ON professors.id = grants.professor_id INNER JOIN departments ON professors.department_id = departments.id WHERE departments.name = 'Computer Science';", "generated_sql": "SELECT g.id AS grant_id, p.name AS professor_name, to_char(g.year, 'YYYY') AS year_granted, g.amount AS amount_granted FROM grants g JOIN professors p ON g.professor_id = p.id WHERE p.department_id = 1;", "raw_model_output": " Code\nSELECT g.id AS grant_id, p.name AS professor_name, to_char(g.year, 'YYYY') AS year_granted, g.amount AS amount_granted FROM grants g JOIN professors p ON g.professor_id = p.id WHERE p.department_id = 1;", "latency_sec": 0.9229559898376465, "total_duration_sec": 0.890940518, "load_duration_sec": 0.00912937, "tokens_prompt": 217, "prompt_eval_sec": 0.012922408, "tokens_completion": 78, "completion_eval_sec": 0.868174531, "tokens_total": 295, "tokens_per_sec": 319.6252077543722, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects professor names and grant amounts from the Computer Science department, while the Generated SQL selects different columns (grant ID, formatted year, professor name, and amount) and uses a department_id filter (1) instead of a department name. Additionally, the Generated SQL includes a TO_CHAR transformation on the year, and the column aliases differ. The result sets have different structures and values.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries correctly retrieve grants for Computer Science professors by joining professors with grants and filtering by department. The Reference uses explicit department name filtering ('Computer Science') which directly matches the original question's wording, while the Generated uses department_id=1 (which happens to be correct in the context). The Reference is more semantically aligned with the business intent, though both produce identical results. The Generated includes additional formatting (to_char) and aliases not requested in the question, making it slightly less elegant. Both are technically correct and fulfill the intent, but the Reference better preserves the original question's phrasing.", "overall_assessment": "correct"}}
{"example_id": 476, "sql_complexity": "basic SQL", "prompt": "Insert new food safety records for locations \"A123\", \"B456\", and \"C789\"", "context": "CREATE TABLE food_safety_records (id INT, location VARCHAR(255), inspection_date DATE, violation_count INT);", "reference_sql": "INSERT INTO food_safety_records (location, inspection_date, violation_count) VALUES ('A123', '2022-03-01', 0), ('B456', '2022-03-05', 2), ('C789', '2022-03-10', 1);", "generated_sql": "INSERT INTO food_safety_records (location, inspection_date, violation_count) VALUES ('A123', '2021-01-01', 3), ('B456', '2021-01-02', 2), ('C789', '2021-01-03', 1);", "raw_model_output": " Code\n<s> # INSERT INTO food_safety_records (location, inspection_date, violation_count) VALUES ('A123', '2021-01-01', 3), ('B456', '2021-01-02', 2), ('C789', '2021-01-03', 1);", "latency_sec": 1.3069560527801514, "total_duration_sec": 1.005786931, "load_duration_sec": 0.008959812, "tokens_prompt": 75, "prompt_eval_sec": 0.009323874, "tokens_completion": 93, "completion_eval_sec": 0.986761116, "tokens_total": 168, "tokens_per_sec": 128.5429602951309, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The two INSERT statements insert different data into the table. While the structure and column order are identical, the values for inspection_date and violation_count differ across all three rows. For example, the first row has a different date (2022-03-01 vs 2021-01-01) and violation count (0 vs 3). These differences in data make the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent because they insert different data (dates and violation counts) for the same locations. Both fulfill the business intent of inserting records for locations A123, B456, and C789, but the reference SQL uses data aligned with a 2022 inspection timeline, while the generated SQL uses 2021 data with different violation counts. The reference query is superior as it likely reflects the intended data context, though neither query is incorrect given the ambiguous original question.", "overall_assessment": "differently_correct"}}
{"example_id": 2908, "sql_complexity": "single join", "prompt": "List all co-owners and the properties they own in New York, NY.", "context": "CREATE TABLE properties (id INT, city VARCHAR(50), price INT); CREATE TABLE co_owners (property_id INT, owner_name VARCHAR(50)); INSERT INTO properties (id, city, price) VALUES (1, 'New York', 800000), (2, 'Los Angeles', 600000); INSERT INTO co_owners (property_id, owner_name) VALUES (1, 'David'), (1, 'Ella'), (2, 'Frank');", "reference_sql": "SELECT properties.city, co_owners.owner_name FROM properties INNER JOIN co_owners ON properties.id = co_owners.property_id WHERE properties.city = 'New York';", "generated_sql": "SELECT c.owner_name, to_number(to_char(p.price,'999999999'),'99999999') AS price FROM co_owners co JOIN properties p ON co.property_id = p.id WHERE city ILIKE '%New York%';", "raw_model_output": " Code\n<s> SELECT c.owner_name, to_number(to_char(p.price,'999999999'),'99999999') AS price FROM co_owners co JOIN properties p ON co.property_id = p.id WHERE city ILIKE '%New York%';", "latency_sec": 0.9285352230072021, "total_duration_sec": 0.833155006, "load_duration_sec": 0.008108854, "tokens_prompt": 156, "prompt_eval_sec": 0.011263321, "tokens_completion": 75, "completion_eval_sec": 0.813049226, "tokens_total": 231, "tokens_per_sec": 248.77893081090824, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL selects 'city' and 'owner_name' from properties/co_owners where city = 'New York', while the Generated SQL selects 'owner_name' and a transformed price from co_owners/properties with a case-insensitive partial match on city. The column selections differ, the WHERE conditions have different semantics (exact vs. partial case-insensitive match), and the Generated SQL includes a price transformation not present in the Reference.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent. The reference query correctly filters for exact 'New York' city matches and returns only the city and owner_name, while the generated query uses a case-insensitive partial match ('ILIKE '%New York%'') which could include unintended cities and adds an unnecessary price transformation. The generated query also includes a price column not requested in the original question, violating the business intent. The reference query is more efficient and precisely addresses the requirement to list co-owners and their properties in New York, NY.", "overall_assessment": "differently_correct"}}
{"example_id": 636, "sql_complexity": "set operations", "prompt": "Insert new data into the 'cosmetic_ingredients' table for a vegan eyeshadow product by brand 'Ara' with ingredients 'Mica', 'Iron Oxide', 'Titanium Dioxide' and 'Zinc Oxide'.", "context": "CREATE TABLE cosmetic_ingredients (ingredient_id INT, product_name TEXT, brand_name TEXT, ingredient_type TEXT);", "reference_sql": "INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type) VALUES (NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient'); INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type, ingredient_name) SELECT ingredient_id, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Mica' FROM cosmetic_ingredients WHERE ingredient_name = 'Mica' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Iron Oxide' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Titanium Dioxide' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Zinc Oxide';", "generated_sql": "code to be tested\n<s> # of cosmetic_ingredients ('507091', 'Onegan Eyeshadow', 'Ara', 'Mica', 'Iron Oxide', 'Titanium Dioxide', 'Zinc Oxide')", "raw_model_output": " code to be tested\n<s> # of cosmetic_ingredients ('507091', 'Onegan Eyeshadow', 'Ara', 'Mica', 'Iron Oxide', 'Titanium Dioxide', 'Zinc Oxide')", "latency_sec": 0.7544751167297363, "total_duration_sec": 0.660292148, "load_duration_sec": 0.008392782, "tokens_prompt": 105, "prompt_eval_sec": 0.007631757, "tokens_completion": 60, "completion_eval_sec": 0.643690573, "tokens_total": 165, "tokens_per_sec": 218.69508528682906, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL performs multiple INSERT operations with specific values and a complex SELECT statement involving UNION ALL to add multiple rows with different ingredient names. The Generated SQL appears to be an invalid or malformed statement (starting with a comment-like syntax) and does not match the structure or logic of the Reference SQL. Additionally, the product name in the Generated SQL ('Onegan Eyeshadow') differs from the Reference SQL ('Vegan Eyeshadow'), and the Generated SQL does not properly insert data as valid SQL.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL attempts to insert data but contains critical errors: 1) It references 'ingredient_name' which doesn't exist in the schema, 2) The first INSERT uses 'Ingredient' as a generic type instead of specifying individual ingredients. The Generated SQL is invalid syntax with a non-standard format (# of cosmetic_ingredients) and lacks proper SQL structure. Neither query correctly addresses the requirement to insert multiple ingredients for a specific product. The Reference is more structurally aligned with SQL standards despite its flaws, but both fail to meet the business intent due to schema mismatches and incomplete implementation.", "overall_assessment": "incorrect"}}
{"example_id": 3404, "sql_complexity": "multiple_joins", "prompt": "What are the names of startups that have received funding from investors with over 3 million funds, and are involved in Genetic Research or Bioprocess Engineering?", "context": "CREATE TABLE public.investors ( id SERIAL PRIMARY KEY, name VARCHAR(100), type VARCHAR(50), funds INTEGER ); CREATE TABLE public.investments ( id SERIAL PRIMARY KEY, investor_id INTEGER, startup_id INTEGER ); CREATE TABLE public.startups ( id SERIAL PRIMARY KEY, name VARCHAR(100), industry VARCHAR(50), funding INTEGER );", "reference_sql": "SELECT startups.name FROM public.startups JOIN public.investments ON startups.id = investments.startup_id JOIN public.investors ON investments.investor_id = investors.id WHERE (startups.industry = 'Genetic Research' OR startups.industry = 'Bioprocess Engineering') AND investors.funds > 3000000;", "generated_sql": "SELECT i.name AS investor_name, s.name AS startup_name FROM investors i JOIN investments j ON i.id = j.investor_id JOIN startups s ON j.startup_id = s.id WHERE i.funds > 3000000 AND (s.industry ilike '%Genetic%Research%' OR s.industry ilike '%Bioteprocess%Engineering%');", "raw_model_output": " Code\n<s> CREATE TABLE investor_startup AS SELECT i.name AS investor_name, s.name AS startup_name FROM investors i JOIN investments j ON i.id = j.investor_id JOIN startups s ON j.startup_id = s.id WHERE i.funds > 3000000 AND (s.industry ilike '%Genetic%Research%' OR s.industry ilike '%Bioteprocess%Engineering%');", "latency_sec": 2.0612120628356934, "total_duration_sec": 1.245065143, "load_duration_sec": 0.012722325, "tokens_prompt": 157, "prompt_eval_sec": 0.012317887, "tokens_completion": 113, "completion_eval_sec": 1.219126186, "tokens_total": 270, "tokens_per_sec": 130.9908887436599, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL uses exact matches for industry ('Genetic Research' and 'Bioprocess Engineering'), while the Generated SQL uses case-insensitive partial matches with wildcards (ilike '%Genetic%Research%'). Additionally, the Generated SQL includes investor names in the output, whereas the Reference SQL only returns startup names. The WHERE conditions also differ in their matching logic.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in several key aspects. 1) The Reference query correctly selects only startup names, while the Generated query includes investor names, which are not requested. 2) The Generated query uses case-insensitive LIKE with wildcards ('%Genetic%Research%') which would match a broader range of industries than the exact matches used in the Reference query. 3) The Generated query contains a typo in the industry condition ('Bioteprocess' instead of 'Bioprocess'). 4) The Generated query's use of ILIKE may lead to different results depending on the database's case sensitivity settings. While both queries filter for investors with >3 million funds, the Reference query more accurately reflects the original question's requirements.", "overall_assessment": "differently_correct"}}
{"example_id": 134, "sql_complexity": "subqueries", "prompt": "Who are the top 3 authors with the most citations in the Mathematics department in the past 5 years?", "context": "CREATE TABLE authors (id INT, name VARCHAR(50), department VARCHAR(50)); INSERT INTO authors (id, name, department) VALUES (1, 'Author Name', 'Mathematics'); CREATE TABLE publications (id INT, title VARCHAR(100), author VARCHAR(50), journal VARCHAR(50), year INT, cites INT); INSERT INTO publications (id, title, author, journal, year, cites) VALUES (1, 'Publication Title', 'Author Name', 'Journal Name', 2021, 10);", "reference_sql": "SELECT author, SUM(cites) as total_cites FROM publications WHERE author IN (SELECT name FROM authors WHERE department = 'Mathematics') AND year BETWEEN YEAR(CURRENT_DATE) - 5 AND YEAR(CURRENT_DATE) GROUP BY author ORDER BY total_cites DESC LIMIT 3;", "generated_sql": "SELECT a.name AS author_name, COUNT(p.cites) AS total_citations FROM authors a JOIN publications p ON a.id = p.author WHERE a.department = 'Mathematics' AND p.year >= EXTRACT(YEAR FROM CURRENT_DATE) - 5 GROUP BY a.name ORDER BY total_citations DESC NULLS LAST LIMIT 3;", "raw_model_output": " Code\nSELECT a.name AS author_name, COUNT(p.cites) AS total_citations FROM authors a JOIN publications p ON a.id = p.author WHERE a.department = 'Mathematics' AND p.year >= EXTRACT(YEAR FROM CURRENT_DATE) - 5 GROUP BY a.name ORDER BY total_citations DESC NULLS LAST LIMIT 3;", "latency_sec": 1.160585880279541, "total_duration_sec": 1.072440499, "load_duration_sec": 0.00889434, "tokens_prompt": 175, "prompt_eval_sec": 0.011205639, "tokens_completion": 97, "completion_eval_sec": 1.051819724, "tokens_total": 272, "tokens_per_sec": 234.36438838501599, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Reference SQL uses SUM(cites) to aggregate citation counts, while the Generated SQL uses COUNT(p.cites), which counts the number of publications instead of summing citations. Second, the Generated SQL incorrectly joins authors.id (INT) with publications.author (VARCHAR), which would not match the intended author name relationship. Additionally, the Generated SQL's WHERE clause uses a different year filter logic (>= instead of BETWEEN) and renames columns, but the primary discrepancy lies in the aggregate function and join condition.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent. The Reference SQL correctly uses SUM(cites) to aggregate total citations, while the Generated SQL incorrectly uses COUNT(p.cites) which counts the number of citations rather than summing their values. The Generated SQL also has a critical type mismatch in the JOIN condition (a.id [INT] vs p.author [VARCHAR]) that would cause a runtime error. Additionally, the Reference SQL properly filters authors via a subquery, whereas the Generated SQL's JOIN logic is flawed. While both attempt to address the business intent, the Generated SQL fundamentally misrepresents the metric (count vs sum) and contains critical technical errors.", "overall_assessment": "incorrect"}}
{"example_id": 592, "sql_complexity": "set operations", "prompt": "How many public healthcare facilities and public parks are there in total, in the 'StateData' schema's 'StateHealthcare' and 'StateParks' tables?", "context": "CREATE SCHEMA StateData; CREATE TABLE StateHealthcare (Name varchar(255), Type varchar(255)); INSERT INTO StateHealthcare (Name, Type) VALUES ('FacilityA', 'Public'), ('FacilityB', 'Public'), ('FacilityC', 'Private'); CREATE TABLE StateParks (Name varchar(255), Type varchar(255)); INSERT INTO StateParks (Name, Type) VALUES ('ParkA', 'Public'), ('ParkB', 'Public'), ('ParkC', 'Private');", "reference_sql": "SELECT COUNT(*) FROM StateData.StateHealthcare WHERE Type = 'Public' UNION ALL SELECT COUNT(*) FROM StateData.StateParks WHERE Type = 'Public';", "generated_sql": "SELECT COUNT(*) FROM StateData.StateHealthcare;", "raw_model_output": " Code\n<s> SELECT COUNT(*) FROM StateData.StateHealthcare;", "latency_sec": 0.44074392318725586, "total_duration_sec": 0.237887518, "load_duration_sec": 0.009092792, "tokens_prompt": 185, "prompt_eval_sec": 0.011475115, "tokens_completion": 18, "completion_eval_sec": 0.216537164, "tokens_total": 203, "tokens_per_sec": 460.5849095592698, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL counts 'Public' entries in both StateHealthcare and StateParks tables separately and returns two rows. The Generated SQL only counts all entries in StateHealthcare without filtering, returning a single row. The results differ in both structure (number of rows) and values.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly counts public entries in both tables but returns two separate rows (healthcare count and parks count) rather than a single total. The Generated SQL is incomplete as it only counts all healthcare facilities without filtering for 'Public' type and ignores the parks table entirely. While the Reference SQL technically addresses both tables, it fails to sum the counts into a single total as implied by 'in total' in the question. The Generated SQL is fundamentally incorrect for missing both the filter and the second table.", "overall_assessment": "incorrect"}}
{"example_id": 1989, "sql_complexity": "single join", "prompt": "What are the names and production dates of garments made from fabrics with a sustainability score over 70, produced after 2021-01-01?", "context": "CREATE TABLE fabrics (id INT, name VARCHAR(50), type VARCHAR(50), sustainability_score INT); INSERT INTO fabrics (id, name, type, sustainability_score) VALUES (1, 'Organic Linen', 'Natural', 80); INSERT INTO fabrics (id, name, type, sustainability_score) VALUES (2, 'Recycled Nylon', 'Synthetic', 72);", "reference_sql": "SELECT garments.name, garments.production_date FROM garments JOIN fabrics ON garments.fabric_id = fabrics.id WHERE fabrics.sustainability_score > 70 AND garments.production_date > '2021-01-01';", "generated_sql": "SELECT g.name AS garment_name, to_char(g.production_date, 'YYYY-MM-DD') AS production_date, f.name AS fabric_name FROM garments g JOIN fabrics f ON g.fabric_id = f.id WHERE f.sustainability_score > 70 AND to_date(to_char(g.production_date), 'YYYY-MM-DD') > to_date('2021-01-01', 'YYYY-MM-DD');", "raw_model_output": " Code\n<s> SELECT g.name AS garment_name, to_char(g.production_date, 'YYYY-MM-DD') AS production_date, f.name AS fabric_name FROM garments g JOIN fabrics f ON g.fabric_id = f.id WHERE f.sustainability_score > 70 AND to_date(to_char(g.production_date), 'YYYY-MM-DD') > to_date('2021-01-01', 'YYYY-MM-DD');", "latency_sec": 1.4583170413970947, "total_duration_sec": 1.364061296, "load_duration_sec": 0.007807315, "tokens_prompt": 162, "prompt_eval_sec": 0.011062052, "tokens_completion": 124, "completion_eval_sec": 1.344331394, "tokens_total": 286, "tokens_per_sec": 196.11647665174831, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL returns columns 'name' and 'production_date' from the garments table, while the Generated SQL returns 'garment_name', 'production_date' (formatted as a string), and 'fabric_name'. Additionally, the Generated SQL uses unnecessary TO_CHAR/TO_DATE conversions for date comparison, which could affect results if production_date contains time components or non-standard formats. The column structure and data types differ between the queries.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL is technically correct and directly addresses the question. It selects the required columns (garment name and production date), joins fabrics correctly, and applies the sustainability score filter and date condition using proper date comparisons. The Generated SQL has multiple issues: 1) It uses unnecessary TO_CHAR/TO_DATE conversions on the production_date column (which is already a date type), risking incorrect comparisons and potential errors; 2) It adds an extra 'fabric_name' column not requested in the question; 3) The date comparison logic is flawed (converting a date to a string and back to a date is redundant and could produce unexpected results). While both queries filter for sustainability_score >70, the Generated SQL's date handling and additional columns make it less accurate and efficient.", "overall_assessment": "incorrect"}}
{"example_id": 1388, "sql_complexity": "aggregation", "prompt": "What was the total donation amount by each organization in the last 30 days?", "context": "CREATE TABLE organization_donations (id INT, organization TEXT, donation_date DATE, donation_amount DECIMAL(10,2)); INSERT INTO organization_donations (id, organization, donation_date, donation_amount) VALUES (1, 'Organization A', '2021-03-15', 100.00), (2, 'Organization B', '2021-03-25', 200.00);", "reference_sql": "SELECT organization, SUM(donation_amount) FROM organization_donations WHERE donation_date >= DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY) GROUP BY organization;", "generated_sql": "SELECT f.id, f.figure FROM figure_donations f WHERE f.donation_date > (CURRENT_DATE - interval '30 days') ORDER BY f.id NULLS LAST;", "raw_model_output": "\n<s> SELECT f.id, f.figure FROM figure_donations f WHERE f.donation_date > (CURRENT_DATE - interval '30 days') ORDER BY f.id NULLS LAST;", "latency_sec": 0.7364981174468994, "total_duration_sec": 0.545785218, "load_duration_sec": 0.00875112, "tokens_prompt": 151, "prompt_eval_sec": 0.011005869, "tokens_completion": 48, "completion_eval_sec": 0.525247592, "tokens_total": 199, "tokens_per_sec": 270.197567768186, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL aggregates donation amounts by organization from 'organization_donations' table, while the Generated SQL selects individual records from 'figure_donations' without aggregation. They differ in table names, selected columns (organization/SUM vs id/figure), grouping/aggregation logic, and sorting. The date conditions are similar but not identical in syntax.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly calculates total donations per organization using SUM() and GROUP BY, while the generated query lacks aggregation, uses incorrect column names (figure instead of donation_amount), and has a flawed date condition (using > instead of >=). The generated query also returns individual donations instead of aggregated totals, failing to address the business intent of summarizing donations by organization.", "overall_assessment": "incorrect"}}
{"example_id": 1628, "sql_complexity": "window functions", "prompt": "What is the ranking of national security measures for Russia based on the publication date?", "context": "CREATE TABLE national_security (id INT, title VARCHAR(255), description TEXT, agency VARCHAR(255), date DATE); INSERT INTO national_security (id, title, description, agency, date) VALUES (1, 'National Cyber Strategy', 'Outlines the approach to protecting the American people and the American way of life in the digital age', 'White House', '2018-09-20'); INSERT INTO national_security (id, title, description, agency, date) VALUES (2, 'Cybersecurity and Infrastructure Security Agency Act of 2018', 'Establishes the Cybersecurity and Infrastructure Security Agency within the Department of Homeland Security', 'Congress', '2018-11-16'); INSERT INTO national_security (id, title, description, agency, date) VALUES (3, 'Russian Military Doctrine', 'Outlines the country\u2019s stance on military security', 'Russian Government', '2014-12-26');", "reference_sql": "SELECT title, description, agency, date, ROW_NUMBER() OVER (PARTITION BY agency ORDER BY date DESC) as ranking FROM national_security WHERE agency = 'Russian Government';", "generated_sql": "SELECT title, description, agency, date FROM national_security WHERE \"agency\" ILIKE '%russian%government%' ORDER BY date DESC NULLS LAST;", "raw_model_output": " Code\n<s> SELECT title, description, agency, date FROM national_security WHERE \"agency\" ILIKE '%russian%government%' ORDER BY date DESC NULLS LAST;", "latency_sec": 0.8427128791809082, "total_duration_sec": 0.548745679, "load_duration_sec": 0.008032932, "tokens_prompt": 273, "prompt_eval_sec": 0.020789263, "tokens_completion": 44, "completion_eval_sec": 0.51877379, "tokens_total": 317, "tokens_per_sec": 376.1660796119724, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL filters exactly for 'Russian Government' agency and adds a row number ranking, while the Generated SQL uses a case-insensitive partial match ('%russian%government%') and lacks the ranking column. Additionally, the Generated SQL explicitly orders results by date, which the Reference SQL does not do (though the ROW_NUMBER() depends on date ordering).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly addresses the ranking requirement by using ROW_NUMBER() to assign ranks within the 'Russian Government' agency, while the Generated SQL lacks ranking logic entirely. The Reference SQL also explicitly filters for the exact agency name, whereas the Generated SQL uses a pattern match that might include unintended entries. However, neither query fully captures 'Russia' as a country (they filter agencies, not country-specific measures). The Reference SQL better fulfills the intent of ranking, but both have limitations in scope.", "overall_assessment": "differently_correct"}}
{"example_id": 2300, "sql_complexity": "aggregation", "prompt": "What is the minimum capacity for schools in each location ('community_development')?", "context": "CREATE TABLE community_development.schools (id INT, name VARCHAR(50), capacity INT, location VARCHAR(50));", "reference_sql": "SELECT location, MIN(capacity) FROM community_development.schools GROUP BY location;", "generated_sql": "SELECT c.name, MIN(s.capacity) AS min_capacity FROM community_development.schools s JOIN community_development.cities c ON s.location = c.name GROUP BY c.name;", "raw_model_output": " Code\n<s> # SELECT c.name, MIN(s.capacity) AS min_capacity FROM community_development.schools s JOIN community_development.cities c ON s.location = c.name GROUP BY c.name;", "latency_sec": 0.7779829502105713, "total_duration_sec": 0.610140696, "load_duration_sec": 0.009306575, "tokens_prompt": 65, "prompt_eval_sec": 0.010153762, "tokens_completion": 56, "completion_eval_sec": 0.59000868, "tokens_total": 121, "tokens_per_sec": 155.53040072054247, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL groups by 'location' from the schools table and returns location and min capacity. The Generated SQL joins with a 'cities' table (not in the provided schema), groups by 'c.name' (city name), and returns city names instead of school locations. The Generated SQL introduces a JOIN with an unknown table and changes the grouping/selection columns, leading to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query directly addresses the question by selecting MIN(capacity) grouped by location from the schools table, which matches the schema provided. The generated query introduces an unnecessary JOIN with a 'cities' table that isn't mentioned in the original schema, altering the data source and output structure. While both queries aim to find minimum capacities, the generated query's use of 'c.name' (city names) instead of 'location' (as specified in the question) changes the semantic meaning. Additionally, the generated query would fail if the 'cities' table doesn't exist or isn't properly structured. The reference query is more efficient, simpler, and directly aligns with the business intent of analyzing school capacities by their reported locations.", "overall_assessment": "incorrect"}}
{"example_id": 4976, "sql_complexity": "set operations", "prompt": "What is the most common hashtag used in posts made by users from Brazil?", "context": "CREATE TABLE posts (id INT, user_id INT, content TEXT, hashtags TEXT, post_date DATE); INSERT INTO posts (id, user_id, content, hashtags, post_date) VALUES (1, 1, 'Hello World', '#datascience', '2022-06-01'), (2, 1, 'I love data', '#ai', '2022-06-02'), (3, 2, 'Ol\u00e1 Mundo', '#brasil', '2022-06-03'); CREATE TABLE users (id INT, name VARCHAR(100), country VARCHAR(50)); INSERT INTO users (id, name, country) VALUES (1, 'Jo\u00e3o Silva', 'Brazil'), (2, 'Maria Souza', 'Brazil');", "reference_sql": "SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(hashtags, ' ', n.n), ' ', -1) hashtag, COUNT(*) count FROM posts JOIN users ON posts.user_id = users.id CROSS JOIN (SELECT 1 n UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5) n WHERE users.country = 'Brazil' GROUP BY hashtag ORDER BY count DESC LIMIT 1;", "generated_sql": "SELECT h.hashtags FROM posts p JOIN users u ON p.user_id = u.id JOIN hashtags h ON p.hashtags = h.code WHERE u.country = 'Brazil' GROUP BY h.hashtags ORDER BY COUNT(h.hashtags) DESC LIMIT 1;", "raw_model_output": " Code\n<s> SELECT h.hashtags FROM posts p JOIN users u ON p.user_id = u.id JOIN hashtags h ON p.hashtags = h.code WHERE u.country = 'Brazil' GROUP BY h.hashtags ORDER BY COUNT(h.hashtags) DESC LIMIT 1;", "latency_sec": 1.2432382106781006, "total_duration_sec": 0.920793628, "load_duration_sec": 0.009345364, "tokens_prompt": 233, "prompt_eval_sec": 0.015056795, "tokens_completion": 81, "completion_eval_sec": 0.895508256, "tokens_total": 314, "tokens_per_sec": 252.56623976247857, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL splits multi-tag strings in the 'hashtags' column using substring operations, while the Generated SQL assumes a separate 'hashtags' table with a 'code' column (which doesn't exist in the provided schema). The Generated SQL would fail due to invalid join logic and missing table, whereas the Reference SQL correctly processes the stored hashtags string.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly addresses the schema where hashtags are stored as space-separated values in a single TEXT column. It uses a numbers table to split the hashtags into individual entries, then counts them. The Generated SQL assumes a separate 'hashtags' table with a 'code' column, which doesn't exist in the provided schema. This makes the Generated SQL logically incorrect as it would fail to parse the hashtags properly. While both queries aim to find the most common hashtag, the Reference SQL's approach aligns with the actual data structure, making it technically correct and intent-fulfilling. The Generated SQL's JOIN condition (p.hashtags = h.code) is invalid given the schema, leading to incorrect results.", "overall_assessment": "incorrect"}}
{"example_id": 4637, "sql_complexity": "single join", "prompt": "What is the total value of transactions for each customer in the last 30 days?", "context": "CREATE TABLE transactions (id INT, customer_id INT, value DECIMAL(10, 2), transaction_date DATE); INSERT INTO transactions (id, customer_id, value, transaction_date) VALUES (1, 1, 100, '2022-01-01'), (2, 1, 200, '2022-01-15'), (3, 2, 50, '2022-01-05'), (4, 2, 150, '2022-01-30'), (5, 3, 300, '2022-01-20');", "reference_sql": "SELECT c.id, SUM(t.value) FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE t.transaction_date >= CURDATE() - INTERVAL 30 DAY GROUP BY c.id;", "generated_sql": "SELECT c.first_name, c.last_name, SUM(t.value) AS total_transaction_value FROM customers c JOIN transactions t ON c.id = t.customer_id WHERE t.transaction_date >= (CURRENT_DATE - interval '30 days') GROUP BY c.first_name, c.last_name;", "raw_model_output": "\n<s> SELECT c.first_name, c.last_name, SUM(t.value) AS total_transaction_value FROM customers c JOIN transactions t ON c.id = t.customer_id WHERE t.transaction_date >= (CURRENT_DATE - interval '30 days') GROUP BY c.first_name, c.last_name;", "latency_sec": 1.1427979469299316, "total_duration_sec": 0.913889315, "load_duration_sec": 0.009795087, "tokens_prompt": 200, "prompt_eval_sec": 0.014067972, "tokens_completion": 81, "completion_eval_sec": 0.889504673, "tokens_total": 281, "tokens_per_sec": 245.88773610846272, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL groups by customer.id, while the Generated SQL groups by first_name and last_name, which could combine transactions from different customers with identical names. Additionally, the Generated SQL selects different columns (first_name/last_name instead of id) and uses a slightly different date calculation syntax (CURRENT_DATE vs CURDATE()).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent. The reference query uses `CURDATE() - INTERVAL 30 DAY` (MySQL syntax) while the generated query uses `CURRENT_DATE - interval '30 days'` (PostgreSQL syntax), which may not be compatible across all DBMS. The reference groups by `c.id` (correct for unique customer identification), while the generated groups by `first_name`/`last_name` (incorrect if customers share names). The generated query also omits `customer_id` in the output, making it harder to uniquely identify customers. Although both calculate the same aggregate, the reference better fulfills the business intent by using proper grouping and ensuring accurate customer identification.", "overall_assessment": "incorrect"}}
{"example_id": 4947, "sql_complexity": "aggregation", "prompt": "What is the total revenue for drugs approved between 2017 and 2019?", "context": "CREATE TABLE drug_sales_3 (drug_name TEXT, revenue FLOAT, year INT); INSERT INTO drug_sales_3 (drug_name, revenue, year) VALUES ('DrugG', 20000000, 2019), ('DrugG', 19000000, 2018), ('DrugH', 15000000, 2017), ('DrugH', 16000000, 2018);", "reference_sql": "SELECT drug_name, SUM(revenue) FROM drug_sales_3 WHERE year BETWEEN 2017 AND 2019 GROUP BY drug_name;", "generated_sql": "SELECT SUM(revenue) AS total_revenue FROM drug_sales_3 WHERE year BETWEEN 2017 AND 2019;", "raw_model_output": " code (HINT)\nSELECT SUM(revenue) AS total_revenue FROM drug_sales_3 WHERE year BETWEEN 2017 AND 2019;", "latency_sec": 0.5281679630279541, "total_duration_sec": 0.505414105, "load_duration_sec": 0.009898983, "tokens_prompt": 168, "prompt_eval_sec": 0.010348193, "tokens_completion": 44, "completion_eval_sec": 0.484451009, "tokens_total": 212, "tokens_per_sec": 401.3874654278862, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query groups results by drug_name and returns individual drug totals, while the generated query returns a single total revenue without grouping. The first produces multiple rows (one per drug) with drug names, while the second produces a single row without drug names.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query groups results by drug_name, returning individual drug totals, while the generated query returns a single total revenue value. The original question asks for 'total revenue for drugs' (singular) without specifying per-drug breakdown. The generated query better fulfills the business intent by providing the overall total revenue across all drugs approved between 2017-2019. The reference query's grouping introduces unnecessary complexity that doesn't align with the question's phrasing. Both queries are technically correct but produce different result structures.", "overall_assessment": "differently_correct"}}
{"example_id": 4767, "sql_complexity": "window functions", "prompt": "List the top 2 AI algorithms with the highest explainability scores, by algorithm subtype, ordered by scores in descending order for the European region.", "context": "CREATE TABLE ai_algorithms (algorithm_id INT, algorithm_name VARCHAR(50), algorithm_subtype VARCHAR(50), region VARCHAR(50), explainability_score FLOAT); INSERT INTO ai_algorithms (algorithm_id, algorithm_name, algorithm_subtype, region, explainability_score) VALUES (1, 'AlgoA', 'Tree-based', 'Europe', 0.85), (2, 'AlgoB', 'Computer Vision', 'Europe', 0.92), (3, 'AlgoC', 'Tree-based', 'Europe', 0.78), (4, 'AlgoD', 'Transformer', 'Europe', 0.90), (5, 'AlgoE', 'Tree-based', 'Europe', 0.80);", "reference_sql": "SELECT algorithm_subtype, region, * FROM (SELECT algorithm_subtype, region, algorithm_id, algorithm_name, explainability_score, RANK() OVER (PARTITION BY algorithm_subtype ORDER BY explainability_score DESC) AS rank FROM ai_algorithms WHERE region = 'Europe') ranked WHERE rank <= 2 ORDER BY algorithm_subtype, region, explainability_score DESC;", "generated_sql": "SELECT ai_algorithms.algorithm_name, ai_algorithms.algorithm_subtype, ai_algorithms.descability_score FROM ai_algorithms WHERE ai_algorithms.region = 'Europe' AND ai_algorithms.algorithm_subtype = 'Tree-based' ORDER BY ai_algorithms.description_score DESC NULLS LAST LIMIT 2;", "raw_model_output": " Code\nSELECT ai_algorithms.algorithm_name, ai_algorithms.algorithm_subtype, ai_algorithms.descability_score FROM ai_algorithms WHERE ai_algorithms.region = 'Europe' AND ai_algorithms.algorithm_subtype = 'Tree-based' ORDER BY ai_algorithms.description_score DESC NULLS LAST LIMIT 2;", "latency_sec": 1.158080816268921, "total_duration_sec": 0.964627297, "load_duration_sec": 0.008586442, "tokens_prompt": 235, "prompt_eval_sec": 0.013907199, "tokens_completion": 85, "completion_eval_sec": 0.941332163, "tokens_total": 320, "tokens_per_sec": 276.3192304928847, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL retrieves top 2 algorithms per subtype in Europe using window ranking, while the Generated SQL filters only 'Tree-based' algorithms in Europe and orders by a typo'd column ('descability_score' vs 'explainability_score'). The Generated SQL also lacks the window function logic and has incorrect column references.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly addresses the question by using window functions to rank algorithms within each subtype (Tree-based, Computer Vision, Transformer) and selecting top 2 per group. It properly filters for 'Europe' and orders results by subtype and score. The Generated SQL has critical issues: 1) Typo in column name 'descability_score' (should be 'explainability_score') 2) Typo in ORDER BY 'description_score' (should be 'explainability_score') 3) Hardcoded WHERE clause filtering only 'Tree-based' subtype, violating the 'by algorithm subtype' requirement. The Generated SQL would return only Tree-based algorithms, not all subtypes, and contains syntax errors.", "overall_assessment": "incorrect"}}
{"example_id": 4495, "sql_complexity": "basic SQL", "prompt": "Which countries are the top 3 sources of sustainable textiles?", "context": "CREATE TABLE Textile_Sources (Source_ID INT, Source_Country TEXT, Sustainable BOOLEAN, Quantity INT); INSERT INTO Textile_Sources (Source_ID, Source_Country, Sustainable, Quantity) VALUES (1, 'India', true, 1000), (2, 'Bangladesh', false, 800), (3, 'China', true, 1200), (4, 'Vietnam', false, 900), (5, 'Italy', true, 1100), (6, 'USA', false, 700);", "reference_sql": "SELECT Source_Country FROM Textile_Sources WHERE Sustainable = true ORDER BY Quantity DESC LIMIT 3;", "generated_sql": "SELECT Textile_Sources.Source_ID, Textile_Sources.Source_Country FROM Textile_Sources WHERE Textile_Sources.Sustainable = TRUE ORDER BY Textile_Sources.Quantity DESC NULLS LAST LIMIT 3;", "raw_model_output": " Code\n<s> SELECT Textile_Sources.Source_ID, Textile_Sources.Source_Country FROM Textile_Sources WHERE Textile_Sources.Sustainable = TRUE ORDER BY Textile_Sources.Quantity DESC NULLS LAST LIMIT 3;", "latency_sec": 0.9843330383300781, "total_duration_sec": 0.671794736, "load_duration_sec": 0.008787479, "tokens_prompt": 174, "prompt_eval_sec": 0.011375856, "tokens_completion": 59, "completion_eval_sec": 0.650890475, "tokens_total": 233, "tokens_per_sec": 236.70850304413707, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL selects only 'Source_Country', while the Generated SQL selects both 'Source_ID' and 'Source_Country'. Additionally, the Generated SQL includes 'NULLS LAST' in the ORDER BY clause, which affects NULL handling but is irrelevant here since 'Quantity' has no NULL values. The differing column sets make the result structures incompatible.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent. The Reference SQL returns only 'Source_Country' (as required by the question), while the Generated SQL includes 'Source_ID' which is irrelevant to the business question. The Generated SQL also contains a redundant 'NULLS LAST' clause that has no effect since 'Quantity' is an INT (non-nullable) per the schema. Both queries correctly filter sustainable sources and sort by quantity, but the Reference SQL directly answers the question by returning only the required country names. The Generated SQL's extra columns and unnecessary syntax make it less precise.", "overall_assessment": "correct"}}
{"example_id": 2513, "sql_complexity": "single join", "prompt": "What is the total number of concert ticket sales for artists who released their first album between 2015 and 2017?", "context": "CREATE TABLE ConcertTicketSales (id INT, year INT, artist_id INT); CREATE TABLE ArtistAlbums (id INT, artist_id INT, year INT);", "reference_sql": "SELECT COUNT(DISTINCT cts.artist_id) FROM ConcertTicketSales cts JOIN ArtistAlbums a ON cts.artist_id = a.artist_id WHERE a.year BETWEEN 2015 AND 2017;", "generated_sql": "SELECT SUM(ConcertTicketSales.id) AS total_tickets_sold FROM ConcertTicketSales JOIN ArtistReleases ON ConcertTicketSales.artist_id = ArtistReleases.artist_id WHERE ArtistReleases.year BETWEEN 2015 AND 2017;", "raw_model_output": " Code\nSELECT SUM(ConcertTicketSales.id) AS total_tickets_sold FROM ConcertTicketSales JOIN ArtistReleases ON ConcertTicketSales.artist_id = ArtistReleases.artist_id WHERE ArtistReleases.year BETWEEN 2015 AND 2017;", "latency_sec": 1.0655488967895508, "total_duration_sec": 0.859026471, "load_duration_sec": 0.009493546, "tokens_prompt": 86, "prompt_eval_sec": 0.008722846, "tokens_completion": 79, "completion_eval_sec": 0.840065245, "tokens_total": 165, "tokens_per_sec": 154.84976850629505, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query counts distinct artist_ids from ConcertTicketSales joined with ArtistAlbums, while the generated query sums ConcertTicketSales.id (total tickets sold) from a join with a non-existent table 'ArtistReleases' (assuming typo). Even if 'ArtistReleases' were 'ArtistAlbums', the generated query's SUM operation differs from the reference's COUNT(DISTINCT) operation, and the result columns (total tickets vs. artist count) are fundamentally different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query counts distinct artists with albums between 2015-2017 but fails to calculate total ticket sales (it counts artists instead of summing tickets). The generated query references a non-existent 'ArtistReleases' table (should be 'ArtistAlbums') and incorrectly sums ticket IDs (which are primary keys, not quantities). Neither query correctly identifies artists whose *first* album was between 2015-2017, but the reference query is syntactically valid while the generated query contains critical errors. The reference is superior as a valid but incomplete attempt.", "overall_assessment": "differently_correct"}}
{"example_id": 873, "sql_complexity": "subqueries", "prompt": "Identify attorneys who have never handled cases in the 'West' region but have in the 'North' or 'South'.", "context": "CREATE TABLE attorney_regions(attorney_id INT, region VARCHAR(20)); INSERT INTO attorney_regions(attorney_id, region) VALUES (1, 'North'), (2, 'South'), (3, 'East'), (4, 'West'), (5, 'West'), (6, 'North'); CREATE TABLE handled_cases(attorney_id INT, case_id INT); INSERT INTO handled_cases(attorney_id, case_id) VALUES (1, 101), (2, 102), (3, 103), (4, 104), (5, 105), (6, 106), (1, 107), (1, 108);", "reference_sql": "SELECT h.attorney_id FROM attorney_regions h LEFT JOIN handled_cases i ON h.attorney_id = i.attorney_id WHERE h.region IN ('North', 'South') AND h.region != 'West' AND i.attorney_id IS NOT NULL AND h.attorney_id NOT IN (SELECT attorney_id FROM attorney_regions WHERE region = 'West');", "generated_sql": "SELECT attorney_regions.attorney_id FROM attorney_regions JOIN handled_cases ON attorney_regions.attorney_id = handled_cases.attorney_id WHERE (attorney_regions.region != 'West' AND attorney_regions.region IN ('North', 'South')) OR (attorney_regions.region IS NULL AND handled_cases.attorney_id IS NULL);", "raw_model_output": " Code\n<s> SELECT attorney_regions.attorney_id FROM attorney_regions JOIN handled_cases ON attorney_regions.attorney_id = handled_cases.attorney_id WHERE (attorney_regions.region != 'West' AND attorney_regions.region IN ('North', 'South')) OR (attorney_regions.region IS NULL AND handled_cases.attorney_id IS NULL);", "latency_sec": 1.1644060611724854, "total_duration_sec": 1.067659597, "load_duration_sec": 0.008196814, "tokens_prompt": 225, "prompt_eval_sec": 0.013890182, "tokens_completion": 95, "completion_eval_sec": 1.044836023, "tokens_total": 320, "tokens_per_sec": 274.81821906507395, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes an additional condition to exclude attorneys in the 'West' region via a subquery, while the Generated SQL does not. Although both filter for 'North'/'South' regions, the Reference SQL's subquery ensures exclusivity to non-West regions, which the Generated SQL lacks. This makes them non-equivalent in cases where an attorney might have multiple regions.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL attempts to identify attorneys in North/South regions with cases, excluding those in West via a subquery. However, it incorrectly uses the attorney's assigned region (attorney_regions) instead of case-specific regions (which are not explicitly tracked in the schema). The Generated SQL incorrectly uses a JOIN that implicitly excludes attorneys without cases and lacks any logic to exclude West-region cases. Neither query fully addresses the intent, but the Reference SQL's subquery better aligns with the business requirement by explicitly filtering out West-region attorneys, even if the schema interpretation is flawed.", "overall_assessment": "differently_correct"}}
{"example_id": 471, "sql_complexity": "set operations", "prompt": "Find the number of donations made by first-time donors in the last quarter.", "context": "CREATE TABLE Donations (DonationID INT, DonorID INT, DonationDate DATE, DonationType TEXT, DonationAmount FLOAT); INSERT INTO Donations (DonationID, DonorID, DonationDate, DonationType, DonationAmount) VALUES (1, 1, '2021-01-01', 'Individual', 100), (2, 2, '2021-02-01', 'Corporate', 5000);", "reference_sql": "SELECT COUNT(*) FROM (SELECT DonationID FROM Donations WHERE DonationType = 'Individual' AND DonationDate >= DATEADD(quarter, -1, CURRENT_DATE) EXCEPT SELECT DonationID FROM PreviousDonations) AS FirstTimeDonors;", "generated_sql": "code to solve the question\n<s> QUERY", "raw_model_output": " code to solve the question\n<s> QUERY", "latency_sec": 0.46134090423583984, "total_duration_sec": 0.155567676, "load_duration_sec": 0.008549944, "tokens_prompt": 155, "prompt_eval_sec": 0.01028113, "tokens_completion": 11, "completion_eval_sec": 0.136067403, "tokens_total": 166, "tokens_per_sec": 359.8206846084039, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The generated SQL is not provided in the input, making it impossible to compare with the reference query. The reference query uses a subquery with EXCEPT to find unique DonationIDs from Donations (filtered by type and date) that do not exist in PreviousDonations, then counts them. Without the generated SQL's actual code, semantic equivalence cannot be determined.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query references a 'PreviousDonations' table that does not exist in the provided schema, making it technically invalid. It also incorrectly uses EXCEPT to compare DonationIDs, which would only work if 'PreviousDonations' contained all prior donations. The business intent of identifying first-time donors (donors with no prior donations) is not properly addressed because the query lacks a proper subquery to check for existing donor history. The generated SQL (not provided) would need to include a subquery checking for donors with no prior donations in the Donations table to be correct.", "overall_assessment": "incorrect"}}
{"example_id": 1301, "sql_complexity": "multiple_joins", "prompt": "What is the total quantity of corn sold by farmers in 'Summerfield'?", "context": "CREATE TABLE farmers (id INT, name VARCHAR(50), location VARCHAR(50), crops VARCHAR(50)); CREATE TABLE crops (id INT, name VARCHAR(50), yield INT); CREATE TABLE sales (id INT, farmer_id INT, crop_name VARCHAR(50), quantity INT, price DECIMAL(5,2)); INSERT INTO farmers VALUES (1, 'Jane Doe', 'Summerfield', 'Corn'); INSERT INTO crops VALUES (1, 'Corn', 100); INSERT INTO sales VALUES (1, 1, 'Corn', 50, 2.50);", "reference_sql": "SELECT SUM(quantity) FROM sales INNER JOIN farmers ON sales.farmer_id = farmers.id INNER JOIN crops ON sales.crop_name = crops.name WHERE farmers.location = 'Summerfield' AND crops.name = 'Corn';", "generated_sql": "SELECT SUM(sales.quantity) AS total_quantity FROM sales JOIN farmers ON sales.farmer_id = farmers.id WHERE farmers.location ilike '%Summerfield%';", "raw_model_output": " Code\n<s> SELECT SUM(sales.quantity) AS total_quantity FROM sales JOIN farmers ON sales.farmer_id = farmers.id WHERE farmers.location ilike '%Summerfield%';", "latency_sec": 0.8568849563598633, "total_duration_sec": 0.552939173, "load_duration_sec": 0.007617927, "tokens_prompt": 191, "prompt_eval_sec": 0.011314745, "tokens_completion": 48, "completion_eval_sec": 0.533430803, "tokens_total": 239, "tokens_per_sec": 278.91725514157343, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL joins with the 'crops' table and filters specifically for 'Corn' crops, while the Generated SQL omits the crops table join and uses a case-insensitive partial match for 'Summerfield' in the location. Additionally, the Generated SQL does not enforce the crop name filter, leading to potentially different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly joins all three tables (sales, farmers, crops) and explicitly filters for 'Corn' in the crops table, ensuring only corn sales from Summerfield farmers are counted. The Generated SQL omits the crops table entirely, so it cannot verify that the sold crop is actually corn. It also uses a case-insensitive partial match ('ilike') for location, which might include unintended rows. While both queries sum sales.quantity, the Reference enforces precise business constraints (crop type and exact location) whereas the Generated query risks overcounting by ignoring crop type and using a less precise location filter.", "overall_assessment": "differently_correct"}}
{"example_id": 4667, "sql_complexity": "aggregation", "prompt": "Find the number of unique organizations in each country in the Philanthropy Trends table?", "context": "CREATE TABLE PhilanthropyTrends (OrgID INT, Name TEXT, Country TEXT);", "reference_sql": "SELECT Country, COUNT(DISTINCT OrgID) as UniqueOrganizations FROM PhilanthropyTrends GROUP BY Country;", "generated_sql": "SELECT Country, COUNT(DISTINCT OrgID) AS num_orgs FROM PhilanthropyTrends GROUP BY country ORDER BY num_orgs DESC NULLS LAST;", "raw_model_output": " Code\n<s> #_of_orgs = SELECT Country, COUNT(DISTINCT OrgID) AS num_orgs FROM PhilanthropyTrends GROUP BY country ORDER BY num_orgs DESC NULLS LAST;", "latency_sec": 0.811600923538208, "total_duration_sec": 0.609997189, "load_duration_sec": 0.009268161, "tokens_prompt": 56, "prompt_eval_sec": 0.006654648, "tokens_completion": 57, "completion_eval_sec": 0.5935449, "tokens_total": 113, "tokens_per_sec": 139.23098991481157, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries group by Country and count distinct OrgID. The generated query adds an ORDER BY clause, but semantic equivalence focuses on the data returned, not the order. Column aliases differ but do not affect the result. The GROUP BY case sensitivity depends on database settings, but assuming case-insensitive handling, the queries are equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent due to the additional ORDER BY clause in the generated query, which affects result ordering. Both correctly count unique organizations per country, fulfilling the business intent. The reference query is more elegant and directly addresses the question without unnecessary sorting. The generated query's ORDER BY introduces a non-essential modification that could impact performance and deviates from the original request.", "overall_assessment": "differently_correct"}}
{"example_id": 1006, "sql_complexity": "subqueries", "prompt": "What is the average word count of news articles written by investigative journalists?", "context": "CREATE TABLE reporters (id INT, name VARCHAR(50), gender VARCHAR(10), age INT, position VARCHAR(20), country VARCHAR(50)); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (1, 'Anna Smith', 'Female', 35, 'News Reporter', 'USA'); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (2, 'Mike Johnson', 'Male', 40, 'Investigative Journalist', 'Canada'); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (3, 'Sofia Rodriguez', 'Female', 32, 'Investigative Journalist', 'Mexico'); CREATE TABLE news_articles (id INT, title VARCHAR(100), content TEXT, publication_date DATE, reporter_id INT); INSERT INTO news_articles (id, title, content, publication_date, reporter_id) VALUES (1, 'News Article 1', 'Content of News Article 1', '2021-01-01', 2); INSERT INTO news_articles (id, title, content, publication_date, reporter_id) VALUES (2, 'News Article 2', 'Content of News Article 2', '2021-02-01', 3);", "reference_sql": "SELECT AVG(LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1) AS avg_word_count FROM news_articles WHERE reporter_id IN (SELECT id FROM reporters WHERE position = 'Investigative Journalist');", "generated_sql": "SELECT AVG(length(content)) AS average_word_count FROM news_articles WHERE reporter_id IN (SELECT id FROM reporters WHERE position ilike '%Investigative%Journalist%');", "raw_model_output": " Code\n<s> SELECT AVG(length(content)) AS average_word_count FROM news_articles WHERE reporter_id IN (SELECT id FROM reporters WHERE position ilike '%Investigative%Journalist%');", "latency_sec": 0.8218159675598145, "total_duration_sec": 0.618419995, "load_duration_sec": 0.010403061, "tokens_prompt": 369, "prompt_eval_sec": 0.022463158, "tokens_completion": 48, "completion_eval_sec": 0.584620095, "tokens_total": 417, "tokens_per_sec": 507.41287156804896, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. 1) The calculation method: the Reference SQL calculates average word count by measuring the number of spaces in the content, while the Generated SQL calculates the average length of the content (number of characters). 2) The WHERE clause uses different conditions for filtering reporters: the Reference uses exact string matching, while the Generated SQL uses a case-insensitive partial match. These differences will lead to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly calculates word count by estimating words through space counting (LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1), while the Generated SQL incorrectly uses LENGTH(content) which measures characters instead of words. The Reference properly filters investigative journalists with an exact match ('Investigative Journalist') whereas the Generated SQL uses a case-insensitive wildcard search ('%Investigative%Journalist%') that might include unintended positions. The Reference accurately addresses the business intent of measuring word count, while the Generated SQL fundamentally misunderstands the metric. Although the Generated SQL is more efficient, its semantic error makes it incorrect.", "overall_assessment": "incorrect"}}
{"example_id": 3635, "sql_complexity": "set operations", "prompt": "Which brands have certifications related to cruelty-free, vegan, or organic products?", "context": "CREATE TABLE brands (brand_name VARCHAR(50), is_cruelty_free BOOLEAN, is_vegan BOOLEAN, is_organic BOOLEAN); INSERT INTO brands (brand_name, is_cruelty_free, is_vegan, is_organic) VALUES ('Lush', TRUE, TRUE, FALSE), ('The Body Shop', TRUE, FALSE, FALSE), ('Est\u00e9e Lauder', FALSE, FALSE, FALSE), ('Urban Decay', TRUE, TRUE, FALSE), ('Maybelline', FALSE, FALSE, FALSE), ('Kat Von D', TRUE, TRUE, FALSE), ('Tarte', TRUE, TRUE, TRUE);", "reference_sql": "SELECT brand_name, 'Cruelty-free' as certification FROM brands WHERE is_cruelty_free = TRUE UNION SELECT brand_name, 'Vegan' as certification FROM brands WHERE is_vegan = TRUE UNION SELECT brand_name, 'Organic' as certification FROM brands WHERE is_organic = TRUE;", "generated_sql": "Code\n<s> QUERY brands WHERE is_cruelty_free = TRUE AND is_vegan = TRUE AND is_organic = TRUE;", "raw_model_output": " Code\n<s> QUERY brands WHERE is_cruelty_free = TRUE AND is_vegan = TRUE AND is_organic = TRUE;", "latency_sec": 0.6044516563415527, "total_duration_sec": 0.404384635, "load_duration_sec": 0.008218506, "tokens_prompt": 189, "prompt_eval_sec": 0.011606902, "tokens_completion": 34, "completion_eval_sec": 0.383736058, "tokens_total": 223, "tokens_per_sec": 368.9294216674148, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns brands that meet any of the three certifications (Cruelty-free, Vegan, Organic) as separate rows, while the Generated SQL only returns brands that satisfy all three conditions simultaneously (is_cruelty_free = TRUE AND is_vegan = TRUE AND is_organic = TRUE). The Generated SQL is overly restrictive and does not match the UNION logic of the Reference SQL.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly uses three separate SELECT statements with UNION to identify brands with any of the certifications (cruelty-free, vegan, or organic). The generated query incorrectly requires all three certification flags (is_cruelty_free, is_vegan, is_organic) to be TRUE simultaneously, which is not what the question asks. The original question seeks brands with *any* of these certifications, not brands that satisfy all three. The generated query would only return brands that are simultaneously cruelty-free, vegan, and organic, which is a stricter condition than intended. The reference query properly addresses the business intent by returning all brands with at least one relevant certification.", "overall_assessment": "incorrect"}}
{"example_id": 4932, "sql_complexity": "basic SQL", "prompt": "Delete the workout row with the id of 2.", "context": "CREATE TABLE Workouts (id INT, user_id INT, workout_name TEXT, calories INT); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (1, 1, 'Running', 300); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (2, 1, 'Cycling', 400); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (3, 2, 'Yoga', 200);", "reference_sql": "DELETE FROM Workouts WHERE id = 2;", "generated_sql": "DELETE FROM Workouts WHERE id = 2;", "raw_model_output": " Code\nDELETE FROM Workouts WHERE id = 2;", "latency_sec": 0.4773571491241455, "total_duration_sec": 0.175510666, "load_duration_sec": 0.008097247, "tokens_prompt": 160, "prompt_eval_sec": 0.010151223, "tokens_completion": 13, "completion_eval_sec": 0.15670001, "tokens_total": 173, "tokens_per_sec": 362.4120856206307, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They both delete the record from the Workouts table where the id is 2. The SQL syntax, table name, and WHERE condition are exactly the same in both queries.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical: DELETE FROM Workouts WHERE id = 2;. They correctly target the specific workout row with id=2 as required. The syntax is valid, the logic is sound, and the query directly addresses the business intent of deleting a specific workout. Since the reference and generated queries are exactly the same, neither is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 365, "sql_complexity": "aggregation", "prompt": "Identify the total number of military personnel and their corresponding rank for each branch and country in the 'military_personnel' table, sorted by the total number of personnel in descending order.", "context": "CREATE TABLE military_personnel (id INT, branch VARCHAR(255), rank VARCHAR(255), country VARCHAR(255), personnel INT);", "reference_sql": "SELECT branch, country, SUM(personnel) as total_personnel FROM military_personnel GROUP BY branch, country ORDER BY total_personnel DESC;", "generated_sql": "SELECT military_personnel.branch, military_personnel.country, SUM(military_personnel.personnel) AS total_personnel, rank FROM military_personnel GROUP BY military_personnel.branch, military_personnel.country ORDER BY total_personnel DESC;", "raw_model_output": " Code\n<s> #\nSELECT military_personnel.branch, military_personnel.country, SUM(military_personnel.personnel) AS total_personnel, rank FROM military_personnel GROUP BY military_personnel.branch, military_personnel.country ORDER BY total_personnel DESC;", "latency_sec": 1.0788779258728027, "total_duration_sec": 0.781578052, "load_duration_sec": 0.008340846, "tokens_prompt": 94, "prompt_eval_sec": 0.00997526, "tokens_completion": 72, "completion_eval_sec": 0.762428282, "tokens_total": 166, "tokens_per_sec": 153.86356140868065, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The generated query includes an additional 'rank' column in the SELECT clause that is not present in the reference query. While both queries group by branch and country and calculate the same SUM, the presence of the unaggregated 'rank' column in the generated query makes it invalid in standard SQL (as 'rank' is not in the GROUP BY clause or an aggregate function). Even if allowed by some databases, the result sets differ in column structure, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query is technically correct and aligns with the business intent. It groups by branch and country, sums personnel, and orders by total, which directly answers the request for total personnel per branch/country. The generated query includes 'rank' in the SELECT and GROUP BY clauses, which introduces two issues: 1) 'rank' is not aggregated, leading to SQL syntax errors in standard SQL (though MySQL might allow it with non-standard settings), and 2) grouping by 'rank' would split results by rank within branches/countries, contradicting the original question's requirement to aggregate across all ranks. While the generated query attempts to include rank, it fails technically and semantically. The reference query correctly focuses on the required aggregation without introducing invalid elements.", "overall_assessment": "correct"}}
{"example_id": 521, "sql_complexity": "subqueries", "prompt": "How many vessels have not had an inspection in the past year?", "context": "CREATE TABLE safety_records(id INT, vessel_name VARCHAR(50), inspection_date DATE); CREATE TABLE vessels(id INT, name VARCHAR(50), country VARCHAR(50)); INSERT INTO vessels(id, name, country) VALUES (1, 'Vessel A', 'Philippines'), (2, 'Vessel B', 'Philippines'); INSERT INTO safety_records(id, vessel_name, inspection_date) VALUES (1, 'Vessel A', '2022-01-01');", "reference_sql": "SELECT COUNT(*) FROM vessels WHERE name NOT IN (SELECT vessel_name FROM safety_records WHERE inspection_date BETWEEN DATE_SUB(NOW(), INTERVAL 1 YEAR) AND NOW());", "generated_sql": "SELECT COUNT(DISTINCT v.id) AS num_vessels_without_inspection FROM vessels v LEFT JOIN safety_records sr ON v.name = sr.vessel_name AND sr.inspection_date > CURRENT_DATE - interval '1 year' WHERE sr.id IS NULL;", "raw_model_output": " Code\n<s> SELECT COUNT(DISTINCT v.id) AS num_vessels_without_inspection FROM vessels v LEFT JOIN safety_records sr ON v.name = sr.vessel_name AND sr.inspection_date > CURRENT_DATE - interval '1 year' WHERE sr.id IS NULL;", "latency_sec": 0.9643950462341309, "total_duration_sec": 0.905238942, "load_duration_sec": 0.008242927, "tokens_prompt": 162, "prompt_eval_sec": 0.012379595, "tokens_completion": 81, "completion_eval_sec": 0.883918781, "tokens_total": 243, "tokens_per_sec": 251.9714311566525, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their date condition handling. The Reference SQL uses BETWEEN (inclusive) for the inspection_date, while the Generated SQL uses > (exclusive). This means the Generated SQL excludes inspections exactly one year prior to the current date, whereas the Reference SQL includes them. Additionally, the Generated SQL uses a LEFT JOIN with a date filter in the ON clause, which may not fully align with the NOT IN subquery logic in edge cases.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries differ in their date range logic. The reference query uses BETWEEN with DATE_SUB(NOW(), INTERVAL 1 YEAR) to include the exact date one year ago, while the generated query uses > CURRENT_DATE - interval '1 year' which excludes that specific date. This creates a one-day discrepancy in the inspection date window. Both queries correctly identify vessels without inspections in the past year, but the reference's approach is more precise for a 'past year' definition (365 days). The generated query's LEFT JOIN is more efficient but the date condition makes them technically non-equivalent. Both fulfill the business intent, but the reference is more accurate for the question's phrasing.", "overall_assessment": "differently_correct"}}
{"example_id": 5687, "sql_complexity": "multiple_joins", "prompt": "List organizations with more than 200 volunteers, and their average donation amounts, excluding donations less than $10.", "context": "CREATE TABLE organizations (org_id INT, org_name TEXT, social_impact_score INT);CREATE TABLE volunteers (vol_id INT, org_id INT, vol_country TEXT);CREATE TABLE donations (donation_id INT, donor_id INT, donation_amount INT, donation_date DATE);", "reference_sql": "SELECT o.org_name, AVG(donation_amount) AS avg_donation_amount FROM organizations o JOIN volunteers v ON o.org_id = v.org_id JOIN donations don ON o.org_id = don.org_id WHERE donation_amount >= 10 GROUP BY o.org_name HAVING COUNT(v.vol_id) > 200;", "generated_sql": "SELECT COUNT(volunteer_id) FROM volunteers WHERE org_id = organization_id);", "raw_model_output": " Code\n<s> #_of_volunteers = (SELECT COUNT(volunteer_id) FROM volunteers WHERE org_id = organization_id); SELECT organizations.org_id, AVG(donations.donation_amount) AS average_donation_amount FROM organizations JOIN volunteers ON organizations.org_id = volunteers.org_id JOIN donations ON volunteers.vol_id = donations.donor_id WHERE number_of_volunteers > 200 AND donations.donation_amount >= 10 GROUP BY organizations.org_id;", "latency_sec": 1.6083381175994873, "total_duration_sec": 1.408755273, "load_duration_sec": 0.008477485, "tokens_prompt": 116, "prompt_eval_sec": 0.007466025, "tokens_completion": 130, "completion_eval_sec": 1.392095336, "tokens_total": 246, "tokens_per_sec": 152.9529128907082, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates average donations and filters organizations with >200 volunteers, while the Generated SQL attempts to count volunteers but has invalid syntax (undefined 'organization_id') and lacks necessary joins/aggregation. The schema, logic, and output columns differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference SQL correctly joins organizations, volunteers, and donations tables, filters donations >= $10, groups by organization, and calculates average donations while checking volunteer counts. The generated SQL is syntactically invalid (missing FROM clause, incorrect column name 'organization_id' instead of 'org_id'), fails to calculate averages, and doesn't address the volunteer count requirement. While the reference query could be improved by grouping on org_id instead of org_name, it still technically fulfills the business intent whereas the generated query does not.", "overall_assessment": "incorrect"}}
{"example_id": 1281, "sql_complexity": "subqueries", "prompt": "Find the top 3 contributors with the lowest recycling rate in the 'waste_contributors' table.", "context": "CREATE TABLE waste_contributors (contributor VARCHAR(20), recycling_rate FLOAT); INSERT INTO waste_contributors (contributor, recycling_rate) VALUES ('Manufacturing', 0.4), ('Commercial', 0.38), ('Residential', 0.35), ('Institutional', 0.32), ('Agricultural', 0.2), ('Industrial', 0.15);", "reference_sql": "SELECT contributor FROM waste_contributors WHERE recycling_rate IN (SELECT MIN(recycling_rate) FROM waste_contributors) LIMIT 3;", "generated_sql": "SELECT contributor, recycling_rate FROM waste_contributors ORDER BY recycling_rate ASC NULLS LAST LIMIT 3;", "raw_model_output": " Code\nSELECT contributor, recycling_rate FROM waste_contributors ORDER BY recycling_rate ASC NULLS LAST LIMIT 3;", "latency_sec": 0.5039980411529541, "total_duration_sec": 0.407791634, "load_duration_sec": 0.009310496, "tokens_prompt": 150, "prompt_eval_sec": 0.010330806, "tokens_completion": 35, "completion_eval_sec": 0.387623894, "tokens_total": 185, "tokens_per_sec": 367.0649186984755, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL selects contributors with the minimum recycling rate (only 'Industrial'), while the Generated SQL returns the top 3 contributors with the lowest recycling rates (Industrial, Agricultural, Institutional). Additionally, the Generated SQL includes the recycling_rate column in the output, whereas the Reference SQL does not.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query incorrectly uses WHERE recycling_rate IN (SELECT MIN(...)) which only returns contributors with the absolute minimum recycling rate (e.g., 'Industrial' in sample data), not the top 3 lowest rates. The generated query properly orders by recycling_rate ASC and LIMITs to 3, correctly identifying the three lowest values (0.15, 0.2, 0.32). While both queries avoid NULLs, the generated version directly addresses the 'top 3' requirement through ordering, whereas the reference query's logic is fundamentally misaligned with the question's intent.", "overall_assessment": "differently_correct"}}
{"example_id": 5669, "sql_complexity": "window functions", "prompt": "What is the total number of new and returning volunteers in each program in each month?", "context": "CREATE TABLE Volunteers (VolunteerID INT, VolunteerName TEXT, ProgramID INT, VolunteerDate DATE, IsReturning BOOLEAN); INSERT INTO Volunteers (VolunteerID, VolunteerName, ProgramID, VolunteerDate, IsReturning) VALUES (6, 'David Kim', 1, '2022-03-01', FALSE), (7, 'Emily Chen', 2, '2022-03-15', TRUE), (8, 'James Lee', 2, '2022-04-01', FALSE), (9, 'Grace Park', 3, '2022-04-15', TRUE), (10, 'Daniel Kim', 1, '2022-04-01', FALSE);", "reference_sql": "SELECT ProgramID, EXTRACT(MONTH FROM VolunteerDate) AS Month, SUM(CASE WHEN IsReturning THEN 1 ELSE 0 END) OVER (PARTITION BY ProgramID, EXTRACT(MONTH FROM VolunteerDate) ORDER BY ProgramID, EXTRACT(MONTH FROM VolunteerDate)) + COUNT(DISTINCT VolunteerID) OVER (PARTITION BY ProgramID, EXTRACT(MONTH FROM VolunteerDate) ORDER BY ProgramID, EXTRACT(MONTH FROM VolunteerDate)) AS TotalVolunteers FROM Volunteers;", "generated_sql": "SELECT p.ProgramName, to_char(to_date(v.volunteerdate::text, 'YYYY-MM-DD'), 'Month') AS MONTH, COUNT(*) filter (WHERE isreturning = TRUE) AS returning_volunteers, COUNT(*) filter (WHERE isreturning = FALSE) AS new_volunteers FROM volunteers v JOIN programs p ON v.programid = p.programid GROUP BY p.programname, MONTH;", "raw_model_output": " Code\n<s> SELECT p.ProgramName, to_char(to_date(v.volunteerdate::text, 'YYYY-MM-DD'), 'Month') AS MONTH, COUNT(*) filter (WHERE isreturning = TRUE) AS returning_volunteers, COUNT(*) filter (WHERE isreturning = FALSE) AS new_volunteers FROM volunteers v JOIN programs p ON v.programid = p.programid GROUP BY p.programname, MONTH;", "latency_sec": 1.5651628971099854, "total_duration_sec": 1.263219501, "load_duration_sec": 0.010485874, "tokens_prompt": 228, "prompt_eval_sec": 0.012860858, "tokens_completion": 113, "completion_eval_sec": 1.239128639, "tokens_total": 341, "tokens_per_sec": 217.86869636997127, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in multiple aspects. 1) The Reference SQL uses ProgramID while the Generated SQL uses ProgramName. 2) The Reference SQL calculates a 'TotalVolunteers' by summing a returning volunteer count and a distinct volunteer count, while the Generated SQL separates returning and new volunteers. 3) The Reference SQL uses window functions that may produce duplicate rows with the same values for each group, while the Generated SQL groups and aggregates data, producing a single row per group. 4) The month formatting differs (numeric vs. textual). These differences in structure, calculation, and output mean the queries are not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL has multiple issues: 1) Missing GROUP BY clause, leading to incorrect aggregation; 2) Incorrect use of window functions that would produce duplicate/incorrect totals; 3) Combines returning counts with total volunteers in a way that doesn't align with the question's requirement for separate new/returning counts. The Generated SQL correctly separates new and returning volunteers using COUNT(*) FILTER, groups by program and month, and joins with programs table for program names. However, it doesn't explicitly calculate the total (new + returning) but provides the necessary components to derive it.", "overall_assessment": "differently_correct"}}
{"example_id": 3576, "sql_complexity": "window functions", "prompt": "What is the difference in the number of eco-friendly hotels between the top 2 countries?", "context": "CREATE TABLE eco_hotel_count (country TEXT, num_hotels INT); INSERT INTO eco_hotel_count (country, num_hotels) VALUES ('France', 100), ('Italy', 120), ('Germany', 150), ('Spain', 110), ('UK', 160);", "reference_sql": "SELECT (MAX(num_hotels) OVER (PARTITION BY num_hotels <= 2) - MIN(num_hotels) OVER (PARTITION BY num_hotels <= 2)) AS hotel_difference FROM eco_hotel_count WHERE country IN ('France', 'Italy');", "generated_sql": "SELECT (germany.num_hotels - spain.num_hotels) AS diff_hotels FROM eco_hotel_count AS france, ecotel_count AS germany, ecotel_count AS spain WHERE france.country = 'France' AND germany.country = 'Germany' AND spain.country = 'Spain';", "raw_model_output": " Code\n<s> SELECT (germany.num_hotels - spain.num_hotels) AS diff_hotels FROM eco_hotel_count AS france, ecotel_count AS germany, ecotel_count AS spain WHERE france.country = 'France' AND germany.country = 'Germany' AND spain.country = 'Spain';", "latency_sec": 0.9848370552062988, "total_duration_sec": 0.967275651, "load_duration_sec": 0.010827405, "tokens_prompt": 123, "prompt_eval_sec": 0.007822895, "tokens_completion": 89, "completion_eval_sec": 0.948083107, "tokens_total": 212, "tokens_per_sec": 215.26403670462145, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the difference between max and min num_hotels for countries France and Italy (values 120 and 100, resulting in 20). The Generated SQL subtracts Germany's (150) and Spain's (110) values (resulting in 40). The queries operate on different data subsets and perform different calculations, producing distinct results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL is technically valid but semantically incorrect. It incorrectly filters to France and Italy (not the top 2 countries) and uses flawed window function logic (PARTITION BY num_hotels <= 2, which is nonsensical). The Generated SQL has a critical syntax error (table name typo: ecotel_count instead of eco_hotel_count) and incorrectly subtracts Germany and Spain (not the top 2 countries). Neither query identifies the actual top 2 countries (UK and Germany) to calculate the correct difference (160-150=10). The Reference SQL is more structurally valid, but both fail to fulfill the business intent.", "overall_assessment": "incorrect"}}
{"example_id": 1970, "sql_complexity": "multiple_joins", "prompt": "List all players who have played a specific VR game, 'CyberSphere', and their ages.", "context": "CREATE TABLE Players (PlayerID INT, Age INT, Gender VARCHAR(10), Country VARCHAR(50)); CREATE TABLE VRPlayers (PlayerID INT, VRGameID INT); CREATE TABLE VRGames (VRGameID INT, Title VARCHAR(50)); INSERT INTO Players (PlayerID, Age, Gender, Country) VALUES (1, 25, 'Male', 'USA'); INSERT INTO Players (PlayerID, Age, Gender, Country) VALUES (2, 28, 'Female', 'Canada'); INSERT INTO VRPlayers (PlayerID, VRGameID) VALUES (1, 1); INSERT INTO VRPlayers (PlayerID, VRGameID) VALUES (2, 1); INSERT INTO VRGames (VRGameID, Title) VALUES (1, 'CyberSphere');", "reference_sql": "SELECT Players.Age, Players.PlayerID FROM Players INNER JOIN VRPlayers ON Players.PlayerID = VRPlayers.PlayerID INNER JOIN VRGames ON VRPlayers.VRGameID = VRGames.VRGameID WHERE VRGames.Title = 'CyberSphere';", "generated_sql": "SELECT p.Playerid, p.age FROM players p JOIN vrplayers v ON p.playerid = v.playerid WHERE v.vrgameid IN (SELECT vrgameid FROM virtual_reality WHERE title ILIKE '%cyber%sphere%');", "raw_model_output": " Code\n<s> SELECT p.Playerid, p.age FROM players p JOIN vrplayers v ON p.playerid = v.playerid WHERE v.vrgameid IN (SELECT vrgameid FROM virtual_reality WHERE title ILIKE '%cyber%sphere%');", "latency_sec": 0.8526990413665771, "total_duration_sec": 0.754003918, "load_duration_sec": 0.010732957, "tokens_prompt": 252, "prompt_eval_sec": 0.015049977, "tokens_completion": 64, "completion_eval_sec": 0.727375303, "tokens_total": 316, "tokens_per_sec": 370.58796207107605, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in several key aspects. 1) The generated query references a table 'virtual_reality' which doesn't exist in the schema (the correct table is 'VRGames'). 2) The generated query uses a case-insensitive LIKE operator with wildcards, while the reference uses an exact match. 3) The generated query uses a subquery to find VRGameIDs, while the reference uses an explicit JOIN. 4) The generated query has a typo in the column name 'vrgameid' (should be 'VRGameID'). These differences mean the queries will not produce the same results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query is technically correct and directly addresses the business intent. It properly joins Players, VRPlayers, and VRGames tables with explicit conditions on VRGames.Title = 'CyberSphere'. The generated query has multiple issues: 1) It references a non-existent table 'virtual_reality' instead of 'VRGames' 2) Uses lowercase table/column names conflicting with the schema's capitalization 3) Employs ILIKE which is PostgreSQL-specific and not standard SQL 4) The subquery structure is unnecessarily complex. While both queries aim to retrieve player ages, the generated query would fail due to schema inconsistencies and contains logical flaws that make it technically incorrect.", "overall_assessment": "correct"}}
{"example_id": 2414, "sql_complexity": "window functions", "prompt": "List the policy areas with the lowest citizen satisfaction scores.", "context": "CREATE TABLE Policy (Area VARCHAR(20), Score INT); INSERT INTO Policy (Area, Score) VALUES ('Transportation', 70), ('Education', 85), ('Healthcare', 75), ('PublicSafety', 80);", "reference_sql": "SELECT Area, Score FROM (SELECT Area, Score, ROW_NUMBER() OVER (ORDER BY Score) AS RN FROM Policy) X WHERE RN IN (1, 2);", "generated_sql": "SELECT area FROM Policy ORDER BY score ASC;", "raw_model_output": " Code\nSELECT area FROM Policy ORDER BY score ASC;", "latency_sec": 0.3730318546295166, "total_duration_sec": 0.170212064, "load_duration_sec": 0.009290112, "tokens_prompt": 90, "prompt_eval_sec": 0.006402601, "tokens_completion": 14, "completion_eval_sec": 0.153899338, "tokens_total": 104, "tokens_per_sec": 278.79656578736285, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns the top 2 rows (by Score) with both Area and Score columns, while the Generated SQL returns all rows with only the Area column, ordered by Score. The Generated SQL lacks the Score column and does not limit the result set to 2 rows.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly identifies the top 2 lowest scores using ROW_NUMBER() and explicitly limits results, while the Generated SQL returns all areas ordered by score without filtering. The original question asks for 'lowest' scores (implying a subset), but the Generated SQL provides a full list. The Reference SQL better fulfills the intent by isolating the lowest scores, though neither handles ties. The Generated SQL fails to limit results, making it less precise for the business question.", "overall_assessment": "differently_correct"}}
{"example_id": 1898, "sql_complexity": "single join", "prompt": "What are the total sales for each drug in Q2 2020?", "context": "CREATE TABLE drugs (drug_id INT, drug_name TEXT); INSERT INTO drugs (drug_id, drug_name) VALUES (1001, 'Ibuprofen'), (1002, 'Paracetamol'), (1003, 'Aspirin'); CREATE TABLE sales (sale_id INT, drug_id INT, sale_date DATE, revenue FLOAT); INSERT INTO sales (sale_id, drug_id, sale_date, revenue) VALUES (1, 1001, '2020-04-05', 1800.0), (2, 1002, '2020-04-10', 2300.0), (3, 1003, '2020-04-15', 1400.0), (4, 1001, '2020-05-20', 1900.0), (5, 1002, '2020-06-25', 2400.0);", "reference_sql": "SELECT drug_name, SUM(revenue) as total_sales FROM sales JOIN drugs ON sales.drug_id = drugs.drug_id WHERE sale_date BETWEEN '2020-04-01' AND '2020-06-30' GROUP BY drug_name;", "generated_sql": "SELECT d.drug_name, SUM(s.revenue) AS total_revenue FROM drugs d JOIN sales s ON d.drug_id = s.drug_id WHERE date_part('year', sale_date) = 2020 AND date_part('quarter', sale_date) = 2 GROUP BY d.drug_name;", "raw_model_output": " Code\n<s> SELECT d.drug_name, SUM(s.revenue) AS total_revenue FROM drugs d JOIN sales s ON d.drug_id = s.drug_id WHERE date_part('year', sale_date) = 2020 AND date_part('quarter', sale_date) = 2 GROUP BY d.drug_name;", "latency_sec": 1.1412642002105713, "total_duration_sec": 1.061113286, "load_duration_sec": 0.009059046, "tokens_prompt": 301, "prompt_eval_sec": 0.019215286, "tokens_completion": 90, "completion_eval_sec": 1.03192967, "tokens_total": 391, "tokens_per_sec": 342.6025279053332, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate total sales per drug within the same date range. The Reference SQL uses BETWEEN '2020-04-01' AND '2020-06-30' (April-June 2020), while the Generated SQL filters WHERE date_part('year', sale_date) = 2020 AND date_part('quarter', sale_date) = 2 (Q2 2020), which corresponds to the same period. The JOIN logic, grouping, and aggregation are identical, with only column aliases differing (total_sales vs. total_revenue).", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries correctly calculate total sales per drug for Q2 2020. The reference query uses a simple date range (BETWEEN '2020-04-01' AND '2020-06-30') which directly captures Q2 dates. The generated query uses date_part() functions to filter year=2020 and quarter=2, which also correctly identifies Q2 dates. Both produce identical results for the sample data. However, the reference query is more efficient as it allows for potential index usage on sale_date, while the generated query applies functions to the date column. The reference is also more readable and aligns with standard date filtering practices.", "overall_assessment": "correct"}}
{"example_id": 2403, "sql_complexity": "multiple_joins", "prompt": "Who is the most frequent customer ordering vegetarian items?", "context": "CREATE TABLE customers (customer_id INT, customer_name VARCHAR(50)); INSERT INTO customers VALUES (1, 'John Doe'), (2, 'Jane Smith'), (3, 'Alice Johnson'); CREATE TABLE orders (order_id INT, customer_id INT, menu_id INT, order_date DATE); INSERT INTO orders VALUES (1, 1, 1, '2022-01-01'), (2, 2, 3, '2022-01-02'), (3, 3, 2, '2022-01-03'); CREATE TABLE menu (menu_id INT, item_name VARCHAR(50), is_vegetarian BOOLEAN, price DECIMAL(5,2)); INSERT INTO menu VALUES (1, 'Veggie Burger', true, 8.99), (2, 'Cheeseburger', false, 7.99), (3, 'Tofu Stir Fry', true, 11.99);", "reference_sql": "SELECT customers.customer_name, COUNT(orders.order_id) as order_count FROM customers INNER JOIN orders ON customers.customer_id = orders.customer_id INNER JOIN menu ON orders.menu_id = menu.menu_id WHERE menu.is_vegetarian = true GROUP BY customers.customer_name ORDER BY order_count DESC LIMIT 1;", "generated_sql": "SELECT customers.customer_name, COUNT(orders.order_id) AS order_count FROM orders JOIN menu ON orders.menu_id = menu.menu_id JOIN customers ON orders.customer_id = customers.customer_id WHERE menu.is_vegetarian = TRUE GROUP BY customers.customer_name ORDER BY order_count DESC LIMIT 1;", "raw_model_output": " Code\n<s> SELECT customers.customer_name, COUNT(orders.order_id) AS order_count FROM orders JOIN menu ON orders.menu_id = menu.menu_id JOIN customers ON orders.customer_id = customers.customer_id WHERE menu.is_vegetarian = TRUE GROUP BY customers.customer_name ORDER BY order_count DESC LIMIT 1;", "latency_sec": 1.1332981586456299, "total_duration_sec": 1.033186415, "load_duration_sec": 0.008878646, "tokens_prompt": 280, "prompt_eval_sec": 0.020902079, "tokens_completion": 88, "completion_eval_sec": 1.002514979, "tokens_total": 368, "tokens_per_sec": 324.7159603963229, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the customer with the highest order count for vegetarian menu items. They use equivalent JOIN logic (INNER JOIN vs. JOIN), same ON conditions, WHERE clause (case-insensitive boolean comparison), GROUP BY, ORDER BY, and LIMIT. The semantic result is identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly identify the most frequent customer ordering vegetarian items by joining customers, orders, and menu tables with appropriate filters. The reference query starts with customers and sequentially joins orders/menu, while the generated query starts with orders and joins menu/customers. The order of joins does not affect the result set. Both use COUNT(orders.order_id) with GROUP BY customer_name, WHERE menu.is_vegetarian = true, and ORDER BY count DESC LIMIT 1. The semantic meaning and technical execution are identical, making them functionally equivalent. Neither query has efficiency advantages over the other in this context.", "overall_assessment": "correct"}}
{"example_id": 124, "sql_complexity": "set operations", "prompt": "Find the intersection of AI and accessibility research projects in the EU and those in Africa.", "context": "CREATE SCHEMA if not exists accessibility; CREATE TABLE if not exists accessibility.research (id INT PRIMARY KEY, project_name VARCHAR(255), region VARCHAR(255)); INSERT INTO accessibility.research (id, project_name, region) VALUES (1, 'AI for Accessibility EU', 'EU'), (2, 'Accessibility Africa', 'Africa'), (3, 'AI for Accessibility Africa', 'Africa'), (4, 'Accessibility EU', 'EU');", "reference_sql": "SELECT project_name FROM accessibility.research WHERE region = 'EU' INTERSECT SELECT project_name FROM accessibility.research WHERE region = 'Africa';", "generated_sql": "SELECT DISTINCT project_name FROM accessibility.research WHERE region IN ('EU', 'Africa') AND project_name ILIKE '%AI%';", "raw_model_output": " code to execute\n<s> QUERY SELECT DISTINCT project_name FROM accessibility.research WHERE region IN ('EU', 'Africa') AND project_name ILIKE '%AI%';", "latency_sec": 0.6155967712402344, "total_duration_sec": 0.53001129, "load_duration_sec": 0.009517254, "tokens_prompt": 156, "prompt_eval_sec": 0.01033495, "tokens_completion": 46, "completion_eval_sec": 0.509580824, "tokens_total": 202, "tokens_per_sec": 328.1368737412858, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL finds project names present in both 'EU' and 'Africa' regions (intersection), while the Generated SQL selects distinct project names from either region containing 'AI' in their name. The Reference query returns no rows (no overlapping project names between regions), whereas the Generated query returns two rows ('AI for Accessibility EU' and 'AI for Accessibility Africa'). The logical operations and result sets differ fundamentally.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly identifies projects present in both EU and Africa regions using INTERSECT, but it fails to filter for AI/accessibility keywords. The Generated SQL incorrectly finds projects in either region with 'AI' but lacks the intersection logic. Neither query fully meets the business intent of finding projects that are both in both regions and related to AI/accessibility. However, the Reference SQL better addresses the 'intersection' aspect of the question, while the Generated SQL misinterprets the requirement as a union with a keyword filter.", "overall_assessment": "differently_correct"}}
{"example_id": 1231, "sql_complexity": "basic SQL", "prompt": "What is the average ticket price for performances at the 'Downtown Theater'?", "context": "CREATE TABLE DowntownTheater (show_name TEXT, date DATE, ticket_price FLOAT); INSERT INTO DowntownTheater (show_name, date, ticket_price) VALUES ('Play 1', '2022-01-01', 30.0), ('Play 2', '2022-01-02', 40.0), ('Concert 1', '2022-01-03', 50.0);", "reference_sql": "SELECT AVG(ticket_price) FROM DowntownTheater WHERE show_name = 'Downtown Theater'", "generated_sql": "SELECT AVG(ticket_price) FROM DowntownTheater;", "raw_model_output": " Code\nSELECT AVG(ticket_price) FROM DowntownTheater;", "latency_sec": 0.4423229694366455, "total_duration_sec": 0.24086904, "load_duration_sec": 0.00859712, "tokens_prompt": 152, "prompt_eval_sec": 0.011143389, "tokens_completion": 19, "completion_eval_sec": 0.220430661, "tokens_total": 171, "tokens_per_sec": 386.59534280525884, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters for show_name = 'Downtown Theater' which doesn't exist in the sample data (all rows have show_names like 'Play 1', 'Play 2', 'Concert 1'), resulting in an empty set and NULL average. The Generated SQL calculates the average of all ticket prices (30, 40, 50) which is 40.0. The WHERE clause in Reference SQL changes the dataset being aggregated, making the results different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query is incorrect because it filters on show_name = 'Downtown Theater', but the table contains shows like 'Play 1', 'Play 2', and 'Concert 1' - none of which match the theater name. The generated query correctly averages all ticket prices in the DowntownTheater table, which contains all performances at that venue. The original question's context implies the table itself represents the 'Downtown Theater' venue, making the WHERE clause unnecessary and erroneous.", "overall_assessment": "incorrect"}}
{"example_id": 1485, "sql_complexity": "set operations", "prompt": "How many public schools and public libraries exist in total, in the 'CityData' schema's 'CityEducation' and 'CityLibrary' tables?", "context": "CREATE SCHEMA CityData; CREATE TABLE CityEducation (Name varchar(255), Type varchar(255)); INSERT INTO CityEducation (Name, Type) VALUES ('SchoolA', 'Public'), ('SchoolB', 'Public'), ('SchoolC', 'Private'); CREATE TABLE CityLibrary (Name varchar(255), Type varchar(255)); INSERT INTO CityLibrary (Name, Type) VALUES ('LibraryA', 'Public'), ('LibraryB', 'Public'), ('LibraryC', 'Private');", "reference_sql": "SELECT COUNT(*) FROM CityData.CityEducation WHERE Type = 'Public' UNION ALL SELECT COUNT(*) FROM CityData.CityLibrary WHERE Type = 'Public';", "generated_sql": "SELECT COUNT(*) AS total_schools_and_libraries FROM CityData.CityEducation UNION ALLER SELECT COUNT(*) AS total_schools_and_libraries FROM CityData.CityLibrary;", "raw_model_output": " Code\n<s> QUERY SELECT COUNT(*) AS total_schools_and_libraries FROM CityData.CityEducation UNION ALLER SELECT COUNT(*) AS total_schools_and_libraries FROM CityData.CityLibrary;", "latency_sec": 0.8516159057617188, "total_duration_sec": 0.660220285, "load_duration_sec": 0.008005044, "tokens_prompt": 180, "prompt_eval_sec": 0.012418483, "tokens_completion": 58, "completion_eval_sec": 0.638874212, "tokens_total": 238, "tokens_per_sec": 279.4687116454494, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters both tables by Type = 'Public' before counting, while the Generated SQL lacks these filters and counts all entries in each table. This results in different numerical outputs (e.g., 2 public schools vs 3 total schools, 2 public libraries vs 3 total libraries). The typo 'UNION ALLER' is assumed to be a mistake for 'UNION ALL', but even with that correction, the missing WHERE clauses make the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly filters for 'Public' type in both tables, while the Generated SQL has a syntax error ('UNION ALLER') and omits the 'Public' filter. The Reference SQL returns two separate counts (schools and libraries) but fails to sum them, while the Generated SQL would return invalid results due to syntax and logic errors. Neither query fully answers the 'total' requirement, but the Reference is closer to the correct logic.", "overall_assessment": "differently_correct"}}
{"example_id": 5806, "sql_complexity": "single join", "prompt": "List the top 3 countries with the most veteran employment in the IT industry", "context": "CREATE TABLE veteran_employment (employee_id INT, industry VARCHAR(255), salary DECIMAL(10,2), state VARCHAR(2), country VARCHAR(255)); CREATE TABLE countries (country_id INT, country VARCHAR(255));", "reference_sql": "SELECT country, COUNT(*) as num_veterans FROM veteran_employment JOIN countries ON veteran_employment.country = countries.country WHERE industry = 'IT' GROUP BY country ORDER BY num_veterans DESC LIMIT 3;", "generated_sql": "Code\n<s> #_rank() OVER (PARTITION BY c.country_id ORDER BY COUNT(e.employee_id) DESC NULLS LAST) AS rank, c.country FROM country c JOIN veteran_employment e ON c.country_id = e.country WHERE industry = 'IT' GROUP BY c.country_id, c.country HAVING COUNT(e.employee_id) > 100000 ORDER BY rank NULLS LAST LIMIT 3;", "raw_model_output": " Code\n<s> #_rank() OVER (PARTITION BY c.country_id ORDER BY COUNT(e.employee_id) DESC NULLS LAST) AS rank, c.country FROM country c JOIN veteran_employment e ON c.country_id = e.country WHERE industry = 'IT' GROUP BY c.country_id, c.country HAVING COUNT(e.employee_id) > 100000 ORDER BY rank NULLS LAST LIMIT 3;", "latency_sec": 1.351189136505127, "total_duration_sec": 1.256296723, "load_duration_sec": 0.008396989, "tokens_prompt": 97, "prompt_eval_sec": 0.007655117, "tokens_completion": 117, "completion_eval_sec": 1.239268385, "tokens_total": 214, "tokens_per_sec": 158.3790116559955, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in several key aspects.  The Reference SQL doesn't include a HAVING clause, while the Generated SQL filters results to only include countries with more than 100,000 IT veterans.  Additionally, the join conditions differ: the Reference SQL joins on country names, while the Generated SQL joins on country_id.  The Generated SQL also uses a window function to rank results, which is not present in the Reference SQL.  These differences will lead to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The Reference SQL correctly addresses the original question by counting IT veteran employment per country and returning the top 3. The Generated SQL has several issues: 1) It adds a HAVING clause filtering for >100,000 veterans (not in original question), 2) It uses RANK() which is unnecessary for simple top 3 ranking, 3) It references 'country_id' which isn't in the original schema (though the join is valid). The Reference SQL is simpler, directly answers the question, and avoids unnecessary complexity. Both queries use similar core logic but the Generated SQL introduces irrelevant constraints and functions.", "overall_assessment": "correct"}}
{"example_id": 4126, "sql_complexity": "window functions", "prompt": "What is the average crime rate per capita in each neighborhood?", "context": "CREATE TABLE neighborhoods (name VARCHAR(255), population INT, crime_count INT); INSERT INTO neighborhoods (name, population, crime_count) VALUES ('Central Park', 1000, 25), ('Harlem', 2500, 75), ('Brooklyn', 5000, 120);", "reference_sql": "SELECT name, AVG(crime_count/population) OVER (PARTITION BY name) FROM neighborhoods;", "generated_sql": "SELECT name, (crime_count * 100.0 / population) AS crime_rate FROM neighborhoods;", "raw_model_output": " Code\nSELECT name, (crime_count * 100.0 / population) AS crime_rate FROM neighborhoods;", "latency_sec": 0.9204211235046387, "total_duration_sec": 0.333557973, "load_duration_sec": 0.009710306, "tokens_prompt": 114, "prompt_eval_sec": 0.00742389, "tokens_completion": 29, "completion_eval_sec": 0.315762683, "tokens_total": 143, "tokens_per_sec": 155.3636659874846, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the average of crime_count/population (which simplifies to crime_count/population due to single-row partitions), while the Generated SQL computes (crime_count * 100.0 / population). The latter introduces a 100x scaling factor, making the numerical results different. Although both calculate a crime rate, the scaling factor makes them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query incorrectly uses an analytic function (AVG() OVER) which is unnecessary since each neighborhood is a single row. This would return the same value as the raw crime_count/population ratio but with redundant computation. The generated query correctly calculates the crime rate per capita as (crime_count / population) * 100, which directly answers the question. While both queries return similar numerical results, the generated query is semantically correct and more efficient. The reference query fails to fulfill the business intent because it misuses window functions for a simple calculation.", "overall_assessment": "differently_correct"}}
{"example_id": 4559, "sql_complexity": "basic SQL", "prompt": "List the top 3 energy efficient appliances in the US by energy star rating?", "context": "CREATE TABLE appliances (id INT, name VARCHAR(255), country VARCHAR(255), energy_star_rating INT); INSERT INTO appliances (id, name, country, energy_star_rating) VALUES (1, 'Fridge A', 'USA', 5), (2, 'TV B', 'USA', 4), (3, 'Laptop C', 'USA', 5), (4, 'Microwave D', 'USA', 3);", "reference_sql": "SELECT name, energy_star_rating FROM appliances WHERE country = 'USA' ORDER BY energy_star_rating DESC LIMIT 3;", "generated_sql": "SELECT name, country, energy_star_rating FROM appliances WHERE country = 'USA' ORDER BY energy_star_rating DESC NULLS LAST LIMIT 3;", "raw_model_output": " Code\nSELECT name, country, energy_star_rating FROM appliances WHERE country = 'USA' ORDER BY energy_star_rating DESC NULLS LAST LIMIT 3;", "latency_sec": 0.6514739990234375, "total_duration_sec": 0.462488537, "load_duration_sec": 0.008070121, "tokens_prompt": 144, "prompt_eval_sec": 0.010064895, "tokens_completion": 40, "completion_eval_sec": 0.44360126, "tokens_total": 184, "tokens_per_sec": 282.436444548542, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Generated SQL includes an additional 'country' column in the output, while the Reference SQL only selects 'name' and 'energy_star_rating'. Although the ORDER BY clause in the Generated SQL includes 'NULLS LAST' (which has no effect here since energy_star_rating is an INT and cannot be NULL), the extra column makes the result sets structurally different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent. The Reference SQL selects only the required columns (name, energy_star_rating) and uses standard ORDER BY/LIMIT syntax. The Generated SQL includes an unnecessary 'country' column and adds 'NULLS LAST' which is irrelevant here (no NULLs exist in the data). Both would return the same 3 rows for the given data, but the Reference is more efficient and semantically precise. The business intent is fulfilled by both, but the Reference better matches the question's requirements by avoiding extraneous data and clauses.", "overall_assessment": "differently_correct"}}
{"example_id": 456, "sql_complexity": "window functions", "prompt": "List the intelligence operations and their corresponding threat levels, and rank them based on their threat level and budget.", "context": "CREATE TABLE intel_ops_threat (id INT, operation VARCHAR, threat VARCHAR, budget INT); INSERT INTO intel_ops_threat (id, operation, threat, budget) VALUES (1, 'Operation Red Folder', 'High', 5000000), (2, 'Operation Black Vault', 'Medium', 7000000), (3, 'Operation Blue Sail', 'Low', 6000000);", "reference_sql": "SELECT operation, threat, budget, ROW_NUMBER() OVER (PARTITION BY threat ORDER BY budget DESC) as rank FROM intel_ops_threat;", "generated_sql": "SELECT intel_ops_threat.id AS operation_id, intel_ops_threat.generation, intel_ops_threat.threat, intel_ops_threat.budget FROM intel_ops_threat ORDER BY intel_ops_threat.threat DESC, intel_ops_threat.budget DESC;", "raw_model_output": " Code\n<s> SELECT intel_ops_threat.id AS operation_id, intel_ops_threat.generation, intel_ops_threat.threat, intel_ops_threat.budget FROM intel_ops_threat ORDER BY intel_ops_threat.threat DESC, intel_ops_threat.budget DESC;", "latency_sec": 1.0983059406280518, "total_duration_sec": 0.902781666, "load_duration_sec": 0.008381085, "tokens_prompt": 147, "prompt_eval_sec": 0.010447871, "tokens_completion": 82, "completion_eval_sec": 0.883227083, "tokens_total": 229, "tokens_per_sec": 208.50292393852425, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL includes a ROW_NUMBER() ranking column partitioned by 'threat' and ordered by 'budget' descending, while the Generated SQL selects different columns (including a non-existent 'generation' column) and orders by 'threat' and 'budget' without adding any ranking. The output structures and purposes differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL is technically correct but has a logical flaw in ranking: it partitions by threat level, creating separate rankings within each threat category rather than a global ranking across all operations. The Generated SQL contains a critical error by referencing a non-existent 'generation' column instead of 'operation'. While the Reference SQL attempts to address the ranking requirement, neither query fully satisfies the business intent of ranking operations by both threat level and budget in a single sequence. The Generated SQL's invalid column makes it non-functional, while the Reference SQL's partitioning approach misaligns with the explicit ranking requirement.", "overall_assessment": "differently_correct"}}
{"example_id": 459, "sql_complexity": "set operations", "prompt": "What is the total installed capacity of hydroelectric power plants in Brazil and Canada?", "context": "CREATE TABLE hydroelectric_power (country TEXT, capacity INTEGER); INSERT INTO hydroelectric_power (country, capacity) VALUES ('Brazil', 104000), ('Canada', 78000), ('China', 350000), ('United States', 100000), ('Russia', 45000);", "reference_sql": "(SELECT capacity FROM hydroelectric_power WHERE country = 'Brazil') UNION (SELECT capacity FROM hydroelectric_power WHERE country = 'Canada');", "generated_sql": "SELECT SUM(capacity) AS total_capacity FROM hydroelectric_power WHERE country IN ('Brazil', 'Canada');", "raw_model_output": " code to solve problem\nSELECT SUM(capacity) AS total_capacity FROM hydroelectric_power WHERE country IN ('Brazil', 'Canada');", "latency_sec": 0.5830831527709961, "total_duration_sec": 0.388250977, "load_duration_sec": 0.009568366, "tokens_prompt": 127, "prompt_eval_sec": 0.007980672, "tokens_completion": 34, "completion_eval_sec": 0.369960532, "tokens_total": 161, "tokens_per_sec": 276.1184219349795, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate capacity values (Brazil and Canada) as individual rows, while the Generated SQL returns a single summed value of both countries' capacities. The output structure and result type differ (multiple rows vs. single aggregate value).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query returns individual capacity values for Brazil and Canada as separate rows (using UNION), while the generated query correctly calculates their sum. The original question asks for 'total installed capacity,' which requires aggregation. The generated query uses SUM(capacity) with a WHERE clause to explicitly compute the combined total, aligning with both technical correctness and business intent. The reference query would require additional aggregation (e.g., SUM) to answer the question properly.", "overall_assessment": "correct"}}
{"example_id": 2356, "sql_complexity": "window functions", "prompt": "Find the total billing amount for attorneys in the 'Criminal Law' practice area, for the year 2020, partitioned by attorney's last name and ordered by the total billing amount in descending order.", "context": "CREATE TABLE Attorneys (AttorneyID INT, FirstName VARCHAR(50), LastName VARCHAR(50), PracticeArea VARCHAR(50), TotalBilling FLOAT, BillingYear INT); INSERT INTO Attorneys (AttorneyID, FirstName, LastName, PracticeArea, TotalBilling, BillingYear) VALUES (1, 'Clara', 'Rivera', 'Personal Injury', 8000.00, 2020), (2, 'Jamal', 'Lee', 'Personal Injury', 6000.00, 2019), (3, 'Sophia', 'Gomez', 'Criminal Law', 9000.00, 2020);", "reference_sql": "SELECT LastName, SUM(TotalBilling) OVER (PARTITION BY PracticeArea, LastName, BillingYear) AS TotalBilling FROM Attorneys WHERE PracticeArea = 'Criminal Law' AND BillingYear = 2020 ORDER BY TotalBilling DESC;", "generated_sql": "SELECT a.\"LastName\", SUM(a.TotalBilling) AS Total_Billing FROM Attorneys a WHERE a.PracticeArea = 'Criminal Law' AND a.BillingYear = 2020 GROUP BY a.\"LastName\" ORDER BY Total_Billing DESC NULLS LAST;", "raw_model_output": " Code\n<s> SELECT a.\"LastName\", SUM(a.TotalBilling) AS Total_Billing FROM Attorneys a WHERE a.PracticeArea = 'Criminal Law' AND a.BillingYear = 2020 GROUP BY a.\"LastName\" ORDER BY Total_Billing DESC NULLS LAST;", "latency_sec": 1.1005940437316895, "total_duration_sec": 0.911113261, "load_duration_sec": 0.010051928, "tokens_prompt": 246, "prompt_eval_sec": 0.018965586, "tokens_completion": 78, "completion_eval_sec": 0.879649337, "tokens_total": 324, "tokens_per_sec": 294.3864741457632, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses a window function to calculate SUM(TotalBilling) over partitions of PracticeArea, LastName, and BillingYear, which in this case returns the same value as TotalBilling for each row (since the WHERE clause filters to a single row). The Generated SQL groups by LastName and sums TotalBilling, which would aggregate multiple rows with the same LastName. While both return the same result for the sample data (only one row), they differ in behavior when multiple rows exist. The Reference SQL retains all rows with per-row sums, while the Generated SQL collapses rows by LastName. Thus, they are not semantically equivalent in general.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query uses a window function (SUM OVER) which calculates the sum within partitions but does not aggregate rows. This would return multiple rows per last name if there are multiple attorneys with the same last name, whereas the generated query uses GROUP BY to properly aggregate billing amounts by last name. The generated query correctly addresses the 'partitioned by attorney's last name' requirement through aggregation, while the reference query's window function approach is unnecessary and less precise for this specific business question. Both queries filter for 'Criminal Law' and 2020, but the generated query's structure better aligns with the requirement to summarize billing amounts per last name.", "overall_assessment": "differently_correct"}}
