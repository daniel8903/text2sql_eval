{"example_id": 2656, "sql_complexity": "multiple_joins", "prompt": "Find the drugs and their respective total sales for rare diseases indication with sales greater than the average sales for infectious diseases.", "context": "CREATE TABLE sales (id INT, drug_id INT, quarter INT, year INT, revenue FLOAT); INSERT INTO sales (id, drug_id, quarter, year, revenue) VALUES (1, 1, 1, 2022, 1500000); CREATE TABLE drugs (id INT, name VARCHAR(50), company VARCHAR(50), indication VARCHAR(50)); INSERT INTO drugs (id, name, company, indication) VALUES (1, 'DrugA', 'ABC Corp', 'Rare_Diseases');", "reference_sql": "SELECT s.drug_id, d.name, SUM(s.revenue) as total_sales FROM sales s JOIN drugs d ON s.drug_id = d.id WHERE d.indication = 'Rare_Diseases' GROUP BY s.drug_id HAVING total_sales > (SELECT AVG(s2.revenue) FROM sales s2 JOIN drugs d2 ON s2.drug_id = d2.id WHERE d2.indication = 'Infectious_Diseases')", "generated_sql": "SELECT d.name AS drug_name, SUM(s.revenue) AS total_sales\nFROM sales s\nJOIN drugs d ON s.drug_id = d.id\nWHERE d.indication = 'Rare_Diseases'\nGROUP BY d.name\nHAVING SUM(s.revenue) > (\n    SELECT AVG(total_infectious_sales)\n    FROM (\n        SELECT drug_id, SUM(revenue) AS total_infectious_sales\n        FROM sales\n        JOIN drugs ON sales.drug_id = drugs.id\n        WHERE drugs.indication = 'Infectious_Diseases'\n        GROUP BY drug_id\n    ) subquery\n);", "raw_model_output": "```sql\nSELECT d.name AS drug_name, SUM(s.revenue) AS total_sales\nFROM sales s\nJOIN drugs d ON s.drug_id = d.id\nWHERE d.indication = 'Rare_Diseases'\nGROUP BY d.name\nHAVING SUM(s.revenue) > (\n    SELECT AVG(total_infectious_sales)\n    FROM (\n        SELECT drug_id, SUM(revenue) AS total_infectious_sales\n        FROM sales\n        JOIN drugs ON sales.drug_id = drugs.id\n        WHERE drugs.indication = 'Infectious_Diseases'\n        GROUP BY drug_id\n    ) subquery\n);\n```", "latency_sec": 7.454236030578613, "total_duration_sec": 7.404637945, "load_duration_sec": 4.132296036, "tokens_prompt": 214, "prompt_eval_sec": 0.228903756, "tokens_completion": 132, "completion_eval_sec": 3.03477053, "tokens_total": 346, "tokens_per_sec": 46.41656080926951, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in how they calculate the threshold for the HAVING clause. The Reference SQL uses AVG(s2.revenue) (average of individual sales) for Infectious_Diseases drugs, while the Generated SQL uses AVG(total_infectious_sales) (average of summed revenues per drug). This leads to different threshold values. Additionally, the Generated SQL groups by d.name instead of s.drug_id, which could produce different results if multiple drugs share the same name (though the schema implies names are unique).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in how they calculate the 'average sales for infectious diseases'. The Reference SQL computes the average of individual sales entries for infectious diseases, while the Generated SQL calculates the average of total sales per infectious disease drug. The original question's phrasing ('average sales for infectious diseases') is ambiguous, but the Generated SQL better aligns with the business intent of comparing rare disease drug totals to the average of infectious disease drug totals. The Generated SQL also groups by drug name (which is acceptable if names are unique) and uses a subquery to pre-aggregate infectious disease sales, which may improve efficiency. The Reference SQL's HAVING clause compares to an average of individual sales, which could produce different results.", "overall_assessment": "differently_correct"}}
{"example_id": 3008, "sql_complexity": "multiple_joins", "prompt": "Who are the users who used electric vehicles and their trip details?", "context": "CREATE TABLE users (id INT, name VARCHAR(50), age INT, gender VARCHAR(10), city VARCHAR(50));CREATE TABLE vehicles (id INT, vehicle_type VARCHAR(20), is_electric BOOLEAN);CREATE TABLE trips (id INT, user_id INT, vehicle_id INT, trip_distance FLOAT, trip_duration INT, departure_time TIMESTAMP, arrival_time TIMESTAMP);INSERT INTO users (id, name, age, gender, city) VALUES (3, 'Alex', 30, 'Female', 'New York');INSERT INTO vehicles (id, vehicle_type, is_electric) VALUES (1, 'Tesla', true), (2, 'Bike', false);INSERT INTO trips (id, user_id, vehicle_id, trip_distance, trip_duration, departure_time, arrival_time) VALUES (3, 3, 1, 15.3, 25, '2022-01-03 12:00:00', '2022-01-03 12:25:00');", "reference_sql": "SELECT u.name, v.vehicle_type, t.trip_distance, t.trip_duration FROM users u JOIN trips t ON u.id = t.user_id JOIN vehicles v ON t.vehicle_id = v.id WHERE v.is_electric = true;", "generated_sql": "SELECT u.name, t.trip_distance, t.trip_duration, t.departure_time, t.arrival_time\nFROM users u\nJOIN trips t ON u.id = t.user_id\nJOIN vehicles v ON t.vehicle_id = v.id\nWHERE v.is_electric = true;", "raw_model_output": "```sql\nSELECT u.name, t.trip_distance, t.trip_duration, t.departure_time, t.arrival_time\nFROM users u\nJOIN trips t ON u.id = t.user_id\nJOIN vehicles v ON t.vehicle_id = v.id\nWHERE v.is_electric = true;\n```", "latency_sec": 1.6310129165649414, "total_duration_sec": 1.539958832, "load_duration_sec": 0.029931371, "tokens_prompt": 316, "prompt_eval_sec": 0.069633782, "tokens_completion": 61, "completion_eval_sec": 1.433016395, "tokens_total": 377, "tokens_per_sec": 231.1447053368502, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects 'vehicle_type' from the vehicles table, while the Generated SQL includes 'departure_time' and 'arrival_time' from the trips table. The selected columns differ, resulting in different output structures.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because they select different columns. The reference query returns vehicle_type, while the generated query includes departure_time and arrival_time, which are more detailed trip information. Both correctly identify users who used electric vehicles through the same JOIN logic and WHERE condition. The generated query better fulfills the business intent of retrieving 'trip details' by including time-based metrics, which are critical for understanding trip specifics. While both are efficient, the generated query's additional fields provide richer context without unnecessary complexity.", "overall_assessment": "differently_correct"}}
{"example_id": 2531, "sql_complexity": "basic SQL", "prompt": "Who is the top customer by sales in 2022?", "context": "CREATE TABLE customers (customer_id INT, total_sales_2022 FLOAT); INSERT INTO customers (customer_id, total_sales_2022) VALUES (1, 25000.0), (2, 30000.0), (3, 22000.0), (4, 35000.0);", "reference_sql": "SELECT customer_id, total_sales_2022 FROM customers ORDER BY total_sales_2022 DESC LIMIT 1;", "generated_sql": "SELECT customer_id \nFROM customers \nORDER BY total_sales_2022 DESC \nLIMIT 1;", "raw_model_output": "```sql\nSELECT customer_id \nFROM customers \nORDER BY total_sales_2022 DESC \nLIMIT 1;\n```", "latency_sec": 0.7201862335205078, "total_duration_sec": 0.666158011, "load_duration_sec": 0.013697546, "tokens_prompt": 171, "prompt_eval_sec": 0.034587636, "tokens_completion": 27, "completion_eval_sec": 0.615185107, "tokens_total": 198, "tokens_per_sec": 274.928887535257, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query selects both customer_id and total_sales_2022 columns, while the generated query only selects customer_id. Although both order by total_sales_2022 DESC and limit to 1 row, the result sets differ in column structure (2 columns vs 1 column), making them semantically distinct.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because the reference query returns both customer_id and total_sales_2022 while the generated query only returns customer_id. Both correctly identify the top customer by sales through ordering and limiting results. The generated query better fulfills the business intent by being more efficient (selecting only the required column) while still answering 'who' the top customer is. The reference query includes redundant data that isn't requested in the original question.", "overall_assessment": "differently_correct"}}
{"example_id": 3792, "sql_complexity": "single join", "prompt": "What is the maximum distance traveled by an electric vehicle in a single trip, grouped by vehicle model?", "context": "CREATE TABLE Trips (trip_id INT, vehicle_id INT, distance FLOAT); CREATE TABLE ElectricVehicleModels (vehicle_id INT, vehicle_model TEXT);", "reference_sql": "SELECT evm.vehicle_model, MAX(trips.distance) AS max_distance_traveled FROM Trips trips INNER JOIN ElectricVehicleModels evm ON trips.vehicle_id = evm.vehicle_id GROUP BY 1;", "generated_sql": "SELECT \n    evm.vehicle_model, \n    MAX(t.distance) AS max_distance\nFROM \n    Trips t\nJOIN \n    ElectricVehicleModels evm ON t.vehicle_id = evm.vehicle_id\nGROUP BY \n    evm.vehicle_model;", "raw_model_output": "```sql\nSELECT \n    evm.vehicle_model, \n    MAX(t.distance) AS max_distance\nFROM \n    Trips t\nJOIN \n    ElectricVehicleModels evm ON t.vehicle_id = evm.vehicle_id\nGROUP BY \n    evm.vehicle_model;\n```", "latency_sec": 1.3441870212554932, "total_duration_sec": 1.332566686, "load_duration_sec": 0.021701866, "tokens_prompt": 126, "prompt_eval_sec": 0.030484691, "tokens_completion": 57, "completion_eval_sec": 1.277153756, "tokens_total": 183, "tokens_per_sec": 136.14176978816158, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the maximum distance traveled per vehicle model by joining the Trips and ElectricVehicleModels tables. The differences are purely syntactic: the reference uses 'GROUP BY 1' (referencing the first column) while the generated query explicitly groups by 'evm.vehicle_model'. The table aliases ('trips' vs 't') and column alias names ('max_distance_traveled' vs 'max_distance') do not affect semantic equivalence. The logical structure, join condition, and aggregation remain identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically correct and produce equivalent results. The reference query uses 'GROUP BY 1' (column position) while the generated query explicitly groups by 'evm.vehicle_model'. The generated version is more readable and maintainable due to explicit grouping, though both satisfy the business requirement of finding maximum trip distances per vehicle model. The generated query's column alias 'max_distance' is slightly more concise than 'max_distance_traveled' but does not affect functionality.", "overall_assessment": "correct"}}
{"example_id": 2311, "sql_complexity": "subqueries", "prompt": "Determine the percentage of sales from each ingredient category", "context": "CREATE TABLE Sales_Details (sale_id INT, ingredient_id INT, quantity INT); INSERT INTO Sales_Details (sale_id, ingredient_id, quantity) VALUES (1, 1, 2), (1, 2, 8), (2, 1, 3), (2, 2, 7); CREATE TABLE Ingredient_Categories (ingredient_id INT, ingredient_category VARCHAR(255)); INSERT INTO Ingredient_Categories (ingredient_id, ingredient_category) VALUES (1, 'Legumes'), (2, 'Poultry');", "reference_sql": "SELECT ingredient_category, SUM(quantity) AS total_quantity, SUM(quantity) * 100.0 / (SELECT SUM(quantity) FROM Sales_Details) AS percentage_of_sales FROM Sales_Details, Ingredient_Categories WHERE Sales_Details.ingredient_id = Ingredient_Categories.ingredient_id GROUP BY ingredient_category;", "generated_sql": "SELECT \n    ic.ingredient_category,\n    SUM(sd.quantity) AS total_quantity_sold,\n    (SUM(sd.quantity) * 100.0 / (SELECT SUM(quantity) FROM Sales_Details)) AS percentage_of_sales\nFROM \n    Sales_Details sd\nJOIN \n    Ingredient_Categories ic ON sd.ingredient_id = ic.ingredient_id\nGROUP BY \n    ic.ingredient_category;", "raw_model_output": "```sql\nSELECT \n    ic.ingredient_category,\n    SUM(sd.quantity) AS total_quantity_sold,\n    (SUM(sd.quantity) * 100.0 / (SELECT SUM(quantity) FROM Sales_Details)) AS percentage_of_sales\nFROM \n    Sales_Details sd\nJOIN \n    Ingredient_Categories ic ON sd.ingredient_id = ic.ingredient_id\nGROUP BY \n    ic.ingredient_category;\n```", "latency_sec": 2.302504777908325, "total_duration_sec": 1.996914871, "load_duration_sec": 0.015209711, "tokens_prompt": 198, "prompt_eval_sec": 0.044898136, "tokens_completion": 85, "completion_eval_sec": 1.934418965, "tokens_total": 283, "tokens_per_sec": 122.9096255153429, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the total quantity sold per ingredient category and their percentage of total sales. They use equivalent JOIN logic (implicit vs explicit), same aggregation functions, and identical subquery for total sales calculation. The column aliases differ but do not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the percentage of sales per ingredient category by summing quantities and dividing by total sales. The reference query uses an implicit join (comma syntax) and groups by ingredient_category, which works but is less readable. The generated query uses explicit JOIN syntax, table aliases, and clearer column qualification, making it more maintainable. Both produce identical results, but the generated version is more modern, readable, and follows best practices for SQL clarity and structure.", "overall_assessment": "correct"}}
{"example_id": 3329, "sql_complexity": "set operations", "prompt": "Which causes received funding from donors in both the United States and Canada?", "context": "CREATE TABLE donor_location (donor_id INT, country VARCHAR(50), cause VARCHAR(50), donation DECIMAL(10,2)); INSERT INTO donor_location (donor_id, country, cause, donation) VALUES (1, 'United States', 'Global Health', 1000.00), (2, 'Canada', 'Education', 2000.00), (3, 'United States', 'Environment', 1500.00), (4, 'Canada', 'Animal Welfare', 2500.00);", "reference_sql": "SELECT cause FROM donor_location WHERE country = 'United States' INTERSECT SELECT cause FROM donor_location WHERE country = 'Canada';", "generated_sql": "SELECT cause\nFROM donor_location\nWHERE country = 'United States'\nINTERSECT\nSELECT cause\nFROM donor_location\nWHERE country = 'Canada';", "raw_model_output": "```sql\nSELECT cause\nFROM donor_location\nWHERE country = 'United States'\nINTERSECT\nSELECT cause\nFROM donor_location\nWHERE country = 'Canada';\n```", "latency_sec": 1.1736290454864502, "total_duration_sec": 0.871076646, "load_duration_sec": 0.013749816, "tokens_prompt": 213, "prompt_eval_sec": 0.044647328, "tokens_completion": 36, "completion_eval_sec": 0.810087715, "tokens_total": 249, "tokens_per_sec": 212.16243834251182, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure and logic. Both queries use the INTERSECT operator to find common 'cause' values between donors from 'United States' and 'Canada'. Since the queries are exactly the same, they will produce identical results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic. They use INTERSECT to find causes present in both US and Canadian donor records, which directly answers the question about causes receiving funding from donors in both countries. The queries are equally efficient, elegant, and semantically correct. The apparent difference in formatting (line breaks) does not affect technical equivalence or result accuracy.", "overall_assessment": "correct"}}
{"example_id": 2912, "sql_complexity": "single join", "prompt": "Which company has manufactured the most satellites?", "context": "CREATE TABLE manufacturers (id INT, name TEXT); CREATE TABLE satellites (id INT, manufacturer_id INT, name TEXT, launch_date DATE); INSERT INTO manufacturers (id, name) VALUES (1, 'SpaceX'), (2, 'Blue Origin'), (3, 'ISRO'), (4, 'CAST'); INSERT INTO satellites (id, manufacturer_id, name, launch_date) VALUES (1, 1, 'StarDragon', '2012-05-25'), (2, 1, 'Falcon', '2015-12-21'), (3, 2, 'New Glenn', '2022-01-11'), (4, 3, 'ChinaSat 1E', '2000-12-05'), (5, 3, 'ChinaSat 2A', '2003-08-13'), (6, 4, 'Shijian 9', '2017-11-19'), (7, 1, 'StarLink', '2020-05-24'), (8, 1, 'StarLink', '2020-06-13');", "reference_sql": "SELECT m.name, COUNT(s.id) FROM manufacturers m JOIN satellites s ON m.id = s.manufacturer_id GROUP BY m.name ORDER BY COUNT(s.id) DESC;", "generated_sql": "SELECT m.name AS manufacturer_name\nFROM manufacturers m\nJOIN satellites s ON m.id = s.manufacturer_id\nGROUP BY m.id, m.name\nORDER BY COUNT(s.id) DESC\nLIMIT 1;", "raw_model_output": "```sql\nSELECT m.name AS manufacturer_name\nFROM manufacturers m\nJOIN satellites s ON m.id = s.manufacturer_id\nGROUP BY m.id, m.name\nORDER BY COUNT(s.id) DESC\nLIMIT 1;\n```", "latency_sec": 1.3192079067230225, "total_duration_sec": 1.223379856, "load_duration_sec": 0.015526088, "tokens_prompt": 348, "prompt_eval_sec": 0.077952094, "tokens_completion": 48, "completion_eval_sec": 1.127240172, "tokens_total": 396, "tokens_per_sec": 300.1801292896156, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns all manufacturers sorted by their satellite count in descending order, while the Generated SQL only returns the top manufacturer (due to LIMIT 1). Additionally, the Generated SQL groups by both m.id and m.name, which is functionally equivalent to grouping by m.name alone in this specific dataset (since manufacturer names are unique). However, the LIMIT 1 clause makes the Generated SQL produce a subset of the Reference SQL's results, so they are not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify the manufacturer with the most satellites by joining manufacturers and satellites tables, grouping by manufacturer, and ordering by satellite count. The key differences are: 1) The generated query groups by both m.id and m.name (better practice for uniqueness) while the reference only groups by m.name; 2) The generated query uses LIMIT 1 to directly return the top result, whereas the reference requires manual selection of the top row. The generated query is more efficient and robust, particularly in cases where manufacturer names might not be unique. Both fulfill the business intent, but the generated query better addresses the specific question by returning a single result.", "overall_assessment": "correct"}}
{"example_id": 3170, "sql_complexity": "aggregation", "prompt": "Determine the total production quantity of silver for mining sites in Mexico, between the dates '2017-05-01' and '2017-09-30', having less than 40 employees.", "context": "CREATE TABLE silver_mine_2 (site_id INT, country VARCHAR(50), num_employees INT, extraction_date DATE, quantity INT); INSERT INTO silver_mine_2 (site_id, country, num_employees, extraction_date, quantity) VALUES (1, 'Mexico', 35, '2017-05-02', 1200), (2, 'Mexico', 30, '2017-08-31', 1800), (3, 'Mexico', 37, '2017-07-04', 2200);", "reference_sql": "SELECT country, SUM(quantity) as total_silver_prod FROM silver_mine_2 WHERE num_employees < 40 AND country = 'Mexico' AND extraction_date >= '2017-05-01' AND extraction_date <= '2017-09-30' GROUP BY country;", "generated_sql": "SELECT SUM(quantity) AS total_production_quantity\nFROM silver_mine_2\nWHERE country = 'Mexico'\n  AND extraction_date BETWEEN '2017-05-01' AND '2017-09-30'\n  AND num_employees < 40;", "raw_model_output": "```sql\nSELECT SUM(quantity) AS total_production_quantity\nFROM silver_mine_2\nWHERE country = 'Mexico'\n  AND extraction_date BETWEEN '2017-05-01' AND '2017-09-30'\n  AND num_employees < 40;\n```", "latency_sec": 1.6875250339508057, "total_duration_sec": 1.58931714, "load_duration_sec": 0.015805566, "tokens_prompt": 263, "prompt_eval_sec": 0.055280477, "tokens_completion": 67, "completion_eval_sec": 1.515739909, "tokens_total": 330, "tokens_per_sec": 195.55265454486886, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a GROUP BY country and selects the country column, resulting in a two-column output (country, total_silver_prod). The Generated SQL omits the GROUP BY and does not include the country column, producing a single-column output (total_production_quantity). While both calculate the same sum, their result structures differ, making them semantically distinct.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly filter for Mexico, dates between '2017-05-01' and '2017-09-30', and sites with <40 employees. The Reference SQL includes an unnecessary GROUP BY country (since country is already filtered to Mexico) and returns an extra column, while the Generated SQL directly computes the sum without overhead. The Generated SQL uses BETWEEN which is more concise for date ranges. Both produce the same numerical result, but the Generated version is more efficient and elegant.", "overall_assessment": "correct"}}
{"example_id": 3518, "sql_complexity": "basic SQL", "prompt": "Insert new records of ticket sales for a new event, including event and salesperson information.", "context": "CREATE TABLE salesperson (salesperson_id INT, name VARCHAR(50), position VARCHAR(50)); CREATE TABLE tickets (ticket_id INT, salesperson_id INT, event_id INT, price DECIMAL(5,2), quantity INT); CREATE TABLE events (event_id INT, name VARCHAR(50), date DATE); INSERT INTO salesperson VALUES (1, 'John Doe', 'Senior Salesperson'); INSERT INTO events VALUES (2, 'New Event', '2023-04-15');", "reference_sql": "INSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity) VALUES (2, 1, 2, 75, 50), (3, 2, 2, 65, 75); INSERT INTO events (event_id, name, date) VALUES (2, 'New Event', '2023-04-15');", "generated_sql": "INSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity)\nVALUES \n    (1, 1, 2, 50.00, 10),\n    (2, 1, 2, 60.00, 5);", "raw_model_output": "```sql\nINSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity)\nVALUES \n    (1, 1, 2, 50.00, 10),\n    (2, 1, 2, 60.00, 5);\n```", "latency_sec": 1.7343850135803223, "total_duration_sec": 1.529239257, "load_duration_sec": 0.015894554, "tokens_prompt": 201, "prompt_eval_sec": 0.044933518, "tokens_completion": 66, "completion_eval_sec": 1.465963871, "tokens_total": 267, "tokens_per_sec": 153.94505712940122, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL inserts into both 'tickets' and 'events' tables, while the Generated SQL only inserts into 'tickets'. Additionally, the data in the 'tickets' table differs: the Reference inserts two rows with different salesperson_ids (1 and 2) and values (75,50 and 65,75), whereas the Generated SQL inserts two rows with the same salesperson_id (1) and different values (50.00,10 and 60.00,5). The 'events' table insertion is missing in the Generated SQL.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is technically flawed: it reinserts the same event_id (2) into the events table, which may cause duplicates if event_id is unique, and includes salesperson_id 2 which doesn't exist in the context. The Generated SQL avoids this by only inserting into tickets with valid salesperson_id 1 and event_id 2 (already present). While neither fully addresses 'new event' (since event_id 2 exists), the Generated SQL better fulfills the intent by focusing on ticket sales without redundant/invalid data. The Reference SQL's events insert is unnecessary given the context, making the Generated SQL more efficient and semantically aligned with the existing schema.", "overall_assessment": "differently_correct"}}
{"example_id": 3925, "sql_complexity": "set operations", "prompt": "What is the total number of students and staff with accommodations in the \"disability_services\" schema, excluding the \"accessibility_parking\" type?", "context": "CREATE SCHEMA disability_services; CREATE TABLE staff (id INT, name VARCHAR(50), accommodation VARCHAR(50)); CREATE TABLE students (id INT, name VARCHAR(50), accommodation VARCHAR(50));", "reference_sql": "SELECT COUNT(*) FROM disability_services.staff WHERE accommodation != 'accessibility_parking' UNION SELECT COUNT(*) FROM disability_services.students WHERE accommodation != 'accessibility_parking';", "generated_sql": "SELECT \n    COUNT(*) AS total_with_accommodations\nFROM \n    disability_services.staff\nWHERE \n    accommodation != 'accessibility_parking'\nUNION ALL\nSELECT \n    COUNT(*) AS total_with_accommodations\nFROM \n    disability_services.students\nWHERE \n    accommodation != 'accessibility_parking';", "raw_model_output": "```sql\nSELECT \n    COUNT(*) AS total_with_accommodations\nFROM \n    disability_services.staff\nWHERE \n    accommodation != 'accessibility_parking'\nUNION ALL\nSELECT \n    COUNT(*) AS total_with_accommodations\nFROM \n    disability_services.students\nWHERE \n    accommodation != 'accessibility_parking';\n```", "latency_sec": 1.7181360721588135, "total_duration_sec": 1.618392906, "load_duration_sec": 0.01399814, "tokens_prompt": 150, "prompt_eval_sec": 0.029237367, "tokens_completion": 71, "completion_eval_sec": 1.572469141, "tokens_total": 221, "tokens_per_sec": 128.62776329602153, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their use of UNION vs. UNION ALL. The Reference SQL uses UNION, which removes duplicate rows, while the Generated SQL uses UNION ALL, which retains all rows. If both counts are identical, the Reference query would return a single row, whereas the Generated query would return two rows. This difference in output structure makes them non-equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": false, "superiority": "generated", "explanation": "Both queries are technically equivalent in logic and would produce identical results (two rows with counts of staff and students excluding 'accessibility_parking'). However, neither query fulfills the business intent of returning a single total number. The original question asks for a 'total number', but both queries use UNION/UNION ALL to return separate counts for staff and students. The generated query is more efficient due to using UNION ALL (which avoids unnecessary duplicate elimination) but still fails to address the actual requirement of summing the two counts. A correct solution would use a single query with a SUM of subqueries.", "overall_assessment": "incorrect"}}
{"example_id": 3340, "sql_complexity": "subqueries", "prompt": "Calculate the total revenue for garments manufactured in the US and sold in California.", "context": "CREATE TABLE garment_manufacturing(id INT PRIMARY KEY, garment_id INT, country VARCHAR(50), material VARCHAR(50), manufacturing_date DATE, quantity INT); CREATE TABLE garment_sales(id INT PRIMARY KEY, garment_id INT, store_id INT, sale_date DATE, units INT, revenue DECIMAL(10,2));", "reference_sql": "SELECT SUM(gs.revenue) FROM garment_manufacturing gm JOIN garment_sales gs ON gm.garment_id = gs.garment_id WHERE gm.country = 'United States' AND gs.store_id IN (SELECT id FROM stores WHERE region = 'California');", "generated_sql": "SELECT SUM(s.revenue) AS total_revenue\nFROM garment_sales s\nJOIN garment_manufacturing m ON s.garment_id = m.garment_id\nWHERE m.country = 'US' AND s.store_id IN (\n    SELECT id FROM stores WHERE state = 'California'\n);", "raw_model_output": "```sql\nSELECT SUM(s.revenue) AS total_revenue\nFROM garment_sales s\nJOIN garment_manufacturing m ON s.garment_id = m.garment_id\nWHERE m.country = 'US' AND s.store_id IN (\n    SELECT id FROM stores WHERE state = 'California'\n);\n```\n\nNote: The provided schema does not include a `stores` table, so I assumed the existence of such a table to filter sales by California. If the `store_id` directly corresponds to California without needing a separate `stores` table, you would need to adjust the query accordingly.", "latency_sec": 2.9310762882232666, "total_duration_sec": 2.791907502, "load_duration_sec": 0.015466766, "tokens_prompt": 158, "prompt_eval_sec": 0.030575077, "tokens_completion": 123, "completion_eval_sec": 2.742250076, "tokens_total": 281, "tokens_per_sec": 95.8692208486781, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects: 1) The country condition uses 'United States' vs 'US' (assuming different data representations), and 2) The subquery filters stores by 'region' vs 'state' (assuming different columns in the stores table). These differences would produce different results unless the data explicitly aligns these values, which cannot be assumed.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries are not technically equivalent due to differences in country code ('United States' vs 'US') and column name ('region' vs 'state'). Both queries assume a non-existent 'stores' table, which is not part of the provided schema. The generated query uses 'US' (more concise) and 'state' (more precise for California), while the reference uses 'United States' and 'region'. Neither query is fully correct due to the missing 'stores' table, but the generated query better aligns with common schema conventions. The business intent is partially fulfilled but requires the existence of the 'stores' table, which is not validated in the context.", "overall_assessment": "differently_correct"}}
{"example_id": 596, "sql_complexity": "basic SQL", "prompt": "What is the minimum energy production cost of wind farms in Spain?", "context": "CREATE TABLE wind_farm_costs (id INT, name TEXT, country TEXT, energy_production_cost FLOAT); INSERT INTO wind_farm_costs (id, name, country, energy_production_cost) VALUES (1, 'Las Tiesas', 'Spain', 0.045), (2, 'Eolo', 'Spain', 0.050);", "reference_sql": "SELECT MIN(energy_production_cost) FROM wind_farm_costs WHERE country = 'Spain';", "generated_sql": "SELECT MIN(energy_production_cost) AS min_energy_production_cost\nFROM wind_farm_costs\nWHERE country = 'Spain';", "raw_model_output": "```sql\nSELECT MIN(energy_production_cost) AS min_energy_production_cost\nFROM wind_farm_costs\nWHERE country = 'Spain';\n```", "latency_sec": 1.5481820106506348, "total_duration_sec": 0.731789715, "load_duration_sec": 0.020942271, "tokens_prompt": 164, "prompt_eval_sec": 0.030360446, "tokens_completion": 30, "completion_eval_sec": 0.677516925, "tokens_total": 194, "tokens_per_sec": 125.30826392852227, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the minimum energy_production_cost from the wind_farm_costs table where country is 'Spain'. The generated query adds an alias (min_energy_production_cost) for the column, but this does not affect the semantic result - the value returned remains the same minimum value.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly retrieve the minimum energy production cost for wind farms in Spain. The reference query is concise while the generated query adds an explicit alias for the calculated column. The alias in the generated query improves readability by naming the result column, but both queries produce identical numerical results. The business intent is fully satisfied by either query as they both answer the question about the minimum cost. Neither query is more efficient than the other since they execute the same operation with identical filtering and aggregation.", "overall_assessment": "correct"}}
{"example_id": 2604, "sql_complexity": "subqueries", "prompt": "What is the maximum number of virtual tours taken by a single user in the UK?", "context": "CREATE TABLE virtual_tour_data (user_id INT, hotel_id INT, tour_date DATE); INSERT INTO virtual_tour_data (user_id, hotel_id, tour_date) VALUES (1, 10, '2022-01-01'), (2, 11, '2022-01-03'), (3, 12, '2022-01-05'), (4, 10, '2022-01-07'), (5, 10, '2022-01-09'); CREATE TABLE hotels (hotel_id INT, hotel_name TEXT, country TEXT); INSERT INTO hotels (hotel_id, hotel_name, country) VALUES (10, 'Royal Park Hotel', 'UK'), (11, 'The Ritz London', 'UK'), (12, 'Hotel de Crillon', 'France');", "reference_sql": "SELECT MAX(vt.user_tours) FROM (SELECT user_id, COUNT(DISTINCT hotel_id) as user_tours FROM virtual_tour_data WHERE country = 'UK' GROUP BY user_id) as vt;", "generated_sql": "SELECT MAX(tour_count) AS max_tours\nFROM (\n    SELECT v.user_id, COUNT(v.tour_date) AS tour_count\n    FROM virtual_tour_data v\n    JOIN hotels h ON v.hotel_id = h.hotel_id\n    WHERE h.country = 'UK'\n    GROUP BY v.user_id\n) AS user_tour_counts;", "raw_model_output": "```sql\nSELECT MAX(tour_count) AS max_tours\nFROM (\n    SELECT v.user_id, COUNT(v.tour_date) AS tour_count\n    FROM virtual_tour_data v\n    JOIN hotels h ON v.hotel_id = h.hotel_id\n    WHERE h.country = 'UK'\n    GROUP BY v.user_id\n) AS user_tour_counts;\n```", "latency_sec": 2.092241048812866, "total_duration_sec": 1.895039666, "load_duration_sec": 0.015647627, "tokens_prompt": 290, "prompt_eval_sec": 0.059203732, "tokens_completion": 79, "completion_eval_sec": 1.817434578, "tokens_total": 369, "tokens_per_sec": 176.36591166652138, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL references a 'country' column that does not exist in the virtual_tour_data table, making it invalid. Even if we assume a join was intended, the Reference SQL counts distinct hotel_ids per user, while the Generated SQL counts total tour dates (non-distinct). Additionally, the Reference SQL's structure would require a join to access the country column, which is missing.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is technically incorrect because it references a 'country' column that doesn't exist in the virtual_tour_data table. It incorrectly assumes the country filter can be applied directly to the virtual_tour_data table rather than joining with the hotels table. The Generated SQL correctly joins the tables, filters by UK hotels, and counts tour occurrences. While both queries aim to find maximum tours per user, the Reference SQL's approach is flawed. The Generated SQL properly addresses the business intent by counting actual tours (tour_date) rather than distinct hotels, which would answer a different question (number of unique hotels visited).", "overall_assessment": "incorrect"}}
{"example_id": 5812, "sql_complexity": "single join", "prompt": "Calculate the percentage of Shariah-compliant investments held by each investor in the top 5 countries with the highest percentage?", "context": "CREATE TABLE investors (investor_id INT, investor_name TEXT, country TEXT); INSERT INTO investors (investor_id, investor_name, country) VALUES (1, 'Al Thani', 'Qatar'), (2, 'Saudi Investment Group', 'Saudi Arabia'), (3, 'Temasek Holdings', 'Singapore'); CREATE TABLE investments (investment_id INT, investor_id INT, investment_type TEXT, investment_value DECIMAL, is_shariah_compliant BOOLEAN); INSERT INTO investments (investment_id, investor_id, investment_type, investment_value, is_shariah_compliant) VALUES (1, 1, 'Real Estate', 15000000, true), (2, 2, 'Stocks', 20000000, false);", "reference_sql": "SELECT investor_name, ROUND((SUM(CASE WHEN is_shariah_compliant THEN investment_value ELSE 0 END) / SUM(investment_value)) * 100, 2) AS percentage FROM investments JOIN investors ON investments.investor_id = investors.investor_id GROUP BY investor_name ORDER BY percentage DESC LIMIT 5;", "generated_sql": "WITH CountryInvestmentStats AS (\n    SELECT \n        i.country,\n        COUNT(*) FILTER (WHERE inv.is_shariah_compliant = true) AS shariah_compliant_count,\n        COUNT(*) AS total_investments\n    FROM \n        investors i\n    JOIN \n        investments inv ON i.investor_id = inv.investor_id\n    GROUP BY \n        i.country\n),\nCountryShariahPercentage AS (\n    SELECT \n        country,\n        (shariah_compliant_count * 100.0 / total_investments) AS shariah_percentage\n    FROM \n        CountryInvestmentStats\n)\nSELECT \n    csp.country,\n    csp.shariah_percentage\nFROM \n    CountryShariahPercentage csp\nORDER BY \n    csp.shariah_percentage DESC\nLIMIT 5;", "raw_model_output": "```sql\nWITH CountryInvestmentStats AS (\n    SELECT \n        i.country,\n        COUNT(*) FILTER (WHERE inv.is_shariah_compliant = true) AS shariah_compliant_count,\n        COUNT(*) AS total_investments\n    FROM \n        investors i\n    JOIN \n        investments inv ON i.investor_id = inv.investor_id\n    GROUP BY \n        i.country\n),\nCountryShariahPercentage AS (\n    SELECT \n        country,\n        (shariah_compliant_count * 100.0 / total_investments) AS shariah_percentage\n    FROM \n        CountryInvestmentStats\n)\nSELECT \n    csp.country,\n    csp.shariah_percentage\nFROM \n    CountryShariahPercentage csp\nORDER BY \n    csp.shariah_percentage DESC\nLIMIT 5;\n```", "latency_sec": 4.371888160705566, "total_duration_sec": 4.206193593, "load_duration_sec": 0.016535949, "tokens_prompt": 263, "prompt_eval_sec": 0.058393167, "tokens_completion": 179, "completion_eval_sec": 4.128516271, "tokens_total": 442, "tokens_per_sec": 101.10048193196847, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL calculates the percentage of shariah-compliant investment value per investor, while the Generated SQL calculates the percentage of shariah-compliant investments (count) per country. Key differences: 1) Grouping by investor_name vs country, 2) Calculation based on investment_value (sum) vs count of investments, 3) The Generated SQL uses COUNT(*) FILTER instead of SUM(CASE WHEN...).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query calculates Shariah compliance percentages per investor (grouped by investor_name) rather than per country, directly contradicting the business question which focuses on countries. The generated query correctly groups by country, calculates the percentage of Shariah-compliant investments, and orders by that percentage. While both queries have technical validity within their approaches, only the generated query addresses the country-level analysis required. The reference query's grouping by investor_name makes it fundamentally misaligned with the question's intent.", "overall_assessment": "differently_correct"}}
{"example_id": 4706, "sql_complexity": "multiple_joins", "prompt": "Who are the top 3 customers by total spend on makeup products from Italy and Spain?", "context": "CREATE TABLE customers (customer_id INT, customer_name TEXT, country TEXT); INSERT INTO customers (customer_id, customer_name, country) VALUES (1, 'Alessandro Martini', 'IT'), (2, 'Laura Rossi', 'ES'), (3, 'Daniela Gonzalez', 'MX'), (4, 'Jose Hernandez', 'ES'), (5, 'Sophia Rodriguez', 'IT'); CREATE TABLE sales (sale_id INT, customer_id INT, product_id INT, sale_quantity INT, sale_country TEXT); INSERT INTO sales (sale_id, customer_id, product_id, sale_quantity, sale_country) VALUES (1, 1, 1, 100, 'IT'), (2, 2, 2, 150, 'ES'), (3, 3, 3, 200, 'MX'), (4, 4, 4, 250, 'ES'), (5, 5, 5, 300, 'IT'); CREATE TABLE products (product_id INT, product_name TEXT, category TEXT); INSERT INTO products (product_id, product_name, category) VALUES (1, 'Eyeshadow Palette', 'makeup'), (2, 'Liquid Lipstick', 'makeup'), (3, 'BB Cream', 'makeup'), (4, 'Volumizing Mascara', 'makeup'), (5, 'Nourishing Lip Balm', 'makeup');", "reference_sql": "SELECT c.customer_name, SUM(s.sale_quantity) as total_spent_on_makeup FROM sales s JOIN customers c ON s.customer_id = c.customer_id JOIN products p ON s.product_id = p.product_id WHERE c.country IN ('IT', 'ES') AND p.category = 'makeup' GROUP BY c.customer_name ORDER BY total_spent_on_makeup DESC LIMIT 3;", "generated_sql": "SELECT c.customer_name, SUM(s.sale_quantity * p.price) AS total_spend\nFROM sales s\nJOIN customers c ON s.customer_id = c.customer_id\nJOIN products p ON s.product_id = p.product_id\nWHERE p.category = 'makeup' AND c.country IN ('IT', 'ES')\nGROUP BY c.customer_name\nORDER BY total_spend DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT c.customer_name, SUM(s.sale_quantity * p.price) AS total_spend\nFROM sales s\nJOIN customers c ON s.customer_id = c.customer_id\nJOIN products p ON s.product_id = p.product_id\nWHERE p.category = 'makeup' AND c.country IN ('IT', 'ES')\nGROUP BY c.customer_name\nORDER BY total_spend DESC\nLIMIT 3;\n```", "latency_sec": 2.3411800861358643, "total_duration_sec": 2.162637177, "load_duration_sec": 0.01670867, "tokens_prompt": 399, "prompt_eval_sec": 0.090071351, "tokens_completion": 86, "completion_eval_sec": 2.052725545, "tokens_total": 485, "tokens_per_sec": 207.16048409607663, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query sums 'sale_quantity' directly, while the generated query multiplies 'sale_quantity' by 'p.price'. However, the 'products' table in the schema does not contain a 'price' column, making the generated query invalid. Additionally, even if 'price' existed, the calculated totals would differ due to the multiplication factor.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent. The generated query references a 'price' column in the products table that does not exist in the provided schema, making it syntactically invalid. The reference query correctly uses sale_quantity without requiring a price column. While both filter for makeup products and countries IT/ES, the reference query's approach aligns with the available data structure. However, neither query fully fulfills the business intent of calculating 'total spend' since the schema lacks a price field. The reference query's use of sale_quantity as a proxy for spend is the only viable approach given the data constraints.", "overall_assessment": "incorrect"}}
{"example_id": 1515, "sql_complexity": "multiple_joins", "prompt": "What is the average age of clients who lost cases in the 'personal injury' category?", "context": "CREATE TABLE Cases (CaseID int, ClientID int, Category varchar(50)); INSERT INTO Cases (CaseID, ClientID, Category) VALUES (701, 7, 'Personal Injury'); CREATE TABLE Clients (ClientID int, Age int, Gender varchar(10)); INSERT INTO Clients (ClientID, Age, Gender) VALUES (7, 45, 'Male'); CREATE TABLE CaseOutcomes (CaseID int, Outcome varchar(50)); INSERT INTO CaseOutcomes (CaseID, Outcome) VALUES (701, 'Lost');", "reference_sql": "SELECT AVG(C.Age) as AvgAge FROM Clients C INNER JOIN Cases CA ON C.ClientID = CA.ClientID INNER JOIN CaseOutcomes CO ON CA.CaseID = CO.CaseID WHERE CA.Category = 'Personal Injury' AND CO.Outcome = 'Lost';", "generated_sql": "SELECT AVG(Clients.Age)\nFROM Clients\nJOIN Cases ON Clients.ClientID = Cases.ClientID\nJOIN CaseOutcomes ON Cases.CaseID = CaseOutcomes.CaseID\nWHERE Cases.Category = 'Personal Injury' AND CaseOutcomes.Outcome = 'Lost';", "raw_model_output": "```sql\nSELECT AVG(Clients.Age)\nFROM Clients\nJOIN Cases ON Clients.ClientID = Cases.ClientID\nJOIN CaseOutcomes ON Cases.CaseID = CaseOutcomes.CaseID\nWHERE Cases.Category = 'Personal Injury' AND CaseOutcomes.Outcome = 'Lost';\n```", "latency_sec": 1.7296230792999268, "total_duration_sec": 1.429443574, "load_duration_sec": 0.015016404, "tokens_prompt": 212, "prompt_eval_sec": 0.044120755, "tokens_completion": 60, "completion_eval_sec": 1.367679587, "tokens_total": 272, "tokens_per_sec": 157.25969620507914, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average age of clients with 'Personal Injury' cases that resulted in a 'Lost' outcome. The only differences are table aliasing (reference uses 'C', 'CA', 'CO' while generated uses explicit table names) and column reference style (reference uses 'C.Age' vs generated 'Clients.Age'). These syntactic variations do not affect the semantic result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are structurally identical in logic and syntax, with the only difference being table aliases (reference uses 'C' and 'CA', generated uses full table names). They correctly join Clients, Cases, and CaseOutcomes on the same keys, apply the same filters (Category = 'Personal Injury' and Outcome = 'Lost'), and calculate the average age. Both address the business intent by focusing on clients who lost cases in the specified category. Neither query demonstrates superior efficiency or elegance over the other, as they perform the same operations with equivalent readability.", "overall_assessment": "correct"}}
{"example_id": 4388, "sql_complexity": "subqueries", "prompt": "Insert a new drug with a price 10% higher than the average price", "context": "CREATE TABLE drugs (drug_id INT, drug_name VARCHAR(50), price DECIMAL(10, 2)); INSERT INTO drugs (drug_id, drug_name, price) VALUES (1, 'DrugA', 50), (2, 'DrugB', 75), (3, 'DrugC', 100)", "reference_sql": "INSERT INTO drugs (drug_id, drug_name, price) VALUES ((SELECT MAX(drug_id) FROM drugs) + 1, 'DrugD', (SELECT AVG(price) * 1.1 FROM drugs))", "generated_sql": "INSERT INTO drugs (drug_id, drug_name, price)\nSELECT MAX(drug_id) + 1, 'NewDrug', AVG(price) * 1.10 AS price\nFROM drugs;", "raw_model_output": "```sql\nINSERT INTO drugs (drug_id, drug_name, price)\nSELECT MAX(drug_id) + 1, 'NewDrug', AVG(price) * 1.10 AS price\nFROM drugs;\n```", "latency_sec": 1.1388661861419678, "total_duration_sec": 1.085678534, "load_duration_sec": 0.015781079, "tokens_prompt": 165, "prompt_eval_sec": 0.032898394, "tokens_completion": 46, "completion_eval_sec": 1.034544712, "tokens_total": 211, "tokens_per_sec": 185.27198591678737, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the drug_name value being inserted ('DrugD' vs 'NewDrug'). While the calculations for drug_id and price are equivalent, the inserted drug names are different, leading to distinct results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the average price of existing drugs and insert a new drug with a 10% higher price. The reference query uses scalar subqueries in the VALUES clause, while the generated query uses a SELECT statement with implicit table reference. Both achieve the same result: drug_id = MAX(drug_id) + 1, price = AVG(price) * 1.1. The drug name difference ('DrugD' vs 'NewDrug') is irrelevant since the question doesn't specify a name. Both queries are syntactically valid and semantically equivalent.", "overall_assessment": "correct"}}
{"example_id": 5431, "sql_complexity": "basic SQL", "prompt": "What is the average CO2 emission of ride-hailing vehicles in San Francisco?", "context": "CREATE TABLE SFRideHailing (id INT, company VARCHAR(20), co2_emission DECIMAL(5,2));", "reference_sql": "SELECT AVG(co2_emission) FROM SFRideHailing WHERE company = 'Uber';", "generated_sql": "SELECT AVG(co2_emission) AS average_co2_emission\nFROM SFRideHailing;", "raw_model_output": "```sql\nSELECT AVG(co2_emission) AS average_co2_emission\nFROM SFRideHailing;\n```", "latency_sec": 0.7231371402740479, "total_duration_sec": 0.619835316, "load_duration_sec": 0.019510163, "tokens_prompt": 120, "prompt_eval_sec": 0.025027724, "tokens_completion": 26, "completion_eval_sec": 0.571630705, "tokens_total": 146, "tokens_per_sec": 201.89807972616407, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the average co2_emission specifically for rides from 'Uber' (due to the WHERE company = 'Uber' condition), while the Generated SQL calculates the average for all companies in the table without any filtering. Unless all rows in SFRideHailing belong to Uber (which is not guaranteed by the schema), the results would differ.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query is technically incorrect for the question as it explicitly filters for 'Uber' which is not mentioned in the original question. The generated query correctly calculates the average CO2 emission for all ride-hailing vehicles in San Francisco without arbitrary company restrictions. While both queries compute the same metric (AVG(co2_emission)), the generated query aligns with the business intent of analyzing all ride-hailing vehicles rather than a subset. The generated query is more elegant as it avoids unnecessary constraints and directly addresses the unqualified scope of the question.", "overall_assessment": "correct"}}
{"example_id": 3531, "sql_complexity": "single join", "prompt": "What is the total number of workouts and total workout time per user for users with a membership type of 'Basic'?", "context": "CREATE TABLE Members (id INT, user_name VARCHAR, membership_type VARCHAR, signup_date DATE); CREATE TABLE Workouts (id INT, user_id INT, workout_date DATE, workout_duration INT); INSERT INTO Members (id, user_name, membership_type, signup_date) VALUES (1, 'John Doe', 'Premium', '2020-01-01'), (2, 'Jane Smith', 'Basic', '2019-06-15'), (3, 'Alice Johnson', 'Premium', '2020-03-20'); INSERT INTO Workouts (id, user_id, workout_date, workout_duration) VALUES (1, 1, '2020-01-01', 60), (2, 1, '2020-01-02', 70), (3, 2, '2019-06-15', 90), (4, 3, '2020-03-20', 65), (5, 3, '2020-03-21', 70);", "reference_sql": "SELECT Members.user_name, SUM(Workouts.workout_duration) AS total_workout_time, COUNT(Workouts.id) AS total_workouts FROM Members JOIN Workouts ON Members.id = Workouts.user_id WHERE Members.membership_type = 'Basic' GROUP BY Members.user_name;", "generated_sql": "SELECT \n    M.user_name,\n    COUNT(W.id) AS total_workouts,\n    SUM(W.workout_duration) AS total_workout_time\nFROM \n    Members M\nJOIN \n    Workouts W ON M.id = W.user_id\nWHERE \n    M.membership_type = 'Basic'\nGROUP BY \n    M.user_name;", "raw_model_output": "```sql\nSELECT \n    M.user_name,\n    COUNT(W.id) AS total_workouts,\n    SUM(W.workout_duration) AS total_workout_time\nFROM \n    Members M\nJOIN \n    Workouts W ON M.id = W.user_id\nWHERE \n    M.membership_type = 'Basic'\nGROUP BY \n    M.user_name;\n```", "latency_sec": 2.0447161197662354, "total_duration_sec": 1.848821862, "load_duration_sec": 0.015613212, "tokens_prompt": 348, "prompt_eval_sec": 0.078689883, "tokens_completion": 74, "completion_eval_sec": 1.751494864, "tokens_total": 422, "tokens_per_sec": 206.3856179938786, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same data by joining Members and Workouts tables on user_id, filtering for 'Basic' membership type, and grouping by user_name. The generated query uses table aliases (M/W) and reorders the selected columns, but these syntactic differences do not affect the semantic result. The aggregation functions (SUM and COUNT) and their operands are identical in both queries.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically correct and produce identical results. They join the Members and Workouts tables on user_id, filter for 'Basic' membership, and group by user_name to calculate total workouts and total workout time. The reference query uses explicit table names while the generated query uses aliases (M and W), which is a stylistic choice. The column order differs (total_workout_time vs. total_workout_time), but the data itself is identical. Both fulfill the business intent of counting workouts and summing durations for Basic members. The generated query is slightly more concise with aliases, but neither is objectively superior in functionality.", "overall_assessment": "correct"}}
{"example_id": 5678, "sql_complexity": "set operations", "prompt": "How many public works projects are there in 'Sydney' and 'Melbourne' combined?", "context": "CREATE TABLE PublicWorksC(id INT, city VARCHAR(20), project VARCHAR(30)); INSERT INTO PublicWorksC(id, city, project) VALUES (1, 'Sydney', 'Park Renovation'), (2, 'Melbourne', 'Sidewalk Repair');", "reference_sql": "SELECT COUNT(*) FROM (SELECT city FROM PublicWorksC WHERE city = 'Sydney' UNION ALL SELECT city FROM PublicWorksC WHERE city = 'Melbourne') AS Total;", "generated_sql": "SELECT COUNT(*) AS total_projects\nFROM PublicWorksC\nWHERE city IN ('Sydney', 'Melbourne');", "raw_model_output": "```sql\nSELECT COUNT(*) AS total_projects\nFROM PublicWorksC\nWHERE city IN ('Sydney', 'Melbourne');\n```", "latency_sec": 0.7675390243530273, "total_duration_sec": 0.671857376, "load_duration_sec": 0.01591966, "tokens_prompt": 152, "prompt_eval_sec": 0.030754014, "tokens_completion": 28, "completion_eval_sec": 0.622337351, "tokens_total": 180, "tokens_per_sec": 234.51576309325156, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of rows in PublicWorksC where the city is either 'Sydney' or 'Melbourne'. The Reference SQL uses a UNION ALL subquery to combine results from two separate SELECTs, while the Generated SQL uses a single WHERE clause with IN. Since UNION ALL preserves duplicates and the WHERE IN clause includes all matching rows, both approaches yield the same count. The sample data (1 Sydney, 1 Melbourne) would return 2 in both cases, and this holds for all possible data scenarios.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count projects in Sydney and Melbourne. The reference query uses a UNION ALL subquery to combine results, while the generated query uses a simpler WHERE IN clause. Technically, they produce identical results because both count all rows matching the cities. However, the generated query is more efficient (single table scan vs two subqueries) and elegant. The business intent of combining counts for both cities is fulfilled equally by both.", "overall_assessment": "correct"}}
{"example_id": 5792, "sql_complexity": "multiple_joins", "prompt": "How many cases were handled by attorneys in the 'Los Angeles' office?", "context": "CREATE TABLE offices (office_id INT, office_name VARCHAR(20), city VARCHAR(20), state VARCHAR(20)); INSERT INTO offices (office_id, office_name, city, state) VALUES (1, 'Boston', 'Boston', 'MA'), (2, 'New York', 'New York', 'NY'), (3, 'Los Angeles', 'Los Angeles', 'CA'); CREATE TABLE attorneys (attorney_id INT, office_id INT); INSERT INTO attorneys (attorney_id, office_id) VALUES (1, 1), (2, 2), (3, 3); CREATE TABLE cases (case_id INT, attorney_id INT); INSERT INTO cases (case_id, attorney_id) VALUES (1, 1), (2, 2), (3, 3);", "reference_sql": "SELECT COUNT(*) FROM cases JOIN attorneys ON cases.attorney_id = attorneys.attorney_id JOIN offices ON attorneys.office_id = offices.office_id WHERE offices.city = 'Los Angeles';", "generated_sql": "SELECT COUNT(*) AS num_cases\nFROM cases c\nJOIN attorneys a ON c.attorney_id = a.attorney_id\nJOIN offices o ON a.office_id = o.office_id\nWHERE o.city = 'Los Angeles';", "raw_model_output": "```sql\nSELECT COUNT(*) AS num_cases\nFROM cases c\nJOIN attorneys a ON c.attorney_id = a.attorney_id\nJOIN offices o ON a.office_id = o.office_id\nWHERE o.city = 'Los Angeles';\n```", "latency_sec": 1.688960075378418, "total_duration_sec": 1.216209783, "load_duration_sec": 0.015088433, "tokens_prompt": 257, "prompt_eval_sec": 0.053428523, "tokens_completion": 50, "completion_eval_sec": 1.14518586, "tokens_total": 307, "tokens_per_sec": 181.76865425976126, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform the same three-table join (cases \u2192 attorneys \u2192 offices) with identical join conditions and filter criteria (offices.city = 'Los Angeles'). The generated query uses table aliases (c, a, o) and adds an alias (num_cases) for the COUNT(*) column, but these are syntactic variations that do not affect the semantic result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count cases handled by attorneys in the 'Los Angeles' office by joining cases, attorneys, and offices tables with the same logical condition (offices.city = 'Los Angeles'). The generated query uses table aliases (c, a, o) which improves readability without altering functionality. The reference query is also correct but less concise. Both produce identical results and address the business question accurately.", "overall_assessment": "correct"}}
{"example_id": 5148, "sql_complexity": "window functions", "prompt": "List the unique types of smart city technologies that have been implemented in the top 3 most populous countries in the world.", "context": "CREATE TABLE smart_city_tech (tech_type VARCHAR(255), country VARCHAR(255)); CREATE TABLE country_populations (country VARCHAR(255), population INT);", "reference_sql": "SELECT DISTINCT tech_type FROM smart_city_tech SCT WHERE country IN (SELECT country FROM (SELECT country, ROW_NUMBER() OVER (ORDER BY population DESC) as rank FROM country_populations) CP WHERE rank <= 3);", "generated_sql": "SELECT DISTINCT tech_type\nFROM smart_city_tech\nWHERE country IN (\n    SELECT country\n    FROM country_populations\n    ORDER BY population DESC\n    LIMIT 3\n);", "raw_model_output": "```sql\nSELECT DISTINCT tech_type\nFROM smart_city_tech\nWHERE country IN (\n    SELECT country\n    FROM country_populations\n    ORDER BY population DESC\n    LIMIT 3\n);\n```", "latency_sec": 1.1700971126556396, "total_duration_sec": 0.972105522, "load_duration_sec": 0.015581588, "tokens_prompt": 138, "prompt_eval_sec": 0.027768714, "tokens_completion": 42, "completion_eval_sec": 0.926599346, "tokens_total": 180, "tokens_per_sec": 153.83338532600425, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select distinct tech_type values from smart_city_tech where the country is in the top 3 countries by population. The reference query uses a window function to rank countries by population and filters for rank <= 3, while the generated query uses ORDER BY population DESC with LIMIT 3. Since both approaches retrieve the same set of top 3 countries (assuming deterministic ordering), the final results will be identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify unique smart city technologies in the top 3 most populous countries. The reference query uses a window function with ROW_NUMBER() to rank countries, while the generated query uses ORDER BY + LIMIT 3. Technically, they are equivalent under the assumption that country_populations has unique population values (no ties). However, the generated query is more efficient and elegant, as LIMIT 3 is simpler than a window function approach. Both fulfill the business intent, but the generated query achieves it with better performance and readability.", "overall_assessment": "correct"}}
{"example_id": 5547, "sql_complexity": "multiple_joins", "prompt": "Which species have a population growth rate higher than the average for protected areas?", "context": "CREATE TABLE species (id INT, name VARCHAR(50), population DECIMAL(5,2), protected_area_id INT, growth_rate DECIMAL(5,2)); INSERT INTO species (id, name, population, protected_area_id, growth_rate) VALUES (1, 'Species 1', 500.00, 1, 0.05), (2, 'Species 2', 800.00, 1, 0.03), (3, 'Species 3', 1200.00, 2, 0.07), (4, 'Species 4', 700.00, 2, 0.02); CREATE TABLE protected_areas (id INT, name VARCHAR(50)); INSERT INTO protected_areas (id, name) VALUES (1, 'Area 1'), (2, 'Area 2');", "reference_sql": "SELECT s.name, s.growth_rate FROM species s INNER JOIN protected_areas pa ON s.protected_area_id = pa.id GROUP BY s.name, s.growth_rate HAVING s.growth_rate > (SELECT AVG(s.growth_rate) FROM species s INNER JOIN protected_areas pa ON s.protected_area_id = pa.id);", "generated_sql": "SELECT s.name \nFROM species s\nJOIN (\n    SELECT protected_area_id, AVG(growth_rate) AS avg_growth_rate\n    FROM species\n    GROUP BY protected_area_id\n) pa ON s.protected_area_id = pa.protected_area_id\nWHERE s.growth_rate > pa.avg_growth_rate;", "raw_model_output": "```sql\nSELECT s.name \nFROM species s\nJOIN (\n    SELECT protected_area_id, AVG(growth_rate) AS avg_growth_rate\n    FROM species\n    GROUP BY protected_area_id\n) pa ON s.protected_area_id = pa.protected_area_id\nWHERE s.growth_rate > pa.avg_growth_rate;\n```", "latency_sec": 1.7040979862213135, "total_duration_sec": 1.642524729, "load_duration_sec": 0.0197195, "tokens_prompt": 285, "prompt_eval_sec": 0.057370242, "tokens_completion": 68, "completion_eval_sec": 1.563358971, "tokens_total": 353, "tokens_per_sec": 207.14771266336996, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL compares species growth rates to the overall average growth rate across all protected areas, while the Generated SQL compares them to the average growth rate within their specific protected area. The HAVING clause in the Reference SQL uses a global average (from a subquery without grouping), whereas the Generated SQL uses a per-protected-area average from a derived table. This fundamental difference in aggregation scope makes the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries differ fundamentally in their approach to calculating the average growth rate. The Reference SQL computes a single global average growth rate for all species across all protected areas, while the Generated SQL calculates a per-protected-area average. The original question's phrasing ('average for protected areas') is ambiguous, but the Generated SQL better aligns with the likely business intent of comparing species growth rates to their specific protected area's average. The Reference SQL's approach would only be correct if the question intended a single overall average, which is less probable given the context of protected areas. Both queries have technical correctness, but their semantic equivalence depends on interpretation of the original question.", "overall_assessment": "differently_correct"}}
{"example_id": 5498, "sql_complexity": "aggregation", "prompt": "Identify the destinations with the highest number of repeat visitors from the US.", "context": "CREATE TABLE RepeatTravelers (Visitor VARCHAR(20), Destination VARCHAR(20), VisitCount INT); INSERT INTO RepeatTravelers (Visitor, Destination, VisitCount) VALUES ('David', 'Paris', 3), ('Ella', 'London', 4), ('Fiona', 'Paris', 2);", "reference_sql": "SELECT Destination, AVG(VisitCount) AS AvgVisitCount FROM RepeatTravelers WHERE Visitor LIKE '%USA%' GROUP BY Destination ORDER BY AvgVisitCount DESC;", "generated_sql": "SELECT Destination, MAX(VisitCount) AS MaxVisits\nFROM RepeatTravelers\nWHERE Visitor IN (\n    SELECT Visitor\n    FROM RepeatTravelers\n    WHERE Destination = 'US'\n)\nGROUP BY Destination;", "raw_model_output": "```sql\nSELECT Destination, MAX(VisitCount) AS MaxVisits\nFROM RepeatTravelers\nWHERE Visitor IN (\n    SELECT Visitor\n    FROM RepeatTravelers\n    WHERE Destination = 'US'\n)\nGROUP BY Destination;\n```", "latency_sec": 1.2377429008483887, "total_duration_sec": 1.148261811, "load_duration_sec": 0.015031885, "tokens_prompt": 156, "prompt_eval_sec": 0.030682634, "tokens_completion": 49, "completion_eval_sec": 1.099664736, "tokens_total": 205, "tokens_per_sec": 165.62405638480044, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates the average VisitCount for destinations where the Visitor name contains 'USA', while the generated query finds the maximum VisitCount for destinations where the Visitor's Destination is 'US'. They differ in both the aggregation function (AVG vs MAX) and the filtering condition (Visitor name pattern vs Destination value). Additionally, the sample data contains no entries matching 'US' as a destination, making the generated query return no rows, whereas the reference query would also return no rows due to no 'USA' in Visitor names. However, their logic and intended data subsets differ fundamentally.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent. The reference query uses AVG(VisitCount) on visitors matching '%USA%' (which would return no results in the sample data), while the generated query uses MAX(VisitCount) on visitors whose destination is 'US' (also invalid in the sample data). Neither correctly identifies US visitors, as the schema lacks a country field. The reference query better aligns with the intent of analyzing repeat visitors (via VisitCount) but is flawed in filtering. The generated query incorrectly filters by Destination='US' instead of Visitor country. Both fail to address the actual question due to schema limitations, but the reference query's approach is more semantically aligned with the intent.", "overall_assessment": "differently_correct"}}
{"example_id": 3546, "sql_complexity": "window functions", "prompt": "What are the cryptocurrency exchanges with their corresponding blockchain companies, ranked by exchange ID in ascending order, for the Bitcoin platform?", "context": "CREATE TABLE cryptocurrency_exchanges (exchange_id INT, exchange_name VARCHAR(50), company_id INT); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (1, 'Binance', 1); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (2, 'Coinbase', 2); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (3, 'Kraken', 3); CREATE TABLE blockchain_companies (company_id INT, company_name VARCHAR(50), platform VARCHAR(50)); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (1, 'Binance', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (2, 'Blockstream', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (3, 'Blockchair', 'Bitcoin');", "reference_sql": "SELECT ce.exchange_name, bc.company_name, ce.exchange_id, ROW_NUMBER() OVER (PARTITION BY bc.platform ORDER BY ce.exchange_id ASC) as rank FROM cryptocurrency_exchanges ce JOIN blockchain_companies bc ON ce.company_id = bc.company_id WHERE bc.platform = 'Bitcoin';", "generated_sql": "SELECT \n    ce.exchange_id,\n    ce.exchange_name,\n    bc.company_name\nFROM \n    cryptocurrency_exchanges ce\nJOIN \n    blockchain_companies bc ON ce.company_id = bc.company_id\nWHERE \n    bc.platform = 'Bitcoin'\nORDER BY \n    ce.exchange_id ASC;", "raw_model_output": "```sql\nSELECT \n    ce.exchange_id,\n    ce.exchange_name,\n    bc.company_name\nFROM \n    cryptocurrency_exchanges ce\nJOIN \n    blockchain_companies bc ON ce.company_id = bc.company_id\nWHERE \n    bc.platform = 'Bitcoin'\nORDER BY \n    ce.exchange_id ASC;\n```", "latency_sec": 1.867154836654663, "total_duration_sec": 1.561959231, "load_duration_sec": 0.015479266, "tokens_prompt": 297, "prompt_eval_sec": 0.064995134, "tokens_completion": 64, "completion_eval_sec": 1.478636166, "tokens_total": 361, "tokens_per_sec": 193.3422943363364, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL includes a ROW_NUMBER() column and selects different columns (exchange_name, company_name, exchange_id) compared to the Generated SQL, which selects exchange_id, exchange_name, and company_name. Additionally, the Reference SQL uses a window function with PARTITION BY and ORDER BY, while the Generated SQL uses a simple ORDER BY. The presence of the row number column and differing column order in the SELECT clause make the result sets structurally different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query includes a ROW_NUMBER() ranking column which was not requested in the original question. While both queries correctly join the tables and filter for 'Bitcoin', the generated query directly addresses the requirement to 'rank by exchange ID in ascending order' through ORDER BY rather than adding an explicit rank column. The generated query is more efficient (no window function) and avoids unnecessary complexity. The reference query's ranking logic is technically correct but semantically misaligned with the business intent.", "overall_assessment": "differently_correct"}}
{"example_id": 486, "sql_complexity": "single join", "prompt": "What is the average price of paintings from African artists in our collection?", "context": "CREATE TABLE Artworks (id INT, title VARCHAR(50), price DECIMAL(10,2), medium VARCHAR(50), artist_nationality VARCHAR(50)); CREATE TABLE Collections (id INT, name VARCHAR(50), continent VARCHAR(50));", "reference_sql": "SELECT AVG(Artworks.price) FROM Artworks INNER JOIN Collections ON Artworks.artist_nationality = Collections.continent WHERE Artworks.medium = 'Painting' AND Collections.continent = 'Africa';", "generated_sql": "SELECT AVG(price) AS average_price\nFROM Artworks\nWHERE artist_nationality = 'African';", "raw_model_output": "```sql\nSELECT AVG(price) AS average_price\nFROM Artworks\nWHERE artist_nationality = 'African';\n```", "latency_sec": 0.7553451061248779, "total_duration_sec": 0.653214975, "load_duration_sec": 0.0152892, "tokens_prompt": 147, "prompt_eval_sec": 0.028389004, "tokens_completion": 27, "completion_eval_sec": 0.606793649, "tokens_total": 174, "tokens_per_sec": 230.3582807237164, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the average price of 'Painting' artworks where artist_nationality matches the 'Africa' continent in Collections. The Generated SQL averages all artworks with artist_nationality = 'African' (not 'Africa') and omits the medium filter. Differences in filtering conditions ('Africa' vs 'African') and missing medium constraint make them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The Reference SQL incorrectly joins Artworks.artist_nationality with Collections.continent (e.g., 'Kenyan' vs 'Africa'), and the WHERE clause redundantly filters Collections.continent = 'Africa'. The Generated SQL directly filters Artworks where artist_nationality = 'African', which aligns with the question's explicit focus on African artists. While both aim to calculate the average price of paintings, the Generated SQL avoids unnecessary joins and assumes the artist_nationality field is correctly labeled as 'African', which is more direct for the given schema. The Reference SQL's logic is flawed due to incorrect join conditions and redundant filters.", "overall_assessment": "differently_correct"}}
{"example_id": 794, "sql_complexity": "multiple_joins", "prompt": "Which suppliers have provided raw materials for the production of chemicals with high environmental impact?", "context": "CREATE TABLE suppliers (id INT, name TEXT); INSERT INTO suppliers (id, name) VALUES (1, 'Supplier1'), (2, 'Supplier2'), (3, 'Supplier3'); CREATE TABLE chemicals (id INT, name TEXT, environmental_impact INT); INSERT INTO chemicals (id, name, environmental_impact) VALUES (1, 'ChemA', 10), (2, 'ChemB', 20), (3, 'ChemC', 15); CREATE TABLE raw_materials (chemical_id INT, supplier_id INT); INSERT INTO raw_materials (chemical_id, supplier_id) VALUES (1, 1), (1, 2), (2, 3), (3, 1);", "reference_sql": "SELECT s.name FROM suppliers s INNER JOIN raw_materials rm ON s.id = rm.supplier_id INNER JOIN chemicals c ON rm.chemical_id = c.id WHERE c.environmental_impact > 10;", "generated_sql": "SELECT DISTINCT s.name AS supplier_name\nFROM suppliers s\nJOIN raw_materials rm ON s.id = rm.supplier_id\nJOIN chemicals c ON rm.chemical_id = c.id\nWHERE c.environmental_impact > 15;", "raw_model_output": "```sql\nSELECT DISTINCT s.name AS supplier_name\nFROM suppliers s\nJOIN raw_materials rm ON s.id = rm.supplier_id\nJOIN chemicals c ON rm.chemical_id = c.id\nWHERE c.environmental_impact > 15;\n```", "latency_sec": 1.5091660022735596, "total_duration_sec": 1.303313603, "load_duration_sec": 0.016335593, "tokens_prompt": 244, "prompt_eval_sec": 0.052051838, "tokens_completion": 54, "completion_eval_sec": 1.232102952, "tokens_total": 298, "tokens_per_sec": 197.4600537986297, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects: 1) The Reference SQL uses WHERE c.environmental_impact > 10 while the Generated SQL uses > 15, filtering different sets of chemicals. 2) The Generated SQL includes DISTINCT which could eliminate duplicate supplier names, whereas the Reference SQL does not. These differences would produce different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in their environmental impact thresholds (10 vs. 15), leading to different results. The reference query (c.environmental_impact > 10) includes chemicals with impact 15 (ChemC) and 20 (ChemB), while the generated query (c.environmental_impact > 15) only includes ChemB. The original question asks for 'high environmental impact' without defining the threshold, but the reference's lower threshold (10) is more inclusive and aligns better with typical interpretations of 'high' in environmental contexts. The generated query's stricter condition (15) may exclude suppliers linked to chemicals with moderate impact (e.g., ChemC). Additionally, the generated query uses DISTINCT, which is unnecessary in this dataset but doesn't harm correctness. However, the reference query better fulfills the ambiguous business intent by capturing a broader range of suppliers.", "overall_assessment": "differently_correct"}}
{"example_id": 3164, "sql_complexity": "set operations", "prompt": "What is the average age of patients who received therapy in 'clinic_a' and 'clinic_b'?", "context": "CREATE TABLE clinic_a (patient_id INT, age INT, therapy_received BOOLEAN); INSERT INTO clinic_a (patient_id, age, therapy_received) VALUES (1, 35, true), (2, 42, true), (3, 28, false); CREATE TABLE clinic_b (patient_id INT, age INT, therapy_received BOOLEAN); INSERT INTO clinic_b (patient_id, age, therapy_received) VALUES (4, 50, true), (5, 32, false), (6, 45, true);", "reference_sql": "SELECT AVG(age) FROM (SELECT age FROM clinic_a WHERE therapy_received = true UNION ALL SELECT age FROM clinic_b WHERE therapy_received = true) AS combined_clinics;", "generated_sql": "SELECT AVG(age) AS average_age\nFROM (\n    SELECT age FROM clinic_a WHERE therapy_received = true\n    UNION ALL\n    SELECT age FROM clinic_b WHERE therapy_received = true\n) AS patients_who_received_therapy;", "raw_model_output": "```sql\nSELECT AVG(age) AS average_age\nFROM (\n    SELECT age FROM clinic_a WHERE therapy_received = true\n    UNION ALL\n    SELECT age FROM clinic_b WHERE therapy_received = true\n) AS patients_who_received_therapy;\n```", "latency_sec": 1.3771090507507324, "total_duration_sec": 1.252233899, "load_duration_sec": 0.015405364, "tokens_prompt": 211, "prompt_eval_sec": 0.046302696, "tokens_completion": 52, "completion_eval_sec": 1.187344821, "tokens_total": 263, "tokens_per_sec": 190.97979194648767, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average age of patients who received therapy from both clinics. The subquery structure, filtering condition (therapy_received = true), and use of UNION ALL to combine results from clinic_a and clinic_b are identical. The only differences are the table aliases (combined_clinics vs patients_who_received_therapy) and a column alias (average_age) in the outer query, which do not affect the semantic result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the average age of patients who received therapy in clinic_a and clinic_b. They use identical logic: filtering therapy_received=true in both tables, combining results with UNION ALL, and applying AVG(age). The differences are purely syntactic (alias names) and do not affect results. Both queries efficiently address the business question by focusing on patients who actually received therapy, combining data from both clinics, and computing the average age accurately.", "overall_assessment": "correct"}}
{"example_id": 3704, "sql_complexity": "aggregation", "prompt": "What is the total sales revenue for each category of garments in the South America region in Q1 2022?", "context": "CREATE TABLE sales_category (sale_id INT, garment_category VARCHAR(50), sale_date DATE, total_sales DECIMAL(10, 2), region VARCHAR(50));", "reference_sql": "SELECT garment_category, SUM(total_sales) FROM sales_category WHERE sale_date BETWEEN '2022-01-01' AND '2022-03-31' AND region = 'South America' GROUP BY garment_category;", "generated_sql": "SELECT \n    garment_category, \n    SUM(total_sales) AS total_revenue\nFROM \n    sales_category\nWHERE \n    region = 'South America' \n    AND sale_date BETWEEN '2022-01-01' AND '2022-03-31'\nGROUP BY \n    garment_category;", "raw_model_output": "```sql\nSELECT \n    garment_category, \n    SUM(total_sales) AS total_revenue\nFROM \n    sales_category\nWHERE \n    region = 'South America' \n    AND sale_date BETWEEN '2022-01-01' AND '2022-03-31'\nGROUP BY \n    garment_category;\n```", "latency_sec": 2.0194802284240723, "total_duration_sec": 1.719917518, "load_duration_sec": 0.015855801, "tokens_prompt": 138, "prompt_eval_sec": 0.027896068, "tokens_completion": 75, "completion_eval_sec": 1.673140558, "tokens_total": 213, "tokens_per_sec": 105.47268401147821, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. The generated query adds an alias (total_revenue) for the aggregated column, but this does not affect the result set's data. Both queries filter identical rows (region = 'South America' and sale_date in the same range), group by the same column (garment_category), and calculate the same aggregation (SUM(total_sales)). The order of conditions in the WHERE clause is irrelevant due to logical AND equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically equivalent as they produce identical results through equivalent logic (same columns, filters, and grouping). The generated query improves on the reference by explicitly aliasing the aggregated column as 'total_revenue', which better aligns with the business question's terminology ('total sales revenue'). While both fulfill the intent, the generated query's clarity in naming enhances readability and direct relevance to the requested metric. Neither query has efficiency issues, but the generated version demonstrates slightly better query craftsmanship.", "overall_assessment": "correct"}}
{"example_id": 2851, "sql_complexity": "single join", "prompt": "How many cases were handled by attorneys who joined the firm in 2015 or later?", "context": "CREATE TABLE attorneys (attorney_id INT, join_year INT); CREATE TABLE cases (case_id INT, attorney_id INT, billing_amount INT);", "reference_sql": "SELECT COUNT(DISTINCT cases.case_id) FROM cases INNER JOIN attorneys ON cases.attorney_id = attorneys.attorney_id WHERE attorneys.join_year >= 2015;", "generated_sql": "SELECT COUNT(*) \nFROM cases \nWHERE attorney_id IN (\n    SELECT attorney_id \n    FROM attorneys \n    WHERE join_year >= 2015\n);", "raw_model_output": "```sql\nSELECT COUNT(*) \nFROM cases \nWHERE attorney_id IN (\n    SELECT attorney_id \n    FROM attorneys \n    WHERE join_year >= 2015\n);\n```", "latency_sec": 0.9235329627990723, "total_duration_sec": 0.89037991, "load_duration_sec": 0.01581616, "tokens_prompt": 125, "prompt_eval_sec": 0.024848095, "tokens_completion": 38, "completion_eval_sec": 0.847125623, "tokens_total": 163, "tokens_per_sec": 176.49613664679012, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of cases where the associated attorney joined in 2015 or later. The reference query uses a JOIN and COUNT(DISTINCT case_id), while the generated query uses a subquery with IN and COUNT(*). Since each case is linked to exactly one attorney (assuming foreign key integrity), the COUNT(DISTINCT case_id) in the reference query effectively counts unique cases, which matches the generated query's COUNT(*) when filtering the same set of cases. The subquery in the generated query ensures only valid attorney_ids from the desired join_year are considered, making the results equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly answer the question by identifying cases handled by attorneys who joined in 2015 or later. The reference query uses an INNER JOIN with COUNT(DISTINCT) to ensure unique case counts, while the generated query uses a subquery with IN and COUNT(*). Since the cases table likely contains unique case_id values per case (based on schema design), both approaches produce identical results. The reference query may be slightly more efficient due to JOIN optimization potential, but both are semantically equivalent. Neither query has logical errors, and both fulfill the business intent of counting cases handled by qualifying attorneys.", "overall_assessment": "correct"}}
{"example_id": 3246, "sql_complexity": "single join", "prompt": "What is the average eco-friendliness score of accommodations in Oceania by year?", "context": "CREATE TABLE Accommodations (Accommodation_ID INT, Accommodation_Name VARCHAR(50), City VARCHAR(30), Country VARCHAR(50), Eco_Friendliness_Score INT, Visit_Year INT); INSERT INTO Accommodations (Accommodation_ID, Accommodation_Name, City, Country, Eco_Friendliness_Score, Visit_Year) VALUES (1, 'EcoLodge', 'Sydney', 'Australia', 85, 2019), (2, 'GreenHotel', 'Melbourne', 'Australia', 90, 2019), (3, 'SustainableResort', 'Auckland', 'New Zealand', 80, 2019), (4, 'EcoVilla', 'Wellington', 'New Zealand', 88, 2019); CREATE TABLE Countries (Country VARCHAR(50), Continent VARCHAR(30)); INSERT INTO Countries (Country, Continent) VALUES ('Australia', 'Oceania'), ('New Zealand', 'Oceania');", "reference_sql": "SELECT C.Continent, V.Visit_Year, AVG(A.Eco_Friendliness_Score) AS Avg_Eco_Score  FROM Accommodations A  JOIN Countries C  ON A.Country = C.Country  WHERE C.Continent = 'Oceania'  GROUP BY C.Continent, V.Visit_Year  ORDER BY V.Visit_Year;", "generated_sql": "SELECT \n    A.Visit_Year,\n    AVG(A.Eco_Friendliness_Score) AS Average_Eco_Friendliness_Score\nFROM \n    Accommodations A\nJOIN \n    Countries C ON A.Country = C.Country\nWHERE \n    C.Continent = 'Oceania'\nGROUP BY \n    A.Visit_Year;", "raw_model_output": "```sql\nSELECT \n    A.Visit_Year,\n    AVG(A.Eco_Friendliness_Score) AS Average_Eco_Friendliness_Score\nFROM \n    Accommodations A\nJOIN \n    Countries C ON A.Country = C.Country\nWHERE \n    C.Continent = 'Oceania'\nGROUP BY \n    A.Visit_Year;\n```", "latency_sec": 2.160362958908081, "total_duration_sec": 1.868465576, "load_duration_sec": 0.015030863, "tokens_prompt": 316, "prompt_eval_sec": 0.065464682, "tokens_completion": 77, "completion_eval_sec": 1.785609243, "tokens_total": 393, "tokens_per_sec": 181.91387626764126, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes 'Continent' in both the SELECT and GROUP BY clauses, while the Generated SQL omits it. Although the WHERE clause restricts to 'Oceania', the output structure differs (three columns vs. two), making them non-equivalent. The Generated SQL also groups by only 'Visit_Year', which would still work due to the fixed continent, but the missing 'Continent' column in the result makes the queries produce different outputs.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the average eco-friendliness score for Oceania accommodations by year. The reference query includes the 'Continent' column in the output and GROUP BY, but since the WHERE clause filters to 'Oceania', this column is redundant and doesn't affect the result. The generated query is more efficient by omitting unnecessary columns and simplifying the GROUP BY clause while maintaining identical semantic results. Both fulfill the business intent of analyzing eco-scores by year for Oceania, but the generated query achieves this with cleaner syntax.", "overall_assessment": "differently_correct"}}
{"example_id": 3056, "sql_complexity": "multiple_joins", "prompt": "Identify all suppliers who provide non-GMO ingredients to restaurants with Michelin stars.", "context": "CREATE TABLE Suppliers (id INT, name VARCHAR(50), isNonGMO BOOLEAN); CREATE TABLE Restaurants (id INT, name VARCHAR(50), numStars INT); CREATE TABLE Ingredients (supplierId INT, restaurantId INT, isNonGMO BOOLEAN);", "reference_sql": "SELECT Suppliers.name FROM Suppliers INNER JOIN Ingredients ON Suppliers.id = Ingredients.supplierId INNER JOIN Restaurants ON Ingredients.restaurantId = Restaurants.id WHERE Restaurants.numStars > 2 AND Ingredients.isNonGMO = TRUE;", "generated_sql": "SELECT DISTINCT s.id, s.name\nFROM Suppliers s\nJOIN Ingredients i ON s.id = i.supplierId\nJOIN Restaurants r ON i.restaurantId = r.id\nWHERE s.isNonGMO = TRUE AND r.numStars > 0;", "raw_model_output": "```sql\nSELECT DISTINCT s.id, s.name\nFROM Suppliers s\nJOIN Ingredients i ON s.id = i.supplierId\nJOIN Restaurants r ON i.restaurantId = r.id\nWHERE s.isNonGMO = TRUE AND r.numStars > 0;\n```", "latency_sec": 1.4005091190338135, "total_duration_sec": 1.299363262, "load_duration_sec": 0.015725387, "tokens_prompt": 147, "prompt_eval_sec": 0.027801522, "tokens_completion": 56, "completion_eval_sec": 1.253093022, "tokens_total": 203, "tokens_per_sec": 144.94728898305647, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in several key aspects. 1) The Reference SQL selects only the 'name' column from Suppliers, while the Generated SQL selects both 'id' and 'name'. 2) The WHERE clause in the Reference SQL checks for Restaurants.numStars > 2 and Ingredients.isNonGMO = TRUE, whereas the Generated SQL checks for Suppliers.isNonGMO = TRUE and Restaurants.numStars > 0. These differences in column selection and filtering conditions will result in different output.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in three key aspects: 1) The reference query correctly filters on Ingredients.isNonGMO (the actual ingredient attribute) while the generated query incorrectly uses Suppliers.isNonGMO (supplier attribute). 2) The reference uses Restaurants.numStars > 2 (strictly 3-star restaurants) while the generated uses > 0 (any star rating). 3) The generated query adds DISTINCT which isn't in the reference. The reference better fulfills the business intent by focusing on ingredient-level non-GMO status and matching the strict Michelin star requirement (typically 3-star for the highest rating). The generated query's condition on numStars > 0 would include all restaurants with any stars, which may not align with the intended specificity of Michelin-starred establishments.", "overall_assessment": "differently_correct"}}
{"example_id": 264, "sql_complexity": "set operations", "prompt": "List the number of community health centers and infectious disease tracking facilities in 'southwest' regions.", "context": "CREATE TABLE centers (id INT, name TEXT, region TEXT); INSERT INTO centers (id, name, region) VALUES (1, 'Center A', 'southwest'); INSERT INTO centers (id, name, region) VALUES (2, 'Center B', 'northeast'); INSERT INTO centers (id, name, region) VALUES (3, 'Center C', 'northwest'); CREATE TABLE diseases (id INT, name TEXT, region TEXT); INSERT INTO diseases (id, name, region) VALUES (1, 'Disease A', 'southwest'); INSERT INTO diseases (id, name, region) VALUES (2, 'Disease B', 'southeast');", "reference_sql": "SELECT COUNT(*) FROM ( (SELECT * FROM centers WHERE region = 'southwest') UNION (SELECT * FROM diseases WHERE region = 'southwest') );", "generated_sql": "SELECT \n    COUNT(*) AS num_centers,\n    'community health centers' AS facility_type\nFROM \n    centers\nWHERE \n    region = 'southwest'\n\nUNION ALL\n\nSELECT \n    COUNT(*) AS num_diseases,\n    'infectious disease tracking facilities' AS facility_type\nFROM \n    diseases\nWHERE \n    region = 'southwest';", "raw_model_output": "```sql\nSELECT \n    COUNT(*) AS num_centers,\n    'community health centers' AS facility_type\nFROM \n    centers\nWHERE \n    region = 'southwest'\n\nUNION ALL\n\nSELECT \n    COUNT(*) AS num_diseases,\n    'infectious disease tracking facilities' AS facility_type\nFROM \n    diseases\nWHERE \n    region = 'southwest';\n```", "latency_sec": 1.973681926727295, "total_duration_sec": 1.880270101, "load_duration_sec": 0.015637112, "tokens_prompt": 234, "prompt_eval_sec": 0.049254839, "tokens_completion": 80, "completion_eval_sec": 1.812788096, "tokens_total": 314, "tokens_per_sec": 159.09351742439378, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns a single count of unique rows from both tables where region = 'southwest', while the Generated SQL returns two separate rows with counts and facility type labels. The structure and output format differ significantly, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL combines both tables into a single count using UNION, which would return a single total value (e.g., 2 for 2 centers and 1 disease in the sample data). This fails to distinguish between the two facility types as required by the question. The Generated SQL correctly separates the counts into two rows with explicit labels, matching the business requirement. While both queries are syntactically valid, the Generated SQL's structure directly addresses the need for separate counts of each facility type. The Reference SQL's approach would mislead users by aggregating distinct entities into a single number.", "overall_assessment": "differently_correct"}}
{"example_id": 2838, "sql_complexity": "basic SQL", "prompt": "What is the minimum safety rating of electric vehicles in the 'green_cars' table?", "context": "CREATE TABLE green_cars (id INT, make VARCHAR(50), model VARCHAR(50), type VARCHAR(50), safety_rating INT);", "reference_sql": "SELECT MIN(safety_rating) FROM green_cars WHERE type = 'Electric';", "generated_sql": "SELECT MIN(safety_rating) AS min_safety_rating\nFROM green_cars\nWHERE type = 'electric';", "raw_model_output": "```sql\nSELECT MIN(safety_rating) AS min_safety_rating\nFROM green_cars\nWHERE type = 'electric';\n```", "latency_sec": 0.7725579738616943, "total_duration_sec": 0.667844706, "load_duration_sec": 0.016060621, "tokens_prompt": 125, "prompt_eval_sec": 0.025049086, "tokens_completion": 28, "completion_eval_sec": 0.624096509, "tokens_total": 153, "tokens_per_sec": 198.04338985101268, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the case of the string literal in the WHERE clause ('Electric' vs. 'electric'). While SQL is often case-insensitive for string comparisons by default, this is not guaranteed across all database systems or configurations. The generated query's lowercase 'electric' may not match rows with 'Electric' in a case-sensitive collation, making them semantically different. The column alias ('min_safety_rating') also differs but does not affect the result's content.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in two key aspects: 1) The reference uses 'Electric' (capitalized) while the generated query uses 'electric' (lowercase) in the WHERE clause. This could lead to different results if the database is case-sensitive, as the data may store vehicle types with specific casing. 2) The generated query adds an alias (min_safety_rating) which doesn't affect functionality but changes the output column name. While both queries aim to find the minimum safety rating for electric vehicles, the case sensitivity difference may prevent the generated query from retrieving the correct data if the 'type' column values are stored with uppercase letters. The reference query better aligns with the business intent of finding electric vehicles as explicitly defined in the schema.", "overall_assessment": "differently_correct"}}
{"example_id": 1187, "sql_complexity": "multiple_joins", "prompt": "Who are the top 3 authors with the highest number of articles published in The Guardian?", "context": "CREATE TABLE authors (id INT, name VARCHAR(100), publisher VARCHAR(50)); CREATE TABLE articles_authors (article_id INT, author_id INT); INSERT INTO authors (id, name, publisher) VALUES (1, 'Author1', 'The Guardian'), (2, 'Author2', 'The Guardian'), (3, 'Author3', 'The Guardian'); INSERT INTO articles_authors (article_id, author_id) VALUES (1, 1), (2, 2), (3, 1), (3, 2), (3, 3); INSERT INTO articles (id, title, publication_date, publisher) VALUES (1, 'Article1', '2021-01-01', 'The Guardian'), (2, 'Article2', '2021-01-02', 'The Guardian'), (3, 'Article3', '2021-01-03', 'The Guardian');", "reference_sql": "SELECT a.name, COUNT(aa.article_id) AS articles_count FROM authors a JOIN articles_authors aa ON a.id = aa.author_id JOIN articles ar ON aa.article_id = ar.id WHERE ar.publisher = 'The Guardian' GROUP BY a.name ORDER BY articles_count DESC LIMIT 3;", "generated_sql": "SELECT a.name, COUNT(aa.article_id) AS article_count\nFROM authors a\nJOIN articles_authors aa ON a.id = aa.author_id\nJOIN articles ar ON aa.article_id = ar.id\nWHERE ar.publisher = 'The Guardian'\nGROUP BY a.id, a.name\nORDER BY article_count DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT a.name, COUNT(aa.article_id) AS article_count\nFROM authors a\nJOIN articles_authors aa ON a.id = aa.author_id\nJOIN articles ar ON aa.article_id = ar.id\nWHERE ar.publisher = 'The Guardian'\nGROUP BY a.id, a.name\nORDER BY article_count DESC\nLIMIT 3;\n```", "latency_sec": 1.8782169818878174, "total_duration_sec": 1.747230289, "load_duration_sec": 0.015403069, "tokens_prompt": 298, "prompt_eval_sec": 0.064446911, "tokens_completion": 72, "completion_eval_sec": 1.664756511, "tokens_total": 370, "tokens_per_sec": 196.99534375847713, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their GROUP BY clauses. The Reference SQL groups by 'a.name' alone, while the Generated SQL groups by both 'a.id' and 'a.name'. If authors have non-unique names, the Reference SQL would aggregate articles for authors with the same name into a single row, whereas the Generated SQL would treat them as separate authors due to their unique 'id's. This difference in grouping logic makes the queries semantically non-equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify the top 3 authors by article count in The Guardian. The reference query groups by a.name, which works in this context due to unique author names. The generated query groups by a.id and a.name, which is more technically robust as it ensures proper aggregation even if names were non-unique. The generated version is slightly superior due to explicit grouping on the primary key (id) and name, making it more reliable in general cases. Both queries achieve the business intent of counting articles per author and ordering by descending count.", "overall_assessment": "differently_correct"}}
{"example_id": 360, "sql_complexity": "window functions", "prompt": "What is the change in crime rate for each category, between this year and last year, for the same time period?", "context": "CREATE TABLE CrimeStatistics (ID INT, CrimeType VARCHAR(50), Date TIMESTAMP, Count INT); INSERT INTO CrimeStatistics (ID, CrimeType, Date, Count) VALUES (1, 'Theft', '2022-01-01 00:00:00', 100), (2, 'Vandalism', '2022-01-01 00:00:00', 50), (3, 'Theft', '2022-01-02 00:00:00', 120), (4, 'Vandalism', '2022-01-02 00:00:00', 60), (5, 'Theft', '2021-01-01 00:00:00', 80), (6, 'Vandalism', '2021-01-01 00:00:00', 40), (7, 'Theft', '2021-01-02 00:00:00', 90), (8, 'Vandalism', '2021-01-02 00:00:00', 45);", "reference_sql": "SELECT CrimeType, (SUM(Count) OVER (PARTITION BY CrimeType ORDER BY EXTRACT(YEAR FROM Date) ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)) - SUM(Count) OVER (PARTITION BY CrimeType ORDER BY EXTRACT(YEAR FROM Date)) AS CrimeRateChange FROM CrimeStatistics WHERE Date BETWEEN DATE_TRUNC('year', CURRENT_DATE - INTERVAL '1 year') AND CURRENT_DATE;", "generated_sql": "SELECT \n    CrimeType,\n    SUM(CASE WHEN YEAR(Date) = YEAR(CURRENT_DATE) THEN Count ELSE 0 END) - \n    SUM(CASE WHEN YEAR(Date) = YEAR(CURRENT_DATE) - 1 THEN Count ELSE 0 END) AS ChangeInCrimeRate\nFROM \n    CrimeStatistics\nGROUP BY \n    CrimeType;", "raw_model_output": "```sql\nSELECT \n    CrimeType,\n    SUM(CASE WHEN YEAR(Date) = YEAR(CURRENT_DATE) THEN Count ELSE 0 END) - \n    SUM(CASE WHEN YEAR(Date) = YEAR(CURRENT_DATE) - 1 THEN Count ELSE 0 END) AS ChangeInCrimeRate\nFROM \n    CrimeStatistics\nGROUP BY \n    CrimeType;\n```", "latency_sec": 2.1512160301208496, "total_duration_sec": 1.924315951, "load_duration_sec": 0.017863046, "tokens_prompt": 398, "prompt_eval_sec": 0.086760398, "tokens_completion": 77, "completion_eval_sec": 1.817299904, "tokens_total": 475, "tokens_per_sec": 220.80534606899326, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL uses window functions to calculate a difference between the previous year's sum and the current cumulative sum, which doesn't correctly represent year-over-year change. The Generated SQL directly computes the difference between sums for the current and previous years. Additionally, the Reference SQL filters data to a specific date range, while the Generated SQL does not, leading to potential differences in the dataset considered.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL has multiple technical issues: 1) The WHERE clause filters dates between the start of last year and now, but the question requires comparing *same time periods* (e.g., Jan 1 - Jan 2 in 2022 vs 2021), not entire years. 2) The window function logic is flawed - it attempts to compare adjacent years but doesn't properly aggregate counts for full years. 3) The calculation (previous year sum - current year sum) is inverted. The Generated SQL correctly calculates annual totals for current and previous years using conditional aggregation, then subtracts them. While both queries aim to show year-over-year changes, the Generated SQL more directly addresses the business intent of comparing full-year totals for each crime category.", "overall_assessment": "differently_correct"}}
{"example_id": 335, "sql_complexity": "single join", "prompt": "List the policy numbers, claim amounts, and claim dates for policies that have more than two claims and the total claim amount exceeds $5000", "context": "CREATE TABLE policies (policy_number INT);CREATE TABLE claims (claim_id INT, policy_number INT, claim_amount DECIMAL(10,2), claim_date DATE);", "reference_sql": "SELECT p.policy_number, c.claim_amount, c.claim_date FROM policies p INNER JOIN claims c ON p.policy_number = c.policy_number GROUP BY p.policy_number, c.claim_amount, c.claim_date HAVING COUNT(c.claim_id) > 2 AND SUM(c.claim_amount) > 5000;", "generated_sql": "SELECT p.policy_number, c.claim_amount, c.claim_date\nFROM policies p\nJOIN claims c ON p.policy_number = c.policy_number\nWHERE p.policy_number IN (\n    SELECT policy_number\n    FROM claims\n    GROUP BY policy_number\n    HAVING COUNT(claim_id) > 2 AND SUM(claim_amount) > 5000\n);", "raw_model_output": "```sql\nSELECT p.policy_number, c.claim_amount, c.claim_date\nFROM policies p\nJOIN claims c ON p.policy_number = c.policy_number\nWHERE p.policy_number IN (\n    SELECT policy_number\n    FROM claims\n    GROUP BY policy_number\n    HAVING COUNT(claim_id) > 2 AND SUM(claim_amount) > 5000\n);\n```", "latency_sec": 2.161733865737915, "total_duration_sec": 1.865076615, "load_duration_sec": 0.015565799, "tokens_prompt": 141, "prompt_eval_sec": 0.038643837, "tokens_completion": 82, "completion_eval_sec": 1.808348419, "tokens_total": 223, "tokens_per_sec": 103.15793425564817, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in grouping and filtering logic. The reference query groups by policy_number, claim_amount, and claim_date, filtering groups with >2 claims and sum >5000. The generated query first identifies policies with >2 claims and sum >5000 (grouped by policy_number only), then returns all claims for those policies. This leads to different result sets: the reference query returns specific (policy, amount, date) groups meeting criteria, while the generated query returns all claims for qualifying policies, potentially including multiple amounts/dates per policy.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL is technically incorrect due to flawed grouping. It groups by policy_number, claim_amount, and claim_date, which would split claims into individual rows (since each claim has unique amount/date). This makes COUNT(claim_id) always 1, violating the 'more than two claims' condition. The Generated SQL correctly uses a subquery to first identify qualifying policies (with COUNT(claim_id) > 2 and SUM(claim_amount) > 5000), then retrieves all claims for those policies. While both queries aim to answer the business question, only the Generated SQL properly filters policies before retrieving claims, ensuring accurate results. The Reference SQL would return no rows due to its logical error.", "overall_assessment": "differently_correct"}}
{"example_id": 2866, "sql_complexity": "basic SQL", "prompt": "What is the number of hospitals in 'rural_healthcare' table?", "context": "CREATE TABLE rural_healthcare (name VARCHAR(255), type VARCHAR(255), location VARCHAR(255)); INSERT INTO rural_healthcare (name, type, location) VALUES ('Rural General Hospital', 'Hospital', 'Bushland'), ('Rural Community Hospital', 'Hospital', 'Forest Region');", "reference_sql": "SELECT COUNT(*) FROM rural_healthcare WHERE type = 'Hospital';", "generated_sql": "SELECT COUNT(*) AS hospital_count \nFROM rural_healthcare \nWHERE type = 'Hospital';", "raw_model_output": "```sql\nSELECT COUNT(*) AS hospital_count \nFROM rural_healthcare \nWHERE type = 'Hospital';\n```", "latency_sec": 0.6130292415618896, "total_duration_sec": 0.563268019, "load_duration_sec": 0.017871336, "tokens_prompt": 157, "prompt_eval_sec": 0.030065095, "tokens_completion": 23, "completion_eval_sec": 0.512558034, "tokens_total": 180, "tokens_per_sec": 293.62384009838087, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries count the number of rows where type = 'Hospital'. The generated query adds an alias (hospital_count) to the COUNT(*) result, but this does not affect the actual value returned. The WHERE clause and table structure are identical, so the result will be the same (2 in this case).", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly count rows where type = 'Hospital' from the rural_healthcare table. The reference query uses minimal syntax, while the generated query adds an explicit alias (hospital_count). The alias improves readability by naming the result column but doesn't alter the semantic meaning or technical correctness. Both produce identical results and address the business intent of counting hospitals.", "overall_assessment": "correct"}}
{"example_id": 4440, "sql_complexity": "multiple_joins", "prompt": "What is the average session length for each game genre in the last month, sorted by average session length.", "context": "CREATE TABLE game_sessions(id INT, user_id INT, game_name VARCHAR(50), start_time DATETIME, end_time DATETIME); CREATE TABLE games(id INT, name VARCHAR(50), genre VARCHAR(50));", "reference_sql": "SELECT genres.genre, AVG(TIMESTAMPDIFF(SECOND, start_time, end_time)) as avg_session_length FROM game_sessions JOIN games ON game_sessions.game_name = games.name JOIN (SELECT DISTINCT game_name, genre FROM game_sessions JOIN games ON game_sessions.game_name = games.name) genres ON games.name = genres.game_name WHERE start_time >= DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH) GROUP BY genres.genre ORDER BY avg_session_length DESC;", "generated_sql": "SELECT \n    g.genre,\n    AVG(TIMESTAMPDIFF(MINUTE, gs.start_time, gs.end_time)) AS avg_session_length\nFROM \n    game_sessions gs\nJOIN \n    games g ON gs.game_name = g.name\nWHERE \n    gs.start_time >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH)\nGROUP BY \n    g.genre\nORDER BY \n    avg_session_length;", "raw_model_output": "```sql\nSELECT \n    g.genre,\n    AVG(TIMESTAMPDIFF(MINUTE, gs.start_time, gs.end_time)) AS avg_session_length\nFROM \n    game_sessions gs\nJOIN \n    games g ON gs.game_name = g.name\nWHERE \n    gs.start_time >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH)\nGROUP BY \n    g.genre\nORDER BY \n    avg_session_length;\n```", "latency_sec": 1.9891109466552734, "total_duration_sec": 1.951951257, "load_duration_sec": 0.018018221, "tokens_prompt": 143, "prompt_eval_sec": 0.026354569, "tokens_completion": 86, "completion_eval_sec": 1.905424285, "tokens_total": 229, "tokens_per_sec": 115.12681099315637, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in three key aspects: 1) The Reference uses SECOND while Generated uses MINUTE in TIMESTAMPDIFF, altering the average value by a factor of 60. 2) The Reference includes a subquery to deduplicate game_name/genre pairs, which the Generated query lacks, potentially leading to different groupings. 3) The Reference orders results DESC while the Generated query uses default ASC ordering. These differences ensure non-equivalent results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in three critical aspects: 1) The Reference uses SECOND while Generated uses MINUTE for session length calculation, producing numerically different results. 2) The Reference contains an unnecessary subquery that redundantly joins game_sessions and games, which could impact performance. 3) The Generated query omits the explicit ORDER BY clause's direction (DESC), though it's implied in some SQL dialects. While both address the core business intent of grouping by genre and filtering by date, the unit discrepancy (seconds vs minutes) fundamentally alters the metric being measured. The Reference better fulfills the intent by using the more precise SECOND unit, though its complexity is suboptimal.", "overall_assessment": "differently_correct"}}
{"example_id": 451, "sql_complexity": "single join", "prompt": "Which customers have made a transaction over 500 in the \"risk_management\" category?", "context": "CREATE TABLE customers (id INT, name VARCHAR(50), category VARCHAR(50)); INSERT INTO customers (id, name, category) VALUES (1, 'John Doe', 'risk_management'); INSERT INTO customers (id, name, category) VALUES (2, 'Jane Smith', 'compliance'); INSERT INTO customers (id, name, category) VALUES (3, 'Jim Brown', 'risk_management'); CREATE TABLE transactions (id INT, customer_id INT, amount DECIMAL(10, 2)); INSERT INTO transactions (id, customer_id, amount) VALUES (1, 1, 500.00); INSERT INTO transactions (id, customer_id, amount) VALUES (2, 1, 200.00); INSERT INTO transactions (id, customer_id, amount) VALUES (3, 2, 100.00); INSERT INTO transactions (id, customer_id, amount) VALUES (4, 3, 750.00);", "reference_sql": "SELECT c.name FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE c.category = 'risk_management' AND t.amount > 500;", "generated_sql": "SELECT DISTINCT c.name \nFROM customers c \nJOIN transactions t ON c.id = t.customer_id \nWHERE c.category = 'risk_management' AND t.amount > 500;", "raw_model_output": "```sql\nSELECT DISTINCT c.name \nFROM customers c \nJOIN transactions t ON c.id = t.customer_id \nWHERE c.category = 'risk_management' AND t.amount > 500;\n```", "latency_sec": 1.2115108966827393, "total_duration_sec": 1.071432674, "load_duration_sec": 0.02124384, "tokens_prompt": 305, "prompt_eval_sec": 0.065907948, "tokens_completion": 42, "completion_eval_sec": 0.981455048, "tokens_total": 347, "tokens_per_sec": 286.419215006755, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The generated query uses SELECT DISTINCT, which ensures unique names in the result, while the reference query may return duplicate names if a customer has multiple qualifying transactions. Although the sample data produces the same result, the DISTINCT clause changes the semantics for cases with multiple matching transactions per customer.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because the generated query uses DISTINCT to eliminate duplicate customer names, while the reference query may return duplicates if a customer has multiple transactions over 500. Both correctly filter for 'risk_management' category and transactions > 500, but the generated query better fulfills the business intent of listing customers (which implies unique identifiers). The generated query is more elegant and efficient by ensuring unique results without unnecessary data.", "overall_assessment": "differently_correct"}}
{"example_id": 2879, "sql_complexity": "basic SQL", "prompt": "Update the FoodSafetyRecords.OrganicFarms table to include a new record for a certified organic farm in Kenya.", "context": "CREATE TABLE FoodSafetyRecords.OrganicFarms (farmName TEXT, country TEXT, certified BOOLEAN);", "reference_sql": "INSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('Ngong Organic Farm', 'Kenya', TRUE);", "generated_sql": "INSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified)\nVALUES ('New Organic Farm', 'Kenya', TRUE);", "raw_model_output": "```sql\nINSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified)\nVALUES ('New Organic Farm', 'Kenya', TRUE);\n```", "latency_sec": 0.9421868324279785, "total_duration_sec": 0.811580313, "load_duration_sec": 0.016022482, "tokens_prompt": 121, "prompt_eval_sec": 0.024702516, "tokens_completion": 35, "completion_eval_sec": 0.768437848, "tokens_total": 156, "tokens_per_sec": 165.57225661708105, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The two queries differ in the farmName value inserted ('Ngong Organic Farm' vs 'New Organic Farm'). While the structure and other values are identical, the distinct farm names result in different records being inserted, making them semantically non-equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly insert a new certified organic farm record into the FoodSafetyRecords.OrganicFarms table. The technical structure (syntax, column ordering, data types) is identical, and both satisfy the business requirement of adding a Kenya-based organic farm. The only difference is the farm name ('Ngong Organic Farm' vs. 'New Organic Farm'), which is not specified in the original question. Since the task only requires adding a new record, either name is acceptable. Neither query is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 5688, "sql_complexity": "single join", "prompt": "What is the total amount donated to a specific cause?", "context": "CREATE TABLE causes (id INT, name TEXT); CREATE TABLE donations (id INT, donor_id INT, cause_id INT, donation_amount DECIMAL(10,2)); INSERT INTO causes (id, name) VALUES (1, 'Cause A'), (2, 'Cause B'); INSERT INTO donations (id, donor_id, cause_id, donation_amount) VALUES (1, 1, 1, 50.00), (2, 2, 1, 100.00);", "reference_sql": "SELECT SUM(donation_amount) FROM donations JOIN causes ON donations.cause_id = causes.id WHERE causes.name = 'Cause A';", "generated_sql": "SELECT SUM(donation_amount) AS total_donated\nFROM donations\nWHERE cause_id = <cause_id>;", "raw_model_output": "```sql\nSELECT SUM(donation_amount) AS total_donated\nFROM donations\nWHERE cause_id = <cause_id>;\n```\n\nReplace `<cause_id>` with the actual ID of the cause you are interested in. For example, if you want to find the total amount donated to 'Cause A', use `cause_id = 1`.", "latency_sec": 1.6658687591552734, "total_duration_sec": 1.618791493, "load_duration_sec": 0.01370862, "tokens_prompt": 194, "prompt_eval_sec": 0.03730197, "tokens_completion": 70, "completion_eval_sec": 1.565333344, "tokens_total": 264, "tokens_per_sec": 158.4758694519662, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters donations by the cause's name ('Cause A') through a JOIN with the causes table, while the Generated SQL filters by a parameterized cause_id. Although in the given data, cause_id 1 corresponds to 'Cause A', the Generated SQL lacks the JOIN and relies on an undefined parameter (<cause_id>). Without knowing the value of <cause_id>, the queries are not guaranteed to produce the same results. Additionally, the Generated SQL is not a valid standalone query due to the placeholder.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query is technically correct and directly addresses the business intent by summing donations for a specific cause using the cause name ('Cause A'). The generated query requires a parameter (<cause_id>) that isn't defined in the original question, making it incomplete as written. While both queries would produce equivalent results if the cause_id were known, the reference query is self-contained and aligns with the question's phrasing. The reference also demonstrates proper JOIN logic, whereas the generated query assumes prior knowledge of the cause_id, which isn't provided in the original question.", "overall_assessment": "correct"}}
{"example_id": 3273, "sql_complexity": "multiple_joins", "prompt": "List all departments, the number of chemicals they handle, and the number of machines used in their manufacturing processes.", "context": "CREATE TABLE Departments (DepartmentID INT, DepartmentName VARCHAR(20)); INSERT INTO Departments (DepartmentID, DepartmentName) VALUES (1, 'Manufacturing'), (2, 'Engineering'), (3, 'Chemical Safety'), (4, 'Product Development'); CREATE TABLE Chemicals (ChemicalID INT, ChemicalName VARCHAR(20), DepartmentID INT); INSERT INTO Chemicals (ChemicalID, ChemicalName, DepartmentID) VALUES (1, 'Hydrochloric Acid', 1), (2, 'Nitric Acid', 2), (3, 'Sodium Hydroxide', 3), (4, 'New Chemical', 4); CREATE TABLE Machinery (MachineID INT, MachineName VARCHAR(20), DepartmentID INT); INSERT INTO Machinery (MachineID, MachineName, DepartmentID) VALUES (1, 'Mixer 1', 1), (2, 'Cutter 2', 2), (3, 'Dispenser 3', 3), (4, 'Innovator 4', 4);", "reference_sql": "SELECT D.DepartmentName, COUNT(C.ChemicalID) AS ChemicalCount, COUNT(M.MachineID) AS MachineCount FROM Departments D LEFT JOIN Chemicals C ON D.DepartmentID = C.DepartmentID LEFT JOIN Machinery M ON D.DepartmentID = M.DepartmentID GROUP BY D.DepartmentName;", "generated_sql": "SELECT \n    d.DepartmentName,\n    COUNT(c.ChemicalID) AS NumberOfChemicals,\n    COUNT(m.MachineID) AS NumberOfMachines\nFROM \n    Departments d\nLEFT JOIN \n    Chemicals c ON d.DepartmentID = c.DepartmentID\nLEFT JOIN \n    Machinery m ON d.DepartmentID = m.DepartmentID\nGROUP BY \n    d.DepartmentName;", "raw_model_output": "```sql\nSELECT \n    d.DepartmentName,\n    COUNT(c.ChemicalID) AS NumberOfChemicals,\n    COUNT(m.MachineID) AS NumberOfMachines\nFROM \n    Departments d\nLEFT JOIN \n    Chemicals c ON d.DepartmentID = c.DepartmentID\nLEFT JOIN \n    Machinery m ON d.DepartmentID = m.DepartmentID\nGROUP BY \n    d.DepartmentName;\n```", "latency_sec": 2.2730448246002197, "total_duration_sec": 1.981306542, "load_duration_sec": 0.015019213, "tokens_prompt": 318, "prompt_eval_sec": 0.066263211, "tokens_completion": 82, "completion_eval_sec": 1.896395656, "tokens_total": 400, "tokens_per_sec": 175.97541221843326, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform the same LEFT JOIN operations between Departments, Chemicals, and Machinery tables on DepartmentID. They group by DepartmentName and count ChemicalID and MachineID. The only differences are table aliases (D/d, C/c, M/m) and column aliases (ChemicalCount/NumberOfChemicals, MachineCount/NumberOfMachines), which do not affect the semantic result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically equivalent as they produce identical results through equivalent logic: left-joining Departments with Chemicals and Machinery on DepartmentID, then grouping by DepartmentName to count chemicals and machines. The reference and generated queries differ only in column aliases (e.g., 'ChemicalCount' vs 'NumberOfChemicals') and formatting (e.g., uppercase vs lowercase aliases). The generated query better fulfills the business intent by using more descriptive column names ('NumberOfChemicals' and 'NumberOfMachines') that directly align with the question's phrasing. While both are correct, the generated query's clarity and readability make it superior.", "overall_assessment": "correct"}}
{"example_id": 1895, "sql_complexity": "window functions", "prompt": "What is the average safety score of chemical production sites in the United States, partitioned by state and ranked in descending order?", "context": "CREATE TABLE production_sites (site_id INT, site_name TEXT, country TEXT, state TEXT, safety_score FLOAT); INSERT INTO production_sites (site_id, site_name, country, state, safety_score) VALUES (1, 'Site A', 'USA', 'NY', 92.5), (2, 'Site B', 'USA', 'CA', 87.4), (3, 'Site C', 'USA', 'TX', 95.3), (4, 'Site D', 'USA', 'FL', 89.2);", "reference_sql": "SELECT state, AVG(safety_score) as avg_safety_score, ROW_NUMBER() OVER (ORDER BY AVG(safety_score) DESC) as rank FROM production_sites WHERE country = 'USA' GROUP BY state ORDER BY rank;", "generated_sql": "SELECT \n    state, \n    AVG(safety_score) AS avg_safety_score\nFROM \n    production_sites\nWHERE \n    country = 'USA'\nGROUP BY \n    state\nORDER BY \n    avg_safety_score DESC;", "raw_model_output": "```sql\nSELECT \n    state, \n    AVG(safety_score) AS avg_safety_score\nFROM \n    production_sites\nWHERE \n    country = 'USA'\nGROUP BY \n    state\nORDER BY \n    avg_safety_score DESC;\n```", "latency_sec": 1.4561588764190674, "total_duration_sec": 1.262407315, "load_duration_sec": 0.015965438, "tokens_prompt": 219, "prompt_eval_sec": 0.044889326, "tokens_completion": 53, "completion_eval_sec": 1.199143567, "tokens_total": 272, "tokens_per_sec": 186.79280427757473, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a 'rank' column generated by ROW_NUMBER() and orders by this rank, while the Generated SQL omits the rank column and orders directly by avg_safety_score. Although both queries group by state and calculate the same average safety score, the presence of the additional 'rank' column in the Reference SQL makes the result sets structurally different. Additionally, the Reference SQL's ORDER BY rank would produce the same row order as Generated SQL's ORDER BY avg_safety_score DESC, but the semantic equivalence is invalidated by the differing output columns.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL includes a ROW_NUMBER() ranking column that is not explicitly requested in the original question, while the Generated SQL directly addresses the requirement for average safety scores partitioned by state and ordered by descending average. The Reference SQL's ORDER BY rank is redundant since the window function already sorts by average safety score. The Generated SQL is more concise, avoids unnecessary complexity, and aligns precisely with the business intent of calculating averages and sorting them. Both queries correctly calculate averages, but the Generated SQL better fulfills the explicit requirements of the question.", "overall_assessment": "correct"}}
{"example_id": 4669, "sql_complexity": "set operations", "prompt": "Identify the number of IoT devices in each country and the total number of devices.", "context": "CREATE TABLE device_country (device_id INT, country TEXT); INSERT INTO device_country (device_id, country) VALUES (1, 'USA'), (2, 'Canada'), (3, 'Mexico'), (4, 'Brazil'); CREATE TABLE device_info (device_id INT, device_type TEXT); INSERT INTO device_info (device_id, device_type) VALUES (1, 'Soil Sensor'), (2, 'Temperature Sensor'), (3, 'Humidity Sensor'), (4, 'Precision Sprayer');", "reference_sql": "SELECT country, COUNT(*) AS device_count FROM device_country GROUP BY country UNION SELECT 'Total' AS country, COUNT(*) FROM device_country;", "generated_sql": "SELECT \n    country, \n    COUNT(device_id) AS device_count\nFROM \n    device_country\nGROUP BY \n    country\nUNION ALL\nSELECT \n    'Total' AS country, \n    COUNT(device_id) AS device_count\nFROM \n    device_country;", "raw_model_output": "```sql\nSELECT \n    country, \n    COUNT(device_id) AS device_count\nFROM \n    device_country\nGROUP BY \n    country\nUNION ALL\nSELECT \n    'Total' AS country, \n    COUNT(device_id) AS device_count\nFROM \n    device_country;\n```", "latency_sec": 1.633526086807251, "total_duration_sec": 1.428621203, "load_duration_sec": 0.014621566, "tokens_prompt": 196, "prompt_eval_sec": 0.037459238, "tokens_completion": 61, "completion_eval_sec": 1.373953071, "tokens_total": 257, "tokens_per_sec": 157.32837208759244, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries produce the same result. The Reference SQL uses UNION (which implicitly removes duplicates) while the Generated SQL uses UNION ALL. However, since the two parts of the union cannot produce duplicate rows (the first part groups by country, and the second part is a single 'Total' row), the output remains identical. The COUNT(*) vs COUNT(device_id) is functionally equivalent in this context.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count devices per country and include a total. The reference uses UNION (which removes duplicates, though unnecessary here) while the generated uses UNION ALL (more efficient). The generated query is more efficient due to UNION ALL and explicitly counts device_id, which aligns with the schema's primary key. Both produce identical results, but the generated version is technically superior for performance.", "overall_assessment": "correct"}}
{"example_id": 5302, "sql_complexity": "multiple_joins", "prompt": "Find the supplier with the lowest average delivery time for orders in the last month.", "context": "CREATE TABLE Suppliers (SupplierID int, SupplierName varchar(50)); CREATE TABLE Products (ProductID int, ProductName varchar(50), SupplierID int); CREATE TABLE Orders (OrderID int, ProductID int, OrderDate date, DeliveryTime int); INSERT INTO Suppliers VALUES (1, 'SupplierA'), (2, 'SupplierB'); INSERT INTO Products VALUES (1, 'Organic Apples', 1), (2, 'Bananas', 2); INSERT INTO Orders VALUES (1, 1, '2022-01-01', 2), (2, 2, '2022-01-03', 3);", "reference_sql": "SELECT SupplierName, AVG(DeliveryTime) as AvgDeliveryTime FROM Orders o JOIN Products p ON o.ProductID = p.ProductID JOIN Suppliers sp ON p.SupplierID = sp.SupplierID WHERE OrderDate >= DATEADD(month, -1, GETDATE()) GROUP BY SupplierName ORDER BY AvgDeliveryTime ASC;", "generated_sql": "SELECT s.SupplierName\nFROM Suppliers s\nJOIN Products p ON s.SupplierID = p.SupplierID\nJOIN Orders o ON p.ProductID = o.ProductID\nWHERE o.OrderDate >= DATEADD(MONTH, -1, GETDATE())\nGROUP BY s.SupplierName\nORDER BY AVG(o.DeliveryTime) ASC\nLIMIT 1;", "raw_model_output": "```sql\nSELECT s.SupplierName\nFROM Suppliers s\nJOIN Products p ON s.SupplierID = p.SupplierID\nJOIN Orders o ON p.ProductID = o.ProductID\nWHERE o.OrderDate >= DATEADD(MONTH, -1, GETDATE())\nGROUP BY s.SupplierName\nORDER BY AVG(o.DeliveryTime) ASC\nLIMIT 1;\n```", "latency_sec": 1.9591329097747803, "total_duration_sec": 1.858313579, "load_duration_sec": 0.014808638, "tokens_prompt": 236, "prompt_eval_sec": 0.051076292, "tokens_completion": 79, "completion_eval_sec": 1.788894622, "tokens_total": 315, "tokens_per_sec": 160.78541605235554, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns all suppliers with their average delivery times sorted by ascending average, while the Generated SQL only returns the top supplier (LIMIT 1) with the lowest average delivery time. Additionally, the Generated SQL omits the actual average value from the output, making their result sets structurally and semantically different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in two key aspects. 1) The Reference SQL returns all suppliers ordered by average delivery time, while the Generated SQL retrieves only the top supplier with the lowest average delivery time using LIMIT 1. 2) The Generated SQL uses a more efficient approach by directly ordering by the average delivery time and limiting the result, whereas the Reference SQL requires additional processing to identify the supplier with the lowest average. While both queries correctly calculate average delivery times and filter for the last month, the Generated SQL more directly addresses the business intent of identifying the single supplier with the lowest average delivery time.", "overall_assessment": "differently_correct"}}
{"example_id": 267, "sql_complexity": "subqueries", "prompt": "What is the total number of disability support programs offered in urban and rural areas, and the percentage of total programs for each area type?", "context": "CREATE TABLE programs (program_id INT, program_name VARCHAR(255), area_type VARCHAR(255));", "reference_sql": "SELECT area_type, COUNT(*) as total_programs, ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM programs) , 2) as percentage_of_total FROM programs WHERE area_type IN ('urban', 'rural') GROUP BY area_type;", "generated_sql": "SELECT \n    area_type,\n    COUNT(*) AS total_programs,\n    (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM programs)) AS percentage_of_total\nFROM \n    programs\nGROUP BY \n    area_type;", "raw_model_output": "```sql\nSELECT \n    area_type,\n    COUNT(*) AS total_programs,\n    (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM programs)) AS percentage_of_total\nFROM \n    programs\nGROUP BY \n    area_type;\n```", "latency_sec": 1.5586068630218506, "total_duration_sec": 1.255271514, "load_duration_sec": 0.015920689, "tokens_prompt": 127, "prompt_eval_sec": 0.023399834, "tokens_completion": 55, "completion_eval_sec": 1.213607383, "tokens_total": 182, "tokens_per_sec": 116.77094738767904, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL includes a WHERE clause filtering area_type to ('urban', 'rural') while the Generated SQL groups all area_types. Additionally, the Reference SQL uses ROUND() for the percentage calculation, whereas the Generated SQL does not. These differences would produce different results when there are area_types other than 'urban' and 'rural' or when precision matters.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries differ in two key aspects. 1) The Reference query includes a WHERE clause filtering for 'urban' and 'rural' area types, while the Generated query does not. This means the Generated query could include other area types, potentially skewing the percentage calculation. 2) The Reference query uses the ROUND function to limit the percentage to two decimal places, while the Generated query does not. While both queries correctly calculate the total programs per area type, the Reference query better ensures the results align with the original question's requirements by explicitly filtering the area types and formatting the percentage appropriately. The Generated query, while syntactically correct, might include additional area types not relevant to the question, potentially leading to incorrect percentage calculations.", "overall_assessment": "differently_correct"}}
{"example_id": 3028, "sql_complexity": "basic SQL", "prompt": "What is the number of startups founded by non-binary individuals in the technology industry?", "context": "CREATE TABLE company (id INT, name TEXT, founder_gender TEXT, industry TEXT); INSERT INTO company (id, name, founder_gender, industry) VALUES (1, 'CodeForAll', 'Non-binary', 'Technology'); INSERT INTO company (id, name, founder_gender, industry) VALUES (2, 'TechVillage', 'Male', 'Technology');", "reference_sql": "SELECT COUNT(*) FROM company WHERE founder_gender = 'Non-binary' AND industry = 'Technology';", "generated_sql": "SELECT COUNT(*) \nFROM company \nWHERE founder_gender = 'Non-binary' AND industry = 'Technology';", "raw_model_output": "```sql\nSELECT COUNT(*) \nFROM company \nWHERE founder_gender = 'Non-binary' AND industry = 'Technology';\n```", "latency_sec": 0.823620080947876, "total_duration_sec": 0.632619096, "load_duration_sec": 0.015927231, "tokens_prompt": 166, "prompt_eval_sec": 0.033813635, "tokens_completion": 26, "completion_eval_sec": 0.579743314, "tokens_total": 192, "tokens_per_sec": 233.1171913378239, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries have identical structure, conditions, and logic. The only difference is formatting (line breaks/spaces), which does not affect semantic meaning in SQL.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure, logic, and output. They both correctly count companies where founder_gender is 'Non-binary' and industry is 'Technology', matching the business requirement. The slight formatting difference (line breaks) does not affect execution. Both queries are equally efficient and semantically precise.", "overall_assessment": "correct"}}
{"example_id": 3282, "sql_complexity": "aggregation", "prompt": "Which marine species have been observed in both the Arctic and Antarctic oceans?", "context": "CREATE TABLE marine_species (id INT, species_name VARCHAR(50), common_name VARCHAR(50), region VARCHAR(20));INSERT INTO marine_species (id, species_name, common_name, region) VALUES (1, 'Orcinus_orca', 'Killer Whale', 'Arctic');INSERT INTO marine_species (id, species_name, common_name, region) VALUES (2, 'Balaenoptera_bonaerensis', 'Antarctic Minke Whale', 'Antarctic');", "reference_sql": "SELECT species_name FROM marine_species WHERE region IN ('Arctic', 'Antarctic') GROUP BY species_name HAVING COUNT(DISTINCT region) = 2;", "generated_sql": "SELECT species_name \nFROM marine_species \nWHERE region = 'Arctic' \nINTERSECT \nSELECT species_name \nFROM marine_species \nWHERE region = 'Antarctic';", "raw_model_output": "```sql\nSELECT species_name \nFROM marine_species \nWHERE region = 'Arctic' \nINTERSECT \nSELECT species_name \nFROM marine_species \nWHERE region = 'Antarctic';\n```", "latency_sec": 1.2814619541168213, "total_duration_sec": 0.984760859, "load_duration_sec": 0.014372803, "tokens_prompt": 196, "prompt_eval_sec": 0.037737892, "tokens_completion": 41, "completion_eval_sec": 0.929853746, "tokens_total": 237, "tokens_per_sec": 184.94501474555247, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve species that exist in both the 'Arctic' and 'Antarctic' regions. The Reference SQL uses GROUP BY and HAVING to ensure a species appears in both regions, while the Generated SQL uses INTERSECT to find common species between two region-specific queries. Both approaches logically achieve the same result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify species present in both Arctic and Antarctic regions. The reference query uses GROUP BY and HAVING to count distinct regions per species, while the generated query leverages INTERSECT to directly find common species between the two regions. The generated query is more efficient and elegant, as INTERSECT explicitly expresses the intent to find overlaps, avoiding the need for aggregation. Both produce identical results, but the generated version is semantically clearer for this specific use case.", "overall_assessment": "correct"}}
{"example_id": 3474, "sql_complexity": "subqueries", "prompt": "What is the total transaction volume for the top 3 digital assets by market capitalization in the 'developed_markets' schema?", "context": "CREATE SCHEMA developed_markets; CREATE TABLE developed_markets.digital_assets (asset_name VARCHAR(10), market_cap BIGINT, daily_transaction_volume BIGINT); INSERT INTO developed_markets.digital_assets (asset_name, market_cap, daily_transaction_volume) VALUES ('AssetG', 30000000, 15000000), ('AssetH', 25000000, 12000000), ('AssetI', 20000000, 10000000), ('AssetJ', 15000000, 8000000), ('AssetK', 10000000, 6000000);", "reference_sql": "SELECT SUM(daily_transaction_volume) FROM (SELECT daily_transaction_volume FROM developed_markets.digital_assets ORDER BY market_cap DESC FETCH NEXT 3 ROWS ONLY) t;", "generated_sql": "SELECT SUM(daily_transaction_volume) AS total_transaction_volume\nFROM (\n    SELECT daily_transaction_volume\n    FROM developed_markets.digital_assets\n    ORDER BY market_cap DESC\n    LIMIT 3\n) AS top_assets;", "raw_model_output": "```sql\nSELECT SUM(daily_transaction_volume) AS total_transaction_volume\nFROM (\n    SELECT daily_transaction_volume\n    FROM developed_markets.digital_assets\n    ORDER BY market_cap DESC\n    LIMIT 3\n) AS top_assets;\n```", "latency_sec": 1.529655933380127, "total_duration_sec": 1.228490546, "load_duration_sec": 0.015813567, "tokens_prompt": 273, "prompt_eval_sec": 0.057225944, "tokens_completion": 50, "completion_eval_sec": 1.152772548, "tokens_total": 323, "tokens_per_sec": 211.15859648663417, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of daily_transaction_volume for the top 3 assets ordered by market_cap in descending order. The difference lies in syntax: Reference uses FETCH NEXT 3 ROWS ONLY (Oracle-style) while Generated uses LIMIT 3 (PostgreSQL/MySQL-style). Both achieve the same result of limiting to 3 rows after ordering.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the total transaction volume for the top 3 digital assets by market capitalization. The reference query uses FETCH NEXT 3 ROWS ONLY (SQL:2011 standard), while the generated query uses LIMIT 3 (common in PostgreSQL/MySQL). Both achieve the same result by ordering by market_cap DESC, selecting the top 3 rows, and summing their daily_transaction_volume. The generated query is more concise and uses a widely supported syntax (LIMIT), making it slightly more elegant. The business intent is fully satisfied in both cases.", "overall_assessment": "correct"}}
{"example_id": 1626, "sql_complexity": "aggregation", "prompt": "Find the total value of social impact bonds issued by each organization.", "context": "CREATE TABLE social_impact_bonds (id INT, organization_name VARCHAR(255), issue_year INT, value FLOAT); INSERT INTO social_impact_bonds (id, organization_name, issue_year, value) VALUES (1, 'Acme Corp', 2018, 2000000), (2, 'XYZ Foundation', 2019, 3000000), (3, 'Global Giving', 2018, 1500000), (4, 'Acme Corp', 2019, 2500000), (5, 'XYZ Foundation', 2018, 1000000);", "reference_sql": "SELECT organization_name, SUM(value) as total_value FROM social_impact_bonds GROUP BY organization_name;", "generated_sql": "SELECT organization_name, SUM(value) AS total_value\nFROM social_impact_bonds\nGROUP BY organization_name;", "raw_model_output": "```sql\nSELECT organization_name, SUM(value) AS total_value\nFROM social_impact_bonds\nGROUP BY organization_name;\n```", "latency_sec": 0.9312160015106201, "total_duration_sec": 0.720538414, "load_duration_sec": 0.020578211, "tokens_prompt": 246, "prompt_eval_sec": 0.049721214, "tokens_completion": 28, "completion_eval_sec": 0.647695279, "tokens_total": 274, "tokens_per_sec": 294.23893012525207, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select organization_name and sum the value column, grouping by organization_name. The differences are purely stylistic (capitalization of 'AS' and line breaks) and do not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic. They correctly aggregate the total value of social impact bonds by organization using SUM(value) with GROUP BY organization_name. The queries are syntactically identical, produce the same results, and directly address the business requirement to calculate organization-specific totals. Neither query has any technical issues or semantic differences.", "overall_assessment": "correct"}}
{"example_id": 1315, "sql_complexity": "single join", "prompt": "List all the transactions made by clients living in New York with a transaction amount greater than $1000.", "context": "CREATE TABLE transactions (id INT, client_id INT, transaction_amount DECIMAL(10,2), transaction_date DATE); INSERT INTO transactions (id, client_id, transaction_amount, transaction_date) VALUES (1, 3, 1500.00, '2022-01-01'), (2, 4, 800.00, '2022-01-02'), (3, 3, 1200.00, '2022-01-03'); CREATE TABLE clients (id INT, name VARCHAR(255), state VARCHAR(255)); INSERT INTO clients (id, name, state) VALUES (3, 'Mike Johnson', 'New York'), (4, 'Sara Lee', 'California');", "reference_sql": "SELECT transactions.id, transactions.client_id, transactions.transaction_amount, transactions.transaction_date FROM transactions INNER JOIN clients ON transactions.client_id = clients.id WHERE clients.state = 'New York' AND transactions.transaction_amount > 1000.00;", "generated_sql": "SELECT t.id, t.client_id, t.transaction_amount, t.transaction_date\nFROM transactions t\nJOIN clients c ON t.client_id = c.id\nWHERE c.state = 'New York' AND t.transaction_amount > 1000.00;", "raw_model_output": "```sql\nSELECT t.id, t.client_id, t.transaction_amount, t.transaction_date\nFROM transactions t\nJOIN clients c ON t.client_id = c.id\nWHERE c.state = 'New York' AND t.transaction_amount > 1000.00;\n```", "latency_sec": 1.7076311111450195, "total_duration_sec": 1.424132686, "load_duration_sec": 0.015795792, "tokens_prompt": 274, "prompt_eval_sec": 0.058161618, "tokens_completion": 58, "completion_eval_sec": 1.347884576, "tokens_total": 332, "tokens_per_sec": 194.42138166327018, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between transactions and clients tables on client_id, filter for clients in 'New York' and transactions over 1000. The generated query uses table aliases (t/c) but maintains identical join conditions and WHERE clauses. The semantic meaning remains unchanged.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent as they perform the same inner join between transactions and clients tables, apply identical filters (clients.state = 'New York' and transaction_amount > 1000.00), and select the same columns. The generated query uses table aliases (t/c) which is a matter of style rather than functionality. Both correctly address the business intent by retrieving transactions meeting the specified criteria. The reference query uses explicit table names while the generated query uses aliases, but this doesn't affect result accuracy or performance. Neither query is more efficient than the other as they represent the same logical operation.", "overall_assessment": "correct"}}
{"example_id": 520, "sql_complexity": "multiple_joins", "prompt": "What is the total number of electric vehicles sold in 'California' in the 'sales' schema?", "context": "CREATE TABLE sales_regions (id INT, name VARCHAR(50));   CREATE TABLE sales (id INT, region_id INT, vehicle_count INT);   CREATE TABLE vehicles (id INT, type VARCHAR(50));   INSERT INTO sales_regions VALUES (1, 'California');   INSERT INTO sales VALUES (1, 1, 5000);   INSERT INTO vehicles VALUES (1, 'electric');", "reference_sql": "SELECT SUM(sales.vehicle_count) FROM sales INNER JOIN sales_regions ON sales.region_id = sales_regions.id INNER JOIN vehicles ON sales.id = vehicles.id WHERE vehicles.type = 'electric' AND sales_regions.name = 'California';", "generated_sql": "SELECT SUM(s.vehicle_count) AS total_electric_vehicles_sold\nFROM sales s\nJOIN sales_regions sr ON s.region_id = sr.id\nJOIN vehicles v ON s.vehicle_count = v.id\nWHERE sr.name = 'California' AND v.type = 'electric';", "raw_model_output": "```sql\nSELECT SUM(s.vehicle_count) AS total_electric_vehicles_sold\nFROM sales s\nJOIN sales_regions sr ON s.region_id = sr.id\nJOIN vehicles v ON s.vehicle_count = v.id\nWHERE sr.name = 'California' AND v.type = 'electric';\n```", "latency_sec": 1.7305450439453125, "total_duration_sec": 1.39284903, "load_duration_sec": 0.015226314, "tokens_prompt": 180, "prompt_eval_sec": 0.034458227, "tokens_completion": 60, "completion_eval_sec": 1.340326614, "tokens_total": 240, "tokens_per_sec": 138.6846305097299, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the join condition between 'sales' and 'vehicles'. The Reference SQL uses 'sales.id = vehicles.id', while the Generated SQL uses 'sales.vehicle_count = vehicles.id'. This changes the relationship being joined, leading to different results. For example, in the sample data, the Reference SQL would match the sale (id=1) with the vehicle (id=1), but the Generated SQL would compare vehicle_count (5000) with vehicle.id (1), which does not match.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent due to critical differences in join logic. The reference query correctly joins sales.id = vehicles.id (matching the sample data structure), while the generated query incorrectly uses s.vehicle_count = v.id (which would never match given the sample data where vehicle_count=5000 and v.id=1). The reference query properly filters for 'electric' vehicles in California, whereas the generated query's flawed join would return zero results. Both queries fail to address the actual business intent of counting electric vehicles sold, but the reference query's structure is closer to the schema's implicit relationships.", "overall_assessment": "differently_correct"}}
{"example_id": 3999, "sql_complexity": "single join", "prompt": "What is the total number of tickets sold for performances with a rating of 5?", "context": "CREATE TABLE performance (id INT PRIMARY KEY, name VARCHAR(255), date DATE, artist_id INT, rating INT); INSERT INTO performance (id, name, date, artist_id, rating) VALUES (1, 'Dance Recital', '2022-03-01', 1, 5);", "reference_sql": "SELECT SUM(t.quantity) as total_tickets_sold FROM performance p INNER JOIN ticket t ON p.id = t.performance_id WHERE p.rating = 5;", "generated_sql": "SELECT COUNT(*) AS total_tickets_sold\nFROM performance\nWHERE rating = 5;", "raw_model_output": "```sql\nSELECT COUNT(*) AS total_tickets_sold\nFROM performance\nWHERE rating = 5;\n```", "latency_sec": 0.8484368324279785, "total_duration_sec": 0.538000311, "load_duration_sec": 0.014489151, "tokens_prompt": 162, "prompt_eval_sec": 0.031264032, "tokens_completion": 22, "completion_eval_sec": 0.489117162, "tokens_total": 184, "tokens_per_sec": 216.86941557386862, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the total tickets sold (sum of ticket quantities) for performances with a rating of 5, while the Generated SQL counts the number of performances with a rating of 5. They aggregate different data (sum vs. count) and do not produce the same result.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly joins the performance and ticket tables to sum ticket quantities for 5-rated performances, while the generated query only counts the number of 5-rated performances without considering ticket data. The original question requires aggregating ticket quantities (SUM(t.quantity)), but the generated query uses COUNT(*) which measures rows in the performance table. This results in fundamentally different business insights: the reference answers 'total tickets sold' while the generated answer reflects 'number of high-rated performances'. The reference query is both technically correct and semantically aligned with the business intent.", "overall_assessment": "incorrect"}}
{"example_id": 2261, "sql_complexity": "multiple_joins", "prompt": "What is the total number of animals that have been released into 'protected' habitats, and the average weight of those animals?", "context": "CREATE TABLE habitats (habitat_id INT, habitat_name VARCHAR(50), habitat_status VARCHAR(50)); INSERT INTO habitats (habitat_id, habitat_name, habitat_status) VALUES (1, 'Habitat A', 'protected'), (2, 'Habitat B', 'unprotected'); CREATE TABLE animal_habitats (animal_id INT, habitat_id INT, animal_weight FLOAT); INSERT INTO animal_habitats (animal_id, habitat_id, animal_weight) VALUES (101, 1, 25.5), (102, 2, 15.2); CREATE TABLE animals (animal_id INT, animal_name VARCHAR(50)); INSERT INTO animals (animal_id, animal_name) VALUES (101, 'Dog'), (102, 'Cat');", "reference_sql": "SELECT COUNT(*), AVG(animal_habitats.animal_weight) FROM animal_habitats INNER JOIN animals ON animal_habitats.animal_id = animals.animal_id INNER JOIN habitats ON animal_habitats.habitat_id = habitats.habitat_id WHERE habitats.habitat_status = 'protected';", "generated_sql": "SELECT \n    COUNT(*) AS total_animals,\n    AVG(animal_weight) AS average_weight\nFROM \n    animal_habitats ah\nJOIN \n    habitats h ON ah.habitat_id = h.habitat_id\nWHERE \n    h.habitat_status = 'protected';", "raw_model_output": "```sql\nSELECT \n    COUNT(*) AS total_animals,\n    AVG(animal_weight) AS average_weight\nFROM \n    animal_habitats ah\nJOIN \n    habitats h ON ah.habitat_id = h.habitat_id\nWHERE \n    h.habitat_status = 'protected';\n```", "latency_sec": 1.5859310626983643, "total_duration_sec": 1.559719405, "load_duration_sec": 0.01533827, "tokens_prompt": 270, "prompt_eval_sec": 0.057339386, "tokens_completion": 64, "completion_eval_sec": 1.483834565, "tokens_total": 334, "tokens_per_sec": 210.6018400520635, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes an unnecessary INNER JOIN with the 'animals' table, which could filter out rows if there are orphaned entries in 'animal_habitats' (i.e., animal_ids without matching entries in 'animals'). The Generated SQL omits this join, potentially including such rows. While the sample data may produce the same result, the queries are not semantically equivalent in general cases where data inconsistencies exist.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the total number of animals in 'protected' habitats and their average weight. The reference query includes an unnecessary join with the 'animals' table, which doesn't affect the result but adds complexity. The generated query achieves the same outcome with fewer joins, making it more efficient and elegant. Both are technically correct and fulfill the business intent, but the generated query is superior due to its simplicity.", "overall_assessment": "correct"}}
{"example_id": 3439, "sql_complexity": "multiple_joins", "prompt": "How many menu items contain ingredients sourced from local suppliers for each restaurant?", "context": "CREATE TABLE restaurants (id INT, name VARCHAR(50), location VARCHAR(50)); INSERT INTO restaurants VALUES (1, 'Restaurant A', 'City A'); INSERT INTO restaurants VALUES (2, 'Restaurant B', 'City B'); CREATE TABLE menu_items (id INT, name VARCHAR(50), restaurant_id INT, price DECIMAL(5,2)); INSERT INTO menu_items VALUES (1, 'Item A', 1, 10.99); INSERT INTO menu_items VALUES (2, 'Item B', 1, 12.99); INSERT INTO menu_items VALUES (3, 'Item C', 2, 11.99); CREATE TABLE ingredients (id INT, name VARCHAR(50), local_source BOOLEAN, menu_item_id INT); INSERT INTO ingredients VALUES (1, 'Ingredient A', TRUE, 1); INSERT INTO ingredients VALUES (2, 'Ingredient B', FALSE, 1); INSERT INTO ingredients VALUES (3, 'Ingredient C', TRUE, 2); INSERT INTO ingredients VALUES (4, 'Ingredient D', FALSE, 2); INSERT INTO ingredients VALUES (5, 'Ingredient E', TRUE, 3);", "reference_sql": "SELECT r.name, COUNT(DISTINCT mi.id) as num_local_items FROM restaurants r JOIN menu_items mi ON r.id = mi.restaurant_id JOIN ingredients i ON mi.id = i.menu_item_id WHERE i.local_source = TRUE GROUP BY r.name;", "generated_sql": "SELECT \n    r.name AS restaurant_name,\n    COUNT(DISTINCT mi.id) AS num_menu_items_with_local_ingredients\nFROM \n    restaurants r\nJOIN \n    menu_items mi ON r.id = mi.restaurant_id\nJOIN \n    ingredients i ON mi.id = i.menu_item_id\nWHERE \n    i.local_source = TRUE\nGROUP BY \n    r.name;", "raw_model_output": "```sql\nSELECT \n    r.name AS restaurant_name,\n    COUNT(DISTINCT mi.id) AS num_menu_items_with_local_ingredients\nFROM \n    restaurants r\nJOIN \n    menu_items mi ON r.id = mi.restaurant_id\nJOIN \n    ingredients i ON mi.id = i.menu_item_id\nWHERE \n    i.local_source = TRUE\nGROUP BY \n    r.name;\n```", "latency_sec": 2.2431800365448, "total_duration_sec": 1.98881427, "load_duration_sec": 0.020235839, "tokens_prompt": 333, "prompt_eval_sec": 0.075179304, "tokens_completion": 81, "completion_eval_sec": 1.89109142, "tokens_total": 414, "tokens_per_sec": 184.55941710220003, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same data by joining the same tables with identical conditions, filtering on local_source = TRUE, and grouping by restaurant name. The differences are only in column aliases (e.g., 'name' vs 'restaurant_name', 'num_local_items' vs 'num_menu_items_with_local_ingredients'), which do not affect the semantic meaning or result set.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically equivalent as they produce identical results through the same logical structure: joining restaurants, menu_items, and ingredients tables; filtering for local ingredients; and counting distinct menu items per restaurant. The generated query improves upon the reference by using more descriptive column aliases (e.g., 'restaurant_name' vs 'name', 'num_menu_items_with_local_ingredients' vs 'num_local_items'), enhancing readability and clarity for business users. The business intent is fully fulfilled as both correctly count menu items with at least one local ingredient per restaurant. The generated query's improved naming convention makes it more elegant and user-friendly without altering functionality.", "overall_assessment": "correct"}}
{"example_id": 2265, "sql_complexity": "aggregation", "prompt": "Hourly revenue for a specific movie?", "context": "CREATE TABLE Movie_Revenue (id INT, movie_title VARCHAR(100), revenue_time TIME, revenue DECIMAL(10,2));", "reference_sql": "SELECT revenue_time, SUM(revenue) FROM Movie_Revenue WHERE movie_title = 'Spider-Man: No Way Home' GROUP BY revenue_time;", "generated_sql": "SELECT \n    DATE_FORMAT(revenue_time, '%H') AS hour,\n    SUM(revenue) AS total_revenue\nFROM \n    Movie_Revenue\nWHERE \n    movie_title = 'Specific Movie Title'\nGROUP BY \n    DATE_FORMAT(revenue_time, '%H')\nORDER BY \n    hour;", "raw_model_output": "```sql\nSELECT \n    DATE_FORMAT(revenue_time, '%H') AS hour,\n    SUM(revenue) AS total_revenue\nFROM \n    Movie_Revenue\nWHERE \n    movie_title = 'Specific Movie Title'\nGROUP BY \n    DATE_FORMAT(revenue_time, '%H')\nORDER BY \n    hour;\n```", "latency_sec": 1.8136088848114014, "total_duration_sec": 1.510941977, "load_duration_sec": 0.015733246, "tokens_prompt": 114, "prompt_eval_sec": 0.023122113, "tokens_completion": 67, "completion_eval_sec": 1.46924895, "tokens_total": 181, "tokens_per_sec": 99.80101085511738, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent.  The WHERE clause uses different movie titles ('Spider-Man: No Way Home' vs 'Specific Movie Title').  The grouping is different (full revenue_time vs hour extracted from revenue_time).  Additionally, the generated query includes an ORDER BY clause not present in the reference query.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query groups by the exact 'revenue_time' (e.g., 10:00:00, 10:15:00), which would not aggregate revenue into hourly buckets as intended. The generated query correctly extracts the hour portion using DATE_FORMAT('%H') and groups by that, aligning with the 'hourly revenue' requirement. While the generated query uses a placeholder ('Specific Movie Title') instead of the exact movie name, this is likely a parameterization artifact. The generated query's structure better fulfills the business intent of aggregating revenue by hour.", "overall_assessment": "differently_correct"}}
{"example_id": 1763, "sql_complexity": "multiple_joins", "prompt": "What is the total food and beverage revenue last month for hotels in 'Bangkok'?", "context": "CREATE TABLE revenue (hotel_id INT, revenue_source VARCHAR(50), revenue INT, revenue_date DATE); INSERT INTO revenue (hotel_id, revenue_source, revenue, revenue_date) VALUES (5, 'Room revenue', 12000, '2022-03-01'), (5, 'Food and beverage', 4000, '2022-03-02'), (5, 'Other revenue', 1000, '2022-03-03'); CREATE TABLE hotels (hotel_id INT, city VARCHAR(50)); INSERT INTO hotels (hotel_id, city) VALUES (5, 'Bangkok'); CREATE TABLE dates (date DATE); INSERT INTO dates (date) VALUES ('2022-03-01'), ('2022-03-02'), ('2022-03-03');", "reference_sql": "SELECT SUM(revenue) FROM revenue JOIN hotels ON revenue.hotel_id = hotels.hotel_id JOIN dates ON revenue.revenue_date = dates.date WHERE hotels.city = 'Bangkok' AND revenue_source = 'Food and beverage' AND dates.date >= DATEADD(month, -1, GETDATE());", "generated_sql": "SELECT SUM(revenue) AS total_food_and_beverage_revenue\nFROM revenue\nJOIN hotels ON revenue.hotel_id = hotels.hotel_id\nWHERE hotels.city = 'Bangkok'\n  AND revenue.revenue_source = 'Food and beverage'\n  AND revenue_date >= DATEADD(MONTH, DATEDIFF(MONTH, 0, GETDATE()) - 1, 0)\n  AND revenue_date < DATEADD(MONTH, DATEDIFF(MONTH, 0, GETDATE()), 0);", "raw_model_output": "```sql\nSELECT SUM(revenue) AS total_food_and_beverage_revenue\nFROM revenue\nJOIN hotels ON revenue.hotel_id = hotels.hotel_id\nWHERE hotels.city = 'Bangkok'\n  AND revenue.revenue_source = 'Food and beverage'\n  AND revenue_date >= DATEADD(MONTH, DATEDIFF(MONTH, 0, GETDATE()) - 1, 0)\n  AND revenue_date < DATEADD(MONTH, DATEDIFF(MONTH, 0, GETDATE()), 0);\n```", "latency_sec": 2.982646942138672, "total_duration_sec": 2.687736371, "load_duration_sec": 0.016354782, "tokens_prompt": 290, "prompt_eval_sec": 0.058551066, "tokens_completion": 114, "completion_eval_sec": 2.609979103, "tokens_total": 404, "tokens_per_sec": 135.4501581438655, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their date filtering logic. The Reference SQL uses `dates.date >= DATEADD(month, -1, GETDATE())` which checks for dates within the last month from the current date, while the Generated SQL uses a range for the entire previous month (e.g., first day of previous month to first day of current month). Additionally, the Reference SQL joins with the `dates` table, which the Generated SQL omits, potentially affecting results if the `dates` table contains dates outside the generated range.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in date filtering logic. The Reference SQL uses `dates.date >= DATEADD(month, -1, GETDATE())` which captures dates from one month ago to today, potentially including partial months. The Generated SQL uses a more precise range: `revenue_date >= DATEADD(MONTH, DATEDIFF(MONTH, 0, GETDATE()) - 1, 0)` (start of previous month) and `revenue_date < DATEADD(MONTH, DATEDIFF(MONTH, 0, GETDATE()), 0)` (start of current month), ensuring full month coverage. Additionally, the Generated SQL avoids an unnecessary join with the `dates` table, improving efficiency. Both fulfill the business intent, but the Generated SQL's date logic is more accurate for 'last month'.", "overall_assessment": "correct"}}
{"example_id": 5499, "sql_complexity": "set operations", "prompt": "How many legal aid clinics and community mediation centers are there in total, and what is the sum of cases handled by each type of center, for centers located in the state of California?", "context": "CREATE TABLE LegalAidClinics (ClinicName text, State text, NumCases int); INSERT INTO LegalAidClinics VALUES ('Clinic1', 'CA', 30, '2022-01-01'), ('Clinic2', 'CA', 25, '2022-01-01'); CREATE TABLE CommunityMediationCenters (CenterName text, State text, NumCases int); INSERT INTO CommunityMediationCenters VALUES ('CM1', 'CA', 22, '2022-01-01'), ('CM2', 'CA', 28, '2022-01-01');", "reference_sql": "SELECT State, 'Legal Aid Clinics' AS CenterType, COUNT(*) AS NumCenters, SUM(NumCases) AS TotalCases FROM LegalAidClinics WHERE State = 'CA' UNION ALL SELECT State, 'Community Mediation Centers', COUNT(*), SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA';", "generated_sql": "SELECT \n    'LegalAidClinics' AS CenterType,\n    COUNT(*) AS TotalCenters,\n    SUM(NumCases) AS TotalCases\nFROM \n    LegalAidClinics\nWHERE \n    State = 'CA'\nUNION ALL\nSELECT \n    'CommunityMediationCenters' AS CenterType,\n    COUNT(*) AS TotalCenters,\n    SUM(NumCases) AS TotalCases\nFROM \n    CommunityMediationCenters\nWHERE \n    State = 'CA';", "raw_model_output": "```sql\nSELECT \n    'LegalAidClinics' AS CenterType,\n    COUNT(*) AS TotalCenters,\n    SUM(NumCases) AS TotalCases\nFROM \n    LegalAidClinics\nWHERE \n    State = 'CA'\nUNION ALL\nSELECT \n    'CommunityMediationCenters' AS CenterType,\n    COUNT(*) AS TotalCenters,\n    SUM(NumCases) AS TotalCases\nFROM \n    CommunityMediationCenters\nWHERE \n    State = 'CA';\n```", "latency_sec": 2.7163338661193848, "total_duration_sec": 2.514999892, "load_duration_sec": 0.016144339, "tokens_prompt": 262, "prompt_eval_sec": 0.05785118, "tokens_completion": 107, "completion_eval_sec": 2.438207296, "tokens_total": 369, "tokens_per_sec": 135.84486229859573, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in column structure and naming. The Reference SQL includes a 'State' column and uses 'NumCenters' for the count, while the Generated SQL omits 'State' and uses 'TotalCenters' for the count. Additionally, the Generated SQL's second query lacks the 'State' filter explicitly, though both filter by State = 'CA'. The result sets have different columns, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because the reference query includes a redundant 'State' column in the output (which is always 'CA' due to the WHERE clause), while the generated query omits it. Both correctly calculate counts and sums for California centers, but the generated query is more concise and aligns better with the business intent by avoiding unnecessary data. The reference query's inclusion of 'State' doesn't add value since the question specifically focuses on California. Both queries efficiently filter by 'CA' and use UNION ALL to separate the two center types.", "overall_assessment": "differently_correct"}}
{"example_id": 2408, "sql_complexity": "aggregation", "prompt": "What is the average number of victories for players from Japan and South Korea, partitioned by game mode?", "context": "CREATE TABLE PlayerVictories (PlayerID INT, GameMode VARCHAR(255), Victories INT, Country VARCHAR(255)); INSERT INTO PlayerVictories (PlayerID, GameMode, Victories, Country) VALUES (1, 'Battle Royale', 25, 'Japan'), (2, 'Team Deathmatch', 18, 'South Korea');", "reference_sql": "SELECT GameMode, AVG(Victories) as AvgVictories FROM PlayerVictories WHERE Country IN ('Japan', 'South Korea') GROUP BY GameMode, Country WITH ROLLUP;", "generated_sql": "SELECT GameMode, AVG(Victories) AS AverageVictories\nFROM PlayerVictories\nWHERE Country IN ('Japan', 'South Korea')\nGROUP BY GameMode;", "raw_model_output": "```sql\nSELECT GameMode, AVG(Victories) AS AverageVictories\nFROM PlayerVictories\nWHERE Country IN ('Japan', 'South Korea')\nGROUP BY GameMode;\n```", "latency_sec": 1.0214898586273193, "total_duration_sec": 0.923542424, "load_duration_sec": 0.013570003, "tokens_prompt": 174, "prompt_eval_sec": 0.034402607, "tokens_completion": 39, "completion_eval_sec": 0.872724187, "tokens_total": 213, "tokens_per_sec": 208.51895709099838, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes 'Country' in the GROUP BY clause and uses WITH ROLLUP, which adds summary rows for each GameMode/Country combination and a final total row. The Generated SQL groups only by GameMode, omitting Country and ROLLUP. This results in different aggregation scopes (per-game-mode-and-country vs. per-game-mode) and missing summary rows, making the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL groups by both GameMode and Country (with ROLLUP), which introduces unnecessary granularity and adds subtotal/grand total rows not requested in the original question. The Generated SQL correctly groups only by GameMode, calculating the average victories across all players from Japan and South Korea per game mode. While both queries filter the correct countries, the Reference SQL's additional grouping and ROLLUP clause produce results that diverge from the business requirement of 'partitioned by game mode' without country segmentation. The Generated SQL is more efficient and directly addresses the question's intent.", "overall_assessment": "differently_correct"}}
{"example_id": 2729, "sql_complexity": "subqueries", "prompt": "Find the total number of trips made by shared autonomous vehicles in Seattle", "context": "CREATE TABLE shared_vehicles (id INT, vehicle_type VARCHAR(20), is_autonomous BOOLEAN, trip_count INT); INSERT INTO shared_vehicles (id, vehicle_type, is_autonomous, trip_count) VALUES (1, 'ebike', false, 1200), (2, 'escooter', false, 800), (3, 'car', true, 1500); CREATE TABLE city_data (city VARCHAR(20), has_autonomous_vehicles BOOLEAN); INSERT INTO city_data (city, has_autonomous_vehicles) VALUES ('Seattle', true), ('Denver', false), ('Portland', true);", "reference_sql": "SELECT SUM(trip_count) FROM shared_vehicles WHERE is_autonomous = true AND vehicle_type != 'ebike' AND vehicle_type != 'escooter' AND city IN (SELECT city FROM city_data WHERE has_autonomous_vehicles = true AND city = 'Seattle');", "generated_sql": "SELECT SUM(trip_count) AS total_trips\nFROM shared_vehicles sv\nJOIN city_data cd ON sv.is_autonomous = cd.has_autonomous_vehicles\nWHERE sv.is_autonomous = true AND cd.city = 'Seattle';", "raw_model_output": "```sql\nSELECT SUM(trip_count) AS total_trips\nFROM shared_vehicles sv\nJOIN city_data cd ON sv.is_autonomous = cd.has_autonomous_vehicles\nWHERE sv.is_autonomous = true AND cd.city = 'Seattle';\n```", "latency_sec": 1.454483985900879, "total_duration_sec": 1.264902347, "load_duration_sec": 0.015238025, "tokens_prompt": 224, "prompt_eval_sec": 0.044935755, "tokens_completion": 53, "completion_eval_sec": 1.20255567, "tokens_total": 277, "tokens_per_sec": 190.44554817042666, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Reference SQL includes vehicle_type filters ('ebike' and 'escooter' exclusion) which the Generated SQL lacks. Second, the Reference SQL incorrectly references a non-existent 'city' column in shared_vehicles, while the Generated SQL joins city_data on is_autonomous = has_autonomous_vehicles, leading to different filtering logic. The Generated SQL also doesn't enforce the vehicle_type restrictions, resulting in potentially different sums.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL contains a critical syntax error by referencing a non-existent 'city' column in the shared_vehicles table. The Generated SQL is syntactically valid but logically flawed. While it correctly filters for autonomous vehicles (sv.is_autonomous = true) and Seattle (cd.city = 'Seattle'), its join condition (sv.is_autonomous = cd.has_autonomous_vehicles) incorrectly links vehicles to cities based on autonomous status rather than geographic location. Neither query properly addresses the missing city information in the shared_vehicles table, but the Generated SQL avoids the syntax error and better aligns with the business intent of filtering for Seattle.", "overall_assessment": "differently_correct"}}
{"example_id": 2952, "sql_complexity": "aggregation", "prompt": "Show the total budget allocated for each program category in 2023.", "context": "CREATE TABLE Budget (id INT, category TEXT, year INT, allocated_amount INT); INSERT INTO Budget (id, category, year, allocated_amount) VALUES (1, 'Education', 2023, 30000); INSERT INTO Budget (id, category, year, allocated_amount) VALUES (2, 'Healthcare', 2023, 50000);", "reference_sql": "SELECT category, SUM(allocated_amount) FROM Budget WHERE year = 2023 GROUP BY category;", "generated_sql": "SELECT category, SUM(allocated_amount) AS total_allocated\nFROM Budget\nWHERE year = 2023\nGROUP BY category;", "raw_model_output": "```sql\nSELECT category, SUM(allocated_amount) AS total_allocated\nFROM Budget\nWHERE year = 2023\nGROUP BY category;\n```", "latency_sec": 1.0750939846038818, "total_duration_sec": 0.794929391, "load_duration_sec": 0.013891994, "tokens_prompt": 176, "prompt_eval_sec": 0.04130453, "tokens_completion": 33, "completion_eval_sec": 0.737391887, "tokens_total": 209, "tokens_per_sec": 194.40160859704375, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (category and summed allocated_amount) from the Budget table where year = 2023, grouped by category. The generated query adds an alias (total_allocated) to the sum, but this does not affect the semantic result - the data returned (category names and corresponding summed amounts) remains identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the total allocated budget per category for 2023 using SUM and GROUP BY. The generated query improves upon the reference by adding an explicit alias (total_allocated) for the aggregated column, which enhances readability and clearly communicates the meaning of the calculated field. While the reference query is technically correct, the generated version is more elegant and aligns better with best practices for query clarity without altering functionality.", "overall_assessment": "correct"}}
{"example_id": 4328, "sql_complexity": "aggregation", "prompt": "What is the average cargo handling time in hours for each port?", "context": "CREATE TABLE cargo_handling (id INT, port_id INT, time_in_hours DECIMAL(5,2)); INSERT INTO cargo_handling (id, port_id, time_in_hours) VALUES (1, 1, 20.5), (2, 1, 22.3), (3, 2, 18.7);", "reference_sql": "SELECT port_id, AVG(time_in_hours) FROM cargo_handling GROUP BY port_id;", "generated_sql": "SELECT port_id, AVG(time_in_hours) AS average_time_in_hours\nFROM cargo_handling\nGROUP BY port_id;", "raw_model_output": "```sql\nSELECT port_id, AVG(time_in_hours) AS average_time_in_hours\nFROM cargo_handling\nGROUP BY port_id;\n```", "latency_sec": 0.7556769847869873, "total_duration_sec": 0.698284868, "load_duration_sec": 0.015377081, "tokens_prompt": 162, "prompt_eval_sec": 0.031860552, "tokens_completion": 29, "completion_eval_sec": 0.648417612, "tokens_total": 191, "tokens_per_sec": 252.7534963286459, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries perform the same aggregation (AVG(time_in_hours)) on the cargo_handling table, grouped by port_id. The generated query only adds an explicit column alias (average_time_in_hours) which does not affect the semantic result set content.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the average cargo handling time per port using AVG() and GROUP BY. The generated query adds an explicit alias (average_time_in_hours) which improves readability but doesn't alter the result. The reference query is functionally identical but less descriptive. Neither query contains syntax errors or logical flaws. Both address the business intent of determining average handling times by port.", "overall_assessment": "correct"}}
{"example_id": 4915, "sql_complexity": "window functions", "prompt": "Calculate the percentage of total Europium production for each country.", "context": "CREATE TABLE europium_production (country VARCHAR(50), quantity INT);", "reference_sql": "SELECT country, quantity * 100.0 / SUM(quantity) OVER (PARTITION BY NULL) AS percentage FROM europium_production;", "generated_sql": "SELECT \n    country, \n    (quantity * 100.0 / SUM(quantity) OVER ()) AS percentage_of_total\nFROM \n    europium_production;", "raw_model_output": "```sql\nSELECT \n    country, \n    (quantity * 100.0 / SUM(quantity) OVER ()) AS percentage_of_total\nFROM \n    europium_production;\n```", "latency_sec": 1.1629209518432617, "total_duration_sec": 0.889839102, "load_duration_sec": 0.015693497, "tokens_prompt": 103, "prompt_eval_sec": 0.019834572, "tokens_completion": 39, "completion_eval_sec": 0.851341437, "tokens_total": 142, "tokens_per_sec": 122.10632182258483, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the percentage of each country's production relative to the total production. The window function SUM(quantity) OVER () in the generated query is equivalent to SUM(quantity) OVER (PARTITION BY NULL) in the reference query, as PARTITION BY NULL creates a single partition for the entire dataset. The column alias difference (percentage vs. percentage_of_total) does not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the percentage of total Europium production per country using window functions. The reference query uses `SUM(quantity) OVER (PARTITION BY NULL)` while the generated query uses `SUM(quantity) OVER ()`. These are functionally identical as both compute the total sum across all rows. The column aliases differ slightly (`percentage` vs `percentage_of_total`), but this does not affect the calculation. Both queries handle edge cases (e.g., zero values, empty datasets) appropriately. The generated query is slightly more concise with `OVER()`, but neither is significantly more efficient. Both fulfill the business intent of determining each country's share of total production.", "overall_assessment": "correct"}}
{"example_id": 5030, "sql_complexity": "subqueries", "prompt": "What is the success rate of diverse-led startups (at least 1 female or underrepresented racial or ethnic group executive) in the past 3 years?", "context": "CREATE TABLE DiverseStartups(id INT, name TEXT, country TEXT, year INT, success BOOLEAN);   INSERT INTO DiverseStartups VALUES (1, 'FemTech', 'USA', 2020, true), (2, 'GreenCity', 'Canada', 2019, false), (3, 'AI-Health', 'UK', 2021, true), (4, 'SolarEnergy', 'USA', 2020, false), (5, 'DataAnalytics', 'Germany', 2019, true), (6, 'SmartGrid', 'USA', 2021, true), (7, 'CloudServices', 'India', 2020, false), (8, 'RenewableEnergy', 'USA', 2019, true);", "reference_sql": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3) AS success_rate FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3 AND success = true;", "generated_sql": "SELECT \n    (SUM(CASE WHEN success = TRUE THEN 1 ELSE 0 END) * 1.0 / COUNT(*)) AS success_rate\nFROM \n    DiverseStartups\nWHERE \n    year >= YEAR(CURRENT_DATE) - 3;", "raw_model_output": "```sql\nSELECT \n    (SUM(CASE WHEN success = TRUE THEN 1 ELSE 0 END) * 1.0 / COUNT(*)) AS success_rate\nFROM \n    DiverseStartups\nWHERE \n    year >= YEAR(CURRENT_DATE) - 3;\n```", "latency_sec": 1.6383988857269287, "total_duration_sec": 1.439525546, "load_duration_sec": 0.016096476, "tokens_prompt": 284, "prompt_eval_sec": 0.05970941, "tokens_completion": 59, "completion_eval_sec": 1.360834088, "tokens_total": 343, "tokens_per_sec": 209.35072831657655, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates a percentage (multiplied by 100) while the Generated SQL computes a ratio (without multiplying by 100). For example, if 3 out of 5 startups are successful, Reference returns 60.0 (3*100/5) and Generated returns 0.6 (3/5). The numerical results differ by a factor of 100.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries calculate the success rate of diverse-led startups in the past 3 years. The reference query uses a subquery to calculate the denominator, while the generated query uses a single aggregation with a CASE statement. Both correctly filter the time window (year >= YEAR(CURRENT_DATE) - 3) and compute the ratio of successful startups. The generated query is more efficient as it avoids a subquery and uses explicit aggregation, making it more elegant. However, both handle the division correctly (1.0 vs 100.0) to ensure floating-point results.", "overall_assessment": "correct"}}
{"example_id": 4626, "sql_complexity": "aggregation", "prompt": "What was the maximum number of training hours for farmers in each country in 2020?", "context": "CREATE TABLE training (id INT, country_id INT, farmer_id INT, hours INT, date DATE);", "reference_sql": "SELECT country_id, MAX(hours) FROM training WHERE YEAR(date) = 2020 GROUP BY country_id;", "generated_sql": "SELECT \n    country_id, \n    MAX(hours) AS max_training_hours\nFROM \n    training\nWHERE \n    YEAR(date) = 2020\nGROUP BY \n    country_id;", "raw_model_output": "```sql\nSELECT \n    country_id, \n    MAX(hours) AS max_training_hours\nFROM \n    training\nWHERE \n    YEAR(date) = 2020\nGROUP BY \n    country_id;\n```", "latency_sec": 1.0913710594177246, "total_duration_sec": 1.052737517, "load_duration_sec": 0.01600161, "tokens_prompt": 117, "prompt_eval_sec": 0.024339252, "tokens_completion": 46, "completion_eval_sec": 1.010267134, "tokens_total": 163, "tokens_per_sec": 149.35341980477733, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select country_id and the maximum hours from the training table where the date is in 2020, grouped by country_id. The only difference is the column alias (max_training_hours vs. implicit name), which does not affect the semantic result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically correct and produce identical results. The Reference SQL returns the same data as the Generated SQL but without an explicit column alias. The Generated SQL improves readability by naming the aggregated column 'max_training_hours', which better communicates the meaning of the result to end-users. While both satisfy the business intent of identifying maximum training hours per country in 2020, the Generated SQL's explicit alias makes it more elegant and user-friendly without altering the logical outcome.", "overall_assessment": "correct"}}
{"example_id": 2703, "sql_complexity": "set operations", "prompt": "Identify the species unique to 'MarineResearchAreaA' and 'MarineResearchAreaB'", "context": "CREATE TABLE ResearchAreaSpecies (area VARCHAR(255), species VARCHAR(255)); INSERT INTO ResearchAreaSpecies (area, species) VALUES ('MarineResearchAreaA', 'Coral'), ('MarineResearchAreaA', 'Starfish'), ('MarineResearchAreaB', 'Jellyfish');", "reference_sql": "(SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB') UNION (SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA');", "generated_sql": "SELECT species \nFROM ResearchAreaSpecies \nWHERE area IN ('MarineResearchAreaA', 'MarineResearchAreaB') \nGROUP BY species \nHAVING COUNT(DISTINCT area) = 2;", "raw_model_output": "```sql\nSELECT species \nFROM ResearchAreaSpecies \nWHERE area IN ('MarineResearchAreaA', 'MarineResearchAreaB') \nGROUP BY species \nHAVING COUNT(DISTINCT area) = 2;\n```", "latency_sec": 1.2911098003387451, "total_duration_sec": 1.100357822, "load_duration_sec": 0.014133593, "tokens_prompt": 162, "prompt_eval_sec": 0.03171542, "tokens_completion": 47, "completion_eval_sec": 1.051689339, "tokens_total": 209, "tokens_per_sec": 161.87624007281582, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL computes the symmetric difference (species unique to each area), while the Generated SQL finds species present in both areas. The first returns species in either area but not both, the second returns only species common to both. Their results are complementary, not equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly identifies species unique to each area using EXCEPT and UNION to find asymmetric differences. The generated query mistakenly finds species present in both areas (COUNT(DISTINCT area) = 2) rather than unique ones. While the generated query is more efficient, it fundamentally misinterprets the business requirement. The reference query properly addresses the 'unique to' requirement by comparing sets between the two areas.", "overall_assessment": "incorrect"}}
{"example_id": 200, "sql_complexity": "window functions", "prompt": "List the top three categories of workforce development programs with the highest budget increases.", "context": "CREATE TABLE programs (program_id INT, program_name VARCHAR(50), budget DECIMAL(10, 2), category VARCHAR(50), budget_date DATE);", "reference_sql": "SELECT category, SUM(budget - LAG(budget) OVER (PARTITION BY category ORDER BY budget_date)) as total_budget_increase FROM programs GROUP BY category ORDER BY total_budget_increase DESC LIMIT 3;", "generated_sql": "SELECT category, SUM(budget) AS total_budget_increase\nFROM programs\nWHERE program_name LIKE '%workforce development%'\nGROUP BY category\nORDER BY total_budget_increase DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT category, SUM(budget) AS total_budget_increase\nFROM programs\nWHERE program_name LIKE '%workforce development%'\nGROUP BY category\nORDER BY total_budget_increase DESC\nLIMIT 3;\n```", "latency_sec": 1.1209158897399902, "total_duration_sec": 1.024307309, "load_duration_sec": 0.013971314, "tokens_prompt": 126, "prompt_eval_sec": 0.025042854, "tokens_completion": 44, "completion_eval_sec": 0.98257525, "tokens_total": 170, "tokens_per_sec": 151.66169161847952, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates the total budget increase per category using a window function (LAG) to compare consecutive budgets, while the generated query sums absolute budgets for programs matching a specific name pattern. Key differences: 1) Filtering on program_name in generated query 2) Different calculation logic (budget difference vs. sum of budgets) 3) No window function in generated query.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query attempts to calculate budget increases by using the LAG function to compare consecutive budgets within each category, then sums those differences. However, this approach is flawed because it sums individual period-over-period changes rather than total cumulative increases. The generated query incorrectly calculates total budgets instead of budget increases and lacks proper filtering for 'workforce development' programs. Neither query fully addresses the question, but the reference query better aligns with the intent of measuring budget changes, even though both have critical flaws.", "overall_assessment": "differently_correct"}}
{"example_id": 5131, "sql_complexity": "basic SQL", "prompt": "How many wells were drilled in the Eagle Ford Shale and Bakken Formation?", "context": "CREATE TABLE wells (id INT, region VARCHAR(255), well_type VARCHAR(255), num_drilled INT); INSERT INTO wells (id, region, well_type, num_drilled) VALUES (1, 'Eagle Ford Shale', 'Oil', 2000), (2, 'Eagle Ford Shale', 'Gas', 1500), (3, 'Bakken Formation', 'Oil', 1000), (4, 'Bakken Formation', 'Gas', 1200);", "reference_sql": "SELECT SUM(num_drilled) as total_wells FROM wells WHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "generated_sql": "SELECT SUM(num_drilled) AS total_wells_drilled\nFROM wells\nWHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "raw_model_output": "```sql\nSELECT SUM(num_drilled) AS total_wells_drilled\nFROM wells\nWHERE region IN ('Eagle Ford Shale', 'Bakken Formation');\n```", "latency_sec": 0.9962210655212402, "total_duration_sec": 0.900825234, "load_duration_sec": 0.016862398, "tokens_prompt": 209, "prompt_eval_sec": 0.043116748, "tokens_completion": 37, "completion_eval_sec": 0.838374542, "tokens_total": 246, "tokens_per_sec": 246.93314417246188, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of num_drilled for wells in the 'Eagle Ford Shale' and 'Bakken Formation' regions. The only difference is the alias name (total_wells vs. total_wells_drilled), which doesn't affect the semantic result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically identical in structure, logic, and output. The only difference is the column alias name ('total_wells' vs 'total_wells_drilled'), which does not affect the result. Both correctly sum the 'num_drilled' values for the specified regions, fulfilling the business intent of counting total wells drilled in Eagle Ford Shale and Bakken Formation. Neither query is more efficient or elegant than the other, as they perform the same operation with identical syntax.", "overall_assessment": "correct"}}
{"example_id": 1160, "sql_complexity": "subqueries", "prompt": "What is the total revenue generated from ads on Instagram in March 2021, for users in the 'brand' category who have posted more than 10 times?", "context": "CREATE TABLE ads (ad_id INT, user_id INT, platform VARCHAR(255), ad_revenue DECIMAL(10,2), post_count INT); INSERT INTO ads (ad_id, user_id, platform, ad_revenue, post_count) VALUES (1, 1, 'Instagram', 150.50, 12), (2, 2, 'Twitter', 80.00, 15), (3, 3, 'Instagram', 120.75, 8);", "reference_sql": "SELECT SUM(ad_revenue) FROM ads WHERE platform = 'Instagram' AND MONTH(ad_date) = 3 AND YEAR(ad_date) = 2021 AND user_id IN (SELECT user_id FROM users WHERE category = 'brand' AND post_count > 10);", "generated_sql": "SELECT SUM(ad_revenue) AS total_revenue\nFROM ads\nWHERE platform = 'Instagram'\nAND user_id IN (\n    SELECT user_id\n    FROM user_categories\n    WHERE category = 'brand'\n)\nAND post_count > 10\nAND MONTH(ad_date) = 3 AND YEAR(ad_date) = 2021;", "raw_model_output": "```sql\nSELECT SUM(ad_revenue) AS total_revenue\nFROM ads\nWHERE platform = 'Instagram'\nAND user_id IN (\n    SELECT user_id\n    FROM user_categories\n    WHERE category = 'brand'\n)\nAND post_count > 10\nAND MONTH(ad_date) = 3 AND YEAR(ad_date) = 2021;\n```", "latency_sec": 1.98897385597229, "total_duration_sec": 1.794779705, "load_duration_sec": 0.016528895, "tokens_prompt": 227, "prompt_eval_sec": 0.046111814, "tokens_completion": 76, "completion_eval_sec": 1.72942059, "tokens_total": 303, "tokens_per_sec": 152.33986062219077, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. 1) The Reference SQL uses a subquery on a 'users' table (not defined in the provided schema) with a 'post_count' condition, while the Generated SQL uses a subquery on a 'user_categories' table (also not defined) and applies the 'post_count > 10' condition directly to the 'ads' table. 2) The Reference SQL's subquery filters users with 'category = 'brand'' and 'post_count > 10', while the Generated SQL's subquery only filters by 'category = 'brand'' and applies the 'post_count > 10' condition to the ads table. These differences in table structure and filtering logic will lead to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly addresses the business intent by filtering users in the 'brand' category with post_count > 10 via a subquery on a users table (even though the schema doesn't explicitly show it). The Generated SQL incorrectly applies post_count > 10 to the ads table instead of user data, which misrepresents the requirement. Both queries reference non-existent tables (users/user_categories), but the Reference SQL's logic aligns better with the business question. The Generated SQL's placement of post_count > 10 in the main query is technically incorrect for the user's post count requirement.", "overall_assessment": "differently_correct"}}
{"example_id": 4708, "sql_complexity": "subqueries", "prompt": "What is the maximum number of high-level threats reported by a single agency in a month?", "context": "CREATE TABLE Threat_Intelligence (Threat_ID INT, Threat_Type VARCHAR(50), Threat_Level VARCHAR(50), Reported_Date DATE, Reporting_Agency VARCHAR(50)); CREATE VIEW High_Level_Threats AS SELECT Threat_Type, Threat_Level, Reported_Date FROM Threat_Intelligence WHERE Threat_Level = 'High';", "reference_sql": "SELECT Reporting_Agency, MAX(Number_of_High_Level_Threats) as Max_High_Level_Threats_in_a_Month FROM (SELECT Reporting_Agency, TO_CHAR(Reported_Date, 'YYYY-MM') as Month, COUNT(*) as Number_of_High_Level_Threats FROM High_Level_Threats GROUP BY Reporting_Agency, Month) GROUP BY Reporting_Agency;", "generated_sql": "SELECT Reporting_Agency, MAX(Count) AS Max_High_Level_Threats\nFROM (\n    SELECT Reporting_Agency, COUNT(*) AS Count\n    FROM Threat_Intelligence\n    WHERE Threat_Level = 'High'\n    GROUP BY Reporting_Agency, YEAR(Reported_Date), MONTH(Reported_Date)\n) AS Monthly_Threat_Counts\nGROUP BY Reporting_Agency;", "raw_model_output": "```sql\nSELECT Reporting_Agency, MAX(Count) AS Max_High_Level_Threats\nFROM (\n    SELECT Reporting_Agency, COUNT(*) AS Count\n    FROM Threat_Intelligence\n    WHERE Threat_Level = 'High'\n    GROUP BY Reporting_Agency, YEAR(Reported_Date), MONTH(Reported_Date)\n) AS Monthly_Threat_Counts\nGROUP BY Reporting_Agency;\n```", "latency_sec": 2.209986925125122, "total_duration_sec": 1.939587196, "load_duration_sec": 0.017207915, "tokens_prompt": 160, "prompt_eval_sec": 0.032137235, "tokens_completion": 85, "completion_eval_sec": 1.887576715, "tokens_total": 245, "tokens_per_sec": 110.8603843826492, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references 'Reporting_Agency' from the High_Level_Threats view, which does not include this column in its definition (the view only selects Threat_Type, Threat_Level, and Reported_Date). This makes the Reference SQL invalid. The Generated SQL correctly accesses 'Reporting_Agency' from the original Threat_Intelligence table. Additionally, while both queries aim to calculate monthly counts of high-level threats, the Reference SQL's structure is fundamentally flawed due to the missing column in the view.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are structurally equivalent in logic and would produce the same results. They both count high-level threats per agency-month, then find the maximum count per agency. However, the Generated SQL is more efficient and elegant: it avoids the High_Level_Threats view (reducing complexity), uses standard date functions (YEAR/MONTH vs. TO_CHAR), and has simpler syntax. The Reference SQL's TO_CHAR function may not be portable across all SQL dialects. Both fulfill the business intent of finding the maximum monthly high-level threats per agency, but the Generated SQL is technically superior.", "overall_assessment": "correct"}}
{"example_id": 5608, "sql_complexity": "set operations", "prompt": "List the suppliers that provide materials for both product A and product C.", "context": "CREATE TABLE products (product_id INT, product_name TEXT); CREATE TABLE materials (material_id INT, material_name TEXT, product_id INT, supplier_id INT); INSERT INTO products (product_id, product_name) VALUES (1, 'Product A'), (2, 'Product B'), (3, 'Product C'); INSERT INTO materials (material_id, material_name, product_id, supplier_id) VALUES (1, 'Material 1', 1, 101), (2, 'Material 2', 1, 102), (3, 'Material 3', 2, 103), (4, 'Material 4', 3, 101), (5, 'Material 5', 3, 102);", "reference_sql": "SELECT supplier_id FROM materials WHERE product_id = 1 INTERSECT SELECT supplier_id FROM materials WHERE product_id = 3;", "generated_sql": "SELECT supplier_id\nFROM materials\nWHERE product_id = 1\nINTERSECT\nSELECT supplier_id\nFROM materials\nWHERE product_id = 3;", "raw_model_output": "```sql\nSELECT supplier_id\nFROM materials\nWHERE product_id = 1\nINTERSECT\nSELECT supplier_id\nFROM materials\nWHERE product_id = 3;\n```", "latency_sec": 1.005115032196045, "total_duration_sec": 0.926009839, "load_duration_sec": 0.022005296, "tokens_prompt": 251, "prompt_eval_sec": 0.050992775, "tokens_completion": 37, "completion_eval_sec": 0.849905503, "tokens_total": 288, "tokens_per_sec": 286.53436748504066, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select supplier_id from materials where product_id is 1 and intersect with supplier_id from materials where product_id is 3. The formatting differences (line breaks, spacing) do not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure and logic. They use INTERSECT to find supplier_ids present in materials for product_id=1 (Product A) and product_id=3 (Product C). The queries correctly implement the business requirement by identifying suppliers that provide materials for both products. The syntax is valid, the logic is sound, and the result set will contain exactly the suppliers meeting the criteria. Neither query is more efficient or elegant than the other as they are identical.", "overall_assessment": "correct"}}
{"example_id": 1506, "sql_complexity": "basic SQL", "prompt": "How many habitats are in the 'animal_habitats' table?", "context": "CREATE TABLE animal_habitats (id INT PRIMARY KEY, habitat_name VARCHAR, num_animals INT);", "reference_sql": "SELECT COUNT(*) FROM animal_habitats;", "generated_sql": "SELECT COUNT(*) AS number_of_habitats FROM animal_habitats;", "raw_model_output": "```sql\nSELECT COUNT(*) AS number_of_habitats FROM animal_habitats;\n```", "latency_sec": 0.8775379657745361, "total_duration_sec": 0.47499592, "load_duration_sec": 0.014515798, "tokens_prompt": 111, "prompt_eval_sec": 0.022407046, "tokens_completion": 20, "completion_eval_sec": 0.435399941, "tokens_total": 131, "tokens_per_sec": 149.28129050733006, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries count the number of rows in the animal_habitats table. The generated query adds an alias (number_of_habitats) to the COUNT(*) result, but this does not change the actual value returned. The semantic result (a single numeric count) remains identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count all rows in the 'animal_habitats' table. The reference query uses the minimal syntax (COUNT(*)) while the generated query adds an explicit alias (number_of_habitats). The alias improves readability by clearly labeling the result column, which is particularly useful in reports or when integrating with applications that expect named columns. Both are logically equivalent and technically correct, but the generated query better fulfills the business intent by providing a more descriptive output.", "overall_assessment": "correct"}}
{"example_id": 3117, "sql_complexity": "aggregation", "prompt": "What is the percentage of the population that has access to clean water in each continent?", "context": "CREATE TABLE water_data (id INT, country VARCHAR(50), continent CHAR(2), access_to_clean_water BOOLEAN); INSERT INTO water_data VALUES (1, 'Canada', 'NA', true), (2, 'Mexico', 'NA', false), (3, 'Brazil', 'SA', true), (4, 'Russia', 'EU', true);", "reference_sql": "SELECT continent, COUNT(*) FILTER (WHERE access_to_clean_water) * 100.0 / COUNT(*) AS percentage FROM water_data GROUP BY continent;", "generated_sql": "SELECT \n    continent,\n    ROUND((SUM(CASE WHEN access_to_clean_water = true THEN 1 ELSE 0 END) * 100.0 / COUNT(*)), 2) AS percentage_with_access\nFROM \n    water_data\nGROUP BY \n    continent;", "raw_model_output": "```sql\nSELECT \n    continent,\n    ROUND((SUM(CASE WHEN access_to_clean_water = true THEN 1 ELSE 0 END) * 100.0 / COUNT(*)), 2) AS percentage_with_access\nFROM \n    water_data\nGROUP BY \n    continent;\n```", "latency_sec": 1.4791629314422607, "total_duration_sec": 1.441948819, "load_duration_sec": 0.021227773, "tokens_prompt": 167, "prompt_eval_sec": 0.036372313, "tokens_completion": 62, "completion_eval_sec": 1.379887448, "tokens_total": 229, "tokens_per_sec": 154.81729235650403, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their handling of decimal precision. The Reference SQL calculates an exact percentage without rounding, while the Generated SQL uses ROUND() to limit results to two decimal places. This would produce different numerical outputs in cases where the percentage has more than two decimal digits.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent due to differences in calculation precision and syntax. The reference query uses PostgreSQL's COUNT(*) FILTER syntax which directly counts true values, while the generated query uses SUM(CASE WHEN ... THEN 1 ELSE 0 END) which achieves the same result but with more verbose syntax. The key difference is the generated query applies ROUND(..., 2) which would round results to two decimal places, potentially altering precision. Both correctly calculate percentages by continent, but the reference query's approach is more concise and avoids rounding. The reference better preserves exact values while fulfilling the business intent of calculating population access percentages per continent.", "overall_assessment": "differently_correct"}}
{"example_id": 3542, "sql_complexity": "window functions", "prompt": "What is the average yield of crops for each country, ranked by average yield?", "context": "CREATE TABLE farming (id INT, name TEXT, country TEXT, crop TEXT, yield INT); INSERT INTO farming VALUES (1, 'Smith Farm', 'USA', 'Corn', 120), (2, 'Brown Farm', 'Canada', 'Soybeans', 45), (3, 'Jones Farm', 'Mexico', 'Wheat', 80);", "reference_sql": "SELECT country, AVG(yield) as avg_yield, ROW_NUMBER() OVER (ORDER BY AVG(yield) DESC) as rank FROM farming GROUP BY country;", "generated_sql": "SELECT country, AVG(yield) AS average_yield\nFROM farming\nGROUP BY country\nORDER BY average_yield DESC;", "raw_model_output": "```sql\nSELECT country, AVG(yield) AS average_yield\nFROM farming\nGROUP BY country\nORDER BY average_yield DESC;\n```", "latency_sec": 0.9931848049163818, "total_duration_sec": 0.700581413, "load_duration_sec": 0.015914538, "tokens_prompt": 170, "prompt_eval_sec": 0.033361541, "tokens_completion": 29, "completion_eval_sec": 0.648174945, "tokens_total": 199, "tokens_per_sec": 200.36553017618328, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a ROW_NUMBER() column that ranks countries by average yield, while the Generated SQL only returns country and average_yield without the rank. The Generated SQL also lacks the explicit ORDER BY in the final output (though it implicitly orders via the ROW_NUMBER() in the Reference SQL). The result sets differ in structure and content.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL includes a rank column using ROW_NUMBER() which directly addresses the 'ranked by average yield' requirement, while the Generated SQL only orders results without explicitly showing ranks. Both are technically correct, but the Reference better fulfills the business intent by providing explicit rankings. The Generated SQL meets the average yield calculation but fails to include the requested ranking metric. The Reference query is more elegant in addressing all aspects of the question.", "overall_assessment": "differently_correct"}}
{"example_id": 2274, "sql_complexity": "subqueries", "prompt": "Add a new crop 'amaranth' to farm 'Nourishing Harvest' with yield 50 in 2023", "context": "CREATE TABLE farms (id INT, name TEXT, location TEXT, size FLOAT); INSERT INTO farms (id, name, location, size) VALUES (1, 'Nourishing Harvest', 'Mexico', 120.0); CREATE TABLE crops (id INT, farm_id INT, crop TEXT, yield INT, year INT);", "reference_sql": "INSERT INTO crops (id, farm_id, crop, yield, year) VALUES (5, (SELECT id FROM farms WHERE name = 'Nourishing Harvest'), 'amaranth', 50, 2023);", "generated_sql": "INSERT INTO crops (farm_id, crop, yield, year)\nSELECT id, 'amaranth', 50, 2023\nFROM farms\nWHERE name = 'Nourishing Harvest';", "raw_model_output": "```sql\nINSERT INTO crops (farm_id, crop, yield, year)\nSELECT id, 'amaranth', 50, 2023\nFROM farms\nWHERE name = 'Nourishing Harvest';\n```", "latency_sec": 1.4156990051269531, "total_duration_sec": 1.112530313, "load_duration_sec": 0.02540346, "tokens_prompt": 172, "prompt_eval_sec": 0.037558307, "tokens_completion": 47, "completion_eval_sec": 1.045112016, "tokens_total": 219, "tokens_per_sec": 154.6938997674588, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL explicitly specifies an id (5) for the inserted row, while the Generated SQL omits the id column and relies on the database's default behavior (e.g., auto-increment). Additionally, the Generated SQL would insert one row per matching farm (though the farm name is unique in the sample data), but the key difference lies in the explicit id value vs. implicit handling.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly add 'amaranth' to 'Nourishing Harvest' with yield 50 in 2023. The reference query explicitly specifies an id (5) which is unnecessary since the original question doesn't mention it, while the generated query omits id (assuming it's auto-incremented). The generated query uses a more elegant SELECT-based approach that avoids hardcoded values and directly leverages the farm name to find farm_id. Both handle the core business requirement, but the generated version is more maintainable and less error-prone.", "overall_assessment": "correct"}}
{"example_id": 3705, "sql_complexity": "subqueries", "prompt": "What is the percentage of unions with collective bargaining agreements in the Midwest region?", "context": "CREATE TABLE collective_bargaining (bargaining_id INT, union_name VARCHAR(50), contract_start_date DATE, contract_end_date DATE, region VARCHAR(50));CREATE VIEW union_region AS SELECT DISTINCT union_name, region FROM collective_bargaining;", "reference_sql": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM union_region) as percentage FROM union_region ur WHERE ur.region = 'Midwest' AND EXISTS (SELECT 1 FROM collective_bargaining cb WHERE cb.union_name = ur.union_name);", "generated_sql": "SELECT \n    (COUNT(CASE WHEN region = 'Midwest' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_midwest_unions\nFROM \n    union_region;", "raw_model_output": "```sql\nSELECT \n    (COUNT(CASE WHEN region = 'Midwest' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_midwest_unions\nFROM \n    union_region;\n```", "latency_sec": 1.297820806503296, "total_duration_sec": 1.106724586, "load_duration_sec": 0.014149424, "tokens_prompt": 144, "prompt_eval_sec": 0.027522267, "tokens_completion": 48, "completion_eval_sec": 1.062311211, "tokens_total": 192, "tokens_per_sec": 147.94030041582047, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes an EXISTS clause that filters union_region entries with corresponding records in collective_bargaining, while the Generated SQL simply calculates the percentage of 'Midwest' regions in union_region without this filter. The Generated SQL lacks the condition checking for existence in collective_bargaining, leading to different results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries calculate the percentage of unions with collective bargaining agreements in the Midwest region. The Reference SQL uses a correlated subquery with EXISTS (redundant since union_region already contains only unions with agreements) and counts Midwest unions. The Generated SQL uses a CASE statement to count Midwest unions directly and divides by total unions. While both produce identical results, the Generated SQL is more efficient and elegant by avoiding redundant checks and using a single table scan. Both fulfill the business intent, but the Generated SQL is technically superior.", "overall_assessment": "correct"}}
{"example_id": 240, "sql_complexity": "aggregation", "prompt": "What is the average capacity of renewable energy projects for each country?", "context": "CREATE TABLE projects (name TEXT, type TEXT, capacity INTEGER, country TEXT); INSERT INTO projects (name, type, capacity, country) VALUES ('Project 1', 'Wind', 100, 'USA'), ('Project 2', 'Solar', 200, 'Germany'), ('Project 3', 'Wind', 300, 'France');", "reference_sql": "SELECT country, AVG(capacity) FROM projects GROUP BY country", "generated_sql": "SELECT country, AVG(capacity) AS average_capacity\nFROM projects\nWHERE type IN ('Wind', 'Solar')\nGROUP BY country;", "raw_model_output": "```sql\nSELECT country, AVG(capacity) AS average_capacity\nFROM projects\nWHERE type IN ('Wind', 'Solar')\nGROUP BY country;\n```", "latency_sec": 1.0696990489959717, "total_duration_sec": 0.771212598, "load_duration_sec": 0.014609836, "tokens_prompt": 166, "prompt_eval_sec": 0.033007541, "tokens_completion": 32, "completion_eval_sec": 0.720981718, "tokens_total": 198, "tokens_per_sec": 185.09879034280195, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average capacity per country. The generated query includes a WHERE clause filtering for 'Wind' and 'Solar' types, but all rows in the provided data already meet this condition. Thus, the result sets are identical for the given data.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query is technically correct and fully aligns with the business intent. The original question asks for 'renewable energy projects,' but the database schema doesn't explicitly define which project types are renewable. The reference query analyzes all projects regardless of type, ensuring no potential renewable projects are excluded. The generated query adds a WHERE clause filtering only Wind and Solar projects, which may not represent all renewable energy types (e.g., Hydro, Geothermal). While the generated query is syntactically correct, it makes an implicit assumption about renewable types not stated in the original question. Both queries calculate the same metric (average capacity), but the reference query is more inclusive and avoids unwarranted assumptions. The generated query could be incorrect if other renewable types exist in the dataset.", "overall_assessment": "correct"}}
{"example_id": 2132, "sql_complexity": "set operations", "prompt": "What is the average caseload per attorney in community legal clinics in California, and how does it compare to the state average?", "context": "CREATE TABLE cali_community_legal_clinics(id INT, attorney_count INT, cases_handled INT, state VARCHAR(255));", "reference_sql": "SELECT state, AVG(cases_handled/attorney_count) AS avg_caseload FROM cali_community_legal_clinics WHERE state = 'California' GROUP BY state UNION ALL SELECT 'California', AVG(cases_handled/attorney_count) FROM cali_community_legal_clinics WHERE state = 'California';", "generated_sql": "SELECT \n    AVG(cases_handled / attorney_count) AS avg_caseload_per_attorney,\n    (SELECT AVG(cases_handled / attorney_count) FROM cali_community_legal_clinics) AS state_avg_caseload_per_attorney\nFROM \n    cali_community_legal_clinics;", "raw_model_output": "```sql\nSELECT \n    AVG(cases_handled / attorney_count) AS avg_caseload_per_attorney,\n    (SELECT AVG(cases_handled / attorney_count) FROM cali_community_legal_clinics) AS state_avg_caseload_per_attorney\nFROM \n    cali_community_legal_clinics;\n```", "latency_sec": 1.6862578392028809, "total_duration_sec": 1.607724041, "load_duration_sec": 0.019054441, "tokens_prompt": 129, "prompt_eval_sec": 0.04780679, "tokens_completion": 68, "completion_eval_sec": 1.538504586, "tokens_total": 197, "tokens_per_sec": 116.82673635078537, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the average caseload for California twice (once with grouping and once as a subquery) and returns two rows. The Generated SQL calculates the overall average for the entire table (not filtered by state) and returns a single row with two columns. The filtering, output structure, and scope of data differ significantly between the queries.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL attempts to calculate the California caseload average and includes a redundant second row with the same value, but it fails to properly compute the 'state average' (which should be the overall average across all clinics in California, not just a repeated value). The Generated SQL incorrectly calculates the overall average for all clinics (not filtered by California) and lacks a comparison to the California-specific average. While both queries have flaws, the Reference SQL at least addresses the California caseload calculation, whereas the Generated SQL completely misses the filtering requirement. The Reference SQL's structure is more aligned with the intent of comparing two values, even if its implementation is flawed.", "overall_assessment": "differently_correct"}}
{"example_id": 3276, "sql_complexity": "basic SQL", "prompt": "What is the total energy consumption of the Chemical Plant B in the last quarter?", "context": "CREATE TABLE EnergyConsumption (EnergyID INT, Plant VARCHAR(255), EnergyQuantity DECIMAL(5,2), Timestamp DATETIME);", "reference_sql": "SELECT SUM(EnergyQuantity) FROM EnergyConsumption WHERE Plant = 'Chemical Plant B' AND Timestamp BETWEEN DATE_SUB(CURRENT_DATE(), INTERVAL 3 MONTH) AND CURRENT_DATE();", "generated_sql": "SELECT SUM(EnergyQuantity) AS TotalEnergyConsumption\nFROM EnergyConsumption\nWHERE Plant = 'Chemical Plant B'\n  AND Timestamp >= DATEADD(QUARTER, DATEDIFF(QUARTER, 0, GETDATE()) - 1, 0)\n  AND Timestamp < DATEADD(QUARTER, DATEDIFF(QUARTER, 0, GETDATE()), 0);", "raw_model_output": "```sql\nSELECT SUM(EnergyQuantity) AS TotalEnergyConsumption\nFROM EnergyConsumption\nWHERE Plant = 'Chemical Plant B'\n  AND Timestamp >= DATEADD(QUARTER, DATEDIFF(QUARTER, 0, GETDATE()) - 1, 0)\n  AND Timestamp < DATEADD(QUARTER, DATEDIFF(QUARTER, 0, GETDATE()), 0);\n```", "latency_sec": 2.2677948474884033, "total_duration_sec": 2.075920933, "load_duration_sec": 0.014175806, "tokens_prompt": 122, "prompt_eval_sec": 0.024339566, "tokens_completion": 91, "completion_eval_sec": 2.035127708, "tokens_total": 213, "tokens_per_sec": 93.92383981994615, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query calculates the sum for the last 3 months using DATE_SUB and CURRENT_DATE(), while the generated query uses quarter-based date calculations (DATEADD/DATEDIFF) which may not align with a 3-month period. The generated query captures the entire previous quarter (e.g., Jan 1 - Apr 1) whereas the reference query captures the exact 3-month window (e.g., Jan 5 - Apr 5). Additionally, the generated query uses GETDATE() (with time) while the reference uses CURRENT_DATE() (date-only), leading to potential discrepancies in datetime comparisons.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in date calculation logic. The Reference SQL uses a 3-month window (DATE_SUB/CURRENT_DATE), which may not align with calendar quarters (e.g., if today is January 10th, it would include October-December instead of the full Q4). The Generated SQL correctly identifies the previous calendar quarter using DATEADD and DATEDIFF, ensuring precise quarterly boundaries. Both sum the correct plant's energy, but the Generated query better fulfills the business intent of 'last quarter' as a calendar period. The Generated query also avoids potential edge cases with date boundaries.", "overall_assessment": "differently_correct"}}
{"example_id": 3074, "sql_complexity": "multiple_joins", "prompt": "Find the top 5 players with the highest scores in the 'historical_tournaments' view, including their scores and the names of the tournaments they participated in.", "context": "CREATE VIEW historical_tournaments AS SELECT tournaments.tournament_name, players.player_name, players.score FROM tournaments JOIN players_scores ON tournaments.tournament_id = players_scores.tournament_id JOIN players ON players_scores.player_id = players.player_id;  CREATE TABLE tournaments (tournament_id INT, tournament_name TEXT);  CREATE TABLE players_scores (player_id INT, tournament_id INT, score INT);  CREATE TABLE players (player_id INT, player_name TEXT);", "reference_sql": "SELECT players.player_name, MAX(players_scores.score) as high_score, tournaments.tournament_name FROM historical_tournaments JOIN players ON historical_tournaments.player_id = players.player_id JOIN players_scores ON historical_tournaments.player_id = players_scores.player_id JOIN tournaments ON players_scores.tournament_id = tournaments.tournament_id GROUP BY players.player_id, tournaments.tournament_name ORDER BY high_score DESC LIMIT 5;", "generated_sql": "SELECT ht.player_name, ht.score, ht.tournament_name\nFROM historical_tournaments ht\nORDER BY ht.score DESC\nLIMIT 5;", "raw_model_output": "```sql\nSELECT ht.player_name, ht.score, ht.tournament_name\nFROM historical_tournaments ht\nORDER BY ht.score DESC\nLIMIT 5;\n```", "latency_sec": 0.8776838779449463, "total_duration_sec": 0.846615763, "load_duration_sec": 0.014175765, "tokens_prompt": 198, "prompt_eval_sec": 0.044539526, "tokens_completion": 34, "completion_eval_sec": 0.785524947, "tokens_total": 232, "tokens_per_sec": 264.33207425800805, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL groups by player_id and tournament_name, aggregates scores with MAX, and includes redundant joins, while the Generated SQL directly selects from the view without aggregation or joins. The Reference SQL's GROUP BY and MAX could produce different results if multiple scores exist per player-tournament pair, but the Generated SQL returns raw data without aggregation. Additionally, the Reference SQL's joins are unnecessary and could alter the result set.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is incorrect because it redundantly joins the view with base tables and groups by both player_id and tournament_name, which would return per-tournament scores rather than aggregating players' highest scores. The Generated SQL is simpler and directly queries the view, ordering by score and limiting results. While neither query fully addresses the business intent (which requires aggregating players' maximum scores across tournaments), the Generated SQL is more efficient and closer to the intended outcome by avoiding unnecessary joins and focusing on the view's structure. However, both fail to properly aggregate player scores to identify the top 5 players overall.", "overall_assessment": "incorrect"}}
{"example_id": 2219, "sql_complexity": "window functions", "prompt": "What is the average population of cities with a UNESCO World Heritage designation, ordered by designation date?", "context": "CREATE TABLE cities (name VARCHAR(255), population INT, designation_date DATE); INSERT INTO cities (name, population, designation_date) VALUES ('Paris', 2141000, '1991-09-16'); INSERT INTO cities (name, population, designation_date) VALUES ('Rio de Janeiro', 6727000, '2012-07-01');", "reference_sql": "SELECT AVG(population) FROM (SELECT population, ROW_NUMBER() OVER (ORDER BY designation_date) rn FROM cities WHERE name IN (SELECT name FROM heritagesites)) t WHERE rn % 2 = 1;", "generated_sql": "SELECT AVG(population) AS average_population\nFROM cities\nWHERE name IN ('Paris', 'Rio de Janeiro')\nORDER BY designation_date;", "raw_model_output": "```sql\nSELECT AVG(population) AS average_population\nFROM cities\nWHERE name IN ('Paris', 'Rio de Janeiro')\nORDER BY designation_date;\n```", "latency_sec": 0.8758571147918701, "total_duration_sec": 0.790548833, "load_duration_sec": 0.015915425, "tokens_prompt": 187, "prompt_eval_sec": 0.036952991, "tokens_completion": 33, "completion_eval_sec": 0.734986499, "tokens_total": 220, "tokens_per_sec": 251.18252313595534, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the average of populations from cities in heritagesites, selecting only odd-numbered rows ordered by designation_date. The Generated SQL averages all populations of specified cities without row-number filtering. Even if heritagesites contains the same cities, the Reference SQL's row-numbering logic (rn % 2 = 1) would select only every other row, while the Generated SQL averages all rows. The presence of ORDER BY in the Generated SQL doesn't affect the average calculation, making the queries semantically different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query is technically invalid due to referencing a non-existent 'heritagesites' table. The generated query is syntactically correct but fails to properly filter cities with UNESCO designations (it hardcodes names instead of using a proper filter). Both queries miss the core business intent of identifying designated cities. However, the generated query at least avoids invalid table references and includes the required ORDER BY clause, making it slightly more aligned with the question's structure.", "overall_assessment": "differently_correct"}}
{"example_id": 3786, "sql_complexity": "aggregation", "prompt": "Display the names and average co-owner percentages for all properties in the 'property_coownership' table where the co-owner percentage is greater than 60.", "context": "CREATE TABLE property_coownership (property_id INT, owner VARCHAR(255), percentage INT); INSERT INTO property_coownership (property_id, owner, percentage) VALUES (1, 'Mohammed', 70), (1, 'Fatima', 30), (2, 'Jamal', 65), (2, 'Aisha', 35), (3, 'Ali', 75), (3, 'Khadija', 25);", "reference_sql": "SELECT owner, AVG(percentage) FROM property_coownership WHERE percentage > 60 GROUP BY owner;", "generated_sql": "SELECT owner, AVG(percentage) AS average_percentage\nFROM property_coownership\nWHERE percentage > 60\nGROUP BY owner;", "raw_model_output": "```sql\nSELECT owner, AVG(percentage) AS average_percentage\nFROM property_coownership\nWHERE percentage > 60\nGROUP BY owner;\n```", "latency_sec": 1.005317211151123, "total_duration_sec": 0.783764881, "load_duration_sec": 0.015502433, "tokens_prompt": 207, "prompt_eval_sec": 0.045073861, "tokens_completion": 32, "completion_eval_sec": 0.721026093, "tokens_total": 239, "tokens_per_sec": 237.73590797907133, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. The only difference is that the generated query adds an explicit alias 'average_percentage' for the AVG(percentage) column, but the selected columns, filtering condition, and grouping logic remain identical. The result set structure and data values will be the same.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": false, "superiority": "equal", "explanation": "The queries are technically equivalent as they differ only in column aliasing (AVG(percentage) vs. AVG(percentage) AS average_percentage). However, they do not fulfill the business intent. The original question asks for properties where co-owner percentages exceed 60, but the queries group by 'owner' instead of 'property_id'. This grouping leads to per-owner averages rather than per-property analysis. For example, property 1 (Mohammed 70%, Fatima 30%) would be excluded from property-level analysis, but the queries would include Mohammed's 70% as a separate entry. The correct approach would require grouping by property_id and filtering properties with at least one co-owner >60%.", "overall_assessment": "differently_correct"}}
{"example_id": 2357, "sql_complexity": "basic SQL", "prompt": "What is the total amount of climate finance invested in renewable energy projects by public and private sectors in Africa?", "context": "CREATE TABLE renewable_energy_projects (project_id INT, sector TEXT, investor_type TEXT, region TEXT, amount FLOAT); INSERT INTO renewable_energy_projects (project_id, sector, investor_type, region, amount) VALUES (1, 'Renewable Energy', 'Public', 'Africa', 5000000); INSERT INTO renewable_energy_projects (project_id, sector, investor_type, region, amount) VALUES (2, 'Renewable Energy', 'Private', 'Africa', 7000000);", "reference_sql": "SELECT SUM(amount) FROM renewable_energy_projects WHERE sector = 'Renewable Energy' AND region = 'Africa';", "generated_sql": "SELECT SUM(amount) AS total_investment\nFROM renewable_energy_projects\nWHERE region = 'Africa' AND sector = 'Renewable Energy';", "raw_model_output": "```sql\nSELECT SUM(amount) AS total_investment\nFROM renewable_energy_projects\nWHERE region = 'Africa' AND sector = 'Renewable Energy';\n```", "latency_sec": 1.031569004058838, "total_duration_sec": 0.83384447, "load_duration_sec": 0.02399146, "tokens_prompt": 206, "prompt_eval_sec": 0.043558298, "tokens_completion": 34, "completion_eval_sec": 0.76404012, "tokens_total": 240, "tokens_per_sec": 232.65530377094487, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of 'amount' for projects in the 'Renewable Energy' sector located in 'Africa'. The order of conditions in the WHERE clause does not affect the result, and the column alias ('total_investment') in the generated query does not change the semantic meaning of the output data.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": false, "superiority": "equal", "explanation": "The queries are technically equivalent as they both calculate the sum of amounts for 'Renewable Energy' projects in Africa. However, they fail to fulfill the business intent because they do not explicitly filter for both 'Public' and 'Private' investor types as required by the question. The original question specifies 'public and private sectors,' which likely refers to investor_type, but neither query includes this condition. While the sample data contains only Public/Private entries, the schema allows for other investor_type values, making the current queries incomplete.", "overall_assessment": "differently_correct"}}
{"example_id": 1009, "sql_complexity": "multiple_joins", "prompt": "Find the number of IoT sensors installed in each farm that use Sprinkler irrigation.", "context": "CREATE TABLE IoT_Sensors (id INT, sensor_type VARCHAR(50), Farm_id INT); INSERT INTO IoT_Sensors (id, sensor_type, Farm_id) VALUES (1, 'Soil Moisture', 1), (2, 'Temperature', 1), (3, 'Humidity', 2); CREATE TABLE Irrigation (id INT, Farm_id INT, irrigation_type VARCHAR(50), duration INT); INSERT INTO Irrigation (id, Farm_id, irrigation_type, duration) VALUES (1, 1, 'Sprinkler', 30), (2, 2, 'Drip', 45);", "reference_sql": "SELECT f.id, COUNT(s.id) FROM Farmers f JOIN Irrigation i ON f.id = i.Farm_id JOIN IoT_Sensors s ON f.id = s.Farm_id WHERE i.irrigation_type = 'Sprinkler' GROUP BY f.id;", "generated_sql": "SELECT \n    Farm_id, \n    COUNT(*) AS num_sensors\nFROM \n    IoT_Sensors\nWHERE \n    Farm_id IN (\n        SELECT \n            Farm_id\n        FROM \n            Irrigation\n        WHERE \n            irrigation_type = 'Sprinkler'\n    )\nGROUP BY \n    Farm_id;", "raw_model_output": "```sql\nSELECT \n    Farm_id, \n    COUNT(*) AS num_sensors\nFROM \n    IoT_Sensors\nWHERE \n    Farm_id IN (\n        SELECT \n            Farm_id\n        FROM \n            Irrigation\n        WHERE \n            irrigation_type = 'Sprinkler'\n    )\nGROUP BY \n    Farm_id;\n```", "latency_sec": 1.805037021636963, "total_duration_sec": 1.605326165, "load_duration_sec": 0.016000672, "tokens_prompt": 226, "prompt_eval_sec": 0.045256904, "tokens_completion": 69, "completion_eval_sec": 1.541412705, "tokens_total": 295, "tokens_per_sec": 163.4315509675633, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL may overcount IoT sensors if a farm has multiple Sprinkler irrigation entries. The Generated SQL correctly counts sensors per farm using a subquery that ensures each Farm_id is considered once, while the Reference SQL joins with Irrigation, potentially multiplying sensor counts by the number of matching irrigation entries.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query incorrectly references a 'Farmers' table that doesn't exist in the provided schema, while the generated query properly uses only the IoT_Sensors and Irrigation tables. Both queries correctly identify farms with Sprinkler irrigation and count their sensors, but the generated query avoids unnecessary joins and is more efficient. The reference query would fail due to a missing table, making the generated query the superior solution.", "overall_assessment": "differently_correct"}}
{"example_id": 4217, "sql_complexity": "subqueries", "prompt": "Show consumer preference data for foundations, excluding products from the USA.", "context": "CREATE TABLE cosmetics (product_id INT, product_name VARCHAR(100), product_type VARCHAR(50), is_cruelty_free BOOLEAN, consumer_preference_score INT); INSERT INTO cosmetics (product_id, product_name, product_type, is_cruelty_free, consumer_preference_score) VALUES (1, 'Lipstick A', 'Lipstick', TRUE, 80), (2, 'Foundation B', 'Foundation', FALSE, 90), (3, 'Mascara C', 'Mascara', TRUE, 85), (4, 'Eyeshadow D', 'Eyeshadow', TRUE, 70), (5, 'Blush E', 'Blush', FALSE, 95); CREATE TABLE ingredient_sourcing (ingredient_id INT, ingredient_name VARCHAR(100), sourcing_country VARCHAR(50), is_organic BOOLEAN); INSERT INTO ingredient_sourcing (ingredient_id, ingredient_name, sourcing_country, is_organic) VALUES (1, 'Rosehip Oil', 'Chile', TRUE), (2, 'Shea Butter', 'Ghana', TRUE), (3, 'Jojoba Oil', 'India', TRUE), (4, 'Coconut Oil', 'Philippines', FALSE), (5, 'Aloe Vera', 'USA', TRUE);", "reference_sql": "SELECT * FROM cosmetics WHERE product_type = 'Foundation' AND product_id NOT IN (SELECT cosmetics.product_id FROM cosmetics INNER JOIN ingredient_sourcing ON cosmetics.product_id = ingredient_sourcing.ingredient_id WHERE ingredient_sourcing.sourcing_country = 'USA');", "generated_sql": "SELECT product_name, consumer_preference_score\nFROM cosmetics\nWHERE product_type = 'Foundation' AND is_cruelty_free = FALSE;", "raw_model_output": "```sql\nSELECT product_name, consumer_preference_score\nFROM cosmetics\nWHERE product_type = 'Foundation' AND is_cruelty_free = FALSE;\n```", "latency_sec": 1.0178842544555664, "total_duration_sec": 0.90456256, "load_duration_sec": 0.019525659, "tokens_prompt": 363, "prompt_eval_sec": 0.08616365, "tokens_completion": 33, "completion_eval_sec": 0.795131066, "tokens_total": 396, "tokens_per_sec": 389.0422690660518, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL filters 'Foundation' products excluding those linked to ingredients sourced from the USA via a subquery, while the Generated SQL filters 'Foundation' products that are not cruelty-free. They differ in both filtering conditions (sourcing_country vs. is_cruelty_free) and selected columns (all columns vs. specific columns).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL attempts to exclude foundations with ingredients sourced from the USA by joining cosmetics with ingredient_sourcing on product_id = ingredient_id, but this join condition is logically flawed (product_id and ingredient_id are unrelated in the schema). The Generated SQL incorrectly filters on 'is_cruelty_free = FALSE' instead of addressing the USA exclusion. Neither query is technically correct, but the Reference SQL aligns with the business intent of excluding USA-sourced products (despite flawed implementation), while the Generated SQL completely misses the requirement. The Reference query's structure is more aligned with the question's goal, even if it contains a critical logical error.", "overall_assessment": "incorrect"}}
{"example_id": 5620, "sql_complexity": "basic SQL", "prompt": "What is the recycling rate of plastic in the residential sector in the state of New York?", "context": "CREATE TABLE recycling_rates_city (sector VARCHAR(20), city VARCHAR(20), material VARCHAR(20), recycling_rate DECIMAL(5,2)); INSERT INTO recycling_rates_city (sector, city, material, recycling_rate) VALUES ('residential', 'New York City', 'plastic', 0.25), ('commercial', 'New York City', 'plastic', 0.30), ('residential', 'New York City', 'paper', 0.45), ('commercial', 'New York City', 'paper', 0.50), ('residential', 'Los Angeles', 'plastic', 0.20), ('commercial', 'Los Angeles', 'plastic', 0.35), ('residential', 'Los Angeles', 'paper', 0.40), ('commercial', 'Los Angeles', 'paper', 0.50);", "reference_sql": "SELECT recycling_rate FROM recycling_rates_city WHERE sector = 'residential' AND material = 'plastic' AND city = 'New York City';", "generated_sql": "SELECT recycling_rate \nFROM recycling_rates_city \nWHERE sector = 'residential' AND city = 'New York City' AND material = 'plastic';", "raw_model_output": "```sql\nSELECT recycling_rate \nFROM recycling_rates_city \nWHERE sector = 'residential' AND city = 'New York City' AND material = 'plastic';\n```", "latency_sec": 0.9308149814605713, "total_duration_sec": 0.905561293, "load_duration_sec": 0.015568255, "tokens_prompt": 283, "prompt_eval_sec": 0.058774934, "tokens_completion": 36, "completion_eval_sec": 0.82840591, "tokens_total": 319, "tokens_per_sec": 342.7104272639091, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select the same column and apply identical WHERE conditions (sector = 'residential', city = 'New York City', material = 'plastic'). The order of conditions in the WHERE clause does not affect the result set in SQL.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are structurally identical in terms of syntax, logic, and semantic output. They select the recycling_rate from the same table with the same WHERE conditions (sector = 'residential', city = 'New York City', material = 'plastic'). The order of conditions in the WHERE clause does not affect the result. Both queries directly address the business question by retrieving the specific recycling rate for plastic in the residential sector of New York City. Neither query is more efficient or elegant than the other, as they are functionally identical.", "overall_assessment": "correct"}}
{"example_id": 3151, "sql_complexity": "basic SQL", "prompt": "List all biotech startups that received funding in 2022 and their respective funding amounts.", "context": "CREATE TABLE biotech_startups (name TEXT, funding FLOAT, date DATE); INSERT INTO biotech_startups (name, funding, date) VALUES ('StartupA', 3500000, '2022-02-28'); INSERT INTO biotech_startups (name, funding, date) VALUES ('StartupB', 4500000, '2022-07-12');", "reference_sql": "SELECT name, funding FROM biotech_startups WHERE date BETWEEN '2022-01-01' AND '2022-12-31';", "generated_sql": "SELECT name, funding \nFROM biotech_startups \nWHERE EXTRACT(YEAR FROM date) = 2022;", "raw_model_output": "```sql\nSELECT name, funding \nFROM biotech_startups \nWHERE EXTRACT(YEAR FROM date) = 2022;\n```", "latency_sec": 0.9354321956634521, "total_duration_sec": 0.742426827, "load_duration_sec": 0.015452653, "tokens_prompt": 190, "prompt_eval_sec": 0.035503311, "tokens_completion": 31, "completion_eval_sec": 0.689446926, "tokens_total": 221, "tokens_per_sec": 236.25442979675987, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select records where the date falls in the year 2022. The first uses BETWEEN '2022-01-01' AND '2022-12-31' (inclusive), while the second uses EXTRACT(YEAR FROM date) = 2022. Since the date column is a DATE type, both approaches capture all dates in 2022.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries are technically correct and would produce identical results for the given schema. The reference query uses a date range comparison (BETWEEN '2022-01-01' AND '2022-12-31') which is more explicit and efficient for date filtering. The generated query uses EXTRACT(YEAR FROM date) = 2022 which works but may be less efficient due to potential lack of index utilization on the date column. Both fulfill the business intent of identifying 2022 funding events, but the reference query is more optimized for date-based filtering.", "overall_assessment": "correct"}}
{"example_id": 2136, "sql_complexity": "window functions", "prompt": "What is the total military equipment sales revenue for each sales representative by fiscal year?", "context": "CREATE TABLE SalesReps (SalesRepID INT, SalesRepName VARCHAR(50), FiscalYear INT, Revenue DECIMAL(10,2)); INSERT INTO SalesReps (SalesRepID, SalesRepName, FiscalYear, Revenue) VALUES (1, 'John Doe', 2020, 150000.00), (2, 'Jane Smith', 2020, 200000.00), (1, 'John Doe', 2021, 180000.00), (2, 'Jane Smith', 2021, 250000.00);", "reference_sql": "SELECT SalesRepName, FiscalYear, SUM(Revenue) OVER (PARTITION BY SalesRepName ORDER BY FiscalYear) AS TotalRevenue FROM SalesReps;", "generated_sql": "SELECT SalesRepName, FiscalYear, SUM(Revenue) AS TotalRevenue\nFROM SalesReps\nGROUP BY SalesRepName, FiscalYear;", "raw_model_output": "```sql\nSELECT SalesRepName, FiscalYear, SUM(Revenue) AS TotalRevenue\nFROM SalesReps\nGROUP BY SalesRepName, FiscalYear;\n```", "latency_sec": 0.9696378707885742, "total_duration_sec": 0.871358281, "load_duration_sec": 0.013820409, "tokens_prompt": 240, "prompt_eval_sec": 0.051405612, "tokens_completion": 35, "completion_eval_sec": 0.803249092, "tokens_total": 275, "tokens_per_sec": 283.61103488702605, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses a window function to calculate a running total of Revenue per SalesRepName ordered by FiscalYear, while the Generated SQL aggregates Revenue by exact SalesRepName/FiscalYear pairs. The Reference query shows cumulative sums (e.g., 2020: 150000, 2021: 150000+180000=330000) whereas the Generated query shows per-year totals (e.g., 2020: 150000, 2021: 180000).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL uses a window function to create a running total (cumulative sum) of revenue per sales representative ordered by fiscal year, which does not match the requirement for 'total revenue for each sales representative by fiscal year'. The Generated SQL correctly aggregates revenue using GROUP BY, ensuring each SalesRepName and FiscalYear combination shows the total revenue for that specific year. The Reference SQL would produce incorrect results if there are multiple entries per sales rep per year (e.g., cumulative sums instead of per-year totals). The Generated SQL is both technically correct and semantically aligned with the business question.", "overall_assessment": "differently_correct"}}
{"example_id": 5452, "sql_complexity": "basic SQL", "prompt": "What is the name of the farms with a size greater than 150 acres located in 'Texas'?", "context": "CREATE TABLE farms (id INT PRIMARY KEY, name VARCHAR(50), size INT, location VARCHAR(50)); INSERT INTO farms (id, name, size, location) VALUES (1, 'Smith Farms', 200, 'Texas'), (2, 'Johnson Farms', 100, 'California');", "reference_sql": "SELECT name FROM farms WHERE size > 150 AND location = 'Texas'", "generated_sql": "SELECT name FROM farms WHERE size > 150 AND location = 'Texas';", "raw_model_output": "```sql\nSELECT name FROM farms WHERE size > 150 AND location = 'Texas';\n```", "latency_sec": 0.6262049674987793, "total_duration_sec": 0.547608552, "load_duration_sec": 0.015341885, "tokens_prompt": 166, "prompt_eval_sec": 0.033496876, "tokens_completion": 22, "completion_eval_sec": 0.496314323, "tokens_total": 188, "tokens_per_sec": 300.2211891593889, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. The only difference is the presence of a semicolon at the end of the generated SQL, which is insignificant in SQL syntax as it's merely a statement terminator. Both queries select the 'name' column from the 'farms' table where 'size' is greater than 150 and 'location' is 'Texas', which will return the same result set.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in logic and structure, with the only difference being the presence of a semicolon at the end of the generated SQL. The semicolon is a statement terminator in SQL and does not affect the query's execution or results. Both queries correctly filter farms in Texas with size > 150 acres, producing the same output ('Smith Farms'). The reference and generated queries are functionally equivalent, equally efficient, and fully address the business question.", "overall_assessment": "correct"}}
{"example_id": 5152, "sql_complexity": "aggregation", "prompt": "How many international tourists visited Portugal in 2020, broken down by continent?", "context": "CREATE TABLE international_tourists(tourist_id INT, country TEXT, arrival_year INT, continent TEXT);INSERT INTO international_tourists (tourist_id, country, arrival_year, continent) VALUES (1, 'Spain', 2020, 'Europe'), (2, 'France', 2020, 'Europe'), (3, 'Brazil', 2020, 'South America'), (4, 'United States', 2020, 'North America'), (5, 'China', 2020, 'Asia');", "reference_sql": "SELECT continent, COUNT(*) FROM international_tourists WHERE arrival_year = 2020 GROUP BY continent;", "generated_sql": "SELECT \n    continent, \n    COUNT(*) AS tourist_count\nFROM \n    international_tourists\nWHERE \n    country = 'Portugal' AND arrival_year = 2020\nGROUP BY \n    continent;", "raw_model_output": "```sql\nSELECT \n    continent, \n    COUNT(*) AS tourist_count\nFROM \n    international_tourists\nWHERE \n    country = 'Portugal' AND arrival_year = 2020\nGROUP BY \n    continent;\n```", "latency_sec": 1.5764012336730957, "total_duration_sec": 1.275941132, "load_duration_sec": 0.015265285, "tokens_prompt": 213, "prompt_eval_sec": 0.045397058, "tokens_completion": 51, "completion_eval_sec": 1.212944234, "tokens_total": 264, "tokens_per_sec": 167.470054171974, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL counts all tourists from 2020 grouped by continent, while the Generated SQL adds a WHERE condition filtering for 'Portugal' which doesn't exist in the data. This makes the Generated SQL return no rows, whereas the Reference SQL returns counts for each continent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly counts all international tourists arriving in Portugal in 2020, grouped by their continent of origin. It properly filters by arrival_year = 2020 and groups by continent without restricting to a specific country. The Generated SQL incorrectly filters WHERE country = 'Portugal', which would only count tourists whose *origin* country is Portugal (not visitors to Portugal). The question asks for tourists *visiting* Portugal, but the schema lacks a destination column, implying the table already represents tourists arriving in Portugal. The Generated SQL's filter is semantically incorrect for the business intent.", "overall_assessment": "incorrect"}}
{"example_id": 2477, "sql_complexity": "set operations", "prompt": "What is the carbon price in Europe and Australia for the last quarter of 2020?", "context": "CREATE TABLE CarbonPrices (Country TEXT, Year INT, Quarter INT, CarbonPrice NUMBER); INSERT INTO CarbonPrices (Country, Year, Quarter, CarbonPrice) VALUES ('Europe', 2020, 4, 25), ('Australia', 2020, 4, 15); CREATE TABLE CarbonTaxes (Country TEXT, Year INT, Quarter INT, CarbonPrice NUMBER); INSERT INTO CarbonTaxes (Country, Year, Quarter, CarbonPrice) VALUES ('Europe', 2019, 4, 20), ('Australia', 2019, 4, 10);", "reference_sql": "SELECT Context.Country, Context.CarbonPrice FROM ( SELECT * FROM CarbonPrices WHERE CarbonPrices.Country IN ('Europe', 'Australia') AND CarbonPrices.Year = 2020 AND CarbonPrices.Quarter = 4 UNION SELECT * FROM CarbonTaxes WHERE CarbonTaxes.Country IN ('Europe', 'Australia') AND CarbonTaxes.Year = 2020 AND CarbonTaxes.Quarter = 4 ) AS Context;", "generated_sql": "SELECT Country, CarbonPrice \nFROM CarbonPrices \nWHERE Year = 2020 AND Quarter = 4;", "raw_model_output": "```sql\nSELECT Country, CarbonPrice \nFROM CarbonPrices \nWHERE Year = 2020 AND Quarter = 4;\n```", "latency_sec": 1.032135009765625, "total_duration_sec": 0.733816101, "load_duration_sec": 0.013835051, "tokens_prompt": 228, "prompt_eval_sec": 0.045964668, "tokens_completion": 29, "completion_eval_sec": 0.671812006, "tokens_total": 257, "tokens_per_sec": 248.9984329262884, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL combines data from both CarbonPrices and CarbonTaxes tables using a UNION, while the Generated SQL only queries the CarbonPrices table. The Generated SQL omits the CarbonTaxes table entirely, so it would not include any data from that table even if it contained matching records. Although in the provided sample data CarbonTaxes has no 2020 entries, the queries are not equivalent in general case scenarios.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries return the same results because the CarbonTaxes table has no 2020 Q4 data (only 2019 data), making the UNION with CarbonTaxes irrelevant. However, the generated query is more efficient as it directly targets the CarbonPrices table, which contains the relevant data. The reference query includes unnecessary complexity by combining tables that aren't needed. While both fulfill the business intent of retrieving 2020 Q4 carbon prices, the generated query does so more elegantly and with better performance.", "overall_assessment": "correct"}}
{"example_id": 4573, "sql_complexity": "subqueries", "prompt": "Find the names of all the indigenous communities in the 'Arctic_Communities' table that have a population size greater than the average population size in the 'Antarctic_Communities' table.", "context": "CREATE TABLE Arctic_Communities (name TEXT, population INTEGER); CREATE TABLE Antarctic_Communities (name TEXT, population INTEGER);", "reference_sql": "SELECT name FROM Arctic_Communities WHERE Arctic_Communities.population > (SELECT AVG(population) FROM Antarctic_Communities)", "generated_sql": "SELECT name \nFROM Arctic_Communities \nWHERE population > (SELECT AVG(population) FROM Antarctic_Communities);", "raw_model_output": "```sql\nSELECT name \nFROM Arctic_Communities \nWHERE population > (SELECT AVG(population) FROM Antarctic_Communities);\n```", "latency_sec": 0.8200011253356934, "total_duration_sec": 0.653227993, "load_duration_sec": 0.014043638, "tokens_prompt": 139, "prompt_eval_sec": 0.027921634, "tokens_completion": 27, "completion_eval_sec": 0.607775978, "tokens_total": 166, "tokens_per_sec": 202.43874657128387, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select names from Arctic_Communities where population exceeds the average population of Antarctic_Communities. The generated query omits the table alias in the WHERE clause, but since the column 'population' is unique to Arctic_Communities, the semantic meaning remains identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent. The reference query explicitly qualifies the 'population' column with the table name, while the generated query relies on context from the main table. Since the main query's FROM clause specifies 'Arctic_Communities', the 'population' column in the WHERE clause unambiguously refers to that table. Both achieve the same result: selecting Arctic communities with population > average Antarctic population. The generated query is slightly more concise but the reference version is more explicit. Neither query has performance advantages over the other.", "overall_assessment": "correct"}}
{"example_id": 3596, "sql_complexity": "window functions", "prompt": "What is the total revenue for each game in the \"Gaming\" category?", "context": "CREATE TABLE Games (GameID int, GameName varchar(50), Category varchar(50), Revenue decimal(10,2));", "reference_sql": "SELECT Category, SUM(Revenue) OVER(PARTITION BY Category) as TotalRevenue FROM Games;", "generated_sql": "SELECT GameName, SUM(Revenue) AS TotalRevenue\nFROM Games\nWHERE Category = 'Gaming'\nGROUP BY GameName;", "raw_model_output": "```sql\nSELECT GameName, SUM(Revenue) AS TotalRevenue\nFROM Games\nWHERE Category = 'Gaming'\nGROUP BY GameName;\n```", "latency_sec": 0.9613420963287354, "total_duration_sec": 0.754451071, "load_duration_sec": 0.013252088, "tokens_prompt": 121, "prompt_eval_sec": 0.023878713, "tokens_completion": 32, "completion_eval_sec": 0.715365237, "tokens_total": 153, "tokens_per_sec": 159.15250209503043, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates total revenue per category using a window function, returning Category and TotalRevenue for all games. The generated query filters to only 'Gaming' category, groups by GameName, and sums revenue per game, resulting in different columns, filtering, and aggregation logic.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL calculates the total revenue per category (not per game) using a window function, and does not filter for the 'Gaming' category. It would return the same category total for every game in the Gaming category, which is incorrect. The Generated SQL correctly filters for 'Gaming' and groups by GameName to calculate each game's total revenue. However, if Revenue is already per-game, the SUM is redundant but still technically correct. The Reference SQL fails to address the business intent of isolating Gaming category games and aggregating by individual games.", "overall_assessment": "incorrect"}}
{"example_id": 5039, "sql_complexity": "subqueries", "prompt": "What is the total number of community policing events in 'City Park' in 2021?", "context": "CREATE TABLE locations (id INT, name VARCHAR(255)); CREATE TABLE community_policing (id INT, location_id INT, year INT, events INT); INSERT INTO locations (id, name) VALUES (1, 'City Park'); INSERT INTO community_policing (id, location_id, year, events) VALUES (1, 1, 2021, 5);", "reference_sql": "SELECT SUM(events) FROM community_policing WHERE location_id = (SELECT id FROM locations WHERE name = 'City Park') AND year = 2021;", "generated_sql": "SELECT SUM(events) AS total_events\nFROM community_policing cp\nJOIN locations l ON cp.location_id = l.id\nWHERE l.name = 'City Park' AND cp.year = 2021;", "raw_model_output": "```sql\nSELECT SUM(events) AS total_events\nFROM community_policing cp\nJOIN locations l ON cp.location_id = l.id\nWHERE l.name = 'City Park' AND cp.year = 2021;\n```", "latency_sec": 1.440809965133667, "total_duration_sec": 1.160798949, "load_duration_sec": 0.016277199, "tokens_prompt": 179, "prompt_eval_sec": 0.033373697, "tokens_completion": 49, "completion_eval_sec": 1.108956346, "tokens_total": 228, "tokens_per_sec": 158.24432473219878, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of 'events' for the 'City Park' location in 2021. The Reference SQL uses a subquery to get the location_id, while the Generated SQL uses a JOIN to combine the tables. Since the subquery in the Reference SQL returns a single id (as per the sample data), both approaches yield the same result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the total community policing events in 'City Park' for 2021. The reference query uses a subquery to get location_id, while the generated query uses an explicit JOIN. Semantically, they produce identical results. The generated query is more readable due to explicit JOIN syntax, which may improve maintainability. Both are efficient, but the JOIN version might perform better in some databases with proper indexing. The generated query also explicitly aliases tables, enhancing clarity without sacrificing correctness.", "overall_assessment": "correct"}}
{"example_id": 2724, "sql_complexity": "basic SQL", "prompt": "What is the earliest installation date for solar panels in Italy?", "context": "CREATE TABLE solar_panels_italy (id INT, installation_date DATE); INSERT INTO solar_panels_italy (id, installation_date) VALUES (1, '2018-01-01'), (2, '2019-01-01'), (3, '2020-01-01');", "reference_sql": "SELECT MIN(installation_date) as earliest_date FROM solar_panels_italy;", "generated_sql": "SELECT MIN(installation_date) AS earliest_installation_date\nFROM solar_panels_italy;", "raw_model_output": "```sql\nSELECT MIN(installation_date) AS earliest_installation_date\nFROM solar_panels_italy;\n```", "latency_sec": 0.7815308570861816, "total_duration_sec": 0.633943006, "load_duration_sec": 0.01452511, "tokens_prompt": 164, "prompt_eval_sec": 0.030237637, "tokens_completion": 26, "completion_eval_sec": 0.587129867, "tokens_total": 190, "tokens_per_sec": 243.11260173192133, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the minimum installation_date from the same table. The only difference is the column alias name ('earliest_date' vs 'earliest_installation_date'), which does not affect the semantic result. The MIN() function and table structure are identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly retrieve the earliest installation date using MIN(installation_date). The reference query uses 'earliest_date' while the generated query uses 'earliest_installation_date' as the alias. The generated version's alias is more explicitly descriptive of the data it represents, improving readability without altering functionality. Both are syntactically correct, semantically equivalent, and fulfill the business intent of identifying the earliest installation date.", "overall_assessment": "correct"}}
{"example_id": 2200, "sql_complexity": "single join", "prompt": "Which diversity programs are currently being participated in by employees in the HR department?", "context": "CREATE TABLE Employees (Employee_ID INT, First_Name VARCHAR(20), Last_Name VARCHAR(20), Department VARCHAR(20), Salary DECIMAL(10,2), Date_Hired DATE); CREATE TABLE Diversity_Programs (Program_ID INT, Program_Name VARCHAR(50), Participant_ID INT, Date_Started DATE, Date_Ended DATE);", "reference_sql": "SELECT dp.Program_Name FROM Diversity_Programs dp JOIN Employees e ON dp.Participant_ID = e.Employee_ID WHERE e.Department = 'HR' AND dp.Date_Ended IS NULL;", "generated_sql": "SELECT dp.Program_Name\nFROM Diversity_Programs dp\nJOIN Employees e ON dp.Participant_ID = e.Employee_ID\nWHERE e.Department = 'HR' AND (dp.Date_Ended IS NULL OR dp.Date_Ended > CURDATE());", "raw_model_output": "```sql\nSELECT dp.Program_Name\nFROM Diversity_Programs dp\nJOIN Employees e ON dp.Participant_ID = e.Employee_ID\nWHERE e.Department = 'HR' AND (dp.Date_Ended IS NULL OR dp.Date_Ended > CURDATE());\n```", "latency_sec": 1.3570349216461182, "total_duration_sec": 1.261629224, "load_duration_sec": 0.016044929, "tokens_prompt": 164, "prompt_eval_sec": 0.032436814, "tokens_completion": 53, "completion_eval_sec": 1.211077495, "tokens_total": 217, "tokens_per_sec": 159.90745450881502, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL explicitly requires dp.Date_Ended IS NULL, while the Generated SQL includes an OR condition (dp.Date_Ended IS NULL OR dp.Date_Ended > CURDATE()). This makes the Generated SQL broader, as it would include programs with future end dates (which may not be intended). The original query only targets unended programs (NULL), whereas the generated query could include programs scheduled to end in the future, leading to different result sets.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query only checks for programs where Date_Ended is NULL, which assumes that 'currently participating' means the program has no end date. However, the generated query uses (Date_Ended IS NULL OR Date_Ended > CURDATE()), which captures both programs without end dates and those with future end dates. This is more comprehensive for 'currently participating' as it includes programs that are still active (even if their end date is in the future). While both queries are technically valid, the generated query better aligns with the business intent of identifying all active participation, not just those with explicitly unset end dates. The reference query might miss programs where Date_Ended is a future date, which could still represent ongoing participation.", "overall_assessment": "differently_correct"}}
{"example_id": 4359, "sql_complexity": "window functions", "prompt": "Which destinations have the least hotel awards?", "context": "CREATE TABLE Destinations (destination_id INT, destination_name TEXT, country TEXT, awards INT); INSERT INTO Destinations (destination_id, destination_name, country, awards) VALUES (1, 'City A', 'Germany', 3), (2, 'City B', 'Switzerland', 5), (3, 'City C', 'Norway', 2);", "reference_sql": "SELECT destination_name, country, awards, RANK() OVER (PARTITION BY country ORDER BY awards ASC) AS rank FROM Destinations;", "generated_sql": "SELECT destination_name \nFROM Destinations \nORDER BY awards ASC \nLIMIT 1;", "raw_model_output": "```sql\nSELECT destination_name \nFROM Destinations \nORDER BY awards ASC \nLIMIT 1;\n```", "latency_sec": 0.5969839096069336, "total_duration_sec": 0.546105555, "load_duration_sec": 0.013781732, "tokens_prompt": 160, "prompt_eval_sec": 0.030563108, "tokens_completion": 22, "completion_eval_sec": 0.499538165, "tokens_total": 182, "tokens_per_sec": 304.8658382096638, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates a rank for each destination within its country based on awards, returning all rows with additional rank information. The Generated SQL only retrieves the single destination with the lowest awards, limiting output to one row and selecting only the destination_name. The result sets differ in both structure and content.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query ranks destinations within each country by awards, which introduces a country-based partition not mentioned in the original question. The generated query directly identifies the destination with the minimum awards (LIMIT 1) and aligns with the business intent of finding 'the least hotel awards' globally. While the generated query might miss ties (e.g., multiple destinations with the same minimum awards), it technically fulfills the intent of finding the single destination with the lowest count. The reference query's country partitioning makes it semantically different from the original question.", "overall_assessment": "differently_correct"}}
{"example_id": 1373, "sql_complexity": "subqueries", "prompt": "What is the total value of military equipment sales to Africa in the last 12 months?", "context": "CREATE TABLE Military_Equipment_Sales(sale_id INT, sale_date DATE, equipment_type VARCHAR(50), country VARCHAR(50), sale_value DECIMAL(10,2));", "reference_sql": "SELECT SUM(sale_value) FROM Military_Equipment_Sales WHERE country IN (SELECT country FROM World_Countries WHERE continent = 'Africa') AND sale_date >= DATE_SUB(CURRENT_DATE, INTERVAL 12 MONTH);", "generated_sql": "SELECT SUM(sale_value) AS total_sales_value\nFROM Military_Equipment_Sales\nWHERE country = 'Africa'\nAND sale_date >= DATEADD(MONTH, -12, CURRENT_DATE);", "raw_model_output": "```sql\nSELECT SUM(sale_value) AS total_sales_value\nFROM Military_Equipment_Sales\nWHERE country = 'Africa'\nAND sale_date >= DATEADD(MONTH, -12, CURRENT_DATE);\n```", "latency_sec": 1.193432092666626, "total_duration_sec": 1.082058839, "load_duration_sec": 0.018413376, "tokens_prompt": 134, "prompt_eval_sec": 0.027175545, "tokens_completion": 46, "completion_eval_sec": 1.034552925, "tokens_total": 180, "tokens_per_sec": 150.82550662585652, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their country filtering logic. The Reference SQL uses a subquery to select countries in Africa from World_Countries, while the Generated SQL explicitly checks for country = 'Africa'. This would only be equivalent if 'Africa' was a single country in the Military_Equipment_Sales table, which is unlikely. The date functions (DATE_SUB vs DATEADD) are functionally equivalent but not semantically identical.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly identifies African countries via a subquery on World_Countries, ensuring sales to all African nations are included. The Generated SQL incorrectly filters WHERE country = 'Africa' (treating Africa as a country), which would likely return no results since 'Africa' is a continent, not a country. Both use valid date logic (12-month window), but the Generated query's country filter fundamentally misinterprets the business requirement. The Reference query properly addresses the intent of aggregating sales to the entire continent.", "overall_assessment": "incorrect"}}
{"example_id": 904, "sql_complexity": "basic SQL", "prompt": "What is the minimum Shariah-compliant loan amount issued in the last quarter of 2021?", "context": "CREATE TABLE loans (id INT, amount DECIMAL, date DATE, loan_type VARCHAR); INSERT INTO loans (id, amount, date, loan_type) VALUES (1, 5000, '2021-09-05', 'Shariah-compliant'), (2, 7000, '2021-10-07', 'socially responsible'), (3, 9000, '2021-11-03', 'Shariah-compliant'), (4, 11000, '2021-12-31', 'Shariah-compliant');", "reference_sql": "SELECT MIN(amount) FROM loans WHERE EXTRACT(YEAR FROM date) = 2021 AND EXTRACT(QUARTER FROM date) = 4 AND loan_type = 'Shariah-compliant';", "generated_sql": "SELECT MIN(amount) AS min_shariah_compliant_loan_amount\nFROM loans\nWHERE loan_type = 'Shariah-compliant'\n  AND date >= '2021-10-01' AND date <= '2021-12-31';", "raw_model_output": "```sql\nSELECT MIN(amount) AS min_shariah_compliant_loan_amount\nFROM loans\nWHERE loan_type = 'Shariah-compliant'\n  AND date >= '2021-10-01' AND date <= '2021-12-31';\n```", "latency_sec": 1.6432929039001465, "total_duration_sec": 1.550029795, "load_duration_sec": 0.014106983, "tokens_prompt": 241, "prompt_eval_sec": 0.051245038, "tokens_completion": 64, "completion_eval_sec": 1.482356848, "tokens_total": 305, "tokens_per_sec": 185.6029435021117, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter Shariah-compliant loans in the fourth quarter of 2021. The reference query uses EXTRACT(QUARTER) = 4 and EXTRACT(YEAR) = 2021, which corresponds to October-December 2021. The generated query uses a date range (2021-10-01 to 2021-12-31) that exactly matches the same period. Both return the minimum amount from the same subset of loans (ids 3 and 4), resulting in the same value (9000).", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify the minimum Shariah-compliant loan amount in Q4 2021. The reference query uses EXTRACT() to filter by year and quarter, while the generated query uses a date range. Semantically, both capture the same time period (October-December 2021). However, the generated query is more efficient as date ranges can leverage indexes, whereas EXTRACT() may prevent index usage. The generated query also avoids potential edge cases with EXTRACT(QUARTER) (e.g., different database implementations). Both fulfill the business intent, but the generated version is more elegant and performant.", "overall_assessment": "correct"}}
{"example_id": 3299, "sql_complexity": "set operations", "prompt": "How many schools and hospitals are there in Colombia and which ones need repairs?", "context": "CREATE TABLE schools (id INT, country VARCHAR(20), name VARCHAR(50), needs_repair BOOLEAN); CREATE TABLE hospitals (id INT, country VARCHAR(20), name VARCHAR(50), needs_repair BOOLEAN);", "reference_sql": "SELECT 'Schools' as facility_type, COUNT(*) as total, SUM(needs_repair) as repairs_needed FROM schools WHERE country = 'Colombia' UNION ALL SELECT 'Hospitals' as facility_type, COUNT(*) as total, SUM(needs_repair) as repairs_needed FROM hospitals WHERE country = 'Colombia';", "generated_sql": "SELECT \n    'schools' AS type, \n    COUNT(*) AS count, \n    GROUP_CONCAT(name SEPARATOR ', ') AS names_needing_repairs\nFROM \n    schools\nWHERE \n    country = 'Colombia' AND needs_repair = TRUE\n\nUNION ALL\n\nSELECT \n    'hospitals' AS type, \n    COUNT(*) AS count, \n    GROUP_CONCAT(name SEPARATOR ', ') AS names_needing_repairs\nFROM \n    hospitals\nWHERE \n    country = 'Colombia' AND needs_repair = TRUE;", "raw_model_output": "```sql\nSELECT \n    'schools' AS type, \n    COUNT(*) AS count, \n    GROUP_CONCAT(name SEPARATOR ', ') AS names_needing_repairs\nFROM \n    schools\nWHERE \n    country = 'Colombia' AND needs_repair = TRUE\n\nUNION ALL\n\nSELECT \n    'hospitals' AS type, \n    COUNT(*) AS count, \n    GROUP_CONCAT(name SEPARATOR ', ') AS names_needing_repairs\nFROM \n    hospitals\nWHERE \n    country = 'Colombia' AND needs_repair = TRUE;\n```", "latency_sec": 3.0382437705993652, "total_duration_sec": 2.779594566, "load_duration_sec": 0.027736305, "tokens_prompt": 139, "prompt_eval_sec": 0.02603318, "tokens_completion": 121, "completion_eval_sec": 2.723690022, "tokens_total": 260, "tokens_per_sec": 85.57575350469948, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL calculates total facilities and repairs needed (count and sum of boolean) for both schools/hospitals, while the Generated SQL counts only facilities needing repair and concatenates their names. The output structure differs: the first has 'total' and 'repairs_needed' columns, while the second has 'count' and 'names_needing_repairs'. The Generated SQL also includes a comma-separated name list which the Reference SQL does not.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "equal", "explanation": "The queries are not technically equivalent. The reference query correctly calculates total facilities and repairs needed for both schools/hospitals, but does not list specific facilities needing repairs. The generated query lists names of facilities needing repairs but only counts those needing repairs (not total facilities). Neither query fully addresses both parts of the original question: the reference misses the 'which ones' component, while the generated query misses the total count of facilities. Both have different limitations in fulfilling the business intent.", "overall_assessment": "differently_correct"}}
{"example_id": 907, "sql_complexity": "set operations", "prompt": "What is the total quantity of items with type 'E' or type 'F' in warehouse O and warehouse P?", "context": "CREATE TABLE warehouse_o(item_id INT, item_type VARCHAR(10), quantity INT);CREATE TABLE warehouse_p(item_id INT, item_type VARCHAR(10), quantity INT);INSERT INTO warehouse_o(item_id, item_type, quantity) VALUES (1, 'E', 200), (2, 'F', 300), (3, 'E', 50), (4, 'F', 400);INSERT INTO warehouse_p(item_id, item_type, quantity) VALUES (1, 'E', 150), (2, 'F', 250), (3, 'E', 40), (4, 'F', 350);", "reference_sql": "SELECT quantity FROM warehouse_o WHERE item_type IN ('E', 'F') UNION ALL SELECT quantity FROM warehouse_p WHERE item_type IN ('E', 'F');", "generated_sql": "SELECT SUM(quantity) AS total_quantity\nFROM (\n    SELECT quantity FROM warehouse_o WHERE item_type IN ('E', 'F')\n    UNION ALL\n    SELECT quantity FROM warehouse_p WHERE item_type IN ('E', 'F')\n) AS combined_quantities;", "raw_model_output": "```sql\nSELECT SUM(quantity) AS total_quantity\nFROM (\n    SELECT quantity FROM warehouse_o WHERE item_type IN ('E', 'F')\n    UNION ALL\n    SELECT quantity FROM warehouse_p WHERE item_type IN ('E', 'F')\n) AS combined_quantities;\n```", "latency_sec": 1.4771068096160889, "total_duration_sec": 1.388431198, "load_duration_sec": 0.013531816, "tokens_prompt": 248, "prompt_eval_sec": 0.051481939, "tokens_completion": 57, "completion_eval_sec": 1.321280775, "tokens_total": 305, "tokens_per_sec": 206.48472948227203, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns a list of individual quantities from both tables, while the Generated SQL aggregates all quantities into a single sum. The first produces multiple rows of raw data, the second produces one row with a total value. Their output structures and results differ fundamentally.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query returns individual quantities from both warehouses without aggregation, while the generated query properly sums all qualifying quantities. The reference fails to fulfill the business intent of calculating a total, whereas the generated query correctly aggregates the data. The generated query is also more efficient and elegant by directly using SUM on the combined results.", "overall_assessment": "differently_correct"}}
{"example_id": 1400, "sql_complexity": "single join", "prompt": "What is the maximum co-ownership duration for properties in the neighborhood of 'Chinatown' in San Francisco?'", "context": "CREATE TABLE sf_neighborhoods (neighborhood_id INT, name VARCHAR(255), city VARCHAR(255)); INSERT INTO sf_neighborhoods (neighborhood_id, name, city) VALUES (1, 'Chinatown', 'San Francisco'); CREATE TABLE co_ownership (co_ownership_id INT, property_id INT, co_owner_id INT, start_date DATE, end_date DATE); INSERT INTO co_ownership (co_ownership_id, property_id, co_owner_id, start_date, end_date) VALUES (1, 1, 2, '2010-01-01', '2020-01-01'), (2, 2, 3, '2015-01-01', '2022-01-01'); CREATE TABLE properties (property_id INT, city VARCHAR(255)); INSERT INTO properties (property_id, city) VALUES (1, 'San Francisco'), (2, 'San Francisco');", "reference_sql": "SELECT MAX(DATEDIFF(end_date, start_date)) as max_duration FROM co_ownership JOIN properties ON co_ownership.property_id = properties.property_id WHERE properties.city = 'San Francisco' AND name = 'Chinatown';", "generated_sql": "SELECT MAX(DATEDIFF(end_date, start_date)) AS max_co_ownership_duration\nFROM co_ownership\nJOIN properties ON co_ownership.property_id = properties.property_id\nJOIN sf_neighborhoods ON properties.city = sf_neighborhoods.city\nWHERE sf_neighborhoods.name = 'Chinatown' AND sf_neighborhoods.city = 'San Francisco';", "raw_model_output": "```sql\nSELECT MAX(DATEDIFF(end_date, start_date)) AS max_co_ownership_duration\nFROM co_ownership\nJOIN properties ON co_ownership.property_id = properties.property_id\nJOIN sf_neighborhoods ON properties.city = sf_neighborhoods.city\nWHERE sf_neighborhoods.name = 'Chinatown' AND sf_neighborhoods.city = 'San Francisco';\n```", "latency_sec": 2.0287179946899414, "total_duration_sec": 1.931106303, "load_duration_sec": 0.014306652, "tokens_prompt": 312, "prompt_eval_sec": 0.065510197, "tokens_completion": 79, "completion_eval_sec": 1.848544185, "tokens_total": 391, "tokens_per_sec": 192.73255377209705, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references a 'name' column in the WHERE clause that doesn't exist in the joined tables (co_ownership and properties). The Generated SQL correctly joins with sf_neighborhoods to access the 'name' column. The Reference SQL would throw an error, while the Generated SQL is valid. Additionally, the Generated SQL explicitly joins on city matching between properties and sf_neighborhoods, which the Reference SQL implicitly assumes without proper joining.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query is technically incorrect because it references a 'name' column in the WHERE clause that does not exist in the joined tables (properties table lacks neighborhood information). The generated query correctly joins with sf_neighborhoods to filter by neighborhood name. While both attempt to calculate maximum duration, only the generated query properly links properties to their neighborhoods. The reference query would fail due to an undefined column 'name'.", "overall_assessment": "incorrect"}}
{"example_id": 5248, "sql_complexity": "window functions", "prompt": "Find the top 5 games by rating", "context": "CREATE TABLE games (game_id INT PRIMARY KEY, name VARCHAR(50), genre VARCHAR(50), rating DECIMAL(3,2));", "reference_sql": "SELECT * FROM (SELECT name, rating, ROW_NUMBER() OVER (ORDER BY rating DESC) as rn FROM games) t WHERE rn <= 5;", "generated_sql": "SELECT game_id, name, genre, rating\nFROM games\nORDER BY rating DESC\nLIMIT 5;", "raw_model_output": "```sql\nSELECT game_id, name, genre, rating\nFROM games\nORDER BY rating DESC\nLIMIT 5;\n```", "latency_sec": 0.9328587055206299, "total_duration_sec": 0.641233577, "load_duration_sec": 0.014433961, "tokens_prompt": 115, "prompt_eval_sec": 0.022412845, "tokens_completion": 27, "completion_eval_sec": 0.601468559, "tokens_total": 142, "tokens_per_sec": 152.22026568401864, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL returns only 'name', 'rating', and a row number ('rn') for top 5 ratings, while the Generated SQL returns all columns (game_id, name, genre, rating) for the top 5 ratings. The column sets differ, and the Generated SQL omits the row number calculation.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query returns only 'name' and 'rating' columns, while the generated query returns all columns (game_id, name, genre, rating). Both correctly identify top 5 games by rating, but the generated query provides more complete data. The generated query is more efficient with simpler syntax (ORDER BY + LIMIT) compared to the reference's window function approach. While both fulfill the business intent, the generated query better addresses the implicit need for full game details.", "overall_assessment": "differently_correct"}}
{"example_id": 778, "sql_complexity": "single join", "prompt": "What is the maximum property price in wheelchair-accessible neighborhoods in Singapore?", "context": "CREATE TABLE Singapore_Neighborhoods (Neighborhood_Name TEXT, Wheelchair_Accessibility BOOLEAN); INSERT INTO Singapore_Neighborhoods (Neighborhood_Name, Wheelchair_Accessibility) VALUES ('Orchard', true), ('Marina Bay', true), ('Chinatown', false), ('Little India', false), ('Bugis', true); CREATE TABLE Singapore_Properties (Neighborhood_Name TEXT, Property_Price INTEGER); INSERT INTO Singapore_Properties (Neighborhood_Name, Property_Price) VALUES ('Orchard', 2000000), ('Marina Bay', 3000000), ('Chinatown', 1500000), ('Little India', 1200000), ('Bugis', 1800000);", "reference_sql": "SELECT MAX(Singapore_Properties.Property_Price) FROM Singapore_Properties INNER JOIN Singapore_Neighborhoods ON Singapore_Properties.Neighborhood_Name = Singapore_Neighborhoods.Neighborhood_Name WHERE Singapore_Neighborhoods.Wheelchair_Accessibility = true;", "generated_sql": "SELECT MAX(Property_Price) \nFROM Singapore_Properties \nWHERE Neighborhood_Name IN (\n    SELECT Neighborhood_Name \n    FROM Singapore_Neighborhoods \n    WHERE Wheelchair_Accessibility = true\n);", "raw_model_output": "```sql\nSELECT MAX(Property_Price) \nFROM Singapore_Properties \nWHERE Neighborhood_Name IN (\n    SELECT Neighborhood_Name \n    FROM Singapore_Neighborhoods \n    WHERE Wheelchair_Accessibility = true\n);\n```", "latency_sec": 1.4205482006072998, "total_duration_sec": 1.121611102, "load_duration_sec": 0.014053006, "tokens_prompt": 259, "prompt_eval_sec": 0.055140671, "tokens_completion": 45, "completion_eval_sec": 1.049505458, "tokens_total": 304, "tokens_per_sec": 214.00189016468198, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the maximum property price from neighborhoods with wheelchair accessibility. The Reference SQL uses an INNER JOIN to combine tables and filter on accessibility, while the Generated SQL uses a subquery with IN to achieve the same filtering. Both approaches ensure only properties in accessible neighborhoods are considered, resulting in identical output.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly identify the maximum property price in wheelchair-accessible neighborhoods. The reference query uses an INNER JOIN to combine tables and filter accessible neighborhoods, while the generated query uses a subquery with IN to achieve the same result. Both approaches produce identical results because they filter properties to only those in neighborhoods marked as wheelchair-accessible. The business intent is fully addressed by both queries, as they correctly restrict to the specified subset of neighborhoods. In terms of efficiency, both are equally valid - the JOIN and IN clause approaches have similar performance characteristics in this context. The choice between them would depend on readability preferences or specific database optimization considerations, but neither has a clear advantage in this scenario.", "overall_assessment": "correct"}}
{"example_id": 3859, "sql_complexity": "aggregation", "prompt": "What is the total number of mental health parity violations by month and year?", "context": "CREATE TABLE mental_health_parity_reports (report_id INT, violation_date DATE); INSERT INTO mental_health_parity_reports (report_id, violation_date) VALUES (1, '2022-01-01'), (2, '2022-02-15'), (3, '2022-03-05'), (4, '2022-04-20'), (5, '2021-06-12'), (6, '2021-07-28');", "reference_sql": "SELECT EXTRACT(MONTH FROM violation_date) AS month, EXTRACT(YEAR FROM violation_date) AS year, COUNT(*) FROM mental_health_parity_reports GROUP BY month, year;", "generated_sql": "SELECT \n    EXTRACT(YEAR FROM violation_date) AS year,\n    EXTRACT(MONTH FROM violation_date) AS month,\n    COUNT(*) AS total_violations\nFROM \n    mental_health_parity_reports\nGROUP BY \n    year, month\nORDER BY \n    year, month;", "raw_model_output": "```sql\nSELECT \n    EXTRACT(YEAR FROM violation_date) AS year,\n    EXTRACT(MONTH FROM violation_date) AS month,\n    COUNT(*) AS total_violations\nFROM \n    mental_health_parity_reports\nGROUP BY \n    year, month\nORDER BY \n    year, month;\n```", "latency_sec": 1.8772640228271484, "total_duration_sec": 1.572102971, "load_duration_sec": 0.014668802, "tokens_prompt": 212, "prompt_eval_sec": 0.045243133, "tokens_completion": 66, "completion_eval_sec": 1.509539096, "tokens_total": 278, "tokens_per_sec": 148.0878537166731, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries group by year and month (in different order) and count violations. The SELECT column order differs but does not affect the result's semantic content. The generated query adds an ORDER BY, which does not change the data returned, only the order of rows. Since semantic equivalence focuses on data consistency, not column order or sorting, the queries are equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The Reference SQL is technically correct as it uses EXTRACT functions directly in the GROUP BY clause, which is valid in standard SQL. The Generated SQL attempts to use column aliases (year, month) in the GROUP BY clause, which is not allowed in standard SQL (though some databases like MySQL may permit it). This makes the Generated SQL potentially invalid in most SQL implementations. Both queries fulfill the business intent by grouping violations by month and year, but the Reference is more reliable. The Generated SQL includes an ORDER BY clause, which is not required by the original question but adds minor readability. However, the technical correctness of the Reference makes it superior.", "overall_assessment": "correct"}}
{"example_id": 3551, "sql_complexity": "multiple_joins", "prompt": "List all artists who have performed in New York and Chicago, along with their highest-earning performance.", "context": "CREATE TABLE artist_events (artist_id INT, event_id INT, earnings DECIMAL(5,2)); CREATE TABLE artists (id INT, name VARCHAR(50)); CREATE TABLE events (id INT, city VARCHAR(20));", "reference_sql": "SELECT artists.name, MAX(artist_events.earnings) FROM artists INNER JOIN artist_events ON artists.id = artist_events.artist_id INNER JOIN events ON artist_events.event_id = events.id WHERE city IN ('New York', 'Chicago') GROUP BY artists.name;", "generated_sql": "SELECT a.name AS artist_name, MAX(ae.earnings) AS highest_earning_performance\nFROM artists a\nJOIN artist_events ae ON a.id = ae.artist_id\nJOIN events e ON ae.event_id = e.id\nWHERE e.city IN ('New York', 'Chicago')\nGROUP BY a.name\nHAVING COUNT(DISTINCT e.city) = 2;", "raw_model_output": "```sql\nSELECT a.name AS artist_name, MAX(ae.earnings) AS highest_earning_performance\nFROM artists a\nJOIN artist_events ae ON a.id = ae.artist_id\nJOIN events e ON ae.event_id = e.id\nWHERE e.city IN ('New York', 'Chicago')\nGROUP BY a.name\nHAVING COUNT(DISTINCT e.city) = 2;\n```", "latency_sec": 1.9634342193603516, "total_duration_sec": 1.862056525, "load_duration_sec": 0.015179276, "tokens_prompt": 143, "prompt_eval_sec": 0.027235438, "tokens_completion": 81, "completion_eval_sec": 1.817565393, "tokens_total": 224, "tokens_per_sec": 114.08581850680733, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The generated query includes a HAVING clause filtering for artists with events in both 'New York' and 'Chicago' (COUNT(DISTINCT e.city) = 2), while the reference query only filters events in those cities without requiring multiple cities. This makes the generated query more restrictive.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries differ in their logic. The Reference SQL returns artists who performed in either New York or Chicago (not necessarily both) and shows their maximum earnings across all events. The Generated SQL correctly filters artists who performed in *both* cities (via HAVING COUNT(DISTINCT e.city) = 2) and also shows their highest-earning performance. While both queries calculate MAX(earnings) correctly, the Generated query adds the critical business requirement of ensuring performances in *both* cities. The Reference query would include artists who only performed in one of the cities, which doesn't fully satisfy the original question's intent.", "overall_assessment": "differently_correct"}}
{"example_id": 5168, "sql_complexity": "aggregation", "prompt": "Get the number of renewable energy projects in Australia for each project type.", "context": "CREATE TABLE renewable_projects (id INT PRIMARY KEY, project_name VARCHAR(255), project_location VARCHAR(255), project_type VARCHAR(255), capacity_mw FLOAT);", "reference_sql": "SELECT project_type, COUNT(*) FROM renewable_projects WHERE project_location = 'Australia' GROUP BY project_type;", "generated_sql": "SELECT project_type, COUNT(*) AS number_of_projects\nFROM renewable_projects\nWHERE project_location = 'Australia'\nGROUP BY project_type;", "raw_model_output": "```sql\nSELECT project_type, COUNT(*) AS number_of_projects\nFROM renewable_projects\nWHERE project_location = 'Australia'\nGROUP BY project_type;\n```", "latency_sec": 1.0595970153808594, "total_duration_sec": 0.7604365, "load_duration_sec": 0.014494454, "tokens_prompt": 129, "prompt_eval_sec": 0.025507618, "tokens_completion": 32, "completion_eval_sec": 0.717385452, "tokens_total": 161, "tokens_per_sec": 151.94455784884454, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same data: counts of projects grouped by project_type in Australia. The generated query adds an alias 'number_of_projects' to the count column, but this does not affect the semantic result set structure or values.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count renewable energy projects in Australia by project type. The reference query uses COUNT(*) directly, while the generated query adds an alias 'number_of_projects' which improves readability without altering functionality. The generated version is more elegant due to the explicit column alias, making the output more meaningful for end-users. Both satisfy the business intent of counting projects per type, but the generated query's clarity gives it a slight edge in elegance and practicality.", "overall_assessment": "correct"}}
{"example_id": 4916, "sql_complexity": "aggregation", "prompt": "What is the maximum revenue generated from selling Yttrium in India in the past 3 years?", "context": "CREATE TABLE Yttrium_Sales (id INT PRIMARY KEY, year INT, country VARCHAR(20), quantity INT, price PER_KG); INSERT INTO Yttrium_Sales (id, year, country, quantity, price) VALUES (1, 2019, 'India', 120, 40), (2, 2020, 'India', 130, 45), (3, 2021, 'India', 140, 50), (4, 2019, 'China', 150, 35), (5, 2020, 'China', 160, 40), (6, 2021, 'China', 170, 45);", "reference_sql": "SELECT MAX(quantity * price) FROM Yttrium_Sales WHERE country = 'India' GROUP BY year ORDER BY year DESC LIMIT 3;", "generated_sql": "SELECT MAX(revenue) AS max_revenue\nFROM (\n    SELECT year, SUM(quantity * price) AS revenue\n    FROM Yttrium_Sales\n    WHERE country = 'India' AND year >= YEAR(CURRENT_DATE) - 3\n    GROUP BY year\n) AS yearly_revenue;", "raw_model_output": "```sql\nSELECT MAX(revenue) AS max_revenue\nFROM (\n    SELECT year, SUM(quantity * price) AS revenue\n    FROM Yttrium_Sales\n    WHERE country = 'India' AND year >= YEAR(CURRENT_DATE) - 3\n    GROUP BY year\n) AS yearly_revenue;\n```", "latency_sec": 1.8618950843811035, "total_duration_sec": 1.661441102, "load_duration_sec": 0.013788931, "tokens_prompt": 274, "prompt_eval_sec": 0.05834694, "tokens_completion": 68, "completion_eval_sec": 1.586839275, "tokens_total": 342, "tokens_per_sec": 183.68381917377545, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates the maximum (quantity * price) per year for India, orders by year descending, and limits 3 results. The Generated SQL sums (quantity * price) per year, filters years >= current year - 3, and returns the maximum of those summed revenues. Key differences: 1) Calculation method (max vs sum), 2) Filtering logic (country='India' vs country='India' + year range), 3) Output structure (multiple rows vs single value).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL is technically incorrect because it calculates MAX(quantity * price) per year (individual transaction revenue) rather than total yearly revenue. The Generated SQL correctly sums quantity * price per year to calculate total revenue, then finds the maximum. While the Generated SQL's WHERE clause (year >= YEAR(CURRENT_DATE) - 3) might have edge-case issues with current date logic, it better aligns with the business intent of calculating total revenue over the past 3 years. The Reference SQL's GROUP BY + LIMIT 3 approach would return multiple values (one per year) rather than a single maximum value, making it incomplete.", "overall_assessment": "differently_correct"}}
{"example_id": 812, "sql_complexity": "multiple_joins", "prompt": "What is the average salary of 'engineer' workers in each factory?", "context": "CREATE TABLE factories (factory_id INT, factory_name VARCHAR(20)); INSERT INTO factories VALUES (1, 'Factory X'), (2, 'Factory Y'), (3, 'Factory Z'); CREATE TABLE roles (role_id INT, role_name VARCHAR(20)); INSERT INTO roles VALUES (1, 'engineer'), (2, 'manager'), (3, 'assistant'); CREATE TABLE workers (worker_id INT, factory_id INT, role_id INT, salary DECIMAL(5,2)); INSERT INTO workers VALUES (1, 1, 1, 50000.00), (2, 1, 2, 70000.00), (3, 2, 1, 55000.00), (4, 2, 3, 40000.00), (5, 3, 1, 60000.00);", "reference_sql": "SELECT f.factory_name, AVG(salary) FROM workers w INNER JOIN factories f ON w.factory_id = f.factory_id INNER JOIN roles r ON w.role_id = r.role_id WHERE r.role_name = 'engineer' GROUP BY f.factory_name;", "generated_sql": "SELECT f.factory_name, AVG(w.salary) AS average_salary\nFROM factories f\nJOIN workers w ON f.factory_id = w.factory_id\nJOIN roles r ON w.role_id = r.role_id\nWHERE r.role_name = 'engineer'\nGROUP BY f.factory_name;", "raw_model_output": "```sql\nSELECT f.factory_name, AVG(w.salary) AS average_salary\nFROM factories f\nJOIN workers w ON f.factory_id = w.factory_id\nJOIN roles r ON w.role_id = r.role_id\nWHERE r.role_name = 'engineer'\nGROUP BY f.factory_name;\n```", "latency_sec": 1.7038087844848633, "total_duration_sec": 1.498910226, "load_duration_sec": 0.013717585, "tokens_prompt": 292, "prompt_eval_sec": 0.059480462, "tokens_completion": 61, "completion_eval_sec": 1.423323829, "tokens_total": 353, "tokens_per_sec": 207.18287357975296, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the average salary per factory for workers with the 'engineer' role. They use identical table joins (factories, workers, roles) with the same conditions, filter on 'engineer' role, and group by factory name. The differences are purely syntactic (alias naming, explicit vs implicit JOIN keywords) and do not affect the result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the average salary of 'engineer' workers per factory. They use identical table joins (factories, workers, roles) with the same filter condition (role_name = 'engineer') and grouping by factory_name. The differences are purely stylistic: the generated query uses explicit table aliases in JOIN conditions and includes an explicit column alias (average_salary), while the reference query omits the alias. Both produce identical result sets and follow proper SQL syntax. The generated query might be slightly more readable due to explicit aliases, but neither has a technical advantage.", "overall_assessment": "correct"}}
{"example_id": 5784, "sql_complexity": "set operations", "prompt": "List the number of users who have completed a workout of a specific type (e.g. Running) and have a membership status of 'Active'.", "context": "CREATE TABLE workouts (id INT, user_id INT, workout_type VARCHAR(20)); CREATE TABLE members (id INT, name VARCHAR(50), membership_status VARCHAR(20), state VARCHAR(20)); INSERT INTO workouts (id, user_id, workout_type) VALUES (1, 1, 'Running'), (2, 1, 'Cycling'), (3, 2, 'Running'), (4, 3, 'Cycling'), (5, 3, 'Swimming'), (6, 4, 'Running'), (7, 4, 'Swimming'); INSERT INTO members (id, name, membership_status, state) VALUES (1, 'John Doe', 'Active', 'Texas'), (2, 'Jane Doe', 'Inactive', 'California'), (3, 'Bob Smith', 'Active', 'Texas'), (4, 'Alice Johnson', 'Active', 'California');", "reference_sql": "SELECT COUNT(*) FROM (SELECT user_id FROM workouts WHERE workout_type = 'Running' INTERSECT SELECT id FROM members WHERE membership_status = 'Active') AS user_set;", "generated_sql": "SELECT COUNT(DISTINCT w.user_id) AS active_users_count\nFROM workouts w\nJOIN members m ON w.user_id = m.id\nWHERE w.workout_type = 'Running' AND m.membership_status = 'Active';", "raw_model_output": "```sql\nSELECT COUNT(DISTINCT w.user_id) AS active_users_count\nFROM workouts w\nJOIN members m ON w.user_id = m.id\nWHERE w.workout_type = 'Running' AND m.membership_status = 'Active';\n```", "latency_sec": 1.5786070823669434, "total_duration_sec": 1.306407459, "load_duration_sec": 0.014419772, "tokens_prompt": 295, "prompt_eval_sec": 0.065660677, "tokens_completion": 52, "completion_eval_sec": 1.223658787, "tokens_total": 347, "tokens_per_sec": 219.8140397797485, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of distinct user_ids that appear in both (1) workouts with 'Running' type and (2) active members. The Reference SQL uses INTERSECT to find common user_ids, while the Generated SQL uses a JOIN with COUNT(DISTINCT) to achieve the same result. The sample data confirms they produce identical counts (2 in this case).", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly count users with 'Running' workouts and active memberships. The Reference SQL uses INTERSECT to find common user_ids between workouts and members, while the Generated SQL uses a JOIN to combine tables and COUNT(DISTINCT) to eliminate duplicates. Both approaches yield the same result (2 users in the sample data). The Generated SQL is more explicit in its logic and may be more efficient, but both are technically correct. Neither query has syntax errors or logical flaws.", "overall_assessment": "correct"}}
{"example_id": 3038, "sql_complexity": "subqueries", "prompt": "What is the total assets of clients who have invested in mutual funds but not in stocks?", "context": "CREATE TABLE clients (client_id INT, name TEXT, age INT, gender TEXT, total_assets DECIMAL(10,2)); INSERT INTO clients VALUES (1, 'John Doe', 35, 'Male', 250000.00), (2, 'Jane Smith', 45, 'Female', 500000.00); CREATE TABLE investments (client_id INT, investment_type TEXT); INSERT INTO investments VALUES (1, 'Stocks'), (1, 'Bonds'), (2, 'Stocks'), (3, 'Mutual Funds');", "reference_sql": "SELECT c.total_assets FROM clients c INNER JOIN investments i ON c.client_id = i.client_id WHERE i.investment_type = 'Mutual Funds' AND c.client_id NOT IN (SELECT client_id FROM investments WHERE investment_type = 'Stocks');", "generated_sql": "SELECT SUM(total_assets) \nFROM clients \nWHERE client_id IN (\n    SELECT client_id \n    FROM investments \n    WHERE investment_type = 'Mutual Funds'\n) \nAND client_id NOT IN (\n    SELECT client_id \n    FROM investments \n    WHERE investment_type = 'Stocks'\n);", "raw_model_output": "```sql\nSELECT SUM(total_assets) \nFROM clients \nWHERE client_id IN (\n    SELECT client_id \n    FROM investments \n    WHERE investment_type = 'Mutual Funds'\n) \nAND client_id NOT IN (\n    SELECT client_id \n    FROM investments \n    WHERE investment_type = 'Stocks'\n);\n```", "latency_sec": 1.8682160377502441, "total_duration_sec": 1.564678985, "load_duration_sec": 0.024644579, "tokens_prompt": 220, "prompt_eval_sec": 0.044530536, "tokens_completion": 65, "completion_eval_sec": 1.493411374, "tokens_total": 285, "tokens_per_sec": 152.55195022477415, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns individual client assets (without aggregation), while the Generated SQL sums all matching clients' assets. Additionally, the Generated SQL uses IN clauses for filtering, whereas the Reference uses a JOIN and NOT IN. These differences in output structure and implementation lead to non-equivalence.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in two critical aspects. 1) The reference query returns individual client asset values, while the generated query aggregates them using SUM, which aligns with the 'total assets' requirement. 2) The reference query's WHERE clause uses a NOT IN subquery that could potentially return NULL values, leading to unexpected results. The generated query's structure is more robust and directly addresses the business requirement by explicitly calculating the total. Both queries correctly identify clients with mutual fund investments and no stock investments, but the generated query provides the required aggregated result.", "overall_assessment": "differently_correct"}}
{"example_id": 1078, "sql_complexity": "basic SQL", "prompt": "What is the maximum and minimum temperature difference between any two Arctic research stations?", "context": "CREATE TABLE arctic_stations (id INT, name TEXT, location TEXT, temperature DECIMAL(5,2)); INSERT INTO arctic_stations (id, name, location, temperature) VALUES (1, 'Station A', 'Greenland', 2.3), (2, 'Station B', 'Canada', -5.2);", "reference_sql": "SELECT a.name as station1, b.name as station2, MAX(ABS(a.temperature - b.temperature)) as temp_diff FROM arctic_stations a, arctic_stations b ORDER BY temp_diff DESC LIMIT 1", "generated_sql": "SELECT \n    MAX(temperature) - MIN(temperature) AS max_temp_difference,\n    MIN(temperature) - MAX(temperature) AS min_temp_difference\nFROM \n    arctic_stations;", "raw_model_output": "```sql\nSELECT \n    MAX(temperature) - MIN(temperature) AS max_temp_difference,\n    MIN(temperature) - MAX(temperature) AS min_temp_difference\nFROM \n    arctic_stations;\n```", "latency_sec": 1.461392879486084, "total_duration_sec": 1.06682678, "load_duration_sec": 0.013661583, "tokens_prompt": 162, "prompt_eval_sec": 0.032038335, "tokens_completion": 45, "completion_eval_sec": 1.017900318, "tokens_total": 207, "tokens_per_sec": 141.64568810051543, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the maximum absolute temperature difference between any two stations, returning station names and the max difference. The Generated SQL computes the difference between overall max and min temperatures (which equals the max absolute difference) but returns two columns (max_temp_difference and min_temp_difference) with different values (positive vs negative). The result structures and column counts differ, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "equal", "explanation": "The Reference SQL calculates the maximum temperature difference between any two stations using a self-join and ABS(), but it only returns the maximum difference (not the minimum). The Generated SQL incorrectly computes the minimum difference as a negative value (MIN(temperature) - MAX(temperature)) instead of using absolute values. Neither query fully addresses the original question, which requires both maximum and minimum differences. The Reference SQL is more technically accurate for the maximum difference, while the Generated SQL attempts to address both but with flawed logic. Both have significant shortcomings in fulfilling the business intent.", "overall_assessment": "incorrect"}}
{"example_id": 5015, "sql_complexity": "basic SQL", "prompt": "Calculate the average recycling rate", "context": "CREATE TABLE recycling_rates (id INT PRIMARY KEY, location VARCHAR(50), rate FLOAT);", "reference_sql": "SELECT AVG(rate) FROM recycling_rates;", "generated_sql": "SELECT AVG(rate) AS average_recycling_rate FROM recycling_rates;", "raw_model_output": "```sql\nSELECT AVG(rate) AS average_recycling_rate FROM recycling_rates;\n```", "latency_sec": 0.7568910121917725, "total_duration_sec": 0.440393305, "load_duration_sec": 0.020556671, "tokens_prompt": 101, "prompt_eval_sec": 0.019059575, "tokens_completion": 18, "completion_eval_sec": 0.397933508, "tokens_total": 119, "tokens_per_sec": 157.22210738822875, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average of the 'rate' column. The generated query adds an alias ('average_recycling_rate') to the result, but this does not affect the computed value. The semantic result (the average value) remains the same.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the average recycling rate using AVG(rate). The reference query returns the result without a column alias, while the generated query adds an explicit alias ('average_recycling_rate'). This makes the generated query more semantically descriptive, improving readability and clarity for end-users. The technical equivalence holds because the alias does not alter the computation or result. The business intent is fully met by both, but the generated query better addresses real-world reporting needs by providing a meaningful column name.", "overall_assessment": "correct"}}
{"example_id": 1533, "sql_complexity": "subqueries", "prompt": "Which programs had the highest volunteer participation rate in the last quarter?", "context": "CREATE TABLE Programs (ProgramID INT, ProgramName TEXT, Budget DECIMAL(10,2), NumVolunteers INT); CREATE TABLE VolunteerEvents (EventID INT, ProgramID INT, EventDate DATE, NumVolunteers INT);", "reference_sql": "SELECT p.ProgramName, COUNT(v.EventID) / (SELECT COUNT(*) FROM VolunteerEvents WHERE EventDate >= DATEADD(quarter, -1, GETDATE())) * 100.0 AS VolunteerParticipationRate FROM Programs p INNER JOIN VolunteerEvents v ON p.ProgramID = v.ProgramID WHERE v.EventDate >= DATEADD(quarter, -1, GETDATE()) GROUP BY p.ProgramName ORDER BY VolunteerParticipationRate DESC;", "generated_sql": "WITH LastQuarterVolunteers AS (\n    SELECT \n        ve.ProgramID,\n        SUM(ve.NumVolunteers) AS TotalVolunteers\n    FROM \n        VolunteerEvents ve\n    WHERE \n        ve.EventDate >= DATE_TRUNC('quarter', CURRENT_DATE) - INTERVAL '3 months'\n        AND ve.EventDate < DATE_TRUNC('quarter', CURRENT_DATE)\n    GROUP BY \n        ve.ProgramID\n),\nProgramParticipationRate AS (\n    SELECT \n        p.ProgramID,\n        p.ProgramName,\n        (lqv.TotalVolunteers / p.Budget) * 100 AS ParticipationRate\n    FROM \n        Programs p\n    JOIN \n        LastQuarterVolunteers lqv ON p.ProgramID = lqv.ProgramID\n)\nSELECT \n    ProgramID,\n    ProgramName,\n    ParticipationRate\nFROM \n    ProgramParticipationRate\nORDER BY \n    ParticipationRate DESC;", "raw_model_output": "To determine which programs had the highest volunteer participation rate in the last quarter, we need to calculate the total number of volunteers for each program during that period and then compare it to the budgeted number of volunteers. Here's how you can write the SQL query:\n\n```sql\nWITH LastQuarterVolunteers AS (\n    SELECT \n        ve.ProgramID,\n        SUM(ve.NumVolunteers) AS TotalVolunteers\n    FROM \n        VolunteerEvents ve\n    WHERE \n        ve.EventDate >= DATE_TRUNC('quarter', CURRENT_DATE) - INTERVAL '3 months'\n        AND ve.EventDate < DATE_TRUNC('quarter', CURRENT_DATE)\n    GROUP BY \n        ve.ProgramID\n),\nProgramParticipationRate AS (\n    SELECT \n        p.ProgramID,\n        p.ProgramName,\n        (lqv.TotalVolunteers / p.Budget) * 100 AS ParticipationRate\n    FROM \n        Programs p\n    JOIN \n        LastQuarterVolunteers lqv ON p.ProgramID = lqv.ProgramID\n)\nSELECT \n    ProgramID,\n    ProgramName,\n    ParticipationRate\nFROM \n    ProgramParticipationRate\nORDER BY \n    ParticipationRate DESC;\n```\n\n### Explanation:\n1. **LastQuarterVolunteers CTE**: This common table expression (CTE) calculates the total number of volunteers for each program in the last quarter.\n   - `DATE_TRUNC('quarter', CURRENT_DATE) - INTERVAL '3 months'` gives the start date of the last quarter.\n   - `DATE_TRUNC('quarter', CURRENT_DATE)` gives the start date of the current quarter, effectively setting the end date of the last quarter.\n\n2. **ProgramParticipationRate CTE**: This CTE calculates the participation rate for each program by dividing the total number of volunteers in the last quarter by the budgeted number of volunteers and multiplying by 100 to get a percentage.\n\n3. **Final SELECT Statement**: This selects the program ID, name, and participation rate from the `ProgramParticipationRate` CTE and orders the results by participation rate in descending order to show the programs with the highest rates first.", "latency_sec": 10.079295873641968, "total_duration_sec": 9.784406067, "load_duration_sec": 0.013852285, "tokens_prompt": 137, "prompt_eval_sec": 0.027268185, "tokens_completion": 428, "completion_eval_sec": 9.741101076, "tokens_total": 565, "tokens_per_sec": 56.05550299178267, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries calculate different metrics. The reference query computes the percentage of events in the last quarter relative to total events, while the generated query calculates volunteer hours divided by budget. Additionally, the reference groups by ProgramName and uses EventID counting, whereas the generated query groups by ProgramID and sums NumVolunteers. Output columns and aggregation logic differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "equal", "explanation": "The queries are not technically equivalent due to fundamental differences in calculation logic and date filtering. The reference query calculates participation rate as (program event count / total events in last quarter) * 100, while the generated query uses (total volunteers / program budget) * 100. Neither accurately reflects 'volunteer participation rate' as the question implies. The reference query incorrectly uses event counts instead of volunteer numbers, and the generated query uses budget as a denominator which is not mentioned in the question. Both have date filtering issues: the reference uses DATEADD(quarter, -1, GETDATE()) which may not capture full quarters, while the generated query correctly identifies the previous quarter using DATE_TRUNC. Neither query properly addresses the business intent of measuring volunteer participation rate.", "overall_assessment": "differently_correct"}}
{"example_id": 4021, "sql_complexity": "subqueries", "prompt": "What is the percentage of energy efficiency improvement, per sector, compared to 2015 levels?", "context": "CREATE TABLE energy_efficiency (id INT, sector VARCHAR(50), year INT, efficiency FLOAT); INSERT INTO energy_efficiency (id, sector, year, efficiency) VALUES (1, 'Industry', 2015, 100.0), (2, 'Industry', 2020, 105.0), (3, 'Residential', 2015, 100.0), (4, 'Residential', 2020, 103.0);", "reference_sql": "SELECT sector, (SUM(efficiency) / (SELECT SUM(efficiency) FROM energy_efficiency WHERE year = 2015 AND sector = e.sector) * 100.0) - 100.0 AS improvement FROM energy_efficiency e WHERE year = 2020 GROUP BY sector;", "generated_sql": "SELECT \n    sector,\n    ((MAX(efficiency) - MIN(efficiency)) / MIN(efficiency)) * 100 AS improvement_percentage\nFROM \n    energy_efficiency\nWHERE \n    year IN (2015, 2020)\nGROUP BY \n    sector;", "raw_model_output": "```sql\nSELECT \n    sector,\n    ((MAX(efficiency) - MIN(efficiency)) / MIN(efficiency)) * 100 AS improvement_percentage\nFROM \n    energy_efficiency\nWHERE \n    year IN (2015, 2020)\nGROUP BY \n    sector;\n```", "latency_sec": 1.7679028511047363, "total_duration_sec": 1.616499458, "load_duration_sec": 0.014530921, "tokens_prompt": 211, "prompt_eval_sec": 0.044354049, "tokens_completion": 68, "completion_eval_sec": 1.555432079, "tokens_total": 279, "tokens_per_sec": 157.81410150770276, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL calculates percentage improvement based on summed efficiency values for each sector between 2015 and 2020, while the Generated SQL computes percentage change using max and min efficiency values for the same years. The formulas differ: the first uses relative sums, the second uses relative extremes. For example, if a sector had multiple entries in a year, their sums would differ from max/min values, leading to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query calculates improvement using SUM(efficiency) / (subquery SUM) * 100 - 100, which assumes efficiency is additive (incorrect for rates). The generated query uses (MAX(efficiency) - MIN(efficiency)) / MIN(efficiency) * 100, which correctly calculates percentage change between 2020 and 2015 values. While both return the same results for the given dataset (single entry per sector/year), the generated query better fulfills the business intent by directly comparing 2020 to 2015 values. The reference query would fail if multiple entries exist per year/sector. The generated query is more elegant and semantically accurate.", "overall_assessment": "differently_correct"}}
{"example_id": 1551, "sql_complexity": "single join", "prompt": "How many unique donors made donations in the healthcare industry in Q3 2022?", "context": "CREATE TABLE donations (id INT, donor_id INT, amount FLOAT, donation_date DATE); INSERT INTO donations (id, donor_id, amount, donation_date) VALUES (1, 7, 100, '2022-07-01'); INSERT INTO donations (id, donor_id, amount, donation_date) VALUES (2, 8, 200, '2022-09-15'); INSERT INTO donors (id, name, industry, first_donation_date DATE) VALUES (7, 'Charlie Davis', 'Healthcare', '2022-07-01'); INSERT INTO donors (id, name, industry, first_donation_date DATE) VALUES (8, 'Dana Wilson', 'Healthcare', '2022-09-15');", "reference_sql": "SELECT COUNT(DISTINCT donor_id) FROM donations d JOIN donors don ON d.donor_id = don.id WHERE industry = 'Healthcare' AND donation_date BETWEEN '2022-07-01' AND '2022-09-30';", "generated_sql": "SELECT COUNT(DISTINCT d.id) AS unique_donors_count\nFROM donations don\nJOIN donors d ON don.donor_id = d.id\nWHERE d.industry = 'Healthcare'\nAND EXTRACT(QUARTER FROM don.donation_date) = 3\nAND YEAR(don.donation_date) = 2022;", "raw_model_output": "```sql\nSELECT COUNT(DISTINCT d.id) AS unique_donors_count\nFROM donations don\nJOIN donors d ON don.donor_id = d.id\nWHERE d.industry = 'Healthcare'\nAND EXTRACT(QUARTER FROM don.donation_date) = 3\nAND YEAR(don.donation_date) = 2022;\n```", "latency_sec": 2.0443880558013916, "total_duration_sec": 1.843388087, "load_duration_sec": 0.014589037, "tokens_prompt": 270, "prompt_eval_sec": 0.06056494, "tokens_completion": 76, "completion_eval_sec": 1.765047694, "tokens_total": 346, "tokens_per_sec": 169.24379841593696, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count distinct donor IDs where the donor's industry is 'Healthcare' and the donation date falls in Q3 2022. The Reference SQL uses BETWEEN '2022-07-01' AND '2022-09-30' (July-September 2022), while the Generated SQL uses EXTRACT(QUARTER) = 3 and YEAR = 2022, which also corresponds to Q3 2022. The join conditions and count columns (donor_id vs d.id) are equivalent due to the join on d.id = don.donor_id. Both queries produce the same result for the given schema and sample data.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries correctly count unique healthcare donors in Q3 2022. The reference uses a simple date range (BETWEEN) which is more efficient for index usage compared to the generated query's EXTRACT and YEAR functions. The generated query counts donations.id instead of donor_id, but since the join ensures d.id = donor_id, the result remains equivalent. The reference's syntax is more concise and avoids redundant date filtering (YEAR + EXTRACT) that the reference handles with a single range condition.", "overall_assessment": "correct"}}
{"example_id": 2592, "sql_complexity": "window functions", "prompt": "What is the third highest account balance for Shariah-compliant finance customers?", "context": "CREATE TABLE shariah_compliant_finance(customer_id INT, account_balance DECIMAL(10, 2)); INSERT INTO shariah_compliant_finance VALUES (1, 5000), (2, 7000), (3, 6000), (4, 8000), (5, 9000);", "reference_sql": "SELECT account_balance FROM (SELECT account_balance, RANK() OVER (ORDER BY account_balance DESC) as rn FROM shariah_compliant_finance) t WHERE rn = 3;", "generated_sql": "SELECT account_balance \nFROM shariah_compliant_finance \nORDER BY account_balance DESC \nLIMIT 2, 1;", "raw_model_output": "```sql\nSELECT account_balance \nFROM shariah_compliant_finance \nORDER BY account_balance DESC \nLIMIT 2, 1;\n```", "latency_sec": 1.0418670177459717, "total_duration_sec": 0.755875594, "load_duration_sec": 0.014189754, "tokens_prompt": 170, "prompt_eval_sec": 0.033732833, "tokens_completion": 31, "completion_eval_sec": 0.705669354, "tokens_total": 201, "tokens_per_sec": 192.92289378240773, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the third highest account balance. The reference query uses RANK() to identify the third-ranked value, while the generated query uses LIMIT 2,1 to skip the first two rows after descending ordering. With unique values in the dataset, both approaches yield the same result (7000).", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly retrieve the third highest account balance (7000) from the sample data. The Reference SQL uses RANK() with a subquery, which is semantically correct but less efficient due to the subquery and window function. The Generated SQL uses a simpler ORDER BY + LIMIT approach, which is more efficient and directly achieves the goal. While RANK() handles ties differently (e.g., would return 7000 in this case), the question's context has no ties, making both technically equivalent. However, the Generated SQL is more elegant and efficient for this specific use case.", "overall_assessment": "correct"}}
{"example_id": 3795, "sql_complexity": "single join", "prompt": "What is the total quantity of unsold garments for each manufacturer based in 'Italy' or 'Spain'?", "context": "CREATE TABLE manufacturers (id INT PRIMARY KEY, name VARCHAR(255), country VARCHAR(255)); CREATE TABLE garments (id INT PRIMARY KEY, manufacturer_id INT, quantity_manufactured INT, quantity_sold INT);", "reference_sql": "SELECT m.name, SUM(g.quantity_manufactured - g.quantity_sold) as total_unsold_quantity FROM manufacturers m JOIN garments g ON m.id = g.manufacturer_id WHERE m.country IN ('Italy', 'Spain') GROUP BY m.name;", "generated_sql": "SELECT \n    m.name AS manufacturer_name,\n    SUM(g.quantity_manufactured - g.quantity_sold) AS total_unsold_quantity\nFROM \n    manufacturers m\nJOIN \n    garments g ON m.id = g.manufacturer_id\nWHERE \n    m.country IN ('Italy', 'Spain')\nGROUP BY \n    m.name;", "raw_model_output": "```sql\nSELECT \n    m.name AS manufacturer_name,\n    SUM(g.quantity_manufactured - g.quantity_sold) AS total_unsold_quantity\nFROM \n    manufacturers m\nJOIN \n    garments g ON m.id = g.manufacturer_id\nWHERE \n    m.country IN ('Italy', 'Spain')\nGROUP BY \n    m.name;\n```", "latency_sec": 1.7581727504730225, "total_duration_sec": 1.637754075, "load_duration_sec": 0.014085145, "tokens_prompt": 144, "prompt_eval_sec": 0.027453495, "tokens_completion": 71, "completion_eval_sec": 1.593961589, "tokens_total": 215, "tokens_per_sec": 122.28604950347226, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. Both perform the same operations: joining manufacturers with garments, filtering by country ('Italy'/'Spain'), grouping by manufacturer name, and calculating total unsold quantity. The only differences are whitespace formatting and column alias naming (reference uses 'name', generated uses 'manufacturer_name'), which do not affect the result set.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are structurally identical in logic, syntax, and result set structure. The only difference is the column alias name ('total_unsold_quantity' vs. 'total_unsold_quantity') and the manufacturer name alias ('name' vs. 'manufacturer_name'). These are purely stylistic variations that do not affect the computational logic or output. Both correctly calculate unsold quantities by subtracting sold from manufactured counts, filter manufacturers from Italy/Spain, and group by manufacturer. The business intent is fully addressed in both cases.", "overall_assessment": "correct"}}
{"example_id": 4138, "sql_complexity": "window functions", "prompt": "How many lifelong learning courses has a student with ID '2' completed, in chronological order?", "context": "CREATE TABLE lifelong_learning (student_id INT, course_id INT, completion_date DATE); INSERT INTO lifelong_learning VALUES (2, 1001, '2015-01-01'), (2, 1002, '2016-01-01');", "reference_sql": "SELECT student_id, course_id, COUNT(course_id) OVER (PARTITION BY student_id ORDER BY completion_date) as completed_courses FROM lifelong_learning WHERE student_id = 2;", "generated_sql": "SELECT COUNT(*) AS course_count\nFROM lifelong_learning\nWHERE student_id = 2\nORDER BY completion_date ASC;", "raw_model_output": "```sql\nSELECT COUNT(*) AS course_count\nFROM lifelong_learning\nWHERE student_id = 2\nORDER BY completion_date ASC;\n```", "latency_sec": 0.90506911277771, "total_duration_sec": 0.705268315, "load_duration_sec": 0.015827366, "tokens_prompt": 159, "prompt_eval_sec": 0.030340785, "tokens_completion": 29, "completion_eval_sec": 0.656873005, "tokens_total": 188, "tokens_per_sec": 207.71894360975045, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL returns multiple rows with a cumulative count per course for student_id=2, while the Generated SQL returns a single aggregated count of courses for student_id=2. The structure and output semantics differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL calculates a running count of courses per completion date for student 2, returning multiple rows with cumulative counts (e.g., 1, 2). The Generated SQL correctly counts total courses (2) for student 2. While both filter student_id = 2, the Reference SQL's window function produces a different result structure than the simple COUNT(*) in the Generated SQL. The original question asks for the total number of completed courses, not a running tally. The Generated SQL directly answers this with a single value, while the Reference SQL provides unnecessary per-row metadata. The ORDER BY in the Generated SQL is redundant for COUNT(*) but doesn't harm correctness. The Reference SQL fails to fulfill the business intent of reporting a total count.", "overall_assessment": "incorrect"}}
{"example_id": 312, "sql_complexity": "aggregation", "prompt": "List the top 3 most represented ethnicities in movies produced in the USA.", "context": "CREATE TABLE movies (title VARCHAR(255), production_country VARCHAR(64), lead_actor_ethnicity VARCHAR(64));", "reference_sql": "SELECT lead_actor_ethnicity, COUNT(*) AS count FROM movies WHERE production_country = 'USA' GROUP BY lead_actor_ethnicity ORDER BY count DESC LIMIT 3;", "generated_sql": "SELECT lead_actor_ethnicity, COUNT(*) AS ethnicity_count\nFROM movies\nWHERE production_country = 'USA'\nGROUP BY lead_actor_ethnicity\nORDER BY ethnicity_count DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT lead_actor_ethnicity, COUNT(*) AS ethnicity_count\nFROM movies\nWHERE production_country = 'USA'\nGROUP BY lead_actor_ethnicity\nORDER BY ethnicity_count DESC\nLIMIT 3;\n```", "latency_sec": 1.1133780479431152, "total_duration_sec": 1.065577343, "load_duration_sec": 0.01480256, "tokens_prompt": 120, "prompt_eval_sec": 0.022833256, "tokens_completion": 46, "completion_eval_sec": 1.02593865, "tokens_total": 166, "tokens_per_sec": 149.09580829860343, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. The only difference is the column alias name ('count' vs 'ethnicity_count'), which does not affect the result's content or structure. Both queries filter by production_country = 'USA', group by lead_actor_ethnicity, count rows, order by the count in descending order, and limit to 3 results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are structurally identical except for the column alias name ('count' vs 'ethnicity_count'). The logic correctly filters USA-produced movies, groups by lead actor ethnicity, counts occurrences, orders by descending count, and limits to 3 results. The alias difference does not affect result accuracy or business intent fulfillment. Both queries efficiently address the requirement to identify the top 3 most represented ethnicities.", "overall_assessment": "correct"}}
{"example_id": 4298, "sql_complexity": "single join", "prompt": "How many users joined the gym in Q1 2023?", "context": "CREATE TABLE memberships (id INT, user_id INT, join_date DATE); INSERT INTO memberships (id, user_id, join_date) VALUES (1, 5, '2023-01-15'), (2, 6, '2023-02-03'), (3, 7, '2023-03-20'), (4, 8, '2022-12-31');", "reference_sql": "SELECT COUNT(*) FROM memberships WHERE join_date BETWEEN '2023-01-01' AND '2023-03-31';", "generated_sql": "SELECT COUNT(*) AS q1_joined_users\nFROM memberships\nWHERE join_date BETWEEN '2023-01-01' AND '2023-03-31';", "raw_model_output": "```sql\nSELECT COUNT(*) AS q1_joined_users\nFROM memberships\nWHERE join_date BETWEEN '2023-01-01' AND '2023-03-31';\n```", "latency_sec": 1.4177379608154297, "total_duration_sec": 1.120794763, "load_duration_sec": 0.01383332, "tokens_prompt": 191, "prompt_eval_sec": 0.035756855, "tokens_completion": 47, "completion_eval_sec": 1.069091845, "tokens_total": 238, "tokens_per_sec": 167.87305311562042, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries count the number of memberships where join_date falls between '2023-01-01' and '2023-03-31'. The generated query adds an alias (q1_joined_users) to the COUNT(*) result, but this does not affect the semantic meaning or the actual count value produced.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count users who joined in Q1 2023 using the same WHERE clause with BETWEEN dates. The generated query adds an explicit alias (q1_joined_users) which improves readability and clarifies the column's purpose without altering functionality. The reference query is technically correct but less descriptive. Both address the business intent of counting Q1 2023 joiners.", "overall_assessment": "correct"}}
{"example_id": 5211, "sql_complexity": "multiple_joins", "prompt": "What is the average transaction value in the last week, split by product category and customer demographics?", "context": "CREATE TABLE transactions (transaction_id INT, customer_id INT, product_id INT, category_id INT, transaction_date DATE, amount DECIMAL(10,2)); CREATE TABLE customers (customer_id INT, age INT, gender VARCHAR(10), location VARCHAR(255)); CREATE TABLE products (product_id INT, name VARCHAR(255), category_id INT);", "reference_sql": "SELECT c.age, c.gender, p.category_id, AVG(t.amount) as avg_transaction_value FROM transactions t INNER JOIN customers c ON t.customer_id = c.customer_id INNER JOIN products p ON t.product_id = p.product_id WHERE t.transaction_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 WEEK) GROUP BY c.age, c.gender, p.category_id;", "generated_sql": "SELECT \n    p.category_id,\n    c.gender,\n    c.age,\n    AVG(t.amount) AS average_transaction_value\nFROM \n    transactions t\nJOIN \n    customers c ON t.customer_id = c.customer_id\nJOIN \n    products p ON t.product_id = p.product_id\nWHERE \n    t.transaction_date >= CURRENT_DATE - INTERVAL '7 days'\nGROUP BY \n    p.category_id, c.gender, c.age;", "raw_model_output": "```sql\nSELECT \n    p.category_id,\n    c.gender,\n    c.age,\n    AVG(t.amount) AS average_transaction_value\nFROM \n    transactions t\nJOIN \n    customers c ON t.customer_id = c.customer_id\nJOIN \n    products p ON t.product_id = p.product_id\nWHERE \n    t.transaction_date >= CURRENT_DATE - INTERVAL '7 days'\nGROUP BY \n    p.category_id, c.gender, c.age;\n```", "latency_sec": 2.3483388423919678, "total_duration_sec": 2.149998411, "load_duration_sec": 0.014992548, "tokens_prompt": 171, "prompt_eval_sec": 0.032762879, "tokens_completion": 93, "completion_eval_sec": 2.100036822, "tokens_total": 264, "tokens_per_sec": 112.41989240832692, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same data by joining the same tables with identical conditions. The date filter uses equivalent expressions (DATE_SUB(...) vs CURRENT_DATE - INTERVAL '7 days') to capture transactions from the last week. The SELECT list contains the same columns in different order, and the GROUP BY clause includes identical columns in different order. The aggregation logic (AVG(t.amount)) is equivalent, with only the alias name differing (avg_transaction_value vs average_transaction_value).", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the average transaction value for the last week, grouped by product category (category_id) and customer demographics (age, gender). The technical differences are minor: the reference uses MySQL's DATE_SUB function while the generated query uses PostgreSQL-style INTERVAL syntax (CURRENT_DATE - INTERVAL '7 days'). These date calculations are functionally equivalent. The GROUP BY and SELECT clauses are identical in semantic structure, though ordered differently. Both queries omit customer location (a potential demographic factor) but align with the explicit question's focus on age and gender. Neither query has performance issues, and both are syntactically valid. The superiority is equal as both meet requirements equally well.", "overall_assessment": "correct"}}
{"example_id": 382, "sql_complexity": "window functions", "prompt": "What is the average annual precipitation in the past 10 years for each weather station?", "context": "CREATE TABLE WeatherStation (ID INT, Name VARCHAR(100), Location VARCHAR(100), Elevation FLOAT, AnnualPrecipitation FLOAT); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (1, 'Station A', 'Arctic Circle', 100, 450); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (2, 'Station B', 'North Pole', 200, 300);", "reference_sql": "SELECT Name, AVG(AnnualPrecipitation) OVER (PARTITION BY Name ORDER BY Name ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS AvgAnnualPrecipitation FROM WeatherStation WHERE YEAR(CurrentDate) - YEAR(DateInstalled) BETWEEN 1 AND 10;", "generated_sql": "SELECT Name, AVG(AnnualPrecipitation) AS AverageAnnualPrecipitation\nFROM WeatherStation\nGROUP BY Name;", "raw_model_output": "```sql\nSELECT Name, AVG(AnnualPrecipitation) AS AverageAnnualPrecipitation\nFROM WeatherStation\nGROUP BY Name;\n```", "latency_sec": 0.8495349884033203, "total_duration_sec": 0.756644764, "load_duration_sec": 0.014233359, "tokens_prompt": 209, "prompt_eval_sec": 0.044817999, "tokens_completion": 30, "completion_eval_sec": 0.695333929, "tokens_total": 239, "tokens_per_sec": 281.33037869245913, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL contains a WHERE clause referencing a non-existent 'DateInstalled' column, making it invalid. The Generated SQL lacks this filter and uses GROUP BY instead of a window function. Even if the WHERE clause were valid, the window function in Reference SQL would return the same value as the AnnualPrecipitation for each row (due to partitioning by unique Name), while the GROUP BY in Generated SQL would aggregate values. However, the invalid column in Reference SQL makes the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference SQL contains critical errors: it references a non-existent 'DateInstalled' column and uses a window function incorrectly for this purpose. The generated SQL correctly groups by station name and calculates the average annual precipitation. However, neither query fully addresses the business intent because the schema lacks a 'Year' column to track multi-year data. The generated query is technically valid given the schema, while the reference query is invalid.", "overall_assessment": "incorrect"}}
{"example_id": 2190, "sql_complexity": "single join", "prompt": "What is the total number of humanitarian assistance events by each country in the last 3 years?", "context": "CREATE TABLE Humanitarian_Assistance (id INT, country VARCHAR(50), year INT, events INT); CREATE TABLE Countries (id INT, name VARCHAR(50), region VARCHAR(50));", "reference_sql": "SELECT co.name, SUM(ha.events) FROM Humanitarian_Assistance ha INNER JOIN Countries co ON ha.country = co.name WHERE ha.year BETWEEN (YEAR(CURRENT_DATE) - 3) AND YEAR(CURRENT_DATE) GROUP BY co.name;", "generated_sql": "SELECT \n    c.name AS country,\n    SUM(ha.events) AS total_events\nFROM \n    Humanitarian_Assistance ha\nJOIN \n    Countries c ON ha.country = c.name\nWHERE \n    ha.year >= YEAR(CURRENT_DATE) - 3\nGROUP BY \n    c.name;", "raw_model_output": "```sql\nSELECT \n    c.name AS country,\n    SUM(ha.events) AS total_events\nFROM \n    Humanitarian_Assistance ha\nJOIN \n    Countries c ON ha.country = c.name\nWHERE \n    ha.year >= YEAR(CURRENT_DATE) - 3\nGROUP BY \n    c.name;\n```", "latency_sec": 1.7079033851623535, "total_duration_sec": 1.526267895, "load_duration_sec": 0.019481089, "tokens_prompt": 136, "prompt_eval_sec": 0.026180669, "tokens_completion": 66, "completion_eval_sec": 1.478196318, "tokens_total": 202, "tokens_per_sec": 118.27366919868119, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query uses BETWEEN (YEAR(CURRENT_DATE) - 3) AND YEAR(CURRENT_DATE), which includes years from Y-3 to Y (inclusive). The generated query uses ha.year >= YEAR(CURRENT_DATE) - 3, which includes all years from Y-3 onward without an upper bound. This means the generated query could include years beyond the current year (if present in the data), making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent. They join the same tables on 'country' = 'name', filter records where 'year' is within the last 3 years (using equivalent logic: BETWEEN vs. >=), and aggregate events by country. The reference query uses `BETWEEN (YEAR(CURRENT_DATE) - 3) AND YEAR(CURRENT_DATE)` which includes 4 years (e.g., 2020-2023 for 2023), while the generated query uses `>= YEAR(CURRENT_DATE) - 3` which achieves the same result. Both correctly address the business intent of summarizing humanitarian events by country for the past 3 years. Neither query perfectly aligns with the literal interpretation of 'last 3 years' (which might exclude the current year), but both follow the same logical approach. The generated query is slightly more concise but offers no significant efficiency advantage.", "overall_assessment": "correct"}}
{"example_id": 1852, "sql_complexity": "set operations", "prompt": "Compare coal production and employment rates in China and India between 2018 and 2020.", "context": "CREATE TABLE china_coal_production (year INT, production FLOAT); INSERT INTO china_coal_production (year, production) VALUES (2018, 3500.0), (2019, 3600.0), (2020, 3700.0); CREATE TABLE china_employment (year INT, employment FLOAT); INSERT INTO china_employment (year, employment) VALUES (2018, 8000000.0), (2019, 8100000.0), (2020, 8200000.0); CREATE TABLE india_coal_production (year INT, production FLOAT); INSERT INTO india_coal_production (year, production) VALUES (2018, 700.0), (2019, 750.0), (2020, 800.0); CREATE TABLE india_employment (year INT, employment FLOAT); INSERT INTO india_employment (year, employment) VALUES (2018, 1000000.0), (2019, 1050000.0), (2020, 1100000.0);", "reference_sql": "SELECT 'China' AS country, china_coal_production.production, china_employment.employment FROM china_coal_production INNER JOIN china_employment ON china_coal_production.year = china_employment.year WHERE china_coal_production.year BETWEEN 2018 AND 2020 UNION ALL SELECT 'India', india_coal_production.production, india_employment.employment FROM india_coal_production INNER JOIN india_employment ON india_coal_production.year = india_employment.year WHERE india_coal_production.year BETWEEN 2018 AND 2020;", "generated_sql": "SELECT \n    c.year,\n    c.production AS china_production,\n    i.production AS india_production,\n    e_china.employment AS china_employment,\n    e_india.employment AS india_employment\nFROM \n    china_coal_production c\nJOIN \n    india_coal_production i ON c.year = i.year\nJOIN \n    china_employment e_china ON c.year = e_china.year\nJOIN \n    india_employment e_india ON c.year = e_india.year\nWHERE \n    c.year BETWEEN 2018 AND 2020;", "raw_model_output": "```sql\nSELECT \n    c.year,\n    c.production AS china_production,\n    i.production AS india_production,\n    e_china.employment AS china_employment,\n    e_india.employment AS india_employment\nFROM \n    china_coal_production c\nJOIN \n    india_coal_production i ON c.year = i.year\nJOIN \n    china_employment e_china ON c.year = e_china.year\nJOIN \n    india_employment e_india ON c.year = e_india.year\nWHERE \n    c.year BETWEEN 2018 AND 2020;\n```", "latency_sec": 3.244147777557373, "total_duration_sec": 3.044424378, "load_duration_sec": 0.021283397, "tokens_prompt": 378, "prompt_eval_sec": 0.084251904, "tokens_completion": 125, "completion_eval_sec": 2.93665412, "tokens_total": 503, "tokens_per_sec": 155.04842395888804, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two rows per year (China and India) with columns (country, production, employment), while the Generated SQL returns one row per year with columns (year, china_production, india_production, china_employment, india_employment). The structure and number of rows differ, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because they produce different result structures. The Reference SQL returns two rows per year (China and India separately), while the Generated SQL returns one row per year with all data side-by-side. Both fulfill the business intent of comparing coal production and employment rates, but the Generated SQL is more efficient (single query vs. UNION ALL) and provides a more direct comparison structure. The Generated SQL's horizontal layout makes it easier to compare metrics across countries for the same year, which better aligns with the original question's requirements.", "overall_assessment": "differently_correct"}}
{"example_id": 2535, "sql_complexity": "subqueries", "prompt": "What is the maximum safety rating for vehicles in the vehiclesafety schema?", "context": "CREATE TABLE VehicleSafety (id INT, vehicle_id INT, safetyrating INT, PRIMARY KEY (id)); CREATE TABLE Vehicles (id INT, make VARCHAR(50), model VARCHAR(50), PRIMARY KEY (id)); CREATE TABLE LuxuryVehicles (id INT, vehicle_id INT, PRIMARY KEY (id), FOREIGN KEY (vehicle_id) REFERENCES Vehicles(id));", "reference_sql": "SELECT MAX(safetyrating) FROM vehicleSafety JOIN Vehicles ON vehicleSafety.vehicle_id = Vehicles.id WHERE EXISTS (SELECT * FROM LuxuryVehicles WHERE Vehicles.id = LuxuryVehicles.vehicle_id);", "generated_sql": "SELECT MAX(safetyrating) AS max_safety_rating\nFROM VehicleSafety;", "raw_model_output": "```sql\nSELECT MAX(safetyrating) AS max_safety_rating\nFROM VehicleSafety;\n```", "latency_sec": 0.6414120197296143, "total_duration_sec": 0.5234727, "load_duration_sec": 0.0138143, "tokens_prompt": 163, "prompt_eval_sec": 0.030598392, "tokens_completion": 21, "completion_eval_sec": 0.476958128, "tokens_total": 184, "tokens_per_sec": 286.86709063787856, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters results to only include vehicles present in LuxuryVehicles via the EXISTS clause, while the Generated SQL retrieves the maximum safetyrating from all VehicleSafety entries without any filtering. This means the Generated SQL could include non-luxury vehicles, leading to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query incorrectly filters results to only include luxury vehicles via the EXISTS clause, which was not part of the original question. The generated query directly retrieves the maximum safety rating from the VehicleSafety table as requested. While both queries are syntactically valid, the reference query introduces an unnecessary condition that changes the result set. The original question did not specify any requirement to filter by luxury vehicles, so the generated query better fulfills the business intent by returning the true maximum safety rating across all vehicles in the schema.", "overall_assessment": "correct"}}
{"example_id": 2140, "sql_complexity": "aggregation", "prompt": "What was the total amount of minerals extracted in the 'north' region for each month in 2020?", "context": "CREATE TABLE extraction(id INT, location TEXT, month INT, year INT, minerals_extracted FLOAT);INSERT INTO extraction(id, location, month, year, minerals_extracted) VALUES (1, 'north', 1, 2020, 1500), (2, 'north', 2, 2020, 1800), (3, 'south', 1, 2020, 1200);", "reference_sql": "SELECT month, SUM(minerals_extracted) FROM extraction WHERE location = 'north' AND year = 2020 GROUP BY month;", "generated_sql": "SELECT month, SUM(minerals_extracted) AS total_minerals_extracted\nFROM extraction\nWHERE location = 'north' AND year = 2020\nGROUP BY month;", "raw_model_output": "```sql\nSELECT month, SUM(minerals_extracted) AS total_minerals_extracted\nFROM extraction\nWHERE location = 'north' AND year = 2020\nGROUP BY month;\n```", "latency_sec": 1.3506739139556885, "total_duration_sec": 1.047947455, "load_duration_sec": 0.014191125, "tokens_prompt": 199, "prompt_eval_sec": 0.044437145, "tokens_completion": 43, "completion_eval_sec": 0.987218904, "tokens_total": 242, "tokens_per_sec": 179.16981848806128, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same data by selecting 'month' and the sum of 'minerals_extracted' from the 'extraction' table where location is 'north' and year is 2020, then grouping by 'month'. The only difference is the column alias ('total_minerals_extracted' in the generated query), which does not affect the semantic result set.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically correct and produce identical results. The reference query omits the column alias, while the generated query explicitly names the aggregated column. The generated version improves readability by clarifying the purpose of the summed value, which better fulfills the business intent of reporting 'total minerals extracted' per month. The GROUP BY and WHERE clauses are correctly implemented in both, ensuring accurate aggregation for the 'north' region in 2020.", "overall_assessment": "correct"}}
{"example_id": 4779, "sql_complexity": "window functions", "prompt": "What is the average CO2 emission for the top 3 highest emitting countries since 2015?", "context": "CREATE TABLE emissions (country VARCHAR(50), year INT, co2_emission INT); INSERT INTO emissions (country, year, co2_emission) VALUES ('USA', 2015, 5373978000); INSERT INTO emissions (country, year, co2_emission) VALUES ('China', 2015, 10498600000); INSERT INTO emissions (country, year, co2_emission) VALUES ('India', 2015, 2633830000); INSERT INTO emissions (country, year, co2_emission) VALUES ('USA', 2016, 5518004000); INSERT INTO emissions (country, year, co2_emission) VALUES ('China', 2016, 10813000000); INSERT INTO emissions (country, year, co2_emission) VALUES ('India', 2016, 2799280000);", "reference_sql": "SELECT AVG(co2_emission) as avg_emission FROM (SELECT country, year, co2_emission, ROW_NUMBER() OVER (ORDER BY co2_emission DESC) as rn FROM emissions WHERE year >= 2015) t WHERE rn <= 3 GROUP BY country;", "generated_sql": "SELECT AVG(co2_emission) AS avg_co2_emission\nFROM (\n    SELECT country, SUM(co2_emission) AS total_emission\n    FROM emissions\n    WHERE year >= 2015\n    GROUP BY country\n    ORDER BY total_emission DESC\n    LIMIT 3\n) AS top_countries;", "raw_model_output": "```sql\nSELECT AVG(co2_emission) AS avg_co2_emission\nFROM (\n    SELECT country, SUM(co2_emission) AS total_emission\n    FROM emissions\n    WHERE year >= 2015\n    GROUP BY country\n    ORDER BY total_emission DESC\n    LIMIT 3\n) AS top_countries;\n```", "latency_sec": 2.0191009044647217, "total_duration_sec": 1.81924779, "load_duration_sec": 0.014466966, "tokens_prompt": 329, "prompt_eval_sec": 0.076729983, "tokens_completion": 73, "completion_eval_sec": 1.725515521, "tokens_total": 402, "tokens_per_sec": 199.0985191037657, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates the average of the top 3 individual CO2 emissions (per row) grouped by country, which may include multiple entries from the same country. The Generated SQL first aggregates emissions by country (summing all years >=2015), then takes the top 3 countries by total emission and averages their totals. The Reference SQL's grouping by country after row-numbering leads to different results compared to the Generated SQL's pre-aggregation approach.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL is technically flawed because it uses ROW_NUMBER() without partitioning by country, leading to incorrect ranking of countries. It also groups by country in the outer query, which would calculate averages per country rather than the average of the top 3 countries' emissions. The Generated SQL correctly aggregates emissions per country (summing all years since 2015), selects the top 3 by total emissions, and calculates their average. While both queries have ambiguity about whether to average annual emissions or total emissions, the Generated SQL better aligns with the business intent of identifying the top 3 countries by cumulative emissions and averaging their totals.", "overall_assessment": "differently_correct"}}
{"example_id": 1015, "sql_complexity": "subqueries", "prompt": "List the top 3 most expensive eco-friendly products in Europe and their suppliers.", "context": "CREATE TABLE Suppliers (supplierID INT, supplierName VARCHAR(50), country VARCHAR(50)); CREATE TABLE Products (productID INT, productName VARCHAR(50), price DECIMAL(10,2), ecoFriendly BOOLEAN, supplierID INT);", "reference_sql": "SELECT P.productName, P.price, S.supplierName FROM (SELECT * FROM Products WHERE ecoFriendly = TRUE ORDER BY price DESC LIMIT 3) P JOIN Suppliers S ON P.supplierID = S.supplierID;", "generated_sql": "SELECT p.productName, p.price, s.supplierName\nFROM Products p\nJOIN Suppliers s ON p.supplierID = s.supplierID\nWHERE p.ecoFriendly = TRUE AND s.country = 'Europe'\nORDER BY p.price DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT p.productName, p.price, s.supplierName\nFROM Products p\nJOIN Suppliers s ON p.supplierID = s.supplierID\nWHERE p.ecoFriendly = TRUE AND s.country = 'Europe'\nORDER BY p.price DESC\nLIMIT 3;\n```", "latency_sec": 1.5911600589752197, "total_duration_sec": 1.392376293, "load_duration_sec": 0.01395399, "tokens_prompt": 144, "prompt_eval_sec": 0.027817034, "tokens_completion": 60, "completion_eval_sec": 1.347660896, "tokens_total": 204, "tokens_per_sec": 128.2083463880971, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in filtering conditions. The Reference SQL only filters by ecoFriendly = TRUE, while the Generated SQL adds an additional condition WHERE s.country = 'Europe'. This extra filter in the Generated SQL will exclude suppliers not in Europe, producing different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries differ in critical aspects. The Reference SQL correctly identifies eco-friendly products and orders them by price but fails to filter suppliers based on Europe (missing WHERE s.country = 'Europe'). The Generated SQL correctly filters for European suppliers while maintaining the eco-friendly requirement. Both queries are technically valid but produce different results due to the missing geographic filter in the Reference. The Generated query better fulfills the business intent of restricting to European suppliers.", "overall_assessment": "differently_correct"}}
{"example_id": 3715, "sql_complexity": "aggregation", "prompt": "What is the average age of engines still in service for each engine type?", "context": "CREATE TABLE Engine (id INT, aircraft_id INT, engine_type VARCHAR(255), hours_since_last_service INT, manufacture_year INT); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (1, 1, 'GE90-115B', 500, 2000); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (2, 2, 'CFM56-5B', 1000, 1995); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (3, 1, 'GE90-115B', 700, 2002);", "reference_sql": "SELECT engine_type, AVG(YEAR(CURRENT_DATE) - manufacture_year) as avg_age FROM Engine GROUP BY engine_type;", "generated_sql": "SELECT \n    engine_type, \n    AVG(CURRENT_YEAR - manufacture_year) AS average_age\nFROM \n    Engine\nWHERE \n    hours_since_last_service > 0\nGROUP BY \n    engine_type;", "raw_model_output": "```sql\nSELECT \n    engine_type, \n    AVG(CURRENT_YEAR - manufacture_year) AS average_age\nFROM \n    Engine\nWHERE \n    hours_since_last_service > 0\nGROUP BY \n    engine_type;\n```\n\nNote: Replace `CURRENT_YEAR` with the actual current year in your SQL query or use a function like `EXTRACT(YEAR FROM CURRENT_DATE)` if your SQL dialect supports it.", "latency_sec": 2.1644721031188965, "total_duration_sec": 2.070548443, "load_duration_sec": 0.014174853, "tokens_prompt": 264, "prompt_eval_sec": 0.058522219, "tokens_completion": 86, "completion_eval_sec": 1.995602066, "tokens_total": 350, "tokens_per_sec": 161.70224577885176, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Generated SQL includes a WHERE clause filtering for 'hours_since_last_service > 0', while the Reference SQL does not. This means the Generated SQL excludes engines with zero hours since last service, potentially altering the average age calculation for engine types that have such entries. Additionally, 'CURRENT_YEAR' is not a standard SQL function, but assuming it represents the current year similarly to 'YEAR(CURRENT_DATE)', the core difference remains the filtering condition.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The Reference SQL uses `YEAR(CURRENT_DATE) - manufacture_year` which is valid syntax, while the Generated SQL incorrectly references `CURRENT_YEAR` (not a standard SQL function). The Generated SQL also includes a `WHERE hours_since_last_service > 0` filter, which better aligns with the business intent of excluding engines not in service. However, the syntax error in the Generated SQL makes it technically invalid. If the `CURRENT_YEAR` typo were corrected (e.g., to `YEAR(CURRENT_DATE)`), the Generated SQL would be more precise for the business question by filtering active engines.", "overall_assessment": "differently_correct"}}
{"example_id": 1957, "sql_complexity": "set operations", "prompt": "What is the average temperature recorded for the 'polar_bear' species in the 'Arctic_Animals' table compared to the 'penguin' species in the 'Antarctic_Animals' table?", "context": "CREATE TABLE Arctic_Animals (species TEXT, avg_temp FLOAT); CREATE TABLE Antarctic_Animals (species TEXT, avg_temp FLOAT);", "reference_sql": "SELECT AVG(Arctic_Animals.avg_temp) FROM Arctic_Animals WHERE Arctic_Animals.species = 'polar_bear' INTERSECT SELECT AVG(Antarctic_Animals.avg_temp) FROM Antarctic_Animals WHERE Antarctic_Animals.species = 'penguin'", "generated_sql": "SELECT \n    (SELECT avg_temp FROM Arctic_Animals WHERE species = 'polar_bear') AS polar_bear_avg_temp,\n    (SELECT avg_temp FROM Antarctic_Animals WHERE species = 'penguin') AS penguin_avg_temp;", "raw_model_output": "```sql\nSELECT \n    (SELECT avg_temp FROM Arctic_Animals WHERE species = 'polar_bear') AS polar_bear_avg_temp,\n    (SELECT avg_temp FROM Antarctic_Animals WHERE species = 'penguin') AS penguin_avg_temp;\n```", "latency_sec": 1.4345412254333496, "total_duration_sec": 1.253564756, "load_duration_sec": 0.013650108, "tokens_prompt": 145, "prompt_eval_sec": 0.027359493, "tokens_completion": 54, "completion_eval_sec": 1.210159975, "tokens_total": 199, "tokens_per_sec": 138.7203075602694, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses INTERSECT to find common average temperatures between polar bears and penguins, returning a single value if they match. The Generated SQL retrieves both averages as separate columns in a single row. The first query checks for equality between two aggregates, while the second simply returns two independent values. Their result structures and logic differ fundamentally.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL is technically flawed. It uses INTERSECT, which returns only common values between two queries, but the question requires comparing two separate averages. Additionally, it applies AVG() to a column already named 'avg_temp', implying pre-aggregated data, making the AVG() redundant. The Generated SQL correctly retrieves the pre-aggregated average temperatures for both species in separate columns, directly answering the comparison question. While both queries aim to compare averages, the Generated SQL is semantically and technically superior for this schema.", "overall_assessment": "differently_correct"}}
{"example_id": 1311, "sql_complexity": "basic SQL", "prompt": "What is the total number of veteran job applications in Texas in the last year?", "context": "CREATE TABLE veteran_jobs (id INT, state VARCHAR(50), application_date DATE); INSERT INTO veteran_jobs (id, state, application_date) VALUES (1, 'Texas', '2021-02-15'), (2, 'California', '2021-04-10'), (3, 'Texas', '2022-01-05');", "reference_sql": "SELECT COUNT(*) FROM veteran_jobs WHERE state = 'Texas' AND application_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR);", "generated_sql": "SELECT COUNT(*) AS total_applications\nFROM veteran_jobs\nWHERE state = 'Texas' AND application_date >= DATEADD(year, -1, GETDATE());", "raw_model_output": "```sql\nSELECT COUNT(*) AS total_applications\nFROM veteran_jobs\nWHERE state = 'Texas' AND application_date >= DATEADD(year, -1, GETDATE());\n```", "latency_sec": 0.9839847087860107, "total_duration_sec": 0.889592759, "load_duration_sec": 0.014937517, "tokens_prompt": 177, "prompt_eval_sec": 0.033139632, "tokens_completion": 37, "completion_eval_sec": 0.839462879, "tokens_total": 214, "tokens_per_sec": 217.48305445114295, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count rows where state is 'Texas' and application_date is within the last year. DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR) (MySQL) and DATEADD(year, -1, GETDATE()) (SQL Server) both calculate the date exactly one year before the current date. The difference in function syntax between MySQL and SQL Server does not affect the semantic result. The alias 'total_applications' in the generated query does not impact the count outcome.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "equal", "explanation": "The queries are logically equivalent in purpose but differ technically due to dialect-specific functions. The reference uses MySQL's DATE_SUB and CURRENT_DATE, while the generated query uses SQL Server's DATEADD and GETDATE(). Both correctly count Texas applications within the last year, but their syntax is not portable across DBMS. The generated query adds an alias (total_applications), improving readability. Neither query is strictly superior without knowing the DBMS, but both fulfill the business intent of counting recent Texas veteran job applications.", "overall_assessment": "differently_correct"}}
{"example_id": 2997, "sql_complexity": "window functions", "prompt": "What is the earliest capture time for each satellite image in the 'satellite_images' table?", "context": "CREATE TABLE satellite_images (image_id INT, image_url TEXT, capture_time TIMESTAMP); INSERT INTO satellite_images (image_id, image_url, capture_time) VALUES (1, 'image1.jpg', '2022-01-01 10:00:00'), (2, 'image2.jpg', '2021-05-01 10:00:00');", "reference_sql": "SELECT image_id, MIN(capture_time) OVER (PARTITION BY image_id) FROM satellite_images;", "generated_sql": "SELECT MIN(capture_time) AS earliest_capture_time\nFROM satellite_images;", "raw_model_output": "```sql\nSELECT MIN(capture_time) AS earliest_capture_time\nFROM satellite_images;\n```", "latency_sec": 0.6794888973236084, "total_duration_sec": 0.51284753, "load_duration_sec": 0.015393126, "tokens_prompt": 185, "prompt_eval_sec": 0.035372892, "tokens_completion": 20, "completion_eval_sec": 0.460111647, "tokens_total": 205, "tokens_per_sec": 301.6973504754239, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns each image_id paired with its own capture_time (since MIN() over a partition of one row equals the value itself), resulting in two rows. The Generated SQL returns a single row with the earliest capture_time across all images. The output structure and results differ.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL uses a window function to return image_id and its own capture_time (since each image_id is unique), which technically satisfies 'earliest capture time for each satellite image' but is redundant. The Generated SQL returns a single global minimum value, which does not address the per-image requirement. The original question's intent appears to be misaligned with the schema (no satellite grouping column), but the Reference SQL better aligns with the literal 'per image' requirement despite redundancy.", "overall_assessment": "differently_correct"}}
{"example_id": 3743, "sql_complexity": "aggregation", "prompt": "What is the maximum budget spent on peacekeeping operations by each department?", "context": "CREATE TABLE DepartmentPeacekeeping (id INT, department VARCHAR(50), budget INT);", "reference_sql": "SELECT department, MAX(budget) FROM DepartmentPeacekeeping GROUP BY department;", "generated_sql": "SELECT department, MAX(budget) AS max_budget\nFROM DepartmentPeacekeeping\nGROUP BY department;", "raw_model_output": "```sql\nSELECT department, MAX(budget) AS max_budget\nFROM DepartmentPeacekeeping\nGROUP BY department;\n```", "latency_sec": 0.6341860294342041, "total_duration_sec": 0.591798789, "load_duration_sec": 0.014665368, "tokens_prompt": 108, "prompt_eval_sec": 0.0207066, "tokens_completion": 25, "completion_eval_sec": 0.554543935, "tokens_total": 133, "tokens_per_sec": 209.7176440778069, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries group by 'department' and select the maximum 'budget' for each group. The generated query adds an alias 'max_budget' for the MAX(budget) column, but this does not affect the semantic result set (the data returned). The core logic of grouping and aggregation remains identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the maximum budget per department using GROUP BY and MAX(). The generated query improves upon the reference by adding an explicit alias (max_budget) for the calculated column, which enhances readability and aligns with standard practices for result clarity. While the reference query is technically valid, the generated version provides a more polished output without altering the semantic meaning or efficiency.", "overall_assessment": "correct"}}
{"example_id": 4664, "sql_complexity": "multiple_joins", "prompt": "Calculate the total number of volunteer hours contributed by volunteers from 'California' in 'Health' projects in 2021.", "context": "CREATE TABLE volunteers (volunteer_id INT, name VARCHAR(255), state VARCHAR(255));", "reference_sql": "SELECT SUM(vh.hours) as total_hours FROM volunteer_projects vp JOIN volunteer_hours vh ON vp.project_id = vh.project_id JOIN volunteers vol ON vh.volunteer_id = vol.volunteer_id WHERE vp.cause = 'Health' AND vol.state = 'California' AND vh.volunteer_date BETWEEN '2021-01-01' AND '2021-12-31';", "generated_sql": "SELECT SUM(hours) AS total_volunteer_hours\nFROM volunteers v\nJOIN projects p ON v.volunteer_id = p.volunteer_id\nWHERE v.state = 'California'\nAND p.category = 'Health'\nAND YEAR(p.project_date) = 2021;", "raw_model_output": "```sql\nSELECT SUM(hours) AS total_volunteer_hours\nFROM volunteers v\nJOIN projects p ON v.volunteer_id = p.volunteer_id\nWHERE v.state = 'California'\nAND p.category = 'Health'\nAND YEAR(p.project_date) = 2021;\n```", "latency_sec": 1.6835482120513916, "total_duration_sec": 1.383174114, "load_duration_sec": 0.014604136, "tokens_prompt": 125, "prompt_eval_sec": 0.024253983, "tokens_completion": 60, "completion_eval_sec": 1.342204932, "tokens_total": 185, "tokens_per_sec": 109.8869629486754, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The reference query sums hours from the volunteer_hours table, joining through volunteer_projects (filtering by 'Health' cause) and volunteers (filtering by California state). The generated query sums 'hours' from a 'projects' table, joining directly with volunteers (filtering by 'Health' category) and using YEAR() on a project date. Key differences include: 1) Different tables being summed (volunteer_hours vs. projects), 2) Different join logic (volunteer_projects/volunteer_hours vs. direct volunteer-project join), 3) Different filtering columns (vp.cause vs. p.category), and 4) Potential data structure differences (e.g., project-level vs. volunteer-hour-level data).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in table structure and column semantics. The Reference SQL correctly joins volunteer_projects, volunteer_hours, and volunteers tables to sum hours from the dedicated volunteer_hours table, filtering by project cause, volunteer state, and date range. The Generated SQL incorrectly assumes a 'projects' table with a 'hours' column (not in the provided schema) and uses project_date instead of volunteer_date. It also lacks the necessary join to volunteer_hours. While both attempt to filter by Health projects and California volunteers, the Generated SQL's table structure and column assumptions make it technically incorrect given the context. The Reference better aligns with the business intent by directly accessing volunteer hours data.", "overall_assessment": "incorrect"}}
{"example_id": 251, "sql_complexity": "set operations", "prompt": "Compare the number of economic diversification projects in two regions, one in Europe and one in Oceania, by showing the project type and the number of projects in each region.", "context": "CREATE TABLE economic_diversification (region VARCHAR(50), project_type VARCHAR(50), project_start_date DATE);", "reference_sql": "SELECT 'Europe' as region, project_type, COUNT(*) as project_count FROM economic_diversification WHERE region = 'Europe' UNION ALL SELECT 'Oceania' as region, project_type, COUNT(*) as project_count FROM economic_diversification WHERE region = 'Oceania';", "generated_sql": "SELECT \n    region, \n    project_type, \n    COUNT(*) AS number_of_projects\nFROM \n    economic_diversification\nWHERE \n    region IN ('Europe', 'Oceania')\nGROUP BY \n    region, \n    project_type;", "raw_model_output": "```sql\nSELECT \n    region, \n    project_type, \n    COUNT(*) AS number_of_projects\nFROM \n    economic_diversification\nWHERE \n    region IN ('Europe', 'Oceania')\nGROUP BY \n    region, \n    project_type;\n```", "latency_sec": 1.49173903465271, "total_duration_sec": 1.307682043, "load_duration_sec": 0.013928201, "tokens_prompt": 137, "prompt_eval_sec": 0.025931094, "tokens_completion": 56, "completion_eval_sec": 1.265870309, "tokens_total": 193, "tokens_per_sec": 129.37919804782214, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries produce the same result by counting projects per region and project_type. The reference SQL uses two separate SELECTs with UNION ALL to explicitly set the region value, while the generated SQL filters and groups the data in a single query. The final output will have the same rows with identical counts, even though column names differ (project_count vs. number_of_projects). The data structure and values are equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL is technically incorrect because it lacks GROUP BY clauses in both subqueries, which would cause syntax errors in standard SQL. The Generated SQL correctly groups by region and project_type, ensuring accurate aggregation. Both queries fulfill the business intent by showing project types and counts per region, but the Generated query is more efficient, concise, and avoids redundant logic. The Reference's structure (two separate queries with UNION ALL) is less elegant and prone to errors, while the Generated query achieves the same result with a single, optimized query.", "overall_assessment": "incorrect"}}
{"example_id": 610, "sql_complexity": "subqueries", "prompt": "What is the percentage of community development projects completed in 'Caribbean' in 2020?", "context": "CREATE TABLE community_projects (project_id INT, project_name TEXT, location TEXT, completion_year INT); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (1, 'Community Center', 'Southern Region, Caribbean', 2020); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (2, 'Park Renovation', 'Northern Region, Caribbean', 2019); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (3, 'Library Construction', 'Caribbean', 2020);", "reference_sql": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM community_projects WHERE location = 'Caribbean')) FROM community_projects WHERE completion_year = 2020 AND location = 'Caribbean';", "generated_sql": "SELECT \n    (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM community_projects WHERE completion_year = 2020)) AS percentage_completed_in_caribbean\nFROM \n    community_projects\nWHERE \n    location LIKE '%Caribbean%' AND completion_year = 2020;", "raw_model_output": "```sql\nSELECT \n    (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM community_projects WHERE completion_year = 2020)) AS percentage_completed_in_caribbean\nFROM \n    community_projects\nWHERE \n    location LIKE '%Caribbean%' AND completion_year = 2020;\n```", "latency_sec": 1.8100781440734863, "total_duration_sec": 1.628617785, "load_duration_sec": 0.0163752, "tokens_prompt": 224, "prompt_eval_sec": 0.046328806, "tokens_completion": 68, "completion_eval_sec": 1.563206329, "tokens_total": 292, "tokens_per_sec": 161.31900214145963, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in both numerator and denominator calculations. The Reference SQL calculates (2020 Caribbean projects / total Caribbean projects) while the Generated SQL calculates (2020 Caribbean projects / total 2020 projects). Additionally, the location filter uses exact match ('Caribbean') vs. substring match ('%Caribbean%') which would include different sets of records.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is technically correct but semantically flawed. It calculates (Caribbean 2020 projects / total Caribbean projects), while the question likely intends (Caribbean 2020 projects / total 2020 projects). The Generated SQL correctly uses a LIKE pattern to capture all Caribbean-related locations ('Southern Region, Caribbean' and 'Caribbean') and computes the percentage relative to all 2020 projects. The Reference SQL's exact 'location = 'Caribbean'' filter misses projects with partial matches, and its denominator is misaligned with the question's intent. The Generated SQL better addresses the business requirement by using a more inclusive location filter and appropriate denominator.", "overall_assessment": "differently_correct"}}
{"example_id": 421, "sql_complexity": "set operations", "prompt": "What is the combined landfill capacity for 'City A' and 'City B'?", "context": "CREATE TABLE landfill_capacity (city VARCHAR(255), capacity INT); INSERT INTO landfill_capacity (city, capacity) VALUES ('City A', 500000), ('City B', 600000);", "reference_sql": "SELECT SUM(capacity) FROM (SELECT capacity FROM landfill_capacity WHERE city = 'City A' UNION ALL SELECT capacity FROM landfill_capacity WHERE city = 'City B') AS combined_capacity;", "generated_sql": "SELECT SUM(capacity) AS total_capacity \nFROM landfill_capacity \nWHERE city IN ('City A', 'City B');", "raw_model_output": "```sql\nSELECT SUM(capacity) AS total_capacity \nFROM landfill_capacity \nWHERE city IN ('City A', 'City B');\n```", "latency_sec": 0.7391440868377686, "total_duration_sec": 0.696329361, "load_duration_sec": 0.014060793, "tokens_prompt": 142, "prompt_eval_sec": 0.027098547, "tokens_completion": 29, "completion_eval_sec": 0.653109742, "tokens_total": 171, "tokens_per_sec": 231.34866806765382, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of capacities for 'City A' and 'City B'. The reference query uses a subquery with UNION ALL to combine the two cities' capacities before summing, while the generated query directly filters the cities using IN. Since SUM aggregates all matching rows regardless of grouping, both approaches yield the same result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the combined landfill capacity for 'City A' and 'City B'. The Reference SQL uses a subquery with UNION ALL to isolate the capacities before summing, while the Generated SQL directly sums the capacities where the city matches either 'City A' or 'City B'. Both produce identical results for the given schema and data. However, the Generated SQL is more efficient and elegant, as it avoids unnecessary subquery complexity and directly filters and aggregates in a single pass. The business intent of combining capacities is fulfilled equally by both, but the Generated SQL achieves this with simpler logic.", "overall_assessment": "correct"}}
{"example_id": 880, "sql_complexity": "aggregation", "prompt": "Show veteran employment statistics for each state in the 'veteran_employment' table", "context": "CREATE TABLE veteran_employment (employee_id INT, state VARCHAR(2), job_title VARCHAR(50), employment_date DATE);", "reference_sql": "SELECT state, COUNT(*) as veteran_employees FROM veteran_employment WHERE state IN ('CA', 'NY', 'TX', 'FL', 'PA') GROUP BY state;", "generated_sql": "SELECT \n    state, \n    COUNT(*) AS total_veterans,\n    AVG(DATEDIFF(CURDATE(), employment_date)) AS average_tenure_days\nFROM \n    veteran_employment\nGROUP BY \n    state;", "raw_model_output": "```sql\nSELECT \n    state, \n    COUNT(*) AS total_veterans,\n    AVG(DATEDIFF(CURDATE(), employment_date)) AS average_tenure_days\nFROM \n    veteran_employment\nGROUP BY \n    state;\n```", "latency_sec": 1.385167121887207, "total_duration_sec": 1.188397986, "load_duration_sec": 0.016040446, "tokens_prompt": 120, "prompt_eval_sec": 0.023729244, "tokens_completion": 51, "completion_eval_sec": 1.146635554, "tokens_total": 171, "tokens_per_sec": 123.45080770255561, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL filters results to specific states ('CA', 'NY', 'TX', 'FL', 'PA') and only counts employees, while the Generated SQL includes all states, adds an average tenure calculation, and uses a different column name ('total_veterans' vs 'veteran_employees').", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The Reference SQL filters for specific states ('CA', 'NY', 'TX', 'FL', 'PA') and only returns counts, while the Generated SQL includes all states and adds average tenure calculation. The original question asks for 'veteran employment statistics' without state restrictions, making the Generated SQL more comprehensive. Although the Reference is technically correct for its limited scope, the Generated SQL better fulfills the business intent by providing additional metrics (average tenure) and not arbitrarily restricting states. The Generated query is more elegant as it addresses potential implicit needs for deeper analysis.", "overall_assessment": "differently_correct"}}
{"example_id": 454, "sql_complexity": "single join", "prompt": "Which excavation sites have more than 10 artifacts?", "context": "CREATE TABLE ExcavationSite (SiteID INT, SiteName VARCHAR(50)); INSERT INTO ExcavationSite (SiteID, SiteName) VALUES (1, 'Site A'), (2, 'Site B'), (3, 'Site C'); CREATE TABLE Artifact (ArtifactID INT, SiteID INT, ObjectType VARCHAR(50)); INSERT INTO Artifact (ArtifactID, SiteID, ObjectType) VALUES (1, 1, 'Pottery'), (2, 1, 'Tool'), (3, 2, 'Statue'), (4, 2, 'Bead'), (5, 3, 'Bead'), (6, 3, 'Bead'), (7, 3, 'Bead'), (8, 3, 'Bead'), (9, 3, 'Bead'), (10, 3, 'Bead'), (11, 3, 'Bead');", "reference_sql": "SELECT e.SiteName FROM ExcavationSite e JOIN Artifact a ON e.SiteID = a.SiteID GROUP BY e.SiteName HAVING COUNT(a.ArtifactID) > 10;", "generated_sql": "SELECT SiteName \nFROM ExcavationSite \nWHERE SiteID IN (\n    SELECT SiteID \n    FROM Artifact \n    GROUP BY SiteID \n    HAVING COUNT(*) > 10\n);", "raw_model_output": "```sql\nSELECT SiteName \nFROM ExcavationSite \nWHERE SiteID IN (\n    SELECT SiteID \n    FROM Artifact \n    GROUP BY SiteID \n    HAVING COUNT(*) > 10\n);\n```", "latency_sec": 1.3194139003753662, "total_duration_sec": 1.159322189, "load_duration_sec": 0.014116939, "tokens_prompt": 282, "prompt_eval_sec": 0.058824722, "tokens_completion": 46, "completion_eval_sec": 1.083625412, "tokens_total": 328, "tokens_per_sec": 248.59522846218746, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL groups by SiteName, which could combine multiple sites with the same name, leading to incorrect artifact counts. The Generated SQL correctly groups by SiteID (via a subquery) to ensure accurate artifact counting per unique site. While both may return the same result for the given data (no sites with >10 artifacts), their logic differs in handling edge cases (e.g., duplicate SiteNames).", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify excavation sites with more than 10 artifacts. The reference query uses a JOIN and GROUP BY SiteName, which works in this context but could fail if multiple sites shared the same name (since GROUP BY SiteName would aggregate them). The generated query uses a subquery with GROUP BY SiteID (unique identifier) and IN, which is more robust and efficient. While both produce identical results in the given schema, the generated query is technically superior due to its use of primary keys and avoids potential grouping issues.", "overall_assessment": "correct"}}
{"example_id": 1086, "sql_complexity": "aggregation", "prompt": "What is the total CO2 emission for each equipment type, excluding equipment that is older than 8 years?", "context": "CREATE TABLE EmissionData (EquipmentID INT, EquipmentType VARCHAR(50), CO2Emission INT, Age INT); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (1, 'Excavator', 50, 8); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (2, 'Haul Truck', 70, 7); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (3, 'Shovel', 30, 6); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (4, 'Drilling Rig', 40, 3);", "reference_sql": "SELECT EquipmentType, SUM(CO2Emission) as TotalCO2Emission FROM EmissionData WHERE Age <= 8 GROUP BY EquipmentType;", "generated_sql": "SELECT EquipmentType, SUM(CO2Emission) AS TotalCO2Emission\nFROM EmissionData\nWHERE Age <= 8\nGROUP BY EquipmentType;", "raw_model_output": "```sql\nSELECT EquipmentType, SUM(CO2Emission) AS TotalCO2Emission\nFROM EmissionData\nWHERE Age <= 8\nGROUP BY EquipmentType;\n```", "latency_sec": 1.0009839534759521, "total_duration_sec": 0.993182312, "load_duration_sec": 0.014524622, "tokens_prompt": 263, "prompt_eval_sec": 0.057273194, "tokens_completion": 39, "completion_eval_sec": 0.919112092, "tokens_total": 302, "tokens_per_sec": 301.7031381485131, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select EquipmentType and sum CO2Emission with the same alias, filter where Age <= 8, and group by EquipmentType. The differences are purely stylistic (whitespace and keyword casing) and do not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure, logic, and output. They correctly filter equipment with Age <= 8 (excluding those older than 8 years) and calculate total CO2 emissions per EquipmentType. The WHERE clause aligns with the business requirement to exclude equipment older than 8 years, and the GROUP BY ensures aggregation by equipment type. Since the queries are identical, neither is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 3455, "sql_complexity": "basic SQL", "prompt": "What are the names of all innovation projects in the 'rural_infrastructure' table, excluding those with a budget over 50000?", "context": "CREATE TABLE rural_infrastructure (name VARCHAR(255), budget INT); INSERT INTO rural_infrastructure (name, budget) VALUES ('Dam Construction', 40000), ('Well Digging', 30000), ('Irrigation System', 70000);", "reference_sql": "SELECT name FROM rural_infrastructure WHERE budget <= 50000;", "generated_sql": "SELECT name \nFROM rural_infrastructure \nWHERE budget <= 50000;", "raw_model_output": "```sql\nSELECT name \nFROM rural_infrastructure \nWHERE budget <= 50000;\n```", "latency_sec": 0.6764750480651855, "total_duration_sec": 0.57491721, "load_duration_sec": 0.014662798, "tokens_prompt": 170, "prompt_eval_sec": 0.033277537, "tokens_completion": 23, "completion_eval_sec": 0.524414844, "tokens_total": 193, "tokens_per_sec": 285.30246688626187, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. The only difference is formatting (line breaks and indentation), which does not affect SQL execution. Both select the 'name' column from the rural_infrastructure table where budget is less than or equal to 50000.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are syntactically correct and semantically identical. They select project names from the rural_infrastructure table where the budget is less than or equal to 50000, perfectly matching the business requirement to exclude projects with budgets over 50000. The only difference is formatting (line breaks), which does not affect execution. Neither query is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 3936, "sql_complexity": "window functions", "prompt": "What is the total investment per client for each investment type?", "context": "CREATE TABLE clients (client_id INT, name TEXT, investment_type TEXT, investment FLOAT); INSERT INTO clients (client_id, name, investment_type, investment) VALUES (1, 'John Doe', 'Stocks', 3000.00), (1, 'John Doe', 'Bonds', 2000.00), (2, 'Jane Smith', 'Stocks', 5000.00);", "reference_sql": "SELECT client_id, name, investment_type, SUM(investment) OVER (PARTITION BY client_id, investment_type ORDER BY client_id) as total_investment FROM clients;", "generated_sql": "SELECT \n    client_id, \n    name, \n    investment_type, \n    SUM(investment) AS total_investment\nFROM \n    clients\nGROUP BY \n    client_id, \n    name, \n    investment_type;", "raw_model_output": "```sql\nSELECT \n    client_id, \n    name, \n    investment_type, \n    SUM(investment) AS total_investment\nFROM \n    clients\nGROUP BY \n    client_id, \n    name, \n    investment_type;\n```", "latency_sec": 1.4591999053955078, "total_duration_sec": 1.231045954, "load_duration_sec": 0.013936495, "tokens_prompt": 181, "prompt_eval_sec": 0.03572481, "tokens_completion": 52, "completion_eval_sec": 1.179221844, "tokens_total": 233, "tokens_per_sec": 159.6765454400483, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query uses a window function to calculate a running sum within partitions, retaining all rows and adding the sum as a new column. The generated query aggregates rows using GROUP BY, collapsing multiple rows into a single summary row per group. While they may produce similar values in this specific dataset (due to unique client_id/investment_type combinations), they differ fundamentally in structure and behavior. The window function preserves row-level details with aggregated values, whereas GROUP BY reduces the dataset to aggregated summaries.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query uses a window function that calculates a cumulative sum within partitions, but the ORDER BY clause is unnecessary and could produce misleading results. It would return multiple rows per client-investment_type combination with identical totals, whereas the generated query properly aggregates values using GROUP BY. The generated query directly answers the question by returning one row per client-investment_type pair with the correct total investment. The reference query's window function approach is less efficient and semantically mismatched to the requirement for aggregated totals.", "overall_assessment": "correct"}}
{"example_id": 1838, "sql_complexity": "window functions", "prompt": "What are the top 3 species with the most sightings across all arctic research stations?", "context": "CREATE TABLE research_station (id INT, name TEXT); INSERT INTO research_station (id, name) VALUES (1, 'Station A'); INSERT INTO research_station (id, name) VALUES (2, 'Station B'); CREATE TABLE species_observations (station_id INT, species_name TEXT, sightings INT); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (1, 'Species 1', 10); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (1, 'Species 2', 5); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (2, 'Species 1', 8); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (2, 'Species 3', 15);", "reference_sql": "SELECT species_name, SUM(sightings) as total_sightings, RANK() OVER (ORDER BY SUM(sightings) DESC) as rank FROM species_observations GROUP BY species_name HAVING rank <= 3;", "generated_sql": "SELECT species_name, SUM(sightings) AS total_sightings\nFROM species_observations\nGROUP BY species_name\nORDER BY total_sightings DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT species_name, SUM(sightings) AS total_sightings\nFROM species_observations\nGROUP BY species_name\nORDER BY total_sightings DESC\nLIMIT 3;\n```", "latency_sec": 1.1415660381317139, "total_duration_sec": 1.058820523, "load_duration_sec": 0.014090509, "tokens_prompt": 262, "prompt_eval_sec": 0.056722748, "tokens_completion": 42, "completion_eval_sec": 0.98593746, "tokens_total": 304, "tokens_per_sec": 266.3008444938728, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL contains a HAVING clause that references the alias 'rank' from the SELECT list, which is invalid in standard SQL because HAVING filters groups before the SELECT list is evaluated. The Generated SQL correctly uses ORDER BY and LIMIT to achieve the same result. The Reference SQL would likely produce an error, making the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL contains a critical technical error: the HAVING clause attempts to filter using 'rank', which is an alias from the SELECT clause. In SQL, aliases cannot be used in HAVING clauses. Additionally, RANK() over (ORDER BY SUM(sightings) DESC) is logically flawed because the window function would operate on unaggregated data before grouping. The Generated SQL correctly groups by species_name, sums sightings, orders by total_sightings in descending order, and limits to 3 results, directly answering the business question. While both queries aim for the same intent, the Generated SQL is technically correct and more efficient.", "overall_assessment": "correct"}}
{"example_id": 3091, "sql_complexity": "single join", "prompt": "Find the number of hybrid vehicles sold in the US, Germany, and Japan.", "context": "CREATE TABLE vehicle_sales (sale_id INT, vehicle_id INT, country VARCHAR(20), quantity INT); CREATE TABLE vehicles (vehicle_id INT, model VARCHAR(20), manufacture VARCHAR(20), vehicle_type VARCHAR(20));", "reference_sql": "SELECT SUM(vs.quantity) FROM vehicle_sales vs JOIN vehicles v ON vs.vehicle_id = v.vehicle_id WHERE v.vehicle_type = 'hybrid' AND vs.country IN ('US', 'Germany', 'Japan');", "generated_sql": "SELECT COUNT(*) AS total_hybrid_sales\nFROM vehicle_sales vs\nJOIN vehicles v ON vs.vehicle_id = v.vehicle_id\nWHERE vs.country IN ('US', 'Germany', 'Japan') AND v.vehicle_type = 'hybrid';", "raw_model_output": "```sql\nSELECT COUNT(*) AS total_hybrid_sales\nFROM vehicle_sales vs\nJOIN vehicles v ON vs.vehicle_id = v.vehicle_id\nWHERE vs.country IN ('US', 'Germany', 'Japan') AND v.vehicle_type = 'hybrid';\n```", "latency_sec": 1.5405521392822266, "total_duration_sec": 1.23716964, "load_duration_sec": 0.015434919, "tokens_prompt": 141, "prompt_eval_sec": 0.027267113, "tokens_completion": 53, "completion_eval_sec": 1.191560919, "tokens_total": 194, "tokens_per_sec": 125.92887644191543, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates the total quantity sold (SUM(vs.quantity)), while the generated query counts the number of sales records (COUNT(*)). These would produce different numerical results unless every sale record has a quantity of exactly 1.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries differ in their aggregation approach: the reference uses SUM(vs.quantity) while the generated uses COUNT(*). The original question asks for 'number of hybrid vehicles sold,' which typically refers to total units sold (SUM) rather than the count of sales records (COUNT). The reference query correctly aggregates quantities, while the generated query counts rows, potentially undercounting if multiple vehicles were sold per transaction. Both queries are syntactically correct and share the same logical structure, but they address different interpretations of 'number of vehicles sold.' The reference better aligns with standard business definitions of vehicle sales volume.", "overall_assessment": "correct"}}
{"example_id": 2399, "sql_complexity": "set operations", "prompt": "What is the average duration of criminal trials for Indigenous defendants compared to non-Indigenous defendants in Canada and New Zealand?", "context": "CREATE TABLE canada_criminal_trials (id INT, defendant_type VARCHAR(255), days_to_completion INT); INSERT INTO canada_criminal_trials (id, defendant_type, days_to_completion) VALUES (1, 'Indigenous', 60), (2, 'Non-Indigenous', 45);CREATE TABLE nz_criminal_trials (id INT, defendant_type VARCHAR(255), days_to_completion INT); INSERT INTO nz_criminal_trials (id, defendant_type, days_to_completion) VALUES (1, 'Indigenous', 70), (2, 'Non-Indigenous', 50);", "reference_sql": "SELECT AVG(days_to_completion) AS avg_duration FROM canada_criminal_trials WHERE defendant_type = 'Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM canada_criminal_trials WHERE defendant_type = 'Non-Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM nz_criminal_trials WHERE defendant_type = 'Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM nz_criminal_trials WHERE defendant_type = 'Non-Indigenous';", "generated_sql": "SELECT \n    defendant_type,\n    AVG(days_to_completion) AS avg_days_to_completion\nFROM (\n    SELECT defendant_type, days_to_completion FROM canada_criminal_trials\n    UNION ALL\n    SELECT defendant_type, days_to_completion FROM nz_criminal_trials\n) AS combined_trials\nGROUP BY defendant_type;", "raw_model_output": "```sql\nSELECT \n    defendant_type,\n    AVG(days_to_completion) AS avg_days_to_completion\nFROM (\n    SELECT defendant_type, days_to_completion FROM canada_criminal_trials\n    UNION ALL\n    SELECT defendant_type, days_to_completion FROM nz_criminal_trials\n) AS combined_trials\nGROUP BY defendant_type;\n```", "latency_sec": 1.7995631694793701, "total_duration_sec": 1.600800822, "load_duration_sec": 0.014015303, "tokens_prompt": 228, "prompt_eval_sec": 0.046122299, "tokens_completion": 67, "completion_eval_sec": 1.538438127, "tokens_total": 295, "tokens_per_sec": 163.92867169277872, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates separate averages for each defendant_type within each country (Canada and NZ), resulting in four rows. The Generated SQL combines data from both countries first, then averages by defendant_type across all data, resulting in two rows. The aggregation scope differs (country-specific vs. combined) leading to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly separates averages by country and defendant type, producing four distinct rows (Canada Indigenous, Canada Non-Indigenous, NZ Indigenous, NZ Non-Indigenous). The generated query combines data from both countries into a single dataset, resulting in only two rows (Indigenous and Non-Indigenous) with averages across both countries. This violates the original question's requirement to compare within each country. While both queries are technically correct, they produce fundamentally different results. The reference explicitly addresses the business intent of comparing Indigenous vs non-Indigenous trials separately in Canada and New Zealand, whereas the generated query conflates the datasets.", "overall_assessment": "differently_correct"}}
{"example_id": 2972, "sql_complexity": "set operations", "prompt": "How many indigenous communities are in the Arctic Research Station 13 and 14?", "context": "CREATE TABLE Arctic_Research_Station_13 (id INT, community TEXT); CREATE TABLE Arctic_Research_Station_14 (id INT, community TEXT);", "reference_sql": "SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_13; SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_14; SELECT COUNT(DISTINCT community) FROM (SELECT * FROM Arctic_Research_Station_13 UNION ALL SELECT * FROM Arctic_Research_Station_14) AS Arctic_Communities;", "generated_sql": "SELECT \n    SUM(CASE WHEN table_name = 'Arctic_Research_Station_13' THEN 1 ELSE 0 END) + \n    SUM(CASE WHEN table_name = 'Arctic_Research_Station_14' THEN 1 ELSE 0 END) AS total_indigenous_communities\nFROM (\n    SELECT 'Arctic_Research_Station_13' AS table_name, community FROM Arctic_Research_Station_13\n    UNION ALL\n    SELECT 'Arctic_Research_Station_14' AS table_name, community FROM Arctic_Research_Station_14\n) AS combined_communities;", "raw_model_output": "```sql\nSELECT \n    SUM(CASE WHEN table_name = 'Arctic_Research_Station_13' THEN 1 ELSE 0 END) + \n    SUM(CASE WHEN table_name = 'Arctic_Research_Station_14' THEN 1 ELSE 0 END) AS total_indigenous_communities\nFROM (\n    SELECT 'Arctic_Research_Station_13' AS table_name, community FROM Arctic_Research_Station_13\n    UNION ALL\n    SELECT 'Arctic_Research_Station_14' AS table_name, community FROM Arctic_Research_Station_14\n) AS combined_communities;\n```", "latency_sec": 3.172116994857788, "total_duration_sec": 3.135611785, "load_duration_sec": 0.015414284, "tokens_prompt": 128, "prompt_eval_sec": 0.024030872, "tokens_completion": 138, "completion_eval_sec": 3.094044882, "tokens_total": 266, "tokens_per_sec": 83.85567128551804, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL's third query counts distinct communities across both tables (using UNION ALL and COUNT(DISTINCT)), while the Generated SQL sums the total communities from each table (including duplicates). For example, if a community exists in both tables, the Generated SQL counts it twice, whereas the Reference query counts it once. The first two Reference queries (individual counts) are also not addressed by the Generated SQL.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The Reference SQL correctly addresses the business intent by counting distinct communities across both stations using COUNT(DISTINCT community) on a combined dataset. The Generated SQL incorrectly counts all communities (including duplicates) by using SUM with CASE statements instead of COUNT(DISTINCT). While both queries combine data from both stations, the Reference SQL ensures uniqueness, which is critical for accurately measuring 'indigenous communities' (implying distinct entities). The Generated SQL's approach would overcount if communities appear in both stations or multiple times within a single station.", "overall_assessment": "correct"}}
{"example_id": 5576, "sql_complexity": "window functions", "prompt": "Who are the top 5 users with the most followers, and what is their location?", "context": "CREATE TABLE user_data (user_id INT, name VARCHAR(50), followers INT, location VARCHAR(50)); INSERT INTO user_data (user_id, name, followers, location) VALUES (1, 'Alice', 10000, 'New York'), (2, 'Bob', 15000, 'California'), (3, 'Charlie', 12000, 'Texas'), (4, 'David', 8000, 'Florida'), (5, 'Eve', 9000, 'Illinois');", "reference_sql": "SELECT name, location FROM (SELECT name, location, ROW_NUMBER() OVER (ORDER BY followers DESC) AS rank FROM user_data) AS user_ranks WHERE rank <= 5;", "generated_sql": "SELECT name, location\nFROM user_data\nORDER BY followers DESC\nLIMIT 5;", "raw_model_output": "```sql\nSELECT name, location\nFROM user_data\nORDER BY followers DESC\nLIMIT 5;\n```", "latency_sec": 0.8147051334381104, "total_duration_sec": 0.597741229, "load_duration_sec": 0.015801508, "tokens_prompt": 214, "prompt_eval_sec": 0.043820904, "tokens_completion": 23, "completion_eval_sec": 0.536045841, "tokens_total": 237, "tokens_per_sec": 290.902794486938, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the top 5 users by followers in descending order. The Reference SQL uses ROW_NUMBER() to assign ranks and filters for rank <= 5, while the Generated SQL directly uses ORDER BY with LIMIT 5. Since the ordering logic (followers DESC) is identical and the data has unique follower counts, both produce the same result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly retrieve the top 5 users by followers and their locations. The Reference SQL uses a subquery with ROW_NUMBER() to assign ranks, while the Generated SQL directly orders and limits results. Technically, they produce identical results in this context since the sample data has unique follower counts. However, the Generated SQL is more efficient and elegant, avoiding unnecessary complexity. The Reference SQL could behave differently if there were ties in followers (due to ROW_NUMBER() vs. ORDER BY LIMIT), but the original question's sample data ensures equivalence here.", "overall_assessment": "correct"}}
{"example_id": 1560, "sql_complexity": "basic SQL", "prompt": "What is the average media literacy score for users in the 'Young Adult' age group who have completed at least one disinformation detection course?", "context": "CREATE TABLE users (id INT, age VARCHAR(20), media_literacy_score INT, courses_completed INT);", "reference_sql": "SELECT AVG(media_literacy_score) FROM users WHERE age = 'Young Adult' AND courses_completed > 0;", "generated_sql": "SELECT AVG(media_literacy_score) \nFROM users \nWHERE age = 'Young Adult' AND courses_completed >= 1;", "raw_model_output": "```sql\nSELECT AVG(media_literacy_score) \nFROM users \nWHERE age = 'Young Adult' AND courses_completed >= 1;\n```", "latency_sec": 1.3367328643798828, "total_duration_sec": 0.738663174, "load_duration_sec": 0.014377338, "tokens_prompt": 128, "prompt_eval_sec": 0.026809549, "tokens_completion": 31, "completion_eval_sec": 0.695420927, "tokens_total": 159, "tokens_per_sec": 118.94672767977535, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both conditions 'courses_completed > 0' and 'courses_completed >= 1' evaluate to the same set of rows because the 'courses_completed' column is an integer. For integers, values greater than 0 are exactly the same as values greater than or equal to 1.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the average media literacy score for 'Young Adult' users with at least one completed course. The conditions 'courses_completed > 0' (reference) and 'courses_completed >= 1' (generated) are mathematically equivalent. The generated query uses a more explicit comparison operator ('>= 1') which directly maps to the phrasing 'at least one', enhancing readability. However, neither query is more efficient than the other, and both fully address the business intent of measuring users who completed one or more courses.", "overall_assessment": "correct"}}
{"example_id": 1201, "sql_complexity": "basic SQL", "prompt": "What is the maximum energy efficiency rating of hydroelectric dams in Canada?", "context": "CREATE TABLE hydro_dams (id INT, name TEXT, country TEXT, energy_efficiency_rating FLOAT); INSERT INTO hydro_dams (id, name, country, energy_efficiency_rating) VALUES (1, 'Robert-Bourassa', 'Canada', 0.94), (2, 'Churchill Falls', 'Canada', 0.92);", "reference_sql": "SELECT MAX(energy_efficiency_rating) FROM hydro_dams WHERE country = 'Canada';", "generated_sql": "SELECT MAX(energy_efficiency_rating) AS max_energy_efficiency_rating\nFROM hydro_dams\nWHERE country = 'Canada';", "raw_model_output": "```sql\nSELECT MAX(energy_efficiency_rating) AS max_energy_efficiency_rating\nFROM hydro_dams\nWHERE country = 'Canada';\n```", "latency_sec": 0.9402720928192139, "total_duration_sec": 0.746926556, "load_duration_sec": 0.013681162, "tokens_prompt": 164, "prompt_eval_sec": 0.03060914, "tokens_completion": 31, "completion_eval_sec": 0.700660174, "tokens_total": 195, "tokens_per_sec": 207.38677824131983, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the maximum energy_efficiency_rating for Canadian hydro dams. The generated query adds an alias (max_energy_efficiency_rating) to the column, but this does not affect the actual data returned - the scalar value remains the same.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the maximum energy efficiency rating for Canadian hydroelectric dams. The reference query returns the raw maximum value, while the generated query adds an explicit alias for the result column. The alias improves readability but does not alter the semantic meaning or technical correctness. Both satisfy the business requirement by identifying the highest rating in Canada. The efficiency is identical since both use the same aggregation and filtering logic.", "overall_assessment": "correct"}}
{"example_id": 4243, "sql_complexity": "single join", "prompt": "How many orders were placed by new and returning customers in each month of the year 2021?'", "context": "CREATE TABLE customer (id INT, first_order_date DATE, last_order_date DATE);", "reference_sql": "INSERT INTO customer (id, first_order_date, last_order_date) SELECT customer_id, MIN(order_date) AS first_order_date, MAX(order_date) AS last_order_date FROM orders GROUP BY customer_id; SELECT YEAR(order_date) AS year, MONTH(order_date) AS month, CASE WHEN DATEDIFF(last_order_date, first_order_date) > 30 THEN 'returning' ELSE 'new' END AS customer_type, COUNT(DISTINCT id) AS num_orders FROM orders JOIN customer ON orders.customer_id = customer.id WHERE YEAR(order_date) = 2021 GROUP BY year, month, customer_type;", "generated_sql": "SELECT \n    EXTRACT(YEAR FROM first_order_date) AS year,\n    EXTRACT(MONTH FROM first_order_date) AS month,\n    COUNT(*) AS new_customer_orders,\n    0 AS returning_customer_orders\nFROM \n    customer\nWHERE \n    EXTRACT(YEAR FROM first_order_date) = 2021\nGROUP BY \n    EXTRACT(YEAR FROM first_order_date), EXTRACT(MONTH FROM first_order_date)\n\nUNION ALL\n\nSELECT \n    EXTRACT(YEAR FROM last_order_date) AS year,\n    EXTRACT(MONTH FROM last_order_date) AS month,\n    0 AS new_customer_orders,\n    COUNT(*) AS returning_customer_orders\nFROM \n    customer\nWHERE \n    EXTRACT(YEAR FROM last_order_date) = 2021\n    AND EXTRACT(YEAR FROM first_order_date) < 2021\nGROUP BY \n    EXTRACT(YEAR FROM last_order_date), EXTRACT(MONTH FROM last_order_date)\n\nORDER BY \n    year, month;", "raw_model_output": "To determine how many orders were placed by new and returning customers in each month of the year 2021, we need to analyze the `first_order_date` and `last_order_date` columns in the `customer` table. Here's a step-by-step breakdown of how to construct the SQL query:\n\n1. **Identify New Customers**: A customer is considered new if their `first_order_date` falls within the year 2021.\n2. **Identify Returning Customers**: A customer is considered returning if their `last_order_date` falls within the year 2021 but their `first_order_date` is before 2021.\n3. **Count Orders by Month**: We need to count the number of orders placed by these customers for each month in 2021.\n\nHere's the SQL query that accomplishes this:\n\n```sql\nSELECT \n    EXTRACT(YEAR FROM first_order_date) AS year,\n    EXTRACT(MONTH FROM first_order_date) AS month,\n    COUNT(*) AS new_customer_orders,\n    0 AS returning_customer_orders\nFROM \n    customer\nWHERE \n    EXTRACT(YEAR FROM first_order_date) = 2021\nGROUP BY \n    EXTRACT(YEAR FROM first_order_date), EXTRACT(MONTH FROM first_order_date)\n\nUNION ALL\n\nSELECT \n    EXTRACT(YEAR FROM last_order_date) AS year,\n    EXTRACT(MONTH FROM last_order_date) AS month,\n    0 AS new_customer_orders,\n    COUNT(*) AS returning_customer_orders\nFROM \n    customer\nWHERE \n    EXTRACT(YEAR FROM last_order_date) = 2021\n    AND EXTRACT(YEAR FROM first_order_date) < 2021\nGROUP BY \n    EXTRACT(YEAR FROM last_order_date), EXTRACT(MONTH FROM last_order_date)\n\nORDER BY \n    year, month;\n```\n\n### Explanation:\n- **First Part of the Query**: This part counts the orders placed by new customers in each month of 2021. It filters customers whose `first_order_date` is within 2021 and groups the results by month.\n- **Second Part of the Query**: This part counts the orders placed by returning customers in each month of 2021. It filters customers whose `last_order_date` is within 2021 but their `first_order_date` is before 2021, and groups the results by month.\n- **UNION ALL**: Combines the results from both parts to get a single result set with columns for new and returning customer orders.\n- **ORDER BY**: Ensures the final result is ordered by year and month.", "latency_sec": 12.855649948120117, "total_duration_sec": 12.800430895, "load_duration_sec": 0.014640796, "tokens_prompt": 115, "prompt_eval_sec": 0.021962139, "tokens_completion": 560, "completion_eval_sec": 12.761649076, "tokens_total": 675, "tokens_per_sec": 52.506096753101566, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The reference query calculates customer_type based on the DATEDIFF between first and last order dates (new if <=30 days, returning otherwise) and counts distinct orders from the orders table. The generated query splits customers into 'new' (first_order_date in 2021) and 'returning' (last_order_date in 2021 with first_order_date before 2021) but does not account for the 30-day DATEDIFF logic. Additionally, the generated query counts customers directly rather than orders, and the grouping/conditioning logic differs significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL attempts to answer the question by joining orders with customer data and categorizing customers based on their first/last order dates. However, its logic is flawed: it uses DATEDIFF(last_order_date, first_order_date) > 30 to determine 'returning' customers, which incorrectly classifies customers with multiple orders in 2021 as returning for all orders. The Generated SQL fails to count orders entirely, instead counting customers (COUNT(*)) and using first/last order dates to categorize, which doesn't align with the question's focus on order-level analysis. While both queries have issues, the Reference SQL at least attempts to count orders, making it technically closer to the intent.", "overall_assessment": "differently_correct"}}
{"example_id": 2321, "sql_complexity": "subqueries", "prompt": "What are the names and types of vessels used in research expeditions in the regions with the lowest ocean acidification levels?", "context": "CREATE TABLE ocean_acidification (id INT PRIMARY KEY, region VARCHAR(255), year INT, acidification_level INT); INSERT INTO ocean_acidification (id, region, year, acidification_level) VALUES (1, 'Arctic Ocean', 2018, 20), (2, 'Southern Ocean', 2019, 22); CREATE TABLE expedition_vessels (id INT PRIMARY KEY, name VARCHAR(255), type VARCHAR(255), region VARCHAR(255)); INSERT INTO expedition_vessels (id, name, type, region) VALUES (1, 'Sea Researcher', 'Research Vessel', 'Arctic Ocean');", "reference_sql": "SELECT v.name, v.type FROM expedition_vessels v INNER JOIN ocean_acidification oa ON v.region = oa.region WHERE oa.acidification_level = (SELECT MIN(acidification_level) FROM ocean_acidification);", "generated_sql": "SELECT ev.name, ev.type\nFROM expedition_vessels ev\nWHERE ev.region IN (\n    SELECT oa.region\n    FROM ocean_acidification oa\n    ORDER BY oa.acidification_level ASC\n    LIMIT 1\n);", "raw_model_output": "```sql\nSELECT ev.name, ev.type\nFROM expedition_vessels ev\nWHERE ev.region IN (\n    SELECT oa.region\n    FROM ocean_acidification oa\n    ORDER BY oa.acidification_level ASC\n    LIMIT 1\n);\n```", "latency_sec": 1.3186359405517578, "total_duration_sec": 1.308859733, "load_duration_sec": 0.022350811, "tokens_prompt": 247, "prompt_eval_sec": 0.050260778, "tokens_completion": 53, "completion_eval_sec": 1.234078521, "tokens_total": 300, "tokens_per_sec": 227.50782894213452, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL finds all regions with the minimum acidification_level (which could be multiple regions) and joins vessels in those regions. The Generated SQL selects only a single region (due to LIMIT 1) from the ordered list of regions by acidification_level. If multiple regions share the minimum acidification_level, the Generated SQL would miss some regions, making the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries differ in how they handle multiple regions with the same minimum acidification level. The reference query uses = (SELECT MIN(...)) which correctly identifies all regions with the absolute minimum acidification level, while the generated query uses LIMIT 1 which only returns a single region (potentially missing other regions with the same minimum). Both correctly join vessels to regions, but the reference query is more accurate for the business intent. The generated query could fail if multiple regions share the lowest acidification level. The reference query also explicitly links the acidification level to the vessels through the region, which aligns with the schema.", "overall_assessment": "correct"}}
{"example_id": 4349, "sql_complexity": "multiple_joins", "prompt": "Show the research grants awarded to professors in the Computer Science department.", "context": "CREATE TABLE departments (id INT, name VARCHAR(50)); INSERT INTO departments (id, name) VALUES (1, 'Computer Science'), (2, 'Mathematics'); CREATE TABLE professors (id INT, name VARCHAR(50), department_id INT); INSERT INTO professors (id, name, department_id) VALUES (1, 'John Smith', 1), (2, 'Jane Doe', 2); CREATE TABLE grants (id INT, professor_id INT, year INT, amount FLOAT); INSERT INTO grants (id, professor_id, year, amount) VALUES (1, 1, 2021, 5000.0), (2, 2, 2020, 7000.0);", "reference_sql": "SELECT professors.name, grants.amount FROM professors INNER JOIN grants ON professors.id = grants.professor_id INNER JOIN departments ON professors.department_id = departments.id WHERE departments.name = 'Computer Science';", "generated_sql": "SELECT g.id, g.professor_id, p.name AS professor_name, g.year, g.amount\nFROM grants g\nJOIN professors p ON g.professor_id = p.id\nJOIN departments d ON p.department_id = d.id\nWHERE d.name = 'Computer Science';", "raw_model_output": "```sql\nSELECT g.id, g.professor_id, p.name AS professor_name, g.year, g.amount\nFROM grants g\nJOIN professors p ON g.professor_id = p.id\nJOIN departments d ON p.department_id = d.id\nWHERE d.name = 'Computer Science';\n```", "latency_sec": 1.7548260688781738, "total_duration_sec": 1.475054826, "load_duration_sec": 0.01368704, "tokens_prompt": 245, "prompt_eval_sec": 0.05130936, "tokens_completion": 61, "completion_eval_sec": 1.407558086, "tokens_total": 306, "tokens_per_sec": 174.37625610133537, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent because they select different columns. The Reference SQL returns (professors.name, grants.amount), while the Generated SQL returns (g.id, g.professor_id, p.name, g.year, g.amount). Although both filter for 'Computer Science' department and join the same tables, the result sets have different structures and data.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries are technically correct and would produce semantically equivalent results, as they both retrieve grants awarded to Computer Science professors through identical join logic and filtering. The reference query is more focused on the business intent by selecting only the core required fields (professor name and grant amount), while the generated query includes additional columns (grant ID, year) that weren't explicitly requested. Though the generated query is syntactically valid and provides more data, the reference query better aligns with the original question's requirements by avoiding unnecessary information. Both are efficient, but the reference's simplicity makes it more elegant for this specific use case.", "overall_assessment": "differently_correct"}}
{"example_id": 476, "sql_complexity": "basic SQL", "prompt": "Insert new food safety records for locations \"A123\", \"B456\", and \"C789\"", "context": "CREATE TABLE food_safety_records (id INT, location VARCHAR(255), inspection_date DATE, violation_count INT);", "reference_sql": "INSERT INTO food_safety_records (location, inspection_date, violation_count) VALUES ('A123', '2022-03-01', 0), ('B456', '2022-03-05', 2), ('C789', '2022-03-10', 1);", "generated_sql": "INSERT INTO food_safety_records (location, inspection_date, violation_count)\nVALUES \n('A123', CURRENT_DATE, 0),\n('B456', CURRENT_DATE, 0),\n('C789', CURRENT_DATE, 0);", "raw_model_output": "```sql\nINSERT INTO food_safety_records (location, inspection_date, violation_count)\nVALUES \n('A123', CURRENT_DATE, 0),\n('B456', CURRENT_DATE, 0),\n('C789', CURRENT_DATE, 0);\n```", "latency_sec": 1.4470109939575195, "total_duration_sec": 1.347407231, "load_duration_sec": 0.020052594, "tokens_prompt": 127, "prompt_eval_sec": 0.023390344, "tokens_completion": 58, "completion_eval_sec": 1.301922766, "tokens_total": 185, "tokens_per_sec": 127.8497542676107, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL inserts specific dates (2022-03-01, 2022-03-05, 2022-03-10) and varying violation counts (0, 2, 1), while the Generated SQL uses CURRENT_DATE (which inserts the current date at execution time) and sets all violation_counts to 0. The inspection dates and violation counts differ between the two queries.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent because they insert different data. The reference SQL uses specific dates and violation counts for each location, while the generated SQL uses CURRENT_DATE and zeros for all records. Both fulfill the business intent of inserting records for the specified locations, but the reference provides explicit data that aligns with typical food safety record requirements (specific inspection dates and violation counts). The generated SQL is more efficient in terms of dynamic date handling but lacks the specificity required for accurate record-keeping. The reference query better addresses the implicit need for detailed, accurate records.", "overall_assessment": "differently_correct"}}
{"example_id": 2908, "sql_complexity": "single join", "prompt": "List all co-owners and the properties they own in New York, NY.", "context": "CREATE TABLE properties (id INT, city VARCHAR(50), price INT); CREATE TABLE co_owners (property_id INT, owner_name VARCHAR(50)); INSERT INTO properties (id, city, price) VALUES (1, 'New York', 800000), (2, 'Los Angeles', 600000); INSERT INTO co_owners (property_id, owner_name) VALUES (1, 'David'), (1, 'Ella'), (2, 'Frank');", "reference_sql": "SELECT properties.city, co_owners.owner_name FROM properties INNER JOIN co_owners ON properties.id = co_owners.property_id WHERE properties.city = 'New York';", "generated_sql": "SELECT co_owners.owner_name, properties.id AS property_id, properties.city, properties.price\nFROM co_owners\nJOIN properties ON co_owners.property_id = properties.id\nWHERE properties.city = 'New York';", "raw_model_output": "```sql\nSELECT co_owners.owner_name, properties.id AS property_id, properties.city, properties.price\nFROM co_owners\nJOIN properties ON co_owners.property_id = properties.id\nWHERE properties.city = 'New York';\n```", "latency_sec": 1.383249044418335, "total_duration_sec": 1.182050996, "load_duration_sec": 0.015049255, "tokens_prompt": 198, "prompt_eval_sec": 0.044067679, "tokens_completion": 49, "completion_eval_sec": 1.120692852, "tokens_total": 247, "tokens_per_sec": 178.56509715057499, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects only 'city' and 'owner_name', while the Generated SQL includes additional columns ('owner_name', 'property_id', 'city', 'price'). The extra columns in the Generated SQL change the result set structure, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because the generated query returns additional columns (property_id, price) not present in the reference. Both correctly identify co-owners in New York, NY, but the generated query provides more detailed property information (ID and price) which better fulfills the 'properties they own' requirement. The reference query only returns the city, which is less specific for identifying individual properties. Both are syntactically correct and logically equivalent in filtering, but the generated query's expanded output better addresses the business intent of listing co-owners with their specific property details.", "overall_assessment": "differently_correct"}}
{"example_id": 636, "sql_complexity": "set operations", "prompt": "Insert new data into the 'cosmetic_ingredients' table for a vegan eyeshadow product by brand 'Ara' with ingredients 'Mica', 'Iron Oxide', 'Titanium Dioxide' and 'Zinc Oxide'.", "context": "CREATE TABLE cosmetic_ingredients (ingredient_id INT, product_name TEXT, brand_name TEXT, ingredient_type TEXT);", "reference_sql": "INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type) VALUES (NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient'); INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type, ingredient_name) SELECT ingredient_id, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Mica' FROM cosmetic_ingredients WHERE ingredient_name = 'Mica' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Iron Oxide' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Titanium Dioxide' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Zinc Oxide';", "generated_sql": "INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type)\nVALUES \n(1, 'Vegan Eyeshadow', 'Ara', 'Mica'),\n(2, 'Vegan Eyeshadow', 'Ara', 'Iron Oxide'),\n(3, 'Vegan Eyeshadow', 'Ara', 'Titanium Dioxide'),\n(4, 'Vegan Eyeshadow', 'Ara', 'Zinc Oxide');", "raw_model_output": "```sql\nINSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type)\nVALUES \n(1, 'Vegan Eyeshadow', 'Ara', 'Mica'),\n(2, 'Vegan Eyeshadow', 'Ara', 'Iron Oxide'),\n(3, 'Vegan Eyeshadow', 'Ara', 'Titanium Dioxide'),\n(4, 'Vegan Eyeshadow', 'Ara', 'Zinc Oxide');\n```", "latency_sec": 2.436509370803833, "total_duration_sec": 2.338782838, "load_duration_sec": 0.013792897, "tokens_prompt": 147, "prompt_eval_sec": 0.027093863, "tokens_completion": 102, "completion_eval_sec": 2.295416345, "tokens_total": 249, "tokens_per_sec": 102.19537958019508, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL attempts to insert into a non-existent 'ingredient_name' column (as per the provided schema), while the Generated SQL correctly uses only the existing columns. Additionally, the Generated SQL explicitly assigns numeric ingredient_ids (1-4) with ingredient_type as the actual ingredient name, whereas the Reference SQL sets ingredient_type to 'Ingredient' and includes an unrelated ingredient_name column. Data structure and content differences make them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL contains critical errors: it references a non-existent 'ingredient_name' column in the WHERE clause and attempts to insert a generic 'Ingredient' type instead of the specific ingredients. The Generated SQL correctly inserts each ingredient as a separate row with proper values, aligning with the schema's structure. While both queries aim to add ingredients, the Generated SQL is syntactically valid and directly addresses the requirement without unnecessary complexity. The Reference SQL's approach is flawed due to schema mismatch and logical errors.", "overall_assessment": "correct"}}
{"example_id": 3404, "sql_complexity": "multiple_joins", "prompt": "What are the names of startups that have received funding from investors with over 3 million funds, and are involved in Genetic Research or Bioprocess Engineering?", "context": "CREATE TABLE public.investors ( id SERIAL PRIMARY KEY, name VARCHAR(100), type VARCHAR(50), funds INTEGER ); CREATE TABLE public.investments ( id SERIAL PRIMARY KEY, investor_id INTEGER, startup_id INTEGER ); CREATE TABLE public.startups ( id SERIAL PRIMARY KEY, name VARCHAR(100), industry VARCHAR(50), funding INTEGER );", "reference_sql": "SELECT startups.name FROM public.startups JOIN public.investments ON startups.id = investments.startup_id JOIN public.investors ON investments.investor_id = investors.id WHERE (startups.industry = 'Genetic Research' OR startups.industry = 'Bioprocess Engineering') AND investors.funds > 3000000;", "generated_sql": "SELECT DISTINCT s.name\nFROM public.startups s\nJOIN public.investments i ON s.id = i.startup_id\nJOIN public.investors inv ON i.investor_id = inv.id\nWHERE inv.funds > 3000000\nAND s.industry IN ('Genetic Research', 'Bioprocess Engineering');", "raw_model_output": "```sql\nSELECT DISTINCT s.name\nFROM public.startups s\nJOIN public.investments i ON s.id = i.startup_id\nJOIN public.investors inv ON i.investor_id = inv.id\nWHERE inv.funds > 3000000\nAND s.industry IN ('Genetic Research', 'Bioprocess Engineering');\n```", "latency_sec": 1.8914258480072021, "total_duration_sec": 1.798484155, "load_duration_sec": 0.014055511, "tokens_prompt": 182, "prompt_eval_sec": 0.036875116, "tokens_completion": 77, "completion_eval_sec": 1.745158961, "tokens_total": 259, "tokens_per_sec": 136.93373191070708, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The generated query includes DISTINCT which ensures unique startup names, while the reference query may return duplicates if a startup has multiple investments from qualifying investors. The IN clause is equivalent to the OR conditions, but the DISTINCT clause changes the result set's uniqueness guarantees.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries address the core business question by identifying startups in specified industries funded by high-fund investors. The technical difference lies in the use of DISTINCT in the generated query, which ensures unique startup names (critical when multiple investments exist) versus potential duplicates in the reference query. The generated query also uses IN for cleaner industry filtering and table aliases for readability. While both are logically correct, the generated version better handles edge cases (duplicates) and is more efficient/elegant.", "overall_assessment": "differently_correct"}}
{"example_id": 134, "sql_complexity": "subqueries", "prompt": "Who are the top 3 authors with the most citations in the Mathematics department in the past 5 years?", "context": "CREATE TABLE authors (id INT, name VARCHAR(50), department VARCHAR(50)); INSERT INTO authors (id, name, department) VALUES (1, 'Author Name', 'Mathematics'); CREATE TABLE publications (id INT, title VARCHAR(100), author VARCHAR(50), journal VARCHAR(50), year INT, cites INT); INSERT INTO publications (id, title, author, journal, year, cites) VALUES (1, 'Publication Title', 'Author Name', 'Journal Name', 2021, 10);", "reference_sql": "SELECT author, SUM(cites) as total_cites FROM publications WHERE author IN (SELECT name FROM authors WHERE department = 'Mathematics') AND year BETWEEN YEAR(CURRENT_DATE) - 5 AND YEAR(CURRENT_DATE) GROUP BY author ORDER BY total_cites DESC LIMIT 3;", "generated_sql": "SELECT a.name, SUM(p.cites) AS total_citations\nFROM authors a\nJOIN publications p ON a.name = p.author\nWHERE a.department = 'Mathematics' AND p.year >= YEAR(CURRENT_DATE) - 5\nGROUP BY a.name\nORDER BY total_citations DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT a.name, SUM(p.cites) AS total_citations\nFROM authors a\nJOIN publications p ON a.name = p.author\nWHERE a.department = 'Mathematics' AND p.year >= YEAR(CURRENT_DATE) - 5\nGROUP BY a.name\nORDER BY total_citations DESC\nLIMIT 3;\n```", "latency_sec": 1.8663389682769775, "total_duration_sec": 1.667409797, "load_duration_sec": 0.017388933, "tokens_prompt": 213, "prompt_eval_sec": 0.045479462, "tokens_completion": 70, "completion_eval_sec": 1.601763592, "tokens_total": 283, "tokens_per_sec": 151.63376257490265, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the top 3 authors from the 'Mathematics' department with the highest total citations in the last 5 years. The Reference SQL uses a subquery with IN and BETWEEN, while the Generated SQL uses a JOIN and >=. The year conditions are equivalent (BETWEEN YEAR(CURRENT_DATE)-5 AND YEAR(CURRENT_DATE) matches p.year >= YEAR(CURRENT_DATE)-5). The JOIN ensures authors.department = 'Mathematics' and a.name = p.author, which is equivalent to the subquery filtering. Grouping and ordering logic are identical, and the aliases in ORDER BY (total_cites vs total_citations) do not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically equivalent and fulfill the business intent of identifying the top 3 Mathematics department authors by citations in the past 5 years. The Reference SQL uses a subquery to filter authors, while the Generated SQL uses an explicit JOIN, which is more efficient and avoids potential issues with subquery optimization. The Generated SQL also explicitly aliases tables, improving readability. Both handle year filtering correctly (2018-2023 for 2023 current year) and aggregate citations properly. The Generated SQL's JOIN ensures only authors with matching entries in both tables are considered, which aligns with the business context of linking authors to their publications.", "overall_assessment": "correct"}}
{"example_id": 592, "sql_complexity": "set operations", "prompt": "How many public healthcare facilities and public parks are there in total, in the 'StateData' schema's 'StateHealthcare' and 'StateParks' tables?", "context": "CREATE SCHEMA StateData; CREATE TABLE StateHealthcare (Name varchar(255), Type varchar(255)); INSERT INTO StateHealthcare (Name, Type) VALUES ('FacilityA', 'Public'), ('FacilityB', 'Public'), ('FacilityC', 'Private'); CREATE TABLE StateParks (Name varchar(255), Type varchar(255)); INSERT INTO StateParks (Name, Type) VALUES ('ParkA', 'Public'), ('ParkB', 'Public'), ('ParkC', 'Private');", "reference_sql": "SELECT COUNT(*) FROM StateData.StateHealthcare WHERE Type = 'Public' UNION ALL SELECT COUNT(*) FROM StateData.StateParks WHERE Type = 'Public';", "generated_sql": "SELECT \n    (SELECT COUNT(*) FROM StateData.StateHealthcare WHERE Type = 'Public') + \n    (SELECT COUNT(*) FROM StateData.StateParks WHERE Type = 'Public') AS Total_Public_Facilities;", "raw_model_output": "```sql\nSELECT \n    (SELECT COUNT(*) FROM StateData.StateHealthcare WHERE Type = 'Public') + \n    (SELECT COUNT(*) FROM StateData.StateParks WHERE Type = 'Public') AS Total_Public_Facilities;\n```", "latency_sec": 1.5044939517974854, "total_duration_sec": 1.213584029, "load_duration_sec": 0.015019785, "tokens_prompt": 223, "prompt_eval_sec": 0.045783159, "tokens_completion": 50, "completion_eval_sec": 1.150662196, "tokens_total": 273, "tokens_per_sec": 181.45636256884572, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate counts (one for StateHealthcare and one for StateParks) as two rows, while the Generated SQL returns a single row with the summed total of both counts. The result structures differ (two rows vs. one row), so they are not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query returns two separate counts (healthcare and parks) as two rows, while the generated query correctly returns a single total sum. The original question asks for 'total' numbers, which requires aggregation. The generated query uses explicit arithmetic addition to combine results, ensuring a single numerical answer. The reference query's UNION ALL structure would require additional processing to combine results, making it less efficient and less aligned with the business intent of getting a single total.", "overall_assessment": "differently_correct"}}
{"example_id": 1989, "sql_complexity": "single join", "prompt": "What are the names and production dates of garments made from fabrics with a sustainability score over 70, produced after 2021-01-01?", "context": "CREATE TABLE fabrics (id INT, name VARCHAR(50), type VARCHAR(50), sustainability_score INT); INSERT INTO fabrics (id, name, type, sustainability_score) VALUES (1, 'Organic Linen', 'Natural', 80); INSERT INTO fabrics (id, name, type, sustainability_score) VALUES (2, 'Recycled Nylon', 'Synthetic', 72);", "reference_sql": "SELECT garments.name, garments.production_date FROM garments JOIN fabrics ON garments.fabric_id = fabrics.id WHERE fabrics.sustainability_score > 70 AND garments.production_date > '2021-01-01';", "generated_sql": "SELECT g.name, g.production_date\nFROM garments g\nJOIN fabrics f ON g.fabric_id = f.id\nWHERE f.sustainability_score > 70 AND g.production_date > '2021-01-01';", "raw_model_output": "```sql\nSELECT g.name, g.production_date\nFROM garments g\nJOIN fabrics f ON g.fabric_id = f.id\nWHERE f.sustainability_score > 70 AND g.production_date > '2021-01-01';\n```", "latency_sec": 1.3823931217193604, "total_duration_sec": 1.302979527, "load_duration_sec": 0.013701154, "tokens_prompt": 194, "prompt_eval_sec": 0.036850494, "tokens_completion": 55, "completion_eval_sec": 1.250034229, "tokens_total": 249, "tokens_per_sec": 180.1224239963699, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between 'garments' and 'fabrics' tables on fabric_id, apply the same filters (sustainability_score > 70 and production_date > '2021-01-01'), and select the same columns (name and production_date from garments). The only differences are the use of table aliases (g/f vs. no aliases) and formatting, which do not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent as they perform the same join operation between 'garments' and 'fabrics' tables using the same conditions (sustainability_score > 70 and production_date > '2021-01-01'). They select identical columns (garments.name, garments.production_date) and enforce the same business constraints. The only difference is the use of table aliases ('g' and 'f') in the generated query, which improves readability without altering logic. Both queries fully fulfill the business intent by retrieving garments made from sustainable fabrics produced after the specified date. The efficiency and elegance are comparable, with the generated query's aliases offering minor readability benefits.", "overall_assessment": "correct"}}
{"example_id": 1388, "sql_complexity": "aggregation", "prompt": "What was the total donation amount by each organization in the last 30 days?", "context": "CREATE TABLE organization_donations (id INT, organization TEXT, donation_date DATE, donation_amount DECIMAL(10,2)); INSERT INTO organization_donations (id, organization, donation_date, donation_amount) VALUES (1, 'Organization A', '2021-03-15', 100.00), (2, 'Organization B', '2021-03-25', 200.00);", "reference_sql": "SELECT organization, SUM(donation_amount) FROM organization_donations WHERE donation_date >= DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY) GROUP BY organization;", "generated_sql": "SELECT \n    organization, \n    SUM(donation_amount) AS total_donation_amount\nFROM \n    organization_donations\nWHERE \n    donation_date >= CURRENT_DATE - INTERVAL '30' DAY\nGROUP BY \n    organization;", "raw_model_output": "```sql\nSELECT \n    organization, \n    SUM(donation_amount) AS total_donation_amount\nFROM \n    organization_donations\nWHERE \n    donation_date >= CURRENT_DATE - INTERVAL '30' DAY\nGROUP BY \n    organization;\n```", "latency_sec": 1.43168306350708, "total_duration_sec": 1.23547899, "load_duration_sec": 0.013689369, "tokens_prompt": 190, "prompt_eval_sec": 0.036572012, "tokens_completion": 52, "completion_eval_sec": 1.182846572, "tokens_total": 242, "tokens_per_sec": 169.03182426925682, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter donations from the last 30 days using date calculations and aggregate by organization. The date calculation syntax differs (DATE_SUB vs. CURRENT_DATE - INTERVAL), but both achieve the same logical condition. The column alias difference (total_donation_amount vs. implicit) doesn't affect result equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the total donations per organization for the last 30 days. The reference uses DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY) while the generated uses CURRENT_DATE - INTERVAL '30' DAY. Both date calculations are valid in MySQL and produce equivalent results. The generated query improves readability with the explicit alias 'total_donation_amount' without altering the core logic. The GROUP BY and SUM operations are identical. Both fulfill the business intent of aggregating donations by organization, but the generated version is more semantically clear due to the column alias.", "overall_assessment": "correct"}}
{"example_id": 1628, "sql_complexity": "window functions", "prompt": "What is the ranking of national security measures for Russia based on the publication date?", "context": "CREATE TABLE national_security (id INT, title VARCHAR(255), description TEXT, agency VARCHAR(255), date DATE); INSERT INTO national_security (id, title, description, agency, date) VALUES (1, 'National Cyber Strategy', 'Outlines the approach to protecting the American people and the American way of life in the digital age', 'White House', '2018-09-20'); INSERT INTO national_security (id, title, description, agency, date) VALUES (2, 'Cybersecurity and Infrastructure Security Agency Act of 2018', 'Establishes the Cybersecurity and Infrastructure Security Agency within the Department of Homeland Security', 'Congress', '2018-11-16'); INSERT INTO national_security (id, title, description, agency, date) VALUES (3, 'Russian Military Doctrine', 'Outlines the country\u2019s stance on military security', 'Russian Government', '2014-12-26');", "reference_sql": "SELECT title, description, agency, date, ROW_NUMBER() OVER (PARTITION BY agency ORDER BY date DESC) as ranking FROM national_security WHERE agency = 'Russian Government';", "generated_sql": "SELECT \n    title, \n    description, \n    agency, \n    date,\n    ROW_NUMBER() OVER (ORDER BY date ASC) AS rank\nFROM \n    national_security\nWHERE \n    agency = 'Russian Government'\nORDER BY \n    date ASC;", "raw_model_output": "```sql\nSELECT \n    title, \n    description, \n    agency, \n    date,\n    ROW_NUMBER() OVER (ORDER BY date ASC) AS rank\nFROM \n    national_security\nWHERE \n    agency = 'Russian Government'\nORDER BY \n    date ASC;\n```", "latency_sec": 1.747067928314209, "total_duration_sec": 1.445417043, "load_duration_sec": 0.014257439, "tokens_prompt": 299, "prompt_eval_sec": 0.06597985, "tokens_completion": 58, "completion_eval_sec": 1.362845971, "tokens_total": 357, "tokens_per_sec": 204.3423694146103, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same single row for 'Russian Government'. The Reference SQL uses ROW_NUMBER() with PARTITION BY agency (redundant here) and ORDER BY date DESC, while the Generated SQL uses ROW_NUMBER() with ORDER BY date ASC. Since there's only one row, both produce rank 1. The final ORDER BY in Generated SQL (date ASC) doesn't affect the single row, making results identical for the given data.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent because they produce different rankings. The Reference SQL uses ROW_NUMBER() with ORDER BY date DESC (newest first) and includes a redundant PARTITION BY agency (since the WHERE clause filters to a single agency). The Generated SQL uses ORDER BY date ASC (oldest first) and lacks the PARTITION BY clause. Both queries correctly filter for 'Russian Government' and include date-based ranking, but the Reference's descending order better aligns with typical ranking expectations (e.g., newer measures as higher priority). The Generated SQL's ascending order could be misleading for a 'ranking' question. While both fulfill the intent of ranking by date, the Reference's approach is more semantically aligned with the phrasing of the question.", "overall_assessment": "differently_correct"}}
{"example_id": 2300, "sql_complexity": "aggregation", "prompt": "What is the minimum capacity for schools in each location ('community_development')?", "context": "CREATE TABLE community_development.schools (id INT, name VARCHAR(50), capacity INT, location VARCHAR(50));", "reference_sql": "SELECT location, MIN(capacity) FROM community_development.schools GROUP BY location;", "generated_sql": "SELECT location, MIN(capacity) AS min_capacity\nFROM community_development.schools\nGROUP BY location;", "raw_model_output": "```sql\nSELECT location, MIN(capacity) AS min_capacity\nFROM community_development.schools\nGROUP BY location;\n```", "latency_sec": 0.8165717124938965, "total_duration_sec": 0.646281504, "load_duration_sec": 0.015104475, "tokens_prompt": 118, "prompt_eval_sec": 0.02398226, "tokens_completion": 27, "completion_eval_sec": 0.604525811, "tokens_total": 145, "tokens_per_sec": 177.57166673966043, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries group schools by location and calculate the minimum capacity per group. The generated query adds an explicit alias (min_capacity) for the MIN(capacity) column, but this does not affect the semantic result set. The core logic of grouping and aggregation remains identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly compute the minimum capacity per location using GROUP BY and MIN(). The generated query improves upon the reference by adding an explicit alias ('min_capacity') for the calculated column, enhancing readability and clarity without altering the result. While both satisfy the business intent, the generated version is more elegant and self-documenting.", "overall_assessment": "correct"}}
{"example_id": 4976, "sql_complexity": "set operations", "prompt": "What is the most common hashtag used in posts made by users from Brazil?", "context": "CREATE TABLE posts (id INT, user_id INT, content TEXT, hashtags TEXT, post_date DATE); INSERT INTO posts (id, user_id, content, hashtags, post_date) VALUES (1, 1, 'Hello World', '#datascience', '2022-06-01'), (2, 1, 'I love data', '#ai', '2022-06-02'), (3, 2, 'Ol\u00e1 Mundo', '#brasil', '2022-06-03'); CREATE TABLE users (id INT, name VARCHAR(100), country VARCHAR(50)); INSERT INTO users (id, name, country) VALUES (1, 'Jo\u00e3o Silva', 'Brazil'), (2, 'Maria Souza', 'Brazil');", "reference_sql": "SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(hashtags, ' ', n.n), ' ', -1) hashtag, COUNT(*) count FROM posts JOIN users ON posts.user_id = users.id CROSS JOIN (SELECT 1 n UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5) n WHERE users.country = 'Brazil' GROUP BY hashtag ORDER BY count DESC LIMIT 1;", "generated_sql": "SELECT hashtags, COUNT(*) AS frequency\nFROM posts\nJOIN users ON posts.user_id = users.id\nWHERE users.country = 'Brazil'\nGROUP BY hashtags\nORDER BY frequency DESC\nLIMIT 1;", "raw_model_output": "```sql\nSELECT hashtags, COUNT(*) AS frequency\nFROM posts\nJOIN users ON posts.user_id = users.id\nWHERE users.country = 'Brazil'\nGROUP BY hashtags\nORDER BY frequency DESC\nLIMIT 1;\n```", "latency_sec": 1.4623241424560547, "total_duration_sec": 1.162556583, "load_duration_sec": 0.015257756, "tokens_prompt": 262, "prompt_eval_sec": 0.058245863, "tokens_completion": 46, "completion_eval_sec": 1.086826825, "tokens_total": 308, "tokens_per_sec": 210.6236169244234, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL splits multi-tag entries in the 'hashtags' column into individual tags using SUBSTRING_INDEX, while the Generated SQL treats the entire 'hashtags' string as a single value. If any post contains multiple hashtags (e.g., '#datascience #ai'), the Reference SQL would count them separately, but the Generated SQL would count the combined string as one. Since the queries handle multi-tag scenarios differently, they are not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The generated SQL is technically correct and directly addresses the question. It assumes each post has a single hashtag (as shown in the sample data) and groups by the hashtags column, which works for the given schema. The reference SQL attempts to split multi-value hashtags (e.g., '#a #b') into individual rows, but the sample data and schema suggest hashtags are stored as single values. The reference query would fail to handle cases where hashtags are not space-separated or contain multiple tags, making it less robust. While the reference query might be valid for a different schema, the generated SQL is simpler, more efficient, and aligns with the provided data structure. Both queries fulfill the business intent, but the generated SQL is more elegant and appropriate for the context.", "overall_assessment": "correct"}}
{"example_id": 4637, "sql_complexity": "single join", "prompt": "What is the total value of transactions for each customer in the last 30 days?", "context": "CREATE TABLE transactions (id INT, customer_id INT, value DECIMAL(10, 2), transaction_date DATE); INSERT INTO transactions (id, customer_id, value, transaction_date) VALUES (1, 1, 100, '2022-01-01'), (2, 1, 200, '2022-01-15'), (3, 2, 50, '2022-01-05'), (4, 2, 150, '2022-01-30'), (5, 3, 300, '2022-01-20');", "reference_sql": "SELECT c.id, SUM(t.value) FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE t.transaction_date >= CURDATE() - INTERVAL 30 DAY GROUP BY c.id;", "generated_sql": "SELECT \n    customer_id, \n    SUM(value) AS total_value\nFROM \n    transactions\nWHERE \n    transaction_date >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)\nGROUP BY \n    customer_id;", "raw_model_output": "```sql\nSELECT \n    customer_id, \n    SUM(value) AS total_value\nFROM \n    transactions\nWHERE \n    transaction_date >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)\nGROUP BY \n    customer_id;\n```", "latency_sec": 1.3356990814208984, "total_duration_sec": 1.241504033, "load_duration_sec": 0.014435884, "tokens_prompt": 248, "prompt_eval_sec": 0.052450137, "tokens_completion": 50, "completion_eval_sec": 1.172319867, "tokens_total": 298, "tokens_per_sec": 223.10414384877143, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the total transaction value per customer for the last 30 days. The Reference SQL uses an INNER JOIN between customers and transactions, while the Generated SQL directly groups transactions by customer_id. Since customer_id in transactions corresponds to c.id in customers, the result sets will contain the same customer identifiers and summed values. The date filtering (CURDATE() - INTERVAL 30 DAY vs. DATE_SUB(CURDATE(), INTERVAL 30 DAY)) is functionally equivalent. The only difference is column naming (c.id vs. customer_id), but semantic equivalence focuses on data content, not column names.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the total transaction value per customer for the last 30 days. The Reference SQL uses an unnecessary INNER JOIN with the customers table, which adds computational overhead without providing additional value since the transactions table already contains customer_id. The Generated SQL directly filters and aggregates the transactions table, making it more efficient. Both use equivalent date calculations (CURDATE() - INTERVAL 30 DAY vs. DATE_SUB(CURDATE(), INTERVAL 30 DAY)) and group by customer_id, ensuring identical results. The Generated SQL is simpler and avoids redundant joins, making it technically superior.", "overall_assessment": "correct"}}
{"example_id": 4947, "sql_complexity": "aggregation", "prompt": "What is the total revenue for drugs approved between 2017 and 2019?", "context": "CREATE TABLE drug_sales_3 (drug_name TEXT, revenue FLOAT, year INT); INSERT INTO drug_sales_3 (drug_name, revenue, year) VALUES ('DrugG', 20000000, 2019), ('DrugG', 19000000, 2018), ('DrugH', 15000000, 2017), ('DrugH', 16000000, 2018);", "reference_sql": "SELECT drug_name, SUM(revenue) FROM drug_sales_3 WHERE year BETWEEN 2017 AND 2019 GROUP BY drug_name;", "generated_sql": "SELECT SUM(revenue) AS total_revenue\nFROM drug_sales_3\nWHERE year BETWEEN 2017 AND 2019;", "raw_model_output": "```sql\nSELECT SUM(revenue) AS total_revenue\nFROM drug_sales_3\nWHERE year BETWEEN 2017 AND 2019;\n```", "latency_sec": 0.9491901397705078, "total_duration_sec": 0.890485981, "load_duration_sec": 0.014191633, "tokens_prompt": 209, "prompt_eval_sec": 0.044571219, "tokens_completion": 36, "completion_eval_sec": 0.829122715, "tokens_total": 245, "tokens_per_sec": 258.1147756752249, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query groups results by drug_name and returns individual drug totals, while the generated query calculates a single total revenue for all drugs combined. The generated query lacks a GROUP BY clause, resulting in a different output structure (single value vs multiple rows).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query groups results by drug_name, returning individual drug totals, while the generated query returns a single total revenue value. The original question asks for 'total revenue for drugs' (singular), which implies an overall total rather than per-drug breakdowns. The generated query directly answers this by aggregating all revenues between 2017-2019. The reference query, while technically correct for per-drug analysis, introduces unnecessary granularity that doesn't align with the business intent of the question. Both queries are efficient, but the generated version better matches the explicit request for a single total revenue figure.", "overall_assessment": "differently_correct"}}
{"example_id": 4767, "sql_complexity": "window functions", "prompt": "List the top 2 AI algorithms with the highest explainability scores, by algorithm subtype, ordered by scores in descending order for the European region.", "context": "CREATE TABLE ai_algorithms (algorithm_id INT, algorithm_name VARCHAR(50), algorithm_subtype VARCHAR(50), region VARCHAR(50), explainability_score FLOAT); INSERT INTO ai_algorithms (algorithm_id, algorithm_name, algorithm_subtype, region, explainability_score) VALUES (1, 'AlgoA', 'Tree-based', 'Europe', 0.85), (2, 'AlgoB', 'Computer Vision', 'Europe', 0.92), (3, 'AlgoC', 'Tree-based', 'Europe', 0.78), (4, 'AlgoD', 'Transformer', 'Europe', 0.90), (5, 'AlgoE', 'Tree-based', 'Europe', 0.80);", "reference_sql": "SELECT algorithm_subtype, region, * FROM (SELECT algorithm_subtype, region, algorithm_id, algorithm_name, explainability_score, RANK() OVER (PARTITION BY algorithm_subtype ORDER BY explainability_score DESC) AS rank FROM ai_algorithms WHERE region = 'Europe') ranked WHERE rank <= 2 ORDER BY algorithm_subtype, region, explainability_score DESC;", "generated_sql": "SELECT algorithm_name, algorithm_subtype, explainability_score\nFROM ai_algorithms\nWHERE region = 'Europe'\nORDER BY algorithm_subtype, explainability_score DESC\nLIMIT 2;", "raw_model_output": "```sql\nSELECT algorithm_name, algorithm_subtype, explainability_score\nFROM ai_algorithms\nWHERE region = 'Europe'\nORDER BY algorithm_subtype, explainability_score DESC\nLIMIT 2;\n```", "latency_sec": 1.1151270866394043, "total_duration_sec": 1.038402484, "load_duration_sec": 0.013685965, "tokens_prompt": 266, "prompt_eval_sec": 0.059362038, "tokens_completion": 41, "completion_eval_sec": 0.962892615, "tokens_total": 307, "tokens_per_sec": 275.30494387432435, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL selects top 2 algorithms per algorithm_subtype (e.g., Tree-based, Computer Vision, Transformer) using RANK(), while the Generated SQL simply orders all Europe algorithms by subtype and score, then limits to 2 rows. This results in different rows: the Reference includes 4 rows (2 from Tree-based, 1 each from Computer Vision and Transformer), whereas the Generated includes only 2 rows (e.g., AlgoB and AlgoA). Additionally, column selections differ.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly addresses the requirement to find the top 2 algorithms per subtype using RANK() with PARTITION BY algorithm_subtype, ensuring per-group ranking. The Generated SQL incorrectly applies LIMIT 2 globally instead of per-subtype, failing to meet the business requirement. While the Generated SQL is more efficient, it fundamentally misinterprets the question by not grouping results by algorithm_subtype. The Reference SQL's use of window functions ensures semantic correctness for the specified business logic.", "overall_assessment": "differently_correct"}}
{"example_id": 4495, "sql_complexity": "basic SQL", "prompt": "Which countries are the top 3 sources of sustainable textiles?", "context": "CREATE TABLE Textile_Sources (Source_ID INT, Source_Country TEXT, Sustainable BOOLEAN, Quantity INT); INSERT INTO Textile_Sources (Source_ID, Source_Country, Sustainable, Quantity) VALUES (1, 'India', true, 1000), (2, 'Bangladesh', false, 800), (3, 'China', true, 1200), (4, 'Vietnam', false, 900), (5, 'Italy', true, 1100), (6, 'USA', false, 700);", "reference_sql": "SELECT Source_Country FROM Textile_Sources WHERE Sustainable = true ORDER BY Quantity DESC LIMIT 3;", "generated_sql": "SELECT Source_Country\nFROM Textile_Sources\nWHERE Sustainable = true\nORDER BY Quantity DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT Source_Country\nFROM Textile_Sources\nWHERE Sustainable = true\nORDER BY Quantity DESC\nLIMIT 3;\n```", "latency_sec": 1.0256702899932861, "total_duration_sec": 0.763465056, "load_duration_sec": 0.020838967, "tokens_prompt": 212, "prompt_eval_sec": 0.045051876, "tokens_completion": 30, "completion_eval_sec": 0.69468946, "tokens_total": 242, "tokens_per_sec": 235.94326789126757, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select Source_Country from Textile_Sources where Sustainable is true, order by Quantity descending, and limit to 3 results. The structure, conditions, and ordering logic are identical, producing the same result set.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure, logic, and output. They correctly filter sustainable textile sources (Sustainable = true), sort by Quantity in descending order, and limit results to the top 3 countries. The only difference is formatting (line breaks), which does not affect execution. Both accurately answer the business question by identifying the top 3 sustainable textile sources based on quantity.", "overall_assessment": "correct"}}
{"example_id": 2513, "sql_complexity": "single join", "prompt": "What is the total number of concert ticket sales for artists who released their first album between 2015 and 2017?", "context": "CREATE TABLE ConcertTicketSales (id INT, year INT, artist_id INT); CREATE TABLE ArtistAlbums (id INT, artist_id INT, year INT);", "reference_sql": "SELECT COUNT(DISTINCT cts.artist_id) FROM ConcertTicketSales cts JOIN ArtistAlbums a ON cts.artist_id = a.artist_id WHERE a.year BETWEEN 2015 AND 2017;", "generated_sql": "SELECT COUNT(*) AS total_sales\nFROM ConcertTicketSales cts\nJOIN (\n    SELECT artist_id, MIN(year) AS first_album_year\n    FROM ArtistAlbums\n    WHERE year BETWEEN 2015 AND 2017\n    GROUP BY artist_id\n) aa ON cts.artist_id = aa.artist_id;", "raw_model_output": "```sql\nSELECT COUNT(*) AS total_sales\nFROM ConcertTicketSales cts\nJOIN (\n    SELECT artist_id, MIN(year) AS first_album_year\n    FROM ArtistAlbums\n    WHERE year BETWEEN 2015 AND 2017\n    GROUP BY artist_id\n) aa ON cts.artist_id = aa.artist_id;\n```", "latency_sec": 1.7981147766113281, "total_duration_sec": 1.705640342, "load_duration_sec": 0.016018309, "tokens_prompt": 137, "prompt_eval_sec": 0.026982817, "tokens_completion": 74, "completion_eval_sec": 1.660306959, "tokens_total": 211, "tokens_per_sec": 117.34512320600808, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query counts distinct artist_ids from ConcertTicketSales that have at least one matching album in 2015-2017, while the generated query counts all rows from a join that includes multiple entries per artist (if they have multiple sales). The generated query uses COUNT(*) instead of COUNT(DISTINCT), leading to different results when artists have multiple sales records.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query incorrectly counts artists with *any* album between 2015-2017 (not their first album), while the generated query attempts to find first albums but mistakenly filters ArtistAlbums to only 2015-2017 before calculating MIN(year). Neither query correctly identifies artists whose *first* album was between 2015-2017. However, the generated query's use of MIN(year) better aligns with the business intent of finding first albums, even though its WHERE clause is flawed. The reference query's COUNT(DISTINCT) also fails to address the 'total sales' metric (which likely refers to ticket counts, not artist counts).", "overall_assessment": "differently_correct"}}
{"example_id": 873, "sql_complexity": "subqueries", "prompt": "Identify attorneys who have never handled cases in the 'West' region but have in the 'North' or 'South'.", "context": "CREATE TABLE attorney_regions(attorney_id INT, region VARCHAR(20)); INSERT INTO attorney_regions(attorney_id, region) VALUES (1, 'North'), (2, 'South'), (3, 'East'), (4, 'West'), (5, 'West'), (6, 'North'); CREATE TABLE handled_cases(attorney_id INT, case_id INT); INSERT INTO handled_cases(attorney_id, case_id) VALUES (1, 101), (2, 102), (3, 103), (4, 104), (5, 105), (6, 106), (1, 107), (1, 108);", "reference_sql": "SELECT h.attorney_id FROM attorney_regions h LEFT JOIN handled_cases i ON h.attorney_id = i.attorney_id WHERE h.region IN ('North', 'South') AND h.region != 'West' AND i.attorney_id IS NOT NULL AND h.attorney_id NOT IN (SELECT attorney_id FROM attorney_regions WHERE region = 'West');", "generated_sql": "SELECT ar.attorney_id\nFROM attorney_regions ar\nWHERE ar.region IN ('North', 'South')\nAND ar.attorney_id NOT IN (\n    SELECT hc.attorney_id\n    FROM handled_cases hc\n    JOIN attorney_regions ar2 ON hc.attorney_id = ar2.attorney_id\n    WHERE ar2.region = 'West'\n);", "raw_model_output": "```sql\nSELECT ar.attorney_id\nFROM attorney_regions ar\nWHERE ar.region IN ('North', 'South')\nAND ar.attorney_id NOT IN (\n    SELECT hc.attorney_id\n    FROM handled_cases hc\n    JOIN attorney_regions ar2 ON hc.attorney_id = ar2.attorney_id\n    WHERE ar2.region = 'West'\n);\n```", "latency_sec": 2.0260889530181885, "total_duration_sec": 1.803990111, "load_duration_sec": 0.014870197, "tokens_prompt": 252, "prompt_eval_sec": 0.052604109, "tokens_completion": 75, "completion_eval_sec": 1.734353146, "tokens_total": 327, "tokens_per_sec": 161.39469074784716, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a condition (i.attorney_id IS NOT NULL) to ensure the attorney has at least one case, while the Generated SQL does not enforce this. Additionally, the Reference SQL's subquery checks for attorneys in the West region (regardless of cases), whereas the Generated SQL's subquery only includes West region attorneys with cases. This leads to different result sets.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The Reference SQL correctly identifies attorneys who have handled cases in North/South regions (via region IN ('North', 'South')) and excludes those with any West region cases (via NOT IN subquery). It also ensures the attorney has at least one case (i.attorney_id IS NOT NULL). The Generated SQL incorrectly assumes that 'region IN ('North', 'South')' implies case handling in those regions, but it lacks a direct check for actual case handling in North/South. While both queries exclude West region cases, the Reference SQL explicitly verifies case existence, making it more aligned with the business intent.", "overall_assessment": "correct"}}
{"example_id": 471, "sql_complexity": "set operations", "prompt": "Find the number of donations made by first-time donors in the last quarter.", "context": "CREATE TABLE Donations (DonationID INT, DonorID INT, DonationDate DATE, DonationType TEXT, DonationAmount FLOAT); INSERT INTO Donations (DonationID, DonorID, DonationDate, DonationType, DonationAmount) VALUES (1, 1, '2021-01-01', 'Individual', 100), (2, 2, '2021-02-01', 'Corporate', 5000);", "reference_sql": "SELECT COUNT(*) FROM (SELECT DonationID FROM Donations WHERE DonationType = 'Individual' AND DonationDate >= DATEADD(quarter, -1, CURRENT_DATE) EXCEPT SELECT DonationID FROM PreviousDonations) AS FirstTimeDonors;", "generated_sql": "SELECT COUNT(*) AS NumberOfFirstTimeDonations\nFROM Donations d1\nWHERE DonationDate >= DATE_TRUNC('quarter', CURRENT_DATE) - INTERVAL '3 months'\n  AND NOT EXISTS (\n    SELECT 1\n    FROM Donations d2\n    WHERE d2.DonorID = d1.DonorID\n      AND d2.DonationDate < DATE_TRUNC('quarter', CURRENT_DATE) - INTERVAL '3 months'\n  );", "raw_model_output": "```sql\nSELECT COUNT(*) AS NumberOfFirstTimeDonations\nFROM Donations d1\nWHERE DonationDate >= DATE_TRUNC('quarter', CURRENT_DATE) - INTERVAL '3 months'\n  AND NOT EXISTS (\n    SELECT 1\n    FROM Donations d2\n    WHERE d2.DonorID = d1.DonorID\n      AND d2.DonationDate < DATE_TRUNC('quarter', CURRENT_DATE) - INTERVAL '3 months'\n  );\n```", "latency_sec": 2.231602907180786, "total_duration_sec": 2.193080309, "load_duration_sec": 0.015193534, "tokens_prompt": 194, "prompt_eval_sec": 0.040544667, "tokens_completion": 94, "completion_eval_sec": 2.134321928, "tokens_total": 288, "tokens_per_sec": 129.0552181453439, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in logic and structure. The Reference SQL references a non-existent 'PreviousDonations' table, making it invalid. The Generated SQL correctly identifies first-time donations by checking for donors with no prior donations using NOT EXISTS. Even if 'PreviousDonations' were a typo for 'Donations', the EXCEPT operator would not reliably replicate the NOT EXISTS logic for first-time donors. Additionally, date calculations differ (DATEADD vs. DATE_TRUNC).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL contains a critical error by referencing a non-existent 'PreviousDonations' table, making it technically invalid. The Generated SQL correctly identifies first-time donors by checking for absence of prior donations before the last quarter using NOT EXISTS. Both queries aim to count donations from first-time donors in the last quarter, but the Generated SQL properly handles date calculations (DATE_TRUNC and INTERVAL) and avoids invalid table references. The Reference SQL's use of DATEADD(quarter, -1, CURRENT_DATE) may also be DBMS-specific and less standard than the Generated SQL's approach. The Generated SQL better fulfills the business intent with valid logic and syntax.", "overall_assessment": "differently_correct"}}
{"example_id": 1301, "sql_complexity": "multiple_joins", "prompt": "What is the total quantity of corn sold by farmers in 'Summerfield'?", "context": "CREATE TABLE farmers (id INT, name VARCHAR(50), location VARCHAR(50), crops VARCHAR(50)); CREATE TABLE crops (id INT, name VARCHAR(50), yield INT); CREATE TABLE sales (id INT, farmer_id INT, crop_name VARCHAR(50), quantity INT, price DECIMAL(5,2)); INSERT INTO farmers VALUES (1, 'Jane Doe', 'Summerfield', 'Corn'); INSERT INTO crops VALUES (1, 'Corn', 100); INSERT INTO sales VALUES (1, 1, 'Corn', 50, 2.50);", "reference_sql": "SELECT SUM(quantity) FROM sales INNER JOIN farmers ON sales.farmer_id = farmers.id INNER JOIN crops ON sales.crop_name = crops.name WHERE farmers.location = 'Summerfield' AND crops.name = 'Corn';", "generated_sql": "SELECT SUM(quantity) AS total_quantity_sold\nFROM sales\nJOIN farmers ON sales.farmer_id = farmers.id\nWHERE farmers.location = 'Summerfield' AND sales.crop_name = 'Corn';", "raw_model_output": "```sql\nSELECT SUM(quantity) AS total_quantity_sold\nFROM sales\nJOIN farmers ON sales.farmer_id = farmers.id\nWHERE farmers.location = 'Summerfield' AND sales.crop_name = 'Corn';\n```", "latency_sec": 1.214996099472046, "total_duration_sec": 1.115626886, "load_duration_sec": 0.020649718, "tokens_prompt": 218, "prompt_eval_sec": 0.044192584, "tokens_completion": 45, "completion_eval_sec": 1.048679938, "tokens_total": 263, "tokens_per_sec": 216.4616002588665, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of quantities from sales where the farmer is from 'Summerfield' and the crop is 'Corn'. The Reference SQL joins with the crops table but filters on crops.name = 'Corn', which is equivalent to filtering sales.crop_name = 'Corn' directly in the Generated SQL. Since the sales.crop_name is linked to crops.name, the final result remains the same.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the total corn quantity sold by Summerfield farmers. The reference query includes an unnecessary join to the 'crops' table (since sales.crop_name = 'Corn' already satisfies the condition), while the generated query simplifies the logic by directly filtering on sales.crop_name. The generated query is more efficient due to fewer joins and achieves the same result. Both are technically correct and fulfill the business intent, but the generated query is more elegant and efficient.", "overall_assessment": "correct"}}
{"example_id": 4667, "sql_complexity": "aggregation", "prompt": "Find the number of unique organizations in each country in the Philanthropy Trends table?", "context": "CREATE TABLE PhilanthropyTrends (OrgID INT, Name TEXT, Country TEXT);", "reference_sql": "SELECT Country, COUNT(DISTINCT OrgID) as UniqueOrganizations FROM PhilanthropyTrends GROUP BY Country;", "generated_sql": "SELECT Country, COUNT(DISTINCT OrgID) AS UniqueOrganizations\nFROM PhilanthropyTrends\nGROUP BY Country;", "raw_model_output": "```sql\nSELECT Country, COUNT(DISTINCT OrgID) AS UniqueOrganizations\nFROM PhilanthropyTrends\nGROUP BY Country;\n```", "latency_sec": 0.8296999931335449, "total_duration_sec": 0.733963279, "load_duration_sec": 0.0176616, "tokens_prompt": 111, "prompt_eval_sec": 0.023246696, "tokens_completion": 31, "completion_eval_sec": 0.690127467, "tokens_total": 142, "tokens_per_sec": 171.14619883713112, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select the 'Country' column, count distinct 'OrgID' values, and group by 'Country'. The differences are purely syntactic (line breaks and keyword casing) and do not affect the semantic meaning.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are syntactically identical except for formatting differences (e.g., line breaks and capitalization). They both correctly group by 'Country' and count distinct 'OrgID' values to calculate unique organizations per country. The business intent of aggregating unique organizations by geographic region is fully satisfied by both. Neither query demonstrates superior efficiency or elegance as they execute the same logical operations with identical structure.", "overall_assessment": "correct"}}
{"example_id": 1006, "sql_complexity": "subqueries", "prompt": "What is the average word count of news articles written by investigative journalists?", "context": "CREATE TABLE reporters (id INT, name VARCHAR(50), gender VARCHAR(10), age INT, position VARCHAR(20), country VARCHAR(50)); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (1, 'Anna Smith', 'Female', 35, 'News Reporter', 'USA'); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (2, 'Mike Johnson', 'Male', 40, 'Investigative Journalist', 'Canada'); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (3, 'Sofia Rodriguez', 'Female', 32, 'Investigative Journalist', 'Mexico'); CREATE TABLE news_articles (id INT, title VARCHAR(100), content TEXT, publication_date DATE, reporter_id INT); INSERT INTO news_articles (id, title, content, publication_date, reporter_id) VALUES (1, 'News Article 1', 'Content of News Article 1', '2021-01-01', 2); INSERT INTO news_articles (id, title, content, publication_date, reporter_id) VALUES (2, 'News Article 2', 'Content of News Article 2', '2021-02-01', 3);", "reference_sql": "SELECT AVG(LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1) AS avg_word_count FROM news_articles WHERE reporter_id IN (SELECT id FROM reporters WHERE position = 'Investigative Journalist');", "generated_sql": "SELECT AVG(LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1) AS average_word_count\nFROM news_articles\nJOIN reporters ON news_articles.reporter_id = reporters.id\nWHERE reporters.position = 'Investigative Journalist';", "raw_model_output": "```sql\nSELECT AVG(LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1) AS average_word_count\nFROM news_articles\nJOIN reporters ON news_articles.reporter_id = reporters.id\nWHERE reporters.position = 'Investigative Journalist';\n```", "latency_sec": 1.783790111541748, "total_duration_sec": 1.474656202, "load_duration_sec": 0.01532431, "tokens_prompt": 372, "prompt_eval_sec": 0.086169663, "tokens_completion": 57, "completion_eval_sec": 1.370538459, "tokens_total": 429, "tokens_per_sec": 240.49914685826514, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average word count of news articles written by investigative journalists. The Reference SQL uses a subquery to filter reporter_ids, while the Generated SQL uses a JOIN. Both achieve the same result by restricting to reporters with 'Investigative Journalist' position and applying the same word count formula. The logical outcome is identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the average word count of articles by investigative journalists using the same word-counting logic (length difference between content and space-removed content). The reference query uses a subquery with `IN`, while the generated query uses an explicit `JOIN`, which is more efficient and readable. The generated version directly filters reporters via the join condition, avoiding potential subquery overhead. Both address the business intent, but the generated query is more elegant and efficient.", "overall_assessment": "correct"}}
{"example_id": 3635, "sql_complexity": "set operations", "prompt": "Which brands have certifications related to cruelty-free, vegan, or organic products?", "context": "CREATE TABLE brands (brand_name VARCHAR(50), is_cruelty_free BOOLEAN, is_vegan BOOLEAN, is_organic BOOLEAN); INSERT INTO brands (brand_name, is_cruelty_free, is_vegan, is_organic) VALUES ('Lush', TRUE, TRUE, FALSE), ('The Body Shop', TRUE, FALSE, FALSE), ('Est\u00e9e Lauder', FALSE, FALSE, FALSE), ('Urban Decay', TRUE, TRUE, FALSE), ('Maybelline', FALSE, FALSE, FALSE), ('Kat Von D', TRUE, TRUE, FALSE), ('Tarte', TRUE, TRUE, TRUE);", "reference_sql": "SELECT brand_name, 'Cruelty-free' as certification FROM brands WHERE is_cruelty_free = TRUE UNION SELECT brand_name, 'Vegan' as certification FROM brands WHERE is_vegan = TRUE UNION SELECT brand_name, 'Organic' as certification FROM brands WHERE is_organic = TRUE;", "generated_sql": "SELECT brand_name \nFROM brands \nWHERE is_cruelty_free = TRUE OR is_vegan = TRUE OR is_organic = TRUE;", "raw_model_output": "```sql\nSELECT brand_name \nFROM brands \nWHERE is_cruelty_free = TRUE OR is_vegan = TRUE OR is_organic = TRUE;\n```", "latency_sec": 1.0503580570220947, "total_duration_sec": 0.847746407, "load_duration_sec": 0.013821296, "tokens_prompt": 218, "prompt_eval_sec": 0.045752707, "tokens_completion": 34, "completion_eval_sec": 0.785048888, "tokens_total": 252, "tokens_per_sec": 239.91818629397068, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns brand names with their corresponding certification type (Cruelty-free/Vegan/Organic) as separate rows, while the Generated SQL only returns brand names that meet any of the conditions without indicating which certification they qualify for. The output structures differ: the first has two columns (brand_name, certification) and may include multiple rows per brand, while the second has one column (brand_name) with unique entries. For example, a brand meeting multiple criteria would appear once in Generated SQL but multiple times in Reference SQL.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query returns each brand once per certification type (e.g., a brand with multiple certifications appears multiple times), while the generated query returns each brand only once regardless of how many certifications they have. Both are syntactically correct, but the generated query better fulfills the business intent of identifying brands with any of the certifications. The generated query is more efficient as it uses a single SELECT with OR conditions instead of three UNIONed queries. The reference query provides more granular certification details but the original question only asks for brands, not specific certification types.", "overall_assessment": "differently_correct"}}
{"example_id": 4932, "sql_complexity": "basic SQL", "prompt": "Delete the workout row with the id of 2.", "context": "CREATE TABLE Workouts (id INT, user_id INT, workout_name TEXT, calories INT); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (1, 1, 'Running', 300); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (2, 1, 'Cycling', 400); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (3, 2, 'Yoga', 200);", "reference_sql": "DELETE FROM Workouts WHERE id = 2;", "generated_sql": "DELETE FROM Workouts WHERE id = 2;", "raw_model_output": "```sql\nDELETE FROM Workouts WHERE id = 2;\n```", "latency_sec": 0.6142888069152832, "total_duration_sec": 0.420505806, "load_duration_sec": 0.016339403, "tokens_prompt": 198, "prompt_eval_sec": 0.043510875, "tokens_completion": 15, "completion_eval_sec": 0.35828796, "tokens_total": 213, "tokens_per_sec": 346.74244036710064, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They both delete the record from the Workouts table where the id is 2. The SQL syntax, table name, and WHERE condition are exactly the same in both queries.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in syntax, logic, and effect. They correctly delete the row with id=2 from the Workouts table as required. The WHERE clause precisely targets the specific workout row, ensuring no other records are affected. Both queries are equally efficient, elegant, and fulfill the business intent of removing the specified workout entry.", "overall_assessment": "correct"}}
{"example_id": 365, "sql_complexity": "aggregation", "prompt": "Identify the total number of military personnel and their corresponding rank for each branch and country in the 'military_personnel' table, sorted by the total number of personnel in descending order.", "context": "CREATE TABLE military_personnel (id INT, branch VARCHAR(255), rank VARCHAR(255), country VARCHAR(255), personnel INT);", "reference_sql": "SELECT branch, country, SUM(personnel) as total_personnel FROM military_personnel GROUP BY branch, country ORDER BY total_personnel DESC;", "generated_sql": "SELECT \n    branch, \n    country, \n    rank, \n    SUM(personnel) AS total_personnel\nFROM \n    military_personnel\nGROUP BY \n    branch, \n    country, \n    rank\nORDER BY \n    total_personnel DESC;", "raw_model_output": "```sql\nSELECT \n    branch, \n    country, \n    rank, \n    SUM(personnel) AS total_personnel\nFROM \n    military_personnel\nGROUP BY \n    branch, \n    country, \n    rank\nORDER BY \n    total_personnel DESC;\n```", "latency_sec": 1.5721750259399414, "total_duration_sec": 1.377005369, "load_duration_sec": 0.014029435, "tokens_prompt": 147, "prompt_eval_sec": 0.029325373, "tokens_completion": 59, "completion_eval_sec": 1.330876663, "tokens_total": 206, "tokens_per_sec": 131.0286683105405, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The generated query includes an additional 'rank' column in both the SELECT and GROUP BY clauses, which changes the aggregation granularity. The reference query groups by only 'branch' and 'country', while the generated query groups by 'branch', 'country', and 'rank', leading to different result sets.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly groups by branch and country to calculate total personnel per combination, while the Generated SQL incorrectly adds 'rank' to the GROUP BY clause, which would split results by rank instead of aggregating across all ranks. The original question asks for 'total number of military personnel and their corresponding rank' but this phrasing is ambiguous. However, the Reference SQL aligns with the explicit request for 'each branch and country' (without rank in grouping), whereas the Generated SQL violates this by including rank in the grouping. The Reference SQL is more efficient and semantically matches the question's structure, despite potential ambiguity in the original phrasing.", "overall_assessment": "differently_correct"}}
{"example_id": 521, "sql_complexity": "subqueries", "prompt": "How many vessels have not had an inspection in the past year?", "context": "CREATE TABLE safety_records(id INT, vessel_name VARCHAR(50), inspection_date DATE); CREATE TABLE vessels(id INT, name VARCHAR(50), country VARCHAR(50)); INSERT INTO vessels(id, name, country) VALUES (1, 'Vessel A', 'Philippines'), (2, 'Vessel B', 'Philippines'); INSERT INTO safety_records(id, vessel_name, inspection_date) VALUES (1, 'Vessel A', '2022-01-01');", "reference_sql": "SELECT COUNT(*) FROM vessels WHERE name NOT IN (SELECT vessel_name FROM safety_records WHERE inspection_date BETWEEN DATE_SUB(NOW(), INTERVAL 1 YEAR) AND NOW());", "generated_sql": "SELECT COUNT(*) \nFROM vessels v\nWHERE NOT EXISTS (\n    SELECT 1 \n    FROM safety_records sr \n    WHERE sr.vessel_name = v.name \n      AND sr.inspection_date >= DATEADD(year, -1, CURRENT_DATE)\n);", "raw_model_output": "```sql\nSELECT COUNT(*) \nFROM vessels v\nWHERE NOT EXISTS (\n    SELECT 1 \n    FROM safety_records sr \n    WHERE sr.vessel_name = v.name \n      AND sr.inspection_date >= DATEADD(year, -1, CURRENT_DATE)\n);\n```", "latency_sec": 1.5728659629821777, "total_duration_sec": 1.324189945, "load_duration_sec": 0.015441402, "tokens_prompt": 192, "prompt_eval_sec": 0.035057386, "tokens_completion": 56, "completion_eval_sec": 1.271336893, "tokens_total": 248, "tokens_per_sec": 157.6739568639328, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count vessels that do not have an inspection in the last year. The Reference SQL uses NOT IN with a subquery checking inspection_date between one year ago and now. The Generated SQL uses NOT EXISTS with a subquery checking inspection_date >= one year ago. The date conditions are equivalent because inspection_date cannot be in the future, making the upper bound implicit. Both approaches exclude vessels with recent inspections, and the NOT IN/NOT EXISTS logic is equivalent here since the subquery returns non-null values.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify vessels without inspections in the past year. The reference query uses NOT IN with DATE_SUB(NOW(), INTERVAL 1 YEAR) while the generated query uses NOT EXISTS with DATEADD(year, -1, CURRENT_DATE). The date logic is functionally equivalent (both capture the last 365 days) but the generated query's use of CURRENT_DATE (date-only) is more precise than NOW() (datetime) which could introduce edge cases. NOT EXISTS is generally more reliable than NOT IN for handling potential NULLs. The generated query also uses explicit table aliases and avoids potential subquery NULL issues, making it more robust and efficient.", "overall_assessment": "correct"}}
{"example_id": 5687, "sql_complexity": "multiple_joins", "prompt": "List organizations with more than 200 volunteers, and their average donation amounts, excluding donations less than $10.", "context": "CREATE TABLE organizations (org_id INT, org_name TEXT, social_impact_score INT);CREATE TABLE volunteers (vol_id INT, org_id INT, vol_country TEXT);CREATE TABLE donations (donation_id INT, donor_id INT, donation_amount INT, donation_date DATE);", "reference_sql": "SELECT o.org_name, AVG(donation_amount) AS avg_donation_amount FROM organizations o JOIN volunteers v ON o.org_id = v.org_id JOIN donations don ON o.org_id = don.org_id WHERE donation_amount >= 10 GROUP BY o.org_name HAVING COUNT(v.vol_id) > 200;", "generated_sql": "SELECT \n    o.org_name,\n    AVG(d.donation_amount) AS avg_donation_amount\nFROM \n    organizations o\nJOIN \n    volunteers v ON o.org_id = v.org_id\nLEFT JOIN \n    donations d ON o.org_id = d.donor_id AND d.donation_amount >= 10\nGROUP BY \n    o.org_name\nHAVING \n    COUNT(v.vol_id) > 200;", "raw_model_output": "```sql\nSELECT \n    o.org_name,\n    AVG(d.donation_amount) AS avg_donation_amount\nFROM \n    organizations o\nJOIN \n    volunteers v ON o.org_id = v.org_id\nLEFT JOIN \n    donations d ON o.org_id = d.donor_id AND d.donation_amount >= 10\nGROUP BY \n    o.org_name\nHAVING \n    COUNT(v.vol_id) > 200;\n```", "latency_sec": 2.264986991882324, "total_duration_sec": 2.16717305, "load_duration_sec": 0.015498447, "tokens_prompt": 156, "prompt_eval_sec": 0.029694604, "tokens_completion": 93, "completion_eval_sec": 2.119755468, "tokens_total": 249, "tokens_per_sec": 109.93440619853972, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two critical aspects. First, the Reference SQL joins donations on `o.org_id = don.org_id` (which is invalid per the schema, as donations lacks an `org_id` column), while the Generated SQL uses `o.org_id = d.donor_id` (which may be valid but semantically different). Second, the Generated SQL uses a LEFT JOIN with the `donation_amount >= 10` condition in the ON clause, whereas the Reference SQL uses an INNER JOIN with the condition in the WHERE clause. These differences in join type and column usage lead to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "equal", "explanation": "Both queries have critical technical flaws. The Reference SQL incorrectly joins donations on `org_id` (which doesn't exist in the donations table) and uses an implicit INNER JOIN that would exclude organizations with no donations. The Generated SQL incorrectly joins donations on `donor_id = org_id` (assuming a non-existent relationship between donors and organizations) and uses a LEFT JOIN that could include organizations with no qualifying donations. Neither query correctly links donations to organizations through the volunteer table, which is necessary to associate donations with organizations via volunteers. Both fail to address the business intent of calculating average donations for organizations with >200 volunteers, as their join logic is fundamentally flawed.", "overall_assessment": "incorrect"}}
{"example_id": 1281, "sql_complexity": "subqueries", "prompt": "Find the top 3 contributors with the lowest recycling rate in the 'waste_contributors' table.", "context": "CREATE TABLE waste_contributors (contributor VARCHAR(20), recycling_rate FLOAT); INSERT INTO waste_contributors (contributor, recycling_rate) VALUES ('Manufacturing', 0.4), ('Commercial', 0.38), ('Residential', 0.35), ('Institutional', 0.32), ('Agricultural', 0.2), ('Industrial', 0.15);", "reference_sql": "SELECT contributor FROM waste_contributors WHERE recycling_rate IN (SELECT MIN(recycling_rate) FROM waste_contributors) LIMIT 3;", "generated_sql": "SELECT contributor, recycling_rate\nFROM waste_contributors\nORDER BY recycling_rate ASC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT contributor, recycling_rate\nFROM waste_contributors\nORDER BY recycling_rate ASC\nLIMIT 3;\n```", "latency_sec": 1.1534337997436523, "total_duration_sec": 0.673366015, "load_duration_sec": 0.033620897, "tokens_prompt": 185, "prompt_eval_sec": 0.039996637, "tokens_completion": 26, "completion_eval_sec": 0.596465273, "tokens_total": 211, "tokens_per_sec": 182.9320417408387, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL selects contributors with the minimum recycling rate (only 'Industrial' in the data), while the Generated SQL returns the top 3 contributors with the lowest recycling rates (Industrial, Agricultural, Institutional). The first query filters for the absolute minimum value, whereas the second orders all rows and limits to 3, producing different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query incorrectly uses WHERE recycling_rate IN (SELECT MIN(...)) which only returns contributors with the absolute minimum recycling rate (e.g., 'Industrial' in the sample data), not the top 3 lowest rates. It also lacks a LIMIT 3 clause in the outer query. The generated query properly sorts by recycling_rate ASC and explicitly limits to 3 results, correctly identifying the three contributors with the lowest rates (Industrial, Agricultural, Institutional). The generated query is both technically correct and semantically aligned with the business intent.", "overall_assessment": "differently_correct"}}
{"example_id": 5669, "sql_complexity": "window functions", "prompt": "What is the total number of new and returning volunteers in each program in each month?", "context": "CREATE TABLE Volunteers (VolunteerID INT, VolunteerName TEXT, ProgramID INT, VolunteerDate DATE, IsReturning BOOLEAN); INSERT INTO Volunteers (VolunteerID, VolunteerName, ProgramID, VolunteerDate, IsReturning) VALUES (6, 'David Kim', 1, '2022-03-01', FALSE), (7, 'Emily Chen', 2, '2022-03-15', TRUE), (8, 'James Lee', 2, '2022-04-01', FALSE), (9, 'Grace Park', 3, '2022-04-15', TRUE), (10, 'Daniel Kim', 1, '2022-04-01', FALSE);", "reference_sql": "SELECT ProgramID, EXTRACT(MONTH FROM VolunteerDate) AS Month, SUM(CASE WHEN IsReturning THEN 1 ELSE 0 END) OVER (PARTITION BY ProgramID, EXTRACT(MONTH FROM VolunteerDate) ORDER BY ProgramID, EXTRACT(MONTH FROM VolunteerDate)) + COUNT(DISTINCT VolunteerID) OVER (PARTITION BY ProgramID, EXTRACT(MONTH FROM VolunteerDate) ORDER BY ProgramID, EXTRACT(MONTH FROM VolunteerDate)) AS TotalVolunteers FROM Volunteers;", "generated_sql": "SELECT \n    ProgramID,\n    EXTRACT(YEAR FROM VolunteerDate) AS Year,\n    EXTRACT(MONTH FROM VolunteerDate) AS Month,\n    SUM(CASE WHEN IsReturning = FALSE THEN 1 ELSE 0 END) AS NewVolunteers,\n    SUM(CASE WHEN IsReturning = TRUE THEN 1 ELSE 0 END) AS ReturningVolunteers\nFROM \n    Volunteers\nGROUP BY \n    ProgramID, Year, Month\nORDER BY \n    ProgramID, Year, Month;", "raw_model_output": "```sql\nSELECT \n    ProgramID,\n    EXTRACT(YEAR FROM VolunteerDate) AS Year,\n    EXTRACT(MONTH FROM VolunteerDate) AS Month,\n    SUM(CASE WHEN IsReturning = FALSE THEN 1 ELSE 0 END) AS NewVolunteers,\n    SUM(CASE WHEN IsReturning = TRUE THEN 1 ELSE 0 END) AS ReturningVolunteers\nFROM \n    Volunteers\nGROUP BY \n    ProgramID, Year, Month\nORDER BY \n    ProgramID, Year, Month;\n```", "latency_sec": 2.831333875656128, "total_duration_sec": 2.535493337, "load_duration_sec": 0.01397359, "tokens_prompt": 260, "prompt_eval_sec": 0.054278933, "tokens_completion": 107, "completion_eval_sec": 2.464936623, "tokens_total": 367, "tokens_per_sec": 129.62088404884858, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL uses window functions to calculate a cumulative 'TotalVolunteers' by adding returning volunteers and distinct volunteer counts, without grouping, and only extracts the month. The Generated SQL groups by ProgramID, Year, and Month, separating new and returning volunteers into distinct columns. Differences in aggregation logic, grouping, and output columns (year vs. month-only) ensure they produce different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is technically flawed and fails to address the business question. It incorrectly uses window functions to combine 'Returning' counts with 'TotalVolunteers' (which appears to be a misinterpretation of the requirement). It also omits the year from the date, risking incorrect aggregation across multiple years. The Generated SQL correctly separates new and returning volunteers using explicit CASE statements, groups by ProgramID, Year, and Month (ensuring accurate temporal aggregation), and directly answers the question by providing both metrics. While the Reference SQL might produce syntactically valid output, it does not fulfill the business intent of distinguishing new vs. returning volunteers. The Generated SQL is more efficient, semantically precise, and structurally correct.", "overall_assessment": "differently_correct"}}
{"example_id": 3576, "sql_complexity": "window functions", "prompt": "What is the difference in the number of eco-friendly hotels between the top 2 countries?", "context": "CREATE TABLE eco_hotel_count (country TEXT, num_hotels INT); INSERT INTO eco_hotel_count (country, num_hotels) VALUES ('France', 100), ('Italy', 120), ('Germany', 150), ('Spain', 110), ('UK', 160);", "reference_sql": "SELECT (MAX(num_hotels) OVER (PARTITION BY num_hotels <= 2) - MIN(num_hotels) OVER (PARTITION BY num_hotels <= 2)) AS hotel_difference FROM eco_hotel_count WHERE country IN ('France', 'Italy');", "generated_sql": "SELECT \n    (MAX(num_hotels) - MIN(num_hotels)) AS hotel_difference\nFROM \n    eco_hotel_count;", "raw_model_output": "```sql\nSELECT \n    (MAX(num_hotels) - MIN(num_hotels)) AS hotel_difference\nFROM \n    eco_hotel_count;\n```", "latency_sec": 0.8804562091827393, "total_duration_sec": 0.771182964, "load_duration_sec": 0.014771764, "tokens_prompt": 163, "prompt_eval_sec": 0.030770612, "tokens_completion": 32, "completion_eval_sec": 0.723390121, "tokens_total": 195, "tokens_per_sec": 221.47609156053736, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters to only 'France' and 'Italy' rows, calculates MAX/MIN within a partition where num_hotels <= 2 (which is false for all values, creating a single partition), resulting in 120-100=20 per row (2 rows). The Generated SQL computes MAX-MIN across all rows (160-100=60) as a single value. Results differ in both value (20 vs 60) and row count (2 rows vs 1 row).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is fundamentally flawed: it filters only France and Italy (not the top 2 countries) and uses incorrect window function logic (PARTITION BY num_hotels <= 2, which doesn't identify top values). The Generated SQL calculates MAX(num_hotels) - MIN(num_hotels) across all countries, which incorrectly compares the highest and lowest values (e.g., 160-100=60) instead of the top 2 values (160-150=10). Neither query correctly identifies the top 2 countries, but the Generated SQL at least considers the full dataset rather than a subset. The Reference SQL fails more severely by misidentifying the countries and using invalid window functions.", "overall_assessment": "incorrect"}}
{"example_id": 1970, "sql_complexity": "multiple_joins", "prompt": "List all players who have played a specific VR game, 'CyberSphere', and their ages.", "context": "CREATE TABLE Players (PlayerID INT, Age INT, Gender VARCHAR(10), Country VARCHAR(50)); CREATE TABLE VRPlayers (PlayerID INT, VRGameID INT); CREATE TABLE VRGames (VRGameID INT, Title VARCHAR(50)); INSERT INTO Players (PlayerID, Age, Gender, Country) VALUES (1, 25, 'Male', 'USA'); INSERT INTO Players (PlayerID, Age, Gender, Country) VALUES (2, 28, 'Female', 'Canada'); INSERT INTO VRPlayers (PlayerID, VRGameID) VALUES (1, 1); INSERT INTO VRPlayers (PlayerID, VRGameID) VALUES (2, 1); INSERT INTO VRGames (VRGameID, Title) VALUES (1, 'CyberSphere');", "reference_sql": "SELECT Players.Age, Players.PlayerID FROM Players INNER JOIN VRPlayers ON Players.PlayerID = VRPlayers.PlayerID INNER JOIN VRGames ON VRPlayers.VRGameID = VRGames.VRGameID WHERE VRGames.Title = 'CyberSphere';", "generated_sql": "SELECT P.PlayerID, P.Age\nFROM Players P\nJOIN VRPlayers VP ON P.PlayerID = VP.PlayerID\nJOIN VRGames VG ON VP.VRGameID = VG.VRGameID\nWHERE VG.Title = 'CyberSphere';", "raw_model_output": "```sql\nSELECT P.PlayerID, P.Age\nFROM Players P\nJOIN VRPlayers VP ON P.PlayerID = VP.PlayerID\nJOIN VRGames VG ON VP.VRGameID = VG.VRGameID\nWHERE VG.Title = 'CyberSphere';\n```", "latency_sec": 1.6931791305541992, "total_duration_sec": 1.38780615, "load_duration_sec": 0.028307062, "tokens_prompt": 261, "prompt_eval_sec": 0.056310731, "tokens_completion": 56, "completion_eval_sec": 1.300612295, "tokens_total": 317, "tokens_per_sec": 187.2217736916246, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same data by joining the same tables with identical conditions. The generated query uses table aliases and reverses the column order in the SELECT clause, but these are syntactic variations that do not affect semantic equivalence. The join types (INNER JOIN vs JOIN) and filter conditions are identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent as they produce identical results by joining the same tables with equivalent conditions and filtering on 'CyberSphere'. The reference query uses explicit table names while the generated query uses aliases, but this does not affect functionality. Both select the required PlayerID and Age columns. The business intent is fully fulfilled by identifying players associated with the specific VR game. The generated query's use of aliases improves readability without sacrificing clarity, but neither query has significant efficiency advantages over the other.", "overall_assessment": "correct"}}
{"example_id": 2414, "sql_complexity": "window functions", "prompt": "List the policy areas with the lowest citizen satisfaction scores.", "context": "CREATE TABLE Policy (Area VARCHAR(20), Score INT); INSERT INTO Policy (Area, Score) VALUES ('Transportation', 70), ('Education', 85), ('Healthcare', 75), ('PublicSafety', 80);", "reference_sql": "SELECT Area, Score FROM (SELECT Area, Score, ROW_NUMBER() OVER (ORDER BY Score) AS RN FROM Policy) X WHERE RN IN (1, 2);", "generated_sql": "SELECT Area \nFROM Policy \nORDER BY Score ASC \nLIMIT 1;", "raw_model_output": "```sql\nSELECT Area \nFROM Policy \nORDER BY Score ASC \nLIMIT 1;\n```", "latency_sec": 0.6890740394592285, "total_duration_sec": 0.492798827, "load_duration_sec": 0.013692374, "tokens_prompt": 140, "prompt_eval_sec": 0.027520926, "tokens_completion": 20, "completion_eval_sec": 0.448950591, "tokens_total": 160, "tokens_per_sec": 232.19565799571376, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two rows (top 2 lowest Scores) with both Area and Score columns, while the Generated SQL returns only one row (lowest Score) with just the Area column. The number of rows and selected columns differ, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly identifies the two lowest scores using ROW_NUMBER(), aligning with the plural 'scores' in the question. The Generated SQL only returns a single result, which may not fully address the intent of identifying multiple low scores. While both queries are technically valid, the Reference SQL better fulfills the business intent by retrieving the top two lowest scores. The Generated SQL is simpler but fails to account for potential ties or multiple low scores, making it less comprehensive.", "overall_assessment": "differently_correct"}}
{"example_id": 1898, "sql_complexity": "single join", "prompt": "What are the total sales for each drug in Q2 2020?", "context": "CREATE TABLE drugs (drug_id INT, drug_name TEXT); INSERT INTO drugs (drug_id, drug_name) VALUES (1001, 'Ibuprofen'), (1002, 'Paracetamol'), (1003, 'Aspirin'); CREATE TABLE sales (sale_id INT, drug_id INT, sale_date DATE, revenue FLOAT); INSERT INTO sales (sale_id, drug_id, sale_date, revenue) VALUES (1, 1001, '2020-04-05', 1800.0), (2, 1002, '2020-04-10', 2300.0), (3, 1003, '2020-04-15', 1400.0), (4, 1001, '2020-05-20', 1900.0), (5, 1002, '2020-06-25', 2400.0);", "reference_sql": "SELECT drug_name, SUM(revenue) as total_sales FROM sales JOIN drugs ON sales.drug_id = drugs.drug_id WHERE sale_date BETWEEN '2020-04-01' AND '2020-06-30' GROUP BY drug_name;", "generated_sql": "SELECT d.drug_name, SUM(s.revenue) AS total_sales\nFROM drugs d\nJOIN sales s ON d.drug_id = s.drug_id\nWHERE s.sale_date BETWEEN '2020-04-01' AND '2020-06-30'\nGROUP BY d.drug_name;", "raw_model_output": "```sql\nSELECT d.drug_name, SUM(s.revenue) AS total_sales\nFROM drugs d\nJOIN sales s ON d.drug_id = s.drug_id\nWHERE s.sale_date BETWEEN '2020-04-01' AND '2020-06-30'\nGROUP BY d.drug_name;\n```", "latency_sec": 1.956270694732666, "total_duration_sec": 1.861492888, "load_duration_sec": 0.013740369, "tokens_prompt": 331, "prompt_eval_sec": 0.077011949, "tokens_completion": 75, "completion_eval_sec": 1.768412954, "tokens_total": 406, "tokens_per_sec": 207.53774060674252, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between 'drugs' and 'sales' on drug_id, filter sales within the date range 2020-04-01 to 2020-06-30, and aggregate total sales by drug_name. The generated query uses table aliases (d for drugs, s for sales) but maintains identical logic, column references, and grouping. The semantic meaning remains unchanged.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate total sales per drug for Q2 2020 by joining drugs and sales tables on drug_id, filtering sales between 2020-04-01 and 2020-06-30, and grouping by drug_name. The reference query uses table names directly while the generated query uses aliases, but this doesn't affect functionality. Both achieve the same results with identical logic. The generated query's aliases improve readability without altering behavior.", "overall_assessment": "correct"}}
{"example_id": 2403, "sql_complexity": "multiple_joins", "prompt": "Who is the most frequent customer ordering vegetarian items?", "context": "CREATE TABLE customers (customer_id INT, customer_name VARCHAR(50)); INSERT INTO customers VALUES (1, 'John Doe'), (2, 'Jane Smith'), (3, 'Alice Johnson'); CREATE TABLE orders (order_id INT, customer_id INT, menu_id INT, order_date DATE); INSERT INTO orders VALUES (1, 1, 1, '2022-01-01'), (2, 2, 3, '2022-01-02'), (3, 3, 2, '2022-01-03'); CREATE TABLE menu (menu_id INT, item_name VARCHAR(50), is_vegetarian BOOLEAN, price DECIMAL(5,2)); INSERT INTO menu VALUES (1, 'Veggie Burger', true, 8.99), (2, 'Cheeseburger', false, 7.99), (3, 'Tofu Stir Fry', true, 11.99);", "reference_sql": "SELECT customers.customer_name, COUNT(orders.order_id) as order_count FROM customers INNER JOIN orders ON customers.customer_id = orders.customer_id INNER JOIN menu ON orders.menu_id = menu.menu_id WHERE menu.is_vegetarian = true GROUP BY customers.customer_name ORDER BY order_count DESC LIMIT 1;", "generated_sql": "SELECT c.customer_name\nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nJOIN menu m ON o.menu_id = m.menu_id\nWHERE m.is_vegetarian = true\nGROUP BY c.customer_id, c.customer_name\nORDER BY COUNT(o.order_id) DESC\nLIMIT 1;", "raw_model_output": "```sql\nSELECT c.customer_name\nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nJOIN menu m ON o.menu_id = m.menu_id\nWHERE m.is_vegetarian = true\nGROUP BY c.customer_id, c.customer_name\nORDER BY COUNT(o.order_id) DESC\nLIMIT 1;\n```", "latency_sec": 1.7449049949645996, "total_duration_sec": 1.718796808, "load_duration_sec": 0.01407011, "tokens_prompt": 298, "prompt_eval_sec": 0.064690315, "tokens_completion": 70, "completion_eval_sec": 1.637270673, "tokens_total": 368, "tokens_per_sec": 210.89973440500464, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their GROUP BY clauses. The Reference SQL groups by customer_name alone, which may not be functionally dependent on customer_id (as customer_name isn't guaranteed to be unique). The Generated SQL groups by both customer_id and customer_name, ensuring proper aggregation. While the sample data shows unique names, the schema doesn't enforce uniqueness, making the queries non-equivalent in general cases.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify the most frequent customer ordering vegetarian items by joining customers, orders, and menu tables with a vegetarian filter. The key difference lies in grouping: the reference query groups by customer_name (which could fail if names are non-unique), while the generated query groups by customer_id and customer_name (ensuring accuracy via the primary key). Both would produce identical results in this specific dataset, but the generated query is more robust and technically superior due to proper grouping on the primary key. The business intent is fully fulfilled by both, but the generated version better handles edge cases.", "overall_assessment": "correct"}}
{"example_id": 124, "sql_complexity": "set operations", "prompt": "Find the intersection of AI and accessibility research projects in the EU and those in Africa.", "context": "CREATE SCHEMA if not exists accessibility; CREATE TABLE if not exists accessibility.research (id INT PRIMARY KEY, project_name VARCHAR(255), region VARCHAR(255)); INSERT INTO accessibility.research (id, project_name, region) VALUES (1, 'AI for Accessibility EU', 'EU'), (2, 'Accessibility Africa', 'Africa'), (3, 'AI for Accessibility Africa', 'Africa'), (4, 'Accessibility EU', 'EU');", "reference_sql": "SELECT project_name FROM accessibility.research WHERE region = 'EU' INTERSECT SELECT project_name FROM accessibility.research WHERE region = 'Africa';", "generated_sql": "SELECT project_name \nFROM accessibility.research \nWHERE region = 'EU' AND project_name LIKE '%AI%' \nINTERSECT \nSELECT project_name \nFROM accessibility.research \nWHERE region = 'Africa' AND project_name LIKE '%AI%';", "raw_model_output": "```sql\nSELECT project_name \nFROM accessibility.research \nWHERE region = 'EU' AND project_name LIKE '%AI%' \nINTERSECT \nSELECT project_name \nFROM accessibility.research \nWHERE region = 'Africa' AND project_name LIKE '%AI%';\n```", "latency_sec": 1.4023189544677734, "total_duration_sec": 1.302086666, "load_duration_sec": 0.01384467, "tokens_prompt": 188, "prompt_eval_sec": 0.037212907, "tokens_completion": 55, "completion_eval_sec": 1.248633335, "tokens_total": 243, "tokens_per_sec": 173.28440097440355, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query finds project names present in both 'EU' and 'Africa' regions without any additional filters. The generated query adds WHERE conditions filtering for project_names containing 'AI' in both regions. This makes the generated query more restrictive - it only considers project names with 'AI' in both regions, while the reference query considers all project names. The added LIKE '%AI%' conditions change the semantic meaning.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is technically correct but fails to address the 'AI and accessibility' filter in the original question. It returns all projects in both EU and Africa regions without checking for AI/accessibility keywords. The Generated SQL adds the 'LIKE %AI%' condition to both clauses, better aligning with the business intent by filtering for AI-related projects. However, neither query explicitly checks for 'accessibility' in project names (though sample data implies it via project names). The Generated SQL is more precise in capturing the AI aspect, making it superior for the stated intent, even if it misses the accessibility filter. The Reference SQL's results would include projects like 'Accessibility Africa' (no AI) and 'Accessibility EU' (no AI), which don't meet the full criteria.", "overall_assessment": "differently_correct"}}
{"example_id": 1231, "sql_complexity": "basic SQL", "prompt": "What is the average ticket price for performances at the 'Downtown Theater'?", "context": "CREATE TABLE DowntownTheater (show_name TEXT, date DATE, ticket_price FLOAT); INSERT INTO DowntownTheater (show_name, date, ticket_price) VALUES ('Play 1', '2022-01-01', 30.0), ('Play 2', '2022-01-02', 40.0), ('Concert 1', '2022-01-03', 50.0);", "reference_sql": "SELECT AVG(ticket_price) FROM DowntownTheater WHERE show_name = 'Downtown Theater'", "generated_sql": "SELECT AVG(ticket_price) AS average_ticket_price\nFROM DowntownTheater;", "raw_model_output": "```sql\nSELECT AVG(ticket_price) AS average_ticket_price\nFROM DowntownTheater;\n```", "latency_sec": 0.6203219890594482, "total_duration_sec": 0.516743035, "load_duration_sec": 0.014129227, "tokens_prompt": 194, "prompt_eval_sec": 0.037434987, "tokens_completion": 20, "completion_eval_sec": 0.463001852, "tokens_total": 214, "tokens_per_sec": 344.98212827256623, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters for show_name = 'Downtown Theater' which doesn't exist in the sample data (returns NULL), while the Generated SQL calculates the average of all tickets. The WHERE clause in Reference SQL changes the result significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query is incorrect because it filters for show_name = 'Downtown Theater', but the sample data shows show_names like 'Play 1', 'Play 2', and 'Concert 1' - none of which match the theater name. The generated query correctly calculates the average ticket price for all performances in the DowntownTheater table, which is the appropriate dataset for the question. The reference query would return NULL/0 due to no matching rows, while the generated query returns the correct average of 40.0 (30+40+50)/3. The generated query also has better efficiency by avoiding an unnecessary filter.", "overall_assessment": "incorrect"}}
{"example_id": 1485, "sql_complexity": "set operations", "prompt": "How many public schools and public libraries exist in total, in the 'CityData' schema's 'CityEducation' and 'CityLibrary' tables?", "context": "CREATE SCHEMA CityData; CREATE TABLE CityEducation (Name varchar(255), Type varchar(255)); INSERT INTO CityEducation (Name, Type) VALUES ('SchoolA', 'Public'), ('SchoolB', 'Public'), ('SchoolC', 'Private'); CREATE TABLE CityLibrary (Name varchar(255), Type varchar(255)); INSERT INTO CityLibrary (Name, Type) VALUES ('LibraryA', 'Public'), ('LibraryB', 'Public'), ('LibraryC', 'Private');", "reference_sql": "SELECT COUNT(*) FROM CityData.CityEducation WHERE Type = 'Public' UNION ALL SELECT COUNT(*) FROM CityData.CityLibrary WHERE Type = 'Public';", "generated_sql": "SELECT \n    (SELECT COUNT(*) FROM CityData.CityEducation WHERE Type = 'Public') + \n    (SELECT COUNT(*) FROM CityData.CityLibrary WHERE Type = 'Public') AS Total_Public_Schools_and_Libraries;", "raw_model_output": "```sql\nSELECT \n    (SELECT COUNT(*) FROM CityData.CityEducation WHERE Type = 'Public') + \n    (SELECT COUNT(*) FROM CityData.CityLibrary WHERE Type = 'Public') AS Total_Public_Schools_and_Libraries;\n```", "latency_sec": 1.3718912601470947, "total_duration_sec": 1.22879957, "load_duration_sec": 0.013738981, "tokens_prompt": 212, "prompt_eval_sec": 0.045355956, "tokens_completion": 51, "completion_eval_sec": 1.167176074, "tokens_total": 263, "tokens_per_sec": 191.70615604898674, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate counts (one for CityEducation and one for CityLibrary) as two rows, while the Generated SQL returns a single row with the summed total. The output structure differs, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL returns two separate counts (one for schools, one for libraries) via UNION ALL, while the Generated SQL calculates a single total by summing both counts. The original question explicitly asks for 'total' (a single number), making the Generated SQL more accurate for the business intent. Both queries are technically correct, but they produce different result structures. The Generated SQL better fulfills the requirement to report a combined total.", "overall_assessment": "differently_correct"}}
{"example_id": 5806, "sql_complexity": "single join", "prompt": "List the top 3 countries with the most veteran employment in the IT industry", "context": "CREATE TABLE veteran_employment (employee_id INT, industry VARCHAR(255), salary DECIMAL(10,2), state VARCHAR(2), country VARCHAR(255)); CREATE TABLE countries (country_id INT, country VARCHAR(255));", "reference_sql": "SELECT country, COUNT(*) as num_veterans FROM veteran_employment JOIN countries ON veteran_employment.country = countries.country WHERE industry = 'IT' GROUP BY country ORDER BY num_veterans DESC LIMIT 3;", "generated_sql": "SELECT c.country, COUNT(*) AS veteran_count\nFROM veteran_employment ve\nJOIN countries c ON ve.country = c.country\nWHERE ve.industry = 'IT'\nGROUP BY c.country\nORDER BY veteran_count DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT c.country, COUNT(*) AS veteran_count\nFROM veteran_employment ve\nJOIN countries c ON ve.country = c.country\nWHERE ve.industry = 'IT'\nGROUP BY c.country\nORDER BY veteran_count DESC\nLIMIT 3;\n```", "latency_sec": 1.3096840381622314, "total_duration_sec": 1.254042775, "load_duration_sec": 0.013805308, "tokens_prompt": 145, "prompt_eval_sec": 0.028425113, "tokens_completion": 54, "completion_eval_sec": 1.209414249, "tokens_total": 199, "tokens_per_sec": 151.94504491269498, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between veteran_employment and countries on the country column, filter for industry 'IT', group by country, and order by count in descending order with a limit of 3. The differences are purely syntactic (table aliases and column aliases) and do not affect the semantic result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are structurally identical in logic, syntax, and result set. The reference query uses explicit table names without aliases, while the generated query uses aliases (ve/c) which is a stylistic choice. Both correctly join the tables on country, filter for 'IT' industry, group by country, count veterans, order by count descending, and limit to 3. The column aliases ('num_veterans' vs 'veteran_count') do not affect functionality. Neither query has performance advantages over the other. Both fully address the business intent of identifying top 3 countries by IT veteran employment count.", "overall_assessment": "correct"}}
{"example_id": 4126, "sql_complexity": "window functions", "prompt": "What is the average crime rate per capita in each neighborhood?", "context": "CREATE TABLE neighborhoods (name VARCHAR(255), population INT, crime_count INT); INSERT INTO neighborhoods (name, population, crime_count) VALUES ('Central Park', 1000, 25), ('Harlem', 2500, 75), ('Brooklyn', 5000, 120);", "reference_sql": "SELECT name, AVG(crime_count/population) OVER (PARTITION BY name) FROM neighborhoods;", "generated_sql": "SELECT name, (crime_count / population) AS avg_crime_rate_per_capita\nFROM neighborhoods;", "raw_model_output": "```sql\nSELECT name, (crime_count / population) AS avg_crime_rate_per_capita\nFROM neighborhoods;\n```", "latency_sec": 0.9200448989868164, "total_duration_sec": 0.636069041, "load_duration_sec": 0.014786758, "tokens_prompt": 161, "prompt_eval_sec": 0.03056807, "tokens_completion": 26, "completion_eval_sec": 0.588553289, "tokens_total": 187, "tokens_per_sec": 203.2509502589825, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses an analytic function AVG() with PARTITION BY name, which would calculate the average of crime_count/population within each name group. However, since each name in the sample data is unique, this would effectively return the same value as the raw division (crime_count/population). However, if there were multiple rows with the same name, the Reference SQL would average the ratios while the Generated SQL would return individual values. Thus, they are not semantically equivalent in general.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries produce the same numerical results, but they differ in approach. The reference query incorrectly uses an analytic function (AVG() OVER) which is unnecessary since each neighborhood has a single row. The generated query directly calculates the crime rate per capita (crime_count/population) which is mathematically equivalent but more efficient. While both technically produce identical results, the generated query better fulfills the business intent by providing a straightforward calculation without unnecessary complexity.", "overall_assessment": "differently_correct"}}
{"example_id": 4559, "sql_complexity": "basic SQL", "prompt": "List the top 3 energy efficient appliances in the US by energy star rating?", "context": "CREATE TABLE appliances (id INT, name VARCHAR(255), country VARCHAR(255), energy_star_rating INT); INSERT INTO appliances (id, name, country, energy_star_rating) VALUES (1, 'Fridge A', 'USA', 5), (2, 'TV B', 'USA', 4), (3, 'Laptop C', 'USA', 5), (4, 'Microwave D', 'USA', 3);", "reference_sql": "SELECT name, energy_star_rating FROM appliances WHERE country = 'USA' ORDER BY energy_star_rating DESC LIMIT 3;", "generated_sql": "SELECT name, energy_star_rating \nFROM appliances \nWHERE country = 'USA' \nORDER BY energy_star_rating DESC \nLIMIT 3;", "raw_model_output": "```sql\nSELECT name, energy_star_rating \nFROM appliances \nWHERE country = 'USA' \nORDER BY energy_star_rating DESC \nLIMIT 3;\n```", "latency_sec": 0.8450717926025391, "total_duration_sec": 0.811846789, "load_duration_sec": 0.01783499, "tokens_prompt": 188, "prompt_eval_sec": 0.036835567, "tokens_completion": 33, "completion_eval_sec": 0.75448754, "tokens_total": 221, "tokens_per_sec": 261.51624268441594, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select the same columns (name, energy_star_rating) from the appliances table where country is 'USA', order by energy_star_rating in descending order, and limit to 3 results. The syntax and clauses are exactly the same.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "The reference and generated queries are identical in structure, logic, and syntax. Both correctly filter US appliances, order by energy_star_rating descending, and limit to 3 results. They produce the same output, fulfill the business intent of identifying top energy-efficient appliances by rating, and are equally efficient/elegant. The queries are functionally identical.", "overall_assessment": "correct"}}
{"example_id": 456, "sql_complexity": "window functions", "prompt": "List the intelligence operations and their corresponding threat levels, and rank them based on their threat level and budget.", "context": "CREATE TABLE intel_ops_threat (id INT, operation VARCHAR, threat VARCHAR, budget INT); INSERT INTO intel_ops_threat (id, operation, threat, budget) VALUES (1, 'Operation Red Folder', 'High', 5000000), (2, 'Operation Black Vault', 'Medium', 7000000), (3, 'Operation Blue Sail', 'Low', 6000000);", "reference_sql": "SELECT operation, threat, budget, ROW_NUMBER() OVER (PARTITION BY threat ORDER BY budget DESC) as rank FROM intel_ops_threat;", "generated_sql": "SELECT operation, threat\nFROM intel_ops_threat\nORDER BY FIELD(threat, 'High', 'Medium', 'Low'), budget DESC;", "raw_model_output": "```sql\nSELECT operation, threat\nFROM intel_ops_threat\nORDER BY FIELD(threat, 'High', 'Medium', 'Low'), budget DESC;\n```", "latency_sec": 1.017035961151123, "total_duration_sec": 0.829932736, "load_duration_sec": 0.013908967, "tokens_prompt": 192, "prompt_eval_sec": 0.03670043, "tokens_completion": 34, "completion_eval_sec": 0.776348554, "tokens_total": 226, "tokens_per_sec": 222.2143647154855, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL includes 'budget' and a 'rank' column generated by ROW_NUMBER(), while the Generated SQL omits these and only returns 'operation' and 'threat'. Additionally, the Generated SQL explicitly orders results by a custom threat priority and budget, whereas the Reference SQL does not include an ORDER BY clause, making their result structures and ordering logic fundamentally different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL includes all required fields (operation, threat, budget) and adds a rank based on threat level partitioning and budget ordering. However, it ranks within threat levels rather than globally. The Generated SQL omits the budget column and lacks a true ranking mechanism, instead only sorting by threat priority and budget. Neither query fully satisfies the ranking requirement across all operations, but the Reference better addresses the explicit request for a 'rank' while including all necessary data elements.", "overall_assessment": "differently_correct"}}
{"example_id": 459, "sql_complexity": "set operations", "prompt": "What is the total installed capacity of hydroelectric power plants in Brazil and Canada?", "context": "CREATE TABLE hydroelectric_power (country TEXT, capacity INTEGER); INSERT INTO hydroelectric_power (country, capacity) VALUES ('Brazil', 104000), ('Canada', 78000), ('China', 350000), ('United States', 100000), ('Russia', 45000);", "reference_sql": "(SELECT capacity FROM hydroelectric_power WHERE country = 'Brazil') UNION (SELECT capacity FROM hydroelectric_power WHERE country = 'Canada');", "generated_sql": "SELECT SUM(capacity) AS total_capacity\nFROM hydroelectric_power\nWHERE country IN ('Brazil', 'Canada');", "raw_model_output": "```sql\nSELECT SUM(capacity) AS total_capacity\nFROM hydroelectric_power\nWHERE country IN ('Brazil', 'Canada');\n```", "latency_sec": 0.8091888427734375, "total_duration_sec": 0.695364007, "load_duration_sec": 0.024478026, "tokens_prompt": 169, "prompt_eval_sec": 0.031632125, "tokens_completion": 28, "completion_eval_sec": 0.637155559, "tokens_total": 197, "tokens_per_sec": 243.45367803737437, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate capacity values for Brazil and Canada as individual rows, while the Generated SQL returns a single summed value of their capacities. The first query produces multiple rows, the second a single aggregated value, so they are not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query uses UNION to combine separate capacity values for Brazil and Canada, which would return two rows of individual capacities rather than a single total. The generated query correctly uses SUM(capacity) with a WHERE clause to calculate the combined total. While both queries retrieve data about Brazil and Canada, only the generated query addresses the business intent of calculating 'total installed capacity'. The generated query is also more efficient as it performs a single aggregation operation rather than combining separate results.", "overall_assessment": "differently_correct"}}
{"example_id": 2356, "sql_complexity": "window functions", "prompt": "Find the total billing amount for attorneys in the 'Criminal Law' practice area, for the year 2020, partitioned by attorney's last name and ordered by the total billing amount in descending order.", "context": "CREATE TABLE Attorneys (AttorneyID INT, FirstName VARCHAR(50), LastName VARCHAR(50), PracticeArea VARCHAR(50), TotalBilling FLOAT, BillingYear INT); INSERT INTO Attorneys (AttorneyID, FirstName, LastName, PracticeArea, TotalBilling, BillingYear) VALUES (1, 'Clara', 'Rivera', 'Personal Injury', 8000.00, 2020), (2, 'Jamal', 'Lee', 'Personal Injury', 6000.00, 2019), (3, 'Sophia', 'Gomez', 'Criminal Law', 9000.00, 2020);", "reference_sql": "SELECT LastName, SUM(TotalBilling) OVER (PARTITION BY PracticeArea, LastName, BillingYear) AS TotalBilling FROM Attorneys WHERE PracticeArea = 'Criminal Law' AND BillingYear = 2020 ORDER BY TotalBilling DESC;", "generated_sql": "SELECT LastName, SUM(TotalBilling) AS TotalBillingAmount\nFROM Attorneys\nWHERE PracticeArea = 'Criminal Law' AND BillingYear = 2020\nGROUP BY LastName\nORDER BY TotalBillingAmount DESC;", "raw_model_output": "```sql\nSELECT LastName, SUM(TotalBilling) AS TotalBillingAmount\nFROM Attorneys\nWHERE PracticeArea = 'Criminal Law' AND BillingYear = 2020\nGROUP BY LastName\nORDER BY TotalBillingAmount DESC;\n```", "latency_sec": 1.3688828945159912, "total_duration_sec": 1.304919237, "load_duration_sec": 0.015333197, "tokens_prompt": 270, "prompt_eval_sec": 0.058428172, "tokens_completion": 52, "completion_eval_sec": 1.227944087, "tokens_total": 322, "tokens_per_sec": 235.22830279346326, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL uses a window function to calculate the sum per (PracticeArea, LastName, BillingYear) without grouping, returning all rows with aggregated values. The Generated SQL groups by LastName, collapsing multiple rows into one per LastName. If there are multiple entries for the same LastName in the filtered data, the Reference SQL would return multiple rows with the same sum, while the Generated SQL would return a single aggregated row. This difference in result structure makes them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL uses a window function with redundant partitioning (PracticeArea and BillingYear) that are already filtered by the WHERE clause, leading to unnecessary complexity. It would return the same value per row for each attorney but would not aggregate multiple entries per attorney. The Generated SQL correctly uses GROUP BY to aggregate total billing per attorney, which aligns with the business requirement for 'total billing amount'. While both queries filter for 'Criminal Law' and 2020, the Generated SQL's approach of explicit aggregation better matches the intent of calculating totals. The Reference SQL's window function does not achieve the same result as a GROUP BY aggregation in this context.", "overall_assessment": "differently_correct"}}
