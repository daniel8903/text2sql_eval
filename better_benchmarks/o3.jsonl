{"example_id": 2656, "sql_complexity": "multiple_joins", "prompt": "Find the drugs and their respective total sales for rare diseases indication with sales greater than the average sales for infectious diseases.", "context": "CREATE TABLE sales (id INT, drug_id INT, quarter INT, year INT, revenue FLOAT); INSERT INTO sales (id, drug_id, quarter, year, revenue) VALUES (1, 1, 1, 2022, 1500000); CREATE TABLE drugs (id INT, name VARCHAR(50), company VARCHAR(50), indication VARCHAR(50)); INSERT INTO drugs (id, name, company, indication) VALUES (1, 'DrugA', 'ABC Corp', 'Rare_Diseases');", "reference_sql": "SELECT s.drug_id, d.name, SUM(s.revenue) as total_sales FROM sales s JOIN drugs d ON s.drug_id = d.id WHERE d.indication = 'Rare_Diseases' GROUP BY s.drug_id HAVING total_sales > (SELECT AVG(s2.revenue) FROM sales s2 JOIN drugs d2 ON s2.drug_id = d2.id WHERE d2.indication = 'Infectious_Diseases')", "generated_sql": "SELECT \n    d.name,\n    SUM(s.revenue) AS total_sales\nFROM drugs AS d\nJOIN sales AS s\n      ON s.drug_id = d.id\nWHERE d.indication = 'Rare_Diseases'\nGROUP BY d.name\nHAVING SUM(s.revenue) >\n       ( SELECT AVG(drug_total)\n         FROM ( SELECT SUM(s2.revenue) AS drug_total\n                FROM drugs AS d2\n                JOIN sales  AS s2\n                      ON s2.drug_id = d2.id\n                WHERE d2.indication = 'Infectious_Diseases'\n                GROUP BY d2.id\n              ) AS inf )", "raw_model_output": "SELECT \n    d.name,\n    SUM(s.revenue) AS total_sales\nFROM drugs AS d\nJOIN sales AS s\n      ON s.drug_id = d.id\nWHERE d.indication = 'Rare_Diseases'\nGROUP BY d.name\nHAVING SUM(s.revenue) >\n       ( SELECT AVG(drug_total)\n         FROM ( SELECT SUM(s2.revenue) AS drug_total\n                FROM drugs AS d2\n                JOIN sales  AS s2\n                      ON s2.drug_id = d2.id\n                WHERE d2.indication = 'Infectious_Diseases'\n                GROUP BY d2.id\n              ) AS inf )", "latency_sec": 7.704741716384888, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 195, "prompt_eval_sec": null, "tokens_completion": 475, "completion_eval_sec": null, "tokens_total": 670, "tokens_per_sec": 86.95943675505428, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in how they calculate the average revenue for Infectious_Diseases drugs. The Reference SQL uses AVG(s2.revenue) on individual sales records, while the Generated SQL first groups by drug to calculate per-drug totals and then averages those totals. This leads to different threshold values in the HAVING clause, making the results potentially different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query incorrectly calculates the average sales for infectious diseases by averaging individual sales records (AVG(s2.revenue)) rather than averaging per-drug totals. The generated query properly computes the average of each drug's total sales for infectious diseases by first grouping and summing, then averaging those sums. Both queries correctly identify rare disease drugs with sales above this threshold, but the generated query's approach is statistically accurate. The generated query also uses explicit aggregation in the HAVING clause, which is more robust than the reference's implicit column reference (total_sales).", "overall_assessment": "differently_correct"}}
{"example_id": 3008, "sql_complexity": "multiple_joins", "prompt": "Who are the users who used electric vehicles and their trip details?", "context": "CREATE TABLE users (id INT, name VARCHAR(50), age INT, gender VARCHAR(10), city VARCHAR(50));CREATE TABLE vehicles (id INT, vehicle_type VARCHAR(20), is_electric BOOLEAN);CREATE TABLE trips (id INT, user_id INT, vehicle_id INT, trip_distance FLOAT, trip_duration INT, departure_time TIMESTAMP, arrival_time TIMESTAMP);INSERT INTO users (id, name, age, gender, city) VALUES (3, 'Alex', 30, 'Female', 'New York');INSERT INTO vehicles (id, vehicle_type, is_electric) VALUES (1, 'Tesla', true), (2, 'Bike', false);INSERT INTO trips (id, user_id, vehicle_id, trip_distance, trip_duration, departure_time, arrival_time) VALUES (3, 3, 1, 15.3, 25, '2022-01-03 12:00:00', '2022-01-03 12:25:00');", "reference_sql": "SELECT u.name, v.vehicle_type, t.trip_distance, t.trip_duration FROM users u JOIN trips t ON u.id = t.user_id JOIN vehicles v ON t.vehicle_id = v.id WHERE v.is_electric = true;", "generated_sql": "SELECT\n    u.id            AS user_id,\n    u.name          AS user_name,\n    t.id            AS trip_id,\n    v.vehicle_type,\n    t.trip_distance,\n    t.trip_duration,\n    t.departure_time,\n    t.arrival_time\nFROM trips    t\nJOIN vehicles v ON v.id = t.vehicle_id\nJOIN users    u ON u.id = t.user_id\nWHERE v.is_electric = TRUE;", "raw_model_output": "SELECT\n    u.id            AS user_id,\n    u.name          AS user_name,\n    t.id            AS trip_id,\n    v.vehicle_type,\n    t.trip_distance,\n    t.trip_duration,\n    t.departure_time,\n    t.arrival_time\nFROM trips    t\nJOIN vehicles v ON v.id = t.vehicle_id\nJOIN users    u ON u.id = t.user_id\nWHERE v.is_electric = TRUE;", "latency_sec": 4.630782842636108, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 286, "prompt_eval_sec": null, "tokens_completion": 236, "completion_eval_sec": null, "tokens_total": 522, "tokens_per_sec": 112.7239211465264, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects only 4 columns (u.name, v.vehicle_type, t.trip_distance, t.trip_duration), while the Generated SQL selects 8 columns including additional fields (u.id, t.id, departure_time, arrival_time, etc.). Although both filter on v.is_electric = TRUE and perform the same joins, the Generated SQL returns a superset of the columns from the Reference SQL, making their result sets different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries correctly identify users who used electric vehicles and their trip details. The reference query is more focused, selecting only the core required fields (name, vehicle_type, trip_distance, trip_duration) while the generated query includes additional columns (user_id, trip_id, departure_time, arrival_time). Technically, they are not equivalent due to differing column sets. However, both satisfy the business intent by linking users, trips, and vehicles with proper filtering. The reference query is more concise and directly addresses the question without unnecessary data, making it superior for this specific request.", "overall_assessment": "differently_correct"}}
{"example_id": 2531, "sql_complexity": "basic SQL", "prompt": "Who is the top customer by sales in 2022?", "context": "CREATE TABLE customers (customer_id INT, total_sales_2022 FLOAT); INSERT INTO customers (customer_id, total_sales_2022) VALUES (1, 25000.0), (2, 30000.0), (3, 22000.0), (4, 35000.0);", "reference_sql": "SELECT customer_id, total_sales_2022 FROM customers ORDER BY total_sales_2022 DESC LIMIT 1;", "generated_sql": "SELECT customer_id, total_sales_2022\nFROM customers\nORDER BY total_sales_2022 DESC\nFETCH FIRST 1 ROW ONLY;", "raw_model_output": "SELECT customer_id, total_sales_2022\nFROM customers\nORDER BY total_sales_2022 DESC\nFETCH FIRST 1 ROW ONLY;", "latency_sec": 5.671148061752319, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 143, "prompt_eval_sec": null, "tokens_completion": 240, "completion_eval_sec": null, "tokens_total": 383, "tokens_per_sec": 67.53482642836474, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries order customers by total_sales_2022 in descending order and retrieve the top row. The reference uses LIMIT 1 while the generated query uses FETCH FIRST 1 ROW ONLY, which are functionally equivalent in this context for selecting the maximum value.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly identify the top customer by sales in 2022 by ordering results in descending order and limiting to 1 row. The reference query uses LIMIT 1 (common in MySQL/PostgreSQL), while the generated query uses FETCH FIRST 1 ROW ONLY (standard SQL syntax). Both produce identical results in this context. The difference lies in syntax preference rather than functionality. Neither query is more efficient than the other in this simple case.", "overall_assessment": "correct"}}
{"example_id": 3792, "sql_complexity": "single join", "prompt": "What is the maximum distance traveled by an electric vehicle in a single trip, grouped by vehicle model?", "context": "CREATE TABLE Trips (trip_id INT, vehicle_id INT, distance FLOAT); CREATE TABLE ElectricVehicleModels (vehicle_id INT, vehicle_model TEXT);", "reference_sql": "SELECT evm.vehicle_model, MAX(trips.distance) AS max_distance_traveled FROM Trips trips INNER JOIN ElectricVehicleModels evm ON trips.vehicle_id = evm.vehicle_id GROUP BY 1;", "generated_sql": "SELECT\n    e.vehicle_model,\n    MAX(t.distance) AS max_distance\nFROM Trips AS t\nJOIN ElectricVehicleModels AS e\n  ON t.vehicle_id = e.vehicle_id\nGROUP BY\n    e.vehicle_model;", "raw_model_output": "```sql\nSELECT\n    e.vehicle_model,\n    MAX(t.distance) AS max_distance\nFROM Trips AS t\nJOIN ElectricVehicleModels AS e\n  ON t.vehicle_id = e.vehicle_id\nGROUP BY\n    e.vehicle_model;\n```", "latency_sec": 2.7919020652770996, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 115, "prompt_eval_sec": null, "tokens_completion": 133, "completion_eval_sec": null, "tokens_total": 248, "tokens_per_sec": 88.82833072276327, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the vehicle model and maximum distance traveled per vehicle by joining the Trips and ElectricVehicleModels tables. They use equivalent JOIN conditions (t.vehicle_id = e.vehicle_id vs trips.vehicle_id = evm.vehicle_id), group by the vehicle_model column (either by alias or position), and calculate the same MAX(distance) aggregate. The only differences are alias names and column alias formatting, which do not affect the result set's data.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly answer the question by joining the Trips and ElectricVehicleModels tables on vehicle_id, then grouping by vehicle_model to calculate the maximum distance per model. The reference query uses 'GROUP BY 1' (column position), while the generated query explicitly names the column in GROUP BY. Both approaches are syntactically valid and produce identical results. The business intent of identifying maximum trip distances per vehicle model is fully satisfied by both. Neither query demonstrates clear efficiency or elegance advantages over the other.", "overall_assessment": "correct"}}
{"example_id": 2311, "sql_complexity": "subqueries", "prompt": "Determine the percentage of sales from each ingredient category", "context": "CREATE TABLE Sales_Details (sale_id INT, ingredient_id INT, quantity INT); INSERT INTO Sales_Details (sale_id, ingredient_id, quantity) VALUES (1, 1, 2), (1, 2, 8), (2, 1, 3), (2, 2, 7); CREATE TABLE Ingredient_Categories (ingredient_id INT, ingredient_category VARCHAR(255)); INSERT INTO Ingredient_Categories (ingredient_id, ingredient_category) VALUES (1, 'Legumes'), (2, 'Poultry');", "reference_sql": "SELECT ingredient_category, SUM(quantity) AS total_quantity, SUM(quantity) * 100.0 / (SELECT SUM(quantity) FROM Sales_Details) AS percentage_of_sales FROM Sales_Details, Ingredient_Categories WHERE Sales_Details.ingredient_id = Ingredient_Categories.ingredient_id GROUP BY ingredient_category;", "generated_sql": "SELECT\n    ic.ingredient_category,\n    (SUM(sd.quantity) * 100.0 / t.total_quantity) AS percentage_of_sales\nFROM Sales_Details          sd\nJOIN Ingredient_Categories  ic ON sd.ingredient_id = ic.ingredient_id\nCROSS JOIN (SELECT SUM(quantity) AS total_quantity FROM Sales_Details) t\nGROUP BY ic.ingredient_category, t.total_quantity;", "raw_model_output": "```sql\nSELECT\n    ic.ingredient_category,\n    (SUM(sd.quantity) * 100.0 / t.total_quantity) AS percentage_of_sales\nFROM Sales_Details          sd\nJOIN Ingredient_Categories  ic ON sd.ingredient_id = ic.ingredient_id\nCROSS JOIN (SELECT SUM(quantity) AS total_quantity FROM Sales_Details) t\nGROUP BY ic.ingredient_category, t.total_quantity;\n```", "latency_sec": 5.250277042388916, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 188, "prompt_eval_sec": null, "tokens_completion": 297, "completion_eval_sec": null, "tokens_total": 485, "tokens_per_sec": 92.37607769728687, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a 'total_quantity' column in the output, while the Generated SQL does not. Additionally, the Generated SQL's GROUP BY clause includes 't.total_quantity' (a scalar value from a subquery), which is unnecessary and not present in the Reference SQL. These differences in column selection and grouping make the queries semantically distinct.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the percentage of sales per ingredient category. The reference query uses an implicit join and a scalar subquery, while the generated query uses explicit JOIN syntax and a CROSS JOIN to materialize the total. The generated query's explicit JOINs improve readability and maintainability. The GROUP BY in the generated query includes t.total_quantity (a scalar) which is technically redundant but harmless. Both handle the calculation correctly, but the generated version adheres to modern SQL practices with explicit joins and avoids potential ambiguity in the reference's implicit join syntax.", "overall_assessment": "correct"}}
{"example_id": 3329, "sql_complexity": "set operations", "prompt": "Which causes received funding from donors in both the United States and Canada?", "context": "CREATE TABLE donor_location (donor_id INT, country VARCHAR(50), cause VARCHAR(50), donation DECIMAL(10,2)); INSERT INTO donor_location (donor_id, country, cause, donation) VALUES (1, 'United States', 'Global Health', 1000.00), (2, 'Canada', 'Education', 2000.00), (3, 'United States', 'Environment', 1500.00), (4, 'Canada', 'Animal Welfare', 2500.00);", "reference_sql": "SELECT cause FROM donor_location WHERE country = 'United States' INTERSECT SELECT cause FROM donor_location WHERE country = 'Canada';", "generated_sql": "SELECT\n    cause\nFROM\n    donor_location\nWHERE\n    country IN ('United States', 'Canada')\nGROUP BY\n    cause\nHAVING\n    COUNT(DISTINCT country) = 2;", "raw_model_output": "SELECT\n    cause\nFROM\n    donor_location\nWHERE\n    country IN ('United States', 'Canada')\nGROUP BY\n    cause\nHAVING\n    COUNT(DISTINCT country) = 2;", "latency_sec": 3.3374648094177246, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 188, "prompt_eval_sec": null, "tokens_completion": 126, "completion_eval_sec": null, "tokens_total": 314, "tokens_per_sec": 94.08338901849947, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve causes that exist in both 'United States' and 'Canada'. The reference uses INTERSECT to find common causes between the two countries, while the generated query uses GROUP BY and HAVING to ensure each cause appears in both countries. Both approaches yield the same result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify causes with donations from both the United States and Canada. The Reference SQL uses INTERSECT to find common causes between two filtered subqueries, while the Generated SQL uses a single GROUP BY with HAVING COUNT(DISTINCT country) = 2. Technically, they produce identical results because both ensure a cause appears in both countries. However, the Generated SQL is more efficient and elegant, as it avoids multiple table scans and leverages aggregation. It also handles edge cases (e.g., multiple donations to the same cause in a single country) correctly by counting distinct countries.", "overall_assessment": "correct"}}
{"example_id": 2912, "sql_complexity": "single join", "prompt": "Which company has manufactured the most satellites?", "context": "CREATE TABLE manufacturers (id INT, name TEXT); CREATE TABLE satellites (id INT, manufacturer_id INT, name TEXT, launch_date DATE); INSERT INTO manufacturers (id, name) VALUES (1, 'SpaceX'), (2, 'Blue Origin'), (3, 'ISRO'), (4, 'CAST'); INSERT INTO satellites (id, manufacturer_id, name, launch_date) VALUES (1, 1, 'StarDragon', '2012-05-25'), (2, 1, 'Falcon', '2015-12-21'), (3, 2, 'New Glenn', '2022-01-11'), (4, 3, 'ChinaSat 1E', '2000-12-05'), (5, 3, 'ChinaSat 2A', '2003-08-13'), (6, 4, 'Shijian 9', '2017-11-19'), (7, 1, 'StarLink', '2020-05-24'), (8, 1, 'StarLink', '2020-06-13');", "reference_sql": "SELECT m.name, COUNT(s.id) FROM manufacturers m JOIN satellites s ON m.id = s.manufacturer_id GROUP BY m.name ORDER BY COUNT(s.id) DESC;", "generated_sql": "SELECT m.name\nFROM manufacturers AS m\nJOIN satellites AS s ON s.manufacturer_id = m.id\nGROUP BY m.id, m.name\nORDER BY COUNT(*) DESC\nFETCH FIRST 1 ROW ONLY;", "raw_model_output": "SELECT m.name\nFROM manufacturers AS m\nJOIN satellites AS s ON s.manufacturer_id = m.id\nGROUP BY m.id, m.name\nORDER BY COUNT(*) DESC\nFETCH FIRST 1 ROW ONLY;", "latency_sec": 3.739086151123047, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 306, "prompt_eval_sec": null, "tokens_completion": 254, "completion_eval_sec": null, "tokens_total": 560, "tokens_per_sec": 149.7692156228607, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns all manufacturers with their satellite counts ordered by count descending, while the Generated SQL only returns the top manufacturer (FETCH FIRST 1 ROW ONLY). The Generated SQL also groups by m.id and m.name instead of just m.name, though this wouldn't affect results in this specific dataset due to unique names. The key difference is the row limitation in the Generated SQL.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify the manufacturer with the most satellites by joining manufacturers and satellites tables, grouping by manufacturer, and ordering by count. The reference query includes the count in the output while the generated query omits it, but both would return the same top manufacturer. The generated query is more efficient due to the FETCH FIRST 1 ROW ONLY clause, which stops processing after the first result. The reference query's GROUP BY m.name is functionally equivalent to GROUP BY m.id, m.name in this case since manufacturer names are unique. The generated query better fulfills the business intent by directly returning only the required company name without unnecessary data.", "overall_assessment": "correct"}}
{"example_id": 3170, "sql_complexity": "aggregation", "prompt": "Determine the total production quantity of silver for mining sites in Mexico, between the dates '2017-05-01' and '2017-09-30', having less than 40 employees.", "context": "CREATE TABLE silver_mine_2 (site_id INT, country VARCHAR(50), num_employees INT, extraction_date DATE, quantity INT); INSERT INTO silver_mine_2 (site_id, country, num_employees, extraction_date, quantity) VALUES (1, 'Mexico', 35, '2017-05-02', 1200), (2, 'Mexico', 30, '2017-08-31', 1800), (3, 'Mexico', 37, '2017-07-04', 2200);", "reference_sql": "SELECT country, SUM(quantity) as total_silver_prod FROM silver_mine_2 WHERE num_employees < 40 AND country = 'Mexico' AND extraction_date >= '2017-05-01' AND extraction_date <= '2017-09-30' GROUP BY country;", "generated_sql": "SELECT \n    SUM(quantity) AS total_quantity\nFROM \n    silver_mine_2\nWHERE \n    country = 'Mexico'\n    AND extraction_date BETWEEN DATE '2017-05-01' AND DATE '2017-09-30'\n    AND num_employees < 40;", "raw_model_output": "SELECT \n    SUM(quantity) AS total_quantity\nFROM \n    silver_mine_2\nWHERE \n    country = 'Mexico'\n    AND extraction_date BETWEEN DATE '2017-05-01' AND DATE '2017-09-30'\n    AND num_employees < 40;", "latency_sec": 4.510900020599365, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 221, "prompt_eval_sec": null, "tokens_completion": 79, "completion_eval_sec": null, "tokens_total": 300, "tokens_per_sec": 66.50557508036697, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes 'country' in the SELECT clause with a GROUP BY, producing two columns (country and total_silver_prod), while the Generated SQL only returns a single column (total_quantity). Although both sum the same subset of data, their result structures differ, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the total silver production for Mexican sites with <40 employees between the specified dates. The reference query includes an unnecessary GROUP BY country clause (since the WHERE clause already filters to Mexico), while the generated query is more concise. The generated query also uses BETWEEN for date range filtering, which is functionally equivalent to the explicit >=/<= conditions. Both produce the same numerical result (1200+1800+2200 = 5200), but the generated query better aligns with the business intent by avoiding redundant grouping and explicitly focusing on the required aggregation.", "overall_assessment": "correct"}}
{"example_id": 3518, "sql_complexity": "basic SQL", "prompt": "Insert new records of ticket sales for a new event, including event and salesperson information.", "context": "CREATE TABLE salesperson (salesperson_id INT, name VARCHAR(50), position VARCHAR(50)); CREATE TABLE tickets (ticket_id INT, salesperson_id INT, event_id INT, price DECIMAL(5,2), quantity INT); CREATE TABLE events (event_id INT, name VARCHAR(50), date DATE); INSERT INTO salesperson VALUES (1, 'John Doe', 'Senior Salesperson'); INSERT INTO events VALUES (2, 'New Event', '2023-04-15');", "reference_sql": "INSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity) VALUES (2, 1, 2, 75, 50), (3, 2, 2, 65, 75); INSERT INTO events (event_id, name, date) VALUES (2, 'New Event', '2023-04-15');", "generated_sql": "Insert a new salesperson  \nINSERT INTO salesperson (salesperson_id, name, position)\nVALUES (2, 'Jane Smith', 'Sales Associate');", "raw_model_output": "-- 1) Insert a new salesperson  \nINSERT INTO salesperson (salesperson_id, name, position)\nVALUES (2, 'Jane Smith', 'Sales Associate');\n\n-- 2) Insert a new event  \nINSERT INTO events (event_id, name, date)\nVALUES (3, 'Summer Concert', DATE '2023-06-25');\n\n-- 3) Record ticket sales for the new event / salesperson  \nINSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity)\nVALUES\n    (1, 2, 3,  50.00, 100),   -- General\u2010admission tickets\n    (2, 2, 3,  75.00,  50);   -- VIP tickets", "latency_sec": 10.54490613937378, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 180, "prompt_eval_sec": null, "tokens_completion": 813, "completion_eval_sec": null, "tokens_total": 993, "tokens_per_sec": 94.16869025436108, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL inserts data into the 'tickets' and 'events' tables, while the Generated SQL inserts data into the 'salesperson' table. They operate on different tables with distinct schema requirements and data purposes.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL attempts to insert ticket records and reinserts an existing event, while the Generated SQL inserts a salesperson unrelated to ticket sales. The original question requires inserting ticket sales records with event/salesperson info. The Reference SQL partially fulfills this by inserting into tickets but redundantly modifies events. The Generated SQL fails to address ticket sales entirely. Neither query is fully correct, but the Reference is closer to the intent despite technical flaws.", "overall_assessment": "differently_correct"}}
{"example_id": 3925, "sql_complexity": "set operations", "prompt": "What is the total number of students and staff with accommodations in the \"disability_services\" schema, excluding the \"accessibility_parking\" type?", "context": "CREATE SCHEMA disability_services; CREATE TABLE staff (id INT, name VARCHAR(50), accommodation VARCHAR(50)); CREATE TABLE students (id INT, name VARCHAR(50), accommodation VARCHAR(50));", "reference_sql": "SELECT COUNT(*) FROM disability_services.staff WHERE accommodation != 'accessibility_parking' UNION SELECT COUNT(*) FROM disability_services.students WHERE accommodation != 'accessibility_parking';", "generated_sql": "SELECT COUNT(*) AS total_people_with_accommodations_excl_accessibility_parking\nFROM (\n    SELECT 1\n    FROM disability_services.staff\n    WHERE accommodation IS NOT NULL\n      AND accommodation <> 'accessibility_parking'\n    UNION ALL\n    SELECT 1\n    FROM disability_services.students\n    WHERE accommodation IS NOT NULL\n      AND accommodation <> 'accessibility_parking'\n) AS combined;", "raw_model_output": "SELECT COUNT(*) AS total_people_with_accommodations_excl_accessibility_parking\nFROM (\n    SELECT 1\n    FROM disability_services.staff\n    WHERE accommodation IS NOT NULL\n      AND accommodation <> 'accessibility_parking'\n    UNION ALL\n    SELECT 1\n    FROM disability_services.students\n    WHERE accommodation IS NOT NULL\n      AND accommodation <> 'accessibility_parking'\n) AS combined;", "latency_sec": 5.139843940734863, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 136, "prompt_eval_sec": null, "tokens_completion": 358, "completion_eval_sec": null, "tokens_total": 494, "tokens_per_sec": 96.11186753840836, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate counts (staff and students) where accommodation is not 'accessibility_parking', including NULL values. The Generated SQL excludes NULLs and sums the counts into a single total. Additionally, the Reference SQL uses UNION (which returns two rows) while the Generated SQL returns one row with a combined total. The handling of NULLs and result structure differ, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL uses UNION which combines results as separate rows (e.g., [10, 20] for staff and students counts) rather than summing them, failing to produce a single total. The Generated SQL correctly aggregates both tables into a single count using UNION ALL (to preserve all rows) and wraps in a COUNT(*), ensuring accurate summation. While both exclude 'accessibility_parking', the Generated SQL also adds IS NOT NULL checks for accommodation, making it more robust. The Reference SQL's structure inherently fails to fulfill the business intent of returning a single total.", "overall_assessment": "differently_correct"}}
{"example_id": 3340, "sql_complexity": "subqueries", "prompt": "Calculate the total revenue for garments manufactured in the US and sold in California.", "context": "CREATE TABLE garment_manufacturing(id INT PRIMARY KEY, garment_id INT, country VARCHAR(50), material VARCHAR(50), manufacturing_date DATE, quantity INT); CREATE TABLE garment_sales(id INT PRIMARY KEY, garment_id INT, store_id INT, sale_date DATE, units INT, revenue DECIMAL(10,2));", "reference_sql": "SELECT SUM(gs.revenue) FROM garment_manufacturing gm JOIN garment_sales gs ON gm.garment_id = gs.garment_id WHERE gm.country = 'United States' AND gs.store_id IN (SELECT id FROM stores WHERE region = 'California');", "generated_sql": "SELECT SUM(gs.revenue) AS total_revenue\nFROM   garment_manufacturing gm\nJOIN   garment_sales        gs\n       ON gm.garment_id = gs.garment_id\nWHERE  gm.country = 'US'      -- manufactured in the United States\n  AND  gs.store_id IN (/* California store_id(s) */ 1);", "raw_model_output": "-- Replace the value in the IN-list with the store_id (or list of store_ids)  \n-- that correspond(s) to California in your data set.  \nSELECT SUM(gs.revenue) AS total_revenue\nFROM   garment_manufacturing gm\nJOIN   garment_sales        gs\n       ON gm.garment_id = gs.garment_id\nWHERE  gm.country = 'US'      -- manufactured in the United States\n  AND  gs.store_id IN (/* California store_id(s) */ 1);", "latency_sec": 10.96141529083252, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 145, "prompt_eval_sec": null, "tokens_completion": 959, "completion_eval_sec": null, "tokens_total": 1104, "tokens_per_sec": 100.7169211920399, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. 1) The Reference SQL uses 'United States' while the Generated SQL uses 'US' for the country condition. 2) The Generated SQL's store_id condition is a hardcoded value (1) while the Reference SQL uses a subquery to get all store_ids in California. These differences would lead to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent. The reference query incorrectly references a non-existent 'stores' table in its subquery, causing a syntax error. The generated query hardcodes a single store_id (1) instead of dynamically identifying California stores, which violates the business intent. While both fail to address the missing 'stores' table in the schema, the reference query's structure better aligns with the intended logic (using a subquery for region-based filtering), whereas the generated query's hardcoded value is fundamentally flawed. Neither query fully fulfills the business intent due to schema inconsistencies, but the reference query's approach is more conceptually correct.", "overall_assessment": "incorrect"}}
{"example_id": 596, "sql_complexity": "basic SQL", "prompt": "What is the minimum energy production cost of wind farms in Spain?", "context": "CREATE TABLE wind_farm_costs (id INT, name TEXT, country TEXT, energy_production_cost FLOAT); INSERT INTO wind_farm_costs (id, name, country, energy_production_cost) VALUES (1, 'Las Tiesas', 'Spain', 0.045), (2, 'Eolo', 'Spain', 0.050);", "reference_sql": "SELECT MIN(energy_production_cost) FROM wind_farm_costs WHERE country = 'Spain';", "generated_sql": "SELECT\n    MIN(energy_production_cost) AS minimum_energy_production_cost\nFROM\n    wind_farm_costs\nWHERE\n    country = 'Spain';", "raw_model_output": "SELECT\n    MIN(energy_production_cost) AS minimum_energy_production_cost\nFROM\n    wind_farm_costs\nWHERE\n    country = 'Spain';", "latency_sec": 2.4099631309509277, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 154, "prompt_eval_sec": null, "tokens_completion": 117, "completion_eval_sec": null, "tokens_total": 271, "tokens_per_sec": 112.44985307848603, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the minimum energy_production_cost from the wind_farm_costs table where country is 'Spain'. The generated query adds an alias for the column, but this does not affect the semantic result. The WHERE clause and aggregate function are identical in both queries.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify the minimum energy production cost for Spanish wind farms by filtering on 'Spain' and using the MIN() aggregate function. The generated query improves upon the reference by adding an explicit alias (minimum_energy_production_cost) that clarifies the result's meaning without altering functionality. While both are technically correct and fulfill the business intent, the generated query is more readable and self-documenting, making it slightly superior in elegance and practicality.", "overall_assessment": "correct"}}
{"example_id": 2604, "sql_complexity": "subqueries", "prompt": "What is the maximum number of virtual tours taken by a single user in the UK?", "context": "CREATE TABLE virtual_tour_data (user_id INT, hotel_id INT, tour_date DATE); INSERT INTO virtual_tour_data (user_id, hotel_id, tour_date) VALUES (1, 10, '2022-01-01'), (2, 11, '2022-01-03'), (3, 12, '2022-01-05'), (4, 10, '2022-01-07'), (5, 10, '2022-01-09'); CREATE TABLE hotels (hotel_id INT, hotel_name TEXT, country TEXT); INSERT INTO hotels (hotel_id, hotel_name, country) VALUES (10, 'Royal Park Hotel', 'UK'), (11, 'The Ritz London', 'UK'), (12, 'Hotel de Crillon', 'France');", "reference_sql": "SELECT MAX(vt.user_tours) FROM (SELECT user_id, COUNT(DISTINCT hotel_id) as user_tours FROM virtual_tour_data WHERE country = 'UK' GROUP BY user_id) as vt;", "generated_sql": "SELECT MAX(tour_cnt) AS max_tours\nFROM (\n    SELECT v.user_id,\n           COUNT(*) AS tour_cnt\n    FROM virtual_tour_data AS v\n    JOIN hotels AS h\n      ON v.hotel_id = h.hotel_id\n    WHERE h.country = 'UK'\n    GROUP BY v.user_id\n) AS user_tour_counts;", "raw_model_output": "SELECT MAX(tour_cnt) AS max_tours\nFROM (\n    SELECT v.user_id,\n           COUNT(*) AS tour_cnt\n    FROM virtual_tour_data AS v\n    JOIN hotels AS h\n      ON v.hotel_id = h.hotel_id\n    WHERE h.country = 'UK'\n    GROUP BY v.user_id\n) AS user_tour_counts;", "latency_sec": 8.918708086013794, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 251, "prompt_eval_sec": null, "tokens_completion": 348, "completion_eval_sec": null, "tokens_total": 599, "tokens_per_sec": 67.16219369701585, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references a 'country' column in the virtual_tour_data table, which does not exist according to the schema. The Generated SQL correctly joins virtual_tour_data with hotels to filter by country. Additionally, the Reference SQL uses COUNT(DISTINCT hotel_id) while the Generated SQL uses COUNT(*), leading to different results in general (e.g., multiple tours at the same hotel would be counted differently).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query is technically incorrect because it references a 'country' column in the virtual_tour_data table, which doesn't exist. The generated query correctly joins with the hotels table to filter UK hotels. Semantically, the reference query would fail due to invalid column access, while the generated query properly counts tours per user in the UK. The business intent requires counting actual tours (rows) rather than distinct hotels, which the generated query handles correctly. The generated query is more efficient as it avoids unnecessary complexity and correctly filters data.", "overall_assessment": "incorrect"}}
{"example_id": 5812, "sql_complexity": "single join", "prompt": "Calculate the percentage of Shariah-compliant investments held by each investor in the top 5 countries with the highest percentage?", "context": "CREATE TABLE investors (investor_id INT, investor_name TEXT, country TEXT); INSERT INTO investors (investor_id, investor_name, country) VALUES (1, 'Al Thani', 'Qatar'), (2, 'Saudi Investment Group', 'Saudi Arabia'), (3, 'Temasek Holdings', 'Singapore'); CREATE TABLE investments (investment_id INT, investor_id INT, investment_type TEXT, investment_value DECIMAL, is_shariah_compliant BOOLEAN); INSERT INTO investments (investment_id, investor_id, investment_type, investment_value, is_shariah_compliant) VALUES (1, 1, 'Real Estate', 15000000, true), (2, 2, 'Stocks', 20000000, false);", "reference_sql": "SELECT investor_name, ROUND((SUM(CASE WHEN is_shariah_compliant THEN investment_value ELSE 0 END) / SUM(investment_value)) * 100, 2) AS percentage FROM investments JOIN investors ON investments.investor_id = investors.investor_id GROUP BY investor_name ORDER BY percentage DESC LIMIT 5;", "generated_sql": "WITH country_percentages AS (\n    /* 1.  Shariah-compliance percentage for every country */\n    SELECT  inv.country,\n            SUM(CASE WHEN ins.is_shariah_compliant THEN 1 ELSE 0 END) AS shariah_cnt,\n            COUNT(*)                                          AS total_cnt,\n            100.0 * SUM(CASE WHEN ins.is_shariah_compliant THEN 1 ELSE 0 END) \n                  / COUNT(*)                                  AS shariah_pct\n    FROM    investors   inv\n    JOIN    investments ins\n           ON ins.investor_id = inv.investor_id\n    GROUP BY inv.country\n),\ntop_5_countries AS (\n    /* 2. Pick the 5 countries with the highest Shariah-compliance */\n    SELECT country\n    FROM   country_percentages\n    ORDER BY shariah_pct DESC\n    FETCH FIRST 5 ROWS ONLY\n),\ninvestor_percentages AS (\n    /* 3. Shariah-compliance percentage for every individual investor */\n    SELECT  inv.investor_id,\n            inv.investor_name,\n            inv.country,\n            100.0 * SUM(CASE WHEN ins.is_shariah_compliant THEN 1 ELSE 0 END)\n                  / COUNT(*)                                  AS shariah_pct\n    FROM    investors   inv\n    JOIN    investments ins\n           ON ins.investor_id = inv.investor_id\n    GROUP BY inv.investor_id, inv.investor_name, inv.country\n)\nSELECT  investor_name,\n        country,\n        shariah_pct AS shariah_compliance_percentage\nFROM    investor_percentages\nWHERE   country IN (SELECT country FROM top_5_countries)\nORDER BY country,\n         shariah_pct DESC;", "raw_model_output": "```sql\nWITH country_percentages AS (\n    /* 1.  Shariah-compliance percentage for every country */\n    SELECT  inv.country,\n            SUM(CASE WHEN ins.is_shariah_compliant THEN 1 ELSE 0 END) AS shariah_cnt,\n            COUNT(*)                                          AS total_cnt,\n            100.0 * SUM(CASE WHEN ins.is_shariah_compliant THEN 1 ELSE 0 END) \n                  / COUNT(*)                                  AS shariah_pct\n    FROM    investors   inv\n    JOIN    investments ins\n           ON ins.investor_id = inv.investor_id\n    GROUP BY inv.country\n),\ntop_5_countries AS (\n    /* 2. Pick the 5 countries with the highest Shariah-compliance */\n    SELECT country\n    FROM   country_percentages\n    ORDER BY shariah_pct DESC\n    FETCH FIRST 5 ROWS ONLY\n),\ninvestor_percentages AS (\n    /* 3. Shariah-compliance percentage for every individual investor */\n    SELECT  inv.investor_id,\n            inv.investor_name,\n            inv.country,\n            100.0 * SUM(CASE WHEN ins.is_shariah_compliant THEN 1 ELSE 0 END)\n                  / COUNT(*)                                  AS shariah_pct\n    FROM    investors   inv\n    JOIN    investments ins\n           ON ins.investor_id = inv.investor_id\n    GROUP BY inv.investor_id, inv.investor_name, inv.country\n)\nSELECT  investor_name,\n        country,\n        shariah_pct AS shariah_compliance_percentage\nFROM    investor_percentages\nWHERE   country IN (SELECT country FROM top_5_countries)\nORDER BY country,\n         shariah_pct DESC;\n```", "latency_sec": 15.469800233840942, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 243, "prompt_eval_sec": null, "tokens_completion": 1031, "completion_eval_sec": null, "tokens_total": 1274, "tokens_per_sec": 82.3540046246404, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL calculates the shariah-compliance percentage based on investment values (using SUM(investment_value)), while the Generated SQL uses counts (SUM(CASE WHEN ... THEN 1 ELSE 0 END) / COUNT(*)). Additionally, the Generated SQL filters investors by countries in the top 5 shariah-compliance percentages and includes country information in the output, which the Reference SQL does not. The calculation methods and output structures differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query incorrectly limits to the top 5 investors by compliance percentage rather than identifying the top 5 countries first. It fails to address the requirement to filter investors based on their country's compliance percentage. The generated query correctly: 1) calculates country-level Shariah compliance percentages, 2) identifies the top 5 countries, 3) filters investors from those countries, and 4) calculates individual investor compliance percentages. This structure aligns with the business requirement to focus on countries first, then their investors. The reference query's logic is fundamentally misaligned with the question's intent.", "overall_assessment": "differently_correct"}}
{"example_id": 4706, "sql_complexity": "multiple_joins", "prompt": "Who are the top 3 customers by total spend on makeup products from Italy and Spain?", "context": "CREATE TABLE customers (customer_id INT, customer_name TEXT, country TEXT); INSERT INTO customers (customer_id, customer_name, country) VALUES (1, 'Alessandro Martini', 'IT'), (2, 'Laura Rossi', 'ES'), (3, 'Daniela Gonzalez', 'MX'), (4, 'Jose Hernandez', 'ES'), (5, 'Sophia Rodriguez', 'IT'); CREATE TABLE sales (sale_id INT, customer_id INT, product_id INT, sale_quantity INT, sale_country TEXT); INSERT INTO sales (sale_id, customer_id, product_id, sale_quantity, sale_country) VALUES (1, 1, 1, 100, 'IT'), (2, 2, 2, 150, 'ES'), (3, 3, 3, 200, 'MX'), (4, 4, 4, 250, 'ES'), (5, 5, 5, 300, 'IT'); CREATE TABLE products (product_id INT, product_name TEXT, category TEXT); INSERT INTO products (product_id, product_name, category) VALUES (1, 'Eyeshadow Palette', 'makeup'), (2, 'Liquid Lipstick', 'makeup'), (3, 'BB Cream', 'makeup'), (4, 'Volumizing Mascara', 'makeup'), (5, 'Nourishing Lip Balm', 'makeup');", "reference_sql": "SELECT c.customer_name, SUM(s.sale_quantity) as total_spent_on_makeup FROM sales s JOIN customers c ON s.customer_id = c.customer_id JOIN products p ON s.product_id = p.product_id WHERE c.country IN ('IT', 'ES') AND p.category = 'makeup' GROUP BY c.customer_name ORDER BY total_spent_on_makeup DESC LIMIT 3;", "generated_sql": "SELECT\n    c.customer_id,\n    c.customer_name,\n    SUM(s.sale_quantity) AS total_spend\nFROM\n    customers AS c\nJOIN\n    sales     AS s ON s.customer_id = c.customer_id\nJOIN\n    products  AS p ON p.product_id = s.product_id\nWHERE\n    p.category = 'makeup'\n    AND c.country IN ('IT', 'ES')\nGROUP BY\n    c.customer_id,\n    c.customer_name\nORDER BY\n    total_spend DESC\nFETCH FIRST 3 ROWS ONLY;", "raw_model_output": "SELECT\n    c.customer_id,\n    c.customer_name,\n    SUM(s.sale_quantity) AS total_spend\nFROM\n    customers AS c\nJOIN\n    sales     AS s ON s.customer_id = c.customer_id\nJOIN\n    products  AS p ON p.product_id = s.product_id\nWHERE\n    p.category = 'makeup'\n    AND c.country IN ('IT', 'ES')\nGROUP BY\n    c.customer_id,\n    c.customer_name\nORDER BY\n    total_spend DESC\nFETCH FIRST 3 ROWS ONLY;", "latency_sec": 6.124719858169556, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 376, "prompt_eval_sec": null, "tokens_completion": 260, "completion_eval_sec": null, "tokens_total": 636, "tokens_per_sec": 103.84148413770488, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in selected columns (customer_id included in Generated) and grouping (Generated groups by customer_id and name, Reference groups by name only). Additionally, column aliases differ (total_spent_on_makeup vs total_spend) and LIMIT syntax varies (LIMIT 3 vs FETCH FIRST 3 ROWS ONLY). These differences affect the result structure and grouping logic.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "While both queries address the core requirements, they differ in technical implementation. The generated query uses FETCH FIRST 3 ROWS ONLY (more standard SQL) vs. LIMIT 3 (PostgreSQL-specific). The generated query groups by both customer_id and customer_name (more robust for unique identification) while the reference only groups by name. The reference's SELECT clause omits customer_id, which could be critical for unambiguous customer identification in real-world scenarios with potential name duplicates. Both correctly filter by 'makeup' category and countries IT/ES, but the generated query's grouping strategy is technically superior. The reference's output would match the generated's results in this specific dataset due to unique names, but the generated query is more reliable in general cases.", "overall_assessment": "differently_correct"}}
{"example_id": 1515, "sql_complexity": "multiple_joins", "prompt": "What is the average age of clients who lost cases in the 'personal injury' category?", "context": "CREATE TABLE Cases (CaseID int, ClientID int, Category varchar(50)); INSERT INTO Cases (CaseID, ClientID, Category) VALUES (701, 7, 'Personal Injury'); CREATE TABLE Clients (ClientID int, Age int, Gender varchar(10)); INSERT INTO Clients (ClientID, Age, Gender) VALUES (7, 45, 'Male'); CREATE TABLE CaseOutcomes (CaseID int, Outcome varchar(50)); INSERT INTO CaseOutcomes (CaseID, Outcome) VALUES (701, 'Lost');", "reference_sql": "SELECT AVG(C.Age) as AvgAge FROM Clients C INNER JOIN Cases CA ON C.ClientID = CA.ClientID INNER JOIN CaseOutcomes CO ON CA.CaseID = CO.CaseID WHERE CA.Category = 'Personal Injury' AND CO.Outcome = 'Lost';", "generated_sql": "SELECT\n    AVG(cl.Age) AS avg_age\nFROM\n    Cases          ca\nJOIN\n    CaseOutcomes   co  ON co.CaseID  = ca.CaseID\nJOIN\n    Clients        cl  ON cl.ClientID = ca.ClientID\nWHERE\n    LOWER(ca.Category) = 'personal injury'\n    AND LOWER(co.Outcome) = 'lost';", "raw_model_output": "SELECT\n    AVG(cl.Age) AS avg_age\nFROM\n    Cases          ca\nJOIN\n    CaseOutcomes   co  ON co.CaseID  = ca.CaseID\nJOIN\n    Clients        cl  ON cl.ClientID = ca.ClientID\nWHERE\n    LOWER(ca.Category) = 'personal injury'\n    AND LOWER(co.Outcome) = 'lost';", "latency_sec": 4.607622861862183, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 194, "prompt_eval_sec": null, "tokens_completion": 227, "completion_eval_sec": null, "tokens_total": 421, "tokens_per_sec": 91.37032535467796, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average age of clients with 'Personal Injury' cases that resulted in 'Lost'. The generated query uses LOWER() which normalizes case, but the reference data uses exact case ('Personal Injury' and 'Lost'). Since the WHERE conditions are semantically equivalent when considering case-insensitive matching, the results will be the same. The join logic, table aliases, and aggregation are identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the average age of clients who lost 'personal injury' cases by joining the three tables and applying the necessary filters. The reference query uses exact string matching, while the generated query uses LOWER() to make the comparison case-insensitive. In the provided dataset, both would return the same result because the Category and Outcome values match exactly. However, the generated query is more robust to case variations in the data (e.g., 'PERSONAL INJURY' or 'lost'). The reference query might fail if the database uses a case-sensitive collation and the stored values differ in casing. The generated query's approach better handles real-world data inconsistencies while maintaining semantic equivalence for the given context.", "overall_assessment": "correct"}}
{"example_id": 4388, "sql_complexity": "subqueries", "prompt": "Insert a new drug with a price 10% higher than the average price", "context": "CREATE TABLE drugs (drug_id INT, drug_name VARCHAR(50), price DECIMAL(10, 2)); INSERT INTO drugs (drug_id, drug_name, price) VALUES (1, 'DrugA', 50), (2, 'DrugB', 75), (3, 'DrugC', 100)", "reference_sql": "INSERT INTO drugs (drug_id, drug_name, price) VALUES ((SELECT MAX(drug_id) FROM drugs) + 1, 'DrugD', (SELECT AVG(price) * 1.1 FROM drugs))", "generated_sql": "INSERT INTO drugs (drug_id, drug_name, price)\nSELECT MAX(drug_id) + 1,\n       'NewDrug',\n       AVG(price) * 1.10\nFROM drugs;", "raw_model_output": "INSERT INTO drugs (drug_id, drug_name, price)\nSELECT MAX(drug_id) + 1,\n       'NewDrug',\n       AVG(price) * 1.10\nFROM drugs;", "latency_sec": 3.060293197631836, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 148, "prompt_eval_sec": null, "tokens_completion": 123, "completion_eval_sec": null, "tokens_total": 271, "tokens_per_sec": 88.55360663145265, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the drug_name value inserted ('DrugD' vs 'NewDrug'). While both calculate drug_id and price identically, the distinct drug names make the inserted rows semantically different.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate a new drug price as 10% above the average and generate a new drug_id. The reference uses explicit subqueries in VALUES, while the generated uses a single SELECT statement. The generated version is more efficient as it calculates all required values in one query rather than multiple subqueries. The drug name difference ('DrugD' vs 'NewDrug') doesn't affect technical equivalence since the question didn't specify a name. Both handle edge cases (e.g., empty table) similarly, though the original context has existing data.", "overall_assessment": "correct"}}
{"example_id": 5431, "sql_complexity": "basic SQL", "prompt": "What is the average CO2 emission of ride-hailing vehicles in San Francisco?", "context": "CREATE TABLE SFRideHailing (id INT, company VARCHAR(20), co2_emission DECIMAL(5,2));", "reference_sql": "SELECT AVG(co2_emission) FROM SFRideHailing WHERE company = 'Uber';", "generated_sql": "SELECT \n    AVG(co2_emission) AS average_co2_emission\nFROM \n    SFRideHailing;", "raw_model_output": "SELECT \n    AVG(co2_emission) AS average_co2_emission\nFROM \n    SFRideHailing;", "latency_sec": 5.1283910274505615, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 109, "prompt_eval_sec": null, "tokens_completion": 108, "completion_eval_sec": null, "tokens_total": 217, "tokens_per_sec": 42.313466121922374, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the average co2_emission specifically for rows where company = 'Uber', while the Generated SQL calculates the average for all rows in the table without any filtering. Without a WHERE clause, the Generated SQL would include all companies, leading to a different result unless all entries in the table are already from Uber (which is not indicated here).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query is technically correct but semantically limited. It calculates the average CO2 emission specifically for Uber vehicles, while the original question asks about all ride-hailing vehicles in San Francisco (implied by the SFRideHailing table). The generated query correctly averages CO2 emissions across all entries in the table, aligning with the business intent. However, neither query explicitly filters for 'ride-hailing' vehicles (though the table name suggests this). The generated query is more elegant and aligns with the stated question, while the reference query addresses a narrower subset of the data.", "overall_assessment": "differently_correct"}}
{"example_id": 3531, "sql_complexity": "single join", "prompt": "What is the total number of workouts and total workout time per user for users with a membership type of 'Basic'?", "context": "CREATE TABLE Members (id INT, user_name VARCHAR, membership_type VARCHAR, signup_date DATE); CREATE TABLE Workouts (id INT, user_id INT, workout_date DATE, workout_duration INT); INSERT INTO Members (id, user_name, membership_type, signup_date) VALUES (1, 'John Doe', 'Premium', '2020-01-01'), (2, 'Jane Smith', 'Basic', '2019-06-15'), (3, 'Alice Johnson', 'Premium', '2020-03-20'); INSERT INTO Workouts (id, user_id, workout_date, workout_duration) VALUES (1, 1, '2020-01-01', 60), (2, 1, '2020-01-02', 70), (3, 2, '2019-06-15', 90), (4, 3, '2020-03-20', 65), (5, 3, '2020-03-21', 70);", "reference_sql": "SELECT Members.user_name, SUM(Workouts.workout_duration) AS total_workout_time, COUNT(Workouts.id) AS total_workouts FROM Members JOIN Workouts ON Members.id = Workouts.user_id WHERE Members.membership_type = 'Basic' GROUP BY Members.user_name;", "generated_sql": "SELECT\n    m.user_name,\n    COUNT(*)           AS total_workouts,\n    SUM(w.workout_duration) AS total_workout_time\nFROM Members  AS m\nJOIN Workouts AS w\n      ON w.user_id = m.id\nWHERE m.membership_type = 'Basic'\nGROUP BY m.user_name;", "raw_model_output": "SELECT\n    m.user_name,\n    COUNT(*)           AS total_workouts,\n    SUM(w.workout_duration) AS total_workout_time\nFROM Members  AS m\nJOIN Workouts AS w\n      ON w.user_id = m.id\nWHERE m.membership_type = 'Basic'\nGROUP BY m.user_name;", "latency_sec": 3.1334469318389893, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 301, "prompt_eval_sec": null, "tokens_completion": 148, "completion_eval_sec": null, "tokens_total": 449, "tokens_per_sec": 143.29267728701768, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between Members and Workouts on user_id, filter for 'Basic' membership, and group by user_name. The generated query uses table aliases and COUNT(*) instead of COUNT(Workouts.id), but since each row in the joined result represents a unique workout record, the aggregation results will be identical. The column aliases and ordering are also consistent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate total workouts and total workout time per user for 'Basic' members. The reference query uses explicit column references (Workouts.id, Workouts.workout_duration) while the generated query uses COUNT(*) and table aliases (w, m). The logical structure, join conditions, filtering, and grouping are identical. The generated query is slightly more concise with aliases but neither has performance advantages. Both produce the same results given the sample data.", "overall_assessment": "correct"}}
{"example_id": 5678, "sql_complexity": "set operations", "prompt": "How many public works projects are there in 'Sydney' and 'Melbourne' combined?", "context": "CREATE TABLE PublicWorksC(id INT, city VARCHAR(20), project VARCHAR(30)); INSERT INTO PublicWorksC(id, city, project) VALUES (1, 'Sydney', 'Park Renovation'), (2, 'Melbourne', 'Sidewalk Repair');", "reference_sql": "SELECT COUNT(*) FROM (SELECT city FROM PublicWorksC WHERE city = 'Sydney' UNION ALL SELECT city FROM PublicWorksC WHERE city = 'Melbourne') AS Total;", "generated_sql": "SELECT COUNT(*) AS project_count\nFROM PublicWorksC\nWHERE city IN ('Sydney', 'Melbourne');", "raw_model_output": "SELECT COUNT(*) AS project_count\nFROM PublicWorksC\nWHERE city IN ('Sydney', 'Melbourne');", "latency_sec": 2.5044829845428467, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 137, "prompt_eval_sec": null, "tokens_completion": 105, "completion_eval_sec": null, "tokens_total": 242, "tokens_per_sec": 96.62672954600777, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of rows where the city is either 'Sydney' or 'Melbourne'. The Reference SQL uses a UNION ALL to combine results from two separate selects and then counts them, while the Generated SQL uses a WHERE clause with IN. Since UNION ALL preserves all rows and the WHERE IN condition achieves the same filtering, the final count will be identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count projects in Sydney and Melbourne. The reference query uses a UNION ALL subquery to combine results from two separate city filters, while the generated query uses a single WHERE clause with IN. Both produce identical counts. However, the generated query is more efficient as it scans the table once with a simple filter, whereas the reference query requires two separate scans and a union operation. The generated version is also more concise and readable.", "overall_assessment": "correct"}}
{"example_id": 5792, "sql_complexity": "multiple_joins", "prompt": "How many cases were handled by attorneys in the 'Los Angeles' office?", "context": "CREATE TABLE offices (office_id INT, office_name VARCHAR(20), city VARCHAR(20), state VARCHAR(20)); INSERT INTO offices (office_id, office_name, city, state) VALUES (1, 'Boston', 'Boston', 'MA'), (2, 'New York', 'New York', 'NY'), (3, 'Los Angeles', 'Los Angeles', 'CA'); CREATE TABLE attorneys (attorney_id INT, office_id INT); INSERT INTO attorneys (attorney_id, office_id) VALUES (1, 1), (2, 2), (3, 3); CREATE TABLE cases (case_id INT, attorney_id INT); INSERT INTO cases (case_id, attorney_id) VALUES (1, 1), (2, 2), (3, 3);", "reference_sql": "SELECT COUNT(*) FROM cases JOIN attorneys ON cases.attorney_id = attorneys.attorney_id JOIN offices ON attorneys.office_id = offices.office_id WHERE offices.city = 'Los Angeles';", "generated_sql": "SELECT COUNT(*) AS total_cases\nFROM cases c\nJOIN attorneys a ON c.attorney_id = a.attorney_id\nJOIN offices o ON a.office_id = o.office_id\nWHERE o.office_name = 'Los Angeles';", "raw_model_output": "SELECT COUNT(*) AS total_cases\nFROM cases c\nJOIN attorneys a ON c.attorney_id = a.attorney_id\nJOIN offices o ON a.office_id = o.office_id\nWHERE o.office_name = 'Los Angeles';", "latency_sec": 3.4463350772857666, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 244, "prompt_eval_sec": null, "tokens_completion": 193, "completion_eval_sec": null, "tokens_total": 437, "tokens_per_sec": 126.80136730760623, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters on 'offices.city = 'Los Angeles'', while the Generated SQL filters on 'o.office_name = 'Los Angeles''. Although in the provided sample data the office_name and city values coincide, the queries are not semantically equivalent because they reference different columns. The city and office_name columns could contain different values in other scenarios, leading to different results.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries produce the same result in this specific context because the 'Los Angeles' office has both office_name and city set to 'Los Angeles'. However, the generated query is more semantically precise as it directly references the office's name ('office_name') which better aligns with the business intent of identifying 'Los Angeles' as an office rather than a city. The reference query uses 'city' which could ambiguously match any office located in Los Angeles, not just the specific office named 'Los Angeles'. The generated query's use of aliases and explicit column naming also improves readability and maintainability.", "overall_assessment": "correct"}}
{"example_id": 5148, "sql_complexity": "window functions", "prompt": "List the unique types of smart city technologies that have been implemented in the top 3 most populous countries in the world.", "context": "CREATE TABLE smart_city_tech (tech_type VARCHAR(255), country VARCHAR(255)); CREATE TABLE country_populations (country VARCHAR(255), population INT);", "reference_sql": "SELECT DISTINCT tech_type FROM smart_city_tech SCT WHERE country IN (SELECT country FROM (SELECT country, ROW_NUMBER() OVER (ORDER BY population DESC) as rank FROM country_populations) CP WHERE rank <= 3);", "generated_sql": "SELECT DISTINCT s.tech_type\nFROM smart_city_tech AS s\nJOIN (\n    SELECT country\n    FROM country_populations\n    ORDER BY population DESC\n    FETCH FIRST 3 ROWS ONLY\n) AS top_countries\n  ON s.country = top_countries.country;", "raw_model_output": "SELECT DISTINCT s.tech_type\nFROM smart_city_tech AS s\nJOIN (\n    SELECT country\n    FROM country_populations\n    ORDER BY population DESC\n    FETCH FIRST 3 ROWS ONLY\n) AS top_countries\n  ON s.country = top_countries.country;", "latency_sec": 3.4039268493652344, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 122, "prompt_eval_sec": null, "tokens_completion": 204, "completion_eval_sec": null, "tokens_total": 326, "tokens_per_sec": 95.77174082362922, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve distinct tech_types from smart_city_tech where the country is among the top 3 most populous countries. The Reference SQL uses ROW_NUMBER() to rank countries by population and selects the top 3, while the Generated SQL uses ORDER BY and FETCH FIRST 3 ROWS ONLY. Both approaches effectively identify the same top 3 countries when ordered by population descending, assuming unique population values. The final result sets of tech_types would be identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify unique smart city technologies in the top 3 most populous countries. The reference query uses ROW_NUMBER() with a subquery to rank countries, while the generated query uses FETCH FIRST 3 ROWS ONLY for simplicity. Both approaches correctly filter the top 3 countries by population and join with smart_city_tech. The generated query is more concise and efficient, avoiding the need for window functions and nested subqueries. Both fulfill the business intent, but the generated version is more elegant.", "overall_assessment": "correct"}}
{"example_id": 5547, "sql_complexity": "multiple_joins", "prompt": "Which species have a population growth rate higher than the average for protected areas?", "context": "CREATE TABLE species (id INT, name VARCHAR(50), population DECIMAL(5,2), protected_area_id INT, growth_rate DECIMAL(5,2)); INSERT INTO species (id, name, population, protected_area_id, growth_rate) VALUES (1, 'Species 1', 500.00, 1, 0.05), (2, 'Species 2', 800.00, 1, 0.03), (3, 'Species 3', 1200.00, 2, 0.07), (4, 'Species 4', 700.00, 2, 0.02); CREATE TABLE protected_areas (id INT, name VARCHAR(50)); INSERT INTO protected_areas (id, name) VALUES (1, 'Area 1'), (2, 'Area 2');", "reference_sql": "SELECT s.name, s.growth_rate FROM species s INNER JOIN protected_areas pa ON s.protected_area_id = pa.id GROUP BY s.name, s.growth_rate HAVING s.growth_rate > (SELECT AVG(s.growth_rate) FROM species s INNER JOIN protected_areas pa ON s.protected_area_id = pa.id);", "generated_sql": "SELECT\n    id,\n    name,\n    population,\n    protected_area_id,\n    growth_rate\nFROM\n    species\nWHERE\n    growth_rate > (SELECT AVG(growth_rate) FROM species);", "raw_model_output": "SELECT\n    id,\n    name,\n    population,\n    protected_area_id,\n    growth_rate\nFROM\n    species\nWHERE\n    growth_rate > (SELECT AVG(growth_rate) FROM species);", "latency_sec": 5.234170913696289, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 259, "prompt_eval_sec": null, "tokens_completion": 252, "completion_eval_sec": null, "tokens_total": 511, "tokens_per_sec": 97.62768706364994, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects only 'name' and 'growth_rate' from a joined table, while the Generated SQL selects all columns from the 'species' table. Additionally, the Reference SQL's HAVING clause uses a subquery that joins with 'protected_areas' (though it doesn't filter rows in this specific case), whereas the Generated SQL's subquery directly averages 'growth_rate' from the 'species' table. The column selection and join logic differ, leading to different result structures.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly calculates the average growth rate of species within protected areas by joining the species table with protected_areas, ensuring the comparison is contextually accurate. The generated query incorrectly calculates the average growth rate of all species (including those not in protected areas) and omits the protected_areas context entirely. While both queries filter species with growth rates above an average, the reference query's subquery explicitly restricts to protected area species, aligning with the business intent. The generated query's subquery is semantically incorrect for the question's context.", "overall_assessment": "differently_correct"}}
{"example_id": 5498, "sql_complexity": "aggregation", "prompt": "Identify the destinations with the highest number of repeat visitors from the US.", "context": "CREATE TABLE RepeatTravelers (Visitor VARCHAR(20), Destination VARCHAR(20), VisitCount INT); INSERT INTO RepeatTravelers (Visitor, Destination, VisitCount) VALUES ('David', 'Paris', 3), ('Ella', 'London', 4), ('Fiona', 'Paris', 2);", "reference_sql": "SELECT Destination, AVG(VisitCount) AS AvgVisitCount FROM RepeatTravelers WHERE Visitor LIKE '%USA%' GROUP BY Destination ORDER BY AvgVisitCount DESC;", "generated_sql": "SELECT Destination\nFROM RepeatTravelers\nGROUP BY Destination\nHAVING SUM(VisitCount) = (\n    SELECT MAX(total_visits)\n    FROM (\n        SELECT SUM(VisitCount) AS total_visits\n        FROM RepeatTravelers\n        GROUP BY Destination\n    ) AS sub\n);", "raw_model_output": "```sql\nSELECT Destination\nFROM RepeatTravelers\nGROUP BY Destination\nHAVING SUM(VisitCount) = (\n    SELECT MAX(total_visits)\n    FROM (\n        SELECT SUM(VisitCount) AS total_visits\n        FROM RepeatTravelers\n        GROUP BY Destination\n    ) AS sub\n);\n```", "latency_sec": 4.168514013290405, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 142, "prompt_eval_sec": null, "tokens_completion": 275, "completion_eval_sec": null, "tokens_total": 417, "tokens_per_sec": 100.03564787607424, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the average VisitCount per destination for travelers with 'USA' in their name (which returns no rows in the given data) and orders the results. The Generated SQL finds destinations with the maximum total VisitCount (Paris in the data). The queries serve different purposes: one computes averages with a filter, the other identifies the destination with the highest total visits. They produce different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL attempts to filter for US visitors using WHERE Visitor LIKE '%USA%' but the sample data contains no US visitors (Visitors are names like 'David', 'Ella', 'Fiona'). The Generated SQL ignores the US filter entirely, focusing only on total visit counts. Neither query correctly addresses the business intent of identifying destinations with the highest number of repeat visitors from the US. The Reference SQL is closer to the intent by including a US filter, though it's technically flawed due to the lack of matching data. The Generated SQL fails to address the US requirement and uses SUM(VisitCount) instead of counting actual repeat visitors (which would require filtering VisitCount > 1).", "overall_assessment": "incorrect"}}
{"example_id": 3546, "sql_complexity": "window functions", "prompt": "What are the cryptocurrency exchanges with their corresponding blockchain companies, ranked by exchange ID in ascending order, for the Bitcoin platform?", "context": "CREATE TABLE cryptocurrency_exchanges (exchange_id INT, exchange_name VARCHAR(50), company_id INT); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (1, 'Binance', 1); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (2, 'Coinbase', 2); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (3, 'Kraken', 3); CREATE TABLE blockchain_companies (company_id INT, company_name VARCHAR(50), platform VARCHAR(50)); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (1, 'Binance', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (2, 'Blockstream', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (3, 'Blockchair', 'Bitcoin');", "reference_sql": "SELECT ce.exchange_name, bc.company_name, ce.exchange_id, ROW_NUMBER() OVER (PARTITION BY bc.platform ORDER BY ce.exchange_id ASC) as rank FROM cryptocurrency_exchanges ce JOIN blockchain_companies bc ON ce.company_id = bc.company_id WHERE bc.platform = 'Bitcoin';", "generated_sql": "SELECT\n    ce.exchange_id,\n    ce.exchange_name,\n    bc.company_name AS blockchain_company_name\nFROM\n    cryptocurrency_exchanges AS ce\nJOIN\n    blockchain_companies AS bc\n    ON ce.company_id = bc.company_id\nWHERE\n    bc.platform = 'Bitcoin'\nORDER BY\n    ce.exchange_id ASC;", "raw_model_output": "SELECT\n    ce.exchange_id,\n    ce.exchange_name,\n    bc.company_name AS blockchain_company_name\nFROM\n    cryptocurrency_exchanges AS ce\nJOIN\n    blockchain_companies AS bc\n    ON ce.company_id = bc.company_id\nWHERE\n    bc.platform = 'Bitcoin'\nORDER BY\n    ce.exchange_id ASC;", "latency_sec": 2.592543840408325, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 284, "prompt_eval_sec": null, "tokens_completion": 214, "completion_eval_sec": null, "tokens_total": 498, "tokens_per_sec": 192.08932641292003, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL includes a ROW_NUMBER() calculation as 'rank' and selects additional columns (exchange_name, company_name, exchange_id), while the Generated SQL omits the row number, changes column aliases, and excludes the 'company_name' column. The Generated SQL also lacks the window function logic present in the Reference SQL.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query includes a ROW_NUMBER() ranking column that isn't explicitly requested in the original question, while the generated query directly addresses the requirements. Both correctly join the tables and filter for Bitcoin, but the generated query: 1) Avoids unnecessary window functions 2) Returns exactly the requested columns (exchange_id, exchange_name, blockchain_company_name) 3) Uses explicit ORDER BY for ranking as required. The reference's ranking column adds complexity without business necessity, making the generated query more efficient and directly aligned with the question's requirements.", "overall_assessment": "differently_correct"}}
{"example_id": 486, "sql_complexity": "single join", "prompt": "What is the average price of paintings from African artists in our collection?", "context": "CREATE TABLE Artworks (id INT, title VARCHAR(50), price DECIMAL(10,2), medium VARCHAR(50), artist_nationality VARCHAR(50)); CREATE TABLE Collections (id INT, name VARCHAR(50), continent VARCHAR(50));", "reference_sql": "SELECT AVG(Artworks.price) FROM Artworks INNER JOIN Collections ON Artworks.artist_nationality = Collections.continent WHERE Artworks.medium = 'Painting' AND Collections.continent = 'Africa';", "generated_sql": "SELECT AVG(price) AS average_price\nFROM Artworks\nWHERE LOWER(medium) LIKE '%painting%'\n  AND artist_nationality = 'African';", "raw_model_output": "```sql\nSELECT AVG(price) AS average_price\nFROM Artworks\nWHERE LOWER(medium) LIKE '%painting%'\n  AND artist_nationality = 'African';\n```", "latency_sec": 5.184728145599365, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 131, "prompt_eval_sec": null, "tokens_completion": 310, "completion_eval_sec": null, "tokens_total": 441, "tokens_per_sec": 85.05749725263937, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in several key aspects.  The Reference SQL performs a JOIN between Artworks and Collections tables, filtering on both Artworks.medium = 'Painting' and Collections.continent = 'Africa'.  The Generated SQL, however, does not use a JOIN and instead filters on Artworks.artist_nationality = 'African' and a case-insensitive LIKE match for 'painting' in the medium.  These conditions are not equivalent.  The JOIN condition in the Reference SQL ensures that the artist's nationality matches the continent in the Collections table, while the Generated SQL directly checks the artist's nationality against a specific value.  Additionally, the medium filter in the Reference SQL is exact, while the Generated SQL uses a more general pattern match.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL contains a critical logical error: it joins Artworks.artist_nationality (a nationality) with Collections.continent (a continent), which are fundamentally different attributes. This would produce incorrect results because 'African' (nationality) \u2260 'Africa' (continent). The Generated SQL directly filters Artworks where artist_nationality = 'African' (assuming this matches the data) and checks for 'painting' in medium, which aligns with the business question. While both queries aim to calculate the average price, the Generated SQL avoids unnecessary complexity, is more direct, and better addresses the intent of identifying African artists without flawed joins.", "overall_assessment": "differently_correct"}}
{"example_id": 794, "sql_complexity": "multiple_joins", "prompt": "Which suppliers have provided raw materials for the production of chemicals with high environmental impact?", "context": "CREATE TABLE suppliers (id INT, name TEXT); INSERT INTO suppliers (id, name) VALUES (1, 'Supplier1'), (2, 'Supplier2'), (3, 'Supplier3'); CREATE TABLE chemicals (id INT, name TEXT, environmental_impact INT); INSERT INTO chemicals (id, name, environmental_impact) VALUES (1, 'ChemA', 10), (2, 'ChemB', 20), (3, 'ChemC', 15); CREATE TABLE raw_materials (chemical_id INT, supplier_id INT); INSERT INTO raw_materials (chemical_id, supplier_id) VALUES (1, 1), (1, 2), (2, 3), (3, 1);", "reference_sql": "SELECT s.name FROM suppliers s INNER JOIN raw_materials rm ON s.id = rm.supplier_id INNER JOIN chemicals c ON rm.chemical_id = c.id WHERE c.environmental_impact > 10;", "generated_sql": "SELECT DISTINCT\n       s.id,\n       s.name\nFROM   suppliers       AS s\nJOIN   raw_materials   AS rm ON rm.supplier_id = s.id\nJOIN   chemicals       AS c  ON c.id = rm.chemical_id\nWHERE  c.environmental_impact > 15;  -- threshold for \"high\" impact", "raw_model_output": "```sql\nSELECT DISTINCT\n       s.id,\n       s.name\nFROM   suppliers       AS s\nJOIN   raw_materials   AS rm ON rm.supplier_id = s.id\nJOIN   chemicals       AS c  ON c.id = rm.chemical_id\nWHERE  c.environmental_impact > 15;  -- threshold for \"high\" impact\n```", "latency_sec": 12.861646890640259, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 231, "prompt_eval_sec": null, "tokens_completion": 862, "completion_eval_sec": null, "tokens_total": 1093, "tokens_per_sec": 84.98134098172166, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Reference SQL uses WHERE c.environmental_impact > 10 while the Generated SQL uses WHERE c.environmental_impact > 15, which filters different sets of chemicals. Second, the Generated SQL includes DISTINCT, which is not present in the Reference. Additionally, the Generated SQL selects both id and name, whereas the Reference only selects name. These differences in filtering thresholds and output columns make the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in three key aspects: 1) The reference uses 'environmental_impact > 10' while the generated uses 'environmental_impact > 15' (different thresholds for 'high environmental impact'). 2) The reference returns only 's.name' while the generated returns 's.id' and 's.name'. 3) The generated includes 'DISTINCT' to eliminate duplicates, which the reference lacks. Semantically, the reference includes chemicals with impact 15 (ChemC) and 20 (ChemB), while the generated only includes 20 (ChemB). The original question doesn't define 'high', but the reference's threshold (10) aligns more with a general interpretation of 'high' as above average. The generated query's stricter threshold (15) may exclude valid suppliers. The reference better fulfills the intent by capturing more suppliers for chemicals with higher environmental impact.", "overall_assessment": "differently_correct"}}
{"example_id": 3164, "sql_complexity": "set operations", "prompt": "What is the average age of patients who received therapy in 'clinic_a' and 'clinic_b'?", "context": "CREATE TABLE clinic_a (patient_id INT, age INT, therapy_received BOOLEAN); INSERT INTO clinic_a (patient_id, age, therapy_received) VALUES (1, 35, true), (2, 42, true), (3, 28, false); CREATE TABLE clinic_b (patient_id INT, age INT, therapy_received BOOLEAN); INSERT INTO clinic_b (patient_id, age, therapy_received) VALUES (4, 50, true), (5, 32, false), (6, 45, true);", "reference_sql": "SELECT AVG(age) FROM (SELECT age FROM clinic_a WHERE therapy_received = true UNION ALL SELECT age FROM clinic_b WHERE therapy_received = true) AS combined_clinics;", "generated_sql": "SELECT AVG(age) AS average_age\nFROM (\n    SELECT age\n    FROM clinic_a\n    WHERE therapy_received = TRUE\n    \n    UNION ALL\n    \n    SELECT age\n    FROM clinic_b\n    WHERE therapy_received = TRUE\n) AS combined;", "raw_model_output": "SELECT AVG(age) AS average_age\nFROM (\n    SELECT age\n    FROM clinic_a\n    WHERE therapy_received = TRUE\n    \n    UNION ALL\n    \n    SELECT age\n    FROM clinic_b\n    WHERE therapy_received = TRUE\n) AS combined;", "latency_sec": 3.051574945449829, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 195, "prompt_eval_sec": null, "tokens_completion": 133, "completion_eval_sec": null, "tokens_total": 328, "tokens_per_sec": 107.4854807315407, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average age of patients who received therapy from both clinics. The subquery in both cases combines all 'age' values from clinic_a and clinic_b where therapy_received is true using UNION ALL, and the outer query computes the average. The differences in alias names ('combined_clinics' vs 'combined') and column alias ('average_age') do not affect the semantic result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the average age of patients who received therapy in clinic_a and clinic_b. They use identical logic: filtering therapy_received=true in both tables, combining results with UNION ALL, and applying AVG(age). The differences are purely syntactic (alias names) and formatting. Both queries would produce identical results given the sample data. The business intent is fully addressed by considering patients from both clinics who received therapy.", "overall_assessment": "correct"}}
{"example_id": 3704, "sql_complexity": "aggregation", "prompt": "What is the total sales revenue for each category of garments in the South America region in Q1 2022?", "context": "CREATE TABLE sales_category (sale_id INT, garment_category VARCHAR(50), sale_date DATE, total_sales DECIMAL(10, 2), region VARCHAR(50));", "reference_sql": "SELECT garment_category, SUM(total_sales) FROM sales_category WHERE sale_date BETWEEN '2022-01-01' AND '2022-03-31' AND region = 'South America' GROUP BY garment_category;", "generated_sql": "SELECT\n    garment_category,\n    SUM(total_sales) AS total_sales_revenue\nFROM\n    sales_category\nWHERE\n    region = 'South America'\n    AND sale_date >= DATE '2022-01-01'\n    AND sale_date <  DATE '2022-04-01'   -- covers Q1 (Jan-Mar) of 2022\nGROUP BY\n    garment_category\nORDER BY\n    garment_category;", "raw_model_output": "```sql\nSELECT\n    garment_category,\n    SUM(total_sales) AS total_sales_revenue\nFROM\n    sales_category\nWHERE\n    region = 'South America'\n    AND sale_date >= DATE '2022-01-01'\n    AND sale_date <  DATE '2022-04-01'   -- covers Q1 (Jan-Mar) of 2022\nGROUP BY\n    garment_category\nORDER BY\n    garment_category;\n```", "latency_sec": 3.5284249782562256, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 123, "prompt_eval_sec": null, "tokens_completion": 241, "completion_eval_sec": null, "tokens_total": 364, "tokens_per_sec": 103.16217639403844, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries aggregate total_sales by garment_category for 'South America' region during Q1 2022. The date range in the Generated SQL ('2022-01-01' <= sale_date < '2022-04-01') matches the Reference SQL's BETWEEN '2022-01-01' AND '2022-03-31' (inclusive). The ORDER BY in the Generated SQL does not affect the result set's content, and the column alias difference (total_sales_revenue vs. implicit SUM name) is syntactic, not semantic.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate total sales revenue per garment category in South America for Q1 2022. The reference uses BETWEEN '2022-01-01' AND '2022-03-31' while the generated uses date range [2022-01-01, 2022-04-01) which is technically more precise for Q1 (Jan-Mar). The generated query adds an explicit alias for clarity and includes ORDER BY (though not required). Both handle grouping and filtering correctly. The generated version demonstrates better date range handling by avoiding potential edge cases with inclusive bounds.", "overall_assessment": "correct"}}
{"example_id": 2851, "sql_complexity": "single join", "prompt": "How many cases were handled by attorneys who joined the firm in 2015 or later?", "context": "CREATE TABLE attorneys (attorney_id INT, join_year INT); CREATE TABLE cases (case_id INT, attorney_id INT, billing_amount INT);", "reference_sql": "SELECT COUNT(DISTINCT cases.case_id) FROM cases INNER JOIN attorneys ON cases.attorney_id = attorneys.attorney_id WHERE attorneys.join_year >= 2015;", "generated_sql": "SELECT COUNT(*) AS total_cases\nFROM cases c\nJOIN attorneys a\n  ON c.attorney_id = a.attorney_id\nWHERE a.join_year >= 2015;", "raw_model_output": "SELECT COUNT(*) AS total_cases\nFROM cases c\nJOIN attorneys a\n  ON c.attorney_id = a.attorney_id\nWHERE a.join_year >= 2015;", "latency_sec": 2.722175121307373, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 113, "prompt_eval_sec": null, "tokens_completion": 119, "completion_eval_sec": null, "tokens_total": 232, "tokens_per_sec": 85.2259644076748, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses COUNT(DISTINCT cases.case_id) while the Generated SQL uses COUNT(*). If there are multiple entries in the cases table for the same case_id, the first query would count each case_id only once, whereas the second query would count each occurrence. This difference in aggregation logic makes them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries differ in their aggregation approach: 'COUNT(DISTINCT cases.case_id)' vs 'COUNT(*)'. While both identify cases handled by attorneys joining in 2015 or later, the reference query ensures unique case counting (critical if a case could have multiple attorneys). The generated query might overcount cases with multiple attorney assignments. Both correctly join tables and filter by join_year, but the reference is more robust for the business intent of counting distinct cases.", "overall_assessment": "differently_correct"}}
{"example_id": 3246, "sql_complexity": "single join", "prompt": "What is the average eco-friendliness score of accommodations in Oceania by year?", "context": "CREATE TABLE Accommodations (Accommodation_ID INT, Accommodation_Name VARCHAR(50), City VARCHAR(30), Country VARCHAR(50), Eco_Friendliness_Score INT, Visit_Year INT); INSERT INTO Accommodations (Accommodation_ID, Accommodation_Name, City, Country, Eco_Friendliness_Score, Visit_Year) VALUES (1, 'EcoLodge', 'Sydney', 'Australia', 85, 2019), (2, 'GreenHotel', 'Melbourne', 'Australia', 90, 2019), (3, 'SustainableResort', 'Auckland', 'New Zealand', 80, 2019), (4, 'EcoVilla', 'Wellington', 'New Zealand', 88, 2019); CREATE TABLE Countries (Country VARCHAR(50), Continent VARCHAR(30)); INSERT INTO Countries (Country, Continent) VALUES ('Australia', 'Oceania'), ('New Zealand', 'Oceania');", "reference_sql": "SELECT C.Continent, V.Visit_Year, AVG(A.Eco_Friendliness_Score) AS Avg_Eco_Score  FROM Accommodations A  JOIN Countries C  ON A.Country = C.Country  WHERE C.Continent = 'Oceania'  GROUP BY C.Continent, V.Visit_Year  ORDER BY V.Visit_Year;", "generated_sql": "SELECT\n    a.Visit_Year,\n    AVG(a.Eco_Friendliness_Score) AS Avg_Eco_Friendliness_Score\nFROM\n    Accommodations AS a\nJOIN\n    Countries AS c\n    ON a.Country = c.Country\nWHERE\n    c.Continent = 'Oceania'\nGROUP BY\n    a.Visit_Year\nORDER BY\n    a.Visit_Year;", "raw_model_output": "```sql\nSELECT\n    a.Visit_Year,\n    AVG(a.Eco_Friendliness_Score) AS Avg_Eco_Friendliness_Score\nFROM\n    Accommodations AS a\nJOIN\n    Countries AS c\n    ON a.Country = c.Country\nWHERE\n    c.Continent = 'Oceania'\nGROUP BY\n    a.Visit_Year\nORDER BY\n    a.Visit_Year;\n```", "latency_sec": 4.234974145889282, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 280, "prompt_eval_sec": null, "tokens_completion": 235, "completion_eval_sec": null, "tokens_total": 515, "tokens_per_sec": 121.60640945113907, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes 'Continent' in both SELECT and GROUP BY clauses, while the Generated SQL omits it. Although the WHERE clause filters Continent to 'Oceania', the result sets differ in structure (extra column in Reference). The GROUP BY in Reference uses both Continent and Visit_Year, but since Continent is fixed, it effectively groups by Visit_Year alone. However, the SELECT list difference makes them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query contains a critical syntax error: it references 'V.Visit_Year' but defines no table alias 'V' (the Accommodations table is aliased as 'A'). This would cause a runtime error. The generated query correctly uses 'a.Visit_Year' with the proper alias. Both queries calculate the correct average by year, but the generated query is technically valid. While the reference query includes 'Continent' in the output (which is redundant since the filter is already on Oceania), the generated query is more concise and avoids unnecessary columns. The generated query better fulfills the business intent by producing valid results without extraneous data.", "overall_assessment": "differently_correct"}}
{"example_id": 3056, "sql_complexity": "multiple_joins", "prompt": "Identify all suppliers who provide non-GMO ingredients to restaurants with Michelin stars.", "context": "CREATE TABLE Suppliers (id INT, name VARCHAR(50), isNonGMO BOOLEAN); CREATE TABLE Restaurants (id INT, name VARCHAR(50), numStars INT); CREATE TABLE Ingredients (supplierId INT, restaurantId INT, isNonGMO BOOLEAN);", "reference_sql": "SELECT Suppliers.name FROM Suppliers INNER JOIN Ingredients ON Suppliers.id = Ingredients.supplierId INNER JOIN Restaurants ON Ingredients.restaurantId = Restaurants.id WHERE Restaurants.numStars > 2 AND Ingredients.isNonGMO = TRUE;", "generated_sql": "SELECT DISTINCT\n       s.id,\n       s.name\nFROM   Suppliers   AS s\nJOIN   Ingredients AS i ON i.supplierId  = s.id\nJOIN   Restaurants AS r ON r.id          = i.restaurantId\nWHERE  i.isNonGMO = TRUE\n  AND  r.numStars > 0;", "raw_model_output": "SELECT DISTINCT\n       s.id,\n       s.name\nFROM   Suppliers   AS s\nJOIN   Ingredients AS i ON i.supplierId  = s.id\nJOIN   Restaurants AS r ON r.id          = i.restaurantId\nWHERE  i.isNonGMO = TRUE\n  AND  r.numStars > 0;", "latency_sec": 5.310492277145386, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 133, "prompt_eval_sec": null, "tokens_completion": 278, "completion_eval_sec": null, "tokens_total": 411, "tokens_per_sec": 77.39395493875567, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in three key aspects: 1) The Reference SQL selects only 'Suppliers.name' while the Generated SQL selects 's.id' and 's.name' (different column sets). 2) The WHERE clause in Reference uses 'Restaurants.numStars > 2' whereas Generated uses 'r.numStars > 0' (different numeric thresholds). 3) The Generated SQL includes 'DISTINCT' which could eliminate duplicates not present in the Reference SQL. These differences ensure they do not produce identical results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries differ in three key aspects: 1) The reference query uses `numStars > 2` (only 3-star restaurants) while the generated query uses `numStars > 0` (any restaurant with stars, which better aligns with typical Michelin star classifications). 2) The generated query includes `DISTINCT` to avoid duplicate supplier entries, which is more appropriate for identifying unique suppliers. 3) The reference query returns only supplier names, while the generated query includes both ID and name. The generated query better fulfills the business intent by capturing all Michelin-starred restaurants (not just 3-star) and avoiding duplicates.", "overall_assessment": "differently_correct"}}
{"example_id": 264, "sql_complexity": "set operations", "prompt": "List the number of community health centers and infectious disease tracking facilities in 'southwest' regions.", "context": "CREATE TABLE centers (id INT, name TEXT, region TEXT); INSERT INTO centers (id, name, region) VALUES (1, 'Center A', 'southwest'); INSERT INTO centers (id, name, region) VALUES (2, 'Center B', 'northeast'); INSERT INTO centers (id, name, region) VALUES (3, 'Center C', 'northwest'); CREATE TABLE diseases (id INT, name TEXT, region TEXT); INSERT INTO diseases (id, name, region) VALUES (1, 'Disease A', 'southwest'); INSERT INTO diseases (id, name, region) VALUES (2, 'Disease B', 'southeast');", "reference_sql": "SELECT COUNT(*) FROM ( (SELECT * FROM centers WHERE region = 'southwest') UNION (SELECT * FROM diseases WHERE region = 'southwest') );", "generated_sql": "SELECT\n    (SELECT COUNT(*) FROM centers  WHERE region = 'southwest') AS community_health_centers,\n    (SELECT COUNT(*) FROM diseases WHERE region = 'southwest') AS infectious_disease_tracking_facilities;", "raw_model_output": "```sql\nSELECT\n    (SELECT COUNT(*) FROM centers  WHERE region = 'southwest') AS community_health_centers,\n    (SELECT COUNT(*) FROM diseases WHERE region = 'southwest') AS infectious_disease_tracking_facilities;\n```", "latency_sec": 3.1502468585968018, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 223, "prompt_eval_sec": null, "tokens_completion": 132, "completion_eval_sec": null, "tokens_total": 355, "tokens_per_sec": 112.68958146287171, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns a single count of combined rows from centers and diseases in the 'southwest' region using UNION, while the Generated SQL returns two separate counts as individual columns. The Reference SQL's result is a single integer (total rows from both tables), whereas the Generated SQL produces two integers (counts for centers and diseases separately). The output structures and values differ.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference query uses UNION to combine rows from centers and diseases tables, but this approach is fundamentally flawed. It would count all rows from both tables in 'southwest' as a single number (e.g., 1 center + 1 disease = 2 total), whereas the question requires separate counts for each facility type. The Generated query correctly uses two independent subqueries to count each table separately, producing the required two-column result. While both queries are technically valid SQL, only the Generated query aligns with the business intent of distinguishing between community health centers and infectious disease tracking facilities.", "overall_assessment": "differently_correct"}}
{"example_id": 2838, "sql_complexity": "basic SQL", "prompt": "What is the minimum safety rating of electric vehicles in the 'green_cars' table?", "context": "CREATE TABLE green_cars (id INT, make VARCHAR(50), model VARCHAR(50), type VARCHAR(50), safety_rating INT);", "reference_sql": "SELECT MIN(safety_rating) FROM green_cars WHERE type = 'Electric';", "generated_sql": "SELECT MIN(safety_rating) AS min_safety_rating\nFROM green_cars\nWHERE type = 'Electric';", "raw_model_output": "SELECT MIN(safety_rating) AS min_safety_rating\nFROM green_cars\nWHERE type = 'Electric';", "latency_sec": 1.7711191177368164, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 112, "prompt_eval_sec": null, "tokens_completion": 42, "completion_eval_sec": null, "tokens_total": 154, "tokens_per_sec": 86.95067342324515, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the minimum safety_rating from green_cars where type is 'Electric'. The generated query adds an alias (min_safety_rating) to the result column, but this does not affect the semantic value of the output. The core logic (aggregation, filtering) remains identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly retrieve the minimum safety rating for electric vehicles using the MIN() function with the same WHERE condition. The generated query adds an explicit alias (min_safety_rating) which improves readability but does not alter the result. Since the original question only asks for the minimum value without specifying column naming requirements, both queries are equally valid. The reference query is more concise while the generated query is slightly more descriptive, but neither offers a significant advantage in terms of technical correctness or business intent fulfillment.", "overall_assessment": "correct"}}
{"example_id": 1187, "sql_complexity": "multiple_joins", "prompt": "Who are the top 3 authors with the highest number of articles published in The Guardian?", "context": "CREATE TABLE authors (id INT, name VARCHAR(100), publisher VARCHAR(50)); CREATE TABLE articles_authors (article_id INT, author_id INT); INSERT INTO authors (id, name, publisher) VALUES (1, 'Author1', 'The Guardian'), (2, 'Author2', 'The Guardian'), (3, 'Author3', 'The Guardian'); INSERT INTO articles_authors (article_id, author_id) VALUES (1, 1), (2, 2), (3, 1), (3, 2), (3, 3); INSERT INTO articles (id, title, publication_date, publisher) VALUES (1, 'Article1', '2021-01-01', 'The Guardian'), (2, 'Article2', '2021-01-02', 'The Guardian'), (3, 'Article3', '2021-01-03', 'The Guardian');", "reference_sql": "SELECT a.name, COUNT(aa.article_id) AS articles_count FROM authors a JOIN articles_authors aa ON a.id = aa.author_id JOIN articles ar ON aa.article_id = ar.id WHERE ar.publisher = 'The Guardian' GROUP BY a.name ORDER BY articles_count DESC LIMIT 3;", "generated_sql": "SELECT\n    au.id,\n    au.name,\n    COUNT(*) AS article_count\nFROM authors AS au\nJOIN articles_authors AS aa\n      ON aa.author_id = au.id\nJOIN articles AS ar\n      ON ar.id = aa.article_id\nWHERE ar.publisher = 'The Guardian'\nGROUP BY au.id, au.name\nORDER BY article_count DESC\nFETCH FIRST 3 ROWS ONLY;", "raw_model_output": "```sql\nSELECT\n    au.id,\n    au.name,\n    COUNT(*) AS article_count\nFROM authors AS au\nJOIN articles_authors AS aa\n      ON aa.author_id = au.id\nJOIN articles AS ar\n      ON ar.id = aa.article_id\nWHERE ar.publisher = 'The Guardian'\nGROUP BY au.id, au.name\nORDER BY article_count DESC\nFETCH FIRST 3 ROWS ONLY;\n```", "latency_sec": 9.275871992111206, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 273, "prompt_eval_sec": null, "tokens_completion": 297, "completion_eval_sec": null, "tokens_total": 570, "tokens_per_sec": 61.44974838858971, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in selected columns (Reference includes only 'name' and 'articles_count', while Generated includes 'id', 'name', and 'article_count') and grouping logic (Reference groups by 'a.name' while Generated groups by 'au.id, au.name'). Although the data might overlap in the given sample, the schema allows for non-unique names, making the grouping behavior potentially different. Additionally, the output structure differs, violating semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify authors with the most articles in The Guardian. The reference query uses LIMIT 3 while the generated uses FETCH FIRST 3 ROWS ONLY - both achieve the same result. The generated query is more technically robust by grouping on both author.id and author.name (ensuring correctness even with duplicate names) and uses COUNT(*) which is slightly more efficient. The reference query's GROUP BY a.name could fail if multiple authors share the same name. Both fulfill the business intent but the generated query is more precise and avoids potential edge-case issues.", "overall_assessment": "correct"}}
{"example_id": 360, "sql_complexity": "window functions", "prompt": "What is the change in crime rate for each category, between this year and last year, for the same time period?", "context": "CREATE TABLE CrimeStatistics (ID INT, CrimeType VARCHAR(50), Date TIMESTAMP, Count INT); INSERT INTO CrimeStatistics (ID, CrimeType, Date, Count) VALUES (1, 'Theft', '2022-01-01 00:00:00', 100), (2, 'Vandalism', '2022-01-01 00:00:00', 50), (3, 'Theft', '2022-01-02 00:00:00', 120), (4, 'Vandalism', '2022-01-02 00:00:00', 60), (5, 'Theft', '2021-01-01 00:00:00', 80), (6, 'Vandalism', '2021-01-01 00:00:00', 40), (7, 'Theft', '2021-01-02 00:00:00', 90), (8, 'Vandalism', '2021-01-02 00:00:00', 45);", "reference_sql": "SELECT CrimeType, (SUM(Count) OVER (PARTITION BY CrimeType ORDER BY EXTRACT(YEAR FROM Date) ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)) - SUM(Count) OVER (PARTITION BY CrimeType ORDER BY EXTRACT(YEAR FROM Date)) AS CrimeRateChange FROM CrimeStatistics WHERE Date BETWEEN DATE_TRUNC('year', CURRENT_DATE - INTERVAL '1 year') AND CURRENT_DATE;", "generated_sql": "SELECT MAX(EXTRACT(YEAR FROM Date)) AS this_year\n    FROM CrimeStatistics\n), current_year_days AS (\n    -- month/day values that appear in the current-year data\n    SELECT DISTINCT \n           EXTRACT(MONTH FROM Date) AS mm,\n           EXTRACT(DAY   FROM Date) AS dd\n    FROM CrimeStatistics\n    WHERE EXTRACT(YEAR FROM Date) = (SELECT this_year FROM latest_year)\n), filtered AS (\n    -- keep only rows that fall in the same month/day window for both years\n    SELECT cs.*\n    FROM CrimeStatistics cs\n    JOIN current_year_days d\n      ON  EXTRACT(MONTH FROM cs.Date) = d.mm\n      AND EXTRACT(DAY   FROM cs.Date) = d.dd\n), yearly_totals AS (\n    -- aggregate counts per crime type and calendar year\n    SELECT CrimeType,\n           EXTRACT(YEAR FROM Date) AS yr,\n           SUM(Count)              AS total_cnt\n    FROM filtered\n    GROUP BY CrimeType, EXTRACT(YEAR FROM Date)\n)\nSELECT \n       cy.CrimeType,\n       cy.total_cnt AS this_year_count,\n       py.total_cnt AS last_year_count,\n       cy.total_cnt - py.total_cnt AS change_in_count\nFROM yearly_totals cy\nJOIN yearly_totals py\n      ON py.CrimeType = cy.CrimeType\nJOIN latest_year ly\n      ON cy.yr = ly.this_year\n     AND py.yr = ly.this_year - 1\nORDER BY cy.CrimeType;", "raw_model_output": "WITH latest_year AS (\n    -- most recent year present in the table\n    SELECT MAX(EXTRACT(YEAR FROM Date)) AS this_year\n    FROM CrimeStatistics\n), current_year_days AS (\n    -- month/day values that appear in the current-year data\n    SELECT DISTINCT \n           EXTRACT(MONTH FROM Date) AS mm,\n           EXTRACT(DAY   FROM Date) AS dd\n    FROM CrimeStatistics\n    WHERE EXTRACT(YEAR FROM Date) = (SELECT this_year FROM latest_year)\n), filtered AS (\n    -- keep only rows that fall in the same month/day window for both years\n    SELECT cs.*\n    FROM CrimeStatistics cs\n    JOIN current_year_days d\n      ON  EXTRACT(MONTH FROM cs.Date) = d.mm\n      AND EXTRACT(DAY   FROM cs.Date) = d.dd\n), yearly_totals AS (\n    -- aggregate counts per crime type and calendar year\n    SELECT CrimeType,\n           EXTRACT(YEAR FROM Date) AS yr,\n           SUM(Count)              AS total_cnt\n    FROM filtered\n    GROUP BY CrimeType, EXTRACT(YEAR FROM Date)\n)\nSELECT \n       cy.CrimeType,\n       cy.total_cnt AS this_year_count,\n       py.total_cnt AS last_year_count,\n       cy.total_cnt - py.total_cnt AS change_in_count\nFROM yearly_totals cy\nJOIN yearly_totals py\n      ON py.CrimeType = cy.CrimeType\nJOIN latest_year ly\n      ON cy.yr = ly.this_year\n     AND py.yr = ly.this_year - 1\nORDER BY cy.CrimeType;", "latency_sec": 26.21788215637207, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 322, "prompt_eval_sec": null, "tokens_completion": 1893, "completion_eval_sec": null, "tokens_total": 2215, "tokens_per_sec": 84.48432206648164, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their approach to calculating year-over-year changes. The Reference SQL uses window functions to compare cumulative sums, which may not accurately capture year-specific totals. The Generated SQL explicitly filters for matching month/day across years and calculates differences between full year totals. Additionally, the date filtering logic differs (current year window vs. same month/day comparison), leading to potentially different datasets and results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL fails to properly compare the same time periods between years. It uses window functions ordered by year but doesn't restrict to identical month/day ranges, leading to potential comparisons of different time frames (e.g., 2022 data vs. 2021 data covering different months/days). The Generated SQL correctly identifies the same month/day combinations in the current year, filters both years' data to match those periods, and explicitly compares corresponding years. This ensures accurate 'same time period' comparisons required by the question. The Reference SQL's WHERE clause also incorrectly uses CURRENT_DATE which may not align with the actual data range, while the Generated SQL handles year boundaries more precisely.", "overall_assessment": "differently_correct"}}
{"example_id": 335, "sql_complexity": "single join", "prompt": "List the policy numbers, claim amounts, and claim dates for policies that have more than two claims and the total claim amount exceeds $5000", "context": "CREATE TABLE policies (policy_number INT);CREATE TABLE claims (claim_id INT, policy_number INT, claim_amount DECIMAL(10,2), claim_date DATE);", "reference_sql": "SELECT p.policy_number, c.claim_amount, c.claim_date FROM policies p INNER JOIN claims c ON p.policy_number = c.policy_number GROUP BY p.policy_number, c.claim_amount, c.claim_date HAVING COUNT(c.claim_id) > 2 AND SUM(c.claim_amount) > 5000;", "generated_sql": "SELECT  c.policy_number,\n        c.claim_amount,\n        c.claim_date\nFROM    claims AS c\nJOIN    (\n        SELECT  policy_number\n        FROM    claims\n        GROUP BY policy_number\n        HAVING  COUNT(*) > 2\n            AND SUM(claim_amount) > 5000\n        ) AS qualified\n        ON qualified.policy_number = c.policy_number;", "raw_model_output": "```sql\nSELECT  c.policy_number,\n        c.claim_amount,\n        c.claim_date\nFROM    claims AS c\nJOIN    (\n        SELECT  policy_number\n        FROM    claims\n        GROUP BY policy_number\n        HAVING  COUNT(*) > 2\n            AND SUM(claim_amount) > 5000\n        ) AS qualified\n        ON qualified.policy_number = c.policy_number;\n```", "latency_sec": 4.781841039657593, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 128, "prompt_eval_sec": null, "tokens_completion": 230, "completion_eval_sec": null, "tokens_total": 358, "tokens_per_sec": 74.86656227820464, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query groups by policy_number, claim_amount, and claim_date, filtering groups with more than 2 claims and total claim_amount > 5000. The generated query filters policies with more than 2 claims (regardless of claim_amount/date) and then returns all claims for those policies. The generated query does not enforce the claim_amount/date grouping or the SUM(claim_amount) condition, leading to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL is technically incorrect because it groups by individual claim details (claim_amount, claim_date) rather than policy-level aggregation. This causes the HAVING clause to check per-claim-group counts (not total policy claims) and sums per-group amounts (not total policy amounts). The Generated SQL correctly first identifies qualifying policies via a subquery that groups by policy_number, ensuring accurate count and sum aggregation. It then retrieves all claims for those policies, which aligns with the business intent of listing all claims for policies meeting the criteria. The Generated SQL is more efficient as it avoids unnecessary joins and incorrect grouping.", "overall_assessment": "differently_correct"}}
{"example_id": 2866, "sql_complexity": "basic SQL", "prompt": "What is the number of hospitals in 'rural_healthcare' table?", "context": "CREATE TABLE rural_healthcare (name VARCHAR(255), type VARCHAR(255), location VARCHAR(255)); INSERT INTO rural_healthcare (name, type, location) VALUES ('Rural General Hospital', 'Hospital', 'Bushland'), ('Rural Community Hospital', 'Hospital', 'Forest Region');", "reference_sql": "SELECT COUNT(*) FROM rural_healthcare WHERE type = 'Hospital';", "generated_sql": "SELECT COUNT(*) AS hospital_count\nFROM rural_healthcare\nWHERE type = 'Hospital';", "raw_model_output": "SELECT COUNT(*) AS hospital_count\nFROM rural_healthcare\nWHERE type = 'Hospital';", "latency_sec": 2.7103447914123535, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 141, "prompt_eval_sec": null, "tokens_completion": 101, "completion_eval_sec": null, "tokens_total": 242, "tokens_per_sec": 89.28753299829961, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries count the number of rows in the rural_healthcare table where type is 'Hospital'. The generated query adds an alias (hospital_count) to the COUNT(*) result, but this does not affect the actual count value returned. The semantic result (the numeric count) remains identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly count rows where type = 'Hospital' in the rural_healthcare table. The reference query uses minimal syntax, while the generated query adds an explicit alias (hospital_count) for clarity. The alias does not affect the result but improves readability. Neither query has logical or syntactic issues. Both fulfill the business intent of counting hospitals. The difference in formatting does not impact correctness or efficiency.", "overall_assessment": "correct"}}
{"example_id": 4440, "sql_complexity": "multiple_joins", "prompt": "What is the average session length for each game genre in the last month, sorted by average session length.", "context": "CREATE TABLE game_sessions(id INT, user_id INT, game_name VARCHAR(50), start_time DATETIME, end_time DATETIME); CREATE TABLE games(id INT, name VARCHAR(50), genre VARCHAR(50));", "reference_sql": "SELECT genres.genre, AVG(TIMESTAMPDIFF(SECOND, start_time, end_time)) as avg_session_length FROM game_sessions JOIN games ON game_sessions.game_name = games.name JOIN (SELECT DISTINCT game_name, genre FROM game_sessions JOIN games ON game_sessions.game_name = games.name) genres ON games.name = genres.game_name WHERE start_time >= DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH) GROUP BY genres.genre ORDER BY avg_session_length DESC;", "generated_sql": "SELECT \n        g.genre,\n        AVG(s.end_time - s.start_time) AS avg_session_length\nFROM    game_sessions AS s\nJOIN    games          AS g  ON g.name = s.game_name\nWHERE   s.start_time >= CURRENT_DATE - INTERVAL '1' MONTH\n  AND   s.end_time IS NOT NULL\nGROUP BY g.genre\nORDER BY avg_session_length DESC;", "raw_model_output": "SELECT \n        g.genre,\n        AVG(s.end_time - s.start_time) AS avg_session_length\nFROM    game_sessions AS s\nJOIN    games          AS g  ON g.name = s.game_name\nWHERE   s.start_time >= CURRENT_DATE - INTERVAL '1' MONTH\n  AND   s.end_time IS NOT NULL\nGROUP BY g.genre\nORDER BY avg_session_length DESC;", "latency_sec": 5.319108009338379, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 130, "prompt_eval_sec": null, "tokens_completion": 356, "completion_eval_sec": null, "tokens_total": 486, "tokens_per_sec": 91.3687030131301, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. 1) The Generated SQL includes an additional condition 's.end_time IS NOT NULL' which the Reference SQL lacks, potentially excluding some sessions from the calculation. 2) The calculation of the average session length differs: the Reference SQL uses TIMESTAMPDIFF(SECOND, start_time, end_time) which accurately calculates the difference in seconds, while the Generated SQL uses 's.end_time - s.start_time' which in MySQL returns the difference in days, leading to a significantly different (and incorrect) average value.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries differ in several critical aspects. 1) The Reference SQL correctly calculates session length in seconds using TIMESTAMPDIFF, while the Generated SQL calculates the difference in days (due to subtracting DATETIMEs). 2) The Generated SQL contains a syntax error in the WHERE clause (INTERVAL '1' MONTH should be INTERVAL 1 MONTH). 3) The Reference SQL includes a redundant subquery that's unnecessary given the one-to-one relationship between game_name and genre. 4) The Generated SQL includes an unnecessary check for end_time IS NOT NULL. 5) The Reference SQL's subquery might cause performance issues.  While the Generated SQL is more concise, its incorrect calculation of session length and syntax error make it technically inferior. The Reference SQL, despite its subquery, correctly addresses the business intent of calculating average session length in seconds.", "overall_assessment": "incorrect"}}
{"example_id": 451, "sql_complexity": "single join", "prompt": "Which customers have made a transaction over 500 in the \"risk_management\" category?", "context": "CREATE TABLE customers (id INT, name VARCHAR(50), category VARCHAR(50)); INSERT INTO customers (id, name, category) VALUES (1, 'John Doe', 'risk_management'); INSERT INTO customers (id, name, category) VALUES (2, 'Jane Smith', 'compliance'); INSERT INTO customers (id, name, category) VALUES (3, 'Jim Brown', 'risk_management'); CREATE TABLE transactions (id INT, customer_id INT, amount DECIMAL(10, 2)); INSERT INTO transactions (id, customer_id, amount) VALUES (1, 1, 500.00); INSERT INTO transactions (id, customer_id, amount) VALUES (2, 1, 200.00); INSERT INTO transactions (id, customer_id, amount) VALUES (3, 2, 100.00); INSERT INTO transactions (id, customer_id, amount) VALUES (4, 3, 750.00);", "reference_sql": "SELECT c.name FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE c.category = 'risk_management' AND t.amount > 500;", "generated_sql": "SELECT DISTINCT\n       c.id,\n       c.name\nFROM   customers     AS c\nJOIN   transactions  AS t\n       ON t.customer_id = c.id\nWHERE  c.category = 'risk_management'\n  AND  t.amount > 500;", "raw_model_output": "SELECT DISTINCT\n       c.id,\n       c.name\nFROM   customers     AS c\nJOIN   transactions  AS t\n       ON t.customer_id = c.id\nWHERE  c.category = 'risk_management'\n  AND  t.amount > 500;", "latency_sec": 2.2837510108947754, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 278, "prompt_eval_sec": null, "tokens_completion": 135, "completion_eval_sec": null, "tokens_total": 413, "tokens_per_sec": 180.84283182788226, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects only 'c.name', while the Generated SQL selects 'c.id' and 'c.name'. Additionally, the Generated SQL includes a 'DISTINCT' clause, which could affect results if there were duplicate rows. Although both filter for 'risk_management' customers with transactions over 500, the column sets differ, making their result structures incompatible.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query returns customer names without deduplication, potentially listing the same customer multiple times if they have multiple qualifying transactions. The generated query uses DISTINCT to ensure each customer appears only once, which better aligns with the business intent of identifying customers (not transactions). Both correctly filter for 'risk_management' category and transactions > 500, but the generated query handles edge cases more robustly. The reference query's omission of DISTINCT could lead to inflated results, while the generated query's inclusion of id adds explicit identification without conflicting with the question's requirements.", "overall_assessment": "differently_correct"}}
{"example_id": 2879, "sql_complexity": "basic SQL", "prompt": "Update the FoodSafetyRecords.OrganicFarms table to include a new record for a certified organic farm in Kenya.", "context": "CREATE TABLE FoodSafetyRecords.OrganicFarms (farmName TEXT, country TEXT, certified BOOLEAN);", "reference_sql": "INSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('Ngong Organic Farm', 'Kenya', TRUE);", "generated_sql": "INSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified)\nVALUES ('Shamba Organics', 'Kenya', TRUE);", "raw_model_output": "INSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified)\nVALUES ('Shamba Organics', 'Kenya', TRUE);", "latency_sec": 5.165711164474487, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 109, "prompt_eval_sec": null, "tokens_completion": 305, "completion_eval_sec": null, "tokens_total": 414, "tokens_per_sec": 80.14385373443864, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The two queries insert different farm names ('Ngong Organic Farm' vs 'Shamba Organics') into the OrganicFarms table. While the structure and other values (country 'Kenya', certified TRUE) are identical, the distinct farmName results in different data being inserted, making them semantically non-equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly insert a new certified organic farm record for Kenya. The technical structure (column order, data types, and syntax) is identical. The only difference is the farm name ('Ngong Organic Farm' vs. 'Shamba Organics'), which does not affect technical correctness or business intent fulfillment. Since the original question did not specify a particular farm name, both queries satisfy the requirement equally. Neither query is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 5688, "sql_complexity": "single join", "prompt": "What is the total amount donated to a specific cause?", "context": "CREATE TABLE causes (id INT, name TEXT); CREATE TABLE donations (id INT, donor_id INT, cause_id INT, donation_amount DECIMAL(10,2)); INSERT INTO causes (id, name) VALUES (1, 'Cause A'), (2, 'Cause B'); INSERT INTO donations (id, donor_id, cause_id, donation_amount) VALUES (1, 1, 1, 50.00), (2, 2, 1, 100.00);", "reference_sql": "SELECT SUM(donation_amount) FROM donations JOIN causes ON donations.cause_id = causes.id WHERE causes.name = 'Cause A';", "generated_sql": "SELECT\n    c.name AS cause_name,\n    SUM(d.donation_amount) AS total_amount_donated\nFROM donations d\nJOIN causes   c ON c.id = d.cause_id\nWHERE c.name = 'Cause A'  -- specify the desired cause here\nGROUP BY c.name;", "raw_model_output": "SELECT\n    c.name AS cause_name,\n    SUM(d.donation_amount) AS total_amount_donated\nFROM donations d\nJOIN causes   c ON c.id = d.cause_id\nWHERE c.name = 'Cause A'  -- specify the desired cause here\nGROUP BY c.name;", "latency_sec": 4.907762050628662, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 178, "prompt_eval_sec": null, "tokens_completion": 272, "completion_eval_sec": null, "tokens_total": 450, "tokens_per_sec": 91.69148694614422, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns a single aggregated sum value, while the Generated SQL returns a structured result with two columns (cause_name and total_amount_donated). Although both queries filter for 'Cause A' and calculate the same sum, their output structures differ, making them semantically non-equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries correctly calculate the total donation amount for 'Cause A'. The reference query is more direct, returning only the sum without unnecessary grouping. The generated query includes an extra column (cause_name) and GROUP BY clause, which are redundant given the WHERE condition filters a single cause. While both produce the same numerical result, the reference query is technically more efficient and aligns better with the simple business intent of retrieving a single total value.", "overall_assessment": "correct"}}
{"example_id": 3273, "sql_complexity": "multiple_joins", "prompt": "List all departments, the number of chemicals they handle, and the number of machines used in their manufacturing processes.", "context": "CREATE TABLE Departments (DepartmentID INT, DepartmentName VARCHAR(20)); INSERT INTO Departments (DepartmentID, DepartmentName) VALUES (1, 'Manufacturing'), (2, 'Engineering'), (3, 'Chemical Safety'), (4, 'Product Development'); CREATE TABLE Chemicals (ChemicalID INT, ChemicalName VARCHAR(20), DepartmentID INT); INSERT INTO Chemicals (ChemicalID, ChemicalName, DepartmentID) VALUES (1, 'Hydrochloric Acid', 1), (2, 'Nitric Acid', 2), (3, 'Sodium Hydroxide', 3), (4, 'New Chemical', 4); CREATE TABLE Machinery (MachineID INT, MachineName VARCHAR(20), DepartmentID INT); INSERT INTO Machinery (MachineID, MachineName, DepartmentID) VALUES (1, 'Mixer 1', 1), (2, 'Cutter 2', 2), (3, 'Dispenser 3', 3), (4, 'Innovator 4', 4);", "reference_sql": "SELECT D.DepartmentName, COUNT(C.ChemicalID) AS ChemicalCount, COUNT(M.MachineID) AS MachineCount FROM Departments D LEFT JOIN Chemicals C ON D.DepartmentID = C.DepartmentID LEFT JOIN Machinery M ON D.DepartmentID = M.DepartmentID GROUP BY D.DepartmentName;", "generated_sql": "SELECT\n    d.DepartmentName,\n    ( SELECT COUNT(*) \n      FROM Chemicals c \n      WHERE c.DepartmentID = d.DepartmentID\n    ) AS ChemicalCount,\n    ( SELECT COUNT(*) \n      FROM Machinery m \n      WHERE m.DepartmentID = d.DepartmentID\n    ) AS MachineCount\nFROM Departments d;", "raw_model_output": "```sql\nSELECT\n    d.DepartmentName,\n    ( SELECT COUNT(*) \n      FROM Chemicals c \n      WHERE c.DepartmentID = d.DepartmentID\n    ) AS ChemicalCount,\n    ( SELECT COUNT(*) \n      FROM Machinery m \n      WHERE m.DepartmentID = d.DepartmentID\n    ) AS MachineCount\nFROM Departments d;\n```", "latency_sec": 3.351433038711548, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 298, "prompt_eval_sec": null, "tokens_completion": 280, "completion_eval_sec": null, "tokens_total": 578, "tokens_per_sec": 172.4635382308611, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL groups by DepartmentName, which could aggregate multiple departments with the same name (if they exist), while the Generated SQL returns each department as a separate row. Although the sample data has unique DepartmentNames, the schema does not enforce uniqueness, making the queries behave differently in general cases.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries produce the same results for the given schema. The Reference SQL uses LEFT JOINs with GROUP BY, which works but has a potential flaw: grouping by DepartmentName (not the primary key) could merge departments with identical names. The Generated SQL uses correlated subqueries, which are more explicit, avoid grouping issues, and may perform better with proper indexing. While both fulfill the business intent, the Generated version is more elegant and robust in edge cases.", "overall_assessment": "correct"}}
{"example_id": 1895, "sql_complexity": "window functions", "prompt": "What is the average safety score of chemical production sites in the United States, partitioned by state and ranked in descending order?", "context": "CREATE TABLE production_sites (site_id INT, site_name TEXT, country TEXT, state TEXT, safety_score FLOAT); INSERT INTO production_sites (site_id, site_name, country, state, safety_score) VALUES (1, 'Site A', 'USA', 'NY', 92.5), (2, 'Site B', 'USA', 'CA', 87.4), (3, 'Site C', 'USA', 'TX', 95.3), (4, 'Site D', 'USA', 'FL', 89.2);", "reference_sql": "SELECT state, AVG(safety_score) as avg_safety_score, ROW_NUMBER() OVER (ORDER BY AVG(safety_score) DESC) as rank FROM production_sites WHERE country = 'USA' GROUP BY state ORDER BY rank;", "generated_sql": "SELECT\n        state,\n        AVG(safety_score) AS avg_safety_score\n    FROM production_sites\n    WHERE country = 'USA'\n    GROUP BY state\n)\nSELECT\n    state,\n    avg_safety_score,\n    RANK() OVER (ORDER BY avg_safety_score DESC) AS safety_rank\nFROM state_avg\nORDER BY\n    avg_safety_score DESC;", "raw_model_output": "-- Average safety score per U.S. state, ranked from highest to lowest\nWITH state_avg AS (\n    SELECT\n        state,\n        AVG(safety_score) AS avg_safety_score\n    FROM production_sites\n    WHERE country = 'USA'\n    GROUP BY state\n)\nSELECT\n    state,\n    avg_safety_score,\n    RANK() OVER (ORDER BY avg_safety_score DESC) AS safety_rank\nFROM state_avg\nORDER BY\n    avg_safety_score DESC;", "latency_sec": 7.488234043121338, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 205, "prompt_eval_sec": null, "tokens_completion": 375, "completion_eval_sec": null, "tokens_total": 580, "tokens_per_sec": 77.45484404734728, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries group production_sites by state, calculate average safety scores, and rank them in descending order. The Reference SQL uses ROW_NUMBER() with ORDER BY AVG(safety_score) DESC and orders by the generated rank. The Generated SQL uses RANK() with the same ordering and explicitly sorts by average safety score. Since all safety scores are unique, ROW_NUMBER() and RANK() produce identical results. The final output order and values match.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The Reference SQL is technically correct and fulfills the business intent. It groups by state, calculates the average safety score, and assigns a row number rank based on descending average scores. The Generated SQL contains syntax errors (missing WITH clause for CTE, misplaced parenthesis) and would fail to execute. Even if fixed, it uses RANK() instead of ROW_NUMBER(), which could produce different ranking results (ties would receive same rank vs. unique ranks). The Reference SQL directly addresses the question with proper syntax and logic.", "overall_assessment": "incorrect"}}
{"example_id": 4669, "sql_complexity": "set operations", "prompt": "Identify the number of IoT devices in each country and the total number of devices.", "context": "CREATE TABLE device_country (device_id INT, country TEXT); INSERT INTO device_country (device_id, country) VALUES (1, 'USA'), (2, 'Canada'), (3, 'Mexico'), (4, 'Brazil'); CREATE TABLE device_info (device_id INT, device_type TEXT); INSERT INTO device_info (device_id, device_type) VALUES (1, 'Soil Sensor'), (2, 'Temperature Sensor'), (3, 'Humidity Sensor'), (4, 'Precision Sprayer');", "reference_sql": "SELECT country, COUNT(*) AS device_count FROM device_country GROUP BY country UNION SELECT 'Total' AS country, COUNT(*) FROM device_country;", "generated_sql": "SELECT \n    COALESCE(dc.country, 'Total') AS country,\n    COUNT(*) AS device_count\nFROM device_country AS dc\nJOIN device_info AS di ON di.device_id = dc.device_id   -- count only valid devices\nGROUP BY GROUPING SETS ( (dc.country), () );", "raw_model_output": "SELECT \n    COALESCE(dc.country, 'Total') AS country,\n    COUNT(*) AS device_count\nFROM device_country AS dc\nJOIN device_info AS di ON di.device_id = dc.device_id   -- count only valid devices\nGROUP BY GROUPING SETS ( (dc.country), () );", "latency_sec": 7.509267091751099, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 185, "prompt_eval_sec": null, "tokens_completion": 400, "completion_eval_sec": null, "tokens_total": 585, "tokens_per_sec": 77.90374118435876, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL counts all devices in device_country without considering device_info, while the Generated SQL explicitly joins with device_info, filtering devices to only those present in both tables. This join introduces a semantic difference: the Generated SQL excludes device_country entries without matching device_info records, whereas the Reference SQL includes all device_country entries. Although the sample data may produce matching results, the queries are not semantically equivalent in general.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent. The reference query correctly counts all devices in device_country without filtering, while the generated query incorrectly joins with device_info, potentially excluding devices that lack corresponding entries in device_info. The reference properly uses UNION to include a total row, whereas the generated query's GROUPING SETS approach would produce a total row but might misrepresent counts if devices are missing from device_info. The business intent to count all IoT devices (implied to be in device_country) is better fulfilled by the reference query.", "overall_assessment": "incorrect"}}
{"example_id": 5302, "sql_complexity": "multiple_joins", "prompt": "Find the supplier with the lowest average delivery time for orders in the last month.", "context": "CREATE TABLE Suppliers (SupplierID int, SupplierName varchar(50)); CREATE TABLE Products (ProductID int, ProductName varchar(50), SupplierID int); CREATE TABLE Orders (OrderID int, ProductID int, OrderDate date, DeliveryTime int); INSERT INTO Suppliers VALUES (1, 'SupplierA'), (2, 'SupplierB'); INSERT INTO Products VALUES (1, 'Organic Apples', 1), (2, 'Bananas', 2); INSERT INTO Orders VALUES (1, 1, '2022-01-01', 2), (2, 2, '2022-01-03', 3);", "reference_sql": "SELECT SupplierName, AVG(DeliveryTime) as AvgDeliveryTime FROM Orders o JOIN Products p ON o.ProductID = p.ProductID JOIN Suppliers sp ON p.SupplierID = sp.SupplierID WHERE OrderDate >= DATEADD(month, -1, GETDATE()) GROUP BY SupplierName ORDER BY AvgDeliveryTime ASC;", "generated_sql": "SELECT\n    s.SupplierID,\n    s.SupplierName\nFROM Suppliers  AS s\nJOIN Products   AS p ON p.SupplierID = s.SupplierID\nJOIN Orders     AS o ON o.ProductID  = p.ProductID\nWHERE o.OrderDate >= CURRENT_DATE - INTERVAL '1' MONTH\nGROUP BY s.SupplierID, s.SupplierName\nORDER BY AVG(o.DeliveryTime) ASC\nFETCH FIRST 1 ROW ONLY;", "raw_model_output": "SELECT\n    s.SupplierID,\n    s.SupplierName\nFROM Suppliers  AS s\nJOIN Products   AS p ON p.SupplierID = s.SupplierID\nJOIN Orders     AS o ON o.ProductID  = p.ProductID\nWHERE o.OrderDate >= CURRENT_DATE - INTERVAL '1' MONTH\nGROUP BY s.SupplierID, s.SupplierName\nORDER BY AVG(o.DeliveryTime) ASC\nFETCH FIRST 1 ROW ONLY;", "latency_sec": 6.327532052993774, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 214, "prompt_eval_sec": null, "tokens_completion": 364, "completion_eval_sec": null, "tokens_total": 578, "tokens_per_sec": 91.34683082743582, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in several key aspects. 1) The Reference SQL returns SupplierName and AvgDeliveryTime, while the Generated SQL returns SupplierID and SupplierName. 2) The Generated SQL includes a FETCH FIRST 1 ROW ONLY clause, limiting the result to a single row, whereas the Reference SQL returns all suppliers sorted by average delivery time. 3) The GROUP BY clause in the Generated SQL includes both SupplierID and SupplierName, while the Reference SQL only groups by SupplierName.  These differences ensure the queries produce different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in technical implementation and result structure. The Reference SQL uses SQL Server's DATEADD and GETDATE() functions, while the Generated SQL uses PostgreSQL-style CURRENT_DATE - INTERVAL '1' MONTH. The Reference also lacks a mechanism to limit results to the top supplier, returning all suppliers sorted by average delivery time instead. The Generated SQL correctly uses FETCH FIRST 1 ROW ONLY to identify the supplier with the lowest average delivery time. Both queries correctly join tables and calculate averages, but the Generated version better fulfills the business intent by explicitly returning the single supplier with the lowest average. The Reference would require additional processing to extract the top result.", "overall_assessment": "differently_correct"}}
{"example_id": 267, "sql_complexity": "subqueries", "prompt": "What is the total number of disability support programs offered in urban and rural areas, and the percentage of total programs for each area type?", "context": "CREATE TABLE programs (program_id INT, program_name VARCHAR(255), area_type VARCHAR(255));", "reference_sql": "SELECT area_type, COUNT(*) as total_programs, ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM programs) , 2) as percentage_of_total FROM programs WHERE area_type IN ('urban', 'rural') GROUP BY area_type;", "generated_sql": "SELECT\n    area_type,\n    COUNT(*) AS total_programs,\n    100.0 * COUNT(*) / (\n        SELECT COUNT(*)\n        FROM programs\n        WHERE area_type IN ('urban', 'rural')\n    ) AS percentage_of_total\nFROM programs\nWHERE area_type IN ('urban', 'rural')\nGROUP BY area_type;", "raw_model_output": "```sql\nSELECT\n    area_type,\n    COUNT(*) AS total_programs,\n    100.0 * COUNT(*) / (\n        SELECT COUNT(*)\n        FROM programs\n        WHERE area_type IN ('urban', 'rural')\n    ) AS percentage_of_total\nFROM programs\nWHERE area_type IN ('urban', 'rural')\nGROUP BY area_type;\n```", "latency_sec": 7.695766925811768, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 113, "prompt_eval_sec": null, "tokens_completion": 350, "completion_eval_sec": null, "tokens_total": 463, "tokens_per_sec": 60.16294470237762, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses the total count of all programs (from the entire programs table) in the percentage calculation, while the Generated SQL uses a subquery that filters area_type to ('urban', 'rural') for the denominator. This difference in denominator calculation leads to different percentage results when there are programs with area_type values other than 'urban' or 'rural'.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in how they calculate the total programs for percentage computation. The reference query uses (SELECT COUNT(*) FROM programs) which includes all programs (including non-urban/rural areas) in the denominator, while the generated query uses (SELECT COUNT(*) FROM programs WHERE area_type IN ('urban', 'rural')) which restricts the total to only urban/rural programs. The original question asks for 'percentage of total programs for each area type' where the 'total' likely refers to the sum of urban and rural programs (as those are the only areas mentioned). The generated query correctly calculates percentages relative to this subset, making it more accurate for the business intent. Both queries are syntactically correct and fulfill the intent, but the generated version better aligns with the question's implicit context.", "overall_assessment": "differently_correct"}}
{"example_id": 3028, "sql_complexity": "basic SQL", "prompt": "What is the number of startups founded by non-binary individuals in the technology industry?", "context": "CREATE TABLE company (id INT, name TEXT, founder_gender TEXT, industry TEXT); INSERT INTO company (id, name, founder_gender, industry) VALUES (1, 'CodeForAll', 'Non-binary', 'Technology'); INSERT INTO company (id, name, founder_gender, industry) VALUES (2, 'TechVillage', 'Male', 'Technology');", "reference_sql": "SELECT COUNT(*) FROM company WHERE founder_gender = 'Non-binary' AND industry = 'Technology';", "generated_sql": "SELECT COUNT(*) AS startup_count\nFROM company\nWHERE founder_gender = 'Non-binary'\n  AND industry = 'Technology';", "raw_model_output": "SELECT COUNT(*) AS startup_count\nFROM company\nWHERE founder_gender = 'Non-binary'\n  AND industry = 'Technology';", "latency_sec": 2.1757237911224365, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 157, "prompt_eval_sec": null, "tokens_completion": 109, "completion_eval_sec": null, "tokens_total": 266, "tokens_per_sec": 122.25816580457254, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries count the number of companies where founder_gender is 'Non-binary' and industry is 'Technology'. The generated query adds an alias 'startup_count' to the COUNT(*) result, but this does not affect the semantic result - the numerical count remains identical. The WHERE conditions and table structure are exactly the same in both queries.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly count startups founded by non-binary individuals in the technology industry. The reference query uses minimal syntax, while the generated query adds an alias ('startup_count') for clarity. The alias does not alter the result or logic but may improve readability. Since the original question only requires the count, both queries fulfill the business intent equally. The technical equivalence is confirmed by identical WHERE conditions and aggregate function usage.", "overall_assessment": "correct"}}
{"example_id": 3282, "sql_complexity": "aggregation", "prompt": "Which marine species have been observed in both the Arctic and Antarctic oceans?", "context": "CREATE TABLE marine_species (id INT, species_name VARCHAR(50), common_name VARCHAR(50), region VARCHAR(20));INSERT INTO marine_species (id, species_name, common_name, region) VALUES (1, 'Orcinus_orca', 'Killer Whale', 'Arctic');INSERT INTO marine_species (id, species_name, common_name, region) VALUES (2, 'Balaenoptera_bonaerensis', 'Antarctic Minke Whale', 'Antarctic');", "reference_sql": "SELECT species_name FROM marine_species WHERE region IN ('Arctic', 'Antarctic') GROUP BY species_name HAVING COUNT(DISTINCT region) = 2;", "generated_sql": "SELECT\n    species_name,\n    common_name\nFROM\n    marine_species\nWHERE\n    region IN ('Arctic', 'Antarctic')\nGROUP BY\n    species_name,\n    common_name\nHAVING\n    COUNT(DISTINCT region) = 2;", "raw_model_output": "SELECT\n    species_name,\n    common_name\nFROM\n    marine_species\nWHERE\n    region IN ('Arctic', 'Antarctic')\nGROUP BY\n    species_name,\n    common_name\nHAVING\n    COUNT(DISTINCT region) = 2;", "latency_sec": 4.5143420696258545, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 183, "prompt_eval_sec": null, "tokens_completion": 266, "completion_eval_sec": null, "tokens_total": 449, "tokens_per_sec": 99.46078367012467, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects only 'species_name' and groups by it, while the Generated SQL selects both 'species_name' and 'common_name' and groups by both. This difference in grouping and selected columns leads to different result structures. Additionally, the Generated SQL may return more rows if a species_name has multiple common_names across regions, as the grouping criterion is stricter.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent because the generated query includes 'common_name' in both SELECT and GROUP BY clauses, while the reference query only returns 'species_name'. Both correctly identify species present in both regions via the HAVING COUNT(DISTINCT region) = 2 condition. However, the reference query is more precise for the business intent, as the original question only asks for species names (not common names). The generated query's additional columns introduce unnecessary complexity without enhancing the core answer. The reference query is also more efficient due to simpler grouping.", "overall_assessment": "differently_correct"}}
{"example_id": 3474, "sql_complexity": "subqueries", "prompt": "What is the total transaction volume for the top 3 digital assets by market capitalization in the 'developed_markets' schema?", "context": "CREATE SCHEMA developed_markets; CREATE TABLE developed_markets.digital_assets (asset_name VARCHAR(10), market_cap BIGINT, daily_transaction_volume BIGINT); INSERT INTO developed_markets.digital_assets (asset_name, market_cap, daily_transaction_volume) VALUES ('AssetG', 30000000, 15000000), ('AssetH', 25000000, 12000000), ('AssetI', 20000000, 10000000), ('AssetJ', 15000000, 8000000), ('AssetK', 10000000, 6000000);", "reference_sql": "SELECT SUM(daily_transaction_volume) FROM (SELECT daily_transaction_volume FROM developed_markets.digital_assets ORDER BY market_cap DESC FETCH NEXT 3 ROWS ONLY) t;", "generated_sql": "SELECT SUM(daily_transaction_volume) AS total_transaction_volume\nFROM (\n    SELECT daily_transaction_volume\n    FROM developed_markets.digital_assets\n    ORDER BY market_cap DESC\n    FETCH FIRST 3 ROWS ONLY\n) AS top3;", "raw_model_output": "```sql\nSELECT SUM(daily_transaction_volume) AS total_transaction_volume\nFROM (\n    SELECT daily_transaction_volume\n    FROM developed_markets.digital_assets\n    ORDER BY market_cap DESC\n    FETCH FIRST 3 ROWS ONLY\n) AS top3;\n```", "latency_sec": 2.9565770626068115, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 213, "prompt_eval_sec": null, "tokens_completion": 136, "completion_eval_sec": null, "tokens_total": 349, "tokens_per_sec": 118.04190880527463, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of daily_transaction_volume for the top 3 assets by market_cap. The difference between FETCH NEXT 3 ROWS ONLY and FETCH FIRST 3 ROWS ONLY is syntactic and equivalent in this context. Subquery aliases ('t' vs 'top3') do not affect the result. The ordering and aggregation logic are identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the total transaction volume for the top 3 digital assets by market capitalization. They use identical logic: ordering by market_cap DESC, limiting to 3 rows, and summing daily_transaction_volume. The difference lies in syntax: 'FETCH NEXT 3 ROWS ONLY' (reference) vs 'FETCH FIRST 3 ROWS ONLY' (generated). These are functionally equivalent in most SQL dialects (e.g., PostgreSQL) for this use case. Both properly reference the 'developed_markets' schema and handle the dataset correctly. The generated query adds an explicit alias ('top3') which improves readability but doesn't affect functionality. Neither query has performance issues given the small dataset.", "overall_assessment": "correct"}}
{"example_id": 1626, "sql_complexity": "aggregation", "prompt": "Find the total value of social impact bonds issued by each organization.", "context": "CREATE TABLE social_impact_bonds (id INT, organization_name VARCHAR(255), issue_year INT, value FLOAT); INSERT INTO social_impact_bonds (id, organization_name, issue_year, value) VALUES (1, 'Acme Corp', 2018, 2000000), (2, 'XYZ Foundation', 2019, 3000000), (3, 'Global Giving', 2018, 1500000), (4, 'Acme Corp', 2019, 2500000), (5, 'XYZ Foundation', 2018, 1000000);", "reference_sql": "SELECT organization_name, SUM(value) as total_value FROM social_impact_bonds GROUP BY organization_name;", "generated_sql": "SELECT\n    organization_name,\n    SUM(value) AS total_value\nFROM\n    social_impact_bonds\nGROUP BY\n    organization_name;", "raw_model_output": "SELECT\n    organization_name,\n    SUM(value) AS total_value\nFROM\n    social_impact_bonds\nGROUP BY\n    organization_name;", "latency_sec": 1.9047091007232666, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 204, "prompt_eval_sec": null, "tokens_completion": 113, "completion_eval_sec": null, "tokens_total": 317, "tokens_per_sec": 166.42961378177225, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select organization_name and sum the value column, grouping by organization_name. The Generated SQL is merely formatted with line breaks and capitalization differences, but contains no semantic changes.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are identical in structure, syntax, and logic. They both select organization_name, calculate the sum of values, and group by organization_name. The reference and generated queries produce the same results, fulfill the business requirement of aggregating bond values per organization, and are equally efficient. The formatting differences (e.g., line breaks) do not affect functionality.", "overall_assessment": "correct"}}
{"example_id": 1315, "sql_complexity": "single join", "prompt": "List all the transactions made by clients living in New York with a transaction amount greater than $1000.", "context": "CREATE TABLE transactions (id INT, client_id INT, transaction_amount DECIMAL(10,2), transaction_date DATE); INSERT INTO transactions (id, client_id, transaction_amount, transaction_date) VALUES (1, 3, 1500.00, '2022-01-01'), (2, 4, 800.00, '2022-01-02'), (3, 3, 1200.00, '2022-01-03'); CREATE TABLE clients (id INT, name VARCHAR(255), state VARCHAR(255)); INSERT INTO clients (id, name, state) VALUES (3, 'Mike Johnson', 'New York'), (4, 'Sara Lee', 'California');", "reference_sql": "SELECT transactions.id, transactions.client_id, transactions.transaction_amount, transactions.transaction_date FROM transactions INNER JOIN clients ON transactions.client_id = clients.id WHERE clients.state = 'New York' AND transactions.transaction_amount > 1000.00;", "generated_sql": "SELECT\n    t.*\nFROM\n    transactions AS t\nJOIN\n    clients AS c\n        ON t.client_id = c.id\nWHERE\n    c.state = 'New York'\n    AND t.transaction_amount > 1000;", "raw_model_output": "SELECT\n    t.*\nFROM\n    transactions AS t\nJOIN\n    clients AS c\n        ON t.client_id = c.id\nWHERE\n    c.state = 'New York'\n    AND t.transaction_amount > 1000;", "latency_sec": 2.611009120941162, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 235, "prompt_eval_sec": null, "tokens_completion": 131, "completion_eval_sec": null, "tokens_total": 366, "tokens_per_sec": 140.17568803745579, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an INNER JOIN between transactions and clients on client_id, filter for clients in 'New York' and transactions over 1000. The Reference SQL explicitly lists columns while the Generated SQL uses t.*, but since the transactions table has exactly those four columns, the result sets are identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent as they produce identical results by joining the same tables on client_id, filtering for New York clients and transactions over $1000. The reference query explicitly lists columns while the generated query uses t.*, but both satisfy the 'list all transactions' requirement. The generated query uses aliases which improve readability without affecting functionality. Neither query has performance advantages over the other, as they share the same logical structure and execution plan.", "overall_assessment": "correct"}}
{"example_id": 520, "sql_complexity": "multiple_joins", "prompt": "What is the total number of electric vehicles sold in 'California' in the 'sales' schema?", "context": "CREATE TABLE sales_regions (id INT, name VARCHAR(50));   CREATE TABLE sales (id INT, region_id INT, vehicle_count INT);   CREATE TABLE vehicles (id INT, type VARCHAR(50));   INSERT INTO sales_regions VALUES (1, 'California');   INSERT INTO sales VALUES (1, 1, 5000);   INSERT INTO vehicles VALUES (1, 'electric');", "reference_sql": "SELECT SUM(sales.vehicle_count) FROM sales INNER JOIN sales_regions ON sales.region_id = sales_regions.id INNER JOIN vehicles ON sales.id = vehicles.id WHERE vehicles.type = 'electric' AND sales_regions.name = 'California';", "generated_sql": "SELECT\n    SUM(s.vehicle_count) AS total_electric_vehicles_sold_in_california\nFROM\n    sales          AS s\n    JOIN sales_regions AS r ON r.id = s.region_id\n    JOIN vehicles       AS v ON v.id = s.id      -- matching sales record to its vehicle\nWHERE\n      r.name = 'California'\n  AND v.type = 'electric';", "raw_model_output": "SELECT\n    SUM(s.vehicle_count) AS total_electric_vehicles_sold_in_california\nFROM\n    sales          AS s\n    JOIN sales_regions AS r ON r.id = s.region_id\n    JOIN vehicles       AS v ON v.id = s.id      -- matching sales record to its vehicle\nWHERE\n      r.name = 'California'\n  AND v.type = 'electric';", "latency_sec": 6.218249082565308, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 166, "prompt_eval_sec": null, "tokens_completion": 419, "completion_eval_sec": null, "tokens_total": 585, "tokens_per_sec": 94.0779296924949, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of vehicle_count from the sales table joined with sales_regions and vehicles. They use equivalent JOIN conditions (sales.region_id = sales_regions.id and sales.id = vehicles.id), same WHERE filters (vehicles.type = 'electric' and sales_regions.name = 'California'), and sum the same column (vehicle_count). The differences are only in table aliases (sales vs s, sales_regions vs r, vehicles vs v) and a column alias in the generated query, which do not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically equivalent as they perform identical joins (sales_regions.id = sales.region_id, sales.id = vehicles.id), apply the same filters (region name = 'California', vehicle type = 'electric'), and aggregate the same column (sales.vehicle_count). The generated query improves readability through consistent aliasing (s/r/v) and explicit comment explaining the sales-vehicle relationship. The reference query is functionally identical but uses more verbose syntax. Both correctly address the business intent of counting electric vehicles sold in California.", "overall_assessment": "correct"}}
{"example_id": 3999, "sql_complexity": "single join", "prompt": "What is the total number of tickets sold for performances with a rating of 5?", "context": "CREATE TABLE performance (id INT PRIMARY KEY, name VARCHAR(255), date DATE, artist_id INT, rating INT); INSERT INTO performance (id, name, date, artist_id, rating) VALUES (1, 'Dance Recital', '2022-03-01', 1, 5);", "reference_sql": "SELECT SUM(t.quantity) as total_tickets_sold FROM performance p INNER JOIN ticket t ON p.id = t.performance_id WHERE p.rating = 5;", "generated_sql": "SELECT COUNT(*) AS total_tickets_sold\nFROM performance\nWHERE rating = 5;", "raw_model_output": "```sql\nSELECT COUNT(*) AS total_tickets_sold\nFROM performance\nWHERE rating = 5;\n```", "latency_sec": 3.955589771270752, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 145, "prompt_eval_sec": null, "tokens_completion": 298, "completion_eval_sec": null, "tokens_total": 443, "tokens_per_sec": 111.99341327492718, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the total tickets sold (sum of quantity) for performances with a rating of 5 by joining with the ticket table. The Generated SQL counts the number of performances with a rating of 5 without considering ticket data. They differ in both the aggregation function (SUM vs COUNT) and table usage (includes ticket table vs excludes it).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly joins the performance and ticket tables to sum ticket quantities for 5-star performances, while the generated query only counts the number of 5-star performances without considering ticket sales. The original question requires aggregating ticket data (SUM(t.quantity)), but the generated query uses COUNT(*) which measures rows in the performance table. This results in fundamentally different business insights: the reference addresses 'tickets sold' while the generated query measures 'number of performances'. The reference is technically correct and aligns with the business intent, whereas the generated query fails to retrieve ticket data entirely.", "overall_assessment": "incorrect"}}
{"example_id": 2261, "sql_complexity": "multiple_joins", "prompt": "What is the total number of animals that have been released into 'protected' habitats, and the average weight of those animals?", "context": "CREATE TABLE habitats (habitat_id INT, habitat_name VARCHAR(50), habitat_status VARCHAR(50)); INSERT INTO habitats (habitat_id, habitat_name, habitat_status) VALUES (1, 'Habitat A', 'protected'), (2, 'Habitat B', 'unprotected'); CREATE TABLE animal_habitats (animal_id INT, habitat_id INT, animal_weight FLOAT); INSERT INTO animal_habitats (animal_id, habitat_id, animal_weight) VALUES (101, 1, 25.5), (102, 2, 15.2); CREATE TABLE animals (animal_id INT, animal_name VARCHAR(50)); INSERT INTO animals (animal_id, animal_name) VALUES (101, 'Dog'), (102, 'Cat');", "reference_sql": "SELECT COUNT(*), AVG(animal_habitats.animal_weight) FROM animal_habitats INNER JOIN animals ON animal_habitats.animal_id = animals.animal_id INNER JOIN habitats ON animal_habitats.habitat_id = habitats.habitat_id WHERE habitats.habitat_status = 'protected';", "generated_sql": "SELECT\n    COUNT(DISTINCT ah.animal_id) AS total_animals,\n    AVG(ah.animal_weight)       AS avg_weight\nFROM animal_habitats AS ah\nJOIN habitats AS h\n  ON h.habitat_id = ah.habitat_id\nWHERE h.habitat_status = 'protected';", "raw_model_output": "```sql\nSELECT\n    COUNT(DISTINCT ah.animal_id) AS total_animals,\n    AVG(ah.animal_weight)       AS avg_weight\nFROM animal_habitats AS ah\nJOIN habitats AS h\n  ON h.habitat_id = ah.habitat_id\nWHERE h.habitat_status = 'protected';\n```", "latency_sec": 4.042162895202637, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 245, "prompt_eval_sec": null, "tokens_completion": 282, "completion_eval_sec": null, "tokens_total": 527, "tokens_per_sec": 130.375745278712, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses COUNT(*) which counts all rows in the joined result, while the Generated SQL uses COUNT(DISTINCT ah.animal_id) which counts unique animal IDs. If an animal appears multiple times in the animal_habitats table for protected habitats, the COUNT(*) would overcount while COUNT(DISTINCT) would correctly count unique animals. Additionally, the Reference SQL joins with the animals table unnecessarily, but this doesn't affect the count in the given sample data. The fundamental difference in aggregation logic makes them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in their counting logic. The reference query uses COUNT(*), which counts all rows in the joined result set, potentially overcounting animals if an animal appears multiple times in the animal_habitats table. The generated query uses COUNT(DISTINCT ah.animal_id), which ensures each animal is counted only once, aligning better with the business intent of counting unique animals. Both calculate the same average weight, but the generated query's approach is more accurate for the 'total number of animals' metric. The reference query also includes an unnecessary join to the animals table, which doesn't affect the result but reduces efficiency.", "overall_assessment": "differently_correct"}}
{"example_id": 3439, "sql_complexity": "multiple_joins", "prompt": "How many menu items contain ingredients sourced from local suppliers for each restaurant?", "context": "CREATE TABLE restaurants (id INT, name VARCHAR(50), location VARCHAR(50)); INSERT INTO restaurants VALUES (1, 'Restaurant A', 'City A'); INSERT INTO restaurants VALUES (2, 'Restaurant B', 'City B'); CREATE TABLE menu_items (id INT, name VARCHAR(50), restaurant_id INT, price DECIMAL(5,2)); INSERT INTO menu_items VALUES (1, 'Item A', 1, 10.99); INSERT INTO menu_items VALUES (2, 'Item B', 1, 12.99); INSERT INTO menu_items VALUES (3, 'Item C', 2, 11.99); CREATE TABLE ingredients (id INT, name VARCHAR(50), local_source BOOLEAN, menu_item_id INT); INSERT INTO ingredients VALUES (1, 'Ingredient A', TRUE, 1); INSERT INTO ingredients VALUES (2, 'Ingredient B', FALSE, 1); INSERT INTO ingredients VALUES (3, 'Ingredient C', TRUE, 2); INSERT INTO ingredients VALUES (4, 'Ingredient D', FALSE, 2); INSERT INTO ingredients VALUES (5, 'Ingredient E', TRUE, 3);", "reference_sql": "SELECT r.name, COUNT(DISTINCT mi.id) as num_local_items FROM restaurants r JOIN menu_items mi ON r.id = mi.restaurant_id JOIN ingredients i ON mi.id = i.menu_item_id WHERE i.local_source = TRUE GROUP BY r.name;", "generated_sql": "SELECT\n    r.id,\n    r.name,\n    COUNT(DISTINCT mi.id) AS local_source_menu_item_count\nFROM restaurants   AS r\nJOIN menu_items    AS mi ON mi.restaurant_id = r.id\nJOIN ingredients   AS ig ON ig.menu_item_id   = mi.id\nWHERE ig.local_source = TRUE\nGROUP BY r.id, r.name;", "raw_model_output": "SELECT\n    r.id,\n    r.name,\n    COUNT(DISTINCT mi.id) AS local_source_menu_item_count\nFROM restaurants   AS r\nJOIN menu_items    AS mi ON mi.restaurant_id = r.id\nJOIN ingredients   AS ig ON ig.menu_item_id   = mi.id\nWHERE ig.local_source = TRUE\nGROUP BY r.id, r.name;", "latency_sec": 4.829387187957764, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 313, "prompt_eval_sec": null, "tokens_completion": 286, "completion_eval_sec": null, "tokens_total": 599, "tokens_per_sec": 124.03229989378906, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects only 'r.name' and the count, while the Generated SQL includes 'r.id', 'r.name', and the count. Additionally, the Generated SQL groups by both 'r.id' and 'r.name', whereas the Reference SQL groups by 'r.name' alone. Although the core logic of joining tables and filtering by local_source is similar, the output columns and grouping strategy differ, leading to different result sets.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries correctly count menu items with local ingredients per restaurant. The reference query uses GROUP BY r.name which is sufficient since restaurant names are unique in the sample data. The generated query includes r.id in GROUP BY which is redundant but not incorrect. Both produce same results, but reference is more concise and directly aligns with the business question's requirement to report by restaurant name. The generated query's extra column (id) doesn't add value for this specific question.", "overall_assessment": "correct"}}
{"example_id": 2265, "sql_complexity": "aggregation", "prompt": "Hourly revenue for a specific movie?", "context": "CREATE TABLE Movie_Revenue (id INT, movie_title VARCHAR(100), revenue_time TIME, revenue DECIMAL(10,2));", "reference_sql": "SELECT revenue_time, SUM(revenue) FROM Movie_Revenue WHERE movie_title = 'Spider-Man: No Way Home' GROUP BY revenue_time;", "generated_sql": "SELECT\n    EXTRACT(HOUR FROM revenue_time) AS revenue_hour,\n    SUM(revenue)                           AS total_revenue\nFROM\n    Movie_Revenue\nWHERE\n    movie_title = :movie_title          -- replace with the desired title\nGROUP BY\n    EXTRACT(HOUR FROM revenue_time)\nORDER BY\n    revenue_hour;", "raw_model_output": "```sql\nSELECT\n    EXTRACT(HOUR FROM revenue_time) AS revenue_hour,\n    SUM(revenue)                           AS total_revenue\nFROM\n    Movie_Revenue\nWHERE\n    movie_title = :movie_title          -- replace with the desired title\nGROUP BY\n    EXTRACT(HOUR FROM revenue_time)\nORDER BY\n    revenue_hour;\n```", "latency_sec": 9.797791004180908, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 100, "prompt_eval_sec": null, "tokens_completion": 284, "completion_eval_sec": null, "tokens_total": 384, "tokens_per_sec": 39.19250776385613, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL groups by the exact 'revenue_time' (TIME type), while the Generated SQL groups by the extracted 'hour' from 'revenue_time' (INT). This changes the aggregation granularity: the first groups by specific time values, the second by hour components. Additionally, the Generated SQL includes an 'ORDER BY' clause not present in the Reference SQL.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query groups by the full 'revenue_time' (including minutes/seconds), which would create separate groups for each exact time entry rather than aggregating true hourly buckets. The generated query correctly extracts the hour portion of the time and groups by that, aligning with the 'hourly revenue' requirement. While both queries filter by movie title and sum revenue, only the generated query properly aggregates revenue at the hourly level. The reference query would return more granular time buckets than intended.", "overall_assessment": "differently_correct"}}
{"example_id": 1763, "sql_complexity": "multiple_joins", "prompt": "What is the total food and beverage revenue last month for hotels in 'Bangkok'?", "context": "CREATE TABLE revenue (hotel_id INT, revenue_source VARCHAR(50), revenue INT, revenue_date DATE); INSERT INTO revenue (hotel_id, revenue_source, revenue, revenue_date) VALUES (5, 'Room revenue', 12000, '2022-03-01'), (5, 'Food and beverage', 4000, '2022-03-02'), (5, 'Other revenue', 1000, '2022-03-03'); CREATE TABLE hotels (hotel_id INT, city VARCHAR(50)); INSERT INTO hotels (hotel_id, city) VALUES (5, 'Bangkok'); CREATE TABLE dates (date DATE); INSERT INTO dates (date) VALUES ('2022-03-01'), ('2022-03-02'), ('2022-03-03');", "reference_sql": "SELECT SUM(revenue) FROM revenue JOIN hotels ON revenue.hotel_id = hotels.hotel_id JOIN dates ON revenue.revenue_date = dates.date WHERE hotels.city = 'Bangkok' AND revenue_source = 'Food and beverage' AND dates.date >= DATEADD(month, -1, GETDATE());", "generated_sql": "SELECT\n    SUM(r.revenue) AS total_food_beverage_revenue_last_month\nFROM\n    revenue AS r\nJOIN\n    hotels  AS h ON r.hotel_id = h.hotel_id\nWHERE\n    h.city = 'Bangkok'\n    AND r.revenue_source = 'Food and beverage'\n    AND EXTRACT(YEAR  FROM r.revenue_date) = EXTRACT(YEAR  FROM CURRENT_DATE - INTERVAL '1' MONTH)\n    AND EXTRACT(MONTH FROM r.revenue_date) = EXTRACT(MONTH FROM CURRENT_DATE - INTERVAL '1' MONTH);", "raw_model_output": "SELECT\n    SUM(r.revenue) AS total_food_beverage_revenue_last_month\nFROM\n    revenue AS r\nJOIN\n    hotels  AS h ON r.hotel_id = h.hotel_id\nWHERE\n    h.city = 'Bangkok'\n    AND r.revenue_source = 'Food and beverage'\n    AND EXTRACT(YEAR  FROM r.revenue_date) = EXTRACT(YEAR  FROM CURRENT_DATE - INTERVAL '1' MONTH)\n    AND EXTRACT(MONTH FROM r.revenue_date) = EXTRACT(MONTH FROM CURRENT_DATE - INTERVAL '1' MONTH);", "latency_sec": 10.338939905166626, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 247, "prompt_eval_sec": null, "tokens_completion": 846, "completion_eval_sec": null, "tokens_total": 1093, "tokens_per_sec": 105.716834610268, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in date filtering logic. The Reference SQL uses `DATEADD(month, -1, GETDATE())` to filter dates within the last month (starting from the same day of the previous month), while the Generated SQL uses `EXTRACT` to match the entire previous month's year and month. Additionally, the Reference SQL joins with the `dates` table, which the Generated SQL omits. These differences in date range calculation and table usage make the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in date filtering logic. The Reference SQL uses DATEADD(month, -1, GETDATE()) which captures dates >= the same day of the previous month (e.g., March 5th if today is April 5th), potentially excluding full month data. The Generated SQL correctly matches the entire previous month by comparing year and month components of revenue_date with the previous month's year/month, ensuring all dates in the target month are included. The Generated SQL also avoids an unnecessary JOIN with the dates table, improving efficiency. Both queries correctly filter for 'Bangkok' hotels and 'Food and beverage' revenue sources, but the Generated SQL's date logic better fulfills the business intent of capturing the full previous month's revenue.", "overall_assessment": "differently_correct"}}
{"example_id": 5499, "sql_complexity": "set operations", "prompt": "How many legal aid clinics and community mediation centers are there in total, and what is the sum of cases handled by each type of center, for centers located in the state of California?", "context": "CREATE TABLE LegalAidClinics (ClinicName text, State text, NumCases int); INSERT INTO LegalAidClinics VALUES ('Clinic1', 'CA', 30, '2022-01-01'), ('Clinic2', 'CA', 25, '2022-01-01'); CREATE TABLE CommunityMediationCenters (CenterName text, State text, NumCases int); INSERT INTO CommunityMediationCenters VALUES ('CM1', 'CA', 22, '2022-01-01'), ('CM2', 'CA', 28, '2022-01-01');", "reference_sql": "SELECT State, 'Legal Aid Clinics' AS CenterType, COUNT(*) AS NumCenters, SUM(NumCases) AS TotalCases FROM LegalAidClinics WHERE State = 'CA' UNION ALL SELECT State, 'Community Mediation Centers', COUNT(*), SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA';", "generated_sql": "-- Number of centers and total cases for each center type in California\nSELECT 'LegalAidClinic' AS CenterType,\n       COUNT(*)          AS NumCenters,\n       SUM(NumCases)     AS TotalCases\nFROM   LegalAidClinics\nWHERE  State = 'CA'\n\nUNION ALL\n\nSELECT 'CommunityMediationCenter' AS CenterType,\n       COUNT(*)                   AS NumCenters,\n       SUM(NumCases)              AS TotalCases\nFROM   CommunityMediationCenters\nWHERE  State = 'CA';", "raw_model_output": "```sql\n-- Number of centers and total cases for each center type in California\nSELECT 'LegalAidClinic' AS CenterType,\n       COUNT(*)          AS NumCenters,\n       SUM(NumCases)     AS TotalCases\nFROM   LegalAidClinics\nWHERE  State = 'CA'\n\nUNION ALL\n\nSELECT 'CommunityMediationCenter' AS CenterType,\n       COUNT(*)                   AS NumCenters,\n       SUM(NumCases)              AS TotalCases\nFROM   CommunityMediationCenters\nWHERE  State = 'CA';\n```", "latency_sec": 5.0499022006988525, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 225, "prompt_eval_sec": null, "tokens_completion": 384, "completion_eval_sec": null, "tokens_total": 609, "tokens_per_sec": 120.5963948996321, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL includes the 'State' column in its output, while the Generated SQL omits it. Additionally, the CenterType values differ ('Legal Aid Clinics' vs. 'LegalAidClinic' and 'Community Mediation Centers' vs. 'CommunityMediationCenter'), leading to different result structures and values.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent due to differences in the CenterType labels ('Legal Aid Clinics' vs. 'LegalAidClinic') and table aliases. However, both correctly calculate counts and sums for California centers. The reference query better fulfills the business intent by using the exact terminology from the question ('Legal Aid Clinics' and 'Community Mediation Centers'), ensuring clarity for end-users. The generated query's labels are technically correct but less aligned with the original phrasing. Both queries are efficient, but the reference's explicit alignment with the question's wording makes it superior for business clarity.", "overall_assessment": "differently_correct"}}
{"example_id": 2408, "sql_complexity": "aggregation", "prompt": "What is the average number of victories for players from Japan and South Korea, partitioned by game mode?", "context": "CREATE TABLE PlayerVictories (PlayerID INT, GameMode VARCHAR(255), Victories INT, Country VARCHAR(255)); INSERT INTO PlayerVictories (PlayerID, GameMode, Victories, Country) VALUES (1, 'Battle Royale', 25, 'Japan'), (2, 'Team Deathmatch', 18, 'South Korea');", "reference_sql": "SELECT GameMode, AVG(Victories) as AvgVictories FROM PlayerVictories WHERE Country IN ('Japan', 'South Korea') GROUP BY GameMode, Country WITH ROLLUP;", "generated_sql": "SELECT\n    GameMode,\n    AVG(Victories) AS AvgVictories\nFROM\n    PlayerVictories\nWHERE\n    Country IN ('Japan', 'South Korea')\nGROUP BY\n    GameMode;", "raw_model_output": "```sql\nSELECT\n    GameMode,\n    AVG(Victories) AS AvgVictories\nFROM\n    PlayerVictories\nWHERE\n    Country IN ('Japan', 'South Korea')\nGROUP BY\n    GameMode;\n```", "latency_sec": 3.082707166671753, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 158, "prompt_eval_sec": null, "tokens_completion": 130, "completion_eval_sec": null, "tokens_total": 288, "tokens_per_sec": 93.42437812896105, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL groups by both GameMode and Country with ROLLUP, adding summary rows, while the Generated SQL only groups by GameMode. This results in different aggregation levels: the Reference calculates averages per GameMode/Country combination and includes rollup totals, whereas the Generated SQL averages victories across all countries for each GameMode without summary rows.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL groups by both GameMode and Country with ROLLUP, which introduces subtotals and a grand total not requested in the original question. This creates separate averages for Japan and South Korea within each game mode, whereas the original question seeks a single average per game mode across both countries. The Generated SQL correctly groups by GameMode only, aligning with the 'partitioned by game mode' requirement. While both queries filter for Japan and South Korea, the Reference SQL's additional grouping and ROLLUP make it less precise for the stated business intent. The Generated SQL is more efficient and directly addresses the question.", "overall_assessment": "differently_correct"}}
{"example_id": 2729, "sql_complexity": "subqueries", "prompt": "Find the total number of trips made by shared autonomous vehicles in Seattle", "context": "CREATE TABLE shared_vehicles (id INT, vehicle_type VARCHAR(20), is_autonomous BOOLEAN, trip_count INT); INSERT INTO shared_vehicles (id, vehicle_type, is_autonomous, trip_count) VALUES (1, 'ebike', false, 1200), (2, 'escooter', false, 800), (3, 'car', true, 1500); CREATE TABLE city_data (city VARCHAR(20), has_autonomous_vehicles BOOLEAN); INSERT INTO city_data (city, has_autonomous_vehicles) VALUES ('Seattle', true), ('Denver', false), ('Portland', true);", "reference_sql": "SELECT SUM(trip_count) FROM shared_vehicles WHERE is_autonomous = true AND vehicle_type != 'ebike' AND vehicle_type != 'escooter' AND city IN (SELECT city FROM city_data WHERE has_autonomous_vehicles = true AND city = 'Seattle');", "generated_sql": "SELECT SUM(sv.trip_count) AS total_trips\nFROM   city_data      cd\nJOIN   shared_vehicles sv\n       ON cd.has_autonomous_vehicles = TRUE\nWHERE  cd.city = 'Seattle'\n  AND  sv.is_autonomous = TRUE;", "raw_model_output": "SELECT SUM(sv.trip_count) AS total_trips\nFROM   city_data      cd\nJOIN   shared_vehicles sv\n       ON cd.has_autonomous_vehicles = TRUE\nWHERE  cd.city = 'Seattle'\n  AND  sv.is_autonomous = TRUE;", "latency_sec": 6.345778942108154, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 207, "prompt_eval_sec": null, "tokens_completion": 458, "completion_eval_sec": null, "tokens_total": 665, "tokens_per_sec": 104.79406958022366, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL references a 'city' column in shared_vehicles, which does not exist in the schema. The Generated SQL joins city_data and shared_vehicles but lacks the vehicle_type filters ('ebike' and 'escooter') present in the Reference SQL. Additionally, the Reference SQL's subquery logic is invalid due to the missing 'city' column in shared_vehicles.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL contains a critical technical error: it references a 'city' column in the shared_vehicles table, which does not exist in the schema. This makes the query invalid. The Generated SQL, while logically flawed, at least attempts to connect the city_data table to filter for Seattle. However, both queries fail to address the core issue: the shared_vehicles table lacks a city column to filter trips by location. The Generated SQL's join condition (cd.has_autonomous_vehicles = TRUE) is also incorrect, as it would return all shared_vehicles for every city with autonomous vehicles, not just Seattle. Despite these flaws, the Generated SQL better aligns with the business intent by explicitly filtering for Seattle in the WHERE clause, whereas the Reference SQL is fundamentally invalid.", "overall_assessment": "incorrect"}}
{"example_id": 2952, "sql_complexity": "aggregation", "prompt": "Show the total budget allocated for each program category in 2023.", "context": "CREATE TABLE Budget (id INT, category TEXT, year INT, allocated_amount INT); INSERT INTO Budget (id, category, year, allocated_amount) VALUES (1, 'Education', 2023, 30000); INSERT INTO Budget (id, category, year, allocated_amount) VALUES (2, 'Healthcare', 2023, 50000);", "reference_sql": "SELECT category, SUM(allocated_amount) FROM Budget WHERE year = 2023 GROUP BY category;", "generated_sql": "SELECT\n  category,\n  SUM(allocated_amount) AS total_allocated\nFROM Budget\nWHERE year = 2023\nGROUP BY category;", "raw_model_output": "SELECT\n  category,\n  SUM(allocated_amount) AS total_allocated\nFROM Budget\nWHERE year = 2023\nGROUP BY category;", "latency_sec": 4.7447450160980225, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 153, "prompt_eval_sec": null, "tokens_completion": 113, "completion_eval_sec": null, "tokens_total": 266, "tokens_per_sec": 56.06202211025299, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries group by 'category', filter for year 2023, and calculate the sum of 'allocated_amount'. The only difference is the column alias ('total_allocated' in Generated SQL) which doesn't affect the semantic result set content.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the total allocated budget per category for 2023 using SUM and GROUP BY. The reference query omits an explicit alias for the aggregated column, while the generated query uses 'total_allocated' which improves readability without altering functionality. The generated version is more elegant due to the alias, but both are technically correct and fulfill the business intent of showing total budgets per category.", "overall_assessment": "correct"}}
{"example_id": 4328, "sql_complexity": "aggregation", "prompt": "What is the average cargo handling time in hours for each port?", "context": "CREATE TABLE cargo_handling (id INT, port_id INT, time_in_hours DECIMAL(5,2)); INSERT INTO cargo_handling (id, port_id, time_in_hours) VALUES (1, 1, 20.5), (2, 1, 22.3), (3, 2, 18.7);", "reference_sql": "SELECT port_id, AVG(time_in_hours) FROM cargo_handling GROUP BY port_id;", "generated_sql": "SELECT\n    port_id,\n    AVG(time_in_hours) AS average_time_in_hours\nFROM\n    cargo_handling\nGROUP BY\n    port_id;", "raw_model_output": "SELECT\n    port_id,\n    AVG(time_in_hours) AS average_time_in_hours\nFROM\n    cargo_handling\nGROUP BY\n    port_id;", "latency_sec": 2.474574089050293, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 151, "prompt_eval_sec": null, "tokens_completion": 115, "completion_eval_sec": null, "tokens_total": 266, "tokens_per_sec": 107.49324547485547, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries group by port_id and calculate the average time_in_hours. The generated query adds an alias (average_time_in_hours) for the calculated column, but this does not affect the semantic result. The grouping and aggregation logic are identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the average cargo handling time per port using GROUP BY port_id. The reference query omits an alias for the aggregated column, while the generated query explicitly names it 'average_time_in_hours'. This difference in aliasing does not affect the technical correctness or semantic equivalence of the results. Both queries fulfill the business intent of determining average handling times per port. The generated query improves readability through explicit column naming, but neither query is technically superior in terms of logic, efficiency, or correctness.", "overall_assessment": "correct"}}
{"example_id": 4915, "sql_complexity": "window functions", "prompt": "Calculate the percentage of total Europium production for each country.", "context": "CREATE TABLE europium_production (country VARCHAR(50), quantity INT);", "reference_sql": "SELECT country, quantity * 100.0 / SUM(quantity) OVER (PARTITION BY NULL) AS percentage FROM europium_production;", "generated_sql": "SELECT\n    country,\n    quantity * 100.0 / SUM(quantity) OVER () AS production_percentage\nFROM\n    europium_production;", "raw_model_output": "SELECT\n    country,\n    quantity * 100.0 / SUM(quantity) OVER () AS production_percentage\nFROM\n    europium_production;", "latency_sec": 1.8199360370635986, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 93, "prompt_eval_sec": null, "tokens_completion": 113, "completion_eval_sec": null, "tokens_total": 206, "tokens_per_sec": 113.19079121724168, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the percentage of each country's production relative to the total production. The window function SUM(quantity) OVER (PARTITION BY NULL) in the reference query is equivalent to SUM(quantity) OVER () in the generated query, as PARTITION BY NULL defines a single partition covering all rows. The column alias difference ('percentage' vs 'production_percentage') does not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the percentage of total Europium production per country using window functions. The reference query uses `SUM(quantity) OVER (PARTITION BY NULL)` which is functionally equivalent to `SUM(quantity) OVER ()` in the generated query. The key difference is semantic: the generated query uses a more descriptive column alias (`production_percentage`) compared to the reference's generic `percentage`. While both technically fulfill the business intent, the generated query's clarity in column naming makes it slightly more elegant and user-friendly without affecting correctness.", "overall_assessment": "correct"}}
{"example_id": 5030, "sql_complexity": "subqueries", "prompt": "What is the success rate of diverse-led startups (at least 1 female or underrepresented racial or ethnic group executive) in the past 3 years?", "context": "CREATE TABLE DiverseStartups(id INT, name TEXT, country TEXT, year INT, success BOOLEAN);   INSERT INTO DiverseStartups VALUES (1, 'FemTech', 'USA', 2020, true), (2, 'GreenCity', 'Canada', 2019, false), (3, 'AI-Health', 'UK', 2021, true), (4, 'SolarEnergy', 'USA', 2020, false), (5, 'DataAnalytics', 'Germany', 2019, true), (6, 'SmartGrid', 'USA', 2021, true), (7, 'CloudServices', 'India', 2020, false), (8, 'RenewableEnergy', 'USA', 2019, true);", "reference_sql": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3) AS success_rate FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3 AND success = true;", "generated_sql": "SELECT\n    (SUM(CASE WHEN success THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS success_rate_percentage\nFROM DiverseStartups\nWHERE year >= EXTRACT(YEAR FROM CURRENT_DATE) - 2;  -- past 3 calendar years (current year, current-1, current-2)", "raw_model_output": "```sql\nSELECT\n    (SUM(CASE WHEN success THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS success_rate_percentage\nFROM DiverseStartups\nWHERE year >= EXTRACT(YEAR FROM CURRENT_DATE) - 2;  -- past 3 calendar years (current year, current-1, current-2)\n```", "latency_sec": 6.771436929702759, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 254, "prompt_eval_sec": null, "tokens_completion": 605, "completion_eval_sec": null, "tokens_total": 859, "tokens_per_sec": 126.85638349993566, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their time range filters. The Reference SQL uses `YEAR(CURRENT_DATE) - 3` (including 4 years: current year - 3, -2, -1, and current), while the Generated SQL uses `EXTRACT(YEAR FROM CURRENT_DATE) - 2` (including 3 years: current year - 2, -1, and current). This discrepancy in the time window leads to different datasets being analyzed, making the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in their handling of the 'past 3 years' condition. The reference SQL uses `YEAR(CURRENT_DATE) - 3`, which would include 4 years (e.g., 2020-2023 if current year is 2023) instead of 3. The generated SQL correctly uses `EXTRACT(YEAR FROM CURRENT_DATE) - 2` to capture exactly 3 calendar years (current year, current-1, current-2). Both calculate success rate as (successful / total) * 100, but the generated query is more precise in time filtering and uses explicit aggregation for clarity. The generated query better fulfills the business intent of measuring the success rate over exactly 3 years.", "overall_assessment": "differently_correct"}}
{"example_id": 4626, "sql_complexity": "aggregation", "prompt": "What was the maximum number of training hours for farmers in each country in 2020?", "context": "CREATE TABLE training (id INT, country_id INT, farmer_id INT, hours INT, date DATE);", "reference_sql": "SELECT country_id, MAX(hours) FROM training WHERE YEAR(date) = 2020 GROUP BY country_id;", "generated_sql": "SELECT\n    country_id,\n    MAX(hours) AS max_hours\nFROM\n    training\nWHERE\n    date >= DATE '2020-01-01'\n    AND date <  DATE '2021-01-01'   -- restrict to the year 2020\nGROUP BY\n    country_id;", "raw_model_output": "```sql\nSELECT\n    country_id,\n    MAX(hours) AS max_hours\nFROM\n    training\nWHERE\n    date >= DATE '2020-01-01'\n    AND date <  DATE '2021-01-01'   -- restrict to the year 2020\nGROUP BY\n    country_id;\n```", "latency_sec": 3.5770649909973145, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 105, "prompt_eval_sec": null, "tokens_completion": 215, "completion_eval_sec": null, "tokens_total": 320, "tokens_per_sec": 89.45881632158476, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select the maximum 'hours' per 'country_id' for records in 2020. The reference uses YEAR(date) = 2020, while the generated query uses a date range (2020-01-01 to 2021-01-01). These conditions are equivalent for DATE-typed columns, as they both capture all dates in 2020. The GROUP BY and aggregation logic are identical, and the alias change (max_hours) does not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the maximum training hours per country for 2020. The Reference SQL uses YEAR(date) = 2020 while the Generated SQL uses an explicit date range (2020-01-01 to 2021-01-01). Both approaches are logically equivalent for this purpose. However, the Generated SQL is more efficient as it avoids applying a function to the date column (which could prevent index usage) and explicitly defines the year boundary. The Generated SQL also includes an alias (max_hours) which improves readability without affecting functionality. Both fulfill the business intent of identifying maximum training hours per country in 2020.", "overall_assessment": "correct"}}
{"example_id": 2703, "sql_complexity": "set operations", "prompt": "Identify the species unique to 'MarineResearchAreaA' and 'MarineResearchAreaB'", "context": "CREATE TABLE ResearchAreaSpecies (area VARCHAR(255), species VARCHAR(255)); INSERT INTO ResearchAreaSpecies (area, species) VALUES ('MarineResearchAreaA', 'Coral'), ('MarineResearchAreaA', 'Starfish'), ('MarineResearchAreaB', 'Jellyfish');", "reference_sql": "(SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB') UNION (SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA');", "generated_sql": "SELECT area,\n       species\nFROM   ResearchAreaSpecies AS ras\nWHERE  area IN ('MarineResearchAreaA', 'MarineResearchAreaB')\n  AND NOT EXISTS ( SELECT 1\n                   FROM   ResearchAreaSpecies AS other\n                   WHERE  other.species = ras.species\n                     AND  other.area   <> ras.area );", "raw_model_output": "SELECT area,\n       species\nFROM   ResearchAreaSpecies AS ras\nWHERE  area IN ('MarineResearchAreaA', 'MarineResearchAreaB')\n  AND NOT EXISTS ( SELECT 1\n                   FROM   ResearchAreaSpecies AS other\n                   WHERE  other.species = ras.species\n                     AND  other.area   <> ras.area );", "latency_sec": 28.68014907836914, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 142, "prompt_eval_sec": null, "tokens_completion": 472, "completion_eval_sec": null, "tokens_total": 614, "tokens_per_sec": 21.4085358594975, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in output structure. The reference query returns only 'species' values, while the generated query returns both 'area' and 'species'. Additionally, the generated query includes all entries from 'MarineResearchAreaA' and 'MarineResearchAreaB' where a species isn't present in the other area, but retains the 'area' column, which the reference query explicitly omits. This structural difference in result sets makes them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query correctly returns only species names (no area column) using EXCEPT/UNION to find asymmetric differences between the two areas. The generated query includes an unnecessary 'area' column in its output, which doesn't align with the original question's requirement to 'identify the species'. While both queries logically identify unique species, the reference's output structure is more precise. The generated query's NOT EXISTS approach is technically valid but produces different column metadata. Both fulfill the business intent of finding unique species, but the reference is more elegant and structurally accurate.", "overall_assessment": "differently_correct"}}
{"example_id": 200, "sql_complexity": "window functions", "prompt": "List the top three categories of workforce development programs with the highest budget increases.", "context": "CREATE TABLE programs (program_id INT, program_name VARCHAR(50), budget DECIMAL(10, 2), category VARCHAR(50), budget_date DATE);", "reference_sql": "SELECT category, SUM(budget - LAG(budget) OVER (PARTITION BY category ORDER BY budget_date)) as total_budget_increase FROM programs GROUP BY category ORDER BY total_budget_increase DESC LIMIT 3;", "generated_sql": "-- Top three categories with the greatest budget growth\nWITH category_dates AS (\n    /* Earliest and latest budget dates for every category */\n    SELECT\n        category,\n        MIN(budget_date) AS first_date,\n        MAX(budget_date) AS last_date\n    FROM programs\n    GROUP BY category\n),\nfirst_totals AS (\n    /* Total budget on the first recorded date per category */\n    SELECT\n        p.category,\n        SUM(p.budget) AS first_budget\n    FROM programs p\n    JOIN category_dates cd\n      ON cd.category = p.category\n     AND cd.first_date = p.budget_date\n    GROUP BY p.category\n),\nlast_totals AS (\n    /* Total budget on the most recent date per category */\n    SELECT\n        p.category,\n        SUM(p.budget) AS last_budget\n    FROM programs p\n    JOIN category_dates cd\n      ON cd.category = p.category\n     AND cd.last_date = p.budget_date\n    GROUP BY p.category\n),\nchanges AS (\n    /* Calculate budget increase for each category */\n    SELECT\n        l.category,\n        l.last_budget - f.first_budget AS budget_increase\n    FROM last_totals l\n    JOIN first_totals f\n      ON f.category = l.category\n)\nSELECT\n    category,\n    budget_increase\nFROM changes\nORDER BY budget_increase DESC\nFETCH FIRST 3 ROWS ONLY;", "raw_model_output": "```sql\n-- Top three categories with the greatest budget growth\nWITH category_dates AS (\n    /* Earliest and latest budget dates for every category */\n    SELECT\n        category,\n        MIN(budget_date) AS first_date,\n        MAX(budget_date) AS last_date\n    FROM programs\n    GROUP BY category\n),\nfirst_totals AS (\n    /* Total budget on the first recorded date per category */\n    SELECT\n        p.category,\n        SUM(p.budget) AS first_budget\n    FROM programs p\n    JOIN category_dates cd\n      ON cd.category = p.category\n     AND cd.first_date = p.budget_date\n    GROUP BY p.category\n),\nlast_totals AS (\n    /* Total budget on the most recent date per category */\n    SELECT\n        p.category,\n        SUM(p.budget) AS last_budget\n    FROM programs p\n    JOIN category_dates cd\n      ON cd.category = p.category\n     AND cd.last_date = p.budget_date\n    GROUP BY p.category\n),\nchanges AS (\n    /* Calculate budget increase for each category */\n    SELECT\n        l.category,\n        l.last_budget - f.first_budget AS budget_increase\n    FROM last_totals l\n    JOIN first_totals f\n      ON f.category = l.category\n)\nSELECT\n    category,\n    budget_increase\nFROM changes\nORDER BY budget_increase DESC\nFETCH FIRST 3 ROWS ONLY;\n```", "latency_sec": 24.38677477836609, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 113, "prompt_eval_sec": null, "tokens_completion": 1463, "completion_eval_sec": null, "tokens_total": 1576, "tokens_per_sec": 64.62519190516721, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in how they calculate budget growth. The reference query sums consecutive budget differences (last_budget - first_budget) across all dates, while the generated query calculates the difference between total budgets on the first and last dates. If there are multiple entries on the same date or non-consecutive dates, the two approaches may yield different results. For example, multiple entries on the same date would affect the generated query's sum but not the reference query's cumulative differences.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the total budget increase per category and return the top 3. The reference query uses a window function to sum consecutive budget differences (equivalent to last - first budget), while the generated query explicitly calculates first/last budgets and subtracts them. Mathematically, both approaches yield identical results. The reference query is more concise but less explicit, while the generated query is more verbose but clearer in its logic. Neither has a technical advantage over the other.", "overall_assessment": "correct"}}
{"example_id": 5131, "sql_complexity": "basic SQL", "prompt": "How many wells were drilled in the Eagle Ford Shale and Bakken Formation?", "context": "CREATE TABLE wells (id INT, region VARCHAR(255), well_type VARCHAR(255), num_drilled INT); INSERT INTO wells (id, region, well_type, num_drilled) VALUES (1, 'Eagle Ford Shale', 'Oil', 2000), (2, 'Eagle Ford Shale', 'Gas', 1500), (3, 'Bakken Formation', 'Oil', 1000), (4, 'Bakken Formation', 'Gas', 1200);", "reference_sql": "SELECT SUM(num_drilled) as total_wells FROM wells WHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "generated_sql": "SELECT SUM(num_drilled) AS total_wells_drilled\nFROM wells\nWHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "raw_model_output": "SELECT SUM(num_drilled) AS total_wells_drilled\nFROM wells\nWHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "latency_sec": 6.406636714935303, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 185, "prompt_eval_sec": null, "tokens_completion": 114, "completion_eval_sec": null, "tokens_total": 299, "tokens_per_sec": 46.67035346377049, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of num_drilled for wells in the specified regions. The only difference is the column alias name (total_wells vs. total_wells_drilled), which doesn't affect the semantic result. The WHERE clause and aggregation logic are identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically equivalent as they produce identical results by summing num_drilled for the specified regions. The reference query uses 'total_wells' while the generated query uses 'total_wells_drilled' - the latter provides clearer semantic meaning by explicitly indicating the metric being measured. Both correctly address the business intent of counting total wells drilled in the two formations. The generated query's more descriptive alias improves readability without affecting functionality.", "overall_assessment": "correct"}}
{"example_id": 1160, "sql_complexity": "subqueries", "prompt": "What is the total revenue generated from ads on Instagram in March 2021, for users in the 'brand' category who have posted more than 10 times?", "context": "CREATE TABLE ads (ad_id INT, user_id INT, platform VARCHAR(255), ad_revenue DECIMAL(10,2), post_count INT); INSERT INTO ads (ad_id, user_id, platform, ad_revenue, post_count) VALUES (1, 1, 'Instagram', 150.50, 12), (2, 2, 'Twitter', 80.00, 15), (3, 3, 'Instagram', 120.75, 8);", "reference_sql": "SELECT SUM(ad_revenue) FROM ads WHERE platform = 'Instagram' AND MONTH(ad_date) = 3 AND YEAR(ad_date) = 2021 AND user_id IN (SELECT user_id FROM users WHERE category = 'brand' AND post_count > 10);", "generated_sql": "SELECT \n    SUM(ad_revenue) AS total_revenue\nFROM \n    ads\nWHERE \n    platform = 'Instagram'\n    AND post_count > 10;", "raw_model_output": "```sql\nSELECT \n    SUM(ad_revenue) AS total_revenue\nFROM \n    ads\nWHERE \n    platform = 'Instagram'\n    AND post_count > 10;\n```", "latency_sec": 3.9056079387664795, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 201, "prompt_eval_sec": null, "tokens_completion": 249, "completion_eval_sec": null, "tokens_total": 450, "tokens_per_sec": 115.21893826908928, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL includes additional conditions: filtering by ad_date (MONTH and YEAR) and a subquery joining users table with category = 'brand' and post_count > 10. The Generated SQL omits these conditions and uses ads.post_count instead of users.post_count. These differences would produce different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL references a non-existent 'users' table, making it syntactically invalid. The Generated SQL is syntactically correct but omits critical filters: it lacks the date condition (March 2021) and the 'brand' category filter. While the Generated SQL correctly uses the 'post_count' from the ads table, it fails to address the full business requirements. The Reference SQL's structure aligns more with the intent but is invalidated by the missing table. The Generated SQL is technically superior in syntax but incomplete in logic.", "overall_assessment": "incorrect"}}
{"example_id": 4708, "sql_complexity": "subqueries", "prompt": "What is the maximum number of high-level threats reported by a single agency in a month?", "context": "CREATE TABLE Threat_Intelligence (Threat_ID INT, Threat_Type VARCHAR(50), Threat_Level VARCHAR(50), Reported_Date DATE, Reporting_Agency VARCHAR(50)); CREATE VIEW High_Level_Threats AS SELECT Threat_Type, Threat_Level, Reported_Date FROM Threat_Intelligence WHERE Threat_Level = 'High';", "reference_sql": "SELECT Reporting_Agency, MAX(Number_of_High_Level_Threats) as Max_High_Level_Threats_in_a_Month FROM (SELECT Reporting_Agency, TO_CHAR(Reported_Date, 'YYYY-MM') as Month, COUNT(*) as Number_of_High_Level_Threats FROM High_Level_Threats GROUP BY Reporting_Agency, Month) GROUP BY Reporting_Agency;", "generated_sql": "SELECT MAX(monthly_count) AS max_high_level_threats_in_a_month\nFROM (\n    SELECT\n        Reporting_Agency,\n        COUNT(*) AS monthly_count\n    FROM Threat_Intelligence\n    WHERE Threat_Level = 'High'\n    GROUP BY\n        Reporting_Agency,\n        EXTRACT(YEAR  FROM Reported_Date),\n        EXTRACT(MONTH FROM Reported_Date)\n) AS agency_monthly_totals;", "raw_model_output": "```sql\nSELECT MAX(monthly_count) AS max_high_level_threats_in_a_month\nFROM (\n    SELECT\n        Reporting_Agency,\n        COUNT(*) AS monthly_count\n    FROM Threat_Intelligence\n    WHERE Threat_Level = 'High'\n    GROUP BY\n        Reporting_Agency,\n        EXTRACT(YEAR  FROM Reported_Date),\n        EXTRACT(MONTH FROM Reported_Date)\n) AS agency_monthly_totals;\n```", "latency_sec": 4.755021810531616, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 147, "prompt_eval_sec": null, "tokens_completion": 366, "completion_eval_sec": null, "tokens_total": 513, "tokens_per_sec": 107.88594047324592, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL groups by Reporting_Agency and Month to calculate monthly counts, then finds the maximum per agency. The Generated SQL calculates monthly counts but lacks grouping by Reporting_Agency in the outer query, resulting in a single maximum value across all agencies instead of per-agency maxima. The output structures differ: the first returns per-agency maxima, while the second returns a global maximum.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is structurally incorrect for the question. It groups by Reporting_Agency in both subquery and outer query, which would return per-agency maxima rather than the global maximum across all agencies. The Generated SQL correctly calculates monthly counts per agency and then selects the absolute maximum value. The Reference SQL's use of a view and TO_CHAR() is unnecessary, while the Generated SQL directly filters high-level threats and uses EXTRACT() for date grouping. The Generated SQL better fulfills the business intent of finding the single highest monthly count across all agencies.", "overall_assessment": "differently_correct"}}
{"example_id": 5608, "sql_complexity": "set operations", "prompt": "List the suppliers that provide materials for both product A and product C.", "context": "CREATE TABLE products (product_id INT, product_name TEXT); CREATE TABLE materials (material_id INT, material_name TEXT, product_id INT, supplier_id INT); INSERT INTO products (product_id, product_name) VALUES (1, 'Product A'), (2, 'Product B'), (3, 'Product C'); INSERT INTO materials (material_id, material_name, product_id, supplier_id) VALUES (1, 'Material 1', 1, 101), (2, 'Material 2', 1, 102), (3, 'Material 3', 2, 103), (4, 'Material 4', 3, 101), (5, 'Material 5', 3, 102);", "reference_sql": "SELECT supplier_id FROM materials WHERE product_id = 1 INTERSECT SELECT supplier_id FROM materials WHERE product_id = 3;", "generated_sql": "SELECT supplier_id\nFROM materials\nWHERE product_id IN (\n    SELECT product_id\n    FROM products\n    WHERE product_name IN ('Product A', 'Product C')\n)\nGROUP BY supplier_id\nHAVING COUNT(DISTINCT product_id) = 2;", "raw_model_output": "SELECT supplier_id\nFROM materials\nWHERE product_id IN (\n    SELECT product_id\n    FROM products\n    WHERE product_name IN ('Product A', 'Product C')\n)\nGROUP BY supplier_id\nHAVING COUNT(DISTINCT product_id) = 2;", "latency_sec": 4.864019870758057, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 231, "prompt_eval_sec": null, "tokens_completion": 264, "completion_eval_sec": null, "tokens_total": 495, "tokens_per_sec": 101.76767635672803, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve supplier_ids that have materials for both product_id 1 (Product A) and product_id 3 (Product C). The Reference SQL uses INTERSECT to find common suppliers between the two product_id conditions, while the Generated SQL filters materials for products 1 and 3, groups by supplier_id, and ensures they have entries for both products via COUNT(DISTINCT product_id) = 2. Both approaches logically achieve the same result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly identify suppliers providing materials for both Product A (product_id=1) and Product C (product_id=3). The reference query uses INTERSECT to directly find common supplier_ids between the two product-specific subsets. The generated query uses a subquery to filter materials for Product A/C, then groups by supplier_id to ensure they have materials for both distinct product_ids. Both approaches are logically equivalent and produce the same results. The reference query is more concise, while the generated query is more explicit about the business logic. Neither is significantly more efficient in this context.", "overall_assessment": "correct"}}
{"example_id": 1506, "sql_complexity": "basic SQL", "prompt": "How many habitats are in the 'animal_habitats' table?", "context": "CREATE TABLE animal_habitats (id INT PRIMARY KEY, habitat_name VARCHAR, num_animals INT);", "reference_sql": "SELECT COUNT(*) FROM animal_habitats;", "generated_sql": "SELECT COUNT(*) AS habitat_count\nFROM animal_habitats;", "raw_model_output": "```sql\nSELECT COUNT(*) AS habitat_count\nFROM animal_habitats;\n```", "latency_sec": 1.5219626426696777, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 101, "prompt_eval_sec": null, "tokens_completion": 36, "completion_eval_sec": null, "tokens_total": 137, "tokens_per_sec": 90.0153500217903, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries return the same numerical count of rows from the animal_habitats table. The generated query adds an alias (habitat_count) to the COUNT(*) result, but this does not affect the actual value returned. The semantic meaning of counting all rows remains identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries correctly count the number of habitats in the table. The reference query is more concise, while the generated query adds a column alias ('habitat_count') which improves readability but isn't required for the question. Since the original question doesn't specify a need for column naming, the reference query is technically simpler and directly addresses the requirement without unnecessary elements. Both are semantically equivalent and fulfill the business intent of counting habitats.", "overall_assessment": "correct"}}
{"example_id": 3117, "sql_complexity": "aggregation", "prompt": "What is the percentage of the population that has access to clean water in each continent?", "context": "CREATE TABLE water_data (id INT, country VARCHAR(50), continent CHAR(2), access_to_clean_water BOOLEAN); INSERT INTO water_data VALUES (1, 'Canada', 'NA', true), (2, 'Mexico', 'NA', false), (3, 'Brazil', 'SA', true), (4, 'Russia', 'EU', true);", "reference_sql": "SELECT continent, COUNT(*) FILTER (WHERE access_to_clean_water) * 100.0 / COUNT(*) AS percentage FROM water_data GROUP BY continent;", "generated_sql": "SELECT\n    continent,\n    (CAST(SUM(CASE WHEN access_to_clean_water THEN 1 ELSE 0 END) AS DECIMAL(10,2)) * 100) \n        / COUNT(*) AS percentage_with_access\nFROM\n    water_data\nGROUP BY\n    continent;", "raw_model_output": "```sql\nSELECT\n    continent,\n    (CAST(SUM(CASE WHEN access_to_clean_water THEN 1 ELSE 0 END) AS DECIMAL(10,2)) * 100) \n        / COUNT(*) AS percentage_with_access\nFROM\n    water_data\nGROUP BY\n    continent;\n```", "latency_sec": 6.323811054229736, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 156, "prompt_eval_sec": null, "tokens_completion": 338, "completion_eval_sec": null, "tokens_total": 494, "tokens_per_sec": 78.11745097437466, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the percentage of countries with access to clean water per continent. The reference uses COUNT(*) FILTER (WHERE ...) which is equivalent to SUM(CASE WHEN ... THEN 1 ELSE 0 END) in the generated query. Both then multiply by 100 and divide by total count. The difference in casting (DECIMAL vs 100.0) doesn't affect the semantic result as both ensure floating-point division.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the percentage of the population with access to clean water per continent. The reference query uses PostgreSQL's COUNT(*) FILTER syntax, while the generated query uses a SUM(CASE...) approach. Both methods accurately count true values and compute the percentage via division. The reference is more concise, but the generated query uses standard SQL that might be more portable. The calculation logic (numerator/denominator * 100) is mathematically equivalent in both cases. The generated query explicitly casts to DECIMAL(10,2), which could affect rounding precision, but the question does not specify rounding requirements. Both queries fulfill the business intent of showing percentages per continent.", "overall_assessment": "correct"}}
{"example_id": 3542, "sql_complexity": "window functions", "prompt": "What is the average yield of crops for each country, ranked by average yield?", "context": "CREATE TABLE farming (id INT, name TEXT, country TEXT, crop TEXT, yield INT); INSERT INTO farming VALUES (1, 'Smith Farm', 'USA', 'Corn', 120), (2, 'Brown Farm', 'Canada', 'Soybeans', 45), (3, 'Jones Farm', 'Mexico', 'Wheat', 80);", "reference_sql": "SELECT country, AVG(yield) as avg_yield, ROW_NUMBER() OVER (ORDER BY AVG(yield) DESC) as rank FROM farming GROUP BY country;", "generated_sql": "SELECT\n    country,\n    AVG(yield) AS average_yield,\n    DENSE_RANK() OVER (ORDER BY AVG(yield) DESC) AS yield_rank\nFROM farming\nGROUP BY country\nORDER BY yield_rank;", "raw_model_output": "SELECT\n    country,\n    AVG(yield) AS average_yield,\n    DENSE_RANK() OVER (ORDER BY AVG(yield) DESC) AS yield_rank\nFROM farming\nGROUP BY country\nORDER BY yield_rank;", "latency_sec": 4.324183702468872, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 155, "prompt_eval_sec": null, "tokens_completion": 194, "completion_eval_sec": null, "tokens_total": 349, "tokens_per_sec": 80.70887455607867, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their ranking logic. The Reference SQL uses ROW_NUMBER() which assigns unique ranks, while the Generated SQL uses DENSE_RANK() which assigns same ranks to ties. Additionally, the Generated SQL includes an ORDER BY clause not present in the Reference SQL, affecting result ordering.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in two key aspects: 1) The reference query uses ROW_NUMBER() which assigns unique ranks, while the generated query uses DENSE_RANK() which handles ties by preserving sequential ranking. 2) The generated query includes an explicit ORDER BY yield_rank, ensuring the output is sorted, whereas the reference query's ordering is implicit through the window function but not guaranteed without an explicit ORDER BY. Both fulfill the business intent of ranking countries by average yield, but the generated query better handles potential ties and ensures ordered results. The reference query might produce the same results with the given sample data, but the generated query is more robust and precise.", "overall_assessment": "differently_correct"}}
{"example_id": 2274, "sql_complexity": "subqueries", "prompt": "Add a new crop 'amaranth' to farm 'Nourishing Harvest' with yield 50 in 2023", "context": "CREATE TABLE farms (id INT, name TEXT, location TEXT, size FLOAT); INSERT INTO farms (id, name, location, size) VALUES (1, 'Nourishing Harvest', 'Mexico', 120.0); CREATE TABLE crops (id INT, farm_id INT, crop TEXT, yield INT, year INT);", "reference_sql": "INSERT INTO crops (id, farm_id, crop, yield, year) VALUES (5, (SELECT id FROM farms WHERE name = 'Nourishing Harvest'), 'amaranth', 50, 2023);", "generated_sql": "INSERT INTO crops (id, farm_id, crop, yield, year)\nSELECT\n    (SELECT COALESCE(MAX(id), 0) + 1 FROM crops) AS id,\n    f.id,\n    'amaranth',\n    50,\n    2023\nFROM farms AS f\nWHERE f.name = 'Nourishing Harvest';", "raw_model_output": "INSERT INTO crops (id, farm_id, crop, yield, year)\nSELECT\n    (SELECT COALESCE(MAX(id), 0) + 1 FROM crops) AS id,\n    f.id,\n    'amaranth',\n    50,\n    2023\nFROM farms AS f\nWHERE f.name = 'Nourishing Harvest';", "latency_sec": 4.504025220870972, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 158, "prompt_eval_sec": null, "tokens_completion": 347, "completion_eval_sec": null, "tokens_total": 505, "tokens_per_sec": 112.12192988172144, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in how they generate the 'id' value. The Reference SQL uses a fixed value (5), while the Generated SQL calculates it as MAX(id) + 1 from the crops table. This would produce different results unless the existing crops table has a max id of 4. Additionally, the Generated SQL could insert multiple rows if multiple farms share the same name, though the schema implies a unique name constraint. The core discrepancy lies in the id generation strategy.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in how they handle the 'id' field. The reference query uses a fixed value (5) which could cause conflicts if that ID already exists. The generated query dynamically calculates the next available ID using (SELECT COALESCE(MAX(id), 0) + 1 FROM crops), ensuring uniqueness. Both correctly add the crop to the specified farm, but the generated version better handles real-world scenarios where IDs should be auto-incremented. The reference assumes prior knowledge of available IDs, which is less robust. Both satisfy the business intent, but the generated query is more reliable and elegant.", "overall_assessment": "differently_correct"}}
{"example_id": 3705, "sql_complexity": "subqueries", "prompt": "What is the percentage of unions with collective bargaining agreements in the Midwest region?", "context": "CREATE TABLE collective_bargaining (bargaining_id INT, union_name VARCHAR(50), contract_start_date DATE, contract_end_date DATE, region VARCHAR(50));CREATE VIEW union_region AS SELECT DISTINCT union_name, region FROM collective_bargaining;", "reference_sql": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM union_region) as percentage FROM union_region ur WHERE ur.region = 'Midwest' AND EXISTS (SELECT 1 FROM collective_bargaining cb WHERE cb.union_name = ur.union_name);", "generated_sql": "SELECT\n        COUNT(DISTINCT union_name) AS total_unions,\n        COUNT(DISTINCT CASE WHEN region = 'Midwest' THEN union_name END) AS midwest_unions\n    FROM collective_bargaining\n)\nSELECT\n    100.0 * midwest_unions / total_unions AS midwest_union_percentage\nFROM union_counts;", "raw_model_output": "WITH union_counts AS (\n    SELECT\n        COUNT(DISTINCT union_name) AS total_unions,\n        COUNT(DISTINCT CASE WHEN region = 'Midwest' THEN union_name END) AS midwest_unions\n    FROM collective_bargaining\n)\nSELECT\n    100.0 * midwest_unions / total_unions AS midwest_union_percentage\nFROM union_counts;", "latency_sec": 9.318464040756226, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 132, "prompt_eval_sec": null, "tokens_completion": 866, "completion_eval_sec": null, "tokens_total": 998, "tokens_per_sec": 107.09919527886152, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their calculation approach. The reference query uses a view (union_region) and calculates a percentage based on (Midwest union counts / total union_region rows), while the generated query uses collective_bargaining directly and computes (Midwest unions / total unions). The denominators differ: the reference counts distinct (union_name, region) pairs, while the generated query counts distinct union_names. This leads to different results when a union has multiple regions.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The Reference SQL is technically correct and directly addresses the question. It uses the union_region view (which ensures distinct union-region pairs) and correctly calculates the percentage by counting Midwest unions with agreements (via EXISTS) divided by total unions. The Generated SQL has a syntax error (missing WITH clause for CTE) and would fail execution. Even if corrected, it would produce equivalent results, but the Reference is more explicit in its logic and avoids potential overcounting by leveraging the pre-processed union_region view. Both fulfill the business intent, but the Reference is more robust and elegant.", "overall_assessment": "correct"}}
{"example_id": 240, "sql_complexity": "aggregation", "prompt": "What is the average capacity of renewable energy projects for each country?", "context": "CREATE TABLE projects (name TEXT, type TEXT, capacity INTEGER, country TEXT); INSERT INTO projects (name, type, capacity, country) VALUES ('Project 1', 'Wind', 100, 'USA'), ('Project 2', 'Solar', 200, 'Germany'), ('Project 3', 'Wind', 300, 'France');", "reference_sql": "SELECT country, AVG(capacity) FROM projects GROUP BY country", "generated_sql": "SELECT\n    country,\n    AVG(capacity) AS average_capacity\nFROM\n    projects\nWHERE\n    type IN ('Wind', 'Solar')  -- renewable types\nGROUP BY\n    country;", "raw_model_output": "```sql\nSELECT\n    country,\n    AVG(capacity) AS average_capacity\nFROM\n    projects\nWHERE\n    type IN ('Wind', 'Solar')  -- renewable types\nGROUP BY\n    country;\n```", "latency_sec": 2.498706102371216, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 150, "prompt_eval_sec": null, "tokens_completion": 128, "completion_eval_sec": null, "tokens_total": 278, "tokens_per_sec": 111.2575823688045, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes all projects in the aggregation, while the Generated SQL filters projects to only those with type 'Wind' or 'Solar'. Although the sample data contains only renewable projects, the WHERE clause makes them non-equivalent in general cases.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent because the generated query explicitly filters for renewable energy projects ('Wind' and 'Solar') while the reference query includes all projects regardless of type. The original question specifically asks for renewable energy projects, making the generated query's filter critical for business intent. Although both would produce identical results in the given sample data (which only contains renewable projects), the generated query is more precise and robust for real-world scenarios where non-renewable projects might exist. The reference query risks including non-renewable projects if present, which would misalign with the business question. The generated query better fulfills the intent by directly addressing the 'renewable' requirement.", "overall_assessment": "differently_correct"}}
{"example_id": 2132, "sql_complexity": "set operations", "prompt": "What is the average caseload per attorney in community legal clinics in California, and how does it compare to the state average?", "context": "CREATE TABLE cali_community_legal_clinics(id INT, attorney_count INT, cases_handled INT, state VARCHAR(255));", "reference_sql": "SELECT state, AVG(cases_handled/attorney_count) AS avg_caseload FROM cali_community_legal_clinics WHERE state = 'California' GROUP BY state UNION ALL SELECT 'California', AVG(cases_handled/attorney_count) FROM cali_community_legal_clinics WHERE state = 'California';", "generated_sql": "WITH california AS (\n    SELECT \n        SUM(cases_handled) * 1.0 / NULLIF(SUM(attorney_count), 0) AS avg_caseload_ca\n    FROM cali_community_legal_clinics\n    WHERE state = 'CA'\n),\noverall AS (\n    SELECT \n        SUM(cases_handled) * 1.0 / NULLIF(SUM(attorney_count), 0) AS avg_caseload_state\n    FROM cali_community_legal_clinics\n)\nSELECT \n    california.avg_caseload_ca   AS california_avg_caseload_per_attorney,\n    overall.avg_caseload_state   AS state_avg_caseload_per_attorney,\n    california.avg_caseload_ca - overall.avg_caseload_state AS difference_from_state\nFROM california, overall;", "raw_model_output": "```sql\nWITH california AS (\n    SELECT \n        SUM(cases_handled) * 1.0 / NULLIF(SUM(attorney_count), 0) AS avg_caseload_ca\n    FROM cali_community_legal_clinics\n    WHERE state = 'CA'\n),\noverall AS (\n    SELECT \n        SUM(cases_handled) * 1.0 / NULLIF(SUM(attorney_count), 0) AS avg_caseload_state\n    FROM cali_community_legal_clinics\n)\nSELECT \n    california.avg_caseload_ca   AS california_avg_caseload_per_attorney,\n    overall.avg_caseload_state   AS state_avg_caseload_per_attorney,\n    california.avg_caseload_ca - overall.avg_caseload_state AS difference_from_state\nFROM california, overall;\n```", "latency_sec": 9.400341033935547, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 119, "prompt_eval_sec": null, "tokens_completion": 769, "completion_eval_sec": null, "tokens_total": 888, "tokens_per_sec": 94.46465790914289, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL calculates the average caseload per attorney for California clinics and returns two identical rows (due to UNION ALL), while the Generated SQL computes total caseload divided by total attorneys for California and compares it to the state-wide average, returning a single row with three columns. Additionally, the Reference uses AVG(cases_handled/attorney_count) (per-row average) whereas the Generated uses SUM(cases_handled)/SUM(attorney_count) (total ratio), which mathematically differ.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL has critical flaws: 1) The UNION ALL duplicates the same California average calculation twice, creating redundant rows 2) The second query in the union incorrectly uses 'California' as a string literal instead of referencing the state column 3) It doesn't calculate the state average at all. The Generated SQL properly calculates both averages using SUM() with NULLIF for safety, compares them in a single row, and handles edge cases. While both queries aim to answer the question, the Generated SQL provides a more accurate, efficient, and semantically correct solution that directly addresses the comparison aspect.", "overall_assessment": "differently_correct"}}
{"example_id": 3276, "sql_complexity": "basic SQL", "prompt": "What is the total energy consumption of the Chemical Plant B in the last quarter?", "context": "CREATE TABLE EnergyConsumption (EnergyID INT, Plant VARCHAR(255), EnergyQuantity DECIMAL(5,2), Timestamp DATETIME);", "reference_sql": "SELECT SUM(EnergyQuantity) FROM EnergyConsumption WHERE Plant = 'Chemical Plant B' AND Timestamp BETWEEN DATE_SUB(CURRENT_DATE(), INTERVAL 3 MONTH) AND CURRENT_DATE();", "generated_sql": "SELECT\n    SUM(EnergyQuantity) AS TotalEnergyConsumption\nFROM\n    EnergyConsumption\nWHERE\n    Plant = 'Chemical Plant B'\n    AND EXTRACT(QUARTER FROM \"Timestamp\") = \n            CASE\n                WHEN EXTRACT(QUARTER FROM CURRENT_DATE) = 1\n                     THEN 4                      -- last quarter of previous year\n                ELSE EXTRACT(QUARTER FROM CURRENT_DATE) - 1\n            END\n    AND EXTRACT(YEAR FROM \"Timestamp\") =\n            CASE\n                WHEN EXTRACT(QUARTER FROM CURRENT_DATE) = 1\n                     THEN EXTRACT(YEAR FROM CURRENT_DATE) - 1\n                ELSE EXTRACT(YEAR FROM CURRENT_DATE)\n            END;", "raw_model_output": "-- Total energy consumption for Chemical Plant B during the most-recent\n-- completed calendar quarter.\n\nSELECT\n    SUM(EnergyQuantity) AS TotalEnergyConsumption\nFROM\n    EnergyConsumption\nWHERE\n    Plant = 'Chemical Plant B'\n    AND EXTRACT(QUARTER FROM \"Timestamp\") = \n            CASE\n                WHEN EXTRACT(QUARTER FROM CURRENT_DATE) = 1\n                     THEN 4                      -- last quarter of previous year\n                ELSE EXTRACT(QUARTER FROM CURRENT_DATE) - 1\n            END\n    AND EXTRACT(YEAR FROM \"Timestamp\") =\n            CASE\n                WHEN EXTRACT(QUARTER FROM CURRENT_DATE) = 1\n                     THEN EXTRACT(YEAR FROM CURRENT_DATE) - 1\n                ELSE EXTRACT(YEAR FROM CURRENT_DATE)\n            END;", "latency_sec": 10.891633987426758, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 109, "prompt_eval_sec": null, "tokens_completion": 765, "completion_eval_sec": null, "tokens_total": 874, "tokens_per_sec": 80.24507626761428, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query calculates the sum for the last 3 months using DATE_SUB and CURRENT_DATE, which includes a rolling 90-day period. The generated query uses quarter-based logic to target the previous full quarter (e.g., Q3 for Q4) but misses partial quarters within the 3-month window. For example, if today is in Q4, the generated query excludes October data (part of the 3-month window) while including the full Q3. This discrepancy in time range definition makes them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query uses a 3-month date range (DATE_SUB), which may include more than a full quarter (e.g., if the current date is in the middle of a month). The generated query explicitly targets the exact previous quarter using EXTRACT(QUARTER) and EXTRACT(YEAR) with conditional logic, ensuring precise quarter alignment. While both fulfill the business intent of calculating total energy consumption for Chemical Plant B, the generated query better captures the 'last quarter' requirement by aligning with calendar quarters rather than a fixed 3-month window. However, the reference query may be more efficient due to simpler date range filtering, but the generated query is more semantically accurate for the business question.", "overall_assessment": "differently_correct"}}
{"example_id": 3074, "sql_complexity": "multiple_joins", "prompt": "Find the top 5 players with the highest scores in the 'historical_tournaments' view, including their scores and the names of the tournaments they participated in.", "context": "CREATE VIEW historical_tournaments AS SELECT tournaments.tournament_name, players.player_name, players.score FROM tournaments JOIN players_scores ON tournaments.tournament_id = players_scores.tournament_id JOIN players ON players_scores.player_id = players.player_id;  CREATE TABLE tournaments (tournament_id INT, tournament_name TEXT);  CREATE TABLE players_scores (player_id INT, tournament_id INT, score INT);  CREATE TABLE players (player_id INT, player_name TEXT);", "reference_sql": "SELECT players.player_name, MAX(players_scores.score) as high_score, tournaments.tournament_name FROM historical_tournaments JOIN players ON historical_tournaments.player_id = players.player_id JOIN players_scores ON historical_tournaments.player_id = players_scores.player_id JOIN tournaments ON players_scores.tournament_id = tournaments.tournament_id GROUP BY players.player_id, tournaments.tournament_name ORDER BY high_score DESC LIMIT 5;", "generated_sql": "SELECT\n        player_name,\n        MAX(score) AS max_score\n    FROM historical_tournaments\n    GROUP BY player_name\n),\ntop5 AS (\n    SELECT\n        player_name,\n        max_score\n    FROM max_scores\n    ORDER BY max_score DESC\n    FETCH FIRST 5 ROWS ONLY\n)\nSELECT\n    h.player_name,\n    h.score,\n    h.tournament_name\nFROM historical_tournaments AS h\nJOIN top5 AS t\n  ON  h.player_name = t.player_name\n  AND h.score       = t.max_score\nORDER BY\n    t.max_score DESC,\n    h.tournament_name;", "raw_model_output": "-- 1) Get each player's highest score.\n-- 2) Keep the 5 players with the greatest of those scores.\n-- 3) Return the tournament(s) in which they achieved that top score.\n\nWITH max_scores AS (\n    SELECT\n        player_name,\n        MAX(score) AS max_score\n    FROM historical_tournaments\n    GROUP BY player_name\n),\ntop5 AS (\n    SELECT\n        player_name,\n        max_score\n    FROM max_scores\n    ORDER BY max_score DESC\n    FETCH FIRST 5 ROWS ONLY\n)\nSELECT\n    h.player_name,\n    h.score,\n    h.tournament_name\nFROM historical_tournaments AS h\nJOIN top5 AS t\n  ON  h.player_name = t.player_name\n  AND h.score       = t.max_score\nORDER BY\n    t.max_score DESC,\n    h.tournament_name;", "latency_sec": 7.7005579471588135, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 189, "prompt_eval_sec": null, "tokens_completion": 582, "completion_eval_sec": null, "tokens_total": 771, "tokens_per_sec": 100.12261517809459, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL groups by player_id and tournament_name to find per-player-per-tournament max scores, while the Generated SQL first finds each player's overall max score (regardless of tournament) and then retrieves all tournaments where that max score occurred. The output structures differ: the Reference includes tournament_name in its results, while the Generated SQL's final output includes all tournaments matching a player's max score. Additionally, the Generated SQL's CTE structure and joining logic produce different semantic behavior compared to the Reference's direct grouping and limiting.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL is technically flawed. It incorrectly groups by tournament_name and player_id, which would return per-tournament scores rather than per-player max scores. The Generated SQL correctly identifies each player's maximum score via a CTE, then retrieves all tournaments where that max score was achieved. While the Generated SQL may return multiple rows per player (if they have multiple tournaments with the same max score), it accurately addresses the business intent of finding top scorers and their tournament participation. The Reference SQL fails to aggregate scores correctly for players across tournaments.", "overall_assessment": "differently_correct"}}
{"example_id": 2219, "sql_complexity": "window functions", "prompt": "What is the average population of cities with a UNESCO World Heritage designation, ordered by designation date?", "context": "CREATE TABLE cities (name VARCHAR(255), population INT, designation_date DATE); INSERT INTO cities (name, population, designation_date) VALUES ('Paris', 2141000, '1991-09-16'); INSERT INTO cities (name, population, designation_date) VALUES ('Rio de Janeiro', 6727000, '2012-07-01');", "reference_sql": "SELECT AVG(population) FROM (SELECT population, ROW_NUMBER() OVER (ORDER BY designation_date) rn FROM cities WHERE name IN (SELECT name FROM heritagesites)) t WHERE rn % 2 = 1;", "generated_sql": "SELECT\n    designation_date,\n    AVG(population) AS average_population\nFROM\n    cities\nWHERE\n    designation_date IS NOT NULL\nGROUP BY\n    designation_date\nORDER BY\n    designation_date;", "raw_model_output": "```sql\nSELECT\n    designation_date,\n    AVG(population) AS average_population\nFROM\n    cities\nWHERE\n    designation_date IS NOT NULL\nGROUP BY\n    designation_date\nORDER BY\n    designation_date;\n```", "latency_sec": 8.501281023025513, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 159, "prompt_eval_sec": null, "tokens_completion": 642, "completion_eval_sec": null, "tokens_total": 801, "tokens_per_sec": 94.22109418927701, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates the average population of cities in heritagesites ordered by designation_date, selecting only odd-numbered rows. The generated query groups cities by designation_date and calculates average population per group. Key differences: 1) The reference uses a subquery with ROW_NUMBER() and heritagesites filter, 2) The generated query groups by designation_date and lacks the heritagesites filter, 3) Output structure differs (single value vs multiple rows).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference SQL is invalid due to referencing a non-existent 'heritagesites' table, making it technically incorrect. The generated SQL is also incorrect as it groups by designation_date, producing per-date averages instead of a single overall average. However, the generated query uses the available 'cities' table and avoids invalid references, making it more aligned with the context. Neither query correctly calculates the overall average population, but the generated query is technically superior due to valid table usage.", "overall_assessment": "incorrect"}}
{"example_id": 3786, "sql_complexity": "aggregation", "prompt": "Display the names and average co-owner percentages for all properties in the 'property_coownership' table where the co-owner percentage is greater than 60.", "context": "CREATE TABLE property_coownership (property_id INT, owner VARCHAR(255), percentage INT); INSERT INTO property_coownership (property_id, owner, percentage) VALUES (1, 'Mohammed', 70), (1, 'Fatima', 30), (2, 'Jamal', 65), (2, 'Aisha', 35), (3, 'Ali', 75), (3, 'Khadija', 25);", "reference_sql": "SELECT owner, AVG(percentage) FROM property_coownership WHERE percentage > 60 GROUP BY owner;", "generated_sql": "SELECT\n    pc.owner,\n    p.avg_percentage\nFROM\n    property_coownership AS pc\nJOIN (\n    SELECT\n        property_id,\n        AVG(percentage) AS avg_percentage\n    FROM\n        property_coownership\n    GROUP BY\n        property_id\n) AS p\n      ON p.property_id = pc.property_id\nWHERE\n    pc.percentage > 60;", "raw_model_output": "```sql\nSELECT\n    pc.owner,\n    p.avg_percentage\nFROM\n    property_coownership AS pc\nJOIN (\n    SELECT\n        property_id,\n        AVG(percentage) AS avg_percentage\n    FROM\n        property_coownership\n    GROUP BY\n        property_id\n) AS p\n      ON p.property_id = pc.property_id\nWHERE\n    pc.percentage > 60;\n```", "latency_sec": 7.346882104873657, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 188, "prompt_eval_sec": null, "tokens_completion": 613, "completion_eval_sec": null, "tokens_total": 801, "tokens_per_sec": 109.02584097118496, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the average percentage per owner for rows where percentage > 60, while the Generated SQL joins each row with the property's average percentage. The Reference SQL groups by owner and averages their individual percentages, whereas the Generated SQL retrieves the property-level average for each qualifying row, leading to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL groups by 'owner' and calculates the average percentage of all their entries, which misrepresents the business intent. It would return averages of individual owners' percentages across all properties, not property-level averages. The Generated SQL correctly calculates property-level averages by grouping on 'property_id' in a subquery, then joins back to filter owners with percentages >60. While it technically fulfills the property-level average requirement, it incorrectly filters owners (only showing those with >60% in their own entry) rather than displaying all owners of qualifying properties. The Generated query is more aligned with the intent of analyzing properties with co-owners >60% but fails to show all owners of those properties.", "overall_assessment": "differently_correct"}}
{"example_id": 2357, "sql_complexity": "basic SQL", "prompt": "What is the total amount of climate finance invested in renewable energy projects by public and private sectors in Africa?", "context": "CREATE TABLE renewable_energy_projects (project_id INT, sector TEXT, investor_type TEXT, region TEXT, amount FLOAT); INSERT INTO renewable_energy_projects (project_id, sector, investor_type, region, amount) VALUES (1, 'Renewable Energy', 'Public', 'Africa', 5000000); INSERT INTO renewable_energy_projects (project_id, sector, investor_type, region, amount) VALUES (2, 'Renewable Energy', 'Private', 'Africa', 7000000);", "reference_sql": "SELECT SUM(amount) FROM renewable_energy_projects WHERE sector = 'Renewable Energy' AND region = 'Africa';", "generated_sql": "SELECT\n    SUM(amount) AS total_amount\nFROM\n    renewable_energy_projects\nWHERE\n    sector = 'Renewable Energy'\n    AND region = 'Africa'\n    AND investor_type IN ('Public', 'Private');", "raw_model_output": "```sql\nSELECT\n    SUM(amount) AS total_amount\nFROM\n    renewable_energy_projects\nWHERE\n    sector = 'Renewable Energy'\n    AND region = 'Africa'\n    AND investor_type IN ('Public', 'Private');\n```", "latency_sec": 2.6771960258483887, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 186, "prompt_eval_sec": null, "tokens_completion": 132, "completion_eval_sec": null, "tokens_total": 318, "tokens_per_sec": 118.78099210132645, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL sums all projects in 'Renewable Energy' sector and 'Africa' region regardless of investor_type. The Generated SQL adds an explicit filter for investor_type IN ('Public', 'Private'). While the sample data contains only these two investor types, the queries are not semantically equivalent because the Generated SQL would exclude any projects with other investor_types (e.g., 'Government', 'Other') that might exist in the table, whereas the Reference SQL would include them.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The Reference SQL omits the investor_type filter, while the Generated SQL explicitly includes 'Public' and 'Private' investor types. The original question explicitly asks for investments from both public and private sectors, making the Generated SQL's additional filter critical for accuracy. Although the sample data only contains Public and Private entries, the Reference SQL would include any other investor types present in the dataset, potentially overcounting. The Generated SQL better fulfills the business intent by strictly adhering to the specified investor types.", "overall_assessment": "differently_correct"}}
{"example_id": 1009, "sql_complexity": "multiple_joins", "prompt": "Find the number of IoT sensors installed in each farm that use Sprinkler irrigation.", "context": "CREATE TABLE IoT_Sensors (id INT, sensor_type VARCHAR(50), Farm_id INT); INSERT INTO IoT_Sensors (id, sensor_type, Farm_id) VALUES (1, 'Soil Moisture', 1), (2, 'Temperature', 1), (3, 'Humidity', 2); CREATE TABLE Irrigation (id INT, Farm_id INT, irrigation_type VARCHAR(50), duration INT); INSERT INTO Irrigation (id, Farm_id, irrigation_type, duration) VALUES (1, 1, 'Sprinkler', 30), (2, 2, 'Drip', 45);", "reference_sql": "SELECT f.id, COUNT(s.id) FROM Farmers f JOIN Irrigation i ON f.id = i.Farm_id JOIN IoT_Sensors s ON f.id = s.Farm_id WHERE i.irrigation_type = 'Sprinkler' GROUP BY f.id;", "generated_sql": "SELECT \n    i.Farm_id,\n    COUNT(s.id) AS sensor_count\nFROM Irrigation AS i\nJOIN IoT_Sensors AS s\n  ON s.Farm_id = i.Farm_id\nWHERE i.irrigation_type = 'Sprinkler'\nGROUP BY i.Farm_id;", "raw_model_output": "```sql\nSELECT \n    i.Farm_id,\n    COUNT(s.id) AS sensor_count\nFROM Irrigation AS i\nJOIN IoT_Sensors AS s\n  ON s.Farm_id = i.Farm_id\nWHERE i.irrigation_type = 'Sprinkler'\nGROUP BY i.Farm_id;\n```", "latency_sec": 7.011591196060181, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 214, "prompt_eval_sec": null, "tokens_completion": 213, "completion_eval_sec": null, "tokens_total": 427, "tokens_per_sec": 60.899157988550684, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a JOIN with the Farmers table, which introduces a potential filter on Farm_id values present in the Farmers table. The Generated SQL directly joins Irrigation and IoT_Sensors on Farm_id without involving the Farmers table. This difference could lead to different results if there are Farm_id values in Irrigation or IoT_Sensors that do not exist in the Farmers table. Additionally, the Reference SQL groups by f.id (Farmers.id), while the Generated SQL groups by i.Farm_id, which are functionally equivalent only if Farmers.id matches Farm_id, but the presence of the Farmers table introduces ambiguity in semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count IoT sensors per farm using Sprinkler irrigation. The reference query includes an unnecessary JOIN with the Farmers table (which isn't needed since Farm_id is already in both Irrigation and IoT_Sensors). The generated query is more efficient by directly joining Irrigation and IoT_Sensors, avoiding redundant table access. Both produce identical results, but the generated version is technically superior due to simpler execution plan.", "overall_assessment": "correct"}}
{"example_id": 4217, "sql_complexity": "subqueries", "prompt": "Show consumer preference data for foundations, excluding products from the USA.", "context": "CREATE TABLE cosmetics (product_id INT, product_name VARCHAR(100), product_type VARCHAR(50), is_cruelty_free BOOLEAN, consumer_preference_score INT); INSERT INTO cosmetics (product_id, product_name, product_type, is_cruelty_free, consumer_preference_score) VALUES (1, 'Lipstick A', 'Lipstick', TRUE, 80), (2, 'Foundation B', 'Foundation', FALSE, 90), (3, 'Mascara C', 'Mascara', TRUE, 85), (4, 'Eyeshadow D', 'Eyeshadow', TRUE, 70), (5, 'Blush E', 'Blush', FALSE, 95); CREATE TABLE ingredient_sourcing (ingredient_id INT, ingredient_name VARCHAR(100), sourcing_country VARCHAR(50), is_organic BOOLEAN); INSERT INTO ingredient_sourcing (ingredient_id, ingredient_name, sourcing_country, is_organic) VALUES (1, 'Rosehip Oil', 'Chile', TRUE), (2, 'Shea Butter', 'Ghana', TRUE), (3, 'Jojoba Oil', 'India', TRUE), (4, 'Coconut Oil', 'Philippines', FALSE), (5, 'Aloe Vera', 'USA', TRUE);", "reference_sql": "SELECT * FROM cosmetics WHERE product_type = 'Foundation' AND product_id NOT IN (SELECT cosmetics.product_id FROM cosmetics INNER JOIN ingredient_sourcing ON cosmetics.product_id = ingredient_sourcing.ingredient_id WHERE ingredient_sourcing.sourcing_country = 'USA');", "generated_sql": "SELECT\n    c.product_id,\n    c.product_name,\n    c.consumer_preference_score\nFROM cosmetics            AS c\nJOIN ingredient_sourcing  AS i\n  ON c.product_id = i.ingredient_id\nWHERE c.product_type = 'Foundation'\n  AND i.sourcing_country <> 'USA';", "raw_model_output": "SELECT\n    c.product_id,\n    c.product_name,\n    c.consumer_preference_score\nFROM cosmetics            AS c\nJOIN ingredient_sourcing  AS i\n  ON c.product_id = i.ingredient_id\nWHERE c.product_type = 'Foundation'\n  AND i.sourcing_country <> 'USA';", "latency_sec": 14.120081186294556, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 335, "prompt_eval_sec": null, "tokens_completion": 977, "completion_eval_sec": null, "tokens_total": 1312, "tokens_per_sec": 92.91731277533114, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL excludes Foundation products that have any ingredient sourced from the USA (using NOT IN with a subquery). The Generated SQL selects Foundation products with ingredients not from the USA (using a JOIN with a WHERE condition). However, the Generated SQL incorrectly joins cosmetics.product_id with ingredient_sourcing.ingredient_id (which are different columns/tables), leading to different logic. Additionally, the Generated SQL returns specific columns while the Reference SQL returns all columns, further differing in output structure.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries are not technically equivalent due to fundamental logical errors. Both incorrectly join cosmetics.product_id with ingredient_sourcing.ingredient_id (which are unrelated columns), making their results invalid. The Reference uses a NOT IN subquery with this flawed join, while the Generated uses an explicit JOIN with the same error. However, the Generated query is more efficient (explicit JOIN vs subquery) and selects specific columns rather than all fields. Neither query correctly addresses the business intent because the schema lacks a proper product-ingredient relationship, but the Generated query is structurally superior despite the flaw.", "overall_assessment": "differently_correct"}}
{"example_id": 5620, "sql_complexity": "basic SQL", "prompt": "What is the recycling rate of plastic in the residential sector in the state of New York?", "context": "CREATE TABLE recycling_rates_city (sector VARCHAR(20), city VARCHAR(20), material VARCHAR(20), recycling_rate DECIMAL(5,2)); INSERT INTO recycling_rates_city (sector, city, material, recycling_rate) VALUES ('residential', 'New York City', 'plastic', 0.25), ('commercial', 'New York City', 'plastic', 0.30), ('residential', 'New York City', 'paper', 0.45), ('commercial', 'New York City', 'paper', 0.50), ('residential', 'Los Angeles', 'plastic', 0.20), ('commercial', 'Los Angeles', 'plastic', 0.35), ('residential', 'Los Angeles', 'paper', 0.40), ('commercial', 'Los Angeles', 'paper', 0.50);", "reference_sql": "SELECT recycling_rate FROM recycling_rates_city WHERE sector = 'residential' AND material = 'plastic' AND city = 'New York City';", "generated_sql": "SELECT recycling_rate\nFROM recycling_rates_city\nWHERE sector = 'residential'\n  AND material = 'plastic'\n  AND city = 'New York City';", "raw_model_output": "SELECT recycling_rate\nFROM recycling_rates_city\nWHERE sector = 'residential'\n  AND material = 'plastic'\n  AND city = 'New York City';", "latency_sec": 2.7855172157287598, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 258, "prompt_eval_sec": null, "tokens_completion": 179, "completion_eval_sec": null, "tokens_total": 437, "tokens_per_sec": 156.8828932495648, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the 'recycling_rate' from the same table with identical WHERE conditions (sector = 'residential', material = 'plastic', city = 'New York City'). The generated SQL is syntactically identical to the reference query, with only whitespace/indentation differences that do not affect semantic meaning.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are syntactically identical except for formatting differences (line breaks). They both select the recycling_rate from the recycling_rates_city table where sector is 'residential', material is 'plastic', and city is 'New York City'. The query logic perfectly matches the business question's requirements, as the data schema directly maps to the question's parameters. The result will correctly return the 0.25 value for New York City's residential plastic recycling rate.", "overall_assessment": "correct"}}
{"example_id": 3151, "sql_complexity": "basic SQL", "prompt": "List all biotech startups that received funding in 2022 and their respective funding amounts.", "context": "CREATE TABLE biotech_startups (name TEXT, funding FLOAT, date DATE); INSERT INTO biotech_startups (name, funding, date) VALUES ('StartupA', 3500000, '2022-02-28'); INSERT INTO biotech_startups (name, funding, date) VALUES ('StartupB', 4500000, '2022-07-12');", "reference_sql": "SELECT name, funding FROM biotech_startups WHERE date BETWEEN '2022-01-01' AND '2022-12-31';", "generated_sql": "SELECT\n    name,\n    funding\nFROM\n    biotech_startups\nWHERE\n    date >= DATE '2022-01-01'\n    AND date <  DATE '2023-01-01';", "raw_model_output": "SELECT\n    name,\n    funding\nFROM\n    biotech_startups\nWHERE\n    date >= DATE '2022-01-01'\n    AND date <  DATE '2023-01-01';", "latency_sec": 2.5877649784088135, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 158, "prompt_eval_sec": null, "tokens_completion": 126, "completion_eval_sec": null, "tokens_total": 284, "tokens_per_sec": 109.74721521064416, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select records with dates in 2022. The Reference uses BETWEEN '2022-01-01' AND '2022-12-31' (inclusive), while the Generated uses date >= '2022-01-01' and date < '2023-01-01' (exclusive upper bound). Since '2022-12-31' is less than '2023-01-01', both conditions cover the same date range.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly retrieve biotech startups funded in 2022. The reference query uses BETWEEN '2022-01-01' AND '2022-12-31' which includes all dates in 2022. The generated query uses date >= '2022-01-01' AND date < '2023-01-01' which is functionally identical for DATE type columns. However, the generated query is more robust as it avoids potential edge cases with BETWEEN (e.g., implicit inclusion of 2022-12-31 23:59:59.999 if using DATETIME types). Both fulfill the business intent, but the generated query demonstrates better date range handling practice.", "overall_assessment": "correct"}}
{"example_id": 2136, "sql_complexity": "window functions", "prompt": "What is the total military equipment sales revenue for each sales representative by fiscal year?", "context": "CREATE TABLE SalesReps (SalesRepID INT, SalesRepName VARCHAR(50), FiscalYear INT, Revenue DECIMAL(10,2)); INSERT INTO SalesReps (SalesRepID, SalesRepName, FiscalYear, Revenue) VALUES (1, 'John Doe', 2020, 150000.00), (2, 'Jane Smith', 2020, 200000.00), (1, 'John Doe', 2021, 180000.00), (2, 'Jane Smith', 2021, 250000.00);", "reference_sql": "SELECT SalesRepName, FiscalYear, SUM(Revenue) OVER (PARTITION BY SalesRepName ORDER BY FiscalYear) AS TotalRevenue FROM SalesReps;", "generated_sql": "SELECT\n    SalesRepID,\n    SalesRepName,\n    FiscalYear,\n    SUM(Revenue) AS TotalRevenue\nFROM\n    SalesReps\nGROUP BY\n    SalesRepID,\n    SalesRepName,\n    FiscalYear\nORDER BY\n    SalesRepID,\n    FiscalYear;", "raw_model_output": "```sql\nSELECT\n    SalesRepID,\n    SalesRepName,\n    FiscalYear,\n    SUM(Revenue) AS TotalRevenue\nFROM\n    SalesReps\nGROUP BY\n    SalesRepID,\n    SalesRepName,\n    FiscalYear\nORDER BY\n    SalesRepID,\n    FiscalYear;\n```", "latency_sec": 2.39741587638855, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 200, "prompt_eval_sec": null, "tokens_completion": 148, "completion_eval_sec": null, "tokens_total": 348, "tokens_per_sec": 145.15629241774468, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates a running total of revenue per sales representative over fiscal years using a window function, while the Generated SQL aggregates revenue per sales rep and fiscal year (which would just reproduce the original revenue values since each row is unique per (SalesRepID, FiscalYear)). The output columns and calculation logic differ fundamentally.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query uses a window function to calculate a running total per sales representative across fiscal years (e.g., 2020: $150k, 2021: $150k+$180k=$330k), which does not match the requirement for *yearly* totals. The generated query correctly groups by SalesRepID, SalesRepName, and FiscalYear to sum revenues for each specific year. While both queries are technically valid SQL, only the generated query aligns with the business intent of reporting annual totals. The reference query's cumulative approach would mislead stakeholders expecting standalone yearly figures.", "overall_assessment": "correct"}}
{"example_id": 5452, "sql_complexity": "basic SQL", "prompt": "What is the name of the farms with a size greater than 150 acres located in 'Texas'?", "context": "CREATE TABLE farms (id INT PRIMARY KEY, name VARCHAR(50), size INT, location VARCHAR(50)); INSERT INTO farms (id, name, size, location) VALUES (1, 'Smith Farms', 200, 'Texas'), (2, 'Johnson Farms', 100, 'California');", "reference_sql": "SELECT name FROM farms WHERE size > 150 AND location = 'Texas'", "generated_sql": "SELECT name\nFROM farms\nWHERE size > 150\n  AND location = 'Texas';", "raw_model_output": "SELECT name\nFROM farms\nWHERE size > 150\n  AND location = 'Texas';", "latency_sec": 1.4801390171051025, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 148, "prompt_eval_sec": null, "tokens_completion": 38, "completion_eval_sec": null, "tokens_total": 186, "tokens_per_sec": 125.66387200830907, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the 'name' column from the 'farms' table with identical WHERE conditions (size > 150 AND location = 'Texas'). The generated SQL uses different formatting (line breaks/indentation) but contains the same logical constraints and column/table references as the reference query.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are syntactically identical in logic and structure, with the generated SQL merely using whitespace formatting differences. They both correctly select farm names where size > 150 and location = 'Texas', which directly addresses the business question. The sample data would return 'Smith Farms' in both cases. Neither query demonstrates superior efficiency or elegance over the other as they are functionally identical.", "overall_assessment": "correct"}}
{"example_id": 5152, "sql_complexity": "aggregation", "prompt": "How many international tourists visited Portugal in 2020, broken down by continent?", "context": "CREATE TABLE international_tourists(tourist_id INT, country TEXT, arrival_year INT, continent TEXT);INSERT INTO international_tourists (tourist_id, country, arrival_year, continent) VALUES (1, 'Spain', 2020, 'Europe'), (2, 'France', 2020, 'Europe'), (3, 'Brazil', 2020, 'South America'), (4, 'United States', 2020, 'North America'), (5, 'China', 2020, 'Asia');", "reference_sql": "SELECT continent, COUNT(*) FROM international_tourists WHERE arrival_year = 2020 GROUP BY continent;", "generated_sql": "SELECT\n    continent,\n    COUNT(*) AS num_tourists\nFROM\n    international_tourists\nWHERE\n    country = 'Portugal'\n    AND arrival_year = 2020\nGROUP BY\n    continent;", "raw_model_output": "```sql\nSELECT\n    continent,\n    COUNT(*) AS num_tourists\nFROM\n    international_tourists\nWHERE\n    country = 'Portugal'\n    AND arrival_year = 2020\nGROUP BY\n    continent;\n```", "latency_sec": 2.4712257385253906, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 191, "prompt_eval_sec": null, "tokens_completion": 132, "completion_eval_sec": null, "tokens_total": 323, "tokens_per_sec": 130.70436867201695, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL counts all tourists from 2020 grouped by continent, while the Generated SQL filters for 'Portugal' (which doesn't exist in the data) and would return no results. The WHERE clause in the Generated SQL eliminates all rows, making the results fundamentally different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL is technically correct but fails to filter for Portugal as the destination country, instead counting all international tourists in 2020. The Generated SQL correctly filters for 'Portugal' as the tourist's country but misinterprets the business intent. The question asks for tourists who visited Portugal (destination), but the table structure implies 'country' refers to the tourist's origin. The Reference SQL correctly groups by continent for all 2020 tourists, while the Generated SQL incorrectly restricts to tourists from Portugal (origin) rather than visitors to Portugal (destination). Neither query fully addresses the intent, but the Reference SQL is technically correct for its scope.", "overall_assessment": "incorrect"}}
{"example_id": 2477, "sql_complexity": "set operations", "prompt": "What is the carbon price in Europe and Australia for the last quarter of 2020?", "context": "CREATE TABLE CarbonPrices (Country TEXT, Year INT, Quarter INT, CarbonPrice NUMBER); INSERT INTO CarbonPrices (Country, Year, Quarter, CarbonPrice) VALUES ('Europe', 2020, 4, 25), ('Australia', 2020, 4, 15); CREATE TABLE CarbonTaxes (Country TEXT, Year INT, Quarter INT, CarbonPrice NUMBER); INSERT INTO CarbonTaxes (Country, Year, Quarter, CarbonPrice) VALUES ('Europe', 2019, 4, 20), ('Australia', 2019, 4, 10);", "reference_sql": "SELECT Context.Country, Context.CarbonPrice FROM ( SELECT * FROM CarbonPrices WHERE CarbonPrices.Country IN ('Europe', 'Australia') AND CarbonPrices.Year = 2020 AND CarbonPrices.Quarter = 4 UNION SELECT * FROM CarbonTaxes WHERE CarbonTaxes.Country IN ('Europe', 'Australia') AND CarbonTaxes.Year = 2020 AND CarbonTaxes.Quarter = 4 ) AS Context;", "generated_sql": "SELECT Country,\n       CarbonPrice\nFROM   CarbonPrices\nWHERE  Year = 2020\n  AND  Quarter = 4\n  AND  Country IN ('Europe', 'Australia');", "raw_model_output": "SELECT Country,\n       CarbonPrice\nFROM   CarbonPrices\nWHERE  Year = 2020\n  AND  Quarter = 4\n  AND  Country IN ('Europe', 'Australia');", "latency_sec": 2.740410089492798, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 202, "prompt_eval_sec": null, "tokens_completion": 186, "completion_eval_sec": null, "tokens_total": 388, "tokens_per_sec": 141.58464876759086, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL combines data from both CarbonPrices and CarbonTaxes tables using a UNION, while the Generated SQL only queries the CarbonPrices table. Although the sample data for CarbonTaxes in 2020 is empty, the queries are not equivalent because the Reference SQL would include CarbonTaxes data if available, whereas the Generated SQL explicitly excludes it.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries return the same results because the CarbonTaxes table has no data for 2020 Q4 (only 2019 Q4 exists). The Reference SQL includes an unnecessary UNION with CarbonTaxes, which adds complexity without affecting the output. The Generated SQL is more efficient, directly targets the CarbonPrices table (which contains relevant data), and avoids redundant operations. While both technically fulfill the intent, the Generated SQL better aligns with the business question by focusing on the correct data source.", "overall_assessment": "correct"}}
{"example_id": 4573, "sql_complexity": "subqueries", "prompt": "Find the names of all the indigenous communities in the 'Arctic_Communities' table that have a population size greater than the average population size in the 'Antarctic_Communities' table.", "context": "CREATE TABLE Arctic_Communities (name TEXT, population INTEGER); CREATE TABLE Antarctic_Communities (name TEXT, population INTEGER);", "reference_sql": "SELECT name FROM Arctic_Communities WHERE Arctic_Communities.population > (SELECT AVG(population) FROM Antarctic_Communities)", "generated_sql": "SELECT\n    name\nFROM\n    Arctic_Communities\nWHERE\n    population > (\n        SELECT AVG(population)\n        FROM Antarctic_Communities\n    );", "raw_model_output": "SELECT\n    name\nFROM\n    Arctic_Communities\nWHERE\n    population > (\n        SELECT AVG(population)\n        FROM Antarctic_Communities\n    );", "latency_sec": 2.445996046066284, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 133, "prompt_eval_sec": null, "tokens_completion": 117, "completion_eval_sec": null, "tokens_total": 250, "tokens_per_sec": 102.20785123592356, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select names from Arctic_Communities where population exceeds the average population of Antarctic_Communities. The generated query omits table qualification for the population column (which is unambiguous in context) and removes parentheses around the subquery (which are optional for single-column subqueries). These are syntactic variations without semantic impact.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent. They both select community names from Arctic_Communities where population exceeds the average population from Antarctic_Communities. The reference query explicitly qualifies the population column with the table name, while the generated query relies on column context within the Arctic_Communities table. Both correctly calculate the subquery average and apply the comparison. The business intent of comparing Arctic populations to the Antarctic average is fully satisfied by both. The generated query is slightly more concise but neither demonstrates superior efficiency or elegance over the other.", "overall_assessment": "correct"}}
{"example_id": 3596, "sql_complexity": "window functions", "prompt": "What is the total revenue for each game in the \"Gaming\" category?", "context": "CREATE TABLE Games (GameID int, GameName varchar(50), Category varchar(50), Revenue decimal(10,2));", "reference_sql": "SELECT Category, SUM(Revenue) OVER(PARTITION BY Category) as TotalRevenue FROM Games;", "generated_sql": "SELECT\n    GameName,\n    SUM(Revenue) AS TotalRevenue\nFROM\n    Games\nWHERE\n    Category = 'Gaming'\nGROUP BY\n    GameName;", "raw_model_output": "```sql\nSELECT\n    GameName,\n    SUM(Revenue) AS TotalRevenue\nFROM\n    Games\nWHERE\n    Category = 'Gaming'\nGROUP BY\n    GameName;\n```", "latency_sec": 1.9106481075286865, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 107, "prompt_eval_sec": null, "tokens_completion": 58, "completion_eval_sec": null, "tokens_total": 165, "tokens_per_sec": 86.3581312277424, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates the total revenue per category for all games using a window function, returning Category and TotalRevenue columns. The generated query filters only 'Gaming' category, groups by GameName, and sums revenue per game, resulting in different columns (GameName vs. Category) and different aggregation logic.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query uses a window function to calculate the total revenue per category, but it returns the same category total for every row in the 'Gaming' category, not per game. The generated query correctly filters to the 'Gaming' category, groups by GameName, and sums revenue per game. While the generated query is technically correct for the business intent, it assumes that each GameName is unique and that revenue needs to be aggregated (e.g., for multiple entries per game). The reference query fails to address the actual requirement of separating revenue by individual games.", "overall_assessment": "differently_correct"}}
{"example_id": 5039, "sql_complexity": "subqueries", "prompt": "What is the total number of community policing events in 'City Park' in 2021?", "context": "CREATE TABLE locations (id INT, name VARCHAR(255)); CREATE TABLE community_policing (id INT, location_id INT, year INT, events INT); INSERT INTO locations (id, name) VALUES (1, 'City Park'); INSERT INTO community_policing (id, location_id, year, events) VALUES (1, 1, 2021, 5);", "reference_sql": "SELECT SUM(events) FROM community_policing WHERE location_id = (SELECT id FROM locations WHERE name = 'City Park') AND year = 2021;", "generated_sql": "SELECT SUM(cp.events) AS total_events\nFROM community_policing AS cp\nJOIN locations AS l\n  ON cp.location_id = l.id\nWHERE l.name = 'City Park'\n  AND cp.year = 2021;", "raw_model_output": "SELECT SUM(cp.events) AS total_events\nFROM community_policing AS cp\nJOIN locations AS l\n  ON cp.location_id = l.id\nWHERE l.name = 'City Park'\n  AND cp.year = 2021;", "latency_sec": 3.202481746673584, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 161, "prompt_eval_sec": null, "tokens_completion": 194, "completion_eval_sec": null, "tokens_total": 355, "tokens_per_sec": 110.85152955789313, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of 'events' from community_policing for the location named 'City Park' in 2021. The reference uses a subquery to get the location_id, while the generated query uses a JOIN to correlate the tables. Since the WHERE conditions (location name and year) are equivalent, and the sample data has a unique location name, both produce the same result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the total community policing events in 'City Park' for 2021. The reference query uses a subquery to get location_id, while the generated query uses an explicit JOIN. Both handle the relationship between tables correctly. The generated query is more readable and scalable, as JOINs are standard for relational data and avoid potential issues if multiple locations had the same name. The SUM(events) aggregation is identical in both. The generated version also uses table aliases (cp/l) which improves clarity. While both are correct, the generated query demonstrates better SQL practices for maintainability and efficiency.", "overall_assessment": "correct"}}
{"example_id": 2724, "sql_complexity": "basic SQL", "prompt": "What is the earliest installation date for solar panels in Italy?", "context": "CREATE TABLE solar_panels_italy (id INT, installation_date DATE); INSERT INTO solar_panels_italy (id, installation_date) VALUES (1, '2018-01-01'), (2, '2019-01-01'), (3, '2020-01-01');", "reference_sql": "SELECT MIN(installation_date) as earliest_date FROM solar_panels_italy;", "generated_sql": "SELECT MIN(installation_date) AS earliest_installation_date\nFROM solar_panels_italy;", "raw_model_output": "SELECT MIN(installation_date) AS earliest_installation_date\nFROM solar_panels_italy;", "latency_sec": 2.253412961959839, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 142, "prompt_eval_sec": null, "tokens_completion": 103, "completion_eval_sec": null, "tokens_total": 245, "tokens_per_sec": 108.7239685472114, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the minimum installation_date from the same table. The only difference is the column alias name ('earliest_date' vs 'earliest_installation_date'), which does not affect the semantic result. The MIN() function and table structure are identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly retrieve the earliest installation date using MIN(installation_date). The only difference is the column alias ('earliest_date' vs 'earliest_installation_date'), which does not affect the result's accuracy or business relevance. The generated query's alias is slightly more descriptive but neither query introduces errors or omissions. Both are equally efficient and semantically equivalent.", "overall_assessment": "correct"}}
{"example_id": 2200, "sql_complexity": "single join", "prompt": "Which diversity programs are currently being participated in by employees in the HR department?", "context": "CREATE TABLE Employees (Employee_ID INT, First_Name VARCHAR(20), Last_Name VARCHAR(20), Department VARCHAR(20), Salary DECIMAL(10,2), Date_Hired DATE); CREATE TABLE Diversity_Programs (Program_ID INT, Program_Name VARCHAR(50), Participant_ID INT, Date_Started DATE, Date_Ended DATE);", "reference_sql": "SELECT dp.Program_Name FROM Diversity_Programs dp JOIN Employees e ON dp.Participant_ID = e.Employee_ID WHERE e.Department = 'HR' AND dp.Date_Ended IS NULL;", "generated_sql": "SELECT DISTINCT\n       dp.Program_ID,\n       dp.Program_Name\nFROM   Diversity_Programs AS dp\nJOIN   Employees          AS e\n       ON dp.Participant_ID = e.Employee_ID\nWHERE  e.Department = 'HR'\n  AND (dp.Date_Ended IS NULL OR dp.Date_Ended > CURRENT_DATE);", "raw_model_output": "SELECT DISTINCT\n       dp.Program_ID,\n       dp.Program_Name\nFROM   Diversity_Programs AS dp\nJOIN   Employees          AS e\n       ON dp.Participant_ID = e.Employee_ID\nWHERE  e.Department = 'HR'\n  AND (dp.Date_Ended IS NULL OR dp.Date_Ended > CURRENT_DATE);", "latency_sec": 6.749986171722412, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 149, "prompt_eval_sec": null, "tokens_completion": 276, "completion_eval_sec": null, "tokens_total": 425, "tokens_per_sec": 62.96309195127604, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the generated query includes an additional condition (dp.Date_Ended > CURRENT_DATE) in the WHERE clause, expanding the scope beyond just NULL end dates. Second, the generated query selects both Program_ID and Program_Name with DISTINCT, while the reference query only selects Program_Name. These differences in column selection and filtering criteria make the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The reference query correctly identifies currently active programs by checking for NULL Date_Ended, which aligns with typical data modeling where NULL indicates ongoing participation. The generated query incorrectly uses (Date_Ended IS NULL OR Date_Ended > CURRENT_DATE), which would erroneously include programs ending in the future (assuming Date_Ended represents program end dates, not participant exit dates). Additionally, the generated query includes Program_ID (unnecessary for the question) and uses DISTINCT unnecessarily. While the generated query's condition might be valid in a different data model, the reference better matches the business intent of identifying active participation.", "overall_assessment": "correct"}}
{"example_id": 4359, "sql_complexity": "window functions", "prompt": "Which destinations have the least hotel awards?", "context": "CREATE TABLE Destinations (destination_id INT, destination_name TEXT, country TEXT, awards INT); INSERT INTO Destinations (destination_id, destination_name, country, awards) VALUES (1, 'City A', 'Germany', 3), (2, 'City B', 'Switzerland', 5), (3, 'City C', 'Norway', 2);", "reference_sql": "SELECT destination_name, country, awards, RANK() OVER (PARTITION BY country ORDER BY awards ASC) AS rank FROM Destinations;", "generated_sql": "SELECT destination_name\nFROM Destinations\nWHERE awards = (SELECT MIN(awards) FROM Destinations);", "raw_model_output": "```sql\nSELECT destination_name\nFROM Destinations\nWHERE awards = (SELECT MIN(awards) FROM Destinations);\n```", "latency_sec": 2.6511967182159424, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 150, "prompt_eval_sec": null, "tokens_completion": 109, "completion_eval_sec": null, "tokens_total": 259, "tokens_per_sec": 97.69173227337414, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates ranks within each country based on awards, returning all destinations with their rank. The Generated SQL only returns destinations with the minimum awards globally. They differ in both output columns and logic: the first includes ranking information per country, while the second filters for the absolute minimum awards value.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query ranks destinations within each country by awards, which introduces unnecessary complexity and misaligns with the original question that doesn't mention country-based comparisons. The generated query correctly identifies destinations with the absolute minimum awards (e.g., City C in the sample data). While the reference query could be modified to remove the 'PARTITION BY country' clause to match the generated query's behavior, as written they produce different results. The generated query is more efficient and directly addresses the business intent of finding destinations with the least awards.", "overall_assessment": "differently_correct"}}
{"example_id": 1373, "sql_complexity": "subqueries", "prompt": "What is the total value of military equipment sales to Africa in the last 12 months?", "context": "CREATE TABLE Military_Equipment_Sales(sale_id INT, sale_date DATE, equipment_type VARCHAR(50), country VARCHAR(50), sale_value DECIMAL(10,2));", "reference_sql": "SELECT SUM(sale_value) FROM Military_Equipment_Sales WHERE country IN (SELECT country FROM World_Countries WHERE continent = 'Africa') AND sale_date >= DATE_SUB(CURRENT_DATE, INTERVAL 12 MONTH);", "generated_sql": "SELECT \n    SUM(sale_value) AS total_value\nFROM\n    Military_Equipment_Sales\nWHERE\n    sale_date >= CURRENT_DATE - INTERVAL '12' MONTH\n    AND country IN (\n        'Algeria', 'Angola', 'Benin', 'Botswana', 'Burkina Faso', 'Burundi',\n        'Cabo Verde', 'Cameroon', 'Central African Republic', 'Chad', 'Comoros',\n        'Democratic Republic of the Congo', 'Republic of the Congo',\n        'Cote d''Ivoire', 'Djibouti', 'Egypt', 'Equatorial Guinea', 'Eritrea',\n        'Eswatini', 'Ethiopia', 'Gabon', 'Gambia', 'Ghana', 'Guinea',\n        'Guinea-Bissau', 'Kenya', 'Lesotho', 'Liberia', 'Libya', 'Madagascar',\n        'Malawi', 'Mali', 'Mauritania', 'Mauritius', 'Morocco', 'Mozambique',\n        'Namibia', 'Niger', 'Nigeria', 'Rwanda', 'Sao Tome and Principe',\n        'Senegal', 'Seychelles', 'Sierra Leone', 'Somalia', 'South Africa',\n        'South Sudan', 'Sudan', 'Tanzania', 'Togo', 'Tunisia', 'Uganda',\n        'Zambia', 'Zimbabwe'\n    );", "raw_model_output": "```sql\nSELECT \n    SUM(sale_value) AS total_value\nFROM\n    Military_Equipment_Sales\nWHERE\n    sale_date >= CURRENT_DATE - INTERVAL '12' MONTH\n    AND country IN (\n        'Algeria', 'Angola', 'Benin', 'Botswana', 'Burkina Faso', 'Burundi',\n        'Cabo Verde', 'Cameroon', 'Central African Republic', 'Chad', 'Comoros',\n        'Democratic Republic of the Congo', 'Republic of the Congo',\n        'Cote d''Ivoire', 'Djibouti', 'Egypt', 'Equatorial Guinea', 'Eritrea',\n        'Eswatini', 'Ethiopia', 'Gabon', 'Gambia', 'Ghana', 'Guinea',\n        'Guinea-Bissau', 'Kenya', 'Lesotho', 'Liberia', 'Libya', 'Madagascar',\n        'Malawi', 'Mali', 'Mauritania', 'Mauritius', 'Morocco', 'Mozambique',\n        'Namibia', 'Niger', 'Nigeria', 'Rwanda', 'Sao Tome and Principe',\n        'Senegal', 'Seychelles', 'Sierra Leone', 'Somalia', 'South Africa',\n        'South Sudan', 'Sudan', 'Tanzania', 'Togo', 'Tunisia', 'Uganda',\n        'Zambia', 'Zimbabwe'\n    );\n```", "latency_sec": 14.350008964538574, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 120, "prompt_eval_sec": null, "tokens_completion": 1024, "completion_eval_sec": null, "tokens_total": 1144, "tokens_per_sec": 79.72120455304436, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in how they filter countries. The reference query uses a subquery against the World_Countries table to get African countries, while the generated query uses an explicit hard-coded list. Unless the World_Countries table contains *exactly* the same countries as the list in the generated query (which cannot be confirmed without data inspection), the results may differ. Additionally, the generated query includes countries like 'Democratic Republic of the Congo' and 'Republic of the Congo' which might not be explicitly handled in the subquery's logic.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent. The reference query dynamically identifies African countries via a subquery on World_Countries, while the generated query uses a static list of country names. The reference is more maintainable and less error-prone if the World_Countries table is accurate. Both fulfill the business intent of calculating African military sales, but the reference is superior because it adapts to changes in country-continent mappings. The generated query risks inaccuracies if the hardcoded list is incomplete or outdated. The reference also uses a more elegant date calculation (DATE_SUB) compared to the generated query's INTERVAL '12' MONTH syntax, which may not be standard across all SQL dialects.", "overall_assessment": "differently_correct"}}
{"example_id": 904, "sql_complexity": "basic SQL", "prompt": "What is the minimum Shariah-compliant loan amount issued in the last quarter of 2021?", "context": "CREATE TABLE loans (id INT, amount DECIMAL, date DATE, loan_type VARCHAR); INSERT INTO loans (id, amount, date, loan_type) VALUES (1, 5000, '2021-09-05', 'Shariah-compliant'), (2, 7000, '2021-10-07', 'socially responsible'), (3, 9000, '2021-11-03', 'Shariah-compliant'), (4, 11000, '2021-12-31', 'Shariah-compliant');", "reference_sql": "SELECT MIN(amount) FROM loans WHERE EXTRACT(YEAR FROM date) = 2021 AND EXTRACT(QUARTER FROM date) = 4 AND loan_type = 'Shariah-compliant';", "generated_sql": "SELECT \n    MIN(amount) AS min_shariah_loan_amount\nFROM \n    loans\nWHERE\n    loan_type = 'Shariah-compliant'\n    AND EXTRACT(YEAR FROM date) = 2021\n    AND EXTRACT(QUARTER FROM date) = 4;", "raw_model_output": "SELECT \n    MIN(amount) AS min_shariah_loan_amount\nFROM \n    loans\nWHERE\n    loan_type = 'Shariah-compliant'\n    AND EXTRACT(YEAR FROM date) = 2021\n    AND EXTRACT(QUARTER FROM date) = 4;", "latency_sec": 4.5328309535980225, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 205, "prompt_eval_sec": null, "tokens_completion": 337, "completion_eval_sec": null, "tokens_total": 542, "tokens_per_sec": 119.57207439420986, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter loans with 'Shariah-compliant' type, year 2021, and quarter 4, then select the minimum amount. The order of conditions in the WHERE clause does not affect the result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent as they use identical logic to filter Shariah-compliant loans from Q4 2021 and calculate the minimum amount. The reference query uses a simpler syntax without column aliases, while the generated query adds an explicit alias for clarity. The order of conditions in the WHERE clause does not affect the result. Both correctly address the business intent by restricting to the specified quarter, year, and loan type. Neither query demonstrates superior efficiency or elegance over the other in this context.", "overall_assessment": "correct"}}
{"example_id": 3299, "sql_complexity": "set operations", "prompt": "How many schools and hospitals are there in Colombia and which ones need repairs?", "context": "CREATE TABLE schools (id INT, country VARCHAR(20), name VARCHAR(50), needs_repair BOOLEAN); CREATE TABLE hospitals (id INT, country VARCHAR(20), name VARCHAR(50), needs_repair BOOLEAN);", "reference_sql": "SELECT 'Schools' as facility_type, COUNT(*) as total, SUM(needs_repair) as repairs_needed FROM schools WHERE country = 'Colombia' UNION ALL SELECT 'Hospitals' as facility_type, COUNT(*) as total, SUM(needs_repair) as repairs_needed FROM hospitals WHERE country = 'Colombia';", "generated_sql": "SELECT 'school'   AS facility_type,\n       COUNT(*)   AS total_facilities,\n       STRING_AGG(name, ', ') FILTER (WHERE needs_repair) AS facilities_needing_repair\nFROM   schools\nWHERE  country = 'Colombia'\n\nUNION ALL\n\nSELECT 'hospital',\n       COUNT(*),\n       STRING_AGG(name, ', ') FILTER (WHERE needs_repair)\nFROM   hospitals\nWHERE  country = 'Colombia';", "raw_model_output": "SELECT 'school'   AS facility_type,\n       COUNT(*)   AS total_facilities,\n       STRING_AGG(name, ', ') FILTER (WHERE needs_repair) AS facilities_needing_repair\nFROM   schools\nWHERE  country = 'Colombia'\n\nUNION ALL\n\nSELECT 'hospital',\n       COUNT(*),\n       STRING_AGG(name, ', ') FILTER (WHERE needs_repair)\nFROM   hospitals\nWHERE  country = 'Colombia';", "latency_sec": 23.04173183441162, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 125, "prompt_eval_sec": null, "tokens_completion": 2094, "completion_eval_sec": null, "tokens_total": 2219, "tokens_per_sec": 96.30352509727761, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their output structure and aggregation logic. The Reference SQL calculates COUNT(*) and SUM(needs_repair) for each facility type, while the Generated SQL uses STRING_AGG to concatenate names of facilities needing repair. The first returns numerical counts, the second returns comma-separated strings of names. Additionally, column aliases and facility_type labels differ in casing/pluralization.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query returns counts and repair totals as numeric values, while the generated query provides aggregated facility names as strings. The original question asks for both 'how many' (quantitative) and 'which ones' (qualitative) information. The generated query better fulfills the business intent by explicitly listing facilities needing repair (via STRING_AGG) while still providing counts. The reference query only reports the number of repairs needed (SUM(needs_repair)) rather than specific facility names. The generated query is more elegant in combining both quantitative and qualitative insights in a single result set.", "overall_assessment": "differently_correct"}}
{"example_id": 907, "sql_complexity": "set operations", "prompt": "What is the total quantity of items with type 'E' or type 'F' in warehouse O and warehouse P?", "context": "CREATE TABLE warehouse_o(item_id INT, item_type VARCHAR(10), quantity INT);CREATE TABLE warehouse_p(item_id INT, item_type VARCHAR(10), quantity INT);INSERT INTO warehouse_o(item_id, item_type, quantity) VALUES (1, 'E', 200), (2, 'F', 300), (3, 'E', 50), (4, 'F', 400);INSERT INTO warehouse_p(item_id, item_type, quantity) VALUES (1, 'E', 150), (2, 'F', 250), (3, 'E', 40), (4, 'F', 350);", "reference_sql": "SELECT quantity FROM warehouse_o WHERE item_type IN ('E', 'F') UNION ALL SELECT quantity FROM warehouse_p WHERE item_type IN ('E', 'F');", "generated_sql": "SELECT SUM(quantity) AS total_quantity\nFROM (\n    SELECT quantity\n    FROM warehouse_o\n    WHERE item_type IN ('E', 'F')\n    \n    UNION ALL\n    \n    SELECT quantity\n    FROM warehouse_p\n    WHERE item_type IN ('E', 'F')\n) AS combined;", "raw_model_output": "```sql\nSELECT SUM(quantity) AS total_quantity\nFROM (\n    SELECT quantity\n    FROM warehouse_o\n    WHERE item_type IN ('E', 'F')\n    \n    UNION ALL\n    \n    SELECT quantity\n    FROM warehouse_p\n    WHERE item_type IN ('E', 'F')\n) AS combined;\n```", "latency_sec": 3.0767149925231934, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 222, "prompt_eval_sec": null, "tokens_completion": 146, "completion_eval_sec": null, "tokens_total": 368, "tokens_per_sec": 119.60808878764739, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns individual quantities from both tables combined via UNION ALL, while the Generated SQL aggregates all those quantities into a single sum. The first produces multiple rows of raw data, the second produces a single summarized value. Their result structures and purposes differ fundamentally.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query returns individual quantities from both warehouses without aggregation, while the generated query properly sums all qualifying quantities. The original question explicitly asks for 'total quantity,' which requires aggregation. The reference query would produce multiple rows of data rather than a single total value. The generated query correctly uses a subquery with UNION ALL to combine all relevant quantities and then applies SUM to achieve the desired result. Both queries are syntactically correct but differ in semantic output. The generated query is more efficient as it directly computes the total in a single operation.", "overall_assessment": "differently_correct"}}
{"example_id": 1400, "sql_complexity": "single join", "prompt": "What is the maximum co-ownership duration for properties in the neighborhood of 'Chinatown' in San Francisco?'", "context": "CREATE TABLE sf_neighborhoods (neighborhood_id INT, name VARCHAR(255), city VARCHAR(255)); INSERT INTO sf_neighborhoods (neighborhood_id, name, city) VALUES (1, 'Chinatown', 'San Francisco'); CREATE TABLE co_ownership (co_ownership_id INT, property_id INT, co_owner_id INT, start_date DATE, end_date DATE); INSERT INTO co_ownership (co_ownership_id, property_id, co_owner_id, start_date, end_date) VALUES (1, 1, 2, '2010-01-01', '2020-01-01'), (2, 2, 3, '2015-01-01', '2022-01-01'); CREATE TABLE properties (property_id INT, city VARCHAR(255)); INSERT INTO properties (property_id, city) VALUES (1, 'San Francisco'), (2, 'San Francisco');", "reference_sql": "SELECT MAX(DATEDIFF(end_date, start_date)) as max_duration FROM co_ownership JOIN properties ON co_ownership.property_id = properties.property_id WHERE properties.city = 'San Francisco' AND name = 'Chinatown';", "generated_sql": "SELECT\n    MAX(end_date - start_date) AS max_co_ownership_duration_days\nFROM\n    co_ownership      co\nJOIN\n    properties        p  ON p.property_id = co.property_id\nWHERE\n    p.city = 'San Francisco';", "raw_model_output": "```sql\nSELECT\n    MAX(end_date - start_date) AS max_co_ownership_duration_days\nFROM\n    co_ownership      co\nJOIN\n    properties        p  ON p.property_id = co.property_id\nWHERE\n    p.city = 'San Francisco';\n```", "latency_sec": 7.639098882675171, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 279, "prompt_eval_sec": null, "tokens_completion": 524, "completion_eval_sec": null, "tokens_total": 803, "tokens_per_sec": 105.11711032058192, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a WHERE condition 'name = 'Chinatown'' which references a column from the sf_neighborhoods table, but the query does not join with that table. The Generated SQL omits this condition and only filters by 'San Francisco' in the properties.city column. Since the Reference SQL is invalid (missing required join for 'name') and the Generated SQL lacks the 'name' filter, they are not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query is technically incorrect because it references the 'name' column without joining with the sf_neighborhoods table, leading to a syntax error. The generated query is syntactically valid but fails to filter properties by the 'Chinatown' neighborhood, as it lacks the necessary join with sf_neighborhoods. Both queries miss the critical neighborhood filter, but the generated query is more technically sound (assuming date subtraction is valid in the DBMS). The reference query's use of DATEDIFF vs. the generated's date subtraction may not be equivalent across DBMS, but the generated query's structure is more elegant.", "overall_assessment": "incorrect"}}
{"example_id": 5248, "sql_complexity": "window functions", "prompt": "Find the top 5 games by rating", "context": "CREATE TABLE games (game_id INT PRIMARY KEY, name VARCHAR(50), genre VARCHAR(50), rating DECIMAL(3,2));", "reference_sql": "SELECT * FROM (SELECT name, rating, ROW_NUMBER() OVER (ORDER BY rating DESC) as rn FROM games) t WHERE rn <= 5;", "generated_sql": "SELECT\n    game_id,\n    name,\n    genre,\n    rating\nFROM\n    games\nORDER BY\n    rating DESC\nFETCH FIRST 5 ROWS ONLY;", "raw_model_output": "SELECT\n    game_id,\n    name,\n    genre,\n    rating\nFROM\n    games\nORDER BY\n    rating DESC\nFETCH FIRST 5 ROWS ONLY;", "latency_sec": 2.763740062713623, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 103, "prompt_eval_sec": null, "tokens_completion": 118, "completion_eval_sec": null, "tokens_total": 221, "tokens_per_sec": 79.96410479464829, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in selected columns and result structure. The Reference SQL returns only 'name', 'rating', and 'rn' columns, while the Generated SQL returns all columns (game_id, name, genre, rating). Additionally, the Reference SQL uses ROW_NUMBER() for ranking whereas the Generated SQL uses FETCH FIRST 5 ROWS ONLY, which could behave differently with tied ratings but the column mismatch makes them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query only returns 'name', 'rating', and 'rn' columns, while the generated query returns all columns (game_id, name, genre, rating). The generated query uses a more efficient and standard approach with FETCH FIRST 5 ROWS ONLY, which directly achieves the goal of retrieving the top 5 games by rating. The reference query's use of ROW_NUMBER() is unnecessarily complex for this simple requirement and would produce different column output. Both queries correctly order by rating DESC, but the generated query better fulfills the business intent by returning complete game records.", "overall_assessment": "differently_correct"}}
{"example_id": 778, "sql_complexity": "single join", "prompt": "What is the maximum property price in wheelchair-accessible neighborhoods in Singapore?", "context": "CREATE TABLE Singapore_Neighborhoods (Neighborhood_Name TEXT, Wheelchair_Accessibility BOOLEAN); INSERT INTO Singapore_Neighborhoods (Neighborhood_Name, Wheelchair_Accessibility) VALUES ('Orchard', true), ('Marina Bay', true), ('Chinatown', false), ('Little India', false), ('Bugis', true); CREATE TABLE Singapore_Properties (Neighborhood_Name TEXT, Property_Price INTEGER); INSERT INTO Singapore_Properties (Neighborhood_Name, Property_Price) VALUES ('Orchard', 2000000), ('Marina Bay', 3000000), ('Chinatown', 1500000), ('Little India', 1200000), ('Bugis', 1800000);", "reference_sql": "SELECT MAX(Singapore_Properties.Property_Price) FROM Singapore_Properties INNER JOIN Singapore_Neighborhoods ON Singapore_Properties.Neighborhood_Name = Singapore_Neighborhoods.Neighborhood_Name WHERE Singapore_Neighborhoods.Wheelchair_Accessibility = true;", "generated_sql": "SELECT MAX(p.Property_Price) AS Max_Property_Price\nFROM Singapore_Properties AS p\nJOIN Singapore_Neighborhoods AS n\n  ON p.Neighborhood_Name = n.Neighborhood_Name\nWHERE n.Wheelchair_Accessibility = TRUE;", "raw_model_output": "SELECT MAX(p.Property_Price) AS Max_Property_Price\nFROM Singapore_Properties AS p\nJOIN Singapore_Neighborhoods AS n\n  ON p.Neighborhood_Name = n.Neighborhood_Name\nWHERE n.Wheelchair_Accessibility = TRUE;", "latency_sec": 4.8920509815216064, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 225, "prompt_eval_sec": null, "tokens_completion": 199, "completion_eval_sec": null, "tokens_total": 424, "tokens_per_sec": 86.6712145072782, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the maximum property price from Singapore_Properties joined with Singapore_Neighborhoods on Neighborhood_Name, filtered by Wheelchair_Accessibility = true. The generated query uses table aliases (p and n) and an alias for the MAX result, but these are syntactic variations that do not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly compute the maximum property price in wheelchair-accessible neighborhoods by joining the two tables on Neighborhood_Name and filtering where Wheelchair_Accessibility = true. The reference query uses explicit table names while the generated query uses aliases, but this does not affect the result. Both achieve the same logical execution plan and would return the same value (3000000 from Marina Bay). The business intent is fully addressed as both queries directly answer the question about maximum prices in accessible areas.", "overall_assessment": "correct"}}
{"example_id": 3859, "sql_complexity": "aggregation", "prompt": "What is the total number of mental health parity violations by month and year?", "context": "CREATE TABLE mental_health_parity_reports (report_id INT, violation_date DATE); INSERT INTO mental_health_parity_reports (report_id, violation_date) VALUES (1, '2022-01-01'), (2, '2022-02-15'), (3, '2022-03-05'), (4, '2022-04-20'), (5, '2021-06-12'), (6, '2021-07-28');", "reference_sql": "SELECT EXTRACT(MONTH FROM violation_date) AS month, EXTRACT(YEAR FROM violation_date) AS year, COUNT(*) FROM mental_health_parity_reports GROUP BY month, year;", "generated_sql": "SELECT\n    EXTRACT(YEAR  FROM violation_date) AS violation_year,\n    EXTRACT(MONTH FROM violation_date) AS violation_month,\n    COUNT(*)                                   AS total_violations\nFROM mental_health_parity_reports\nGROUP BY\n    EXTRACT(YEAR  FROM violation_date),\n    EXTRACT(MONTH FROM violation_date)\nORDER BY\n    violation_year,\n    violation_month;", "raw_model_output": "```sql\nSELECT\n    EXTRACT(YEAR  FROM violation_date) AS violation_year,\n    EXTRACT(MONTH FROM violation_date) AS violation_month,\n    COUNT(*)                                   AS total_violations\nFROM mental_health_parity_reports\nGROUP BY\n    EXTRACT(YEAR  FROM violation_date),\n    EXTRACT(MONTH FROM violation_date)\nORDER BY\n    violation_year,\n    violation_month;\n```", "latency_sec": 6.1217591762542725, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 178, "prompt_eval_sec": null, "tokens_completion": 296, "completion_eval_sec": null, "tokens_total": 474, "tokens_per_sec": 77.42872373003522, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries group by year and month extracted from violation_date, count violations, and produce the same data. The differences are in column aliases (month/year vs violation_month/violation_year) and the order of columns, but these do not affect the semantic result. The Generated SQL adds an ORDER BY, but the Reference SQL's result order is not guaranteed. The core aggregation and grouping logic are identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly aggregate violations by year and month. The Reference SQL uses column aliases 'month' and 'year', while the Generated SQL uses 'violation_year' and 'violation_month' which are more descriptive. The Generated SQL also includes an ORDER BY clause, which ensures results are sorted chronologically (a practical enhancement for readability). The GROUP BY logic is identical in both queries, and the COUNT(*) is equivalent. The only difference is column naming and ordering, which doesn't affect the core business intent. The Generated SQL's clarity and ordering make it slightly superior for practical use.", "overall_assessment": "correct"}}
{"example_id": 3551, "sql_complexity": "multiple_joins", "prompt": "List all artists who have performed in New York and Chicago, along with their highest-earning performance.", "context": "CREATE TABLE artist_events (artist_id INT, event_id INT, earnings DECIMAL(5,2)); CREATE TABLE artists (id INT, name VARCHAR(50)); CREATE TABLE events (id INT, city VARCHAR(20));", "reference_sql": "SELECT artists.name, MAX(artist_events.earnings) FROM artists INNER JOIN artist_events ON artists.id = artist_events.artist_id INNER JOIN events ON artist_events.event_id = events.id WHERE city IN ('New York', 'Chicago') GROUP BY artists.name;", "generated_sql": "SELECT\n    a.name,\n    MAX(ae.earnings) AS highest_earning\nFROM\n    artists       AS a\n    JOIN artist_events AS ae ON ae.artist_id = a.id\n    JOIN events        AS e  ON e.id = ae.event_id\nGROUP BY\n    a.id, a.name\nHAVING\n    SUM(CASE WHEN e.city = 'New York' THEN 1 ELSE 0 END) > 0\nAND SUM(CASE WHEN e.city = 'Chicago' THEN 1 ELSE 0 END) > 0;", "raw_model_output": "SELECT\n    a.name,\n    MAX(ae.earnings) AS highest_earning\nFROM\n    artists       AS a\n    JOIN artist_events AS ae ON ae.artist_id = a.id\n    JOIN events        AS e  ON e.id = ae.event_id\nGROUP BY\n    a.id, a.name\nHAVING\n    SUM(CASE WHEN e.city = 'New York' THEN 1 ELSE 0 END) > 0\nAND SUM(CASE WHEN e.city = 'Chicago' THEN 1 ELSE 0 END) > 0;", "latency_sec": 7.433298349380493, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 131, "prompt_eval_sec": null, "tokens_completion": 519, "completion_eval_sec": null, "tokens_total": 650, "tokens_per_sec": 87.44435773308794, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in filtering logic. The reference query includes artists with events in either 'New York' or 'Chicago' (WHERE city IN ...), while the generated query requires artists to have events in *both* cities (HAVING SUM(...) > 0 for both). Additionally, the generated query groups by a.id and a.name (ensuring unique artists) whereas the reference groups only by name, which could combine artists with identical names but different IDs.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is technically correct but fails to ensure artists have performed in *both* New York and Chicago. It only filters events to those cities, allowing artists with performances in either city. The Generated SQL correctly uses HAVING with conditional aggregation to enforce presence in *both* cities. While both calculate MAX(earnings), the Generated SQL's GROUP BY on a.id/a.name is more robust than the Reference's GROUP BY on name alone. The Generated SQL better fulfills the business intent of identifying artists with performances in both cities.", "overall_assessment": "differently_correct"}}
{"example_id": 5168, "sql_complexity": "aggregation", "prompt": "Get the number of renewable energy projects in Australia for each project type.", "context": "CREATE TABLE renewable_projects (id INT PRIMARY KEY, project_name VARCHAR(255), project_location VARCHAR(255), project_type VARCHAR(255), capacity_mw FLOAT);", "reference_sql": "SELECT project_type, COUNT(*) FROM renewable_projects WHERE project_location = 'Australia' GROUP BY project_type;", "generated_sql": "SELECT\n    project_type,\n    COUNT(*) AS project_count\nFROM renewable_projects\nWHERE project_location = 'Australia'\nGROUP BY project_type;", "raw_model_output": "```sql\nSELECT\n    project_type,\n    COUNT(*) AS project_count\nFROM renewable_projects\nWHERE project_location = 'Australia'\nGROUP BY project_type;\n```", "latency_sec": 3.079155206680298, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 113, "prompt_eval_sec": null, "tokens_completion": 116, "completion_eval_sec": null, "tokens_total": 229, "tokens_per_sec": 74.37104810539567, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (project_type and count of projects) from the same table with the same WHERE condition. The generated query adds an alias (project_count) for the count, but this does not affect the semantic result. The GROUP BY clause is identical in both queries.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically correct and produce identical results. The reference query omits an explicit column alias, while the generated query uses 'project_count' to explicitly name the aggregated column. This makes the generated query more readable and semantically precise, though both satisfy the business requirement of counting Australian renewable projects by type. The generated query's explicit alias improves clarity without altering functionality.", "overall_assessment": "correct"}}
{"example_id": 4916, "sql_complexity": "aggregation", "prompt": "What is the maximum revenue generated from selling Yttrium in India in the past 3 years?", "context": "CREATE TABLE Yttrium_Sales (id INT PRIMARY KEY, year INT, country VARCHAR(20), quantity INT, price PER_KG); INSERT INTO Yttrium_Sales (id, year, country, quantity, price) VALUES (1, 2019, 'India', 120, 40), (2, 2020, 'India', 130, 45), (3, 2021, 'India', 140, 50), (4, 2019, 'China', 150, 35), (5, 2020, 'China', 160, 40), (6, 2021, 'China', 170, 45);", "reference_sql": "SELECT MAX(quantity * price) FROM Yttrium_Sales WHERE country = 'India' GROUP BY year ORDER BY year DESC LIMIT 3;", "generated_sql": "SELECT MAX(quantity * price) AS max_revenue\nFROM Yttrium_Sales\nWHERE country = 'India'\n  AND year >= (SELECT MAX(year) FROM Yttrium_Sales WHERE country = 'India') - 2;", "raw_model_output": "SELECT MAX(quantity * price) AS max_revenue\nFROM Yttrium_Sales\nWHERE country = 'India'\n  AND year >= (SELECT MAX(year) FROM Yttrium_Sales WHERE country = 'India') - 2;", "latency_sec": 10.42472791671753, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 233, "prompt_eval_sec": null, "tokens_completion": 454, "completion_eval_sec": null, "tokens_total": 687, "tokens_per_sec": 65.90100053338544, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns the maximum revenue per year for India, grouped by year and ordered descending (3 rows). The Generated SQL calculates a single maximum revenue value for India's sales in the last 3 years (2019-2021) without grouping. They differ in output structure (multiple rows vs single value) and logic (per-year maxima vs overall max in a time window).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL groups by year and returns three separate maximum values (one per year), which does not directly answer the question for the overall maximum revenue across the past three years. The Generated SQL correctly filters for the last three years (using a subquery to determine the latest year) and calculates the absolute maximum revenue across those years. While both queries are syntactically valid, the Generated SQL better aligns with the business intent of finding the single highest revenue value in the specified timeframe. The Reference SQL's grouping and ordering may lead to misinterpretation of results.", "overall_assessment": "differently_correct"}}
{"example_id": 812, "sql_complexity": "multiple_joins", "prompt": "What is the average salary of 'engineer' workers in each factory?", "context": "CREATE TABLE factories (factory_id INT, factory_name VARCHAR(20)); INSERT INTO factories VALUES (1, 'Factory X'), (2, 'Factory Y'), (3, 'Factory Z'); CREATE TABLE roles (role_id INT, role_name VARCHAR(20)); INSERT INTO roles VALUES (1, 'engineer'), (2, 'manager'), (3, 'assistant'); CREATE TABLE workers (worker_id INT, factory_id INT, role_id INT, salary DECIMAL(5,2)); INSERT INTO workers VALUES (1, 1, 1, 50000.00), (2, 1, 2, 70000.00), (3, 2, 1, 55000.00), (4, 2, 3, 40000.00), (5, 3, 1, 60000.00);", "reference_sql": "SELECT f.factory_name, AVG(salary) FROM workers w INNER JOIN factories f ON w.factory_id = f.factory_id INNER JOIN roles r ON w.role_id = r.role_id WHERE r.role_name = 'engineer' GROUP BY f.factory_name;", "generated_sql": "SELECT\n    f.factory_id,\n    f.factory_name,\n    AVG(w.salary) AS average_salary\nFROM factories AS f\nJOIN workers   AS w ON w.factory_id = f.factory_id\nJOIN roles     AS r ON r.role_id    = w.role_id\nWHERE r.role_name = 'engineer'\nGROUP BY f.factory_id, f.factory_name;", "raw_model_output": "SELECT\n    f.factory_id,\n    f.factory_name,\n    AVG(w.salary) AS average_salary\nFROM factories AS f\nJOIN workers   AS w ON w.factory_id = f.factory_id\nJOIN roles     AS r ON r.role_id    = w.role_id\nWHERE r.role_name = 'engineer'\nGROUP BY f.factory_id, f.factory_name;", "latency_sec": 4.5606489181518555, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 260, "prompt_eval_sec": null, "tokens_completion": 221, "completion_eval_sec": null, "tokens_total": 481, "tokens_per_sec": 105.46744742520525, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in selected columns (Reference includes only factory_name, Generated includes factory_id and factory_name) and grouping strategy (Reference groups by factory_name, Generated groups by both factory_id and factory_name). While the data might overlap, the result structures differ, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the average salary of 'engineer' workers per factory. The reference query groups by factory_name, which works here because factory names are unique. The generated query groups by both factory_id and factory_name, which is more robust in general cases where factory names might not be unique. However, since the dataset ensures unique factory names, both produce identical results. The reference query directly answers the question by returning factory names, while the generated query includes factory_id as well. Both are semantically equivalent in this context.", "overall_assessment": "correct"}}
{"example_id": 5784, "sql_complexity": "set operations", "prompt": "List the number of users who have completed a workout of a specific type (e.g. Running) and have a membership status of 'Active'.", "context": "CREATE TABLE workouts (id INT, user_id INT, workout_type VARCHAR(20)); CREATE TABLE members (id INT, name VARCHAR(50), membership_status VARCHAR(20), state VARCHAR(20)); INSERT INTO workouts (id, user_id, workout_type) VALUES (1, 1, 'Running'), (2, 1, 'Cycling'), (3, 2, 'Running'), (4, 3, 'Cycling'), (5, 3, 'Swimming'), (6, 4, 'Running'), (7, 4, 'Swimming'); INSERT INTO members (id, name, membership_status, state) VALUES (1, 'John Doe', 'Active', 'Texas'), (2, 'Jane Doe', 'Inactive', 'California'), (3, 'Bob Smith', 'Active', 'Texas'), (4, 'Alice Johnson', 'Active', 'California');", "reference_sql": "SELECT COUNT(*) FROM (SELECT user_id FROM workouts WHERE workout_type = 'Running' INTERSECT SELECT id FROM members WHERE membership_status = 'Active') AS user_set;", "generated_sql": "SELECT COUNT(DISTINCT m.id) AS active_users_with_running\nFROM members  AS m\nJOIN workouts AS w\n  ON w.user_id = m.id\nWHERE m.membership_status = 'Active'\n  AND w.workout_type = 'Running';", "raw_model_output": "```sql\nSELECT COUNT(DISTINCT m.id) AS active_users_with_running\nFROM members  AS m\nJOIN workouts AS w\n  ON w.user_id = m.id\nWHERE m.membership_status = 'Active'\n  AND w.workout_type = 'Running';\n```", "latency_sec": 3.2852208614349365, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 279, "prompt_eval_sec": null, "tokens_completion": 204, "completion_eval_sec": null, "tokens_total": 483, "tokens_per_sec": 147.02207868880774, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of active members who have at least one 'Running' workout. The Reference SQL uses INTERSECT to find common user_ids between active members and 'Running' workouts, while the Generated SQL joins the tables and counts distinct active members with 'Running' workouts. Both approaches yield the same result by ensuring each active member is counted once if they have at least one 'Running' workout.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count users with 'Active' membership who completed at least one 'Running' workout. The Reference SQL uses INTERSECT to find overlapping user_ids between two subqueries, while the Generated SQL uses a JOIN with COUNT(DISTINCT) to achieve the same result. The Generated SQL is more efficient as it avoids the overhead of INTERSECT and explicitly handles duplicates through DISTINCT. Both satisfy the business intent, but the Generated SQL is more readable and performant.", "overall_assessment": "correct"}}
{"example_id": 3038, "sql_complexity": "subqueries", "prompt": "What is the total assets of clients who have invested in mutual funds but not in stocks?", "context": "CREATE TABLE clients (client_id INT, name TEXT, age INT, gender TEXT, total_assets DECIMAL(10,2)); INSERT INTO clients VALUES (1, 'John Doe', 35, 'Male', 250000.00), (2, 'Jane Smith', 45, 'Female', 500000.00); CREATE TABLE investments (client_id INT, investment_type TEXT); INSERT INTO investments VALUES (1, 'Stocks'), (1, 'Bonds'), (2, 'Stocks'), (3, 'Mutual Funds');", "reference_sql": "SELECT c.total_assets FROM clients c INNER JOIN investments i ON c.client_id = i.client_id WHERE i.investment_type = 'Mutual Funds' AND c.client_id NOT IN (SELECT client_id FROM investments WHERE investment_type = 'Stocks');", "generated_sql": "SELECT SUM(c.total_assets) AS total_assets\nFROM clients c\nWHERE c.client_id IN (\n    SELECT client_id\n    FROM investments\n    GROUP BY client_id\n    HAVING COUNT(CASE WHEN investment_type = 'Mutual Funds' THEN 1 END) > 0\n       AND COUNT(CASE WHEN investment_type = 'Stocks'      THEN 1 END) = 0\n);", "raw_model_output": "```sql\nSELECT SUM(c.total_assets) AS total_assets\nFROM clients c\nWHERE c.client_id IN (\n    SELECT client_id\n    FROM investments\n    GROUP BY client_id\n    HAVING COUNT(CASE WHEN investment_type = 'Mutual Funds' THEN 1 END) > 0\n       AND COUNT(CASE WHEN investment_type = 'Stocks'      THEN 1 END) = 0\n);\n```", "latency_sec": 7.23170804977417, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 195, "prompt_eval_sec": null, "tokens_completion": 489, "completion_eval_sec": null, "tokens_total": 684, "tokens_per_sec": 94.58346427872732, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The reference query returns individual client total_assets values for clients with 'Mutual Funds' investments and no 'Stocks' investments, while the generated query aggregates these values into a single SUM. The logical conditions are similar but the output structure differs (row-level vs. aggregated result).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query is technically incorrect because it selects individual client assets without aggregating them, while the generated query correctly uses SUM() to calculate total assets. Both queries identify clients with mutual funds and no stocks, but the generated query properly addresses the 'total assets' requirement. The reference query's NOT IN subquery may also have edge case issues (e.g., NULL values), whereas the generated query's GROUP BY/HAVING approach is more robust. The generated query better fulfills the business intent of calculating a single total value.", "overall_assessment": "differently_correct"}}
{"example_id": 1078, "sql_complexity": "basic SQL", "prompt": "What is the maximum and minimum temperature difference between any two Arctic research stations?", "context": "CREATE TABLE arctic_stations (id INT, name TEXT, location TEXT, temperature DECIMAL(5,2)); INSERT INTO arctic_stations (id, name, location, temperature) VALUES (1, 'Station A', 'Greenland', 2.3), (2, 'Station B', 'Canada', -5.2);", "reference_sql": "SELECT a.name as station1, b.name as station2, MAX(ABS(a.temperature - b.temperature)) as temp_diff FROM arctic_stations a, arctic_stations b ORDER BY temp_diff DESC LIMIT 1", "generated_sql": "SELECT \n    MAX(diff) AS max_difference,\n    MIN(diff) AS min_difference\nFROM (\n    SELECT \n        ABS(s1.temperature - s2.temperature) AS diff\n    FROM arctic_stations s1\n    JOIN arctic_stations s2\n      ON s1.id < s2.id            -- consider each unique pair once\n) AS pair_differences;", "raw_model_output": "```sql\nSELECT \n    MAX(diff) AS max_difference,\n    MIN(diff) AS min_difference\nFROM (\n    SELECT \n        ABS(s1.temperature - s2.temperature) AS diff\n    FROM arctic_stations s1\n    JOIN arctic_stations s2\n      ON s1.id < s2.id            -- consider each unique pair once\n) AS pair_differences;\n```", "latency_sec": 7.686383962631226, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 152, "prompt_eval_sec": null, "tokens_completion": 293, "completion_eval_sec": null, "tokens_total": 445, "tokens_per_sec": 57.894583742296724, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query returns the single pair of stations with the maximum temperature difference (including station names) and orders by descending difference. The generated query calculates both maximum and minimum differences across all unique station pairs but does not include station names. Additionally, the generated query's subquery uses s1.id < s2.id to avoid duplicate pairs, while the reference query uses a Cartesian product (a, b) which would include duplicates. The output structures and results differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query only returns the maximum temperature difference (not the minimum) and has a logical flaw: it would return multiple rows (one per station pair) with the same MAX(ABS(...)) value, not just the single maximum. The generated query correctly calculates both max and min differences by first generating all unique station pairs (via s1.id < s2.id) and then aggregating the absolute differences. The reference query also uses outdated implicit join syntax instead of explicit JOIN, and its ORDER BY/LIMIT 1 approach would not reliably return the true maximum difference due to potential ties. The generated query is more efficient, semantically complete, and technically sound.", "overall_assessment": "incorrect"}}
{"example_id": 5015, "sql_complexity": "basic SQL", "prompt": "Calculate the average recycling rate", "context": "CREATE TABLE recycling_rates (id INT PRIMARY KEY, location VARCHAR(50), rate FLOAT);", "reference_sql": "SELECT AVG(rate) FROM recycling_rates;", "generated_sql": "SELECT AVG(rate) AS average_recycling_rate\nFROM recycling_rates;", "raw_model_output": "```sql\nSELECT AVG(rate) AS average_recycling_rate\nFROM recycling_rates;\n```", "latency_sec": 1.5227792263031006, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 90, "prompt_eval_sec": null, "tokens_completion": 37, "completion_eval_sec": null, "tokens_total": 127, "tokens_per_sec": 83.40013956476272, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average of the 'rate' column from the recycling_rates table. The generated query adds an alias ('average_recycling_rate') to the result, but this does not affect the computed value. The semantic result (the average value) remains identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the average recycling rate using AVG(rate). The reference query returns the result without a column alias, while the generated query adds an explicit alias 'average_recycling_rate'. This makes the generated query more readable and self-documenting, which better supports business reporting needs. The technical equivalence holds because the alias doesn't affect the calculation. Both fulfill the intent of calculating the average, but the generated version provides clearer output for end-users.", "overall_assessment": "correct"}}
{"example_id": 1533, "sql_complexity": "subqueries", "prompt": "Which programs had the highest volunteer participation rate in the last quarter?", "context": "CREATE TABLE Programs (ProgramID INT, ProgramName TEXT, Budget DECIMAL(10,2), NumVolunteers INT); CREATE TABLE VolunteerEvents (EventID INT, ProgramID INT, EventDate DATE, NumVolunteers INT);", "reference_sql": "SELECT p.ProgramName, COUNT(v.EventID) / (SELECT COUNT(*) FROM VolunteerEvents WHERE EventDate >= DATEADD(quarter, -1, GETDATE())) * 100.0 AS VolunteerParticipationRate FROM Programs p INNER JOIN VolunteerEvents v ON p.ProgramID = v.ProgramID WHERE v.EventDate >= DATEADD(quarter, -1, GETDATE()) GROUP BY p.ProgramName ORDER BY VolunteerParticipationRate DESC;", "generated_sql": "WITH event_totals AS (\n    /* Total volunteers who actually served in each program\u2019s events\n       during the last quarter (the most-recent 3-month period) */\n    SELECT\n        ProgramID,\n        SUM(NumVolunteers) AS event_volunteers\n    FROM VolunteerEvents\n    WHERE EventDate >= (CURRENT_DATE - INTERVAL '3' MONTH)\n      AND EventDate <  CURRENT_DATE\n    GROUP BY ProgramID\n),\nrates AS (\n    /* Participation rate = volunteers who served \u00f7 volunteers available */\n    SELECT\n        p.ProgramID,\n        p.ProgramName,\n        CAST(et.event_volunteers AS DECIMAL(18,4)) / NULLIF(p.NumVolunteers,0) \n            AS participation_rate\n    FROM Programs p\n    JOIN event_totals et\n      ON p.ProgramID = et.ProgramID\n)\n/* Return the program(s) with the highest participation rate */\nSELECT\n    ProgramID,\n    ProgramName,\n    participation_rate\nFROM rates\nWHERE participation_rate = (SELECT MAX(participation_rate) FROM rates);", "raw_model_output": "```sql\nWITH event_totals AS (\n    /* Total volunteers who actually served in each program\u2019s events\n       during the last quarter (the most-recent 3-month period) */\n    SELECT\n        ProgramID,\n        SUM(NumVolunteers) AS event_volunteers\n    FROM VolunteerEvents\n    WHERE EventDate >= (CURRENT_DATE - INTERVAL '3' MONTH)\n      AND EventDate <  CURRENT_DATE\n    GROUP BY ProgramID\n),\nrates AS (\n    /* Participation rate = volunteers who served \u00f7 volunteers available */\n    SELECT\n        p.ProgramID,\n        p.ProgramName,\n        CAST(et.event_volunteers AS DECIMAL(18,4)) / NULLIF(p.NumVolunteers,0) \n            AS participation_rate\n    FROM Programs p\n    JOIN event_totals et\n      ON p.ProgramID = et.ProgramID\n)\n/* Return the program(s) with the highest participation rate */\nSELECT\n    ProgramID,\n    ProgramName,\n    participation_rate\nFROM rates\nWHERE participation_rate = (SELECT MAX(participation_rate) FROM rates);\n```", "latency_sec": 17.06413722038269, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 126, "prompt_eval_sec": null, "tokens_completion": 1457, "completion_eval_sec": null, "tokens_total": 1583, "tokens_per_sec": 92.76765532037246, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries calculate different metrics. The reference query computes the percentage of events (count) per program relative to total events in the last quarter, while the generated query calculates the ratio of volunteers served (sum) to program-specific volunteer capacity. Additionally, the reference uses COUNT(v.EventID) / (subquery count) * 100, whereas the generated uses SUM(NumVolunteers) / NumVolunteers. The output structures and calculation logic differ fundamentally.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries differ fundamentally in their approach to calculating participation rate. The reference query incorrectly uses COUNT(v.EventID) / total_events (event count) while the generated query properly uses SUM(NumVolunteers) (volunteer count) divided by Program.NumVolunteers. The generated query also correctly handles edge cases (NULLIF) and explicitly defines the last quarter as 3 months ago. The reference query's logic misrepresents 'participation rate' as event frequency rather than volunteer volume, failing to address the actual business intent of measuring volunteer engagement. The generated query's CTE structure and explicit time window also make it more robust and readable.", "overall_assessment": "differently_correct"}}
{"example_id": 4021, "sql_complexity": "subqueries", "prompt": "What is the percentage of energy efficiency improvement, per sector, compared to 2015 levels?", "context": "CREATE TABLE energy_efficiency (id INT, sector VARCHAR(50), year INT, efficiency FLOAT); INSERT INTO energy_efficiency (id, sector, year, efficiency) VALUES (1, 'Industry', 2015, 100.0), (2, 'Industry', 2020, 105.0), (3, 'Residential', 2015, 100.0), (4, 'Residential', 2020, 103.0);", "reference_sql": "SELECT sector, (SUM(efficiency) / (SELECT SUM(efficiency) FROM energy_efficiency WHERE year = 2015 AND sector = e.sector) * 100.0) - 100.0 AS improvement FROM energy_efficiency e WHERE year = 2020 GROUP BY sector;", "generated_sql": "SELECT\n        sector,\n        efficiency AS baseline_eff\n    FROM energy_efficiency\n    WHERE year = 2015\n),\nlatest AS (\n    SELECT\n        e1.sector,\n        e1.efficiency AS latest_eff\n    FROM energy_efficiency e1\n    WHERE e1.year = (\n        SELECT MAX(e2.year)\n        FROM energy_efficiency e2\n        WHERE e2.sector = e1.sector\n    )\n)\nSELECT\n    b.sector,\n    ((l.latest_eff - b.baseline_eff) / b.baseline_eff) * 100 AS efficiency_improvement_pct\nFROM baseline b\nJOIN latest  l ON l.sector = b.sector;", "raw_model_output": "-- Percentage improvement in energy efficiency relative to 2015 (latest year available for each sector)\nWITH baseline AS (\n    SELECT\n        sector,\n        efficiency AS baseline_eff\n    FROM energy_efficiency\n    WHERE year = 2015\n),\nlatest AS (\n    SELECT\n        e1.sector,\n        e1.efficiency AS latest_eff\n    FROM energy_efficiency e1\n    WHERE e1.year = (\n        SELECT MAX(e2.year)\n        FROM energy_efficiency e2\n        WHERE e2.sector = e1.sector\n    )\n)\nSELECT\n    b.sector,\n    ((l.latest_eff - b.baseline_eff) / b.baseline_eff) * 100 AS efficiency_improvement_pct\nFROM baseline b\nJOIN latest  l ON l.sector = b.sector;", "latency_sec": 21.410383939743042, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 180, "prompt_eval_sec": null, "tokens_completion": 890, "completion_eval_sec": null, "tokens_total": 1070, "tokens_per_sec": 49.97575022528259, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL calculates the percentage improvement by summing efficiencies for 2020 and comparing to 2015 sums, while the Generated SQL uses individual latest-year efficiency values (not sums) and may return multiple rows per sector if there are multiple entries in the latest year. Additionally, the Generated SQL's approach could produce different results when there are multiple entries in the latest year, whereas the Reference SQL aggregates all 2020 entries.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The Reference SQL assumes the latest year is 2020 (hardcoded) and uses SUM(efficiency) which is incorrect for single-row data. The Generated SQL dynamically finds the latest year per sector and calculates percentage change correctly. While both produce same results for the sample data, the Generated SQL handles edge cases (e.g., multiple entries in latest year, non-2020 latest years) better. The Reference SQL fails if the latest year isn't 2020 or if multiple entries exist in a year. Both fulfill the business intent, but the Generated SQL is more robust and accurate.", "overall_assessment": "differently_correct"}}
{"example_id": 1551, "sql_complexity": "single join", "prompt": "How many unique donors made donations in the healthcare industry in Q3 2022?", "context": "CREATE TABLE donations (id INT, donor_id INT, amount FLOAT, donation_date DATE); INSERT INTO donations (id, donor_id, amount, donation_date) VALUES (1, 7, 100, '2022-07-01'); INSERT INTO donations (id, donor_id, amount, donation_date) VALUES (2, 8, 200, '2022-09-15'); INSERT INTO donors (id, name, industry, first_donation_date DATE) VALUES (7, 'Charlie Davis', 'Healthcare', '2022-07-01'); INSERT INTO donors (id, name, industry, first_donation_date DATE) VALUES (8, 'Dana Wilson', 'Healthcare', '2022-09-15');", "reference_sql": "SELECT COUNT(DISTINCT donor_id) FROM donations d JOIN donors don ON d.donor_id = don.id WHERE industry = 'Healthcare' AND donation_date BETWEEN '2022-07-01' AND '2022-09-30';", "generated_sql": "SELECT COUNT(DISTINCT d.donor_id) AS unique_healthcare_donors_q3_2022\nFROM donations AS d\nJOIN donors    AS n ON n.id = d.donor_id\nWHERE n.industry = 'Healthcare'\n  AND d.donation_date >= DATE '2022-07-01'\n  AND d.donation_date <  DATE '2022-10-01';", "raw_model_output": "```sql\nSELECT COUNT(DISTINCT d.donor_id) AS unique_healthcare_donors_q3_2022\nFROM donations AS d\nJOIN donors    AS n ON n.id = d.donor_id\nWHERE n.industry = 'Healthcare'\n  AND d.donation_date >= DATE '2022-07-01'\n  AND d.donation_date <  DATE '2022-10-01';\n```", "latency_sec": 4.412899017333984, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 235, "prompt_eval_sec": null, "tokens_completion": 298, "completion_eval_sec": null, "tokens_total": 533, "tokens_per_sec": 120.78227892964735, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count distinct donor_ids from donations joined with donors where industry is Healthcare and donation dates fall in Q3 2022. The date range comparison (BETWEEN '2022-07-01' AND '2022-09-30' vs >= '2022-07-01' and < '2022-10-01') is functionally equivalent. The join aliases and column references are semantically identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count unique healthcare donors with donations in Q3 2022. The reference uses BETWEEN '2022-07-01' AND '2022-09-30' while the generated uses >= '2022-07-01' and < '2022-10-01'. These date ranges are functionally equivalent for DATE-typed columns, as both capture the full Q3 period. The generated query's explicit date boundary (using < '2022-10-01') is slightly more robust against time components in datetime values. Both use COUNT(DISTINCT) with proper JOIN logic, but the generated query includes a column alias for clarity. The reference query's syntax is correct but less precise in date handling.", "overall_assessment": "correct"}}
{"example_id": 2592, "sql_complexity": "window functions", "prompt": "What is the third highest account balance for Shariah-compliant finance customers?", "context": "CREATE TABLE shariah_compliant_finance(customer_id INT, account_balance DECIMAL(10, 2)); INSERT INTO shariah_compliant_finance VALUES (1, 5000), (2, 7000), (3, 6000), (4, 8000), (5, 9000);", "reference_sql": "SELECT account_balance FROM (SELECT account_balance, RANK() OVER (ORDER BY account_balance DESC) as rn FROM shariah_compliant_finance) t WHERE rn = 3;", "generated_sql": "SELECT account_balance\nFROM (\n    SELECT \n        account_balance,\n        DENSE_RANK() OVER (ORDER BY account_balance DESC) AS rnk\n    FROM shariah_compliant_finance\n) AS ranked_balances\nWHERE rnk = 3;", "raw_model_output": "```sql\nSELECT account_balance\nFROM (\n    SELECT \n        account_balance,\n        DENSE_RANK() OVER (ORDER BY account_balance DESC) AS rnk\n    FROM shariah_compliant_finance\n) AS ranked_balances\nWHERE rnk = 3;\n```", "latency_sec": 4.750630140304565, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 150, "prompt_eval_sec": null, "tokens_completion": 269, "completion_eval_sec": null, "tokens_total": 419, "tokens_per_sec": 88.19882576106792, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries use different window functions: RANK() vs DENSE_RANK(). While both assign ranks, RANK() leaves gaps when there are ties, whereas DENSE_RANK() does not. In the given data, all account_balances are unique, so both functions would produce the same result here. However, semantically, they are not equivalent because their behavior differs when duplicates exist. The reference query uses RANK() and the generated query uses DENSE_RANK(), making them non-equivalent in general cases.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly retrieve the third highest account balance in this specific dataset. The reference query uses RANK() which assigns unique ranks even with duplicates, while the generated query uses DENSE_RANK() which also assigns unique ranks but avoids gaps in ranking. However, since the dataset contains unique account balances, both approaches yield the same result (7000). The business intent of finding the third highest balance is fulfilled by both. The superiority is equal in this context, but DENSE_RANK() might be more appropriate for general cases with potential duplicates.", "overall_assessment": "correct"}}
{"example_id": 3795, "sql_complexity": "single join", "prompt": "What is the total quantity of unsold garments for each manufacturer based in 'Italy' or 'Spain'?", "context": "CREATE TABLE manufacturers (id INT PRIMARY KEY, name VARCHAR(255), country VARCHAR(255)); CREATE TABLE garments (id INT PRIMARY KEY, manufacturer_id INT, quantity_manufactured INT, quantity_sold INT);", "reference_sql": "SELECT m.name, SUM(g.quantity_manufactured - g.quantity_sold) as total_unsold_quantity FROM manufacturers m JOIN garments g ON m.id = g.manufacturer_id WHERE m.country IN ('Italy', 'Spain') GROUP BY m.name;", "generated_sql": "SELECT\n    m.name                               AS manufacturer_name,\n    SUM(g.quantity_manufactured - g.quantity_sold) AS total_unsold\nFROM\n    manufacturers AS m\nJOIN\n    garments AS g\n      ON g.manufacturer_id = m.id\nWHERE\n    m.country IN ('Italy', 'Spain')\nGROUP BY\n    m.name;", "raw_model_output": "```sql\nSELECT\n    m.name                               AS manufacturer_name,\n    SUM(g.quantity_manufactured - g.quantity_sold) AS total_unsold\nFROM\n    manufacturers AS m\nJOIN\n    garments AS g\n      ON g.manufacturer_id = m.id\nWHERE\n    m.country IN ('Italy', 'Spain')\nGROUP BY\n    m.name;\n```", "latency_sec": 5.449804067611694, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 131, "prompt_eval_sec": null, "tokens_completion": 222, "completion_eval_sec": null, "tokens_total": 353, "tokens_per_sec": 64.77297084823412, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between manufacturers and garments on manufacturer_id, filter for countries 'Italy' and 'Spain', and calculate the total unsold quantity as the sum of (quantity_manufactured - quantity_sold) per manufacturer. The only differences are in column aliases (total_unsold_quantity vs. total_unsold) and formatting, which do not affect the semantic result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent as they perform identical operations: joining manufacturers with garments on manufacturer_id, filtering for Italy/Spain, grouping by manufacturer name, and calculating total unsold quantity via SUM(quantity_manufactured - quantity_sold). The differences are purely syntactic (column/table aliases) and do not affect results. Both fulfill the business intent by answering the original question about unsold garments for Italian/Spanish manufacturers. The generated query uses table aliases which improves readability but neither version is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 4138, "sql_complexity": "window functions", "prompt": "How many lifelong learning courses has a student with ID '2' completed, in chronological order?", "context": "CREATE TABLE lifelong_learning (student_id INT, course_id INT, completion_date DATE); INSERT INTO lifelong_learning VALUES (2, 1001, '2015-01-01'), (2, 1002, '2016-01-01');", "reference_sql": "SELECT student_id, course_id, COUNT(course_id) OVER (PARTITION BY student_id ORDER BY completion_date) as completed_courses FROM lifelong_learning WHERE student_id = 2;", "generated_sql": "SELECT COUNT(*) AS courses_completed\nFROM lifelong_learning\nWHERE student_id = 2;", "raw_model_output": "SELECT COUNT(*) AS courses_completed\nFROM lifelong_learning\nWHERE student_id = 2;", "latency_sec": 5.919149875640869, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 137, "prompt_eval_sec": null, "tokens_completion": 421, "completion_eval_sec": null, "tokens_total": 558, "tokens_per_sec": 94.2702941678065, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns multiple rows with an incremental count of completed courses per student, while the Generated SQL returns a single row with the total count of courses. The first query includes course_id and a window function, whereas the second only counts total rows.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query uses a window function to calculate a running total of courses per completion date, returning multiple rows with cumulative counts. The generated query directly counts all courses for student 2 in a single row. While both are technically correct, the original question asks for the total number of completed courses (a single value), which the generated query fulfills. The reference query provides additional chronological detail but doesn't directly answer the quantitative question. The generated query is more efficient and aligns better with the explicit request for a count.", "overall_assessment": "correct"}}
{"example_id": 312, "sql_complexity": "aggregation", "prompt": "List the top 3 most represented ethnicities in movies produced in the USA.", "context": "CREATE TABLE movies (title VARCHAR(255), production_country VARCHAR(64), lead_actor_ethnicity VARCHAR(64));", "reference_sql": "SELECT lead_actor_ethnicity, COUNT(*) AS count FROM movies WHERE production_country = 'USA' GROUP BY lead_actor_ethnicity ORDER BY count DESC LIMIT 3;", "generated_sql": "SELECT\n    lead_actor_ethnicity,\n    COUNT(*) AS movie_count\nFROM\n    movies\nWHERE\n    production_country = 'USA'\nGROUP BY\n    lead_actor_ethnicity\nORDER BY\n    movie_count DESC\nFETCH FIRST 3 ROWS ONLY;", "raw_model_output": "SELECT\n    lead_actor_ethnicity,\n    COUNT(*) AS movie_count\nFROM\n    movies\nWHERE\n    production_country = 'USA'\nGROUP BY\n    lead_actor_ethnicity\nORDER BY\n    movie_count DESC\nFETCH FIRST 3 ROWS ONLY;", "latency_sec": 4.233248233795166, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 105, "prompt_eval_sec": null, "tokens_completion": 201, "completion_eval_sec": null, "tokens_total": 306, "tokens_per_sec": 72.28491765663993, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter movies by production_country = 'USA', group by lead_actor_ethnicity, and order by count in descending order. The difference is syntactic: 'LIMIT 3' (reference) and 'FETCH FIRST 3 ROWS ONLY' (generated) both limit results to 3 rows. Column alias names ('count' vs 'movie_count') do not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly address the business question by grouping movies by lead_actor_ethnicity, counting occurrences, filtering for USA production, and ordering by count to retrieve the top 3. The difference lies in syntax: the reference uses LIMIT 3 (common in PostgreSQL/MySQL) while the generated query uses FETCH FIRST 3 ROWS ONLY (standard SQL per ISO/IEC 9075). Both are valid in their respective contexts and produce identical results when supported. Neither query is more efficient than the other, as both use equivalent logical operations. The choice between them depends on database system compatibility rather than correctness.", "overall_assessment": "correct"}}
{"example_id": 4298, "sql_complexity": "single join", "prompt": "How many users joined the gym in Q1 2023?", "context": "CREATE TABLE memberships (id INT, user_id INT, join_date DATE); INSERT INTO memberships (id, user_id, join_date) VALUES (1, 5, '2023-01-15'), (2, 6, '2023-02-03'), (3, 7, '2023-03-20'), (4, 8, '2022-12-31');", "reference_sql": "SELECT COUNT(*) FROM memberships WHERE join_date BETWEEN '2023-01-01' AND '2023-03-31';", "generated_sql": "SELECT COUNT(*) AS users_joined_q1_2023\nFROM memberships\nWHERE join_date BETWEEN DATE '2023-01-01' AND DATE '2023-03-31';", "raw_model_output": "SELECT COUNT(*) AS users_joined_q1_2023\nFROM memberships\nWHERE join_date BETWEEN DATE '2023-01-01' AND DATE '2023-03-31';", "latency_sec": 2.6481716632843018, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 163, "prompt_eval_sec": null, "tokens_completion": 122, "completion_eval_sec": null, "tokens_total": 285, "tokens_per_sec": 107.62142196119521, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of members with join dates between '2023-01-01' and '2023-03-31' inclusive. The generated query uses DATE literals which are functionally equivalent to the string literals in the reference query. The COUNT(*) aggregation and WHERE clause logic are identical, resulting in the same output.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count users who joined in Q1 2023 by filtering join_date between '2023-01-01' and '2023-03-31'. The reference query uses implicit date conversion, while the generated query explicitly uses DATE '...' for clarity. The generated query adds an alias (users_joined_q1_2023) which improves readability without altering functionality. Both produce identical results, but the generated version is more explicit and self-documenting.", "overall_assessment": "correct"}}
{"example_id": 5211, "sql_complexity": "multiple_joins", "prompt": "What is the average transaction value in the last week, split by product category and customer demographics?", "context": "CREATE TABLE transactions (transaction_id INT, customer_id INT, product_id INT, category_id INT, transaction_date DATE, amount DECIMAL(10,2)); CREATE TABLE customers (customer_id INT, age INT, gender VARCHAR(10), location VARCHAR(255)); CREATE TABLE products (product_id INT, name VARCHAR(255), category_id INT);", "reference_sql": "SELECT c.age, c.gender, p.category_id, AVG(t.amount) as avg_transaction_value FROM transactions t INNER JOIN customers c ON t.customer_id = c.customer_id INNER JOIN products p ON t.product_id = p.product_id WHERE t.transaction_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 WEEK) GROUP BY c.age, c.gender, p.category_id;", "generated_sql": "SELECT\n    p.category_id,          -- Product category\n    c.age,                  -- Customer age\n    c.gender,               -- Customer gender\n    c.location,             -- Customer location\n    AVG(t.amount) AS average_transaction_value\nFROM\n    transactions AS t\nJOIN\n    customers    AS c ON t.customer_id = c.customer_id\nJOIN\n    products     AS p ON t.product_id  = p.product_id\nWHERE\n    t.transaction_date >= CURRENT_DATE - INTERVAL '7' DAY  -- last 7 days\n    AND t.transaction_date <  CURRENT_DATE                 -- up to (but not including) today\nGROUP BY\n    p.category_id,\n    c.age,\n    c.gender,\n    c.location;", "raw_model_output": "```sql\nSELECT\n    p.category_id,          -- Product category\n    c.age,                  -- Customer age\n    c.gender,               -- Customer gender\n    c.location,             -- Customer location\n    AVG(t.amount) AS average_transaction_value\nFROM\n    transactions AS t\nJOIN\n    customers    AS c ON t.customer_id = c.customer_id\nJOIN\n    products     AS p ON t.product_id  = p.product_id\nWHERE\n    t.transaction_date >= CURRENT_DATE - INTERVAL '7' DAY  -- last 7 days\n    AND t.transaction_date <  CURRENT_DATE                 -- up to (but not including) today\nGROUP BY\n    p.category_id,\n    c.age,\n    c.gender,\n    c.location;\n```", "latency_sec": 11.216850996017456, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 155, "prompt_eval_sec": null, "tokens_completion": 751, "completion_eval_sec": null, "tokens_total": 906, "tokens_per_sec": 80.77133237498433, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in three key aspects: 1) The Generated SQL includes an extra 'location' column in both SELECT and GROUP BY clauses, 2) The Generated SQL adds an explicit upper bound of 'transaction_date < CURRENT_DATE' which excludes today's transactions whereas the Reference uses a 7-day interval from CURRENT_DATE (including today), and 3) The GROUP BY order differs but this doesn't affect semantic equivalence. These differences in columns, grouping, and date filtering mean the result sets would not be identical.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries differ in three key aspects: 1) The generated query includes 'location' in the GROUP BY clause, which wasn't explicitly requested in the original question. 2) The WHERE clause in the generated query excludes today's transactions (t.transaction_date < CURRENT_DATE), while the reference includes the full 7-day window. 3) The reference query uses DATE_SUB syntax (MySQL) while the generated uses PostgreSQL-style INTERVAL. The reference query better fulfills the business intent by focusing on age and gender (core demographics) without adding extraneous dimensions. The generated query's exclusion of today's data might also produce slightly different results depending on execution timing.", "overall_assessment": "correct"}}
{"example_id": 382, "sql_complexity": "window functions", "prompt": "What is the average annual precipitation in the past 10 years for each weather station?", "context": "CREATE TABLE WeatherStation (ID INT, Name VARCHAR(100), Location VARCHAR(100), Elevation FLOAT, AnnualPrecipitation FLOAT); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (1, 'Station A', 'Arctic Circle', 100, 450); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (2, 'Station B', 'North Pole', 200, 300);", "reference_sql": "SELECT Name, AVG(AnnualPrecipitation) OVER (PARTITION BY Name ORDER BY Name ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS AvgAnnualPrecipitation FROM WeatherStation WHERE YEAR(CurrentDate) - YEAR(DateInstalled) BETWEEN 1 AND 10;", "generated_sql": "SELECT\n    Name,\n    AVG(AnnualPrecipitation) AS AvgAnnualPrecipitationLast10Years\nFROM\n    WeatherStation\nGROUP BY\n    Name;", "raw_model_output": "```sql\nSELECT\n    Name,\n    AVG(AnnualPrecipitation) AS AvgAnnualPrecipitationLast10Years\nFROM\n    WeatherStation\nGROUP BY\n    Name;\n```", "latency_sec": 3.3376567363739014, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 186, "prompt_eval_sec": null, "tokens_completion": 250, "completion_eval_sec": null, "tokens_total": 436, "tokens_per_sec": 130.63056941969393, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references a non-existent 'DateInstalled' column in the WHERE clause, making it invalid. The Generated SQL lacks this condition and uses an aggregate function with GROUP BY. Even if the Reference SQL's WHERE clause were valid, the window function in the Reference SQL would calculate a different average (over the entire partition) compared to the GROUP BY average in the Generated SQL.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference SQL contains critical errors: it references a non-existent 'DateInstalled' column and uses a window function that doesn't address the 'past 10 years' requirement. The generated SQL is technically correct but fails to address the time filter due to schema limitations. Neither query properly handles the 'past 10 years' requirement because the schema lacks date fields. However, the generated query is simpler and avoids invalid column references, making it superior in this context.", "overall_assessment": "differently_correct"}}
{"example_id": 2190, "sql_complexity": "single join", "prompt": "What is the total number of humanitarian assistance events by each country in the last 3 years?", "context": "CREATE TABLE Humanitarian_Assistance (id INT, country VARCHAR(50), year INT, events INT); CREATE TABLE Countries (id INT, name VARCHAR(50), region VARCHAR(50));", "reference_sql": "SELECT co.name, SUM(ha.events) FROM Humanitarian_Assistance ha INNER JOIN Countries co ON ha.country = co.name WHERE ha.year BETWEEN (YEAR(CURRENT_DATE) - 3) AND YEAR(CURRENT_DATE) GROUP BY co.name;", "generated_sql": "SELECT\n    c.name   AS country,\n    SUM(ha.events) AS total_events\nFROM\n    Countries               AS c\nJOIN\n    Humanitarian_Assistance AS ha\n      ON ha.country = c.name\nWHERE\n    ha.year >= (SELECT MAX(year) FROM Humanitarian_Assistance) - 2   -- last 3 years inclusive\nGROUP BY\n    c.name\nORDER BY\n    total_events DESC;", "raw_model_output": "```sql\nSELECT\n    c.name   AS country,\n    SUM(ha.events) AS total_events\nFROM\n    Countries               AS c\nJOIN\n    Humanitarian_Assistance AS ha\n      ON ha.country = c.name\nWHERE\n    ha.year >= (SELECT MAX(year) FROM Humanitarian_Assistance) - 2   -- last 3 years inclusive\nGROUP BY\n    c.name\nORDER BY\n    total_events DESC;\n```", "latency_sec": 7.252835750579834, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 123, "prompt_eval_sec": null, "tokens_completion": 495, "completion_eval_sec": null, "tokens_total": 618, "tokens_per_sec": 85.20805120267524, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses a fixed range based on the current year (YEAR(CURRENT_DATE) - 3 to YEAR(CURRENT_DATE)), which includes 4 years. The Generated SQL uses a dynamic range based on the maximum year in the table (MAX(year) - 2), which includes 3 years. If the maximum year in Humanitarian_Assistance is not exactly 3 years behind the current year, the filtered datasets will differ. For example, if current year is 2023 but the latest year in the table is 2022, the Reference includes 2020-2023 while the Generated includes 2020-2022.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries differ in how they define 'last 3 years'. The Reference SQL uses YEAR(CURRENT_DATE) - 3 which includes 4 years (e.g., 2020-2023 if current year is 2023) due to BETWEEN's inclusive nature. The Generated SQL correctly captures exactly 3 years by using MAX(year) - 2 (e.g., 2021-2023 if max year is 2023). While both join on country and aggregate events, the Generated SQL's approach is more reliable when data spans non-consecutive years or lags behind the current date. The Reference SQL fails to fulfill the business intent of strictly capturing 3 years, while the Generated SQL does so accurately.", "overall_assessment": "differently_correct"}}
{"example_id": 1852, "sql_complexity": "set operations", "prompt": "Compare coal production and employment rates in China and India between 2018 and 2020.", "context": "CREATE TABLE china_coal_production (year INT, production FLOAT); INSERT INTO china_coal_production (year, production) VALUES (2018, 3500.0), (2019, 3600.0), (2020, 3700.0); CREATE TABLE china_employment (year INT, employment FLOAT); INSERT INTO china_employment (year, employment) VALUES (2018, 8000000.0), (2019, 8100000.0), (2020, 8200000.0); CREATE TABLE india_coal_production (year INT, production FLOAT); INSERT INTO india_coal_production (year, production) VALUES (2018, 700.0), (2019, 750.0), (2020, 800.0); CREATE TABLE india_employment (year INT, employment FLOAT); INSERT INTO india_employment (year, employment) VALUES (2018, 1000000.0), (2019, 1050000.0), (2020, 1100000.0);", "reference_sql": "SELECT 'China' AS country, china_coal_production.production, china_employment.employment FROM china_coal_production INNER JOIN china_employment ON china_coal_production.year = china_employment.year WHERE china_coal_production.year BETWEEN 2018 AND 2020 UNION ALL SELECT 'India', india_coal_production.production, india_employment.employment FROM india_coal_production INNER JOIN india_employment ON india_coal_production.year = india_employment.year WHERE india_coal_production.year BETWEEN 2018 AND 2020;", "generated_sql": "SELECT\n    ccp.year,\n    ccp.production  AS china_coal_production,\n    icp.production  AS india_coal_production,\n    ce.employment   AS china_employment,\n    ie.employment   AS india_employment\nFROM china_coal_production  AS ccp\nJOIN india_coal_production  AS icp ON icp.year = ccp.year\nJOIN china_employment       AS ce  ON ce.year  = ccp.year\nJOIN india_employment       AS ie  ON ie.year  = ccp.year\nWHERE ccp.year BETWEEN 2018 AND 2020\nORDER BY ccp.year;", "raw_model_output": "SELECT\n    ccp.year,\n    ccp.production  AS china_coal_production,\n    icp.production  AS india_coal_production,\n    ce.employment   AS china_employment,\n    ie.employment   AS india_employment\nFROM china_coal_production  AS ccp\nJOIN india_coal_production  AS icp ON icp.year = ccp.year\nJOIN china_employment       AS ce  ON ce.year  = ccp.year\nJOIN india_employment       AS ie  ON ie.year  = ccp.year\nWHERE ccp.year BETWEEN 2018 AND 2020\nORDER BY ccp.year;", "latency_sec": 13.797128915786743, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 308, "prompt_eval_sec": null, "tokens_completion": 601, "completion_eval_sec": null, "tokens_total": 909, "tokens_per_sec": 65.88327220454669, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL returns separate rows for China and India with three columns (country, production, employment) for each year, while the Generated SQL returns a single row per year with five columns combining data from both countries. The structure, column counts, and row organization differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The Reference SQL returns two rows per year (China and India separately), while the Generated SQL returns one row per year with both countries' data side-by-side. The Generated query better fulfills the business intent by directly enabling comparison of both countries' metrics in a single row, which aligns with the question's requirement to 'compare' coal production and employment rates. The Reference requires manual comparison across separate rows, making the Generated query more efficient and elegant for the task.", "overall_assessment": "differently_correct"}}
{"example_id": 2535, "sql_complexity": "subqueries", "prompt": "What is the maximum safety rating for vehicles in the vehiclesafety schema?", "context": "CREATE TABLE VehicleSafety (id INT, vehicle_id INT, safetyrating INT, PRIMARY KEY (id)); CREATE TABLE Vehicles (id INT, make VARCHAR(50), model VARCHAR(50), PRIMARY KEY (id)); CREATE TABLE LuxuryVehicles (id INT, vehicle_id INT, PRIMARY KEY (id), FOREIGN KEY (vehicle_id) REFERENCES Vehicles(id));", "reference_sql": "SELECT MAX(safetyrating) FROM vehicleSafety JOIN Vehicles ON vehicleSafety.vehicle_id = Vehicles.id WHERE EXISTS (SELECT * FROM LuxuryVehicles WHERE Vehicles.id = LuxuryVehicles.vehicle_id);", "generated_sql": "SELECT\n    MAX(safetyrating) AS max_safety_rating\nFROM\n    VehicleSafety;", "raw_model_output": "SELECT\n    MAX(safetyrating) AS max_safety_rating\nFROM\n    VehicleSafety;", "latency_sec": 1.70271897315979, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 152, "prompt_eval_sec": null, "tokens_completion": 40, "completion_eval_sec": null, "tokens_total": 192, "tokens_per_sec": 112.76082725718352, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters vehicles that exist in LuxuryVehicles via the EXISTS clause, while the Generated SQL evaluates all records in VehicleSafety without any restrictions. The Generated SQL lacks the join and existence check, so it may include safety ratings from non-luxury vehicles, leading to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query incorrectly filters results to only luxury vehicles using a JOIN and EXISTS clause, which was not part of the original question. The generated query directly retrieves the maximum safety rating from the VehicleSafety table as requested. While the reference query might be correct for a different question (e.g., 'maximum safety rating for luxury vehicles'), it introduces unnecessary complexity and changes the scope. The generated query is technically correct, simpler, and directly addresses the original question about all vehicles in the vehiclesafety schema.", "overall_assessment": "correct"}}
{"example_id": 2140, "sql_complexity": "aggregation", "prompt": "What was the total amount of minerals extracted in the 'north' region for each month in 2020?", "context": "CREATE TABLE extraction(id INT, location TEXT, month INT, year INT, minerals_extracted FLOAT);INSERT INTO extraction(id, location, month, year, minerals_extracted) VALUES (1, 'north', 1, 2020, 1500), (2, 'north', 2, 2020, 1800), (3, 'south', 1, 2020, 1200);", "reference_sql": "SELECT month, SUM(minerals_extracted) FROM extraction WHERE location = 'north' AND year = 2020 GROUP BY month;", "generated_sql": "SELECT\n  month,\n  SUM(minerals_extracted) AS total_minerals_extracted\nFROM extraction\nWHERE location = 'north'\n  AND year = 2020\nGROUP BY month\nORDER BY month;", "raw_model_output": "```sql\nSELECT\n  month,\n  SUM(minerals_extracted) AS total_minerals_extracted\nFROM extraction\nWHERE location = 'north'\n  AND year = 2020\nGROUP BY month\nORDER BY month;\n```", "latency_sec": 2.252695083618164, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 175, "prompt_eval_sec": null, "tokens_completion": 133, "completion_eval_sec": null, "tokens_total": 308, "tokens_per_sec": 136.72511750028153, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries group by 'month' and sum 'minerals_extracted' for 'north' location in 2020. The generated query adds an explicit 'ORDER BY month' and a column alias, but these do not alter the semantic result set's data. The order of rows in SQL is not part of the semantic equivalence unless explicitly required, and the column alias does not affect the data itself.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically correct and produce identical results. The reference query is functionally equivalent to the generated query, as they both filter for 'north' location and 2020 year, group by month, and aggregate minerals_extracted with SUM. The generated query adds an explicit column alias (total_minerals_extracted) and ORDER BY month, which improves readability and ensures sorted output without altering the semantic meaning. While the original question didn't specify ordering, the generated query's additional clarity and structure better meet best practices for BI queries. The reference query is correct but less elegant.", "overall_assessment": "correct"}}
{"example_id": 4779, "sql_complexity": "window functions", "prompt": "What is the average CO2 emission for the top 3 highest emitting countries since 2015?", "context": "CREATE TABLE emissions (country VARCHAR(50), year INT, co2_emission INT); INSERT INTO emissions (country, year, co2_emission) VALUES ('USA', 2015, 5373978000); INSERT INTO emissions (country, year, co2_emission) VALUES ('China', 2015, 10498600000); INSERT INTO emissions (country, year, co2_emission) VALUES ('India', 2015, 2633830000); INSERT INTO emissions (country, year, co2_emission) VALUES ('USA', 2016, 5518004000); INSERT INTO emissions (country, year, co2_emission) VALUES ('China', 2016, 10813000000); INSERT INTO emissions (country, year, co2_emission) VALUES ('India', 2016, 2799280000);", "reference_sql": "SELECT AVG(co2_emission) as avg_emission FROM (SELECT country, year, co2_emission, ROW_NUMBER() OVER (ORDER BY co2_emission DESC) as rn FROM emissions WHERE year >= 2015) t WHERE rn <= 3 GROUP BY country;", "generated_sql": "WITH country_totals AS (\n    SELECT\n        country,\n        SUM(co2_emission) AS total_emission\n    FROM emissions\n    WHERE year >= 2015\n    GROUP BY country\n),\ntop_countries AS (\n    SELECT country\n    FROM country_totals\n    ORDER BY total_emission DESC\n    FETCH FIRST 3 ROWS ONLY        -- pick the 3 highest\u2013emitting countries\n),\nrelevant_emissions AS (\n    SELECT e.co2_emission\n    FROM emissions e\n    JOIN top_countries t\n      ON e.country = t.country\n    WHERE e.year >= 2015\n)\nSELECT AVG(co2_emission) AS average_co2_emission\nFROM relevant_emissions;", "raw_model_output": "```sql\nWITH country_totals AS (\n    SELECT\n        country,\n        SUM(co2_emission) AS total_emission\n    FROM emissions\n    WHERE year >= 2015\n    GROUP BY country\n),\ntop_countries AS (\n    SELECT country\n    FROM country_totals\n    ORDER BY total_emission DESC\n    FETCH FIRST 3 ROWS ONLY        -- pick the 3 highest\u2013emitting countries\n),\nrelevant_emissions AS (\n    SELECT e.co2_emission\n    FROM emissions e\n    JOIN top_countries t\n      ON e.country = t.country\n    WHERE e.year >= 2015\n)\nSELECT AVG(co2_emission) AS average_co2_emission\nFROM relevant_emissions;\n```", "latency_sec": 14.214759349822998, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 266, "prompt_eval_sec": null, "tokens_completion": 1068, "completion_eval_sec": null, "tokens_total": 1334, "tokens_per_sec": 93.84611917588397, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the average of the top 3 co2_emission values (by individual row) grouped by country, while the Generated SQL calculates the average of all emissions for the top 3 countries by total emissions. The Reference SQL's row_number() is applied globally, leading to different grouping and aggregation logic compared to the Generated SQL's country-based total aggregation.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL is technically incorrect because it groups by country after selecting top 3 rows by co2_emission, which would produce 3 separate averages (one per country) rather than a single average of the top 3 countries' emissions. The Generated SQL correctly calculates total emissions per country, identifies the top 3 countries by total emissions, and then computes the average of all their emissions (across all years \u22652015). This aligns with the business intent of averaging emissions for the top 3 countries over the entire period since 2015. The Generated SQL also avoids the flawed approach of averaging per-year emissions, which the Reference SQL implicitly does.", "overall_assessment": "differently_correct"}}
{"example_id": 1015, "sql_complexity": "subqueries", "prompt": "List the top 3 most expensive eco-friendly products in Europe and their suppliers.", "context": "CREATE TABLE Suppliers (supplierID INT, supplierName VARCHAR(50), country VARCHAR(50)); CREATE TABLE Products (productID INT, productName VARCHAR(50), price DECIMAL(10,2), ecoFriendly BOOLEAN, supplierID INT);", "reference_sql": "SELECT P.productName, P.price, S.supplierName FROM (SELECT * FROM Products WHERE ecoFriendly = TRUE ORDER BY price DESC LIMIT 3) P JOIN Suppliers S ON P.supplierID = S.supplierID;", "generated_sql": "SELECT\n    p.productName,\n    p.price,\n    s.supplierName,\n    s.country\nFROM\n    Products  AS p\nJOIN\n    Suppliers AS s ON p.supplierID = s.supplierID\nWHERE\n    p.ecoFriendly = TRUE\n    AND s.country IN (\n        'Austria','Belgium','Croatia','Cyprus','Czech Republic','Denmark','Estonia',\n        'Finland','France','Germany','Greece','Hungary','Ireland','Italy','Latvia',\n        'Lithuania','Luxembourg','Malta','Netherlands','Norway','Poland','Portugal',\n        'Romania','Slovakia','Slovenia','Spain','Sweden','Switzerland','United Kingdom'\n    )\nORDER BY\n    p.price DESC\nFETCH FIRST 3 ROWS ONLY;", "raw_model_output": "```sql\nSELECT\n    p.productName,\n    p.price,\n    s.supplierName,\n    s.country\nFROM\n    Products  AS p\nJOIN\n    Suppliers AS s ON p.supplierID = s.supplierID\nWHERE\n    p.ecoFriendly = TRUE\n    AND s.country IN (\n        'Austria','Belgium','Croatia','Cyprus','Czech Republic','Denmark','Estonia',\n        'Finland','France','Germany','Greece','Hungary','Ireland','Italy','Latvia',\n        'Lithuania','Luxembourg','Malta','Netherlands','Norway','Poland','Portugal',\n        'Romania','Slovakia','Slovenia','Spain','Sweden','Switzerland','United Kingdom'\n    )\nORDER BY\n    p.price DESC\nFETCH FIRST 3 ROWS ONLY;\n```", "latency_sec": 7.234797954559326, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 131, "prompt_eval_sec": null, "tokens_completion": 517, "completion_eval_sec": null, "tokens_total": 648, "tokens_per_sec": 89.56711770943572, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The generated query includes an additional 'country' column in the SELECT list and applies a country filter in the WHERE clause, which is absent in the reference query. Additionally, the reference query uses LIMIT 3 while the generated query uses FETCH FIRST 3 ROWS ONLY (functionally similar but not identical syntax). The country filter could also change the result set by excluding suppliers from specific countries.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query lacks a country filter, potentially returning non-European suppliers, while the generated query explicitly filters European countries. Both correctly identify eco-friendly products and join with suppliers, but the generated query better fulfills the business intent by ensuring European suppliers. The generated query's country list covers most European nations (though excludes some like Russia), while the reference query ignores geographic constraints entirely. The generated query uses FETCH FIRST 3 ROWS ONLY (modern syntax) vs. LIMIT 3, but both achieve the same result. The generated query's explicit country filter makes it more accurate for the business requirement.", "overall_assessment": "differently_correct"}}
{"example_id": 3715, "sql_complexity": "aggregation", "prompt": "What is the average age of engines still in service for each engine type?", "context": "CREATE TABLE Engine (id INT, aircraft_id INT, engine_type VARCHAR(255), hours_since_last_service INT, manufacture_year INT); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (1, 1, 'GE90-115B', 500, 2000); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (2, 2, 'CFM56-5B', 1000, 1995); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (3, 1, 'GE90-115B', 700, 2002);", "reference_sql": "SELECT engine_type, AVG(YEAR(CURRENT_DATE) - manufacture_year) as avg_age FROM Engine GROUP BY engine_type;", "generated_sql": "SELECT\n    engine_type,\n    AVG(EXTRACT(YEAR FROM CURRENT_DATE) - manufacture_year) AS average_age\nFROM\n    Engine\nGROUP BY\n    engine_type;", "raw_model_output": "```sql\nSELECT\n    engine_type,\n    AVG(EXTRACT(YEAR FROM CURRENT_DATE) - manufacture_year) AS average_age\nFROM\n    Engine\nGROUP BY\n    engine_type;\n```", "latency_sec": 3.2263360023498535, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 233, "prompt_eval_sec": null, "tokens_completion": 187, "completion_eval_sec": null, "tokens_total": 420, "tokens_per_sec": 130.1786297813059, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average age of engines by subtracting the manufacture_year from the current year. The Reference SQL uses YEAR(CURRENT_DATE) while the Generated SQL uses EXTRACT(YEAR FROM CURRENT_DATE). These expressions are functionally equivalent for the purpose of calculating the current year, so the queries produce the same result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries calculate the average age of engines by subtracting the manufacture_year from the current year, grouped by engine_type. The reference query uses YEAR(CURRENT_DATE) while the generated query uses EXTRACT(YEAR FROM CURRENT_DATE). These expressions are functionally equivalent in standard SQL for this purpose. However, neither query explicitly filters for 'engines still in service' despite the question's wording. The provided context lacks a status field to identify active engines, so both queries assume all records in the Engine table represent engines in service. The queries are equally efficient and semantically equivalent given the constraints.", "overall_assessment": "correct"}}
{"example_id": 1957, "sql_complexity": "set operations", "prompt": "What is the average temperature recorded for the 'polar_bear' species in the 'Arctic_Animals' table compared to the 'penguin' species in the 'Antarctic_Animals' table?", "context": "CREATE TABLE Arctic_Animals (species TEXT, avg_temp FLOAT); CREATE TABLE Antarctic_Animals (species TEXT, avg_temp FLOAT);", "reference_sql": "SELECT AVG(Arctic_Animals.avg_temp) FROM Arctic_Animals WHERE Arctic_Animals.species = 'polar_bear' INTERSECT SELECT AVG(Antarctic_Animals.avg_temp) FROM Antarctic_Animals WHERE Antarctic_Animals.species = 'penguin'", "generated_sql": "SELECT\n    (SELECT AVG(avg_temp) FROM Arctic_Animals    WHERE species = 'polar_bear') AS polar_bear_avg_temp,\n    (SELECT AVG(avg_temp) FROM Antarctic_Animals WHERE species = 'penguin')     AS penguin_avg_temp;", "raw_model_output": "SELECT\n    (SELECT AVG(avg_temp) FROM Arctic_Animals    WHERE species = 'polar_bear') AS polar_bear_avg_temp,\n    (SELECT AVG(avg_temp) FROM Antarctic_Animals WHERE species = 'penguin')     AS penguin_avg_temp;", "latency_sec": 4.34494686126709, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 134, "prompt_eval_sec": null, "tokens_completion": 201, "completion_eval_sec": null, "tokens_total": 335, "tokens_per_sec": 77.10105800978796, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses INTERSECT to find common rows between two aggregated values (polar bear and penguin avg_temps), returning a single value if they match. The Generated SQL returns both averages as separate columns in a single row. The first query enforces equality between the two averages, while the second simply retrieves both values independently.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is technically incorrect because it uses INTERSECT, which returns only common rows between two result sets. Since each subquery returns a single value (average temperature), INTERSECT would only return a result if the two averages are exactly equal (which is unlikely). This fundamentally misrepresents the comparison intent. The Generated SQL correctly calculates both averages independently in separate subqueries and returns them as two columns, enabling direct comparison. While both queries are syntactically valid, only the Generated SQL fulfills the business intent of comparing the two averages. The Generated version is also more efficient and semantically precise.", "overall_assessment": "differently_correct"}}
{"example_id": 1311, "sql_complexity": "basic SQL", "prompt": "What is the total number of veteran job applications in Texas in the last year?", "context": "CREATE TABLE veteran_jobs (id INT, state VARCHAR(50), application_date DATE); INSERT INTO veteran_jobs (id, state, application_date) VALUES (1, 'Texas', '2021-02-15'), (2, 'California', '2021-04-10'), (3, 'Texas', '2022-01-05');", "reference_sql": "SELECT COUNT(*) FROM veteran_jobs WHERE state = 'Texas' AND application_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR);", "generated_sql": "SELECT COUNT(*) AS total_applications\nFROM veteran_jobs\nWHERE state = 'Texas'\n  AND application_date >= CURRENT_DATE - INTERVAL '1' YEAR;", "raw_model_output": "SELECT COUNT(*) AS total_applications\nFROM veteran_jobs\nWHERE state = 'Texas'\n  AND application_date >= CURRENT_DATE - INTERVAL '1' YEAR;", "latency_sec": 3.667464017868042, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 154, "prompt_eval_sec": null, "tokens_completion": 180, "completion_eval_sec": null, "tokens_total": 334, "tokens_per_sec": 91.07110482140729, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count rows where state is 'Texas' and application_date is within the last year from current date. The date calculation syntax differs (DATE_SUB vs. CURRENT_DATE - INTERVAL), but both achieve the same logical result. The alias in the Generated SQL doesn't affect the semantic output.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly count veteran job applications in Texas within the last year. The reference uses DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR), while the generated query uses CURRENT_DATE - INTERVAL '1' YEAR. These date calculations are functionally equivalent in most SQL dialects (e.g., MySQL, PostgreSQL) for determining the same time window. The generated query adds an explicit alias (total_applications), which improves readability but does not affect correctness. Both queries strictly enforce the state = 'Texas' condition and filter applications within the required timeframe. Neither query has logical errors or syntax issues.", "overall_assessment": "correct"}}
{"example_id": 2997, "sql_complexity": "window functions", "prompt": "What is the earliest capture time for each satellite image in the 'satellite_images' table?", "context": "CREATE TABLE satellite_images (image_id INT, image_url TEXT, capture_time TIMESTAMP); INSERT INTO satellite_images (image_id, image_url, capture_time) VALUES (1, 'image1.jpg', '2022-01-01 10:00:00'), (2, 'image2.jpg', '2021-05-01 10:00:00');", "reference_sql": "SELECT image_id, MIN(capture_time) OVER (PARTITION BY image_id) FROM satellite_images;", "generated_sql": "SELECT\n    image_id,\n    MIN(capture_time) AS earliest_capture_time\nFROM\n    satellite_images\nGROUP BY\n    image_id;", "raw_model_output": "```sql\nSELECT\n    image_id,\n    MIN(capture_time) AS earliest_capture_time\nFROM\n    satellite_images\nGROUP BY\n    image_id;\n```", "latency_sec": 3.183173894882202, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 162, "prompt_eval_sec": null, "tokens_completion": 181, "completion_eval_sec": null, "tokens_total": 343, "tokens_per_sec": 107.75408800363174, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses a window function to return all rows with the minimum capture_time per image_id group, while the Generated SQL aggregates rows into one per image_id. If there are multiple rows with the same image_id, the Reference SQL would return multiple rows with the same min value, whereas the Generated SQL would return a single row per image_id. Thus, they are not semantically equivalent in general.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries return the same results because each image_id is unique (as per the sample data) and the MIN(capture_time) for a single row is the same as the original capture_time. However, the Generated SQL is more efficient and semantically appropriate: it explicitly groups by image_id and calculates the minimum capture time, which aligns with the business intent of finding the earliest capture time per image. The Reference SQL uses a window function unnecessarily, which would be redundant for unique image_ids but could still work if multiple captures existed per image. The Generated SQL is clearer and more efficient for this specific schema.", "overall_assessment": "correct"}}
{"example_id": 3743, "sql_complexity": "aggregation", "prompt": "What is the maximum budget spent on peacekeeping operations by each department?", "context": "CREATE TABLE DepartmentPeacekeeping (id INT, department VARCHAR(50), budget INT);", "reference_sql": "SELECT department, MAX(budget) FROM DepartmentPeacekeeping GROUP BY department;", "generated_sql": "SELECT\n    department,\n    MAX(budget) AS max_budget\nFROM\n    DepartmentPeacekeeping\nGROUP BY\n    department;", "raw_model_output": "```sql\nSELECT\n    department,\n    MAX(budget) AS max_budget\nFROM\n    DepartmentPeacekeeping\nGROUP BY\n    department;\n```", "latency_sec": 2.1172616481781006, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 97, "prompt_eval_sec": null, "tokens_completion": 114, "completion_eval_sec": null, "tokens_total": 211, "tokens_per_sec": 99.65702641502295, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries group by 'department' and select the maximum 'budget' for each group. The generated query adds an explicit alias 'max_budget' for the MAX(budget) column, but this does not affect the semantic result. The core logic and output data remain identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the maximum budget per department using GROUP BY and MAX(). The generated query improves readability by explicitly aliasing the calculated column as 'max_budget', which makes the result set more descriptive. While the reference query is technically valid, the generated version enhances clarity without altering functionality. Both satisfy the business intent of identifying the highest budget per department.", "overall_assessment": "correct"}}
{"example_id": 4664, "sql_complexity": "multiple_joins", "prompt": "Calculate the total number of volunteer hours contributed by volunteers from 'California' in 'Health' projects in 2021.", "context": "CREATE TABLE volunteers (volunteer_id INT, name VARCHAR(255), state VARCHAR(255));", "reference_sql": "SELECT SUM(vh.hours) as total_hours FROM volunteer_projects vp JOIN volunteer_hours vh ON vp.project_id = vh.project_id JOIN volunteers vol ON vh.volunteer_id = vol.volunteer_id WHERE vp.cause = 'Health' AND vol.state = 'California' AND vh.volunteer_date BETWEEN '2021-01-01' AND '2021-12-31';", "generated_sql": "SELECT NULL AS total_volunteer_hours;", "raw_model_output": "/* The provided schema does not contain any tables or columns that record\n   volunteer hours, project categories, or dates.  Consequently, it is\n   impossible to compute the requested total with the available data. */\nSELECT NULL AS total_volunteer_hours;", "latency_sec": 9.567887306213379, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 109, "prompt_eval_sec": null, "tokens_completion": 839, "completion_eval_sec": null, "tokens_total": 948, "tokens_per_sec": 99.08143455916014, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the sum of volunteer hours for specific criteria, while the Generated SQL returns a constant NULL value. They produce entirely different results (calculated value vs. null) and have different query structures.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The reference query correctly calculates total volunteer hours by joining relevant tables (volunteer_projects, volunteer_hours, volunteers) with appropriate filters for 'Health' cause, California state, and 2021 date range. The generated query returns a single NULL value without any computation or data retrieval, failing to address the business question. While the reference query is technically correct and semantically aligned with the intent, the generated query is entirely non-functional for this task.", "overall_assessment": "incorrect"}}
{"example_id": 251, "sql_complexity": "set operations", "prompt": "Compare the number of economic diversification projects in two regions, one in Europe and one in Oceania, by showing the project type and the number of projects in each region.", "context": "CREATE TABLE economic_diversification (region VARCHAR(50), project_type VARCHAR(50), project_start_date DATE);", "reference_sql": "SELECT 'Europe' as region, project_type, COUNT(*) as project_count FROM economic_diversification WHERE region = 'Europe' UNION ALL SELECT 'Oceania' as region, project_type, COUNT(*) as project_count FROM economic_diversification WHERE region = 'Oceania';", "generated_sql": "SELECT\n    project_type,\n    COUNT(CASE WHEN region = 'Europe'  THEN 1 END)   AS europe_project_count,\n    COUNT(CASE WHEN region = 'Oceania' THEN 1 END)   AS oceania_project_count\nFROM economic_diversification\nWHERE region IN ('Europe', 'Oceania')          -- pick one European and one Oceanian region\nGROUP BY project_type\nORDER BY project_type;", "raw_model_output": "```sql\nSELECT\n    project_type,\n    COUNT(CASE WHEN region = 'Europe'  THEN 1 END)   AS europe_project_count,\n    COUNT(CASE WHEN region = 'Oceania' THEN 1 END)   AS oceania_project_count\nFROM economic_diversification\nWHERE region IN ('Europe', 'Oceania')          -- pick one European and one Oceanian region\nGROUP BY project_type\nORDER BY project_type;\n```", "latency_sec": 10.198212146759033, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 123, "prompt_eval_sec": null, "tokens_completion": 625, "completion_eval_sec": null, "tokens_total": 748, "tokens_per_sec": 73.34618943357759, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate rows per project_type (one for Europe and one for Oceania), while the Generated SQL returns a single row per project_type with two columns (europe_project_count and oceania_project_count). The structure of the result sets differs: the first is vertical (two rows per project_type) and the second is horizontal (one row per project_type with aggregated counts).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent due to differing result structures. The Reference SQL produces two rows per project type (Europe/Oceania), while the Generated SQL produces one row per project type with separate columns for each region. The Generated SQL better fulfills the business intent by directly enabling side-by-side comparison of project counts between regions. It is more efficient as a single query with conditional aggregation, avoiding UNION ALL. The Reference SQL requires post-processing to compare regions, while the Generated SQL explicitly addresses the 'compare' requirement in the output structure.", "overall_assessment": "differently_correct"}}
{"example_id": 610, "sql_complexity": "subqueries", "prompt": "What is the percentage of community development projects completed in 'Caribbean' in 2020?", "context": "CREATE TABLE community_projects (project_id INT, project_name TEXT, location TEXT, completion_year INT); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (1, 'Community Center', 'Southern Region, Caribbean', 2020); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (2, 'Park Renovation', 'Northern Region, Caribbean', 2019); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (3, 'Library Construction', 'Caribbean', 2020);", "reference_sql": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM community_projects WHERE location = 'Caribbean')) FROM community_projects WHERE completion_year = 2020 AND location = 'Caribbean';", "generated_sql": "SELECT\n    ( COUNT(CASE WHEN location = 'Caribbean' THEN 1 END) * 100.0\n      / COUNT(*) ) AS percentage_in_caribbean_2020\nFROM community_projects\nWHERE completion_year = 2020;", "raw_model_output": "```sql\nSELECT\n    ( COUNT(CASE WHEN location = 'Caribbean' THEN 1 END) * 100.0\n      / COUNT(*) ) AS percentage_in_caribbean_2020\nFROM community_projects\nWHERE completion_year = 2020;\n```", "latency_sec": 9.018841981887817, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 206, "prompt_eval_sec": null, "tokens_completion": 842, "completion_eval_sec": null, "tokens_total": 1048, "tokens_per_sec": 116.20117107103736, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the percentage of Caribbean projects completed in 2020 relative to all Caribbean projects (denominator: total Caribbean projects). The Generated SQL calculates the percentage of 2020 projects that are in the Caribbean relative to all 2020 projects (denominator: total 2020 projects). The denominators differ, leading to different results. For the given data, Reference SQL returns 100% (1/1) while Generated SQL returns 50% (1/2).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query calculates (Caribbean 2020 projects) / (total Caribbean projects) * 100, while the generated query calculates (Caribbean 2020 projects) / (total 2020 projects) * 100. The original question asks for the percentage of projects completed in the Caribbean in 2020, which is best interpreted as the proportion of 2020 projects that are in the Caribbean (generated query). The reference query instead answers the inverse question: what percentage of Caribbean projects were completed in 2020. The generated query correctly focuses on the 2020 cohort, aligning with typical business interpretations of such percentage questions.", "overall_assessment": "correct"}}
{"example_id": 421, "sql_complexity": "set operations", "prompt": "What is the combined landfill capacity for 'City A' and 'City B'?", "context": "CREATE TABLE landfill_capacity (city VARCHAR(255), capacity INT); INSERT INTO landfill_capacity (city, capacity) VALUES ('City A', 500000), ('City B', 600000);", "reference_sql": "SELECT SUM(capacity) FROM (SELECT capacity FROM landfill_capacity WHERE city = 'City A' UNION ALL SELECT capacity FROM landfill_capacity WHERE city = 'City B') AS combined_capacity;", "generated_sql": "SELECT SUM(capacity) AS combined_capacity\nFROM landfill_capacity\nWHERE city IN ('City A', 'City B');", "raw_model_output": "SELECT SUM(capacity) AS combined_capacity\nFROM landfill_capacity\nWHERE city IN ('City A', 'City B');", "latency_sec": 1.921259880065918, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 122, "prompt_eval_sec": null, "tokens_completion": 43, "completion_eval_sec": null, "tokens_total": 165, "tokens_per_sec": 85.88114586265075, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of capacities for 'City A' and 'City B'. The reference query uses a subquery with UNION ALL to combine capacities from each city before summing, while the generated query directly filters and sums the capacities. Since SUM aggregates all values regardless of their source, both approaches yield the same result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the combined landfill capacity for 'City A' and 'City B'. The Reference SQL uses a subquery with UNION ALL to isolate each city's capacity before summing, while the Generated SQL directly filters and sums the capacities in a single query. Technically, they produce identical results. However, the Generated SQL is more efficient (fewer operations, single table scan) and elegant. Both fulfill the business intent, but the Generated query better addresses the question with simpler logic.", "overall_assessment": "correct"}}
{"example_id": 880, "sql_complexity": "aggregation", "prompt": "Show veteran employment statistics for each state in the 'veteran_employment' table", "context": "CREATE TABLE veteran_employment (employee_id INT, state VARCHAR(2), job_title VARCHAR(50), employment_date DATE);", "reference_sql": "SELECT state, COUNT(*) as veteran_employees FROM veteran_employment WHERE state IN ('CA', 'NY', 'TX', 'FL', 'PA') GROUP BY state;", "generated_sql": "SELECT\n    state,\n    COUNT(*) AS employee_count\nFROM\n    veteran_employment\nGROUP BY\n    state\nORDER BY\n    state;", "raw_model_output": "```sql\nSELECT\n    state,\n    COUNT(*) AS employee_count\nFROM\n    veteran_employment\nGROUP BY\n    state\nORDER BY\n    state;\n```", "latency_sec": 2.1458020210266113, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 109, "prompt_eval_sec": null, "tokens_completion": 118, "completion_eval_sec": null, "tokens_total": 227, "tokens_per_sec": 105.78795143989886, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters results to only include records where state is in ('CA', 'NY', 'TX', 'FL', 'PA'), while the Generated SQL includes all states present in the table. The GROUP BY logic is identical, but the Generated SQL lacks the WHERE clause restriction, leading to potentially different result sets if other states exist in the data.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ technically: the reference query filters results to specific states ('CA', 'NY', 'TX', 'FL', 'PA') while the generated query includes all states. The original question asked for statistics for 'each state' in the table without specifying particular states, making the generated query more accurate. The reference query's WHERE clause introduces an implicit constraint not present in the original question. Both queries correctly use GROUP BY and COUNT(*), but the generated query better fulfills the business intent by providing comprehensive state-level statistics.", "overall_assessment": "differently_correct"}}
{"example_id": 454, "sql_complexity": "single join", "prompt": "Which excavation sites have more than 10 artifacts?", "context": "CREATE TABLE ExcavationSite (SiteID INT, SiteName VARCHAR(50)); INSERT INTO ExcavationSite (SiteID, SiteName) VALUES (1, 'Site A'), (2, 'Site B'), (3, 'Site C'); CREATE TABLE Artifact (ArtifactID INT, SiteID INT, ObjectType VARCHAR(50)); INSERT INTO Artifact (ArtifactID, SiteID, ObjectType) VALUES (1, 1, 'Pottery'), (2, 1, 'Tool'), (3, 2, 'Statue'), (4, 2, 'Bead'), (5, 3, 'Bead'), (6, 3, 'Bead'), (7, 3, 'Bead'), (8, 3, 'Bead'), (9, 3, 'Bead'), (10, 3, 'Bead'), (11, 3, 'Bead');", "reference_sql": "SELECT e.SiteName FROM ExcavationSite e JOIN Artifact a ON e.SiteID = a.SiteID GROUP BY e.SiteName HAVING COUNT(a.ArtifactID) > 10;", "generated_sql": "SELECT \n    es.SiteID,\n    es.SiteName\nFROM \n    ExcavationSite AS es\nJOIN \n    Artifact AS a\n    ON es.SiteID = a.SiteID\nGROUP BY \n    es.SiteID,\n    es.SiteName\nHAVING \n    COUNT(*) > 10;", "raw_model_output": "SELECT \n    es.SiteID,\n    es.SiteName\nFROM \n    ExcavationSite AS es\nJOIN \n    Artifact AS a\n    ON es.SiteID = a.SiteID\nGROUP BY \n    es.SiteID,\n    es.SiteName\nHAVING \n    COUNT(*) > 10;", "latency_sec": 3.4143218994140625, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 267, "prompt_eval_sec": null, "tokens_completion": 208, "completion_eval_sec": null, "tokens_total": 475, "tokens_per_sec": 139.11986449828166, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects only 'SiteName' while the Generated SQL selects both 'SiteID' and 'SiteName'. Additionally, the Generated SQL groups by both 'SiteID' and 'SiteName' (though grouping by 'SiteID' alone would suffice since it's a primary key), whereas the Reference SQL groups by 'SiteName' alone. Although the HAVING clause and join logic are similar, the differing output columns and grouping strategies make the result sets structurally different.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "reference", "explanation": "Both queries correctly identify excavation sites with more than 10 artifacts. The Reference SQL uses GROUP BY SiteName and COUNT(ArtifactID), while the Generated SQL uses GROUP BY SiteID/SiteName and COUNT(*). Since the sample data has no sites with >10 artifacts, both return empty results. The Reference SQL directly answers the question by returning only SiteName, which matches the original intent. The Generated SQL includes SiteID unnecessarily but is more robust in grouping (using SiteID + SiteName). However, the Reference SQL better fulfills the business intent by focusing on the requested output (site names).", "overall_assessment": "correct"}}
{"example_id": 1086, "sql_complexity": "aggregation", "prompt": "What is the total CO2 emission for each equipment type, excluding equipment that is older than 8 years?", "context": "CREATE TABLE EmissionData (EquipmentID INT, EquipmentType VARCHAR(50), CO2Emission INT, Age INT); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (1, 'Excavator', 50, 8); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (2, 'Haul Truck', 70, 7); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (3, 'Shovel', 30, 6); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (4, 'Drilling Rig', 40, 3);", "reference_sql": "SELECT EquipmentType, SUM(CO2Emission) as TotalCO2Emission FROM EmissionData WHERE Age <= 8 GROUP BY EquipmentType;", "generated_sql": "SELECT\n    EquipmentType,\n    SUM(CO2Emission) AS TotalCO2Emission\nFROM\n    EmissionData\nWHERE\n    Age <= 8\nGROUP BY\n    EquipmentType;", "raw_model_output": "SELECT\n    EquipmentType,\n    SUM(CO2Emission) AS TotalCO2Emission\nFROM\n    EmissionData\nWHERE\n    Age <= 8\nGROUP BY\n    EquipmentType;", "latency_sec": 3.0632572174072266, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 243, "prompt_eval_sec": null, "tokens_completion": 188, "completion_eval_sec": null, "tokens_total": 431, "tokens_per_sec": 140.69990516983194, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select EquipmentType and sum CO2Emission where Age <= 8, grouping by EquipmentType. The only differences are formatting (whitespace and line breaks) which do not affect semantic meaning.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are structurally identical in logic, syntax, and output. The Reference SQL and Generated SQL both: 1) Filter equipment with Age <= 8 (correctly excluding older equipment), 2) Group by EquipmentType, 3) Sum CO2Emission. The only difference is formatting (line breaks and capitalization), which does not affect execution. Both fully address the business intent of calculating total CO2 emissions per equipment type while excluding equipment older than 8 years. Neither query is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 3455, "sql_complexity": "basic SQL", "prompt": "What are the names of all innovation projects in the 'rural_infrastructure' table, excluding those with a budget over 50000?", "context": "CREATE TABLE rural_infrastructure (name VARCHAR(255), budget INT); INSERT INTO rural_infrastructure (name, budget) VALUES ('Dam Construction', 40000), ('Well Digging', 30000), ('Irrigation System', 70000);", "reference_sql": "SELECT name FROM rural_infrastructure WHERE budget <= 50000;", "generated_sql": "SELECT\n    name\nFROM\n    rural_infrastructure\nWHERE\n    budget <= 50000;", "raw_model_output": "SELECT\n    name\nFROM\n    rural_infrastructure\nWHERE\n    budget <= 50000;", "latency_sec": 2.0023279190063477, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 146, "prompt_eval_sec": null, "tokens_completion": 104, "completion_eval_sec": null, "tokens_total": 250, "tokens_per_sec": 124.85467421543127, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the 'name' column from the 'rural_infrastructure' table where budget is less than or equal to 50000. The generated SQL has identical logic but different formatting (line breaks and capitalization). SQL is case-insensitive for keywords and whitespace does not affect execution.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are syntactically correct and semantically identical. They select project names from the rural_infrastructure table where budget is less than or equal to 50000, perfectly matching the business requirement to exclude projects with budgets over 50000. The reference query is more concise while the generated query uses proper formatting with line breaks, but they produce identical results. Both efficiently address the question with the same logical condition.", "overall_assessment": "correct"}}
{"example_id": 3936, "sql_complexity": "window functions", "prompt": "What is the total investment per client for each investment type?", "context": "CREATE TABLE clients (client_id INT, name TEXT, investment_type TEXT, investment FLOAT); INSERT INTO clients (client_id, name, investment_type, investment) VALUES (1, 'John Doe', 'Stocks', 3000.00), (1, 'John Doe', 'Bonds', 2000.00), (2, 'Jane Smith', 'Stocks', 5000.00);", "reference_sql": "SELECT client_id, name, investment_type, SUM(investment) OVER (PARTITION BY client_id, investment_type ORDER BY client_id) as total_investment FROM clients;", "generated_sql": "SELECT\n    client_id,\n    name,\n    investment_type,\n    SUM(investment) AS total_investment\nFROM\n    clients\nGROUP BY\n    client_id,\n    name,\n    investment_type;", "raw_model_output": "SELECT\n    client_id,\n    name,\n    investment_type,\n    SUM(investment) AS total_investment\nFROM\n    clients\nGROUP BY\n    client_id,\n    name,\n    investment_type;", "latency_sec": 3.0099263191223145, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 160, "prompt_eval_sec": null, "tokens_completion": 127, "completion_eval_sec": null, "tokens_total": 287, "tokens_per_sec": 95.35117128172371, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The reference query uses a window function to calculate a cumulative sum within partitions, retaining all rows. The generated query aggregates rows using GROUP BY, collapsing multiple rows into one per group. For data with multiple entries per client_id/investment_type, the reference query would show cumulative sums while the generated query would show total sums, leading to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query uses a window function that calculates a cumulative sum partitioned by client_id and investment_type, but the ORDER BY client_id is unnecessary and could lead to unexpected results if there are multiple entries per client/investment_type combination. The generated query properly groups by client_id, name, and investment_type to aggregate investments, ensuring one row per client-investment_type pair with the correct total. While both might return similar results for the sample data, the generated query is semantically correct for the business intent of summarizing totals. The reference query's window function approach would return duplicate rows for multiple entries, failing to meet the requirement for per-client-per-type totals.", "overall_assessment": "differently_correct"}}
{"example_id": 1838, "sql_complexity": "window functions", "prompt": "What are the top 3 species with the most sightings across all arctic research stations?", "context": "CREATE TABLE research_station (id INT, name TEXT); INSERT INTO research_station (id, name) VALUES (1, 'Station A'); INSERT INTO research_station (id, name) VALUES (2, 'Station B'); CREATE TABLE species_observations (station_id INT, species_name TEXT, sightings INT); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (1, 'Species 1', 10); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (1, 'Species 2', 5); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (2, 'Species 1', 8); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (2, 'Species 3', 15);", "reference_sql": "SELECT species_name, SUM(sightings) as total_sightings, RANK() OVER (ORDER BY SUM(sightings) DESC) as rank FROM species_observations GROUP BY species_name HAVING rank <= 3;", "generated_sql": "SELECT\n    so.species_name,\n    SUM(so.sightings) AS total_sightings\nFROM\n    species_observations AS so\nGROUP BY\n    so.species_name\nORDER BY\n    total_sightings DESC\nFETCH FIRST 3 ROWS ONLY;", "raw_model_output": "```sql\nSELECT\n    so.species_name,\n    SUM(so.sightings) AS total_sightings\nFROM\n    species_observations AS so\nGROUP BY\n    so.species_name\nORDER BY\n    total_sightings DESC\nFETCH FIRST 3 ROWS ONLY;\n```", "latency_sec": 2.751389741897583, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 255, "prompt_eval_sec": null, "tokens_completion": 146, "completion_eval_sec": null, "tokens_total": 401, "tokens_per_sec": 145.7445282628108, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses a RANK() window function in the SELECT clause with a HAVING rank <= 3 filter, which is invalid because HAVING cannot reference column aliases from the SELECT. The Generated SQL correctly groups, sums, orders, and limits results. The Reference SQL would fail syntactically, making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL contains a critical technical error: the HAVING clause attempts to filter on 'rank', which is a window function result not available in the HAVING clause (window functions cannot be used in HAVING). The Generated SQL correctly groups, sums, orders, and limits results. Both queries aim to find top species by sightings, but the Generated SQL achieves this with proper syntax and logic. The Reference SQL would fail execution or return incorrect results due to the invalid HAVING clause. The Generated SQL is more efficient and directly addresses the business intent.", "overall_assessment": "incorrect"}}
{"example_id": 3091, "sql_complexity": "single join", "prompt": "Find the number of hybrid vehicles sold in the US, Germany, and Japan.", "context": "CREATE TABLE vehicle_sales (sale_id INT, vehicle_id INT, country VARCHAR(20), quantity INT); CREATE TABLE vehicles (vehicle_id INT, model VARCHAR(20), manufacture VARCHAR(20), vehicle_type VARCHAR(20));", "reference_sql": "SELECT SUM(vs.quantity) FROM vehicle_sales vs JOIN vehicles v ON vs.vehicle_id = v.vehicle_id WHERE v.vehicle_type = 'hybrid' AND vs.country IN ('US', 'Germany', 'Japan');", "generated_sql": "SELECT\n    vs.country,\n    SUM(vs.quantity) AS hybrid_vehicles_sold\nFROM\n    vehicle_sales AS vs\nJOIN\n    vehicles AS v\n    ON vs.vehicle_id = v.vehicle_id\nWHERE\n    v.vehicle_type = 'hybrid'\n    AND vs.country IN ('US', 'Germany', 'Japan')\nGROUP BY\n    vs.country;", "raw_model_output": "```sql\nSELECT\n    vs.country,\n    SUM(vs.quantity) AS hybrid_vehicles_sold\nFROM\n    vehicle_sales AS vs\nJOIN\n    vehicles AS v\n    ON vs.vehicle_id = v.vehicle_id\nWHERE\n    v.vehicle_type = 'hybrid'\n    AND vs.country IN ('US', 'Germany', 'Japan')\nGROUP BY\n    vs.country;\n```", "latency_sec": 3.679213047027588, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 127, "prompt_eval_sec": null, "tokens_completion": 227, "completion_eval_sec": null, "tokens_total": 354, "tokens_per_sec": 96.21622762128284, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns a single total sum of hybrid vehicle sales across all specified countries, while the Generated SQL returns separate sums grouped by country. The output structure differs (single value vs. multiple rows), making them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query returns a single total sum of hybrid vehicles sold across all three countries, while the generated query provides separate sums per country. The original question is ambiguous but leans toward requiring a breakdown by country (as it lists specific countries). The generated query better fulfills the business intent by offering granular insights per country, which is more actionable for analysis. While the reference query is technically correct for a total, the generated query's grouping provides richer data without sacrificing correctness. Both are efficient, but the generated query's structure aligns better with typical BI requirements for regional breakdowns.", "overall_assessment": "differently_correct"}}
{"example_id": 2399, "sql_complexity": "set operations", "prompt": "What is the average duration of criminal trials for Indigenous defendants compared to non-Indigenous defendants in Canada and New Zealand?", "context": "CREATE TABLE canada_criminal_trials (id INT, defendant_type VARCHAR(255), days_to_completion INT); INSERT INTO canada_criminal_trials (id, defendant_type, days_to_completion) VALUES (1, 'Indigenous', 60), (2, 'Non-Indigenous', 45);CREATE TABLE nz_criminal_trials (id INT, defendant_type VARCHAR(255), days_to_completion INT); INSERT INTO nz_criminal_trials (id, defendant_type, days_to_completion) VALUES (1, 'Indigenous', 70), (2, 'Non-Indigenous', 50);", "reference_sql": "SELECT AVG(days_to_completion) AS avg_duration FROM canada_criminal_trials WHERE defendant_type = 'Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM canada_criminal_trials WHERE defendant_type = 'Non-Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM nz_criminal_trials WHERE defendant_type = 'Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM nz_criminal_trials WHERE defendant_type = 'Non-Indigenous';", "generated_sql": "SELECT \n    'Canada'      AS country,\n    defendant_type,\n    AVG(days_to_completion) AS avg_days_to_completion\nFROM canada_criminal_trials\nGROUP BY defendant_type\n\nUNION ALL\n\nSELECT \n    'New Zealand' AS country,\n    defendant_type,\n    AVG(days_to_completion) AS avg_days_to_completion\nFROM nz_criminal_trials\nGROUP BY defendant_type;", "raw_model_output": "```sql\nSELECT \n    'Canada'      AS country,\n    defendant_type,\n    AVG(days_to_completion) AS avg_days_to_completion\nFROM canada_criminal_trials\nGROUP BY defendant_type\n\nUNION ALL\n\nSELECT \n    'New Zealand' AS country,\n    defendant_type,\n    AVG(days_to_completion) AS avg_days_to_completion\nFROM nz_criminal_trials\nGROUP BY defendant_type;\n```", "latency_sec": 3.033445119857788, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 207, "prompt_eval_sec": null, "tokens_completion": 165, "completion_eval_sec": null, "tokens_total": 372, "tokens_per_sec": 122.63284328593353, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in output structure. The Reference SQL returns only average durations without country information, while the Generated SQL includes a 'country' column and groups results by defendant_type. The Generated SQL's output has 4 rows (2 defendant types \u00d7 2 countries) with structured columns, whereas the Reference SQL returns 4 rows with unstructured averages. The semantic equivalence is broken by the additional 'country' column and different result formatting.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent due to differences in output structure. The reference query returns four separate averages without country context, while the generated query includes a 'country' column for clear comparison. Both calculate correct averages (60/45 for Canada, 70/50 for NZ), but the generated query better fulfills the business intent by explicitly linking averages to their respective countries. The generated query is more efficient (uses GROUP BY instead of multiple WHERE clauses) and produces a structured result that directly addresses the comparative nature of the question.", "overall_assessment": "differently_correct"}}
{"example_id": 2972, "sql_complexity": "set operations", "prompt": "How many indigenous communities are in the Arctic Research Station 13 and 14?", "context": "CREATE TABLE Arctic_Research_Station_13 (id INT, community TEXT); CREATE TABLE Arctic_Research_Station_14 (id INT, community TEXT);", "reference_sql": "SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_13; SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_14; SELECT COUNT(DISTINCT community) FROM (SELECT * FROM Arctic_Research_Station_13 UNION ALL SELECT * FROM Arctic_Research_Station_14) AS Arctic_Communities;", "generated_sql": "SELECT COUNT(*) AS indigenous_community_count\nFROM (\n    SELECT community FROM Arctic_Research_Station_13\n    UNION               -- UNION removes duplicates\n    SELECT community FROM Arctic_Research_Station_14\n) AS combined_communities;", "raw_model_output": "```sql\nSELECT COUNT(*) AS indigenous_community_count\nFROM (\n    SELECT community FROM Arctic_Research_Station_13\n    UNION               -- UNION removes duplicates\n    SELECT community FROM Arctic_Research_Station_14\n) AS combined_communities;\n```", "latency_sec": 4.061809778213501, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 114, "prompt_eval_sec": null, "tokens_completion": 265, "completion_eval_sec": null, "tokens_total": 379, "tokens_per_sec": 93.30816081857357, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of distinct communities across both tables. The Reference's third query uses COUNT(DISTINCT) on a UNION ALL result (which includes duplicates but then counts unique values), while the Generated SQL uses UNION (which removes duplicates before counting). Both approaches yield the same final count of unique communities.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL contains three separate queries: two that count distinct communities in each station individually, and a third that combines both stations using UNION ALL (which preserves duplicates). The Generated SQL correctly combines both stations using UNION (which removes duplicates) and counts the total unique communities. While both approaches aim to answer the question, the Generated SQL directly addresses the intent of finding unique communities across both stations. The Reference's third query would overcount duplicates, making it technically incorrect for the business question. The Generated SQL is more efficient and semantically precise.", "overall_assessment": "correct"}}
{"example_id": 5576, "sql_complexity": "window functions", "prompt": "Who are the top 5 users with the most followers, and what is their location?", "context": "CREATE TABLE user_data (user_id INT, name VARCHAR(50), followers INT, location VARCHAR(50)); INSERT INTO user_data (user_id, name, followers, location) VALUES (1, 'Alice', 10000, 'New York'), (2, 'Bob', 15000, 'California'), (3, 'Charlie', 12000, 'Texas'), (4, 'David', 8000, 'Florida'), (5, 'Eve', 9000, 'Illinois');", "reference_sql": "SELECT name, location FROM (SELECT name, location, ROW_NUMBER() OVER (ORDER BY followers DESC) AS rank FROM user_data) AS user_ranks WHERE rank <= 5;", "generated_sql": "SELECT\n    name,\n    location,\n    followers\nFROM\n    user_data\nORDER BY\n    followers DESC\nFETCH FIRST 5 ROWS ONLY;", "raw_model_output": "SELECT\n    name,\n    location,\n    followers\nFROM\n    user_data\nORDER BY\n    followers DESC\nFETCH FIRST 5 ROWS ONLY;", "latency_sec": 3.2044148445129395, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 188, "prompt_eval_sec": null, "tokens_completion": 179, "completion_eval_sec": null, "tokens_total": 367, "tokens_per_sec": 114.52949065831169, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL selects only 'name' and 'location' columns, while the Generated SQL includes 'followers' as well. Additionally, the Reference uses a subquery with ROW_NUMBER() for ranking, whereas the Generated uses FETCH FIRST 5 ROWS ONLY. Though both retrieve top 5 users by followers, the column sets differ.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly returns only 'name' and 'location' as requested, while the Generated SQL includes an extra 'followers' column not required by the question. Both queries would return the top 5 users by followers, but the Generated SQL's additional column makes it semantically incorrect for the business intent. The Reference uses a more robust ranking approach that handles ties explicitly, though the question doesn't specify tie-breaking requirements. The Generated SQL's FETCH FIRST syntax is database-specific, while the Reference uses standard SQL window functions.", "overall_assessment": "differently_correct"}}
{"example_id": 1560, "sql_complexity": "basic SQL", "prompt": "What is the average media literacy score for users in the 'Young Adult' age group who have completed at least one disinformation detection course?", "context": "CREATE TABLE users (id INT, age VARCHAR(20), media_literacy_score INT, courses_completed INT);", "reference_sql": "SELECT AVG(media_literacy_score) FROM users WHERE age = 'Young Adult' AND courses_completed > 0;", "generated_sql": "SELECT AVG(media_literacy_score) AS avg_media_literacy_score\nFROM   users\nWHERE  age = 'Young Adult'\n  AND  courses_completed >= 1;", "raw_model_output": "SELECT AVG(media_literacy_score) AS avg_media_literacy_score\nFROM   users\nWHERE  age = 'Young Adult'\n  AND  courses_completed >= 1;", "latency_sec": 2.346543073654175, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 117, "prompt_eval_sec": null, "tokens_completion": 120, "completion_eval_sec": null, "tokens_total": 237, "tokens_per_sec": 100.99963757789865, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The conditions 'courses_completed > 0' and 'courses_completed >= 1' are logically equivalent because courses_completed is an integer. Both ensure only rows with at least 1 course completed are included. The alias in the generated query does not affect semantic equivalence.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the average media literacy score for 'Young Adult' users with at least one completed course. The conditions 'courses_completed > 0' (reference) and 'courses_completed >= 1' (generated) are logically equivalent. The generated query adds an explicit alias, which improves readability but doesn't affect functionality. Both queries address the business intent by filtering the correct age group and course completion criteria. Neither query demonstrates superior efficiency or elegance over the other.", "overall_assessment": "correct"}}
{"example_id": 1201, "sql_complexity": "basic SQL", "prompt": "What is the maximum energy efficiency rating of hydroelectric dams in Canada?", "context": "CREATE TABLE hydro_dams (id INT, name TEXT, country TEXT, energy_efficiency_rating FLOAT); INSERT INTO hydro_dams (id, name, country, energy_efficiency_rating) VALUES (1, 'Robert-Bourassa', 'Canada', 0.94), (2, 'Churchill Falls', 'Canada', 0.92);", "reference_sql": "SELECT MAX(energy_efficiency_rating) FROM hydro_dams WHERE country = 'Canada';", "generated_sql": "SELECT\n    MAX(energy_efficiency_rating) AS max_energy_efficiency_rating\nFROM\n    hydro_dams\nWHERE\n    country = 'Canada';", "raw_model_output": "SELECT\n    MAX(energy_efficiency_rating) AS max_energy_efficiency_rating\nFROM\n    hydro_dams\nWHERE\n    country = 'Canada';", "latency_sec": 2.158958673477173, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 152, "prompt_eval_sec": null, "tokens_completion": 115, "completion_eval_sec": null, "tokens_total": 267, "tokens_per_sec": 123.67073222850324, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the maximum energy_efficiency_rating for dams in Canada. The generated query adds an alias to the result column, but this does not affect the semantic meaning or the actual value returned. The WHERE clause and aggregate function are identical in both queries.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate the maximum energy efficiency rating for Canadian hydroelectric dams. The reference query is more concise while the generated query adds an explicit alias. The semantic meaning and results are identical, as the MAX() function and WHERE clause are implemented identically. Both address the business intent of finding the highest efficiency rating in Canada. The generated query's alias improves readability but doesn't alter functionality. Neither query has performance advantages over the other.", "overall_assessment": "correct"}}
{"example_id": 4243, "sql_complexity": "single join", "prompt": "How many orders were placed by new and returning customers in each month of the year 2021?'", "context": "CREATE TABLE customer (id INT, first_order_date DATE, last_order_date DATE);", "reference_sql": "INSERT INTO customer (id, first_order_date, last_order_date) SELECT customer_id, MIN(order_date) AS first_order_date, MAX(order_date) AS last_order_date FROM orders GROUP BY customer_id; SELECT YEAR(order_date) AS year, MONTH(order_date) AS month, CASE WHEN DATEDIFF(last_order_date, first_order_date) > 30 THEN 'returning' ELSE 'new' END AS customer_type, COUNT(DISTINCT id) AS num_orders FROM orders JOIN customer ON orders.customer_id = customer.id WHERE YEAR(order_date) = 2021 GROUP BY year, month, customer_type;", "generated_sql": "/*  Orders in 2021 split by \u201cnew\u201d vs. \u201creturning\u201d customers\n    -------------------------------------------------------\n    \u2022 A \u201cnew-customer\u201d order is the customer\u2019s very first order, \n      so we count customers whose first_order_date falls in 2021.\n\n    \u2022 A \u201creturning-customer\u201d order is any order in 2021 placed by \n      a customer whose first order happened before 2021; with only\n      first_order_date / last_order_date available, we can at least\n      count one such order per returning customer (the fact that the\n      customer\u2019s last_order_date is in 2021 proves the customer ordered\n      during that year).\n\n    The query returns, for every month of 2021, the number of orders\n    coming from new customers and from returning customers.\n*/\nSELECT\n    EXTRACT(MONTH FROM order_date)                                AS month_2021,\n    SUM(new_orders)                                               AS new_customer_orders,\n    SUM(returning_orders)                                         AS returning_customer_orders\nFROM (\n    /* first order in 2021  \u2192 \u201cnew-customer\u201d order */\n    SELECT\n        first_order_date  AS order_date,\n        1                 AS new_orders,\n        0                 AS returning_orders\n    FROM customer\n    WHERE first_order_date BETWEEN DATE '2021-01-01' AND DATE '2021-12-31'\n    \n    UNION ALL\n    \n    /* any 2021 order by a customer whose first order was before 2021\n       \u2192 \u201creturning-customer\u201d order */\n    SELECT\n        last_order_date   AS order_date,\n        0                 AS new_orders,\n        1                 AS returning_orders\n    FROM customer\n    WHERE first_order_date < DATE '2021-01-01'\n      AND last_order_date  BETWEEN DATE '2021-01-01' AND DATE '2021-12-31'\n) AS orders_2021\nGROUP BY EXTRACT(MONTH FROM order_date)\nORDER BY month_2021;", "raw_model_output": "```sql\n/*  Orders in 2021 split by \u201cnew\u201d vs. \u201creturning\u201d customers\n    -------------------------------------------------------\n    \u2022 A \u201cnew-customer\u201d order is the customer\u2019s very first order, \n      so we count customers whose first_order_date falls in 2021.\n\n    \u2022 A \u201creturning-customer\u201d order is any order in 2021 placed by \n      a customer whose first order happened before 2021; with only\n      first_order_date / last_order_date available, we can at least\n      count one such order per returning customer (the fact that the\n      customer\u2019s last_order_date is in 2021 proves the customer ordered\n      during that year).\n\n    The query returns, for every month of 2021, the number of orders\n    coming from new customers and from returning customers.\n*/\nSELECT\n    EXTRACT(MONTH FROM order_date)                                AS month_2021,\n    SUM(new_orders)                                               AS new_customer_orders,\n    SUM(returning_orders)                                         AS returning_customer_orders\nFROM (\n    /* first order in 2021  \u2192 \u201cnew-customer\u201d order */\n    SELECT\n        first_order_date  AS order_date,\n        1                 AS new_orders,\n        0                 AS returning_orders\n    FROM customer\n    WHERE first_order_date BETWEEN DATE '2021-01-01' AND DATE '2021-12-31'\n    \n    UNION ALL\n    \n    /* any 2021 order by a customer whose first order was before 2021\n       \u2192 \u201creturning-customer\u201d order */\n    SELECT\n        last_order_date   AS order_date,\n        0                 AS new_orders,\n        1                 AS returning_orders\n    FROM customer\n    WHERE first_order_date < DATE '2021-01-01'\n      AND last_order_date  BETWEEN DATE '2021-01-01' AND DATE '2021-12-31'\n) AS orders_2021\nGROUP BY EXTRACT(MONTH FROM order_date)\nORDER BY month_2021;\n```", "latency_sec": 67.4730441570282, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 104, "prompt_eval_sec": null, "tokens_completion": 2619, "completion_eval_sec": null, "tokens_total": 2723, "tokens_per_sec": 40.356857082998, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their logic for determining 'new' vs. 'returning' customers. The Reference SQL uses the difference between first_order_date and last_order_date (>30 days) to classify customers, while the Generated SQL uses temporal boundaries (first_order_date in 2021 vs. before 2021). Additionally, the Generated SQL aggregates based on customer's first/last order dates directly, whereas the Reference SQL joins with the orders table and counts distinct customer IDs. The aggregation strategies and classification criteria are fundamentally different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL incorrectly determines customer_type using DATEDIFF(last_order_date, first_order_date) > 30, which doesn't align with the business definition of 'new' (first_order_date in 2021) vs. 'returning' (first_order_date before 2021). The Generated SQL correctly identifies new/returning customers based on first_order_date but has a critical flaw: it only counts one order per customer (first_order_date for new, last_order_date for returning), rather than all orders in 2021. This undercounts returning orders and fails to track monthly order volumes accurately. While the Generated SQL better aligns with the business intent by using first_order_date, both queries fail to properly count orders by month.", "overall_assessment": "differently_correct"}}
{"example_id": 2321, "sql_complexity": "subqueries", "prompt": "What are the names and types of vessels used in research expeditions in the regions with the lowest ocean acidification levels?", "context": "CREATE TABLE ocean_acidification (id INT PRIMARY KEY, region VARCHAR(255), year INT, acidification_level INT); INSERT INTO ocean_acidification (id, region, year, acidification_level) VALUES (1, 'Arctic Ocean', 2018, 20), (2, 'Southern Ocean', 2019, 22); CREATE TABLE expedition_vessels (id INT PRIMARY KEY, name VARCHAR(255), type VARCHAR(255), region VARCHAR(255)); INSERT INTO expedition_vessels (id, name, type, region) VALUES (1, 'Sea Researcher', 'Research Vessel', 'Arctic Ocean');", "reference_sql": "SELECT v.name, v.type FROM expedition_vessels v INNER JOIN ocean_acidification oa ON v.region = oa.region WHERE oa.acidification_level = (SELECT MIN(acidification_level) FROM ocean_acidification);", "generated_sql": "SELECT DISTINCT\n       ev.name,\n       ev.type\nFROM expedition_vessels AS ev\nJOIN (\n     -- Regions with the lowest recorded ocean acidification level\n     SELECT DISTINCT region\n     FROM ocean_acidification\n     WHERE acidification_level = (\n           SELECT MIN(acidification_level) \n           FROM ocean_acidification\n     )\n) AS lowest_regions\nON ev.region = lowest_regions.region;", "raw_model_output": "```sql\nSELECT DISTINCT\n       ev.name,\n       ev.type\nFROM expedition_vessels AS ev\nJOIN (\n     -- Regions with the lowest recorded ocean acidification level\n     SELECT DISTINCT region\n     FROM ocean_acidification\n     WHERE acidification_level = (\n           SELECT MIN(acidification_level) \n           FROM ocean_acidification\n     )\n) AS lowest_regions\nON ev.region = lowest_regions.region;\n```", "latency_sec": 5.048485040664673, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 222, "prompt_eval_sec": null, "tokens_completion": 298, "completion_eval_sec": null, "tokens_total": 520, "tokens_per_sec": 103.00119655926284, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL may return duplicate vessel entries if multiple ocean_acidification records exist for the same region with the minimum acidification level, while the Generated SQL explicitly uses DISTINCT to eliminate duplicates. The Generated SQL also filters regions first with a subquery, whereas the Reference SQL performs the join directly. This difference in handling duplicates and query structure makes them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries differ in how they handle regions with the same minimum acidification level. The reference query directly joins on region and filters by the minimum acidification_level, which could return duplicate vessels if multiple ocean_acidification records exist for the same region. The generated query first explicitly selects distinct regions with the minimum acidification level, then joins with vessels. This avoids duplicates and ensures only regions with the absolute minimum are considered. While both fulfill the business intent, the generated query is more robust, efficient, and elegant by isolating the region selection first.", "overall_assessment": "differently_correct"}}
{"example_id": 4349, "sql_complexity": "multiple_joins", "prompt": "Show the research grants awarded to professors in the Computer Science department.", "context": "CREATE TABLE departments (id INT, name VARCHAR(50)); INSERT INTO departments (id, name) VALUES (1, 'Computer Science'), (2, 'Mathematics'); CREATE TABLE professors (id INT, name VARCHAR(50), department_id INT); INSERT INTO professors (id, name, department_id) VALUES (1, 'John Smith', 1), (2, 'Jane Doe', 2); CREATE TABLE grants (id INT, professor_id INT, year INT, amount FLOAT); INSERT INTO grants (id, professor_id, year, amount) VALUES (1, 1, 2021, 5000.0), (2, 2, 2020, 7000.0);", "reference_sql": "SELECT professors.name, grants.amount FROM professors INNER JOIN grants ON professors.id = grants.professor_id INNER JOIN departments ON professors.department_id = departments.id WHERE departments.name = 'Computer Science';", "generated_sql": "SELECT \n    g.id AS grant_id,\n    p.name AS professor_name,\n    g.year,\n    g.amount\nFROM grants      AS g\nJOIN professors  AS p ON p.id = g.professor_id\nJOIN departments AS d ON d.id = p.department_id\nWHERE d.name = 'Computer Science';", "raw_model_output": "SELECT \n    g.id AS grant_id,\n    p.name AS professor_name,\n    g.year,\n    g.amount\nFROM grants      AS g\nJOIN professors  AS p ON p.id = g.professor_id\nJOIN departments AS d ON d.id = p.department_id\nWHERE d.name = 'Computer Science';", "latency_sec": 3.7622339725494385, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 226, "prompt_eval_sec": null, "tokens_completion": 211, "completion_eval_sec": null, "tokens_total": 437, "tokens_per_sec": 116.1543920948307, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects only 'professors.name' and 'grants.amount', while the Generated SQL selects four columns: 'g.id', 'p.name', 'g.year', and 'g.amount'. Although both filter for 'Computer Science' department, the result sets differ in column structure and content.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent due to differences in selected columns (reference includes only name/amount, generated includes grant_id/year) and formatting. Both correctly join departments, professors, and grants with the same filter condition, fulfilling the business intent of identifying CS department grants. The generated query is more comprehensive with explicit aliases and additional fields (grant_id, year) that could be valuable for analysis, while maintaining clarity through table aliases. The reference query is simpler but less detailed.", "overall_assessment": "differently_correct"}}
{"example_id": 476, "sql_complexity": "basic SQL", "prompt": "Insert new food safety records for locations \"A123\", \"B456\", and \"C789\"", "context": "CREATE TABLE food_safety_records (id INT, location VARCHAR(255), inspection_date DATE, violation_count INT);", "reference_sql": "INSERT INTO food_safety_records (location, inspection_date, violation_count) VALUES ('A123', '2022-03-01', 0), ('B456', '2022-03-05', 2), ('C789', '2022-03-10', 1);", "generated_sql": "INSERT INTO food_safety_records (id, location, inspection_date, violation_count)\nVALUES\n    (1, 'A123', CURRENT_DATE, 0),\n    (2, 'B456', CURRENT_DATE, 0),\n    (3, 'C789', CURRENT_DATE, 0);", "raw_model_output": "INSERT INTO food_safety_records (id, location, inspection_date, violation_count)\nVALUES\n    (1, 'A123', CURRENT_DATE, 0),\n    (2, 'B456', CURRENT_DATE, 0),\n    (3, 'C789', CURRENT_DATE, 0);", "latency_sec": 5.346152305603027, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 109, "prompt_eval_sec": null, "tokens_completion": 400, "completion_eval_sec": null, "tokens_total": 509, "tokens_per_sec": 95.20866052890848, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL inserts specific violation counts (0, 2, 1) and fixed inspection dates, while the Generated SQL uses CURRENT_DATE (which would insert the current date) and sets all violation_counts to 0. Additionally, the Generated SQL explicitly provides id values (1, 2, 3) that are not present in the Reference SQL. These differences in data values and column coverage make the results distinct.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent. The reference SQL inserts specific records with defined inspection dates and violation counts for each location, while the generated SQL uses CURRENT_DATE (which may not match the intended inspection dates) and sets violation_count to 0 for all entries. The generated SQL also includes an 'id' column, which is not mentioned in the original question or schema constraints, potentially violating implicit assumptions about auto-incrementing IDs. Although both fulfill the basic intent of inserting records for the specified locations, the generated SQL makes assumptions about default values that may not align with business requirements. The reference SQL more accurately addresses the explicit data requirements.", "overall_assessment": "differently_correct"}}
{"example_id": 2908, "sql_complexity": "single join", "prompt": "List all co-owners and the properties they own in New York, NY.", "context": "CREATE TABLE properties (id INT, city VARCHAR(50), price INT); CREATE TABLE co_owners (property_id INT, owner_name VARCHAR(50)); INSERT INTO properties (id, city, price) VALUES (1, 'New York', 800000), (2, 'Los Angeles', 600000); INSERT INTO co_owners (property_id, owner_name) VALUES (1, 'David'), (1, 'Ella'), (2, 'Frank');", "reference_sql": "SELECT properties.city, co_owners.owner_name FROM properties INNER JOIN co_owners ON properties.id = co_owners.property_id WHERE properties.city = 'New York';", "generated_sql": "SELECT\n    c.owner_name,\n    p.id AS property_id\nFROM\n    co_owners AS c\nJOIN\n    properties AS p\n      ON c.property_id = p.id\nWHERE\n    p.city = 'New York';", "raw_model_output": "```sql\nSELECT\n    c.owner_name,\n    p.id AS property_id\nFROM\n    co_owners AS c\nJOIN\n    properties AS p\n      ON c.property_id = p.id\nWHERE\n    p.city = 'New York';\n```", "latency_sec": 2.8849658966064453, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 177, "prompt_eval_sec": null, "tokens_completion": 200, "completion_eval_sec": null, "tokens_total": 377, "tokens_per_sec": 130.67745460820217, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries select different columns. The Reference SQL returns (city, owner_name) while the Generated SQL returns (owner_name, property_id). Although both filter properties in 'New York', the result sets have different structures and data (city vs. property_id).", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify co-owners of properties in New York (matching the 'New York' value in the database). The reference query includes the city column (redundant since all results are filtered to New York) and uses table-qualified column names, while the generated query uses aliases and explicitly selects property_id. The generated query is more concise and directly answers the 'properties they own' requirement by showing property IDs. Both are logically equivalent but the generated version better aligns with the business intent through its focus on property identifiers.", "overall_assessment": "correct"}}
{"example_id": 636, "sql_complexity": "set operations", "prompt": "Insert new data into the 'cosmetic_ingredients' table for a vegan eyeshadow product by brand 'Ara' with ingredients 'Mica', 'Iron Oxide', 'Titanium Dioxide' and 'Zinc Oxide'.", "context": "CREATE TABLE cosmetic_ingredients (ingredient_id INT, product_name TEXT, brand_name TEXT, ingredient_type TEXT);", "reference_sql": "INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type) VALUES (NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient'); INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type, ingredient_name) SELECT ingredient_id, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Mica' FROM cosmetic_ingredients WHERE ingredient_name = 'Mica' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Iron Oxide' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Titanium Dioxide' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Zinc Oxide';", "generated_sql": "INSERT INTO cosmetic_ingredients (product_name, brand_name, ingredient_type)\nVALUES\n  ('Vegan Eyeshadow', 'Ara', 'Mica'),\n  ('Vegan Eyeshadow', 'Ara', 'Iron Oxide'),\n  ('Vegan Eyeshadow', 'Ara', 'Titanium Dioxide'),\n  ('Vegan Eyeshadow', 'Ara', 'Zinc Oxide');", "raw_model_output": "INSERT INTO cosmetic_ingredients (product_name, brand_name, ingredient_type)\nVALUES\n  ('Vegan Eyeshadow', 'Ara', 'Mica'),\n  ('Vegan Eyeshadow', 'Ara', 'Iron Oxide'),\n  ('Vegan Eyeshadow', 'Ara', 'Titanium Dioxide'),\n  ('Vegan Eyeshadow', 'Ara', 'Zinc Oxide');", "latency_sec": 8.42102599143982, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 135, "prompt_eval_sec": null, "tokens_completion": 673, "completion_eval_sec": null, "tokens_total": 808, "tokens_per_sec": 95.95030354037048, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL attempts to insert into a non-existent 'ingredient_name' column and includes an initial row with 'ingredient_type' = 'Ingredient', while the Generated SQL directly inserts four rows with 'ingredient_type' as the actual ingredient names. Additionally, the Reference SQL's SELECT portion references a column ('ingredient_name') not present in the schema, making it invalid. The Generated SQL also omits the 'ingredient_id' column, which may be required depending on the database setup.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL contains critical errors: it references a non-existent 'ingredient_name' column in the schema and attempts to insert a generic 'Ingredient' type instead of the specific ingredients. The Generated SQL correctly inserts each ingredient into the 'ingredient_type' column (assuming this column is intended to store ingredient names, despite potential schema design ambiguity). While both queries aim to add data, the Generated SQL avoids syntax errors and directly addresses the requirement to insert the four specified ingredients. The Reference SQL's approach is invalid due to schema mismatch and incomplete logic.", "overall_assessment": "correct"}}
{"example_id": 3404, "sql_complexity": "multiple_joins", "prompt": "What are the names of startups that have received funding from investors with over 3 million funds, and are involved in Genetic Research or Bioprocess Engineering?", "context": "CREATE TABLE public.investors ( id SERIAL PRIMARY KEY, name VARCHAR(100), type VARCHAR(50), funds INTEGER ); CREATE TABLE public.investments ( id SERIAL PRIMARY KEY, investor_id INTEGER, startup_id INTEGER ); CREATE TABLE public.startups ( id SERIAL PRIMARY KEY, name VARCHAR(100), industry VARCHAR(50), funding INTEGER );", "reference_sql": "SELECT startups.name FROM public.startups JOIN public.investments ON startups.id = investments.startup_id JOIN public.investors ON investments.investor_id = investors.id WHERE (startups.industry = 'Genetic Research' OR startups.industry = 'Bioprocess Engineering') AND investors.funds > 3000000;", "generated_sql": "SELECT DISTINCT\n       s.name\nFROM public.startups      AS s\nJOIN public.investments   AS iv ON iv.startup_id = s.id\nJOIN public.investors     AS i  ON i.id = iv.investor_id\nWHERE i.funds > 3000000\n  AND s.industry IN ('Genetic Research', 'Bioprocess Engineering');", "raw_model_output": "SELECT DISTINCT\n       s.name\nFROM public.startups      AS s\nJOIN public.investments   AS iv ON iv.startup_id = s.id\nJOIN public.investors     AS i  ON i.id = iv.investor_id\nWHERE i.funds > 3000000\n  AND s.industry IN ('Genetic Research', 'Bioprocess Engineering');", "latency_sec": 3.7956368923187256, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 166, "prompt_eval_sec": null, "tokens_completion": 289, "completion_eval_sec": null, "tokens_total": 455, "tokens_per_sec": 119.87448033313956, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their handling of duplicate results. The Reference SQL omits DISTINCT, potentially returning duplicate startup names if multiple investments exist, while the Generated SQL explicitly uses DISTINCT to eliminate duplicates. The semantic equivalence depends on data uniqueness, but without guarantees of unique (startup, investor) pairs, the result sets may differ.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "While both queries address the core business intent, they differ technically. The generated query uses `DISTINCT` to eliminate duplicate startup names (which could occur if a startup has multiple qualifying investors), whereas the reference query might return duplicates. Semantically, both filter startups in the specified industries with investors having >3M funds. The generated query is more elegant and precise for the business intent, as it ensures unique startup names. The reference query's lack of `DISTINCT` makes it less robust for reporting purposes.", "overall_assessment": "differently_correct"}}
{"example_id": 134, "sql_complexity": "subqueries", "prompt": "Who are the top 3 authors with the most citations in the Mathematics department in the past 5 years?", "context": "CREATE TABLE authors (id INT, name VARCHAR(50), department VARCHAR(50)); INSERT INTO authors (id, name, department) VALUES (1, 'Author Name', 'Mathematics'); CREATE TABLE publications (id INT, title VARCHAR(100), author VARCHAR(50), journal VARCHAR(50), year INT, cites INT); INSERT INTO publications (id, title, author, journal, year, cites) VALUES (1, 'Publication Title', 'Author Name', 'Journal Name', 2021, 10);", "reference_sql": "SELECT author, SUM(cites) as total_cites FROM publications WHERE author IN (SELECT name FROM authors WHERE department = 'Mathematics') AND year BETWEEN YEAR(CURRENT_DATE) - 5 AND YEAR(CURRENT_DATE) GROUP BY author ORDER BY total_cites DESC LIMIT 3;", "generated_sql": "SELECT\n    a.name,\n    SUM(p.cites) AS total_citations\nFROM authors AS a\nJOIN publications AS p\n      ON p.author = a.name\nWHERE a.department = 'Mathematics'\n  AND p.year >= EXTRACT(YEAR FROM CURRENT_DATE) - 4  -- past 5 years (current year inclusive)\nGROUP BY a.name\nORDER BY total_citations DESC\nFETCH FIRST 3 ROWS ONLY;", "raw_model_output": "SELECT\n    a.name,\n    SUM(p.cites) AS total_citations\nFROM authors AS a\nJOIN publications AS p\n      ON p.author = a.name\nWHERE a.department = 'Mathematics'\n  AND p.year >= EXTRACT(YEAR FROM CURRENT_DATE) - 4  -- past 5 years (current year inclusive)\nGROUP BY a.name\nORDER BY total_citations DESC\nFETCH FIRST 3 ROWS ONLY;", "latency_sec": 5.443471908569336, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 195, "prompt_eval_sec": null, "tokens_completion": 302, "completion_eval_sec": null, "tokens_total": 497, "tokens_per_sec": 91.30202347836172, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their year range conditions. The Reference SQL uses `BETWEEN YEAR(CURRENT_DATE) - 5 AND YEAR(CURRENT_DATE)` which includes 6 years (e.g., 2018-2023 for 2023), while the Generated SQL uses `p.year >= EXTRACT(YEAR FROM CURRENT_DATE) - 4` which includes 5 years (e.g., 2019-2023). This discrepancy in the time window affects the results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries differ in two key aspects. 1) The year range calculation: the Reference SQL uses `BETWEEN YEAR(CURRENT_DATE) - 5 AND YEAR(CURRENT_DATE)` which includes 6 years (e.g., 2018-2023 if current year is 2023), while the Generated SQL uses `p.year >= EXTRACT(YEAR FROM CURRENT_DATE) - 4` which correctly captures the past 5 years (e.g., 2019-2023). 2) The approach to filter Mathematics department authors: the Reference uses a subquery, while the Generated uses a JOIN. The JOIN approach is more efficient and avoids potential issues with duplicate author names. The Generated SQL also uses `FETCH FIRST 3 ROWS ONLY` which is more standard than `LIMIT 3`. While both queries aim to find the top 3 authors, the Reference's year range is incorrect, making it less accurate in fulfilling the business intent.", "overall_assessment": "differently_correct"}}
{"example_id": 592, "sql_complexity": "set operations", "prompt": "How many public healthcare facilities and public parks are there in total, in the 'StateData' schema's 'StateHealthcare' and 'StateParks' tables?", "context": "CREATE SCHEMA StateData; CREATE TABLE StateHealthcare (Name varchar(255), Type varchar(255)); INSERT INTO StateHealthcare (Name, Type) VALUES ('FacilityA', 'Public'), ('FacilityB', 'Public'), ('FacilityC', 'Private'); CREATE TABLE StateParks (Name varchar(255), Type varchar(255)); INSERT INTO StateParks (Name, Type) VALUES ('ParkA', 'Public'), ('ParkB', 'Public'), ('ParkC', 'Private');", "reference_sql": "SELECT COUNT(*) FROM StateData.StateHealthcare WHERE Type = 'Public' UNION ALL SELECT COUNT(*) FROM StateData.StateParks WHERE Type = 'Public';", "generated_sql": "SELECT \n    (SELECT COUNT(*) FROM StateData.StateHealthcare WHERE Type = 'Public') +\n    (SELECT COUNT(*) FROM StateData.StateParks      WHERE Type = 'Public') AS total_public_facilities_parks;", "raw_model_output": "SELECT \n    (SELECT COUNT(*) FROM StateData.StateHealthcare WHERE Type = 'Public') +\n    (SELECT COUNT(*) FROM StateData.StateParks      WHERE Type = 'Public') AS total_public_facilities_parks;", "latency_sec": 4.374253034591675, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 199, "prompt_eval_sec": null, "tokens_completion": 256, "completion_eval_sec": null, "tokens_total": 455, "tokens_per_sec": 104.01775946701105, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate count values as individual rows (e.g., 2 and 2), while the Generated SQL returns a single row with the summed total (e.g., 4). The output structure differs, so they are not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query uses UNION ALL to return two separate counts (healthcare and parks) as two rows, while the generated query calculates a single summed total. The original question asks for a 'total' count, which requires aggregation of both values. The generated query correctly combines the counts using addition, whereas the reference query provides separate values. Both are technically correct but differ in result structure. The generated query better fulfills the business intent of providing a single total value.", "overall_assessment": "differently_correct"}}
{"example_id": 1989, "sql_complexity": "single join", "prompt": "What are the names and production dates of garments made from fabrics with a sustainability score over 70, produced after 2021-01-01?", "context": "CREATE TABLE fabrics (id INT, name VARCHAR(50), type VARCHAR(50), sustainability_score INT); INSERT INTO fabrics (id, name, type, sustainability_score) VALUES (1, 'Organic Linen', 'Natural', 80); INSERT INTO fabrics (id, name, type, sustainability_score) VALUES (2, 'Recycled Nylon', 'Synthetic', 72);", "reference_sql": "SELECT garments.name, garments.production_date FROM garments JOIN fabrics ON garments.fabric_id = fabrics.id WHERE fabrics.sustainability_score > 70 AND garments.production_date > '2021-01-01';", "generated_sql": "Unable to generate a valid SQL statement: the required information about garments (e.g., a garments table with name, production_date, and fabric reference) is not present in the provided schema.", "raw_model_output": "Unable to generate a valid SQL statement: the required information about garments (e.g., a garments table with name, production_date, and fabric reference) is not present in the provided schema.", "latency_sec": 6.593414068222046, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 172, "prompt_eval_sec": null, "tokens_completion": 569, "completion_eval_sec": null, "tokens_total": 741, "tokens_per_sec": 112.38487259147902, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Generated SQL cannot be validated because the required 'garments' table structure is missing from the schema. The Reference SQL assumes the existence of a 'garments' table with 'name', 'production_date', and 'fabric_id' columns, which are not defined in the provided database schema. Since the Generated SQL is invalid and the Reference SQL references undefined schema elements, they cannot be semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL assumes the existence of a 'garments' table with columns 'name', 'production_date', and 'fabric_id', but the provided schema only defines the 'fabrics' table. The Generated SQL correctly identifies this missing information as invalid. While the Reference SQL's logic is technically sound if the garments table existed, it cannot execute with the given schema. Neither query fully fulfills the intent due to schema limitations, but the Generated SQL accurately highlights the data deficiency.", "overall_assessment": "differently_correct"}}
{"example_id": 1388, "sql_complexity": "aggregation", "prompt": "What was the total donation amount by each organization in the last 30 days?", "context": "CREATE TABLE organization_donations (id INT, organization TEXT, donation_date DATE, donation_amount DECIMAL(10,2)); INSERT INTO organization_donations (id, organization, donation_date, donation_amount) VALUES (1, 'Organization A', '2021-03-15', 100.00), (2, 'Organization B', '2021-03-25', 200.00);", "reference_sql": "SELECT organization, SUM(donation_amount) FROM organization_donations WHERE donation_date >= DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY) GROUP BY organization;", "generated_sql": "SELECT\n    organization,\n    SUM(donation_amount) AS total_donation_amount\nFROM organization_donations\nWHERE donation_date >= CURRENT_DATE - INTERVAL '30' DAY\nGROUP BY organization;", "raw_model_output": "```sql\nSELECT\n    organization,\n    SUM(donation_amount) AS total_donation_amount\nFROM organization_donations\nWHERE donation_date >= CURRENT_DATE - INTERVAL '30' DAY\nGROUP BY organization;\n```", "latency_sec": 3.727550983428955, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 166, "prompt_eval_sec": null, "tokens_completion": 192, "completion_eval_sec": null, "tokens_total": 358, "tokens_per_sec": 96.04161058869747, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of donation_amount for each organization where donation_date is within the last 30 days. The date calculation syntax differs (DATE_SUB vs. CURRENT_DATE - INTERVAL), but both expressions evaluate to the same date range. The generated query adds an alias for the sum, but this doesn't affect the semantic result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries are technically correct and produce equivalent results. The reference query uses DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY) while the generated query uses CURRENT_DATE - INTERVAL '30' DAY. Both calculate the 30-day window accurately. The generated query adds an explicit alias (total_donation_amount) which improves readability and clarity, making it slightly more elegant. Both fulfill the business intent of aggregating donations by organization for the last 30 days.", "overall_assessment": "correct"}}
{"example_id": 1628, "sql_complexity": "window functions", "prompt": "What is the ranking of national security measures for Russia based on the publication date?", "context": "CREATE TABLE national_security (id INT, title VARCHAR(255), description TEXT, agency VARCHAR(255), date DATE); INSERT INTO national_security (id, title, description, agency, date) VALUES (1, 'National Cyber Strategy', 'Outlines the approach to protecting the American people and the American way of life in the digital age', 'White House', '2018-09-20'); INSERT INTO national_security (id, title, description, agency, date) VALUES (2, 'Cybersecurity and Infrastructure Security Agency Act of 2018', 'Establishes the Cybersecurity and Infrastructure Security Agency within the Department of Homeland Security', 'Congress', '2018-11-16'); INSERT INTO national_security (id, title, description, agency, date) VALUES (3, 'Russian Military Doctrine', 'Outlines the country\u2019s stance on military security', 'Russian Government', '2014-12-26');", "reference_sql": "SELECT title, description, agency, date, ROW_NUMBER() OVER (PARTITION BY agency ORDER BY date DESC) as ranking FROM national_security WHERE agency = 'Russian Government';", "generated_sql": "SELECT\n    id,\n    title,\n    date,\n    RANK() OVER (ORDER BY date) AS publication_date_rank\nFROM national_security\nWHERE agency = 'Russian Government'\nORDER BY publication_date_rank;", "raw_model_output": "SELECT\n    id,\n    title,\n    date,\n    RANK() OVER (ORDER BY date) AS publication_date_rank\nFROM national_security\nWHERE agency = 'Russian Government'\nORDER BY publication_date_rank;", "latency_sec": 5.328071117401123, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 271, "prompt_eval_sec": null, "tokens_completion": 318, "completion_eval_sec": null, "tokens_total": 589, "tokens_per_sec": 110.54657248781186, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL selects title, description, agency, date, and a ROW_NUMBER() ranking partitioned by agency (with date DESC), while the Generated SQL selects id, title, date, and a RANK() ranking ordered by date (ascending). Additionally, the Generated SQL includes an ORDER BY clause that isn't present in the Reference SQL. Although both filter for 'Russian Government', the columns returned differ, and the ranking logic (ROW_NUMBER vs RANK) and ordering direction (DESC vs ASC) would produce different results for multiple rows.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The queries are not technically equivalent due to differences in ranking logic and ordering. The Reference SQL uses ROW_NUMBER() with date DESC to rank Russia's measures from most recent to oldest, while the Generated SQL uses RANK() with date ASC, ranking from oldest to most recent. The original question lacks explicit ordering direction, but 'ranking based on publication date' typically implies descending order (latest first). The Reference query also includes more descriptive fields (title, description, agency) aligning better with the intent to 'rank measures' rather than just dates. The Generated query's use of RANK() could create ties, whereas ROW_NUMBER() ensures unique ranks. Both queries filter correctly for 'Russian Government', but the Reference better addresses the implicit need for chronological ranking.", "overall_assessment": "differently_correct"}}
{"example_id": 2300, "sql_complexity": "aggregation", "prompt": "What is the minimum capacity for schools in each location ('community_development')?", "context": "CREATE TABLE community_development.schools (id INT, name VARCHAR(50), capacity INT, location VARCHAR(50));", "reference_sql": "SELECT location, MIN(capacity) FROM community_development.schools GROUP BY location;", "generated_sql": "SELECT\n    location,\n    MIN(capacity) AS min_capacity\nFROM\n    community_development.schools\nGROUP BY\n    location;", "raw_model_output": "```sql\nSELECT\n    location,\n    MIN(capacity) AS min_capacity\nFROM\n    community_development.schools\nGROUP BY\n    location;\n```", "latency_sec": 3.591586112976074, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 106, "prompt_eval_sec": null, "tokens_completion": 180, "completion_eval_sec": null, "tokens_total": 286, "tokens_per_sec": 79.63055625109698, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries group schools by location and calculate the minimum capacity per location. The generated query adds an explicit column alias ('min_capacity'), but this does not affect the semantic result. The GROUP BY clause and aggregate function remain identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly group by location and calculate the minimum capacity per group. The generated query improves upon the reference by explicitly aliasing the MIN(capacity) result as 'min_capacity', which enhances readability and clarity without altering the semantic meaning. While the reference query is technically valid, the generated version is more elegant and practical for downstream use cases like reporting or data analysis. Both satisfy the business requirement of identifying the minimum school capacity per location.", "overall_assessment": "correct"}}
{"example_id": 4976, "sql_complexity": "set operations", "prompt": "What is the most common hashtag used in posts made by users from Brazil?", "context": "CREATE TABLE posts (id INT, user_id INT, content TEXT, hashtags TEXT, post_date DATE); INSERT INTO posts (id, user_id, content, hashtags, post_date) VALUES (1, 1, 'Hello World', '#datascience', '2022-06-01'), (2, 1, 'I love data', '#ai', '2022-06-02'), (3, 2, 'Ol\u00e1 Mundo', '#brasil', '2022-06-03'); CREATE TABLE users (id INT, name VARCHAR(100), country VARCHAR(50)); INSERT INTO users (id, name, country) VALUES (1, 'Jo\u00e3o Silva', 'Brazil'), (2, 'Maria Souza', 'Brazil');", "reference_sql": "SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(hashtags, ' ', n.n), ' ', -1) hashtag, COUNT(*) count FROM posts JOIN users ON posts.user_id = users.id CROSS JOIN (SELECT 1 n UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5) n WHERE users.country = 'Brazil' GROUP BY hashtag ORDER BY count DESC LIMIT 1;", "generated_sql": "SELECT\n    p.hashtags AS most_common_hashtag\nFROM\n    posts  AS p\nJOIN\n    users  AS u ON p.user_id = u.id\nWHERE\n    u.country = 'Brazil'\nGROUP BY\n    p.hashtags\nORDER BY\n    COUNT(*) DESC\nFETCH FIRST 1 ROW ONLY;", "raw_model_output": "SELECT\n    p.hashtags AS most_common_hashtag\nFROM\n    posts  AS p\nJOIN\n    users  AS u ON p.user_id = u.id\nWHERE\n    u.country = 'Brazil'\nGROUP BY\n    p.hashtags\nORDER BY\n    COUNT(*) DESC\nFETCH FIRST 1 ROW ONLY;", "latency_sec": 4.17403507232666, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 234, "prompt_eval_sec": null, "tokens_completion": 214, "completion_eval_sec": null, "tokens_total": 448, "tokens_per_sec": 107.33019541934014, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL splits multi-word hashtags into individual entries using SUBSTRING_INDEX and a numbers table, while the Generated SQL treats the entire hashtags field as a single string. This difference causes them to handle posts with multiple hashtags (e.g., '#a #b') differently - the Reference SQL would count '#a' and '#b' separately, while the Generated SQL would treat them as a single hashtag value. The Generated SQL also lacks the cross-join logic to handle multiple hashtags per post.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The Reference SQL correctly handles the denormalized hashtags column by splitting multi-value strings into individual hashtags using SUBSTRING_INDEX. The Generated SQL incorrectly groups by the entire hashtags string (e.g., '#datascience #ai' as a single value) rather than individual hashtags. While both filter Brazilian users, the Reference properly counts individual hashtags, whereas the Generated SQL would fail to split multi-hashtag posts. The Reference also uses a numbers table approach which is standard for such splitting, while the Generated SQL's FETCH FIRST 1 ROW ONLY is functionally equivalent to LIMIT 1 but less portable.", "overall_assessment": "correct"}}
{"example_id": 4637, "sql_complexity": "single join", "prompt": "What is the total value of transactions for each customer in the last 30 days?", "context": "CREATE TABLE transactions (id INT, customer_id INT, value DECIMAL(10, 2), transaction_date DATE); INSERT INTO transactions (id, customer_id, value, transaction_date) VALUES (1, 1, 100, '2022-01-01'), (2, 1, 200, '2022-01-15'), (3, 2, 50, '2022-01-05'), (4, 2, 150, '2022-01-30'), (5, 3, 300, '2022-01-20');", "reference_sql": "SELECT c.id, SUM(t.value) FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE t.transaction_date >= CURDATE() - INTERVAL 30 DAY GROUP BY c.id;", "generated_sql": "SELECT\n    customer_id,\n    SUM(value) AS total_value\nFROM\n    transactions\nWHERE\n    transaction_date >= CURRENT_DATE - INTERVAL '30' DAY\nGROUP BY\n    customer_id;", "raw_model_output": "```sql\nSELECT\n    customer_id,\n    SUM(value) AS total_value\nFROM\n    transactions\nWHERE\n    transaction_date >= CURRENT_DATE - INTERVAL '30' DAY\nGROUP BY\n    customer_id;\n```", "latency_sec": 3.969040870666504, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 207, "prompt_eval_sec": null, "tokens_completion": 257, "completion_eval_sec": null, "tokens_total": 464, "tokens_per_sec": 116.90481784383401, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of transaction values for each customer over the last 30 days. The Reference SQL uses an INNER JOIN with customers (which is redundant since transactions already contain customer_id) and groups by c.id. The Generated SQL directly groups by customer_id from transactions, achieving the same result. The date filter (CURDATE() - INTERVAL 30 DAY vs CURRENT_DATE - INTERVAL '30' DAY) is functionally equivalent in this context, assuming the database system treats them identically. Both return customer_id and total_value for customers with transactions in the specified period.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the total transaction value per customer for the last 30 days. The Reference SQL uses an unnecessary JOIN with the customers table, which adds overhead without providing additional value since the customer_id is already in the transactions table. The Generated SQL is more efficient by directly querying the transactions table and avoids redundant joins. The date calculation syntax differs (CURDATE() vs CURRENT_DATE), but both achieve the same temporal filtering. The Generated SQL is more elegant and efficient while maintaining semantic equivalence.", "overall_assessment": "correct"}}
{"example_id": 4947, "sql_complexity": "aggregation", "prompt": "What is the total revenue for drugs approved between 2017 and 2019?", "context": "CREATE TABLE drug_sales_3 (drug_name TEXT, revenue FLOAT, year INT); INSERT INTO drug_sales_3 (drug_name, revenue, year) VALUES ('DrugG', 20000000, 2019), ('DrugG', 19000000, 2018), ('DrugH', 15000000, 2017), ('DrugH', 16000000, 2018);", "reference_sql": "SELECT drug_name, SUM(revenue) FROM drug_sales_3 WHERE year BETWEEN 2017 AND 2019 GROUP BY drug_name;", "generated_sql": "SELECT \n    SUM(revenue) AS total_revenue\nFROM \n    drug_sales_3\nWHERE \n    year BETWEEN 2017 AND 2019;", "raw_model_output": "SELECT \n    SUM(revenue) AS total_revenue\nFROM \n    drug_sales_3\nWHERE \n    year BETWEEN 2017 AND 2019;", "latency_sec": 3.173257827758789, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 167, "prompt_eval_sec": null, "tokens_completion": 116, "completion_eval_sec": null, "tokens_total": 283, "tokens_per_sec": 89.18279426411357, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL groups results by drug_name and calculates per-drug revenue sums, while the Generated SQL lacks a GROUP BY clause and returns a single total revenue value for all drugs combined. The presence of drug_name in the SELECT list and the GROUP BY clause in the Reference SQL ensures per-drug aggregation, which is missing in the Generated SQL.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query groups results by drug_name, returning per-drug totals, while the generated query calculates a single total revenue across all drugs in the specified period. The original question asks for 'total revenue' (singular), which aligns with the generated query's output. The reference query's grouping introduces unnecessary complexity and would not produce the same result set. Both queries are technically correct but differ in semantic intent. The generated query better fulfills the business requirement by directly answering the question as phrased.", "overall_assessment": "differently_correct"}}
{"example_id": 4767, "sql_complexity": "window functions", "prompt": "List the top 2 AI algorithms with the highest explainability scores, by algorithm subtype, ordered by scores in descending order for the European region.", "context": "CREATE TABLE ai_algorithms (algorithm_id INT, algorithm_name VARCHAR(50), algorithm_subtype VARCHAR(50), region VARCHAR(50), explainability_score FLOAT); INSERT INTO ai_algorithms (algorithm_id, algorithm_name, algorithm_subtype, region, explainability_score) VALUES (1, 'AlgoA', 'Tree-based', 'Europe', 0.85), (2, 'AlgoB', 'Computer Vision', 'Europe', 0.92), (3, 'AlgoC', 'Tree-based', 'Europe', 0.78), (4, 'AlgoD', 'Transformer', 'Europe', 0.90), (5, 'AlgoE', 'Tree-based', 'Europe', 0.80);", "reference_sql": "SELECT algorithm_subtype, region, * FROM (SELECT algorithm_subtype, region, algorithm_id, algorithm_name, explainability_score, RANK() OVER (PARTITION BY algorithm_subtype ORDER BY explainability_score DESC) AS rank FROM ai_algorithms WHERE region = 'Europe') ranked WHERE rank <= 2 ORDER BY algorithm_subtype, region, explainability_score DESC;", "generated_sql": "SELECT\n    algorithm_subtype,\n    algorithm_name,\n    explainability_score\nFROM (\n    SELECT\n        algorithm_subtype,\n        algorithm_name,\n        explainability_score,\n        ROW_NUMBER() OVER (PARTITION BY algorithm_subtype\n                           ORDER BY explainability_score DESC) AS rn\n    FROM ai_algorithms\n    WHERE region = 'Europe'\n) ranked\nWHERE rn <= 2\nORDER BY\n    algorithm_subtype,\n    explainability_score DESC;", "raw_model_output": "```sql\nSELECT\n    algorithm_subtype,\n    algorithm_name,\n    explainability_score\nFROM (\n    SELECT\n        algorithm_subtype,\n        algorithm_name,\n        explainability_score,\n        ROW_NUMBER() OVER (PARTITION BY algorithm_subtype\n                           ORDER BY explainability_score DESC) AS rn\n    FROM ai_algorithms\n    WHERE region = 'Europe'\n) ranked\nWHERE rn <= 2\nORDER BY\n    algorithm_subtype,\n    explainability_score DESC;\n```", "latency_sec": 5.8175048828125, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 245, "prompt_eval_sec": null, "tokens_completion": 502, "completion_eval_sec": null, "tokens_total": 747, "tokens_per_sec": 128.4055647648824, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects all columns (via *) along with algorithm_subtype and region, while the Generated SQL only selects specific columns (algorithm_subtype, algorithm_name, explainability_score). Additionally, the Reference SQL uses RANK() while the Generated SQL uses ROW_NUMBER(), which could produce different results if there are ties in explainability_score. However, the primary discrepancy is the differing column selections, which ensures the result sets are not identical.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent due to differences in ranking functions (RANK() vs ROW_NUMBER()) and column selection. The Reference SQL includes redundant columns (e.g., algorithm_id, region) and uses RANK(), which may return more than 2 rows per subtype if there are ties. The Generated SQL explicitly selects only required columns and uses ROW_NUMBER(), ensuring exactly 2 rows per subtype. Both filter for Europe and order by explainability score, but the Generated SQL better aligns with the business intent by focusing on relevant data and avoiding unnecessary complexity.", "overall_assessment": "differently_correct"}}
{"example_id": 4495, "sql_complexity": "basic SQL", "prompt": "Which countries are the top 3 sources of sustainable textiles?", "context": "CREATE TABLE Textile_Sources (Source_ID INT, Source_Country TEXT, Sustainable BOOLEAN, Quantity INT); INSERT INTO Textile_Sources (Source_ID, Source_Country, Sustainable, Quantity) VALUES (1, 'India', true, 1000), (2, 'Bangladesh', false, 800), (3, 'China', true, 1200), (4, 'Vietnam', false, 900), (5, 'Italy', true, 1100), (6, 'USA', false, 700);", "reference_sql": "SELECT Source_Country FROM Textile_Sources WHERE Sustainable = true ORDER BY Quantity DESC LIMIT 3;", "generated_sql": "SELECT\n    Source_Country\nFROM\n    Textile_Sources\nWHERE\n    Sustainable = TRUE\nORDER BY\n    Quantity DESC\nFETCH FIRST 3 ROWS ONLY;", "raw_model_output": "SELECT\n    Source_Country\nFROM\n    Textile_Sources\nWHERE\n    Sustainable = TRUE\nORDER BY\n    Quantity DESC\nFETCH FIRST 3 ROWS ONLY;", "latency_sec": 2.4382269382476807, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 187, "prompt_eval_sec": null, "tokens_completion": 119, "completion_eval_sec": null, "tokens_total": 306, "tokens_per_sec": 125.50103323028573, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select Source_Country from Textile_Sources where Sustainable is true, order by Quantity descending, and limit to 3 rows. The difference is purely syntactic: 'LIMIT 3' (reference) and 'FETCH FIRST 3 ROWS ONLY' (generated) are functionally equivalent in SQL standards and produce the same result set.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly filter sustainable sources (Sustainable = TRUE), order by Quantity descending, and limit to 3 results. The Reference SQL uses LIMIT 3 (common in MySQL/PostgreSQL), while the Generated SQL uses FETCH FIRST 3 ROWS ONLY (standard SQL syntax). Both produce identical results: China (1200), Italy (1100), India (1000). The difference is purely syntactic and does not affect outcome or business intent. Neither query is more efficient or elegant than the other in this context.", "overall_assessment": "correct"}}
{"example_id": 2513, "sql_complexity": "single join", "prompt": "What is the total number of concert ticket sales for artists who released their first album between 2015 and 2017?", "context": "CREATE TABLE ConcertTicketSales (id INT, year INT, artist_id INT); CREATE TABLE ArtistAlbums (id INT, artist_id INT, year INT);", "reference_sql": "SELECT COUNT(DISTINCT cts.artist_id) FROM ConcertTicketSales cts JOIN ArtistAlbums a ON cts.artist_id = a.artist_id WHERE a.year BETWEEN 2015 AND 2017;", "generated_sql": "WITH first_album AS (\n    SELECT artist_id,\n           MIN(year) AS first_release_year\n    FROM ArtistAlbums\n    GROUP BY artist_id\n)\nSELECT COUNT(*) AS total_ticket_sales\nFROM ConcertTicketSales c\nJOIN first_album f\n  ON c.artist_id = f.artist_id\nWHERE f.first_release_year BETWEEN 2015 AND 2017;", "raw_model_output": "```sql\nWITH first_album AS (\n    SELECT artist_id,\n           MIN(year) AS first_release_year\n    FROM ArtistAlbums\n    GROUP BY artist_id\n)\nSELECT COUNT(*) AS total_ticket_sales\nFROM ConcertTicketSales c\nJOIN first_album f\n  ON c.artist_id = f.artist_id\nWHERE f.first_release_year BETWEEN 2015 AND 2017;\n```", "latency_sec": 5.047483205795288, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 122, "prompt_eval_sec": null, "tokens_completion": 353, "completion_eval_sec": null, "tokens_total": 475, "tokens_per_sec": 94.10630617940974, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the reference query counts DISTINCT artist_ids, while the generated query counts all rows (COUNT(*)), which would overcount artists with multiple ticket sales. Second, the reference filters on any album year between 2015-2017, whereas the generated query filters on the artist's first album year in that range. This means the generated query excludes artists who had later albums in the range but first released before 2015.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The queries are not technically equivalent. The reference query incorrectly counts artists who have *any* album between 2015-2017, not just those whose *first* album falls in that range. The generated query properly identifies artists' first album years using a CTE and filters on that. While both count artists, the generated query accurately addresses the business intent of identifying artists whose *first* album was between 2015-2017. The reference query would overcount artists with later albums in the range. The generated query is more precise and fulfills the intent correctly.", "overall_assessment": "differently_correct"}}
{"example_id": 873, "sql_complexity": "subqueries", "prompt": "Identify attorneys who have never handled cases in the 'West' region but have in the 'North' or 'South'.", "context": "CREATE TABLE attorney_regions(attorney_id INT, region VARCHAR(20)); INSERT INTO attorney_regions(attorney_id, region) VALUES (1, 'North'), (2, 'South'), (3, 'East'), (4, 'West'), (5, 'West'), (6, 'North'); CREATE TABLE handled_cases(attorney_id INT, case_id INT); INSERT INTO handled_cases(attorney_id, case_id) VALUES (1, 101), (2, 102), (3, 103), (4, 104), (5, 105), (6, 106), (1, 107), (1, 108);", "reference_sql": "SELECT h.attorney_id FROM attorney_regions h LEFT JOIN handled_cases i ON h.attorney_id = i.attorney_id WHERE h.region IN ('North', 'South') AND h.region != 'West' AND i.attorney_id IS NOT NULL AND h.attorney_id NOT IN (SELECT attorney_id FROM attorney_regions WHERE region = 'West');", "generated_sql": "SELECT DISTINCT hc.attorney_id\nFROM handled_cases      AS hc\nJOIN attorney_regions   AS ar\n  ON ar.attorney_id = hc.attorney_id\nWHERE ar.region IN ('North', 'South')          -- has handled in North or South\n  AND hc.attorney_id NOT IN (                  -- but never in West\n        SELECT attorney_id\n        FROM attorney_regions\n        WHERE region = 'West'\n      );", "raw_model_output": "```sql\nSELECT DISTINCT hc.attorney_id\nFROM handled_cases      AS hc\nJOIN attorney_regions   AS ar\n  ON ar.attorney_id = hc.attorney_id\nWHERE ar.region IN ('North', 'South')          -- has handled in North or South\n  AND hc.attorney_id NOT IN (                  -- but never in West\n        SELECT attorney_id\n        FROM attorney_regions\n        WHERE region = 'West'\n      );\n```", "latency_sec": 11.261569023132324, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 224, "prompt_eval_sec": null, "tokens_completion": 878, "completion_eval_sec": null, "tokens_total": 1102, "tokens_per_sec": 97.85492569786574, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select attorney_ids from North/South regions who have handled cases and are not in West. The Reference SQL uses a LEFT JOIN with a NULL check (equivalent to INNER JOIN) and excludes West via a NOT IN subquery. The Generated SQL uses an INNER JOIN and the same NOT IN subquery. Both achieve identical filtering and join logic, producing the same result set.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly identify attorneys with cases in North/South but not West. The Reference SQL uses a LEFT JOIN with redundant conditions (h.region IN ('North', 'South') AND h.region != 'West') since IN already excludes West. The Generated SQL uses a more efficient INNER JOIN and avoids this redundancy. Both produce same results, but Generated is more elegant and efficient with explicit JOINs and DISTINCT. The Reference's subquery is correct but the LEFT JOIN/IS NOT NULL pattern is less optimal than INNER JOIN.", "overall_assessment": "correct"}}
{"example_id": 471, "sql_complexity": "set operations", "prompt": "Find the number of donations made by first-time donors in the last quarter.", "context": "CREATE TABLE Donations (DonationID INT, DonorID INT, DonationDate DATE, DonationType TEXT, DonationAmount FLOAT); INSERT INTO Donations (DonationID, DonorID, DonationDate, DonationType, DonationAmount) VALUES (1, 1, '2021-01-01', 'Individual', 100), (2, 2, '2021-02-01', 'Corporate', 5000);", "reference_sql": "SELECT COUNT(*) FROM (SELECT DonationID FROM Donations WHERE DonationType = 'Individual' AND DonationDate >= DATEADD(quarter, -1, CURRENT_DATE) EXCEPT SELECT DonationID FROM PreviousDonations) AS FirstTimeDonors;", "generated_sql": "WITH\n/* Determine the calendar year and quarter that\n   immediately precede the current quarter. */\nlast_qtr AS (\n    SELECT\n        CASE\n            WHEN EXTRACT(QUARTER FROM CURRENT_DATE) = 1\n                 THEN EXTRACT(YEAR FROM CURRENT_DATE) - 1\n            ELSE EXTRACT(YEAR FROM CURRENT_DATE)\n        END  AS yr,\n        CASE\n            WHEN EXTRACT(QUARTER FROM CURRENT_DATE) = 1\n                 THEN 4\n            ELSE EXTRACT(QUARTER FROM CURRENT_DATE) - 1\n        END AS qtr\n),\n\n/* Identify the first-ever donation made by each donor. */\nfirst_donors AS (\n    SELECT  DonorID,\n            MIN(DonationDate)                      AS first_donation_date,\n            EXTRACT(YEAR    FROM MIN(DonationDate)) AS first_year,\n            EXTRACT(QUARTER FROM MIN(DonationDate)) AS first_quarter\n    FROM Donations\n    GROUP BY DonorID\n)\n\n/* Count donations that\n   1) were made in the last quarter, and\n   2) came from donors whose very first donation also occurred in that same quarter. */\nSELECT COUNT(*) AS number_of_donations\nFROM   Donations            d\nJOIN   first_donors         fd ON fd.DonorID = d.DonorID\nJOIN   last_qtr             lq ON fd.first_year    = lq.yr\n                                AND fd.first_quarter = lq.qtr\nWHERE  EXTRACT(YEAR    FROM d.DonationDate)   = lq.yr\n  AND  EXTRACT(QUARTER FROM d.DonationDate)   = lq.qtr;", "raw_model_output": "```sql\nWITH\n/* Determine the calendar year and quarter that\n   immediately precede the current quarter. */\nlast_qtr AS (\n    SELECT\n        CASE\n            WHEN EXTRACT(QUARTER FROM CURRENT_DATE) = 1\n                 THEN EXTRACT(YEAR FROM CURRENT_DATE) - 1\n            ELSE EXTRACT(YEAR FROM CURRENT_DATE)\n        END  AS yr,\n        CASE\n            WHEN EXTRACT(QUARTER FROM CURRENT_DATE) = 1\n                 THEN 4\n            ELSE EXTRACT(QUARTER FROM CURRENT_DATE) - 1\n        END AS qtr\n),\n\n/* Identify the first-ever donation made by each donor. */\nfirst_donors AS (\n    SELECT  DonorID,\n            MIN(DonationDate)                      AS first_donation_date,\n            EXTRACT(YEAR    FROM MIN(DonationDate)) AS first_year,\n            EXTRACT(QUARTER FROM MIN(DonationDate)) AS first_quarter\n    FROM Donations\n    GROUP BY DonorID\n)\n\n/* Count donations that\n   1) were made in the last quarter, and\n   2) came from donors whose very first donation also occurred in that same quarter. */\nSELECT COUNT(*) AS number_of_donations\nFROM   Donations            d\nJOIN   first_donors         fd ON fd.DonorID = d.DonorID\nJOIN   last_qtr             lq ON fd.first_year    = lq.yr\n                                AND fd.first_quarter = lq.qtr\nWHERE  EXTRACT(YEAR    FROM d.DonationDate)   = lq.yr\n  AND  EXTRACT(QUARTER FROM d.DonationDate)   = lq.qtr;\n```", "latency_sec": 22.707969665527344, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 168, "prompt_eval_sec": null, "tokens_completion": 1786, "completion_eval_sec": null, "tokens_total": 1954, "tokens_per_sec": 86.04908447479303, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses EXCEPT to find Individual donations in the last quarter not present in PreviousDonations, while the Generated SQL counts donations in the last quarter from donors whose first donation was in that same quarter. The logic and conditions differ: the first compares against a separate table (PreviousDonations), while the second focuses on first-time donors. The schema also lacks definition for PreviousDonations, making equivalence impossible.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL is invalid due to referencing a non-existent 'PreviousDonations' table, making it technically incorrect. The Generated SQL correctly identifies first-time donors by finding donors whose first donation occurred in the last quarter (using CTEs to calculate the last quarter and filter by first donation date). It then counts all donations in that quarter from those donors, which aligns with the business intent of counting donations from first-time donors in the last quarter. The Generated SQL is both syntactically valid and semantically correct, while the Reference SQL fails due to schema inconsistency.", "overall_assessment": "incorrect"}}
{"example_id": 1301, "sql_complexity": "multiple_joins", "prompt": "What is the total quantity of corn sold by farmers in 'Summerfield'?", "context": "CREATE TABLE farmers (id INT, name VARCHAR(50), location VARCHAR(50), crops VARCHAR(50)); CREATE TABLE crops (id INT, name VARCHAR(50), yield INT); CREATE TABLE sales (id INT, farmer_id INT, crop_name VARCHAR(50), quantity INT, price DECIMAL(5,2)); INSERT INTO farmers VALUES (1, 'Jane Doe', 'Summerfield', 'Corn'); INSERT INTO crops VALUES (1, 'Corn', 100); INSERT INTO sales VALUES (1, 1, 'Corn', 50, 2.50);", "reference_sql": "SELECT SUM(quantity) FROM sales INNER JOIN farmers ON sales.farmer_id = farmers.id INNER JOIN crops ON sales.crop_name = crops.name WHERE farmers.location = 'Summerfield' AND crops.name = 'Corn';", "generated_sql": "SELECT \n    SUM(s.quantity) AS total_quantity\nFROM \n    sales   AS s\nJOIN \n    farmers AS f  ON f.id = s.farmer_id\nWHERE \n    f.location = 'Summerfield'\n    AND s.crop_name = 'Corn';", "raw_model_output": "SELECT \n    SUM(s.quantity) AS total_quantity\nFROM \n    sales   AS s\nJOIN \n    farmers AS f  ON f.id = s.farmer_id\nWHERE \n    f.location = 'Summerfield'\n    AND s.crop_name = 'Corn';", "latency_sec": 3.095395088195801, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 199, "prompt_eval_sec": null, "tokens_completion": 138, "completion_eval_sec": null, "tokens_total": 337, "tokens_per_sec": 108.87140103217831, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of quantities from sales where the farmer is located in 'Summerfield' and the crop is 'Corn'. The Reference SQL joins with the crops table but filters on crops.name = 'Corn', which is equivalent to filtering on sales.crop_name = 'Corn' (since the join ensures sales.crop_name matches crops.name). The Generated SQL directly filters on sales.crop_name, achieving the same result without the unnecessary join. The final output is identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the total corn quantity sold by Summerfield farmers. The reference query includes an unnecessary JOIN with the 'crops' table and redundant WHERE condition (crops.name = 'Corn') since the sales.crop_name column directly provides the required filter. The generated query simplifies the logic by eliminating the redundant join and directly filtering on sales.crop_name = 'Corn', achieving the same result with better efficiency. Both address the business intent, but the generated query is more elegant and performant.", "overall_assessment": "correct"}}
{"example_id": 4667, "sql_complexity": "aggregation", "prompt": "Find the number of unique organizations in each country in the Philanthropy Trends table?", "context": "CREATE TABLE PhilanthropyTrends (OrgID INT, Name TEXT, Country TEXT);", "reference_sql": "SELECT Country, COUNT(DISTINCT OrgID) as UniqueOrganizations FROM PhilanthropyTrends GROUP BY Country;", "generated_sql": "SELECT\n    Country,\n    COUNT(DISTINCT OrgID) AS num_unique_organizations\nFROM PhilanthropyTrends\nGROUP BY Country;", "raw_model_output": "```sql\nSELECT\n    Country,\n    COUNT(DISTINCT OrgID) AS num_unique_organizations\nFROM PhilanthropyTrends\nGROUP BY Country;\n```", "latency_sec": 2.865661144256592, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 101, "prompt_eval_sec": null, "tokens_completion": 117, "completion_eval_sec": null, "tokens_total": 218, "tokens_per_sec": 76.07319533815762, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries group by 'Country' and count distinct 'OrgID's. The only differences are the column alias name ('UniqueOrganizations' vs 'num_unique_organizations') and minor formatting (space after comma). Semantic meaning remains identical.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are syntactically correct and semantically equivalent. They both group by 'Country' and count distinct 'OrgID' values to determine unique organizations per country. The only difference is the column alias name ('UniqueOrganizations' vs 'num_unique_organizations'), which doesn't affect result accuracy or business intent fulfillment. Both queries efficiently address the requirement to count unique organizations by country.", "overall_assessment": "correct"}}
{"example_id": 1006, "sql_complexity": "subqueries", "prompt": "What is the average word count of news articles written by investigative journalists?", "context": "CREATE TABLE reporters (id INT, name VARCHAR(50), gender VARCHAR(10), age INT, position VARCHAR(20), country VARCHAR(50)); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (1, 'Anna Smith', 'Female', 35, 'News Reporter', 'USA'); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (2, 'Mike Johnson', 'Male', 40, 'Investigative Journalist', 'Canada'); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (3, 'Sofia Rodriguez', 'Female', 32, 'Investigative Journalist', 'Mexico'); CREATE TABLE news_articles (id INT, title VARCHAR(100), content TEXT, publication_date DATE, reporter_id INT); INSERT INTO news_articles (id, title, content, publication_date, reporter_id) VALUES (1, 'News Article 1', 'Content of News Article 1', '2021-01-01', 2); INSERT INTO news_articles (id, title, content, publication_date, reporter_id) VALUES (2, 'News Article 2', 'Content of News Article 2', '2021-02-01', 3);", "reference_sql": "SELECT AVG(LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1) AS avg_word_count FROM news_articles WHERE reporter_id IN (SELECT id FROM reporters WHERE position = 'Investigative Journalist');", "generated_sql": "SELECT AVG(word_cnt) AS average_word_count\nFROM (\n    SELECT \n        (CHARACTER_LENGTH(na.content) \n         - CHARACTER_LENGTH(REPLACE(na.content, ' ', '')) \n         + 1) AS word_cnt\n    FROM news_articles AS na\n    JOIN reporters AS r\n      ON na.reporter_id = r.id\n    WHERE r.position = 'Investigative Journalist'\n) AS t;", "raw_model_output": "SELECT AVG(word_cnt) AS average_word_count\nFROM (\n    SELECT \n        (CHARACTER_LENGTH(na.content) \n         - CHARACTER_LENGTH(REPLACE(na.content, ' ', '')) \n         + 1) AS word_cnt\n    FROM news_articles AS na\n    JOIN reporters AS r\n      ON na.reporter_id = r.id\n    WHERE r.position = 'Investigative Journalist'\n) AS t;", "latency_sec": 6.057049989700317, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 340, "prompt_eval_sec": null, "tokens_completion": 425, "completion_eval_sec": null, "tokens_total": 765, "tokens_per_sec": 126.29910621521049, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average word count of news articles written by investigative journalists. The Reference SQL uses a subquery with IN to filter reporters, while the Generated SQL uses a JOIN. The word count calculation (LENGTH vs CHARACTER_LENGTH) is functionally equivalent in most SQL implementations. Both approaches correctly filter articles by reporters with the 'Investigative Journalist' position and compute the same average.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly calculate the average word count of articles by investigative journalists. The reference uses a subquery with LENGTH(), while the generated query uses CHARACTER_LENGTH() (equivalent in most SQL implementations) and a JOIN. The generated query's explicit JOIN clarifies the relationship between tables, and the subquery structure avoids potential issues with correlated subqueries. Both handle edge cases (e.g., empty content) similarly, but the generated query's syntax is more explicit and potentially more efficient.", "overall_assessment": "correct"}}
{"example_id": 3635, "sql_complexity": "set operations", "prompt": "Which brands have certifications related to cruelty-free, vegan, or organic products?", "context": "CREATE TABLE brands (brand_name VARCHAR(50), is_cruelty_free BOOLEAN, is_vegan BOOLEAN, is_organic BOOLEAN); INSERT INTO brands (brand_name, is_cruelty_free, is_vegan, is_organic) VALUES ('Lush', TRUE, TRUE, FALSE), ('The Body Shop', TRUE, FALSE, FALSE), ('Est\u00e9e Lauder', FALSE, FALSE, FALSE), ('Urban Decay', TRUE, TRUE, FALSE), ('Maybelline', FALSE, FALSE, FALSE), ('Kat Von D', TRUE, TRUE, FALSE), ('Tarte', TRUE, TRUE, TRUE);", "reference_sql": "SELECT brand_name, 'Cruelty-free' as certification FROM brands WHERE is_cruelty_free = TRUE UNION SELECT brand_name, 'Vegan' as certification FROM brands WHERE is_vegan = TRUE UNION SELECT brand_name, 'Organic' as certification FROM brands WHERE is_organic = TRUE;", "generated_sql": "SELECT\n  brand_name\nFROM\n  brands\nWHERE\n  is_cruelty_free = TRUE\n  OR is_vegan = TRUE\n  OR is_organic = TRUE;", "raw_model_output": "SELECT\n  brand_name\nFROM\n  brands\nWHERE\n  is_cruelty_free = TRUE\n  OR is_vegan = TRUE\n  OR is_organic = TRUE;", "latency_sec": 2.9881699085235596, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 208, "prompt_eval_sec": null, "tokens_completion": 186, "completion_eval_sec": null, "tokens_total": 394, "tokens_per_sec": 131.85327878315778, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns each certification type as a separate row for brands that meet any of the criteria, while the Generated SQL returns a single row per brand that meets any criterion. For example, a brand that is both cruelty-free and vegan would appear twice in the Reference SQL result but only once in the Generated SQL result. The output structures and row counts differ.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query returns each certification type as a separate row for qualifying brands (e.g., a brand with multiple certifications would appear multiple times), while the generated query returns each brand once per certification type. However, the original question asks for brands with any of these certifications, not the specific types. The generated query correctly identifies brands with at least one certification through OR conditions, which is more efficient and directly addresses the business intent. The reference query provides more granular certification type information but isn't required by the question. Both queries are technically correct, but the generated version better fulfills the intent with simpler logic.", "overall_assessment": "correct"}}
{"example_id": 4932, "sql_complexity": "basic SQL", "prompt": "Delete the workout row with the id of 2.", "context": "CREATE TABLE Workouts (id INT, user_id INT, workout_name TEXT, calories INT); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (1, 1, 'Running', 300); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (2, 1, 'Cycling', 400); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (3, 2, 'Yoga', 200);", "reference_sql": "DELETE FROM Workouts WHERE id = 2;", "generated_sql": "DELETE FROM Workouts\nWHERE id = 2;", "raw_model_output": "DELETE FROM Workouts\nWHERE id = 2;", "latency_sec": 1.3542311191558838, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 181, "prompt_eval_sec": null, "tokens_completion": 30, "completion_eval_sec": null, "tokens_total": 211, "tokens_per_sec": 155.80796882848182, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. The only difference is the formatting (line break after DELETE), which does not affect SQL execution. Both delete the workout with id=2 from the Workouts table.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are syntactically identical except for whitespace formatting. The DELETE statement correctly targets the Workout with id=2 in both cases. The line break in the generated SQL does not affect execution logic or results. Both queries perfectly fulfill the business intent of deleting the specified workout row. Neither version is more efficient or elegant than the other.", "overall_assessment": "correct"}}
{"example_id": 365, "sql_complexity": "aggregation", "prompt": "Identify the total number of military personnel and their corresponding rank for each branch and country in the 'military_personnel' table, sorted by the total number of personnel in descending order.", "context": "CREATE TABLE military_personnel (id INT, branch VARCHAR(255), rank VARCHAR(255), country VARCHAR(255), personnel INT);", "reference_sql": "SELECT branch, country, SUM(personnel) as total_personnel FROM military_personnel GROUP BY branch, country ORDER BY total_personnel DESC;", "generated_sql": "SELECT\n    branch,\n    country,\n    rank,\n    SUM(personnel) AS total_personnel\nFROM\n    military_personnel\nGROUP BY\n    branch,\n    country,\n    rank\nORDER BY\n    total_personnel DESC;", "raw_model_output": "```sql\nSELECT\n    branch,\n    country,\n    rank,\n    SUM(personnel) AS total_personnel\nFROM\n    military_personnel\nGROUP BY\n    branch,\n    country,\n    rank\nORDER BY\n    total_personnel DESC;\n```", "latency_sec": 5.542040109634399, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 130, "prompt_eval_sec": null, "tokens_completion": 392, "completion_eval_sec": null, "tokens_total": 522, "tokens_per_sec": 94.18914148465728, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query groups by only 'branch' and 'country', aggregating all ranks within each branch-country combination. The generated query adds 'rank' to the GROUP BY clause, causing aggregation at the branch-country-rank level instead of just branch-country. Additionally, the generated query includes 'rank' in the output columns, which the reference query does not. These differences in grouping and selected columns produce distinct results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly groups by branch and country to calculate total personnel per combination, aligning with the original question's requirement for 'each branch and country'. The Generated SQL incorrectly adds 'rank' to the GROUP BY clause, which splits results by rank within branches/countries, contradicting the original question's intent. While the original question mentions 'corresponding rank', this is ambiguous\u2014however, the Reference SQL's approach of aggregating totals without rank is more logically consistent with the phrasing 'for each branch and country'. The Generated SQL's inclusion of rank introduces unnecessary granularity and fails to address the actual business requirement.", "overall_assessment": "incorrect"}}
{"example_id": 521, "sql_complexity": "subqueries", "prompt": "How many vessels have not had an inspection in the past year?", "context": "CREATE TABLE safety_records(id INT, vessel_name VARCHAR(50), inspection_date DATE); CREATE TABLE vessels(id INT, name VARCHAR(50), country VARCHAR(50)); INSERT INTO vessels(id, name, country) VALUES (1, 'Vessel A', 'Philippines'), (2, 'Vessel B', 'Philippines'); INSERT INTO safety_records(id, vessel_name, inspection_date) VALUES (1, 'Vessel A', '2022-01-01');", "reference_sql": "SELECT COUNT(*) FROM vessels WHERE name NOT IN (SELECT vessel_name FROM safety_records WHERE inspection_date BETWEEN DATE_SUB(NOW(), INTERVAL 1 YEAR) AND NOW());", "generated_sql": "SELECT COUNT(*) AS vessels_without_recent_inspection\nFROM vessels v\nWHERE NOT EXISTS (\n    SELECT 1\n    FROM safety_records s\n    WHERE s.vessel_name = v.name\n      AND s.inspection_date >= CURRENT_DATE - INTERVAL '1' YEAR\n);", "raw_model_output": "SELECT COUNT(*) AS vessels_without_recent_inspection\nFROM vessels v\nWHERE NOT EXISTS (\n    SELECT 1\n    FROM safety_records s\n    WHERE s.vessel_name = v.name\n      AND s.inspection_date >= CURRENT_DATE - INTERVAL '1' YEAR\n);", "latency_sec": 4.485322952270508, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 175, "prompt_eval_sec": null, "tokens_completion": 204, "completion_eval_sec": null, "tokens_total": 379, "tokens_per_sec": 84.49781744437088, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count vessels without a safety record in the last year. The Reference SQL uses NOT IN with a subquery filtering by date range, while the Generated SQL uses NOT EXISTS with an equivalent date condition. The date calculations (DATE_SUB vs CURRENT_DATE - INTERVAL) are functionally similar for DATE-typed inspection_date. Both handle the same logic of excluding vessels with recent inspections, and the NOT EXISTS approach avoids potential NULL issues in NOT IN. The result set and aggregation are identical.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent due to differences in date calculation syntax. The Reference SQL uses MySQL-compatible DATE_SUB(NOW(), INTERVAL 1 YEAR), while the Generated SQL uses CURRENT_DATE - INTERVAL '1' YEAR, which is invalid in MySQL (requires '1 YEAR' with space). Both correctly identify vessels without recent inspections via NOT IN/NOT EXISTS, but the Generated SQL's date syntax would fail in MySQL. Both fulfill the business intent, but the Reference is technically correct for the context.", "overall_assessment": "differently_correct"}}
{"example_id": 5687, "sql_complexity": "multiple_joins", "prompt": "List organizations with more than 200 volunteers, and their average donation amounts, excluding donations less than $10.", "context": "CREATE TABLE organizations (org_id INT, org_name TEXT, social_impact_score INT);CREATE TABLE volunteers (vol_id INT, org_id INT, vol_country TEXT);CREATE TABLE donations (donation_id INT, donor_id INT, donation_amount INT, donation_date DATE);", "reference_sql": "SELECT o.org_name, AVG(donation_amount) AS avg_donation_amount FROM organizations o JOIN volunteers v ON o.org_id = v.org_id JOIN donations don ON o.org_id = don.org_id WHERE donation_amount >= 10 GROUP BY o.org_name HAVING COUNT(v.vol_id) > 200;", "generated_sql": "SELECT\n    o.org_name,\n    AVG(d.donation_amount) AS average_donation_amount\nFROM organizations  AS o\nJOIN volunteers      AS v ON v.org_id  = o.org_id          -- link volunteers to their organization\nJOIN donations       AS d ON d.donor_id = v.vol_id         -- link donations (via volunteer = donor)\nWHERE d.donation_amount >= 10                               -- exclude donations under $10\nGROUP BY o.org_id, o.org_name\nHAVING (                                                  -- keep only orgs with > 200 volunteers\n        SELECT COUNT(*)\n        FROM volunteers v2\n        WHERE v2.org_id = o.org_id\n       ) > 200;", "raw_model_output": "SELECT\n    o.org_name,\n    AVG(d.donation_amount) AS average_donation_amount\nFROM organizations  AS o\nJOIN volunteers      AS v ON v.org_id  = o.org_id          -- link volunteers to their organization\nJOIN donations       AS d ON d.donor_id = v.vol_id         -- link donations (via volunteer = donor)\nWHERE d.donation_amount >= 10                               -- exclude donations under $10\nGROUP BY o.org_id, o.org_name\nHAVING (                                                  -- keep only orgs with > 200 volunteers\n        SELECT COUNT(*)\n        FROM volunteers v2\n        WHERE v2.org_id = o.org_id\n       ) > 200;", "latency_sec": 17.821601152420044, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 143, "prompt_eval_sec": null, "tokens_completion": 1312, "completion_eval_sec": null, "tokens_total": 1455, "tokens_per_sec": 81.64249595510792, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their join conditions between donations and volunteers. The Reference SQL joins donations to organizations (o.org_id = don.org_id), while the Generated SQL joins donations to volunteers via donor_id = vol_id. This changes the dataset being aggregated, leading to different results. Additionally, the Generated SQL uses a subquery in HAVING which, while logically similar, depends on the correctness of the join condition. The different join logic makes the queries non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL contains a critical technical error: it attempts to join the donations table on a non-existent 'org_id' column. The donations table schema does not include an 'org_id', making this join invalid. The Generated SQL, while having a questionable join condition (donor_id = vol_id), correctly uses a subquery in the HAVING clause to count volunteers, which is more accurate than the Reference's COUNT(v.vol_id) approach. The Generated SQL also properly groups by org_id and org_name, ensuring uniqueness. However, the join between donations and volunteers via donor_id = vol_id is ambiguous without explicit schema validation. Despite this, the Generated SQL's structure better addresses the business intent by accurately counting volunteers and avoiding potential grouping issues with org_name. The Reference SQL fails due to the invalid join, making it technically incorrect.", "overall_assessment": "incorrect"}}
{"example_id": 1281, "sql_complexity": "subqueries", "prompt": "Find the top 3 contributors with the lowest recycling rate in the 'waste_contributors' table.", "context": "CREATE TABLE waste_contributors (contributor VARCHAR(20), recycling_rate FLOAT); INSERT INTO waste_contributors (contributor, recycling_rate) VALUES ('Manufacturing', 0.4), ('Commercial', 0.38), ('Residential', 0.35), ('Institutional', 0.32), ('Agricultural', 0.2), ('Industrial', 0.15);", "reference_sql": "SELECT contributor FROM waste_contributors WHERE recycling_rate IN (SELECT MIN(recycling_rate) FROM waste_contributors) LIMIT 3;", "generated_sql": "SELECT\n    contributor,\n    recycling_rate\nFROM\n    waste_contributors\nORDER BY\n    recycling_rate ASC\nFETCH FIRST 3 ROWS ONLY;", "raw_model_output": "```sql\nSELECT\n    contributor,\n    recycling_rate\nFROM\n    waste_contributors\nORDER BY\n    recycling_rate ASC\nFETCH FIRST 3 ROWS ONLY;\n```", "latency_sec": 3.324838876724243, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 167, "prompt_eval_sec": null, "tokens_completion": 119, "completion_eval_sec": null, "tokens_total": 286, "tokens_per_sec": 86.01920592368013, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query selects contributors with the minimum recycling rate (which is 0.15, 'Industrial') and limits to 3 rows. The generated query orders all contributors by ascending recycling rate and returns the top 3 lowest values (Industrial, Agricultural, Institutional). The first query returns only the minimum-value row(s), while the second returns the three lowest values, which may include non-minimal values. Additionally, the generated query includes an extra column ('recycling_rate') not present in the reference query.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query incorrectly identifies contributors with the absolute minimum recycling rate (which may be a single value) and applies a LIMIT 3, which would only return ties for the minimum rate. However, the original question asks for the *top 3 contributors with the lowest recycling rates* (i.e., the three smallest values), not just the minimum. The generated query properly sorts by recycling_rate in ascending order and fetches the first 3 rows, ensuring it captures the three lowest rates regardless of ties. While both queries are technically valid SQL, only the generated query aligns with the business intent of retrieving the three lowest recycling rates.", "overall_assessment": "differently_correct"}}
{"example_id": 5669, "sql_complexity": "window functions", "prompt": "What is the total number of new and returning volunteers in each program in each month?", "context": "CREATE TABLE Volunteers (VolunteerID INT, VolunteerName TEXT, ProgramID INT, VolunteerDate DATE, IsReturning BOOLEAN); INSERT INTO Volunteers (VolunteerID, VolunteerName, ProgramID, VolunteerDate, IsReturning) VALUES (6, 'David Kim', 1, '2022-03-01', FALSE), (7, 'Emily Chen', 2, '2022-03-15', TRUE), (8, 'James Lee', 2, '2022-04-01', FALSE), (9, 'Grace Park', 3, '2022-04-15', TRUE), (10, 'Daniel Kim', 1, '2022-04-01', FALSE);", "reference_sql": "SELECT ProgramID, EXTRACT(MONTH FROM VolunteerDate) AS Month, SUM(CASE WHEN IsReturning THEN 1 ELSE 0 END) OVER (PARTITION BY ProgramID, EXTRACT(MONTH FROM VolunteerDate) ORDER BY ProgramID, EXTRACT(MONTH FROM VolunteerDate)) + COUNT(DISTINCT VolunteerID) OVER (PARTITION BY ProgramID, EXTRACT(MONTH FROM VolunteerDate) ORDER BY ProgramID, EXTRACT(MONTH FROM VolunteerDate)) AS TotalVolunteers FROM Volunteers;", "generated_sql": "SELECT \n    ProgramID,\n    EXTRACT(YEAR  FROM VolunteerDate)  AS volunteer_year,\n    EXTRACT(MONTH FROM VolunteerDate)  AS volunteer_month,\n    \n    /* totals by type */\n    SUM(CASE WHEN IsReturning = FALSE THEN 1 ELSE 0 END) AS new_volunteers,\n    SUM(CASE WHEN IsReturning = TRUE  THEN 1 ELSE 0 END) AS returning_volunteers\nFROM Volunteers\nGROUP BY\n    ProgramID,\n    EXTRACT(YEAR  FROM VolunteerDate),\n    EXTRACT(MONTH FROM VolunteerDate)\nORDER BY\n    ProgramID,\n    volunteer_year,\n    volunteer_month;", "raw_model_output": "```sql\nSELECT \n    ProgramID,\n    EXTRACT(YEAR  FROM VolunteerDate)  AS volunteer_year,\n    EXTRACT(MONTH FROM VolunteerDate)  AS volunteer_month,\n    \n    /* totals by type */\n    SUM(CASE WHEN IsReturning = FALSE THEN 1 ELSE 0 END) AS new_volunteers,\n    SUM(CASE WHEN IsReturning = TRUE  THEN 1 ELSE 0 END) AS returning_volunteers\nFROM Volunteers\nGROUP BY\n    ProgramID,\n    EXTRACT(YEAR  FROM VolunteerDate),\n    EXTRACT(MONTH FROM VolunteerDate)\nORDER BY\n    ProgramID,\n    volunteer_year,\n    volunteer_month;\n```", "latency_sec": 34.220457315444946, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 227, "prompt_eval_sec": null, "tokens_completion": 860, "completion_eval_sec": null, "tokens_total": 1087, "tokens_per_sec": 31.76462517668918, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL returns all rows with window functions calculating cumulative totals per ProgramID and month, while the Generated SQL groups data by ProgramID, year, and month to aggregate new/returning volunteer counts. The output structure, column definitions, and calculation logic differ significantly. The Reference SQL's 'TotalVolunteers' combines two window functions, whereas the Generated SQL separates new and returning volunteers into distinct columns.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is technically flawed and fails to fulfill the business intent. It incorrectly uses window functions to sum returning volunteers and add them to a distinct count of all volunteers, which would double-count returning volunteers and misrepresent the data. The Generated SQL properly groups by ProgramID, year, and month, then separately calculates new and returning volunteers using conditional aggregation. While the Reference SQL's output structure is invalid (combining counts into a single 'TotalVolunteers' column), the Generated SQL explicitly separates new and returning counts as required. The Generated SQL also correctly extracts both year and month for proper temporal grouping, whereas the Reference SQL only extracts the month. The Generated SQL is more efficient, semantically accurate, and directly addresses the business question.", "overall_assessment": "incorrect"}}
{"example_id": 3576, "sql_complexity": "window functions", "prompt": "What is the difference in the number of eco-friendly hotels between the top 2 countries?", "context": "CREATE TABLE eco_hotel_count (country TEXT, num_hotels INT); INSERT INTO eco_hotel_count (country, num_hotels) VALUES ('France', 100), ('Italy', 120), ('Germany', 150), ('Spain', 110), ('UK', 160);", "reference_sql": "SELECT (MAX(num_hotels) OVER (PARTITION BY num_hotels <= 2) - MIN(num_hotels) OVER (PARTITION BY num_hotels <= 2)) AS hotel_difference FROM eco_hotel_count WHERE country IN ('France', 'Italy');", "generated_sql": "SELECT\n  MAX(num_hotels) - MIN(num_hotels) AS difference_between_top_two\nFROM (\n  SELECT num_hotels\n  FROM eco_hotel_count\n  ORDER BY num_hotels DESC\n  FETCH FIRST 2 ROWS ONLY\n) AS top2;", "raw_model_output": "SELECT\n  MAX(num_hotels) - MIN(num_hotels) AS difference_between_top_two\nFROM (\n  SELECT num_hotels\n  FROM eco_hotel_count\n  ORDER BY num_hotels DESC\n  FETCH FIRST 2 ROWS ONLY\n) AS top2;", "latency_sec": 4.817957878112793, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 143, "prompt_eval_sec": null, "tokens_completion": 332, "completion_eval_sec": null, "tokens_total": 475, "tokens_per_sec": 98.58948791517014, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the difference between the maximum and minimum num_hotels for France and Italy (120-100=20), while the Generated SQL finds the difference between the top two hotels in the entire table (160-150=10). The WHERE clause in the Reference SQL restricts data to specific countries, whereas the Generated SQL operates on the full dataset, leading to different results.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is fundamentally flawed. It incorrectly partitions data using 'num_hotels <= 2' (which doesn't apply to any records) and filters only France and Italy, ignoring the actual top 2 countries. The Generated SQL correctly identifies the top 2 countries by ordering all records descending, selecting the top 2, and calculating their difference. While both queries compute a difference between max/min values, the Reference SQL's logic is irrelevant to the question. The Generated SQL properly addresses the business intent by focusing on the actual top 2 countries (UK and Germany) and their hotel counts.", "overall_assessment": "incorrect"}}
{"example_id": 1970, "sql_complexity": "multiple_joins", "prompt": "List all players who have played a specific VR game, 'CyberSphere', and their ages.", "context": "CREATE TABLE Players (PlayerID INT, Age INT, Gender VARCHAR(10), Country VARCHAR(50)); CREATE TABLE VRPlayers (PlayerID INT, VRGameID INT); CREATE TABLE VRGames (VRGameID INT, Title VARCHAR(50)); INSERT INTO Players (PlayerID, Age, Gender, Country) VALUES (1, 25, 'Male', 'USA'); INSERT INTO Players (PlayerID, Age, Gender, Country) VALUES (2, 28, 'Female', 'Canada'); INSERT INTO VRPlayers (PlayerID, VRGameID) VALUES (1, 1); INSERT INTO VRPlayers (PlayerID, VRGameID) VALUES (2, 1); INSERT INTO VRGames (VRGameID, Title) VALUES (1, 'CyberSphere');", "reference_sql": "SELECT Players.Age, Players.PlayerID FROM Players INNER JOIN VRPlayers ON Players.PlayerID = VRPlayers.PlayerID INNER JOIN VRGames ON VRPlayers.VRGameID = VRGames.VRGameID WHERE VRGames.Title = 'CyberSphere';", "generated_sql": "SELECT p.PlayerID,\n       p.Age\nFROM Players     AS p\nJOIN VRPlayers   AS vp ON vp.PlayerID = p.PlayerID\nJOIN VRGames     AS vg ON vg.VRGameID = vp.VRGameID\nWHERE vg.Title = 'CyberSphere';", "raw_model_output": "SELECT p.PlayerID,\n       p.Age\nFROM Players     AS p\nJOIN VRPlayers   AS vp ON vp.PlayerID = p.PlayerID\nJOIN VRGames     AS vg ON vg.VRGameID = vp.VRGameID\nWHERE vg.Title = 'CyberSphere';", "latency_sec": 3.528320074081421, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 244, "prompt_eval_sec": null, "tokens_completion": 205, "completion_eval_sec": null, "tokens_total": 449, "tokens_per_sec": 127.25602852708728, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform identical INNER JOIN operations between the same tables (Players, VRPlayers, VRGames) with equivalent join conditions. The Generated SQL uses table aliases (p, vp, vg) but references the same columns (PlayerID, Age, Title) and applies the same WHERE filter (vg.Title = 'CyberSphere'). The select list and join logic are identical in effect.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries are technically equivalent as they produce identical results through equivalent logic. They correctly join the three tables (Players, VRPlayers, VRGames) with the same conditions, filter for 'CyberSphere' via the VRGames.Title column, and select the required PlayerID and Age fields. The generated query uses table aliases (p, vp, vg) which improves readability without altering functionality. Both fulfill the business intent of listing players who played 'CyberSphere' with their ages. The superiority is equal as both are equally efficient, correct, and elegant.", "overall_assessment": "correct"}}
{"example_id": 2414, "sql_complexity": "window functions", "prompt": "List the policy areas with the lowest citizen satisfaction scores.", "context": "CREATE TABLE Policy (Area VARCHAR(20), Score INT); INSERT INTO Policy (Area, Score) VALUES ('Transportation', 70), ('Education', 85), ('Healthcare', 75), ('PublicSafety', 80);", "reference_sql": "SELECT Area, Score FROM (SELECT Area, Score, ROW_NUMBER() OVER (ORDER BY Score) AS RN FROM Policy) X WHERE RN IN (1, 2);", "generated_sql": "SELECT Area\nFROM Policy\nWHERE Score = (SELECT MIN(Score) FROM Policy);", "raw_model_output": "```sql\nSELECT Area\nFROM Policy\nWHERE Score = (SELECT MIN(Score) FROM Policy);\n```", "latency_sec": 8.640470027923584, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 123, "prompt_eval_sec": null, "tokens_completion": 105, "completion_eval_sec": null, "tokens_total": 228, "tokens_per_sec": 26.38745337500943, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns the two lowest-scoring policies (rows with RN=1 and RN=2 after ordering by Score), while the Generated SQL only returns the policy with the absolute minimum Score. In the sample data, this would return two rows vs. one row (Transportation vs. Transportation and Healthcare).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The Reference SQL uses ROW_NUMBER() to select the first two rows ordered by Score, which may not correctly identify all policies with the absolute lowest scores (e.g., if multiple policies share the minimum score). The Generated SQL correctly retrieves all policies with the minimum score by using a subquery with MIN(Score), ensuring it captures all instances of the lowest satisfaction scores. While the Reference SQL might return the 'two lowest' scores, the original question asks for 'lowest' (singular) scores, making the Generated SQL more accurate. The Generated SQL is also more efficient and semantically aligned with the business intent of identifying all policies with the minimum score.", "overall_assessment": "correct"}}
{"example_id": 1898, "sql_complexity": "single join", "prompt": "What are the total sales for each drug in Q2 2020?", "context": "CREATE TABLE drugs (drug_id INT, drug_name TEXT); INSERT INTO drugs (drug_id, drug_name) VALUES (1001, 'Ibuprofen'), (1002, 'Paracetamol'), (1003, 'Aspirin'); CREATE TABLE sales (sale_id INT, drug_id INT, sale_date DATE, revenue FLOAT); INSERT INTO sales (sale_id, drug_id, sale_date, revenue) VALUES (1, 1001, '2020-04-05', 1800.0), (2, 1002, '2020-04-10', 2300.0), (3, 1003, '2020-04-15', 1400.0), (4, 1001, '2020-05-20', 1900.0), (5, 1002, '2020-06-25', 2400.0);", "reference_sql": "SELECT drug_name, SUM(revenue) as total_sales FROM sales JOIN drugs ON sales.drug_id = drugs.drug_id WHERE sale_date BETWEEN '2020-04-01' AND '2020-06-30' GROUP BY drug_name;", "generated_sql": "SELECT\n    d.drug_name,\n    SUM(s.revenue) AS total_sales\nFROM\n    drugs AS d\nJOIN\n    sales AS s\n    ON s.drug_id = d.drug_id\nWHERE\n    s.sale_date BETWEEN DATE '2020-04-01' AND DATE '2020-06-30'\nGROUP BY\n    d.drug_name;", "raw_model_output": "SELECT\n    d.drug_name,\n    SUM(s.revenue) AS total_sales\nFROM\n    drugs AS d\nJOIN\n    sales AS s\n    ON s.drug_id = d.drug_id\nWHERE\n    s.sale_date BETWEEN DATE '2020-04-01' AND DATE '2020-06-30'\nGROUP BY\n    d.drug_name;", "latency_sec": 3.676021099090576, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 270, "prompt_eval_sec": null, "tokens_completion": 226, "completion_eval_sec": null, "tokens_total": 496, "tokens_per_sec": 134.92849649930116, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between 'drugs' and 'sales' on drug_id, filter sales within the date range '2020-04-01' to '2020-06-30', and group by drug_name to calculate total sales. The differences are purely syntactic (aliases, date literal formatting) and do not affect the result. The GROUP BY clause uses drug_name in both cases, which is functionally dependent on drug_id (as per the sample data and schema).", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly calculate total sales per drug for Q2 2020. The Reference uses explicit table names while the Generated uses aliases, but this doesn't affect results. The DATE keyword in Generated is dialect-specific (e.g., PostgreSQL) but equivalent to the Reference's string literals in functionality. Both properly join on drug_id, filter dates (April-June 2020), and group by drug_name. The business intent of aggregating Q2 sales per drug is fully met by both queries.", "overall_assessment": "correct"}}
{"example_id": 2403, "sql_complexity": "multiple_joins", "prompt": "Who is the most frequent customer ordering vegetarian items?", "context": "CREATE TABLE customers (customer_id INT, customer_name VARCHAR(50)); INSERT INTO customers VALUES (1, 'John Doe'), (2, 'Jane Smith'), (3, 'Alice Johnson'); CREATE TABLE orders (order_id INT, customer_id INT, menu_id INT, order_date DATE); INSERT INTO orders VALUES (1, 1, 1, '2022-01-01'), (2, 2, 3, '2022-01-02'), (3, 3, 2, '2022-01-03'); CREATE TABLE menu (menu_id INT, item_name VARCHAR(50), is_vegetarian BOOLEAN, price DECIMAL(5,2)); INSERT INTO menu VALUES (1, 'Veggie Burger', true, 8.99), (2, 'Cheeseburger', false, 7.99), (3, 'Tofu Stir Fry', true, 11.99);", "reference_sql": "SELECT customers.customer_name, COUNT(orders.order_id) as order_count FROM customers INNER JOIN orders ON customers.customer_id = orders.customer_id INNER JOIN menu ON orders.menu_id = menu.menu_id WHERE menu.is_vegetarian = true GROUP BY customers.customer_name ORDER BY order_count DESC LIMIT 1;", "generated_sql": "SELECT\n    c.customer_name\nFROM\n    customers AS c\nJOIN\n    orders   AS o ON c.customer_id = o.customer_id\nJOIN\n    menu     AS m ON o.menu_id = m.menu_id\nWHERE\n    m.is_vegetarian = TRUE\nGROUP BY\n    c.customer_name\nORDER BY\n    COUNT(*) DESC\nFETCH FIRST 1 ROW ONLY;", "raw_model_output": "SELECT\n    c.customer_name\nFROM\n    customers AS c\nJOIN\n    orders   AS o ON c.customer_id = o.customer_id\nJOIN\n    menu     AS m ON o.menu_id = m.menu_id\nWHERE\n    m.is_vegetarian = TRUE\nGROUP BY\n    c.customer_name\nORDER BY\n    COUNT(*) DESC\nFETCH FIRST 1 ROW ONLY;", "latency_sec": 4.031376838684082, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 269, "prompt_eval_sec": null, "tokens_completion": 291, "completion_eval_sec": null, "tokens_total": 560, "tokens_per_sec": 138.91035802616622, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the customer with the highest count of vegetarian orders. They use equivalent JOIN conditions, filter on menu.is_vegetarian = true, group by customer_name, and order by count descending. The difference in COUNT(*) vs COUNT(orders.order_id) is irrelevant here since both count the same rows. The LIMIT 1 and FETCH FIRST 1 ROW ONLY clauses are functionally equivalent in this context.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "equal", "explanation": "Both queries correctly identify the most frequent customer ordering vegetarian items by joining customers, orders, and menu tables with a vegetarian filter. They both group by customer, count orders, and sort descending. The Reference uses LIMIT 1 while the Generated uses FETCH FIRST 1 ROW ONLY - both achieve the same result. The Reference explicitly counts order_id while the Generated uses COUNT(*), but since the joins are inner joins, both will produce identical counts. The business intent is fully addressed in both cases.", "overall_assessment": "correct"}}
{"example_id": 124, "sql_complexity": "set operations", "prompt": "Find the intersection of AI and accessibility research projects in the EU and those in Africa.", "context": "CREATE SCHEMA if not exists accessibility; CREATE TABLE if not exists accessibility.research (id INT PRIMARY KEY, project_name VARCHAR(255), region VARCHAR(255)); INSERT INTO accessibility.research (id, project_name, region) VALUES (1, 'AI for Accessibility EU', 'EU'), (2, 'Accessibility Africa', 'Africa'), (3, 'AI for Accessibility Africa', 'Africa'), (4, 'Accessibility EU', 'EU');", "reference_sql": "SELECT project_name FROM accessibility.research WHERE region = 'EU' INTERSECT SELECT project_name FROM accessibility.research WHERE region = 'Africa';", "generated_sql": "SELECT id,\n       project_name,\n       region\nFROM   accessibility.research\nWHERE  LOWER(project_name) LIKE '%ai%'\n  AND  LOWER(project_name) LIKE '%accessibility%'\n  AND  region IN ('EU', 'Africa');", "raw_model_output": "-- AI & Accessibility projects that are present in both the EU and Africa regions\nSELECT id,\n       project_name,\n       region\nFROM   accessibility.research\nWHERE  LOWER(project_name) LIKE '%ai%'\n  AND  LOWER(project_name) LIKE '%accessibility%'\n  AND  region IN ('EU', 'Africa');", "latency_sec": 22.050696849822998, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 174, "prompt_eval_sec": null, "tokens_completion": 1556, "completion_eval_sec": null, "tokens_total": 1730, "tokens_per_sec": 78.45557044215983, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL finds project names present in both 'EU' and 'Africa' regions (intersection), while the Generated SQL selects projects containing both 'ai' and 'accessibility' in their name with regions 'EU' or 'Africa'. The Reference query returns no results (no overlapping project names between regions), whereas the Generated query returns projects like 'AI for Accessibility EU' and 'AI for Accessibility Africa'. The logic and results differ significantly.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "reference", "explanation": "The Reference SQL correctly uses INTERSECT to find projects present in both EU and Africa regions, directly addressing the intersection requirement. The Generated SQL filters projects containing 'ai' and 'accessibility' in their names within either region, but fails to identify projects that exist in both regions. While the Generated SQL technically works for keyword-based filtering, it does not fulfill the business intent of finding overlapping projects between regions. The Reference SQL is both logically and semantically aligned with the question, while the Generated SQL addresses a different query altogether.", "overall_assessment": "incorrect"}}
{"example_id": 1231, "sql_complexity": "basic SQL", "prompt": "What is the average ticket price for performances at the 'Downtown Theater'?", "context": "CREATE TABLE DowntownTheater (show_name TEXT, date DATE, ticket_price FLOAT); INSERT INTO DowntownTheater (show_name, date, ticket_price) VALUES ('Play 1', '2022-01-01', 30.0), ('Play 2', '2022-01-02', 40.0), ('Concert 1', '2022-01-03', 50.0);", "reference_sql": "SELECT AVG(ticket_price) FROM DowntownTheater WHERE show_name = 'Downtown Theater'", "generated_sql": "SELECT AVG(ticket_price) AS average_ticket_price\nFROM DowntownTheater;", "raw_model_output": "SELECT AVG(ticket_price) AS average_ticket_price\nFROM DowntownTheater;", "latency_sec": 2.5493719577789307, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 168, "prompt_eval_sec": null, "tokens_completion": 98, "completion_eval_sec": null, "tokens_total": 266, "tokens_per_sec": 104.33942335811409, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters for show_name = 'Downtown Theater' which doesn't exist in the sample data (the actual show names are 'Play 1', 'Play 2', 'Concert 1'), resulting in NULL. The Generated SQL calculates the average of all tickets. The Reference query would return NULL (no matching rows) while the Generated query returns 40.0 (average of 30, 40, 50).", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query incorrectly filters for show_name = 'Downtown Theater', but the sample data shows show_names are 'Play 1', 'Play 2', and 'Concert 1' - none matching the filter. This would return NULL or 0. The generated query correctly calculates the average of all ticket prices in the DowntownTheater table, which contains the three performances. The reference query's WHERE clause is semantically incorrect for the business question, while the generated query properly addresses the request by averaging all performances at the theater.", "overall_assessment": "incorrect"}}
{"example_id": 1485, "sql_complexity": "set operations", "prompt": "How many public schools and public libraries exist in total, in the 'CityData' schema's 'CityEducation' and 'CityLibrary' tables?", "context": "CREATE SCHEMA CityData; CREATE TABLE CityEducation (Name varchar(255), Type varchar(255)); INSERT INTO CityEducation (Name, Type) VALUES ('SchoolA', 'Public'), ('SchoolB', 'Public'), ('SchoolC', 'Private'); CREATE TABLE CityLibrary (Name varchar(255), Type varchar(255)); INSERT INTO CityLibrary (Name, Type) VALUES ('LibraryA', 'Public'), ('LibraryB', 'Public'), ('LibraryC', 'Private');", "reference_sql": "SELECT COUNT(*) FROM CityData.CityEducation WHERE Type = 'Public' UNION ALL SELECT COUNT(*) FROM CityData.CityLibrary WHERE Type = 'Public';", "generated_sql": "SELECT \n    (SELECT COUNT(*) \n     FROM CityData.CityEducation \n     WHERE Type = 'Public')\n  + \n    (SELECT COUNT(*) \n     FROM CityData.CityLibrary \n     WHERE Type = 'Public') \n    AS total_public_entities;", "raw_model_output": "SELECT \n    (SELECT COUNT(*) \n     FROM CityData.CityEducation \n     WHERE Type = 'Public')\n  + \n    (SELECT COUNT(*) \n     FROM CityData.CityLibrary \n     WHERE Type = 'Public') \n    AS total_public_entities;", "latency_sec": 2.533673048019409, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 194, "prompt_eval_sec": null, "tokens_completion": 135, "completion_eval_sec": null, "tokens_total": 329, "tokens_per_sec": 129.8510083047936, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate counts as individual rows (e.g., 2 and 2), while the Generated SQL returns a single summed value (e.g., 4). The output structure and values differ, so they are not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL uses UNION ALL to combine two separate counts, resulting in two rows of output (e.g., 2 and 2). The Generated SQL correctly calculates a single total by summing the counts from both tables. While both queries correctly count public entities in their respective tables, the Reference SQL fails to aggregate the results into a single total as required by the question. The Generated SQL directly addresses the business intent of providing a combined total, making it more appropriate for the task.", "overall_assessment": "differently_correct"}}
{"example_id": 5806, "sql_complexity": "single join", "prompt": "List the top 3 countries with the most veteran employment in the IT industry", "context": "CREATE TABLE veteran_employment (employee_id INT, industry VARCHAR(255), salary DECIMAL(10,2), state VARCHAR(2), country VARCHAR(255)); CREATE TABLE countries (country_id INT, country VARCHAR(255));", "reference_sql": "SELECT country, COUNT(*) as num_veterans FROM veteran_employment JOIN countries ON veteran_employment.country = countries.country WHERE industry = 'IT' GROUP BY country ORDER BY num_veterans DESC LIMIT 3;", "generated_sql": "SELECT\n    ve.country,\n    COUNT(*) AS veteran_count\nFROM\n    veteran_employment AS ve\nWHERE\n    ve.industry = 'IT'\nGROUP BY\n    ve.country\nORDER BY\n    veteran_count DESC\nFETCH FIRST 3 ROWS ONLY;", "raw_model_output": "SELECT\n    ve.country,\n    COUNT(*) AS veteran_count\nFROM\n    veteran_employment AS ve\nWHERE\n    ve.industry = 'IT'\nGROUP BY\n    ve.country\nORDER BY\n    veteran_count DESC\nFETCH FIRST 3 ROWS ONLY;", "latency_sec": 3.618389129638672, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 128, "prompt_eval_sec": null, "tokens_completion": 202, "completion_eval_sec": null, "tokens_total": 330, "tokens_per_sec": 91.20080460582011, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes an unnecessary JOIN with the countries table that doesn't affect the result (no columns from countries are used). However, this JOIN would cause the COUNT(*) to be inflated if there are multiple matching rows in the countries table for a given country. The Generated SQL omits this JOIN, resulting in correct aggregation. Additionally, while both use row-limiting clauses (LIMIT vs FETCH FIRST), these are functionally equivalent in most SQL dialects. The critical difference is the redundant JOIN in the Reference SQL, which alters the result.", "enhanced_judgment": {"technically_equivalent": true, "fulfills_intent": true, "superiority": "generated", "explanation": "Both queries correctly count IT industry veterans per country and return the top 3. The reference query includes an unnecessary JOIN with the 'countries' table, which doesn't affect the result since the 'country' column is already present in 'veteran_employment'. The generated query avoids this redundant join, making it more efficient. The LIMIT clause in the reference uses MySQL syntax, while the generated query uses FETCH FIRST (Oracle syntax), but both achieve the same result. The generated query is more elegant and efficient.", "overall_assessment": "correct"}}
{"example_id": 4126, "sql_complexity": "window functions", "prompt": "What is the average crime rate per capita in each neighborhood?", "context": "CREATE TABLE neighborhoods (name VARCHAR(255), population INT, crime_count INT); INSERT INTO neighborhoods (name, population, crime_count) VALUES ('Central Park', 1000, 25), ('Harlem', 2500, 75), ('Brooklyn', 5000, 120);", "reference_sql": "SELECT name, AVG(crime_count/population) OVER (PARTITION BY name) FROM neighborhoods;", "generated_sql": "SELECT\n    name,\n    CAST(crime_count AS DECIMAL(10,4)) / population AS crime_rate_per_capita\nFROM\n    neighborhoods;", "raw_model_output": "```sql\nSELECT\n    name,\n    CAST(crime_count AS DECIMAL(10,4)) / population AS crime_rate_per_capita\nFROM\n    neighborhoods;\n```", "latency_sec": 4.61515474319458, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 139, "prompt_eval_sec": null, "tokens_completion": 183, "completion_eval_sec": null, "tokens_total": 322, "tokens_per_sec": 69.77014161330455, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query calculates the average of (crime_count/population) over each neighborhood partition, which for unique names would return the same value as crime_count/population. However, the generated query explicitly computes crime_count/population with decimal precision. While the results may appear similar, the reference query's division might use integer division (depending on the SQL dialect), whereas the generated query ensures decimal division. Additionally, the reference query's window function adds unnecessary complexity that doesn't change the outcome but makes the queries structurally different.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "generated", "explanation": "The reference query incorrectly uses an analytic function (AVG() OVER) that has no effect here since each neighborhood is a single row. This would return the same value as crime_count/population without any true aggregation. The generated query correctly calculates the per capita crime rate by casting to decimal for precision and avoids unnecessary window functions. Both queries address the business intent of calculating crime rate per capita, but the generated query does so with proper arithmetic and clarity.", "overall_assessment": "differently_correct"}}
{"example_id": 4559, "sql_complexity": "basic SQL", "prompt": "List the top 3 energy efficient appliances in the US by energy star rating?", "context": "CREATE TABLE appliances (id INT, name VARCHAR(255), country VARCHAR(255), energy_star_rating INT); INSERT INTO appliances (id, name, country, energy_star_rating) VALUES (1, 'Fridge A', 'USA', 5), (2, 'TV B', 'USA', 4), (3, 'Laptop C', 'USA', 5), (4, 'Microwave D', 'USA', 3);", "reference_sql": "SELECT name, energy_star_rating FROM appliances WHERE country = 'USA' ORDER BY energy_star_rating DESC LIMIT 3;", "generated_sql": "SELECT\n    id,\n    name,\n    energy_star_rating\nFROM\n    appliances\nWHERE\n    country = 'USA'\nORDER BY\n    energy_star_rating DESC,\n    id ASC\nFETCH FIRST 3 ROWS ONLY;", "raw_model_output": "```sql\nSELECT\n    id,\n    name,\n    energy_star_rating\nFROM\n    appliances\nWHERE\n    country = 'USA'\nORDER BY\n    energy_star_rating DESC,\n    id ASC\nFETCH FIRST 3 ROWS ONLY;\n```", "latency_sec": 2.7663328647613525, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 173, "prompt_eval_sec": null, "tokens_completion": 134, "completion_eval_sec": null, "tokens_total": 307, "tokens_per_sec": 110.97724496957254, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL selects only 'name' and 'energy_star_rating', while the Generated SQL includes 'id' as well. Additionally, the Generated SQL adds a secondary sort on 'id ASC' which could affect row ordering when there are ties in 'energy_star_rating', potentially changing the exact rows selected when multiple entries have the same energy rating. The column differences alone make the result sets structurally distinct.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": true, "superiority": "reference", "explanation": "The queries are not technically equivalent. The Reference SQL selects only 'name' and 'energy_star_rating' columns, while the Generated SQL includes 'id' and adds an explicit 'id ASC' tiebreaker in the ORDER BY. The Reference uses LIMIT 3 (standard SQL) while the Generated uses FETCH FIRST 3 ROWS ONLY (database-specific syntax). Both correctly filter USA appliances and sort by energy_star_rating DESC, but the Reference is more concise and directly addresses the question's requirements. The Generated query's additional column and tiebreaker are unnecessary for the original question.", "overall_assessment": "differently_correct"}}
{"example_id": 456, "sql_complexity": "window functions", "prompt": "List the intelligence operations and their corresponding threat levels, and rank them based on their threat level and budget.", "context": "CREATE TABLE intel_ops_threat (id INT, operation VARCHAR, threat VARCHAR, budget INT); INSERT INTO intel_ops_threat (id, operation, threat, budget) VALUES (1, 'Operation Red Folder', 'High', 5000000), (2, 'Operation Black Vault', 'Medium', 7000000), (3, 'Operation Blue Sail', 'Low', 6000000);", "reference_sql": "SELECT operation, threat, budget, ROW_NUMBER() OVER (PARTITION BY threat ORDER BY budget DESC) as rank FROM intel_ops_threat;", "generated_sql": "SELECT\n    operation,\n    threat,\n    ROW_NUMBER() OVER (\n        ORDER BY \n            CASE threat\n                WHEN 'High'   THEN 1\n                WHEN 'Medium' THEN 2\n                WHEN 'Low'    THEN 3\n                ELSE 4\n            END,\n            budget DESC          -- higher budget gets higher priority within same threat level\n    ) AS threat_budget_rank\nFROM intel_ops_threat;", "raw_model_output": "```sql\nSELECT\n    operation,\n    threat,\n    ROW_NUMBER() OVER (\n        ORDER BY \n            CASE threat\n                WHEN 'High'   THEN 1\n                WHEN 'Medium' THEN 2\n                WHEN 'Low'    THEN 3\n                ELSE 4\n            END,\n            budget DESC          -- higher budget gets higher priority within same threat level\n    ) AS threat_budget_rank\nFROM intel_ops_threat;\n```", "latency_sec": 4.684469938278198, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 170, "prompt_eval_sec": null, "tokens_completion": 366, "completion_eval_sec": null, "tokens_total": 536, "tokens_per_sec": 114.42062966829704, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL partitions by 'threat' and ranks within each partition, while the Generated SQL orders globally by threat level (High/Medium/Low) and budget. This results in different ranking behaviors: the first query gives per-threat rankings, while the second provides a global ranking ordered by threat priority and budget. For example, in the sample data, the Reference SQL would assign rank 1 to all three rows (one per threat), whereas the Generated SQL would assign ranks 1, 2, 3 based on threat priority and budget.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The queries are not technically equivalent. The Reference SQL ranks operations within each threat level (partitioned by threat) using budget as the secondary sort, while the Generated SQL ranks all operations globally by prioritizing threat level (High > Medium > Low) and then budget. The original question requires a combined ranking of threat and budget, which the Generated SQL achieves by explicitly defining threat priority in the ORDER BY clause. The Reference SQL only ranks within threat groups, failing to address the 'rank them based on their threat level and budget' requirement. The Generated SQL better fulfills the business intent by creating a unified ranking that reflects both criteria.", "overall_assessment": "differently_correct"}}
{"example_id": 459, "sql_complexity": "set operations", "prompt": "What is the total installed capacity of hydroelectric power plants in Brazil and Canada?", "context": "CREATE TABLE hydroelectric_power (country TEXT, capacity INTEGER); INSERT INTO hydroelectric_power (country, capacity) VALUES ('Brazil', 104000), ('Canada', 78000), ('China', 350000), ('United States', 100000), ('Russia', 45000);", "reference_sql": "(SELECT capacity FROM hydroelectric_power WHERE country = 'Brazil') UNION (SELECT capacity FROM hydroelectric_power WHERE country = 'Canada');", "generated_sql": "SELECT SUM(capacity) AS total_capacity\nFROM hydroelectric_power\nWHERE country IN ('Brazil', 'Canada');", "raw_model_output": "```sql\nSELECT SUM(capacity) AS total_capacity\nFROM hydroelectric_power\nWHERE country IN ('Brazil', 'Canada');\n```", "latency_sec": 2.0732829570770264, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 141, "prompt_eval_sec": null, "tokens_completion": 46, "completion_eval_sec": null, "tokens_total": 187, "tokens_per_sec": 90.1951175365074, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate rows with individual capacities of Brazil and Canada, while the Generated SQL returns a single row with the summed capacity of both countries. The output structures differ (two rows vs. one row with aggregate value), so they are not semantically equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The reference query uses UNION to combine separate capacity values for Brazil and Canada, returning two rows instead of a single summed total. The generated query correctly uses SUM(capacity) with a WHERE clause to calculate the combined total. While both queries retrieve data for the correct countries, only the generated query addresses the 'total' requirement in the question. The reference query fails to aggregate values, making it technically incorrect for the business intent. The generated query is more efficient and directly answers the question.", "overall_assessment": "incorrect"}}
{"example_id": 2356, "sql_complexity": "window functions", "prompt": "Find the total billing amount for attorneys in the 'Criminal Law' practice area, for the year 2020, partitioned by attorney's last name and ordered by the total billing amount in descending order.", "context": "CREATE TABLE Attorneys (AttorneyID INT, FirstName VARCHAR(50), LastName VARCHAR(50), PracticeArea VARCHAR(50), TotalBilling FLOAT, BillingYear INT); INSERT INTO Attorneys (AttorneyID, FirstName, LastName, PracticeArea, TotalBilling, BillingYear) VALUES (1, 'Clara', 'Rivera', 'Personal Injury', 8000.00, 2020), (2, 'Jamal', 'Lee', 'Personal Injury', 6000.00, 2019), (3, 'Sophia', 'Gomez', 'Criminal Law', 9000.00, 2020);", "reference_sql": "SELECT LastName, SUM(TotalBilling) OVER (PARTITION BY PracticeArea, LastName, BillingYear) AS TotalBilling FROM Attorneys WHERE PracticeArea = 'Criminal Law' AND BillingYear = 2020 ORDER BY TotalBilling DESC;", "generated_sql": "SELECT DISTINCT\n       LastName,\n       SUM(TotalBilling) OVER (PARTITION BY LastName) AS TotalBilling\nFROM Attorneys\nWHERE PracticeArea = 'Criminal Law'\n  AND BillingYear = 2020\nORDER BY TotalBilling DESC;", "raw_model_output": "SELECT DISTINCT\n       LastName,\n       SUM(TotalBilling) OVER (PARTITION BY LastName) AS TotalBilling\nFROM Attorneys\nWHERE PracticeArea = 'Criminal Law'\n  AND BillingYear = 2020\nORDER BY TotalBilling DESC;", "latency_sec": 6.7505011558532715, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 240, "prompt_eval_sec": null, "tokens_completion": 519, "completion_eval_sec": null, "tokens_total": 759, "tokens_per_sec": 112.4360965914184, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL uses a window function partitioned by (PracticeArea, LastName, BillingYear), while the Generated SQL uses (LastName) only. Although the WHERE clause restricts to 'Criminal Law' and 2020, the Generated SQL's DISTINCT keyword may eliminate duplicate LastName entries that the Reference SQL would retain. For example, if multiple attorneys shared the same LastName, the Reference SQL would return multiple rows with the same LastName and TotalBilling, while the Generated SQL would collapse them into a single row. This difference in output structure makes them non-equivalent.", "enhanced_judgment": {"technically_equivalent": false, "fulfills_intent": false, "superiority": "generated", "explanation": "The Reference SQL is technically incorrect because it uses a window function with redundant partitioning (PracticeArea, LastName, BillingYear) that doesn't achieve the intended aggregation. Since the WHERE clause already filters to 'Criminal Law' and 2020, the partitioning by those fields is unnecessary and causes the SUM to return the same value as TotalBilling for each row. The Generated SQL correctly sums TotalBilling by LastName within the filtered dataset (Criminal Law, 2020) using a window function, which aligns with the business intent of aggregating billing amounts per attorney. However, neither query uses GROUP BY, which would be more appropriate for this aggregation. The Generated SQL better fulfills the intent by correctly summing per LastName, while the Reference SQL fails to aggregate properly.", "overall_assessment": "differently_correct"}}
