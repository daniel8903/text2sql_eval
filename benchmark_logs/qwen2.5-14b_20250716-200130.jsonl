{"example_id": 2656, "sql_complexity": "multiple_joins", "prompt": "Find the drugs and their respective total sales for rare diseases indication with sales greater than the average sales for infectious diseases.", "context": "CREATE TABLE sales (id INT, drug_id INT, quarter INT, year INT, revenue FLOAT); INSERT INTO sales (id, drug_id, quarter, year, revenue) VALUES (1, 1, 1, 2022, 1500000); CREATE TABLE drugs (id INT, name VARCHAR(50), company VARCHAR(50), indication VARCHAR(50)); INSERT INTO drugs (id, name, company, indication) VALUES (1, 'DrugA', 'ABC Corp', 'Rare_Diseases');", "reference_sql": "SELECT s.drug_id, d.name, SUM(s.revenue) as total_sales FROM sales s JOIN drugs d ON s.drug_id = d.id WHERE d.indication = 'Rare_Diseases' GROUP BY s.drug_id HAVING total_sales > (SELECT AVG(s2.revenue) FROM sales s2 JOIN drugs d2 ON s2.drug_id = d2.id WHERE d2.indication = 'Infectious_Diseases')", "generated_sql": "SELECT \n    d.name,\n    SUM(s.revenue) AS total_sales\nFROM \n    sales s\nJOIN \n    drugs d ON s.drug_id = d.id\nWHERE \n    d.indication = 'Rare_Diseases'\nGROUP BY \n    d.name, d.id\nHAVING \n    SUM(s.revenue) > (SELECT AVG(revenue) FROM sales WHERE drug_id IN (\n        SELECT id FROM drugs WHERE indication = 'Infectious_Diseases'))", "raw_model_output": "To find the drugs and their respective total sales for the \"Rare_Diseases\" indication, where the total sales are greater than the average sales of drugs indicated for \"Infectious_Diseases\", you can use the following SQL query:\n\n```sql\nSELECT \n    d.name,\n    SUM(s.revenue) AS total_sales\nFROM \n    sales s\nJOIN \n    drugs d ON s.drug_id = d.id\nWHERE \n    d.indication = 'Rare_Diseases'\nGROUP BY \n    d.name, d.id\nHAVING \n    SUM(s.revenue) > (SELECT AVG(revenue) FROM sales WHERE drug_id IN (\n        SELECT id FROM drugs WHERE indication = 'Infectious_Diseases'))\n```\n\nThis query first calculates the total revenue for each drug indicated as \"Rare_Diseases\". Then it compares this total to the average revenue of all drugs indicated as \"Infectious_Diseases\" and filters out those with a lower total sales.", "latency_sec": 6.818572998046875, "total_duration_sec": 6.809313684, "load_duration_sec": 1.624697397, "tokens_prompt": 207, "prompt_eval_sec": 0.173982836, "tokens_completion": 203, "completion_eval_sec": 5.00342776, "tokens_total": 410, "tokens_per_sec": 60.12988349870877, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their output columns and grouping logic. The Reference SQL returns 'drug_id' and 'name', while the Generated SQL only returns 'name'. Additionally, the Reference groups by 's.drug_id' (a single column), whereas the Generated groups by 'd.name, d.id' (two columns). Although the underlying data may align, the result sets have different structures, making them non-equivalent."}
{"example_id": 3008, "sql_complexity": "multiple_joins", "prompt": "Who are the users who used electric vehicles and their trip details?", "context": "CREATE TABLE users (id INT, name VARCHAR(50), age INT, gender VARCHAR(10), city VARCHAR(50));CREATE TABLE vehicles (id INT, vehicle_type VARCHAR(20), is_electric BOOLEAN);CREATE TABLE trips (id INT, user_id INT, vehicle_id INT, trip_distance FLOAT, trip_duration INT, departure_time TIMESTAMP, arrival_time TIMESTAMP);INSERT INTO users (id, name, age, gender, city) VALUES (3, 'Alex', 30, 'Female', 'New York');INSERT INTO vehicles (id, vehicle_type, is_electric) VALUES (1, 'Tesla', true), (2, 'Bike', false);INSERT INTO trips (id, user_id, vehicle_id, trip_distance, trip_duration, departure_time, arrival_time) VALUES (3, 3, 1, 15.3, 25, '2022-01-03 12:00:00', '2022-01-03 12:25:00');", "reference_sql": "SELECT u.name, v.vehicle_type, t.trip_distance, t.trip_duration FROM users u JOIN trips t ON u.id = t.user_id JOIN vehicles v ON t.vehicle_id = v.id WHERE v.is_electric = true;", "generated_sql": "SELECT u.name, v.vehicle_type, t.trip_distance, t.trip_duration, t.departure_time, t.arrival_time\nFROM users u\nJOIN trips t ON u.id = t.user_id\nJOIN vehicles v ON v.id = t.vehicle_id\nWHERE v.is_electric = true;", "raw_model_output": "```sql\nSELECT u.name, v.vehicle_type, t.trip_distance, t.trip_duration, t.departure_time, t.arrival_time\nFROM users u\nJOIN trips t ON u.id = t.user_id\nJOIN vehicles v ON v.id = t.vehicle_id\nWHERE v.is_electric = true;\n```", "latency_sec": 1.6489579677581787, "total_duration_sec": 1.643215016, "load_duration_sec": 0.014195408, "tokens_prompt": 309, "prompt_eval_sec": 0.082190042, "tokens_completion": 65, "completion_eval_sec": 1.54418397, "tokens_total": 374, "tokens_per_sec": 226.8099049901601, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent because the Generated SQL includes additional columns (departure_time, arrival_time) in the SELECT clause that are not present in the Reference SQL. This results in different output schemas, even though both queries share the same joins, filter conditions, and core selected columns."}
{"example_id": 2531, "sql_complexity": "basic SQL", "prompt": "Who is the top customer by sales in 2022?", "context": "CREATE TABLE customers (customer_id INT, total_sales_2022 FLOAT); INSERT INTO customers (customer_id, total_sales_2022) VALUES (1, 25000.0), (2, 30000.0), (3, 22000.0), (4, 35000.0);", "reference_sql": "SELECT customer_id, total_sales_2022 FROM customers ORDER BY total_sales_2022 DESC LIMIT 1;", "generated_sql": "SELECT customer_id, total_sales_2022 AS top_sales\nFROM customers\nORDER BY total_sales_2022 DESC\nLIMIT 1;", "raw_model_output": "```sql\nSELECT customer_id, total_sales_2022 AS top_sales\nFROM customers\nORDER BY total_sales_2022 DESC\nLIMIT 1;\n```", "latency_sec": 0.9251670837402344, "total_duration_sec": 0.920229035, "load_duration_sec": 0.017055501, "tokens_prompt": 164, "prompt_eval_sec": 0.034849186, "tokens_completion": 38, "completion_eval_sec": 0.865655578, "tokens_total": 202, "tokens_per_sec": 218.33893958198468, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same data (customer_id and total_sales_2022) from the customers table, ordered by total_sales_2022 in descending order and limited to 1 result. The only difference is the column alias ('top_sales' vs. original name), which does not affect the semantic result."}
{"example_id": 3792, "sql_complexity": "single join", "prompt": "What is the maximum distance traveled by an electric vehicle in a single trip, grouped by vehicle model?", "context": "CREATE TABLE Trips (trip_id INT, vehicle_id INT, distance FLOAT); CREATE TABLE ElectricVehicleModels (vehicle_id INT, vehicle_model TEXT);", "reference_sql": "SELECT evm.vehicle_model, MAX(trips.distance) AS max_distance_traveled FROM Trips trips INNER JOIN ElectricVehicleModels evm ON trips.vehicle_id = evm.vehicle_id GROUP BY 1;", "generated_sql": "SELECT evm.vehicle_model, MAX(t.distance) AS max_distance\nFROM Trips t\nJOIN ElectricVehicleModels evm ON t.vehicle_id = evm.vehicle_id\nGROUP BY evm.vehicle_model;", "raw_model_output": "To find the maximum distance traveled by an electric vehicle in a single trip, grouped by vehicle model, you can use the following SQL query:\n\n```sql\nSELECT evm.vehicle_model, MAX(t.distance) AS max_distance\nFROM Trips t\nJOIN ElectricVehicleModels evm ON t.vehicle_id = evm.vehicle_id\nGROUP BY evm.vehicle_model;\n```\n\nThis query joins the `Trips` and `ElectricVehicleModels` tables on the `vehicle_id`, groups the results by `vehicle_model`, and calculates the maximum distance for each vehicle model.", "latency_sec": 2.699812173843384, "total_duration_sec": 2.695128653, "load_duration_sec": 0.022381888, "tokens_prompt": 119, "prompt_eval_sec": 0.023975247, "tokens_completion": 115, "completion_eval_sec": 2.646751309, "tokens_total": 234, "tokens_per_sec": 86.67269607384708, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the maximum distance traveled per vehicle model by joining the Trips and ElectricVehicleModels tables. The Reference SQL uses 'GROUP BY 1' (referencing the first column in the SELECT list) while the Generated SQL explicitly groups by 'evm.vehicle_model'. Since the first column in both queries is 'evm.vehicle_model', the grouping logic is identical. The table aliases (trips vs t) and column alias names (max_distance_traveled vs max_distance) are syntactic variations that do not affect semantic equivalence."}
{"example_id": 2311, "sql_complexity": "subqueries", "prompt": "Determine the percentage of sales from each ingredient category", "context": "CREATE TABLE Sales_Details (sale_id INT, ingredient_id INT, quantity INT); INSERT INTO Sales_Details (sale_id, ingredient_id, quantity) VALUES (1, 1, 2), (1, 2, 8), (2, 1, 3), (2, 2, 7); CREATE TABLE Ingredient_Categories (ingredient_id INT, ingredient_category VARCHAR(255)); INSERT INTO Ingredient_Categories (ingredient_id, ingredient_category) VALUES (1, 'Legumes'), (2, 'Poultry');", "reference_sql": "SELECT ingredient_category, SUM(quantity) AS total_quantity, SUM(quantity) * 100.0 / (SELECT SUM(quantity) FROM Sales_Details) AS percentage_of_sales FROM Sales_Details, Ingredient_Categories WHERE Sales_Details.ingredient_id = Ingredient_Categories.ingredient_id GROUP BY ingredient_category;", "generated_sql": "WITH Total_Sales AS (\n    SELECT \n        i.ingredient_category,\n        SUM(sd.quantity) AS total_quantity\n    FROM \n        Sales_Details sd\n    JOIN \n        Ingredient_Categories i ON sd.ingredient_id = i.ingredient_id\n    GROUP BY \n        i.ingredient_category\n),\nOverall_Total AS (\n    SELECT \n        SUM(quantity) AS overall_total\n    FROM \n        Sales_Details\n)\nSELECT \n    ts.ingredient_category,\n    (ts.total_quantity * 100.0 / ot.overall_total) AS percentage_of_sales\nFROM \n    Total_Sales ts, Overall_Total ot;", "raw_model_output": "To determine the percentage of sales from each ingredient category, we need to calculate the total quantity sold for each ingredient and then aggregate these quantities by their respective categories. Finally, we will compute the percentage of the total sales that each category represents.\n\nHere is the SQL query to achieve this:\n\n```sql\nWITH Total_Sales AS (\n    SELECT \n        i.ingredient_category,\n        SUM(sd.quantity) AS total_quantity\n    FROM \n        Sales_Details sd\n    JOIN \n        Ingredient_Categories i ON sd.ingredient_id = i.ingredient_id\n    GROUP BY \n        i.ingredient_category\n),\nOverall_Total AS (\n    SELECT \n        SUM(quantity) AS overall_total\n    FROM \n        Sales_Details\n)\nSELECT \n    ts.ingredient_category,\n    (ts.total_quantity * 100.0 / ot.overall_total) AS percentage_of_sales\nFROM \n    Total_Sales ts, Overall_Total ot;\n```\n\nThis query uses two Common Table Expressions (CTEs): `Total_Sales` to calculate the total quantity sold for each ingredient category and `Overall_Total` to get the overall total quantity of all sales. The final SELECT statement calculates the percentage of sales from each category relative to the overall total.", "latency_sec": 6.032012224197388, "total_duration_sec": 6.027423692, "load_duration_sec": 0.013860452, "tokens_prompt": 191, "prompt_eval_sec": 0.045549876, "tokens_completion": 251, "completion_eval_sec": 5.96583981, "tokens_total": 442, "tokens_per_sec": 73.27571357148766, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a 'total_quantity' column in its output, while the Generated SQL does not. Both queries calculate the percentage of sales correctly, but the difference in returned columns makes them semantically inequivalent."}
{"example_id": 3329, "sql_complexity": "set operations", "prompt": "Which causes received funding from donors in both the United States and Canada?", "context": "CREATE TABLE donor_location (donor_id INT, country VARCHAR(50), cause VARCHAR(50), donation DECIMAL(10,2)); INSERT INTO donor_location (donor_id, country, cause, donation) VALUES (1, 'United States', 'Global Health', 1000.00), (2, 'Canada', 'Education', 2000.00), (3, 'United States', 'Environment', 1500.00), (4, 'Canada', 'Animal Welfare', 2500.00);", "reference_sql": "SELECT cause FROM donor_location WHERE country = 'United States' INTERSECT SELECT cause FROM donor_location WHERE country = 'Canada';", "generated_sql": "SELECT cause\nFROM donor_location\nWHERE country = 'United States'\nINTERSECT\nSELECT cause\nFROM donor_location\nWHERE country = 'Canada';", "raw_model_output": "```sql\nSELECT cause\nFROM donor_location\nWHERE country = 'United States'\nINTERSECT\nSELECT cause\nFROM donor_location\nWHERE country = 'Canada';\n```", "latency_sec": 0.926332950592041, "total_duration_sec": 0.921166593, "load_duration_sec": 0.015110925, "tokens_prompt": 206, "prompt_eval_sec": 0.04646756, "tokens_completion": 36, "completion_eval_sec": 0.857007756, "tokens_total": 242, "tokens_per_sec": 261.24516011800307, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries use the same structure: selecting 'cause' from donor_location where country is 'United States' and intersecting it with 'cause' from donor_location where country is 'Canada'. The syntax and logic are identical, so they will produce the same result."}
{"example_id": 2912, "sql_complexity": "single join", "prompt": "Which company has manufactured the most satellites?", "context": "CREATE TABLE manufacturers (id INT, name TEXT); CREATE TABLE satellites (id INT, manufacturer_id INT, name TEXT, launch_date DATE); INSERT INTO manufacturers (id, name) VALUES (1, 'SpaceX'), (2, 'Blue Origin'), (3, 'ISRO'), (4, 'CAST'); INSERT INTO satellites (id, manufacturer_id, name, launch_date) VALUES (1, 1, 'StarDragon', '2012-05-25'), (2, 1, 'Falcon', '2015-12-21'), (3, 2, 'New Glenn', '2022-01-11'), (4, 3, 'ChinaSat 1E', '2000-12-05'), (5, 3, 'ChinaSat 2A', '2003-08-13'), (6, 4, 'Shijian 9', '2017-11-19'), (7, 1, 'StarLink', '2020-05-24'), (8, 1, 'StarLink', '2020-06-13');", "reference_sql": "SELECT m.name, COUNT(s.id) FROM manufacturers m JOIN satellites s ON m.id = s.manufacturer_id GROUP BY m.name ORDER BY COUNT(s.id) DESC;", "generated_sql": "SELECT m.name AS manufacturer_name, COUNT(s.id) AS satellite_count\nFROM manufacturers m\nJOIN satellites s ON m.id = s.manufacturer_id\nGROUP BY m.id, m.name\nORDER BY satellite_count DESC\nLIMIT 1;", "raw_model_output": "To determine which company has manufactured the most satellites, you can use a `GROUP BY` clause on the manufacturer and then count the number of satellites each manufacturer has produced. Finally, you would select the manufacturer with the highest count.\n\nHere is the corresponding SQL query:\n\n```sql\nSELECT m.name AS manufacturer_name, COUNT(s.id) AS satellite_count\nFROM manufacturers m\nJOIN satellites s ON m.id = s.manufacturer_id\nGROUP BY m.id, m.name\nORDER BY satellite_count DESC\nLIMIT 1;\n```\n\nThis query joins the `manufacturers` and `satellites` tables on the `manufacturer_id`, groups by manufacturer, counts the number of satellites each manufacturer has produced, orders the results in descending order based on the count, and limits the result to just one row (the manufacturer with the highest count).", "latency_sec": 4.17845606803894, "total_duration_sec": 4.17366318, "load_duration_sec": 0.013939837, "tokens_prompt": 341, "prompt_eval_sec": 0.079368358, "tokens_completion": 169, "completion_eval_sec": 4.078166068, "tokens_total": 510, "tokens_per_sec": 122.05465169324047, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns all manufacturers with their satellite counts ordered by count descending, while the Generated SQL adds a LIMIT 1 clause, returning only the top result. The GROUP BY in Generated SQL (m.id, m.name) is functionally equivalent to GROUP BY m.name in Reference SQL due to the primary key relationship, but the LIMIT 1 makes the results different."}
{"example_id": 3170, "sql_complexity": "aggregation", "prompt": "Determine the total production quantity of silver for mining sites in Mexico, between the dates '2017-05-01' and '2017-09-30', having less than 40 employees.", "context": "CREATE TABLE silver_mine_2 (site_id INT, country VARCHAR(50), num_employees INT, extraction_date DATE, quantity INT); INSERT INTO silver_mine_2 (site_id, country, num_employees, extraction_date, quantity) VALUES (1, 'Mexico', 35, '2017-05-02', 1200), (2, 'Mexico', 30, '2017-08-31', 1800), (3, 'Mexico', 37, '2017-07-04', 2200);", "reference_sql": "SELECT country, SUM(quantity) as total_silver_prod FROM silver_mine_2 WHERE num_employees < 40 AND country = 'Mexico' AND extraction_date >= '2017-05-01' AND extraction_date <= '2017-09-30' GROUP BY country;", "generated_sql": "SELECT SUM(quantity) AS total_production\nFROM silver_mine_2\nWHERE country = 'Mexico'\n  AND extraction_date BETWEEN '2017-05-01' AND '2017-09-30'\n  AND num_employees < 40;", "raw_model_output": "```sql\nSELECT SUM(quantity) AS total_production\nFROM silver_mine_2\nWHERE country = 'Mexico'\n  AND extraction_date BETWEEN '2017-05-01' AND '2017-09-30'\n  AND num_employees < 40;\n```", "latency_sec": 1.673638105392456, "total_duration_sec": 1.668537872, "load_duration_sec": 0.020609161, "tokens_prompt": 256, "prompt_eval_sec": 0.064619471, "tokens_completion": 66, "completion_eval_sec": 1.578920542, "tokens_total": 322, "tokens_per_sec": 192.39523703632054, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes 'country' in the SELECT clause and groups by 'country', while the Generated SQL omits 'country' and lacks a GROUP BY clause. Although both filter the same data, the Reference query returns two columns (country and total_silver_prod) whereas the Generated query returns only one column (total_production). The presence of the 'country' column in the Reference query makes the result sets structurally different, even though the numerical sum may be the same."}
{"example_id": 3518, "sql_complexity": "basic SQL", "prompt": "Insert new records of ticket sales for a new event, including event and salesperson information.", "context": "CREATE TABLE salesperson (salesperson_id INT, name VARCHAR(50), position VARCHAR(50)); CREATE TABLE tickets (ticket_id INT, salesperson_id INT, event_id INT, price DECIMAL(5,2), quantity INT); CREATE TABLE events (event_id INT, name VARCHAR(50), date DATE); INSERT INTO salesperson VALUES (1, 'John Doe', 'Senior Salesperson'); INSERT INTO events VALUES (2, 'New Event', '2023-04-15');", "reference_sql": "INSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity) VALUES (2, 1, 2, 75, 50), (3, 2, 2, 65, 75); INSERT INTO events (event_id, name, date) VALUES (2, 'New Event', '2023-04-15');", "generated_sql": "-- Step 1: Insert new event into events table\nINSERT INTO events (event_id, name, date)\nVALUES (3, 'Spring Festival', '2023-05-15');\n\n-- Step 2: Ensure we have a salesperson record (if needed). In this case, we already have one.\n-- We can skip this step since the salesperson with ID 1 exists.\n\n-- Step 3: Insert new ticket sales into tickets table\nINSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity)\nVALUES \n(101, 1, 3, 50.00, 2),\n(102, 1, 3, 75.00, 1);", "raw_model_output": "To insert new records of ticket sales for a new event, we need to follow these steps:\n\n1. Insert the new event into the `events` table.\n2. Identify or create a salesperson record if needed (assuming we already have a salesperson in the database).\n3. Insert the new ticket sales into the `tickets` table.\n\nLet's assume that the new event is \"Spring Festival\" and it will take place on '2023-05-15'. We'll also assume that the existing salesperson with ID 1 (John Doe) will handle these tickets.\n\nHere are the SQL statements to achieve this:\n\n```sql\n-- Step 1: Insert new event into events table\nINSERT INTO events (event_id, name, date)\nVALUES (3, 'Spring Festival', '2023-05-15');\n\n-- Step 2: Ensure we have a salesperson record (if needed). In this case, we already have one.\n-- We can skip this step since the salesperson with ID 1 exists.\n\n-- Step 3: Insert new ticket sales into tickets table\nINSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity)\nVALUES \n(101, 1, 3, 50.00, 2),\n(102, 1, 3, 75.00, 1);\n```\n\nThis will insert two new ticket sales records for the \"Spring Festival\" event handled by John Doe (salesperson ID 1).", "latency_sec": 7.661892890930176, "total_duration_sec": 7.655484159, "load_duration_sec": 0.013867993, "tokens_prompt": 194, "prompt_eval_sec": 0.045816496, "tokens_completion": 321, "completion_eval_sec": 7.593561725, "tokens_total": 515, "tokens_per_sec": 67.21576604257092, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL inserts data for event_id=2 (existing event) with two tickets involving salesperson_id=1 and 2, while the Generated SQL inserts data for a new event_id=3 with two tickets only for salesperson_id=1. The event IDs, salesperson IDs, and ticket details differ significantly between the two queries."}
{"example_id": 3925, "sql_complexity": "set operations", "prompt": "What is the total number of students and staff with accommodations in the \"disability_services\" schema, excluding the \"accessibility_parking\" type?", "context": "CREATE SCHEMA disability_services; CREATE TABLE staff (id INT, name VARCHAR(50), accommodation VARCHAR(50)); CREATE TABLE students (id INT, name VARCHAR(50), accommodation VARCHAR(50));", "reference_sql": "SELECT COUNT(*) FROM disability_services.staff WHERE accommodation != 'accessibility_parking' UNION SELECT COUNT(*) FROM disability_services.students WHERE accommodation != 'accessibility_parking';", "generated_sql": "SELECT COUNT(*) AS total_count\nFROM (\n    SELECT id FROM disability_services.students WHERE accommodation IS NOT NULL AND accommodation != 'accessibility_parking'\n    UNION ALL\n    SELECT id FROM disability_services.staff WHERE accommodation IS NOT NULL AND accommodation != 'accessibility_parking'\n) AS combined_table;", "raw_model_output": "```sql\nSELECT COUNT(*) AS total_count\nFROM (\n    SELECT id FROM disability_services.students WHERE accommodation IS NOT NULL AND accommodation != 'accessibility_parking'\n    UNION ALL\n    SELECT id FROM disability_services.staff WHERE accommodation IS NOT NULL AND accommodation != 'accessibility_parking'\n) AS combined_table;\n```", "latency_sec": 1.5499107837677002, "total_duration_sec": 1.545620745, "load_duration_sec": 0.014596454, "tokens_prompt": 143, "prompt_eval_sec": 0.030054995, "tokens_completion": 65, "completion_eval_sec": 1.498756139, "tokens_total": 208, "tokens_per_sec": 134.20127285931247, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate counts (staff and students) as two rows, while the Generated SQL returns a single total count of combined staff and student records. The structure of the results differs (two rows vs. one row), making them non-equivalent."}
{"example_id": 3340, "sql_complexity": "subqueries", "prompt": "Calculate the total revenue for garments manufactured in the US and sold in California.", "context": "CREATE TABLE garment_manufacturing(id INT PRIMARY KEY, garment_id INT, country VARCHAR(50), material VARCHAR(50), manufacturing_date DATE, quantity INT); CREATE TABLE garment_sales(id INT PRIMARY KEY, garment_id INT, store_id INT, sale_date DATE, units INT, revenue DECIMAL(10,2));", "reference_sql": "SELECT SUM(gs.revenue) FROM garment_manufacturing gm JOIN garment_sales gs ON gm.garment_id = gs.garment_id WHERE gm.country = 'United States' AND gs.store_id IN (SELECT id FROM stores WHERE region = 'California');", "generated_sql": "SELECT SUM(gs.revenue) AS total_revenue\nFROM garment_manufacturing gm\nJOIN garment_sales gs ON gm.garment_id = gs.garment_id\nWHERE gm.country = 'US' AND s.state = 'California';", "raw_model_output": "To calculate the total revenue for garments manufactured in the US and sold in California, you need to join the `garment_manufacturing` table with the `garment_sales` table on the `garment_id`, filter by the manufacturing country (US) and sales store location (California), and then sum up the revenue.\n\nHere is the SQL statement:\n\n```sql\nSELECT SUM(gs.revenue) AS total_revenue\nFROM garment_manufacturing gm\nJOIN garment_sales gs ON gm.garment_id = gs.garment_id\nWHERE gm.country = 'US' AND s.state = 'California';\n```\n\nHowever, there's a missing reference to the store location in `garment_sales` table. Assuming that there is another table called `store_locations` with columns `id`, `state`, and `store_id`, you can join it as follows:\n\n```sql\nSELECT SUM(gs.revenue) AS total_revenue\nFROM garment_manufacturing gm\nJOIN garment_sales gs ON gm.garment_id = gs.garment_id\nJOIN store_locations sl ON gs.store_id = sl.id\nWHERE gm.country = 'US' AND sl.state = 'California';\n```\n\nIf `store_locations` table is not available, you need to assume that the state information is directly stored in `garment_sales`. If it's not, please provide additional schema details. Assuming `state` column exists in `garment_sales`, here\u2019s the SQL:\n\n```sql\nSELECT SUM(gs.revenue) AS total_revenue\nFROM garment_manufacturing gm\nJOIN garment_sales gs ON gm.garment_id = gs.garment_id\nWHERE gm.country = 'US' AND gs.state = 'California';\n```\n\nThis query will give you the total revenue for garments manufactured in the US and sold in California.", "latency_sec": 8.775062084197998, "total_duration_sec": 8.768635667, "load_duration_sec": 0.015858786, "tokens_prompt": 151, "prompt_eval_sec": 0.032021404, "tokens_completion": 371, "completion_eval_sec": 8.717584604, "tokens_total": 522, "tokens_per_sec": 59.486758611088334, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL uses a subquery to filter store_id values from the 'stores' table where region = 'California', while the Generated SQL references an undefined table alias 's' (missing JOIN/alias definition) and uses 's.state = 'California'' which is invalid. The Generated SQL contains a syntax error and would not execute, making it semantically different from the Reference SQL."}
{"example_id": 596, "sql_complexity": "basic SQL", "prompt": "What is the minimum energy production cost of wind farms in Spain?", "context": "CREATE TABLE wind_farm_costs (id INT, name TEXT, country TEXT, energy_production_cost FLOAT); INSERT INTO wind_farm_costs (id, name, country, energy_production_cost) VALUES (1, 'Las Tiesas', 'Spain', 0.045), (2, 'Eolo', 'Spain', 0.050);", "reference_sql": "SELECT MIN(energy_production_cost) FROM wind_farm_costs WHERE country = 'Spain';", "generated_sql": "SELECT MIN(energy_production_cost) AS min_energy_production_cost \nFROM wind_farm_costs \nWHERE country = 'Spain';", "raw_model_output": "```sql\nSELECT MIN(energy_production_cost) AS min_energy_production_cost \nFROM wind_farm_costs \nWHERE country = 'Spain';\n```", "latency_sec": 0.7562398910522461, "total_duration_sec": 0.750495919, "load_duration_sec": 0.014726048, "tokens_prompt": 157, "prompt_eval_sec": 0.03134998, "tokens_completion": 30, "completion_eval_sec": 0.701955414, "tokens_total": 187, "tokens_per_sec": 247.27603266181154, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the minimum energy_production_cost from the wind_farm_costs table where country is 'Spain'. The generated query adds an alias (min_energy_production_cost) to the result column, but this does not affect the semantic meaning or the actual data returned. The WHERE clause and aggregate function are identical in both queries."}
{"example_id": 2604, "sql_complexity": "subqueries", "prompt": "What is the maximum number of virtual tours taken by a single user in the UK?", "context": "CREATE TABLE virtual_tour_data (user_id INT, hotel_id INT, tour_date DATE); INSERT INTO virtual_tour_data (user_id, hotel_id, tour_date) VALUES (1, 10, '2022-01-01'), (2, 11, '2022-01-03'), (3, 12, '2022-01-05'), (4, 10, '2022-01-07'), (5, 10, '2022-01-09'); CREATE TABLE hotels (hotel_id INT, hotel_name TEXT, country TEXT); INSERT INTO hotels (hotel_id, hotel_name, country) VALUES (10, 'Royal Park Hotel', 'UK'), (11, 'The Ritz London', 'UK'), (12, 'Hotel de Crillon', 'France');", "reference_sql": "SELECT MAX(vt.user_tours) FROM (SELECT user_id, COUNT(DISTINCT hotel_id) as user_tours FROM virtual_tour_data WHERE country = 'UK' GROUP BY user_id) as vt;", "generated_sql": "SELECT MAX(tour_count) AS max_tours_per_user\nFROM (\n    SELECT v.user_id, COUNT(v.tour_date) AS tour_count\n    FROM virtual_tour_data v\n    JOIN hotels h ON v.hotel_id = h.hotel_id\n    WHERE h.country = 'UK'\n    GROUP BY v.user_id\n) AS user_tour_counts;", "raw_model_output": "To find the maximum number of virtual tours taken by a single user for hotels located in the UK, you can use the following SQL query:\n\n```sql\nSELECT MAX(tour_count) AS max_tours_per_user\nFROM (\n    SELECT v.user_id, COUNT(v.tour_date) AS tour_count\n    FROM virtual_tour_data v\n    JOIN hotels h ON v.hotel_id = h.hotel_id\n    WHERE h.country = 'UK'\n    GROUP BY v.user_id\n) AS user_tour_counts;\n```\n\nThis query first joins the `virtual_tour_data` and `hotels` tables to filter out tours for UK hotels. Then it groups by `user_id` to count the number of tours each user has taken in the UK, and finally finds the maximum value among these counts.", "latency_sec": 4.0777270793914795, "total_duration_sec": 4.072639307, "load_duration_sec": 0.01501781, "tokens_prompt": 283, "prompt_eval_sec": 0.062087529, "tokens_completion": 167, "completion_eval_sec": 3.992054123, "tokens_total": 450, "tokens_per_sec": 110.35559546745185, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references a 'country' column in virtual_tour_data, which doesn't exist in the schema. The Generated SQL correctly joins with hotels to filter by country. Additionally, the Reference SQL uses COUNT(DISTINCT hotel_id) while the Generated SQL uses COUNT(tour_date), which would produce different results if users visited the same hotel multiple times. Even if the Reference SQL were fixed, the semantic logic differs between distinct hotel counts and total tour counts."}
{"example_id": 5812, "sql_complexity": "single join", "prompt": "Calculate the percentage of Shariah-compliant investments held by each investor in the top 5 countries with the highest percentage?", "context": "CREATE TABLE investors (investor_id INT, investor_name TEXT, country TEXT); INSERT INTO investors (investor_id, investor_name, country) VALUES (1, 'Al Thani', 'Qatar'), (2, 'Saudi Investment Group', 'Saudi Arabia'), (3, 'Temasek Holdings', 'Singapore'); CREATE TABLE investments (investment_id INT, investor_id INT, investment_type TEXT, investment_value DECIMAL, is_shariah_compliant BOOLEAN); INSERT INTO investments (investment_id, investor_id, investment_type, investment_value, is_shariah_compliant) VALUES (1, 1, 'Real Estate', 15000000, true), (2, 2, 'Stocks', 20000000, false);", "reference_sql": "SELECT investor_name, ROUND((SUM(CASE WHEN is_shariah_compliant THEN investment_value ELSE 0 END) / SUM(investment_value)) * 100, 2) AS percentage FROM investments JOIN investors ON investments.investor_id = investors.investor_id GROUP BY investor_name ORDER BY percentage DESC LIMIT 5;", "generated_sql": "WITH total_investment AS (\n    SELECT \n        i.country,\n        SUM(iv.investment_value) AS total_investment_value\n    FROM \n        investors i\n    JOIN \n        investments iv ON i.investor_id = iv.investor_id\n    GROUP BY \n        i.country\n),\nshariah_compliant_investment AS (\n    SELECT \n        i.country,\n        SUM(CASE WHEN iv.is_shariah_compliant THEN iv.investment_value ELSE 0 END) AS shariah_compliant_value\n    FROM \n        investors i\n    JOIN \n        investments iv ON i.investor_id = iv.investor_id\n    GROUP BY \n        i.country\n),\ncountry_percentage AS (\n    SELECT \n        ti.country,\n        (sc.shariah_compliant_value * 100.0 / ti.total_investment_value) AS shariah_compliance_percentage\n    FROM \n        total_investment ti\n    JOIN \n        shariah_compliant_investment sc ON ti.country = sc.country\n),\ntop_countries AS (\n    SELECT \n        country,\n        shariah_compliance_percentage\n    FROM \n        country_percentage\n    ORDER BY \n        shariah_compliance_percentage DESC\n    LIMIT 5\n)\nSELECT \n    i.investor_name,\n    c.country,\n    (iv.shariah_compliant_value * 100.0 / iv.total_investment_value) AS investor_shariah_compliance_percentage\nFROM (\n    SELECT \n        country,\n        SUM(CASE WHEN is_shariah_compliant THEN investment_value ELSE 0 END) AS shariah_compliant_value,\n        SUM(investment_value) AS total_investment_value\n    FROM \n        investments iv\n    JOIN \n        investors i ON iv.investor_id = i.investor_id\n    WHERE \n        i.country IN (SELECT country FROM top_countries)\n    GROUP BY \n        i.investor_name, i.country\n) iv\nJOIN \n    investors i ON iv.investor_name = i.investor_name AND iv.country = i.country;", "raw_model_output": "To calculate the percentage of Shariah-compliant investments held by each investor in the top 5 countries with the highest percentage, we need to follow these steps:\n\n1. Calculate the total investment value for each country.\n2. Calculate the total Shariah-compliant investment value for each country.\n3. Compute the percentage of Shariah-compliant investments for each country.\n4. Identify the top 5 countries based on this percentage.\n5. For those top 5 countries, calculate the percentage of Shariah-compliant investments held by each investor.\n\nHere is the SQL query to achieve that:\n\n```sql\nWITH total_investment AS (\n    SELECT \n        i.country,\n        SUM(iv.investment_value) AS total_investment_value\n    FROM \n        investors i\n    JOIN \n        investments iv ON i.investor_id = iv.investor_id\n    GROUP BY \n        i.country\n),\nshariah_compliant_investment AS (\n    SELECT \n        i.country,\n        SUM(CASE WHEN iv.is_shariah_compliant THEN iv.investment_value ELSE 0 END) AS shariah_compliant_value\n    FROM \n        investors i\n    JOIN \n        investments iv ON i.investor_id = iv.investor_id\n    GROUP BY \n        i.country\n),\ncountry_percentage AS (\n    SELECT \n        ti.country,\n        (sc.shariah_compliant_value * 100.0 / ti.total_investment_value) AS shariah_compliance_percentage\n    FROM \n        total_investment ti\n    JOIN \n        shariah_compliant_investment sc ON ti.country = sc.country\n),\ntop_countries AS (\n    SELECT \n        country,\n        shariah_compliance_percentage\n    FROM \n        country_percentage\n    ORDER BY \n        shariah_compliance_percentage DESC\n    LIMIT 5\n)\nSELECT \n    i.investor_name,\n    c.country,\n    (iv.shariah_compliant_value * 100.0 / iv.total_investment_value) AS investor_shariah_compliance_percentage\nFROM (\n    SELECT \n        country,\n        SUM(CASE WHEN is_shariah_compliant THEN investment_value ELSE 0 END) AS shariah_compliant_value,\n        SUM(investment_value) AS total_investment_value\n    FROM \n        investments iv\n    JOIN \n        investors i ON iv.investor_id = i.investor_id\n    WHERE \n        i.country IN (SELECT country FROM top_countries)\n    GROUP BY \n        i.investor_name, i.country\n) iv\nJOIN \n    investors i ON iv.investor_name = i.investor_name AND iv.country = i.country;\n```\n\nThis query first calculates the total and Shariah-compliant investment values for each country. Then it computes the percentage of Shariah-compliant investments per country and identifies the top 5 countries based on this percentage. Finally, it calculates the percentage of Shariah-compliant investments held by each investor in those top countries.", "latency_sec": 14.663094997406006, "total_duration_sec": 14.655765814, "load_duration_sec": 0.013939021, "tokens_prompt": 256, "prompt_eval_sec": 0.057823457, "tokens_completion": 617, "completion_eval_sec": 14.580816985, "tokens_total": 873, "tokens_per_sec": 59.537225950895035, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL calculates the shariah compliance percentage per investor, grouping by investor_name. The Generated SQL calculates country-level compliance percentages, filters top countries, and then shows investor-level data within those countries. Key differences: 1) The Generated SQL includes 'country' in the output and groups by both investor_name and country, 2) It uses country-level aggregates before filtering, while the Reference calculates directly per investor, 3) The Generated SQL's final calculation is based on country-level totals rather than individual investor totals."}
{"example_id": 4706, "sql_complexity": "multiple_joins", "prompt": "Who are the top 3 customers by total spend on makeup products from Italy and Spain?", "context": "CREATE TABLE customers (customer_id INT, customer_name TEXT, country TEXT); INSERT INTO customers (customer_id, customer_name, country) VALUES (1, 'Alessandro Martini', 'IT'), (2, 'Laura Rossi', 'ES'), (3, 'Daniela Gonzalez', 'MX'), (4, 'Jose Hernandez', 'ES'), (5, 'Sophia Rodriguez', 'IT'); CREATE TABLE sales (sale_id INT, customer_id INT, product_id INT, sale_quantity INT, sale_country TEXT); INSERT INTO sales (sale_id, customer_id, product_id, sale_quantity, sale_country) VALUES (1, 1, 1, 100, 'IT'), (2, 2, 2, 150, 'ES'), (3, 3, 3, 200, 'MX'), (4, 4, 4, 250, 'ES'), (5, 5, 5, 300, 'IT'); CREATE TABLE products (product_id INT, product_name TEXT, category TEXT); INSERT INTO products (product_id, product_name, category) VALUES (1, 'Eyeshadow Palette', 'makeup'), (2, 'Liquid Lipstick', 'makeup'), (3, 'BB Cream', 'makeup'), (4, 'Volumizing Mascara', 'makeup'), (5, 'Nourishing Lip Balm', 'makeup');", "reference_sql": "SELECT c.customer_name, SUM(s.sale_quantity) as total_spent_on_makeup FROM sales s JOIN customers c ON s.customer_id = c.customer_id JOIN products p ON s.product_id = p.product_id WHERE c.country IN ('IT', 'ES') AND p.category = 'makeup' GROUP BY c.customer_name ORDER BY total_spent_on_makeup DESC LIMIT 3;", "generated_sql": "SELECT \n    c.customer_id,\n    c.customer_name,\n    SUM(s.sale_quantity) AS total_spend\nFROM \n    customers c\nJOIN \n    sales s ON c.customer_id = s.customer_id\nJOIN \n    products p ON s.product_id = p.product_id\nWHERE \n    c.country IN ('IT', 'ES')\nGROUP BY \n    c.customer_id, c.customer_name\nORDER BY \n    total_spend DESC\nLIMIT 3;", "raw_model_output": "To determine the top 3 customers by total spend on makeup products from Italy and Spain, we need to join the `customers`, `sales`, and `products` tables. We will filter for sales in Italy and Spain and then calculate the total quantity sold per customer. Finally, we will order the results by this total quantity in descending order and limit the result to the top 3 customers.\n\nHere is the SQL query:\n\n```sql\nSELECT \n    c.customer_id,\n    c.customer_name,\n    SUM(s.sale_quantity) AS total_spend\nFROM \n    customers c\nJOIN \n    sales s ON c.customer_id = s.customer_id\nJOIN \n    products p ON s.product_id = p.product_id\nWHERE \n    c.country IN ('IT', 'ES')\nGROUP BY \n    c.customer_id, c.customer_name\nORDER BY \n    total_spend DESC\nLIMIT 3;\n```\n\nThis query joins the `customers`, `sales`, and `products` tables to filter for customers from Italy or Spain who have purchased makeup products. It then groups by customer ID and name, sums up their sale quantities (assuming quantity directly correlates with spend), orders the results in descending order of total spend, and limits the output to the top 3 customers.", "latency_sec": 6.225346088409424, "total_duration_sec": 6.217158856, "load_duration_sec": 0.014052032, "tokens_prompt": 392, "prompt_eval_sec": 0.08932571, "tokens_completion": 257, "completion_eval_sec": 6.11112948, "tokens_total": 649, "tokens_per_sec": 104.25123210552613, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Generated SQL omits the 'p.category = 'makeup'' condition from the WHERE clause, which filters only makeup products in the Reference SQL. Second, the Generated SQL groups by both customer_id and customer_name, while the Reference SQL groups only by customer_name. These differences would produce different results, as the Generated SQL would aggregate sales across all product categories and might handle duplicate customer names differently."}
{"example_id": 1515, "sql_complexity": "multiple_joins", "prompt": "What is the average age of clients who lost cases in the 'personal injury' category?", "context": "CREATE TABLE Cases (CaseID int, ClientID int, Category varchar(50)); INSERT INTO Cases (CaseID, ClientID, Category) VALUES (701, 7, 'Personal Injury'); CREATE TABLE Clients (ClientID int, Age int, Gender varchar(10)); INSERT INTO Clients (ClientID, Age, Gender) VALUES (7, 45, 'Male'); CREATE TABLE CaseOutcomes (CaseID int, Outcome varchar(50)); INSERT INTO CaseOutcomes (CaseID, Outcome) VALUES (701, 'Lost');", "reference_sql": "SELECT AVG(C.Age) as AvgAge FROM Clients C INNER JOIN Cases CA ON C.ClientID = CA.ClientID INNER JOIN CaseOutcomes CO ON CA.CaseID = CO.CaseID WHERE CA.Category = 'Personal Injury' AND CO.Outcome = 'Lost';", "generated_sql": "SELECT AVG(c.Age) AS AverageAge\nFROM Clients c\nJOIN Cases cs ON c.ClientID = cs.ClientID\nJOIN CaseOutcomes co ON cs.CaseID = co.CaseID\nWHERE cs.Category = 'Personal Injury' AND co.Outcome = 'Lost';", "raw_model_output": "To find the average age of clients who lost cases in the 'Personal Injury' category, you can use a JOIN operation to connect the `Cases`, `Clients`, and `CaseOutcomes` tables. Then, filter for the relevant conditions (i.e., where the outcome is 'Lost' and the case category is 'Personal Injury') before calculating the average age.\n\nHere's the SQL query:\n\n```sql\nSELECT AVG(c.Age) AS AverageAge\nFROM Clients c\nJOIN Cases cs ON c.ClientID = cs.ClientID\nJOIN CaseOutcomes co ON cs.CaseID = co.CaseID\nWHERE cs.Category = 'Personal Injury' AND co.Outcome = 'Lost';\n```\n\nThis query calculates the average age of clients who meet both conditions: their cases are in the 'Personal Injury' category and they lost those cases.", "latency_sec": 4.126468658447266, "total_duration_sec": 4.121465417, "load_duration_sec": 0.025289299, "tokens_prompt": 205, "prompt_eval_sec": 0.045375923, "tokens_completion": 172, "completion_eval_sec": 4.048162854, "tokens_total": 377, "tokens_per_sec": 91.36141122221925, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform the same operations: joining Clients, Cases, and CaseOutcomes tables on identical conditions, filtering with the same WHERE clause ('Personal Injury' and 'Lost'), and calculating the average age from the Clients table. The only differences are table aliases (C/CA/CO vs c/cs/co), which do not affect semantic equivalence."}
{"example_id": 4388, "sql_complexity": "subqueries", "prompt": "Insert a new drug with a price 10% higher than the average price", "context": "CREATE TABLE drugs (drug_id INT, drug_name VARCHAR(50), price DECIMAL(10, 2)); INSERT INTO drugs (drug_id, drug_name, price) VALUES (1, 'DrugA', 50), (2, 'DrugB', 75), (3, 'DrugC', 100)", "reference_sql": "INSERT INTO drugs (drug_id, drug_name, price) VALUES ((SELECT MAX(drug_id) FROM drugs) + 1, 'DrugD', (SELECT AVG(price) * 1.1 FROM drugs))", "generated_sql": "WITH avg_price AS (\n    SELECT AVG(price) AS avg_p FROM drugs\n),\nnew_drug_price AS (\n    SELECT (avg_p * 1.10) AS price FROM avg_price\n)\nINSERT INTO drugs (drug_id, drug_name, price)\nVALUES ((SELECT MAX(drug_id) + 1 FROM drugs), 'NewDrug', (SELECT price FROM new_drug_price));", "raw_model_output": "To insert a new drug with a price that is 10% higher than the average price of existing drugs in the `drugs` table, you can follow these steps:\n\n1. Calculate the average price of all drugs.\n2. Compute the price for the new drug by increasing the average price by 10%.\n3. Insert the new drug into the `drugs` table with a unique `drug_id`.\n\nHere is the SQL statement to achieve this:\n\n```sql\nWITH avg_price AS (\n    SELECT AVG(price) AS avg_p FROM drugs\n),\nnew_drug_price AS (\n    SELECT (avg_p * 1.10) AS price FROM avg_price\n)\nINSERT INTO drugs (drug_id, drug_name, price)\nVALUES ((SELECT MAX(drug_id) + 1 FROM drugs), 'NewDrug', (SELECT price FROM new_drug_price));\n```\n\nThis SQL statement uses Common Table Expressions (CTEs) to first calculate the average price and then compute the new drug's price. Finally, it inserts a new row into the `drugs` table with an incremented `drug_id`.", "latency_sec": 5.433381080627441, "total_duration_sec": 5.428222021, "load_duration_sec": 0.02477427, "tokens_prompt": 158, "prompt_eval_sec": 0.032061095, "tokens_completion": 230, "completion_eval_sec": 5.369168654, "tokens_total": 388, "tokens_per_sec": 71.41041540108469, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the inserted drug_name values ('DrugD' vs 'NewDrug'), which makes their results semantically distinct. While both calculate the same price and drug_id, the drug_name discrepancy ensures the output rows are not identical."}
{"example_id": 5431, "sql_complexity": "basic SQL", "prompt": "What is the average CO2 emission of ride-hailing vehicles in San Francisco?", "context": "CREATE TABLE SFRideHailing (id INT, company VARCHAR(20), co2_emission DECIMAL(5,2));", "reference_sql": "SELECT AVG(co2_emission) FROM SFRideHailing WHERE company = 'Uber';", "generated_sql": "SELECT AVG(co2_emission) AS avg_co2_emission\nFROM SFRideHailing;", "raw_model_output": "To find the average CO2 emission of ride-hailing vehicles in San Francisco, you can use the following SQL query:\n\n```sql\nSELECT AVG(co2_emission) AS avg_co2_emission\nFROM SFRideHailing;\n```", "latency_sec": 1.194911003112793, "total_duration_sec": 1.188778666, "load_duration_sec": 0.014224222, "tokens_prompt": 113, "prompt_eval_sec": 0.024525833, "tokens_completion": 50, "completion_eval_sec": 1.147987732, "tokens_total": 163, "tokens_per_sec": 136.41183282719652, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters results to only include rows where company = 'Uber', while the Generated SQL calculates the average for all companies without any filtering. Unless all rows in the table have company 'Uber', the two queries would produce different results."}
{"example_id": 3531, "sql_complexity": "single join", "prompt": "What is the total number of workouts and total workout time per user for users with a membership type of 'Basic'?", "context": "CREATE TABLE Members (id INT, user_name VARCHAR, membership_type VARCHAR, signup_date DATE); CREATE TABLE Workouts (id INT, user_id INT, workout_date DATE, workout_duration INT); INSERT INTO Members (id, user_name, membership_type, signup_date) VALUES (1, 'John Doe', 'Premium', '2020-01-01'), (2, 'Jane Smith', 'Basic', '2019-06-15'), (3, 'Alice Johnson', 'Premium', '2020-03-20'); INSERT INTO Workouts (id, user_id, workout_date, workout_duration) VALUES (1, 1, '2020-01-01', 60), (2, 1, '2020-01-02', 70), (3, 2, '2019-06-15', 90), (4, 3, '2020-03-20', 65), (5, 3, '2020-03-21', 70);", "reference_sql": "SELECT Members.user_name, SUM(Workouts.workout_duration) AS total_workout_time, COUNT(Workouts.id) AS total_workouts FROM Members JOIN Workouts ON Members.id = Workouts.user_id WHERE Members.membership_type = 'Basic' GROUP BY Members.user_name;", "generated_sql": "SELECT m.user_name, COUNT(w.id) AS total_workouts, SUM(w.workout_duration) AS total_workout_time\nFROM Members m\nJOIN Workouts w ON m.id = w.user_id\nWHERE m.membership_type = 'Basic'\nGROUP BY m.user_name;", "raw_model_output": "```sql\nSELECT m.user_name, COUNT(w.id) AS total_workouts, SUM(w.workout_duration) AS total_workout_time\nFROM Members m\nJOIN Workouts w ON m.id = w.user_id\nWHERE m.membership_type = 'Basic'\nGROUP BY m.user_name;\n```", "latency_sec": 1.62923002243042, "total_duration_sec": 1.624047683, "load_duration_sec": 0.024212602, "tokens_prompt": 341, "prompt_eval_sec": 0.078929531, "tokens_completion": 62, "completion_eval_sec": 1.518637717, "tokens_total": 403, "tokens_per_sec": 247.3561096049659, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same data by joining Members and Workouts tables on user_id, filtering for 'Basic' membership type, and grouping by user_name. The generated query uses table aliases (m/w) and swaps the order of COUNT and SUM in the SELECT clause, but these are syntactic variations that do not affect the semantic result. The aggregation logic and filtering conditions are identical."}
{"example_id": 5678, "sql_complexity": "set operations", "prompt": "How many public works projects are there in 'Sydney' and 'Melbourne' combined?", "context": "CREATE TABLE PublicWorksC(id INT, city VARCHAR(20), project VARCHAR(30)); INSERT INTO PublicWorksC(id, city, project) VALUES (1, 'Sydney', 'Park Renovation'), (2, 'Melbourne', 'Sidewalk Repair');", "reference_sql": "SELECT COUNT(*) FROM (SELECT city FROM PublicWorksC WHERE city = 'Sydney' UNION ALL SELECT city FROM PublicWorksC WHERE city = 'Melbourne') AS Total;", "generated_sql": "SELECT COUNT(id) AS project_count \nFROM PublicWorksC \nWHERE city IN ('Sydney', 'Melbourne');", "raw_model_output": "```sql\nSELECT COUNT(id) AS project_count \nFROM PublicWorksC \nWHERE city IN ('Sydney', 'Melbourne');\n```", "latency_sec": 0.7272911071777344, "total_duration_sec": 0.721811819, "load_duration_sec": 0.013809776, "tokens_prompt": 145, "prompt_eval_sec": 0.030463736, "tokens_completion": 29, "completion_eval_sec": 0.675517658, "tokens_total": 174, "tokens_per_sec": 239.24395373842805, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of rows where the city is either 'Sydney' or 'Melbourne'. The Reference SQL uses a UNION ALL to combine results from two separate SELECTs and then counts them, while the Generated SQL uses a single WHERE clause with IN. Since UNION ALL preserves duplicates and the WHERE IN clause includes all matching rows, the final count will be identical in both cases."}
{"example_id": 5792, "sql_complexity": "multiple_joins", "prompt": "How many cases were handled by attorneys in the 'Los Angeles' office?", "context": "CREATE TABLE offices (office_id INT, office_name VARCHAR(20), city VARCHAR(20), state VARCHAR(20)); INSERT INTO offices (office_id, office_name, city, state) VALUES (1, 'Boston', 'Boston', 'MA'), (2, 'New York', 'New York', 'NY'), (3, 'Los Angeles', 'Los Angeles', 'CA'); CREATE TABLE attorneys (attorney_id INT, office_id INT); INSERT INTO attorneys (attorney_id, office_id) VALUES (1, 1), (2, 2), (3, 3); CREATE TABLE cases (case_id INT, attorney_id INT); INSERT INTO cases (case_id, attorney_id) VALUES (1, 1), (2, 2), (3, 3);", "reference_sql": "SELECT COUNT(*) FROM cases JOIN attorneys ON cases.attorney_id = attorneys.attorney_id JOIN offices ON attorneys.office_id = offices.office_id WHERE offices.city = 'Los Angeles';", "generated_sql": "SELECT COUNT(c.case_id)\nFROM cases c\nJOIN attorneys a ON c.attorney_id = a.attorney_id\nJOIN offices o ON a.office_id = o.office_id\nWHERE o.office_name = 'Los Angeles';", "raw_model_output": "```sql\nSELECT COUNT(c.case_id)\nFROM cases c\nJOIN attorneys a ON c.attorney_id = a.attorney_id\nJOIN offices o ON a.office_id = o.office_id\nWHERE o.office_name = 'Los Angeles';\n```", "latency_sec": 1.2680132389068604, "total_duration_sec": 1.263003124, "load_duration_sec": 0.014174718, "tokens_prompt": 250, "prompt_eval_sec": 0.054031132, "tokens_completion": 50, "completion_eval_sec": 1.192559145, "tokens_total": 300, "tokens_per_sec": 236.5905897470176, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their WHERE clause conditions: the Reference SQL filters on 'offices.city = 'Los Angeles'', while the Generated SQL filters on 'offices.office_name = 'Los Angeles''. Although in the provided data the office_name and city columns match for the Los Angeles office, there is no constraint ensuring office_name and city are always identical. This makes the conditions semantically distinct."}
{"example_id": 5148, "sql_complexity": "window functions", "prompt": "List the unique types of smart city technologies that have been implemented in the top 3 most populous countries in the world.", "context": "CREATE TABLE smart_city_tech (tech_type VARCHAR(255), country VARCHAR(255)); CREATE TABLE country_populations (country VARCHAR(255), population INT);", "reference_sql": "SELECT DISTINCT tech_type FROM smart_city_tech SCT WHERE country IN (SELECT country FROM (SELECT country, ROW_NUMBER() OVER (ORDER BY population DESC) as rank FROM country_populations) CP WHERE rank <= 3);", "generated_sql": "SELECT DISTINCT s.tech_type\nFROM smart_city_tech s\nJOIN (\n    SELECT country, population\n    FROM country_populations\n    ORDER BY population DESC\n    LIMIT 3\n) c ON s.country = c.country;", "raw_model_output": "```sql\nSELECT DISTINCT s.tech_type\nFROM smart_city_tech s\nJOIN (\n    SELECT country, population\n    FROM country_populations\n    ORDER BY population DESC\n    LIMIT 3\n) c ON s.country = c.country;\n```", "latency_sec": 1.2478961944580078, "total_duration_sec": 1.242570743, "load_duration_sec": 0.013980698, "tokens_prompt": 131, "prompt_eval_sec": 0.026851067, "tokens_completion": 52, "completion_eval_sec": 1.199464764, "tokens_total": 183, "tokens_per_sec": 146.64681310249642, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve distinct tech_types from smart_city_tech where the country is among the top 3 most populous countries. The Reference SQL uses ROW_NUMBER() to rank countries by population descending and filters rank <= 3, while the Generated SQL uses ORDER BY population DESC with LIMIT 3. Both approaches effectively select the same top 3 countries, ensuring identical results."}
{"example_id": 5547, "sql_complexity": "multiple_joins", "prompt": "Which species have a population growth rate higher than the average for protected areas?", "context": "CREATE TABLE species (id INT, name VARCHAR(50), population DECIMAL(5,2), protected_area_id INT, growth_rate DECIMAL(5,2)); INSERT INTO species (id, name, population, protected_area_id, growth_rate) VALUES (1, 'Species 1', 500.00, 1, 0.05), (2, 'Species 2', 800.00, 1, 0.03), (3, 'Species 3', 1200.00, 2, 0.07), (4, 'Species 4', 700.00, 2, 0.02); CREATE TABLE protected_areas (id INT, name VARCHAR(50)); INSERT INTO protected_areas (id, name) VALUES (1, 'Area 1'), (2, 'Area 2');", "reference_sql": "SELECT s.name, s.growth_rate FROM species s INNER JOIN protected_areas pa ON s.protected_area_id = pa.id GROUP BY s.name, s.growth_rate HAVING s.growth_rate > (SELECT AVG(s.growth_rate) FROM species s INNER JOIN protected_areas pa ON s.protected_area_id = pa.id);", "generated_sql": "SELECT s.id AS species_id, s.name AS species_name, s.growth_rate AS species_growth_rate, pa.name AS protected_area_name\nFROM species s\nJOIN protected_areas pa ON s.protected_area_id = pa.id\nWHERE s.growth_rate > (\n    SELECT AVG(s2.growth_rate) \n    FROM species s2 \n    WHERE s2.protected_area_id = s.protected_area_id\n);", "raw_model_output": "To determine which species have a population growth rate higher than the average for their respective protected areas, we need to follow these steps:\n\n1. Calculate the average growth rate for each protected area.\n2. Compare each species' growth rate with its corresponding protected area's average growth rate.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT s.id AS species_id, s.name AS species_name, s.growth_rate AS species_growth_rate, pa.name AS protected_area_name\nFROM species s\nJOIN protected_areas pa ON s.protected_area_id = pa.id\nWHERE s.growth_rate > (\n    SELECT AVG(s2.growth_rate) \n    FROM species s2 \n    WHERE s2.protected_area_id = s.protected_area_id\n);\n```\n\nThis query joins the `species` and `protected_areas` tables, then filters out species whose growth rate is greater than the average growth rate of all species in their respective protected area.", "latency_sec": 4.73543119430542, "total_duration_sec": 4.729120571, "load_duration_sec": 0.011056598, "tokens_prompt": 278, "prompt_eval_sec": 0.061281136, "tokens_completion": 195, "completion_eval_sec": 4.653447965, "tokens_total": 473, "tokens_per_sec": 99.88530729129903, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates an overall average growth rate across all species, while the Generated SQL calculates a protected area-specific average. The HAVING clause in Reference uses a global average, whereas the Generated SQL's WHERE clause uses a correlated subquery that averages growth rates within the same protected area. Additionally, the Generated SQL returns different columns than the Reference SQL."}
{"example_id": 5498, "sql_complexity": "aggregation", "prompt": "Identify the destinations with the highest number of repeat visitors from the US.", "context": "CREATE TABLE RepeatTravelers (Visitor VARCHAR(20), Destination VARCHAR(20), VisitCount INT); INSERT INTO RepeatTravelers (Visitor, Destination, VisitCount) VALUES ('David', 'Paris', 3), ('Ella', 'London', 4), ('Fiona', 'Paris', 2);", "reference_sql": "SELECT Destination, AVG(VisitCount) AS AvgVisitCount FROM RepeatTravelers WHERE Visitor LIKE '%USA%' GROUP BY Destination ORDER BY AvgVisitCount DESC;", "generated_sql": "CREATE TABLE Visitors (Visitor VARCHAR(20), Country VARCHAR(20));\nINSERT INTO Visitors (Visitor, Country) VALUES ('David', 'US'), ('Ella', 'Canada'), ('Fiona', 'US');", "raw_model_output": "To identify the destinations with the highest number of repeat visitors from the US, we need to assume that there is a table containing information about the visitors' countries. Let's call this table `Visitors` and it would have columns like `Visitor` (VARCHAR) and `Country` (VARCHAR).\n\nGiven the schema provided:\n\n```sql\nCREATE TABLE Visitors (Visitor VARCHAR(20), Country VARCHAR(20));\nINSERT INTO Visitors (Visitor, Country) VALUES ('David', 'US'), ('Ella', 'Canada'), ('Fiona', 'US');\n```\n\nWe can now write a query to find the destinations with the highest number of repeat visitors from the US.\n\n```sql\nSELECT rt.Destination\nFROM RepeatTravelers rt\nJOIN Visitors v ON rt.Visitor = v.Visitor\nWHERE v.Country = 'US'\nGROUP BY rt.Destination, rt.VisitCount\nHAVING VisitCount = (\n    SELECT MAX(VisitCount)\n    FROM RepeatTravelers rt2\n    JOIN Visitors v2 ON rt2.Visitor = v2.Visitor\n    WHERE v2.Country = 'US'\n);\n```\n\nThis query joins the `RepeatTravelers` and `Visitors` tables to filter out visitors from the US, groups by destination and visit count, and then uses a subquery in the HAVING clause to find destinations with the maximum visit count among US visitors.", "latency_sec": 6.682667016983032, "total_duration_sec": 6.676669176, "load_duration_sec": 0.014759784, "tokens_prompt": 149, "prompt_eval_sec": 0.030615894, "tokens_completion": 283, "completion_eval_sec": 6.629408387, "tokens_total": 432, "tokens_per_sec": 64.64484896556037, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL is a query that selects from the RepeatTravelers table, while the Generated SQL contains DDL (CREATE TABLE) and DML (INSERT) statements. They are fundamentally different types of SQL operations and cannot be semantically equivalent."}
{"example_id": 3546, "sql_complexity": "window functions", "prompt": "What are the cryptocurrency exchanges with their corresponding blockchain companies, ranked by exchange ID in ascending order, for the Bitcoin platform?", "context": "CREATE TABLE cryptocurrency_exchanges (exchange_id INT, exchange_name VARCHAR(50), company_id INT); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (1, 'Binance', 1); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (2, 'Coinbase', 2); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (3, 'Kraken', 3); CREATE TABLE blockchain_companies (company_id INT, company_name VARCHAR(50), platform VARCHAR(50)); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (1, 'Binance', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (2, 'Blockstream', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (3, 'Blockchair', 'Bitcoin');", "reference_sql": "SELECT ce.exchange_name, bc.company_name, ce.exchange_id, ROW_NUMBER() OVER (PARTITION BY bc.platform ORDER BY ce.exchange_id ASC) as rank FROM cryptocurrency_exchanges ce JOIN blockchain_companies bc ON ce.company_id = bc.company_id WHERE bc.platform = 'Bitcoin';", "generated_sql": "SELECT ce.exchange_name, bc.company_name\nFROM cryptocurrency_exchanges ce\nJOIN blockchain_companies bc ON ce.company_id = bc.company_id\nWHERE bc.platform = 'Bitcoin'\nORDER BY ce.exchange_id ASC;", "raw_model_output": "```sql\nSELECT ce.exchange_name, bc.company_name\nFROM cryptocurrency_exchanges ce\nJOIN blockchain_companies bc ON ce.company_id = bc.company_id\nWHERE bc.platform = 'Bitcoin'\nORDER BY ce.exchange_id ASC;\n```", "latency_sec": 1.2622289657592773, "total_duration_sec": 1.254601051, "load_duration_sec": 0.023596257, "tokens_prompt": 290, "prompt_eval_sec": 0.065229602, "tokens_completion": 48, "completion_eval_sec": 1.163617355, "tokens_total": 338, "tokens_per_sec": 267.7802595004469, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes an additional 'exchange_id' column and a 'rank' calculated using ROW_NUMBER(), while the Generated SQL omits these. The Generated SQL also lacks the window function logic that defines the 'rank' in the Reference SQL. Although both queries join the same tables and filter by 'Bitcoin', the result sets differ in structure and content."}
{"example_id": 486, "sql_complexity": "single join", "prompt": "What is the average price of paintings from African artists in our collection?", "context": "CREATE TABLE Artworks (id INT, title VARCHAR(50), price DECIMAL(10,2), medium VARCHAR(50), artist_nationality VARCHAR(50)); CREATE TABLE Collections (id INT, name VARCHAR(50), continent VARCHAR(50));", "reference_sql": "SELECT AVG(Artworks.price) FROM Artworks INNER JOIN Collections ON Artworks.artist_nationality = Collections.continent WHERE Artworks.medium = 'Painting' AND Collections.continent = 'Africa';", "generated_sql": "SELECT AVG(price) AS avg_price\nFROM Artworks\nWHERE medium = 'painting' AND artist_nationality LIKE '%African%';", "raw_model_output": "To find the average price of paintings from African artists in your collection, you need to filter the artworks based on the medium and artist's nationality. Assuming that \"painting\" is a specific value for the `medium` column, here is the corresponding SQL query:\n\n```sql\nSELECT AVG(price) AS avg_price\nFROM Artworks\nWHERE medium = 'painting' AND artist_nationality LIKE '%African%';\n```\n\nThis query calculates the average price of artworks where the `medium` is \"painting\" and the `artist_nationality` includes the term \"African\".", "latency_sec": 2.871544122695923, "total_duration_sec": 2.867390863, "load_duration_sec": 0.014112689, "tokens_prompt": 140, "prompt_eval_sec": 0.027861625, "tokens_completion": 122, "completion_eval_sec": 2.823281112, "tokens_total": 262, "tokens_per_sec": 91.2401094342314, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their filtering conditions and join logic. The Reference SQL joins Artworks with Collections on artist_nationality = continent and filters Collections.continent = 'Africa', while the Generated SQL uses a LIKE condition on artist_nationality ('%African%') without any join. This leads to different datasets: the first requires exact continent matches, the second allows substring matches, and the join in the Reference SQL may introduce additional constraints not present in the Generated SQL."}
{"example_id": 794, "sql_complexity": "multiple_joins", "prompt": "Which suppliers have provided raw materials for the production of chemicals with high environmental impact?", "context": "CREATE TABLE suppliers (id INT, name TEXT); INSERT INTO suppliers (id, name) VALUES (1, 'Supplier1'), (2, 'Supplier2'), (3, 'Supplier3'); CREATE TABLE chemicals (id INT, name TEXT, environmental_impact INT); INSERT INTO chemicals (id, name, environmental_impact) VALUES (1, 'ChemA', 10), (2, 'ChemB', 20), (3, 'ChemC', 15); CREATE TABLE raw_materials (chemical_id INT, supplier_id INT); INSERT INTO raw_materials (chemical_id, supplier_id) VALUES (1, 1), (1, 2), (2, 3), (3, 1);", "reference_sql": "SELECT s.name FROM suppliers s INNER JOIN raw_materials rm ON s.id = rm.supplier_id INNER JOIN chemicals c ON rm.chemical_id = c.id WHERE c.environmental_impact > 10;", "generated_sql": "SELECT DISTINCT s.name AS supplier_name\nFROM suppliers s\nJOIN raw_materials rm ON s.id = rm.supplier_id\nJOIN chemicals c ON rm.chemical_id = c.id\nWHERE c.environmental_impact > 15;", "raw_model_output": "To determine which suppliers have provided raw materials for the production of chemicals with a high environmental impact, we need to follow these steps:\n\n1. Identify chemicals with a high environmental impact.\n2. Find the raw materials associated with those chemicals.\n3. Determine the suppliers providing those raw materials.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT DISTINCT s.name AS supplier_name\nFROM suppliers s\nJOIN raw_materials rm ON s.id = rm.supplier_id\nJOIN chemicals c ON rm.chemical_id = c.id\nWHERE c.environmental_impact > 15;\n```\n\nThis query selects the names of suppliers who provide raw materials for chemicals with an environmental impact greater than 15 (assuming \"high\" means a value above this threshold).", "latency_sec": 3.767057180404663, "total_duration_sec": 3.75975907, "load_duration_sec": 0.014294044, "tokens_prompt": 237, "prompt_eval_sec": 0.050923402, "tokens_completion": 156, "completion_eval_sec": 3.69228607, "tokens_total": 393, "tokens_per_sec": 104.32546711642517, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters chemicals with environmental_impact > 10, while the Generated SQL uses > 15. This changes the set of chemicals considered, leading to different results. For example, ChemC (impact 15) is included in the Reference SQL but excluded in the Generated SQL. Additionally, the Generated SQL uses DISTINCT, which could further alter results if duplicates existed, though the core filter difference makes them non-equivalent."}
{"example_id": 3164, "sql_complexity": "set operations", "prompt": "What is the average age of patients who received therapy in 'clinic_a' and 'clinic_b'?", "context": "CREATE TABLE clinic_a (patient_id INT, age INT, therapy_received BOOLEAN); INSERT INTO clinic_a (patient_id, age, therapy_received) VALUES (1, 35, true), (2, 42, true), (3, 28, false); CREATE TABLE clinic_b (patient_id INT, age INT, therapy_received BOOLEAN); INSERT INTO clinic_b (patient_id, age, therapy_received) VALUES (4, 50, true), (5, 32, false), (6, 45, true);", "reference_sql": "SELECT AVG(age) FROM (SELECT age FROM clinic_a WHERE therapy_received = true UNION ALL SELECT age FROM clinic_b WHERE therapy_received = true) AS combined_clinics;", "generated_sql": "SELECT AVG(age) AS avg_age\nFROM (\n    SELECT age FROM clinic_a WHERE therapy_received = true\n    UNION ALL\n    SELECT age FROM clinic_b WHERE therapy_received = true\n) AS combined_therapy_patients;", "raw_model_output": "To find the average age of patients who received therapy in both `clinic_a` and `clinic_b`, you can use a combination of filtering conditions and aggregation. Here's the corresponding SQL query:\n\n```sql\nSELECT AVG(age) AS avg_age\nFROM (\n    SELECT age FROM clinic_a WHERE therapy_received = true\n    UNION ALL\n    SELECT age FROM clinic_b WHERE therapy_received = true\n) AS combined_therapy_patients;\n```\n\nThis query first selects the ages of patients who received therapy from both clinics and then calculates the average age of those patients.", "latency_sec": 2.779090166091919, "total_duration_sec": 2.771495106, "load_duration_sec": 0.024530757, "tokens_prompt": 204, "prompt_eval_sec": 0.044997979, "tokens_completion": 115, "completion_eval_sec": 2.699927214, "tokens_total": 319, "tokens_per_sec": 114.78576833964048, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average age of patients who received therapy by combining rows from clinic_a and clinic_b where therapy_received is true. The only differences are the subquery alias names and a column alias in the outer query, which do not affect the result's semantic content."}
{"example_id": 3704, "sql_complexity": "aggregation", "prompt": "What is the total sales revenue for each category of garments in the South America region in Q1 2022?", "context": "CREATE TABLE sales_category (sale_id INT, garment_category VARCHAR(50), sale_date DATE, total_sales DECIMAL(10, 2), region VARCHAR(50));", "reference_sql": "SELECT garment_category, SUM(total_sales) FROM sales_category WHERE sale_date BETWEEN '2022-01-01' AND '2022-03-31' AND region = 'South America' GROUP BY garment_category;", "generated_sql": "SELECT garment_category, SUM(total_sales) AS total_revenue\nFROM sales_category\nWHERE region = 'South America' AND sale_date BETWEEN '2022-01-01' AND '2022-03-31'\nGROUP BY garment_category;", "raw_model_output": "```sql\nSELECT garment_category, SUM(total_sales) AS total_revenue\nFROM sales_category\nWHERE region = 'South America' AND sale_date BETWEEN '2022-01-01' AND '2022-03-31'\nGROUP BY garment_category;\n```", "latency_sec": 1.50022292137146, "total_duration_sec": 1.496116111, "load_duration_sec": 0.014212032, "tokens_prompt": 131, "prompt_eval_sec": 0.027639632, "tokens_completion": 63, "completion_eval_sec": 1.452135068, "tokens_total": 194, "tokens_per_sec": 129.31411541336195, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (garment_category and SUM(total_sales)), apply identical WHERE conditions (region = 'South America' and sale_date between '2022-01-01' and '2022-03-31'), and group by the same column (garment_category). The only difference is the alias 'total_revenue' in the generated query, which does not affect the semantic result content."}
{"example_id": 2851, "sql_complexity": "single join", "prompt": "How many cases were handled by attorneys who joined the firm in 2015 or later?", "context": "CREATE TABLE attorneys (attorney_id INT, join_year INT); CREATE TABLE cases (case_id INT, attorney_id INT, billing_amount INT);", "reference_sql": "SELECT COUNT(DISTINCT cases.case_id) FROM cases INNER JOIN attorneys ON cases.attorney_id = attorneys.attorney_id WHERE attorneys.join_year >= 2015;", "generated_sql": "SELECT COUNT(case_id)\nFROM cases\nWHERE attorney_id IN (\n    SELECT attorney_id\n    FROM attorneys\n    WHERE join_year >= 2015\n);", "raw_model_output": "```sql\nSELECT COUNT(case_id)\nFROM cases\nWHERE attorney_id IN (\n    SELECT attorney_id\n    FROM attorneys\n    WHERE join_year >= 2015\n);\n```", "latency_sec": 0.9385080337524414, "total_duration_sec": 0.93441576, "load_duration_sec": 0.013885975, "tokens_prompt": 118, "prompt_eval_sec": 0.023898294, "tokens_completion": 39, "completion_eval_sec": 0.89414226, "tokens_total": 157, "tokens_per_sec": 167.28679388312332, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query uses COUNT(DISTINCT cases.case_id) while the generated query uses COUNT(case_id). If there are multiple entries in the 'cases' table with the same case_id for attorneys who joined in 2015 or later, the generated query would count duplicates whereas the reference query would count each case_id only once. This difference in handling duplicates makes them non-equivalent."}
{"example_id": 3246, "sql_complexity": "single join", "prompt": "What is the average eco-friendliness score of accommodations in Oceania by year?", "context": "CREATE TABLE Accommodations (Accommodation_ID INT, Accommodation_Name VARCHAR(50), City VARCHAR(30), Country VARCHAR(50), Eco_Friendliness_Score INT, Visit_Year INT); INSERT INTO Accommodations (Accommodation_ID, Accommodation_Name, City, Country, Eco_Friendliness_Score, Visit_Year) VALUES (1, 'EcoLodge', 'Sydney', 'Australia', 85, 2019), (2, 'GreenHotel', 'Melbourne', 'Australia', 90, 2019), (3, 'SustainableResort', 'Auckland', 'New Zealand', 80, 2019), (4, 'EcoVilla', 'Wellington', 'New Zealand', 88, 2019); CREATE TABLE Countries (Country VARCHAR(50), Continent VARCHAR(30)); INSERT INTO Countries (Country, Continent) VALUES ('Australia', 'Oceania'), ('New Zealand', 'Oceania');", "reference_sql": "SELECT C.Continent, V.Visit_Year, AVG(A.Eco_Friendliness_Score) AS Avg_Eco_Score  FROM Accommodations A  JOIN Countries C  ON A.Country = C.Country  WHERE C.Continent = 'Oceania'  GROUP BY C.Continent, V.Visit_Year  ORDER BY V.Visit_Year;", "generated_sql": "SELECT \n    a.Visit_Year,\n    AVG(a.Eco_Friendliness_Score) AS Average_Eco_Friendliness_Score\nFROM \n    Accommodations a\nJOIN \n    Countries c ON a.Country = c.Country\nWHERE \n    c.Continent = 'Oceania'\nGROUP BY \n    a.Visit_Year;", "raw_model_output": "To find the average eco-friendliness score of accommodations in Oceania by year, you can use a JOIN to connect the `Accommodations` table with the `Countries` table based on the country name. Then, you can group the results by year and calculate the average eco-friendliness score for each year.\n\nHere is the SQL query:\n\n```sql\nSELECT \n    a.Visit_Year,\n    AVG(a.Eco_Friendliness_Score) AS Average_Eco_Friendliness_Score\nFROM \n    Accommodations a\nJOIN \n    Countries c ON a.Country = c.Country\nWHERE \n    c.Continent = 'Oceania'\nGROUP BY \n    a.Visit_Year;\n```", "latency_sec": 3.679910898208618, "total_duration_sec": 3.675493684, "load_duration_sec": 0.013628925, "tokens_prompt": 309, "prompt_eval_sec": 0.067386098, "tokens_completion": 150, "completion_eval_sec": 3.592054123, "tokens_total": 459, "tokens_per_sec": 124.73128091863347, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes 'Continent' in both the SELECT and GROUP BY clauses, while the Generated SQL omits 'Continent'. Although the WHERE clause restricts to 'Oceania', the result sets differ in columns. The Reference query returns 'Continent', 'Visit_Year', and 'Avg_Eco_Score', whereas the Generated query only returns 'Visit_Year' and 'Average_Eco_Friendliness_Score'. This makes them semantically distinct."}
{"example_id": 3056, "sql_complexity": "multiple_joins", "prompt": "Identify all suppliers who provide non-GMO ingredients to restaurants with Michelin stars.", "context": "CREATE TABLE Suppliers (id INT, name VARCHAR(50), isNonGMO BOOLEAN); CREATE TABLE Restaurants (id INT, name VARCHAR(50), numStars INT); CREATE TABLE Ingredients (supplierId INT, restaurantId INT, isNonGMO BOOLEAN);", "reference_sql": "SELECT Suppliers.name FROM Suppliers INNER JOIN Ingredients ON Suppliers.id = Ingredients.supplierId INNER JOIN Restaurants ON Ingredients.restaurantId = Restaurants.id WHERE Restaurants.numStars > 2 AND Ingredients.isNonGMO = TRUE;", "generated_sql": "SELECT DISTINCT S.id, S.name\nFROM Suppliers S\nJOIN Ingredients I ON S.id = I.supplierId\nJOIN Restaurants R ON I.restaurantId = R.id\nWHERE I.isNonGMO = TRUE AND R.numStars > 0;", "raw_model_output": "To identify all suppliers who provide non-GMO ingredients to restaurants with Michelin stars, we need to join the `Suppliers`, `Restaurants`, and `Ingredients` tables. We will filter for non-GMO ingredients provided by suppliers to restaurants that have a number of stars greater than 0.\n\nHere is the SQL query:\n\n```sql\nSELECT DISTINCT S.id, S.name\nFROM Suppliers S\nJOIN Ingredients I ON S.id = I.supplierId\nJOIN Restaurants R ON I.restaurantId = R.id\nWHERE I.isNonGMO = TRUE AND R.numStars > 0;\n```\n\nThis query selects distinct supplier IDs and names from the `Suppliers` table where there is a corresponding entry in the `Ingredients` table indicating non-GMO ingredients provided to restaurants with Michelin stars (i.e., `numStars > 0`).", "latency_sec": 4.061955690383911, "total_duration_sec": 4.057833565, "load_duration_sec": 0.014560502, "tokens_prompt": 140, "prompt_eval_sec": 0.027623369, "tokens_completion": 173, "completion_eval_sec": 4.013374449, "tokens_total": 313, "tokens_per_sec": 77.05647817404359, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects: 1) The Reference SQL selects only 'Suppliers.name' while the Generated SQL selects 'S.id' and 'S.name', changing the output columns. 2) The WHERE clause in Reference uses 'Restaurants.numStars > 2' whereas Generated uses 'R.numStars > 0', altering the filtering condition. These differences ensure they do not produce identical results."}
{"example_id": 264, "sql_complexity": "set operations", "prompt": "List the number of community health centers and infectious disease tracking facilities in 'southwest' regions.", "context": "CREATE TABLE centers (id INT, name TEXT, region TEXT); INSERT INTO centers (id, name, region) VALUES (1, 'Center A', 'southwest'); INSERT INTO centers (id, name, region) VALUES (2, 'Center B', 'northeast'); INSERT INTO centers (id, name, region) VALUES (3, 'Center C', 'northwest'); CREATE TABLE diseases (id INT, name TEXT, region TEXT); INSERT INTO diseases (id, name, region) VALUES (1, 'Disease A', 'southwest'); INSERT INTO diseases (id, name, region) VALUES (2, 'Disease B', 'southeast');", "reference_sql": "SELECT COUNT(*) FROM ( (SELECT * FROM centers WHERE region = 'southwest') UNION (SELECT * FROM diseases WHERE region = 'southwest') );", "generated_sql": "SELECT \n    COUNT(CASE WHEN table_name = 'centers' THEN 1 END) AS center_count,\n    COUNT(CASE WHEN table_name = 'diseases' THEN 1 END) AS disease_facility_count\nFROM (\n    SELECT 'centers' AS table_name, id FROM centers WHERE region = 'southwest'\n    UNION ALL\n    SELECT 'diseases' AS table_name, id FROM diseases WHERE region = 'southwest'\n) AS facility_counts;", "raw_model_output": "```sql\nSELECT \n    COUNT(CASE WHEN table_name = 'centers' THEN 1 END) AS center_count,\n    COUNT(CASE WHEN table_name = 'diseases' THEN 1 END) AS disease_facility_count\nFROM (\n    SELECT 'centers' AS table_name, id FROM centers WHERE region = 'southwest'\n    UNION ALL\n    SELECT 'diseases' AS table_name, id FROM diseases WHERE region = 'southwest'\n) AS facility_counts;\n```", "latency_sec": 2.473219871520996, "total_duration_sec": 2.467561302, "load_duration_sec": 0.013446175, "tokens_prompt": 227, "prompt_eval_sec": 0.050895708, "tokens_completion": 102, "completion_eval_sec": 2.401030349, "tokens_total": 329, "tokens_per_sec": 133.02497031841716, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns a single count of unique rows from both tables combined, while the Generated SQL returns separate counts for each table. The Reference uses UNION (removes duplicates) and counts all rows, whereas the Generated uses UNION ALL (retains duplicates) and splits the count into two columns. The output structure and logic differ fundamentally."}
{"example_id": 2838, "sql_complexity": "basic SQL", "prompt": "What is the minimum safety rating of electric vehicles in the 'green_cars' table?", "context": "CREATE TABLE green_cars (id INT, make VARCHAR(50), model VARCHAR(50), type VARCHAR(50), safety_rating INT);", "reference_sql": "SELECT MIN(safety_rating) FROM green_cars WHERE type = 'Electric';", "generated_sql": "SELECT MIN(safety_rating) AS min_safety_rating \nFROM green_cars \nWHERE type = 'electric';", "raw_model_output": "```sql\nSELECT MIN(safety_rating) AS min_safety_rating \nFROM green_cars \nWHERE type = 'electric';\n```", "latency_sec": 0.6897327899932861, "total_duration_sec": 0.682527395, "load_duration_sec": 0.013810153, "tokens_prompt": 118, "prompt_eval_sec": 0.024993817, "tokens_completion": 28, "completion_eval_sec": 0.641575245, "tokens_total": 146, "tokens_per_sec": 211.67617680090456, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the minimum safety_rating from the green_cars table where the type matches a specific value. The difference in string case ('Electric' vs 'electric') is likely negligible in standard SQL implementations (case-insensitive comparisons by default), and the alias in the Generated SQL does not affect the result's content. The core logic and output data remain equivalent."}
{"example_id": 1187, "sql_complexity": "multiple_joins", "prompt": "Who are the top 3 authors with the highest number of articles published in The Guardian?", "context": "CREATE TABLE authors (id INT, name VARCHAR(100), publisher VARCHAR(50)); CREATE TABLE articles_authors (article_id INT, author_id INT); INSERT INTO authors (id, name, publisher) VALUES (1, 'Author1', 'The Guardian'), (2, 'Author2', 'The Guardian'), (3, 'Author3', 'The Guardian'); INSERT INTO articles_authors (article_id, author_id) VALUES (1, 1), (2, 2), (3, 1), (3, 2), (3, 3); INSERT INTO articles (id, title, publication_date, publisher) VALUES (1, 'Article1', '2021-01-01', 'The Guardian'), (2, 'Article2', '2021-01-02', 'The Guardian'), (3, 'Article3', '2021-01-03', 'The Guardian');", "reference_sql": "SELECT a.name, COUNT(aa.article_id) AS articles_count FROM authors a JOIN articles_authors aa ON a.id = aa.author_id JOIN articles ar ON aa.article_id = ar.id WHERE ar.publisher = 'The Guardian' GROUP BY a.name ORDER BY articles_count DESC LIMIT 3;", "generated_sql": "SELECT \n    a.id, \n    a.name,\n    COUNT(aa.article_id) AS article_count\nFROM \n    authors a\nJOIN \n    articles_authors aa ON a.id = aa.author_id\nJOIN \n    articles ar ON aa.article_id = ar.id AND ar.publisher = 'The Guardian'\nGROUP BY \n    a.id, a.name\nORDER BY \n    article_count DESC\nLIMIT 3;", "raw_model_output": "To find the top 3 authors with the highest number of articles published in \"The Guardian\", you can use a combination of `JOIN`, `GROUP BY`, and window functions or `ORDER BY` and `LIMIT`. Here is an example using standard ANSI SQL:\n\n```sql\nSELECT \n    a.id, \n    a.name,\n    COUNT(aa.article_id) AS article_count\nFROM \n    authors a\nJOIN \n    articles_authors aa ON a.id = aa.author_id\nJOIN \n    articles ar ON aa.article_id = ar.id AND ar.publisher = 'The Guardian'\nGROUP BY \n    a.id, a.name\nORDER BY \n    article_count DESC\nLIMIT 3;\n```\n\nThis query joins the `authors`, `articles_authors`, and `articles` tables to count the number of articles each author has published in \"The Guardian\" and then orders the results by the count in descending order to get the top 3 authors.", "latency_sec": 4.726366996765137, "total_duration_sec": 4.721486698, "load_duration_sec": 0.024571787, "tokens_prompt": 291, "prompt_eval_sec": 0.064479319, "tokens_completion": 194, "completion_eval_sec": 4.63014011, "tokens_total": 485, "tokens_per_sec": 102.61581471179622, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in output columns (Reference selects only 'name', Generated includes 'id' and 'name') and grouping logic (Reference groups by 'name', Generated groups by 'id' and 'name'). Additionally, the publisher filter is applied in the JOIN condition in Generated vs. WHERE clause in Reference, which could affect results if non-unique names exist. These differences make the queries not semantically equivalent."}
{"example_id": 360, "sql_complexity": "window functions", "prompt": "What is the change in crime rate for each category, between this year and last year, for the same time period?", "context": "CREATE TABLE CrimeStatistics (ID INT, CrimeType VARCHAR(50), Date TIMESTAMP, Count INT); INSERT INTO CrimeStatistics (ID, CrimeType, Date, Count) VALUES (1, 'Theft', '2022-01-01 00:00:00', 100), (2, 'Vandalism', '2022-01-01 00:00:00', 50), (3, 'Theft', '2022-01-02 00:00:00', 120), (4, 'Vandalism', '2022-01-02 00:00:00', 60), (5, 'Theft', '2021-01-01 00:00:00', 80), (6, 'Vandalism', '2021-01-01 00:00:00', 40), (7, 'Theft', '2021-01-02 00:00:00', 90), (8, 'Vandalism', '2021-01-02 00:00:00', 45);", "reference_sql": "SELECT CrimeType, (SUM(Count) OVER (PARTITION BY CrimeType ORDER BY EXTRACT(YEAR FROM Date) ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)) - SUM(Count) OVER (PARTITION BY CrimeType ORDER BY EXTRACT(YEAR FROM Date)) AS CrimeRateChange FROM CrimeStatistics WHERE Date BETWEEN DATE_TRUNC('year', CURRENT_DATE - INTERVAL '1 year') AND CURRENT_DATE;", "generated_sql": "SELECT \n    c1.CrimeType,\n    DATE_FORMAT(c1.Date, '%Y-%m-%d') AS ThisYearDate,\n    c1.Count AS ThisYearCount,\n    c2.Count AS LastYearCount,\n    (c1.Count - c2.Count) AS ChangeInCrimeRate\nFROM \n    CrimeStatistics c1\nJOIN \n    CrimeStatistics c2 ON DATE_FORMAT(c1.Date, '%Y-%m-01') = DATE_FORMAT(c2.Date, '%Y-%m-01')\n                      AND c1.CrimeType = c2.CrimeType\nWHERE \n    YEAR(c1.Date) - YEAR(c2.Date) = 1;", "raw_model_output": "To calculate the change in crime rates for each category between this year and last year for the same time period, we can use a query that joins the `CrimeStatistics` table with itself to compare counts from different years. Here's how you could write such an SQL statement:\n\n```sql\nSELECT \n    c1.CrimeType,\n    DATE_FORMAT(c1.Date, '%Y-%m-%d') AS ThisYearDate,\n    c1.Count AS ThisYearCount,\n    c2.Count AS LastYearCount,\n    (c1.Count - c2.Count) AS ChangeInCrimeRate\nFROM \n    CrimeStatistics c1\nJOIN \n    CrimeStatistics c2 ON DATE_FORMAT(c1.Date, '%Y-%m-01') = DATE_FORMAT(c2.Date, '%Y-%m-01')\n                      AND c1.CrimeType = c2.CrimeType\nWHERE \n    YEAR(c1.Date) - YEAR(c2.Date) = 1;\n```\n\nThis query does the following:\n- Joins `CrimeStatistics` with itself on the condition that both records are for the same month (using `DATE_FORMAT(date, '%Y-%m-01')`) and have the same crime type.\n- Ensures that the year difference between the two records is exactly one year (`YEAR(c1.Date) - YEAR(c2.Date) = 1`).\n- Calculates the change in count for each category by subtracting last year's count from this year's count.", "latency_sec": 7.281290054321289, "total_duration_sec": 7.274983576, "load_duration_sec": 0.014078613, "tokens_prompt": 391, "prompt_eval_sec": 0.089435116, "tokens_completion": 303, "completion_eval_sec": 7.169323785, "tokens_total": 694, "tokens_per_sec": 95.31278040326465, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL calculates yearly aggregate changes using window functions, comparing cumulative sums across years, while the Generated SQL performs a self-join to compare individual row counts between the same month in consecutive years. The Reference SQL aggregates data by year and computes a single change value per CrimeType, whereas the Generated SQL returns per-date comparisons with multiple rows per CrimeType. Additionally, the date filtering and calculation logic differ significantly."}
{"example_id": 335, "sql_complexity": "single join", "prompt": "List the policy numbers, claim amounts, and claim dates for policies that have more than two claims and the total claim amount exceeds $5000", "context": "CREATE TABLE policies (policy_number INT);CREATE TABLE claims (claim_id INT, policy_number INT, claim_amount DECIMAL(10,2), claim_date DATE);", "reference_sql": "SELECT p.policy_number, c.claim_amount, c.claim_date FROM policies p INNER JOIN claims c ON p.policy_number = c.policy_number GROUP BY p.policy_number, c.claim_amount, c.claim_date HAVING COUNT(c.claim_id) > 2 AND SUM(c.claim_amount) > 5000;", "generated_sql": "SELECT c.policy_number, c.claim_amount, c.claim_date\nFROM claims c\nWHERE c.policy_number IN (\n    SELECT policy_number \n    FROM claims \n    GROUP BY policy_number \n    HAVING COUNT(claim_id) > 2 AND SUM(claim_amount) > 5000\n);", "raw_model_output": "To list the policy numbers, claim amounts, and claim dates for policies that have more than two claims and where the total claim amount exceeds $5000, you can use the following SQL query:\n\n```sql\nSELECT c.policy_number, c.claim_amount, c.claim_date\nFROM claims c\nWHERE c.policy_number IN (\n    SELECT policy_number \n    FROM claims \n    GROUP BY policy_number \n    HAVING COUNT(claim_id) > 2 AND SUM(claim_amount) > 5000\n);\n```", "latency_sec": 2.6233270168304443, "total_duration_sec": 2.616471977, "load_duration_sec": 0.019083114, "tokens_prompt": 134, "prompt_eval_sec": 0.033276887, "tokens_completion": 111, "completion_eval_sec": 2.559511416, "tokens_total": 245, "tokens_per_sec": 93.39285511419536, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their grouping and filtering logic. The reference query groups by policy_number, claim_amount, and claim_date, requiring each unique (policy, amount, date) combination to have >2 claims and sum >5000. The generated query filters policies with >2 total claims and sum >5000, then returns all claims for those policies. This means the generated query may include claims that individually don't meet the HAVING conditions, while the reference query only includes claims that meet the conditions in their specific (policy, amount, date) group."}
{"example_id": 2866, "sql_complexity": "basic SQL", "prompt": "What is the number of hospitals in 'rural_healthcare' table?", "context": "CREATE TABLE rural_healthcare (name VARCHAR(255), type VARCHAR(255), location VARCHAR(255)); INSERT INTO rural_healthcare (name, type, location) VALUES ('Rural General Hospital', 'Hospital', 'Bushland'), ('Rural Community Hospital', 'Hospital', 'Forest Region');", "reference_sql": "SELECT COUNT(*) FROM rural_healthcare WHERE type = 'Hospital';", "generated_sql": "SELECT COUNT(*) AS hospital_count \nFROM rural_healthcare \nWHERE type = 'Hospital';", "raw_model_output": "```sql\nSELECT COUNT(*) AS hospital_count \nFROM rural_healthcare \nWHERE type = 'Hospital';\n```", "latency_sec": 0.5990982055664062, "total_duration_sec": 0.591460209, "load_duration_sec": 0.024407011, "tokens_prompt": 150, "prompt_eval_sec": 0.029660235, "tokens_completion": 23, "completion_eval_sec": 0.535239549, "tokens_total": 173, "tokens_per_sec": 288.76734797835087, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries count the number of rows where type = 'Hospital'. The generated query adds an alias (hospital_count) for the COUNT(*) result, but this does not affect the semantic output. The WHERE clause and aggregate function are identical, ensuring the same result."}
{"example_id": 4440, "sql_complexity": "multiple_joins", "prompt": "What is the average session length for each game genre in the last month, sorted by average session length.", "context": "CREATE TABLE game_sessions(id INT, user_id INT, game_name VARCHAR(50), start_time DATETIME, end_time DATETIME); CREATE TABLE games(id INT, name VARCHAR(50), genre VARCHAR(50));", "reference_sql": "SELECT genres.genre, AVG(TIMESTAMPDIFF(SECOND, start_time, end_time)) as avg_session_length FROM game_sessions JOIN games ON game_sessions.game_name = games.name JOIN (SELECT DISTINCT game_name, genre FROM game_sessions JOIN games ON game_sessions.game_name = games.name) genres ON games.name = genres.game_name WHERE start_time >= DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH) GROUP BY genres.genre ORDER BY avg_session_length DESC;", "generated_sql": "SELECT g.genre, AVG(TIMESTAMPDIFF(SECOND, gs.start_time, gs.end_time)) AS avg_session_length\nFROM game_sessions gs\nJOIN games g ON gs.game_name = g.name\nWHERE gs.start_time >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH)\nGROUP BY g.genre\nORDER BY avg_session_length;", "raw_model_output": "To find the average session length for each game genre in the last month and sort them by average session length, you can use the following SQL query:\n\n```sql\nSELECT g.genre, AVG(TIMESTAMPDIFF(SECOND, gs.start_time, gs.end_time)) AS avg_session_length\nFROM game_sessions gs\nJOIN games g ON gs.game_name = g.name\nWHERE gs.start_time >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH)\nGROUP BY g.genre\nORDER BY avg_session_length;\n```\n\nThis query calculates the average session length in seconds for each game genre, filters sessions from the last month, and sorts the results by average session length.", "latency_sec": 3.1269192695617676, "total_duration_sec": 3.12173909, "load_duration_sec": 0.021556896, "tokens_prompt": 136, "prompt_eval_sec": 0.026815917, "tokens_completion": 133, "completion_eval_sec": 3.071340854, "tokens_total": 269, "tokens_per_sec": 86.02716501782277, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the ORDER BY clause: the Reference SQL uses DESC while the Generated SQL does not. This results in different ordering of the output, making them semantically non-equivalent. Additionally, the Reference SQL includes a redundant subquery that may not affect the result but adds unnecessary complexity."}
{"example_id": 451, "sql_complexity": "single join", "prompt": "Which customers have made a transaction over 500 in the \"risk_management\" category?", "context": "CREATE TABLE customers (id INT, name VARCHAR(50), category VARCHAR(50)); INSERT INTO customers (id, name, category) VALUES (1, 'John Doe', 'risk_management'); INSERT INTO customers (id, name, category) VALUES (2, 'Jane Smith', 'compliance'); INSERT INTO customers (id, name, category) VALUES (3, 'Jim Brown', 'risk_management'); CREATE TABLE transactions (id INT, customer_id INT, amount DECIMAL(10, 2)); INSERT INTO transactions (id, customer_id, amount) VALUES (1, 1, 500.00); INSERT INTO transactions (id, customer_id, amount) VALUES (2, 1, 200.00); INSERT INTO transactions (id, customer_id, amount) VALUES (3, 2, 100.00); INSERT INTO transactions (id, customer_id, amount) VALUES (4, 3, 750.00);", "reference_sql": "SELECT c.name FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE c.category = 'risk_management' AND t.amount > 500;", "generated_sql": "SELECT c.name\nFROM customers c\nJOIN transactions t ON c.id = t.customer_id\nWHERE c.category = 'risk_management' AND t.amount > 500;", "raw_model_output": "```sql\nSELECT c.name\nFROM customers c\nJOIN transactions t ON c.id = t.customer_id\nWHERE c.category = 'risk_management' AND t.amount > 500;\n```", "latency_sec": 1.1006238460540771, "total_duration_sec": 1.093824456, "load_duration_sec": 0.024068876, "tokens_prompt": 298, "prompt_eval_sec": 0.064878437, "tokens_completion": 41, "completion_eval_sec": 1.002643958, "tokens_total": 339, "tokens_per_sec": 308.0071372389145, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between customers and transactions tables on customer_id, apply the same WHERE conditions (category = 'risk_management' and amount > 500), and select the same column (c.name). The only difference is that the generated query uses the shorthand JOIN syntax instead of INNER JOIN, which is semantically equivalent in SQL."}
{"example_id": 2879, "sql_complexity": "basic SQL", "prompt": "Update the FoodSafetyRecords.OrganicFarms table to include a new record for a certified organic farm in Kenya.", "context": "CREATE TABLE FoodSafetyRecords.OrganicFarms (farmName TEXT, country TEXT, certified BOOLEAN);", "reference_sql": "INSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('Ngong Organic Farm', 'Kenya', TRUE);", "generated_sql": "INSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('New Organic Farm', 'Kenya', TRUE);", "raw_model_output": "```sql\nINSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('New Organic Farm', 'Kenya', TRUE);\n```", "latency_sec": 0.8481628894805908, "total_duration_sec": 0.841761, "load_duration_sec": 0.014212839, "tokens_prompt": 114, "prompt_eval_sec": 0.022695956, "tokens_completion": 35, "completion_eval_sec": 0.802913167, "tokens_total": 149, "tokens_per_sec": 175.67380257729337, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The two queries differ in the farmName value being inserted ('Ngong Organic Farm' vs 'New Organic Farm'). While the structure and other values (country 'Kenya', certified TRUE) are identical, the distinct farm names result in different data being inserted, making the queries not semantically equivalent."}
{"example_id": 5688, "sql_complexity": "single join", "prompt": "What is the total amount donated to a specific cause?", "context": "CREATE TABLE causes (id INT, name TEXT); CREATE TABLE donations (id INT, donor_id INT, cause_id INT, donation_amount DECIMAL(10,2)); INSERT INTO causes (id, name) VALUES (1, 'Cause A'), (2, 'Cause B'); INSERT INTO donations (id, donor_id, cause_id, donation_amount) VALUES (1, 1, 1, 50.00), (2, 2, 1, 100.00);", "reference_sql": "SELECT SUM(donation_amount) FROM donations JOIN causes ON donations.cause_id = causes.id WHERE causes.name = 'Cause A';", "generated_sql": "SELECT SUM(donation_amount) AS total_donation\nFROM donations\nWHERE cause_id = 1;", "raw_model_output": "To find the total amount donated to a specific cause, you need to specify the `cause_id` of that cause in your query. Assuming we want to get the total donation for `cause_id = 1`, here's the corresponding SQL statement:\n\n```sql\nSELECT SUM(donation_amount) AS total_donation\nFROM donations\nWHERE cause_id = 1;\n```\n\nIf you need a general solution where any specific `cause_id` can be provided, you could use a parameterized query or replace `1` with another value as needed.", "latency_sec": 2.6756789684295654, "total_duration_sec": 2.670945455, "load_duration_sec": 0.014859855, "tokens_prompt": 187, "prompt_eval_sec": 0.037049773, "tokens_completion": 112, "completion_eval_sec": 2.61691683, "tokens_total": 299, "tokens_per_sec": 111.74733722838651, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the total donations for 'Cause A'. The reference query joins donations with causes and filters by name, while the generated query directly filters by cause_id=1. Since 'Cause A' corresponds to cause_id=1 in the provided data, both return the same sum of 150.00."}
{"example_id": 3273, "sql_complexity": "multiple_joins", "prompt": "List all departments, the number of chemicals they handle, and the number of machines used in their manufacturing processes.", "context": "CREATE TABLE Departments (DepartmentID INT, DepartmentName VARCHAR(20)); INSERT INTO Departments (DepartmentID, DepartmentName) VALUES (1, 'Manufacturing'), (2, 'Engineering'), (3, 'Chemical Safety'), (4, 'Product Development'); CREATE TABLE Chemicals (ChemicalID INT, ChemicalName VARCHAR(20), DepartmentID INT); INSERT INTO Chemicals (ChemicalID, ChemicalName, DepartmentID) VALUES (1, 'Hydrochloric Acid', 1), (2, 'Nitric Acid', 2), (3, 'Sodium Hydroxide', 3), (4, 'New Chemical', 4); CREATE TABLE Machinery (MachineID INT, MachineName VARCHAR(20), DepartmentID INT); INSERT INTO Machinery (MachineID, MachineName, DepartmentID) VALUES (1, 'Mixer 1', 1), (2, 'Cutter 2', 2), (3, 'Dispenser 3', 3), (4, 'Innovator 4', 4);", "reference_sql": "SELECT D.DepartmentName, COUNT(C.ChemicalID) AS ChemicalCount, COUNT(M.MachineID) AS MachineCount FROM Departments D LEFT JOIN Chemicals C ON D.DepartmentID = C.DepartmentID LEFT JOIN Machinery M ON D.DepartmentID = M.DepartmentID GROUP BY D.DepartmentName;", "generated_sql": "SELECT \n    d.DepartmentName,\n    COUNT(c.ChemicalID) AS NumberOfChemicals,\n    COUNT(m.MachineID) AS NumberOfMachines\nFROM \n    Departments d\nLEFT JOIN \n    Chemicals c ON d.DepartmentID = c.DepartmentID\nLEFT JOIN \n    Machinery m ON d.DepartmentID = m.DepartmentID\nGROUP BY \n    d.DepartmentName;", "raw_model_output": "To list all departments along with the number of chemicals they handle and the number of machines used in their manufacturing processes, you can use the following SQL query:\n\n```sql\nSELECT \n    d.DepartmentName,\n    COUNT(c.ChemicalID) AS NumberOfChemicals,\n    COUNT(m.MachineID) AS NumberOfMachines\nFROM \n    Departments d\nLEFT JOIN \n    Chemicals c ON d.DepartmentID = c.DepartmentID\nLEFT JOIN \n    Machinery m ON d.DepartmentID = m.DepartmentID\nGROUP BY \n    d.DepartmentName;\n```\n\nThis query uses `LEFT JOIN` to ensure that departments without any chemicals or machines are still included in the result set. The `COUNT` function is used to count the number of chemicals and machines associated with each department, and the results are grouped by department name.", "latency_sec": 4.0826520919799805, "total_duration_sec": 4.074783181, "load_duration_sec": 0.014059793, "tokens_prompt": 311, "prompt_eval_sec": 0.066385786, "tokens_completion": 167, "completion_eval_sec": 3.992008957, "tokens_total": 478, "tokens_per_sec": 117.08075761316766, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform the same operations: left joining Departments with Chemicals and Machinery on DepartmentID, grouping by DepartmentName, and counting ChemicalID and MachineID. The differences are only in table/column aliases (e.g., D vs d, ChemicalCount vs NumberOfChemicals) and formatting, which do not affect the semantic result."}
{"example_id": 1895, "sql_complexity": "window functions", "prompt": "What is the average safety score of chemical production sites in the United States, partitioned by state and ranked in descending order?", "context": "CREATE TABLE production_sites (site_id INT, site_name TEXT, country TEXT, state TEXT, safety_score FLOAT); INSERT INTO production_sites (site_id, site_name, country, state, safety_score) VALUES (1, 'Site A', 'USA', 'NY', 92.5), (2, 'Site B', 'USA', 'CA', 87.4), (3, 'Site C', 'USA', 'TX', 95.3), (4, 'Site D', 'USA', 'FL', 89.2);", "reference_sql": "SELECT state, AVG(safety_score) as avg_safety_score, ROW_NUMBER() OVER (ORDER BY AVG(safety_score) DESC) as rank FROM production_sites WHERE country = 'USA' GROUP BY state ORDER BY rank;", "generated_sql": "SELECT \n    state,\n    AVG(safety_score) AS avg_safety_score\nFROM \n    production_sites\nWHERE \n    country = 'USA'\nGROUP BY \n    state\nORDER BY \n    AVG(safety_score) DESC;", "raw_model_output": "To find the average safety score of chemical production sites in the United States, partitioned by state and ranked in descending order, you can use the following SQL query:\n\n```sql\nSELECT \n    state,\n    AVG(safety_score) AS avg_safety_score\nFROM \n    production_sites\nWHERE \n    country = 'USA'\nGROUP BY \n    state\nORDER BY \n    AVG(safety_score) DESC;\n```\n\nThis query calculates the average safety score for each state in the United States and orders the results by these averages in descending order.", "latency_sec": 2.6937270164489746, "total_duration_sec": 2.689136011, "load_duration_sec": 0.014205264, "tokens_prompt": 212, "prompt_eval_sec": 0.045342768, "tokens_completion": 112, "completion_eval_sec": 2.627392449, "tokens_total": 324, "tokens_per_sec": 120.27944851929182, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a ROW_NUMBER() column for ranking, while the Generated SQL does not. The Reference also orders by 'rank' (derived from the aggregated safety score), whereas the Generated SQL orders directly by the aggregated safety score. The presence of an additional column and different ordering mechanism makes them non-equivalent."}
{"example_id": 4669, "sql_complexity": "set operations", "prompt": "Identify the number of IoT devices in each country and the total number of devices.", "context": "CREATE TABLE device_country (device_id INT, country TEXT); INSERT INTO device_country (device_id, country) VALUES (1, 'USA'), (2, 'Canada'), (3, 'Mexico'), (4, 'Brazil'); CREATE TABLE device_info (device_id INT, device_type TEXT); INSERT INTO device_info (device_id, device_type) VALUES (1, 'Soil Sensor'), (2, 'Temperature Sensor'), (3, 'Humidity Sensor'), (4, 'Precision Sprayer');", "reference_sql": "SELECT country, COUNT(*) AS device_count FROM device_country GROUP BY country UNION SELECT 'Total' AS country, COUNT(*) FROM device_country;", "generated_sql": "SELECT \n    dc.country,\n    COUNT(di.device_id) AS device_count_in_country,\n    SUM(COUNT(di.device_id)) OVER () AS total_device_count\nFROM \n    device_country dc\nJOIN \n    device_info di \nON \n    dc.device_id = di.device_id\nGROUP BY \n    dc.country;", "raw_model_output": "To identify the number of IoT devices in each country and also provide the total number of devices across all countries, you can use a combination of `GROUP BY`, `COUNT()`, and window functions. Here is the corresponding SQL query:\n\n```sql\nSELECT \n    dc.country,\n    COUNT(di.device_id) AS device_count_in_country,\n    SUM(COUNT(di.device_id)) OVER () AS total_device_count\nFROM \n    device_country dc\nJOIN \n    device_info di \nON \n    dc.device_id = di.device_id\nGROUP BY \n    dc.country;\n```\n\nThis query groups the devices by country and counts them, while also using a window function to calculate the total number of devices across all countries.", "latency_sec": 3.4725849628448486, "total_duration_sec": 3.467681717, "load_duration_sec": 0.024890597, "tokens_prompt": 189, "prompt_eval_sec": 0.036124234, "tokens_completion": 146, "completion_eval_sec": 3.404469611, "tokens_total": 335, "tokens_per_sec": 96.46992185485871, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL counts devices per country from device_country and adds a 'Total' row. The Generated SQL joins device_country with device_info, counts devices per country (which may differ if there are unmatched device_ids), and includes a total in every row via a window function. The output structure and logic differ: the Reference includes a separate 'Total' row, while the Generated includes a total column. Additionally, the Generated SQL may exclude devices without corresponding entries in device_info."}
{"example_id": 5302, "sql_complexity": "multiple_joins", "prompt": "Find the supplier with the lowest average delivery time for orders in the last month.", "context": "CREATE TABLE Suppliers (SupplierID int, SupplierName varchar(50)); CREATE TABLE Products (ProductID int, ProductName varchar(50), SupplierID int); CREATE TABLE Orders (OrderID int, ProductID int, OrderDate date, DeliveryTime int); INSERT INTO Suppliers VALUES (1, 'SupplierA'), (2, 'SupplierB'); INSERT INTO Products VALUES (1, 'Organic Apples', 1), (2, 'Bananas', 2); INSERT INTO Orders VALUES (1, 1, '2022-01-01', 2), (2, 2, '2022-01-03', 3);", "reference_sql": "SELECT SupplierName, AVG(DeliveryTime) as AvgDeliveryTime FROM Orders o JOIN Products p ON o.ProductID = p.ProductID JOIN Suppliers sp ON p.SupplierID = sp.SupplierID WHERE OrderDate >= DATEADD(month, -1, GETDATE()) GROUP BY SupplierName ORDER BY AvgDeliveryTime ASC;", "generated_sql": "WITH RecentOrders AS (\n    SELECT ProductID, DeliveryTime \n    FROM Orders \n    WHERE OrderDate >= CURRENT_DATE - INTERVAL '1 month'\n),\nSupplierDeliveryTimes AS (\n    SELECT s.SupplierName, AVG(ro.DeliveryTime) AS AvgDeliveryTime\n    FROM Suppliers s\n    JOIN Products p ON s.SupplierID = p.SupplierID\n    JOIN RecentOrders ro ON p.ProductID = ro.ProductID\n    GROUP BY s.SupplierName\n)\nSELECT SupplierName \nFROM SupplierDeliveryTimes \nWHERE AvgDeliveryTime = (SELECT MIN(AvgDeliveryTime) FROM SupplierDeliveryTimes);", "raw_model_output": "To find the supplier with the lowest average delivery time for orders placed in the last month, we need to follow these steps:\n\n1. Filter out orders that were placed within the last month.\n2. Calculate the average delivery time per supplier.\n3. Identify the supplier(s) with the minimum average delivery time.\n\nHere is the SQL query to achieve this:\n\n```sql\nWITH RecentOrders AS (\n    SELECT ProductID, DeliveryTime \n    FROM Orders \n    WHERE OrderDate >= CURRENT_DATE - INTERVAL '1 month'\n),\nSupplierDeliveryTimes AS (\n    SELECT s.SupplierName, AVG(ro.DeliveryTime) AS AvgDeliveryTime\n    FROM Suppliers s\n    JOIN Products p ON s.SupplierID = p.SupplierID\n    JOIN RecentOrders ro ON p.ProductID = ro.ProductID\n    GROUP BY s.SupplierName\n)\nSELECT SupplierName \nFROM SupplierDeliveryTimes \nWHERE AvgDeliveryTime = (SELECT MIN(AvgDeliveryTime) FROM SupplierDeliveryTimes);\n```\n\nThis query uses Common Table Expressions (CTEs) to break down the problem into manageable parts. The `RecentOrders` CTE filters orders placed in the last month, and the `SupplierDeliveryTimes` CTE calculates the average delivery time for each supplier based on these recent orders. Finally, it selects the supplier(s) with the minimum average delivery time from the results of the second CTE.", "latency_sec": 6.753935813903809, "total_duration_sec": 6.745704483, "load_duration_sec": 0.018685105, "tokens_prompt": 229, "prompt_eval_sec": 0.053567504, "tokens_completion": 282, "completion_eval_sec": 6.671184658, "tokens_total": 511, "tokens_per_sec": 75.65958784329037, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns all suppliers with their average delivery times for the last month, sorted by the average. The Generated SQL filters to only return the supplier(s) with the minimum average delivery time. The Generated SQL's final WHERE clause restricts results to the minimum average, while the Reference SQL includes all suppliers."}
{"example_id": 267, "sql_complexity": "subqueries", "prompt": "What is the total number of disability support programs offered in urban and rural areas, and the percentage of total programs for each area type?", "context": "CREATE TABLE programs (program_id INT, program_name VARCHAR(255), area_type VARCHAR(255));", "reference_sql": "SELECT area_type, COUNT(*) as total_programs, ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM programs) , 2) as percentage_of_total FROM programs WHERE area_type IN ('urban', 'rural') GROUP BY area_type;", "generated_sql": "SELECT \n    area_type,\n    COUNT(program_id) AS program_count,\n    (COUNT(program_id) * 100 / SUM(COUNT(program_id)) OVER ()) AS percentage_of_total\nFROM \n    programs\nWHERE \n    area_type IN ('urban', 'rural')\nGROUP BY \n    area_type;", "raw_model_output": "To solve this problem, we need to calculate the count of programs for both \"urban\" and \"rural\" area types separately. Then, we will compute the percentage of these counts relative to the total number of programs.\n\nHere is the corresponding SQL query:\n\n```sql\nSELECT \n    area_type,\n    COUNT(program_id) AS program_count,\n    (COUNT(program_id) * 100 / SUM(COUNT(program_id)) OVER ()) AS percentage_of_total\nFROM \n    programs\nWHERE \n    area_type IN ('urban', 'rural')\nGROUP BY \n    area_type;\n```\n\nThis query will provide the count of disability support programs for each area type and their respective percentages relative to the total number of such programs.", "latency_sec": 3.5089030265808105, "total_duration_sec": 3.501731258, "load_duration_sec": 0.014592773, "tokens_prompt": 120, "prompt_eval_sec": 0.024153875, "tokens_completion": 150, "completion_eval_sec": 3.460760188, "tokens_total": 270, "tokens_per_sec": 76.94712505722815, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in how they calculate the percentage. The Reference SQL uses ROUND() and 100.0 for floating-point division, while the Generated SQL uses integer division (no decimal point) and lacks rounding. This can lead to different numerical results, especially when the division isn't exact. Additionally, the Generated SQL's window function SUM(COUNT(...)) OVER () may behave differently in edge cases compared to the subquery approach."}
{"example_id": 3028, "sql_complexity": "basic SQL", "prompt": "What is the number of startups founded by non-binary individuals in the technology industry?", "context": "CREATE TABLE company (id INT, name TEXT, founder_gender TEXT, industry TEXT); INSERT INTO company (id, name, founder_gender, industry) VALUES (1, 'CodeForAll', 'Non-binary', 'Technology'); INSERT INTO company (id, name, founder_gender, industry) VALUES (2, 'TechVillage', 'Male', 'Technology');", "reference_sql": "SELECT COUNT(*) FROM company WHERE founder_gender = 'Non-binary' AND industry = 'Technology';", "generated_sql": "SELECT COUNT(*) AS num_startups \nFROM company \nWHERE founder_gender = 'Non-binary' AND industry = 'Technology';", "raw_model_output": "```sql\nSELECT COUNT(*) AS num_startups \nFROM company \nWHERE founder_gender = 'Non-binary' AND industry = 'Technology';\n```", "latency_sec": 0.7567040920257568, "total_duration_sec": 0.751480267, "load_duration_sec": 0.01400554, "tokens_prompt": 159, "prompt_eval_sec": 0.032939624, "tokens_completion": 30, "completion_eval_sec": 0.702278778, "tokens_total": 189, "tokens_per_sec": 249.7673819815511, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries count the same rows from the company table with identical WHERE conditions. The generated query adds an alias (num_startups) to the COUNT(*) result, which doesn't affect the semantic meaning of the query's output value."}
{"example_id": 3282, "sql_complexity": "aggregation", "prompt": "Which marine species have been observed in both the Arctic and Antarctic oceans?", "context": "CREATE TABLE marine_species (id INT, species_name VARCHAR(50), common_name VARCHAR(50), region VARCHAR(20));INSERT INTO marine_species (id, species_name, common_name, region) VALUES (1, 'Orcinus_orca', 'Killer Whale', 'Arctic');INSERT INTO marine_species (id, species_name, common_name, region) VALUES (2, 'Balaenoptera_bonaerensis', 'Antarctic Minke Whale', 'Antarctic');", "reference_sql": "SELECT species_name FROM marine_species WHERE region IN ('Arctic', 'Antarctic') GROUP BY species_name HAVING COUNT(DISTINCT region) = 2;", "generated_sql": "SELECT ms1.species_name\nFROM marine_species ms1\nJOIN marine_species ms2 ON ms1.species_name = ms2.species_name\nWHERE ms1.region = 'Arctic' AND ms2.region = 'Antarctic';", "raw_model_output": "To find which marine species have been observed in both the Arctic and Antarctic regions, you can use an INNER JOIN to match species that appear in both regions. Here is the corresponding SQL query:\n\n```sql\nSELECT ms1.species_name\nFROM marine_species ms1\nJOIN marine_species ms2 ON ms1.species_name = ms2.species_name\nWHERE ms1.region = 'Arctic' AND ms2.region = 'Antarctic';\n```\n\nThis query joins the `marine_species` table to itself on the `species_name`, and filters for species that are present in both regions.", "latency_sec": 2.8365318775177, "total_duration_sec": 2.831877772, "load_duration_sec": 0.014116529, "tokens_prompt": 189, "prompt_eval_sec": 0.037260167, "tokens_completion": 119, "completion_eval_sec": 2.778306404, "tokens_total": 308, "tokens_per_sec": 108.58330288518961, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query returns species present in both Arctic and Antarctic regions (using GROUP BY and HAVING COUNT(DISTINCT region) = 2), ensuring each species is listed once. The generated query uses a self-join to find species with at least one entry in each region, but may return duplicate rows if a species has multiple entries in either region. The generated query's result can include duplicates, while the reference query's result is deduplicated. Thus, they are not semantically equivalent."}
{"example_id": 3474, "sql_complexity": "subqueries", "prompt": "What is the total transaction volume for the top 3 digital assets by market capitalization in the 'developed_markets' schema?", "context": "CREATE SCHEMA developed_markets; CREATE TABLE developed_markets.digital_assets (asset_name VARCHAR(10), market_cap BIGINT, daily_transaction_volume BIGINT); INSERT INTO developed_markets.digital_assets (asset_name, market_cap, daily_transaction_volume) VALUES ('AssetG', 30000000, 15000000), ('AssetH', 25000000, 12000000), ('AssetI', 20000000, 10000000), ('AssetJ', 15000000, 8000000), ('AssetK', 10000000, 6000000);", "reference_sql": "SELECT SUM(daily_transaction_volume) FROM (SELECT daily_transaction_volume FROM developed_markets.digital_assets ORDER BY market_cap DESC FETCH NEXT 3 ROWS ONLY) t;", "generated_sql": "SELECT SUM(daily_transaction_volume) AS total_transaction_volume\nFROM (\n    SELECT daily_transaction_volume,\n           ROW_NUMBER() OVER (ORDER BY market_cap DESC) AS rn\n    FROM developed_markets.digital_assets\n) AS ranked_assets\nWHERE rn <= 3;", "raw_model_output": "To find the total transaction volume for the top 3 digital assets by market capitalization, you can use a combination of `ROW_NUMBER()` window function and a subquery. Here is the corresponding SQL query:\n\n```sql\nSELECT SUM(daily_transaction_volume) AS total_transaction_volume\nFROM (\n    SELECT daily_transaction_volume,\n           ROW_NUMBER() OVER (ORDER BY market_cap DESC) AS rn\n    FROM developed_markets.digital_assets\n) AS ranked_assets\nWHERE rn <= 3;\n```\n\nThis query first ranks the digital assets by their market capitalization in descending order and then sums up the `daily_transaction_volume` for the top 3 ranked assets.", "latency_sec": 3.3708741664886475, "total_duration_sec": 3.36326822, "load_duration_sec": 0.018308539, "tokens_prompt": 266, "prompt_eval_sec": 0.063912745, "tokens_completion": 135, "completion_eval_sec": 3.278945846, "tokens_total": 401, "tokens_per_sec": 118.96024004292968, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of daily_transaction_volume for the top 3 assets by market_cap descending. The Reference SQL uses ORDER BY with FETCH NEXT 3 ROWS, while the Generated SQL uses ROW_NUMBER() to achieve the same ordering and filtering. Since the data has unique market_cap values, both approaches select the same top 3 assets (AssetG, AssetH, AssetI) and sum their transaction volumes."}
{"example_id": 1626, "sql_complexity": "aggregation", "prompt": "Find the total value of social impact bonds issued by each organization.", "context": "CREATE TABLE social_impact_bonds (id INT, organization_name VARCHAR(255), issue_year INT, value FLOAT); INSERT INTO social_impact_bonds (id, organization_name, issue_year, value) VALUES (1, 'Acme Corp', 2018, 2000000), (2, 'XYZ Foundation', 2019, 3000000), (3, 'Global Giving', 2018, 1500000), (4, 'Acme Corp', 2019, 2500000), (5, 'XYZ Foundation', 2018, 1000000);", "reference_sql": "SELECT organization_name, SUM(value) as total_value FROM social_impact_bonds GROUP BY organization_name;", "generated_sql": "SELECT organization_name, SUM(value) AS total_value\nFROM social_impact_bonds\nGROUP BY organization_name;", "raw_model_output": "```sql\nSELECT organization_name, SUM(value) AS total_value\nFROM social_impact_bonds\nGROUP BY organization_name;\n```", "latency_sec": 0.7655670642852783, "total_duration_sec": 0.759610615, "load_duration_sec": 0.013801697, "tokens_prompt": 239, "prompt_eval_sec": 0.053174026, "tokens_completion": 28, "completion_eval_sec": 0.69029597, "tokens_total": 267, "tokens_per_sec": 348.761085025604, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select organization_name and sum the value column, grouping by organization_name. The only differences are whitespace and formatting (line breaks/indentation), which do not affect SQL semantics."}
{"example_id": 1315, "sql_complexity": "single join", "prompt": "List all the transactions made by clients living in New York with a transaction amount greater than $1000.", "context": "CREATE TABLE transactions (id INT, client_id INT, transaction_amount DECIMAL(10,2), transaction_date DATE); INSERT INTO transactions (id, client_id, transaction_amount, transaction_date) VALUES (1, 3, 1500.00, '2022-01-01'), (2, 4, 800.00, '2022-01-02'), (3, 3, 1200.00, '2022-01-03'); CREATE TABLE clients (id INT, name VARCHAR(255), state VARCHAR(255)); INSERT INTO clients (id, name, state) VALUES (3, 'Mike Johnson', 'New York'), (4, 'Sara Lee', 'California');", "reference_sql": "SELECT transactions.id, transactions.client_id, transactions.transaction_amount, transactions.transaction_date FROM transactions INNER JOIN clients ON transactions.client_id = clients.id WHERE clients.state = 'New York' AND transactions.transaction_amount > 1000.00;", "generated_sql": "SELECT t.id, t.transaction_amount, t.transaction_date\nFROM transactions t\nJOIN clients c ON t.client_id = c.id\nWHERE c.state = 'New York' AND t.transaction_amount > 1000;", "raw_model_output": "```sql\nSELECT t.id, t.transaction_amount, t.transaction_date\nFROM transactions t\nJOIN clients c ON t.client_id = c.id\nWHERE c.state = 'New York' AND t.transaction_amount > 1000;\n```", "latency_sec": 1.3470869064331055, "total_duration_sec": 1.3425624, "load_duration_sec": 0.024706285, "tokens_prompt": 267, "prompt_eval_sec": 0.058936231, "tokens_completion": 51, "completion_eval_sec": 1.256920414, "tokens_total": 318, "tokens_per_sec": 236.0649476150123, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent because they select different columns. The Reference SQL includes 'client_id' in the output, while the Generated SQL omits it. Both queries filter on the same conditions, but the result sets differ in column structure."}
{"example_id": 520, "sql_complexity": "multiple_joins", "prompt": "What is the total number of electric vehicles sold in 'California' in the 'sales' schema?", "context": "CREATE TABLE sales_regions (id INT, name VARCHAR(50));   CREATE TABLE sales (id INT, region_id INT, vehicle_count INT);   CREATE TABLE vehicles (id INT, type VARCHAR(50));   INSERT INTO sales_regions VALUES (1, 'California');   INSERT INTO sales VALUES (1, 1, 5000);   INSERT INTO vehicles VALUES (1, 'electric');", "reference_sql": "SELECT SUM(sales.vehicle_count) FROM sales INNER JOIN sales_regions ON sales.region_id = sales_regions.id INNER JOIN vehicles ON sales.id = vehicles.id WHERE vehicles.type = 'electric' AND sales_regions.name = 'California';", "generated_sql": "SELECT SUM(s.vehicle_count) AS total_electric_vehicles_sold\nFROM sales s\nJOIN sales_regions sr ON s.region_id = sr.id\nJOIN vehicles v ON s.id = v.id\nWHERE sr.name = 'California' AND v.type = 'electric';", "raw_model_output": "```sql\nSELECT SUM(s.vehicle_count) AS total_electric_vehicles_sold\nFROM sales s\nJOIN sales_regions sr ON s.region_id = sr.id\nJOIN vehicles v ON s.id = v.id\nWHERE sr.name = 'California' AND v.type = 'electric';\n```", "latency_sec": 1.4771440029144287, "total_duration_sec": 1.472431159, "load_duration_sec": 0.02698967, "tokens_prompt": 173, "prompt_eval_sec": 0.033469607, "tokens_completion": 59, "completion_eval_sec": 1.409905701, "tokens_total": 232, "tokens_per_sec": 157.05983948908184, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of vehicle_count from sales where the region is California and vehicle type is electric. The differences are purely syntactic (table aliases) and do not affect the semantic result. The join conditions, WHERE clauses, and aggregate functions are identical in logic."}
{"example_id": 3999, "sql_complexity": "single join", "prompt": "What is the total number of tickets sold for performances with a rating of 5?", "context": "CREATE TABLE performance (id INT PRIMARY KEY, name VARCHAR(255), date DATE, artist_id INT, rating INT); INSERT INTO performance (id, name, date, artist_id, rating) VALUES (1, 'Dance Recital', '2022-03-01', 1, 5);", "reference_sql": "SELECT SUM(t.quantity) as total_tickets_sold FROM performance p INNER JOIN ticket t ON p.id = t.performance_id WHERE p.rating = 5;", "generated_sql": "SELECT SUM(t.quantity) AS total_tickets_sold\nFROM performance p\nJOIN tickets t ON p.id = t.performance_id\nWHERE p.rating = 5;", "raw_model_output": "To determine the total number of tickets sold for performances with a rating of 5, we need to consider that the provided schema does not include any table or column related to ticket sales. Therefore, it's impossible to directly answer this question based on the given information.\n\nHowever, if there were an additional table such as `tickets` with columns like `performance_id`, `quantity`, and other relevant details, you could join the `performance` table with the `tickets` table and aggregate the total number of tickets sold for performances with a rating of 5. \n\nSince we don't have that information, I'll provide an example SQL statement assuming such a table exists:\n\n```sql\nSELECT SUM(t.quantity) AS total_tickets_sold\nFROM performance p\nJOIN tickets t ON p.id = t.performance_id\nWHERE p.rating = 5;\n```\n\nIf you can provide the schema for the `tickets` table or any other relevant tables, I can refine this query further.", "latency_sec": 4.970956802368164, "total_duration_sec": 4.965800263, "load_duration_sec": 0.013566594, "tokens_prompt": 155, "prompt_eval_sec": 0.031534029, "tokens_completion": 197, "completion_eval_sec": 4.918545807, "tokens_total": 352, "tokens_per_sec": 70.81131741726405, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the table name used in the JOIN clause. The Reference SQL uses 'ticket' while the Generated SQL uses 'tickets'. This would result in different tables being joined, making the queries non-equivalent unless 'ticket' and 'tickets' are aliases for the same table, which is not indicated here."}
{"example_id": 2261, "sql_complexity": "multiple_joins", "prompt": "What is the total number of animals that have been released into 'protected' habitats, and the average weight of those animals?", "context": "CREATE TABLE habitats (habitat_id INT, habitat_name VARCHAR(50), habitat_status VARCHAR(50)); INSERT INTO habitats (habitat_id, habitat_name, habitat_status) VALUES (1, 'Habitat A', 'protected'), (2, 'Habitat B', 'unprotected'); CREATE TABLE animal_habitats (animal_id INT, habitat_id INT, animal_weight FLOAT); INSERT INTO animal_habitats (animal_id, habitat_id, animal_weight) VALUES (101, 1, 25.5), (102, 2, 15.2); CREATE TABLE animals (animal_id INT, animal_name VARCHAR(50)); INSERT INTO animals (animal_id, animal_name) VALUES (101, 'Dog'), (102, 'Cat');", "reference_sql": "SELECT COUNT(*), AVG(animal_habitats.animal_weight) FROM animal_habitats INNER JOIN animals ON animal_habitats.animal_id = animals.animal_id INNER JOIN habitats ON animal_habitats.habitat_id = habitats.habitat_id WHERE habitats.habitat_status = 'protected';", "generated_sql": "SELECT COUNT(a.animal_id) AS total_animals, AVG(ah.animal_weight) AS avg_weight\nFROM animals a\nJOIN animal_habitats ah ON a.animal_id = ah.animal_id\nJOIN habitats h ON ah.habitat_id = h.habitat_id\nWHERE h.habitat_status = 'protected';", "raw_model_output": "To find the total number of animals in 'protected' habitats and their average weight, you can use the following SQL query:\n\n```sql\nSELECT COUNT(a.animal_id) AS total_animals, AVG(ah.animal_weight) AS avg_weight\nFROM animals a\nJOIN animal_habitats ah ON a.animal_id = ah.animal_id\nJOIN habitats h ON ah.habitat_id = h.habitat_id\nWHERE h.habitat_status = 'protected';\n```\n\nThis query joins the `animals`, `animal_habitats`, and `habitats` tables to filter out animals in protected habitats, then calculates the total number of such animals and their average weight.", "latency_sec": 3.645458936691284, "total_duration_sec": 3.638750904, "load_duration_sec": 0.014582405, "tokens_prompt": 263, "prompt_eval_sec": 0.063070472, "tokens_completion": 141, "completion_eval_sec": 3.558793875, "tokens_total": 404, "tokens_per_sec": 110.82280914860097, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform the same inner joins between animals, animal_habitats, and habitats tables, apply the same WHERE condition (habitat_status = 'protected'), and calculate identical aggregations (count of animals and average animal weight). The differences are only in table aliases (animal_habitats vs. ah, animals vs. a) and column reference styles (COUNT(*) vs COUNT(a.animal_id)), which do not affect the semantic result."}
{"example_id": 3439, "sql_complexity": "multiple_joins", "prompt": "How many menu items contain ingredients sourced from local suppliers for each restaurant?", "context": "CREATE TABLE restaurants (id INT, name VARCHAR(50), location VARCHAR(50)); INSERT INTO restaurants VALUES (1, 'Restaurant A', 'City A'); INSERT INTO restaurants VALUES (2, 'Restaurant B', 'City B'); CREATE TABLE menu_items (id INT, name VARCHAR(50), restaurant_id INT, price DECIMAL(5,2)); INSERT INTO menu_items VALUES (1, 'Item A', 1, 10.99); INSERT INTO menu_items VALUES (2, 'Item B', 1, 12.99); INSERT INTO menu_items VALUES (3, 'Item C', 2, 11.99); CREATE TABLE ingredients (id INT, name VARCHAR(50), local_source BOOLEAN, menu_item_id INT); INSERT INTO ingredients VALUES (1, 'Ingredient A', TRUE, 1); INSERT INTO ingredients VALUES (2, 'Ingredient B', FALSE, 1); INSERT INTO ingredients VALUES (3, 'Ingredient C', TRUE, 2); INSERT INTO ingredients VALUES (4, 'Ingredient D', FALSE, 2); INSERT INTO ingredients VALUES (5, 'Ingredient E', TRUE, 3);", "reference_sql": "SELECT r.name, COUNT(DISTINCT mi.id) as num_local_items FROM restaurants r JOIN menu_items mi ON r.id = mi.restaurant_id JOIN ingredients i ON mi.id = i.menu_item_id WHERE i.local_source = TRUE GROUP BY r.name;", "generated_sql": "SELECT \n    r.id AS restaurant_id,\n    COUNT(DISTINCT mi.id) AS menu_items_with_local_ingredients\nFROM \n    restaurants r\nJOIN \n    menu_items mi ON r.id = mi.restaurant_id\nJOIN \n    ingredients i ON mi.id = i.menu_item_id\nWHERE \n    i.local_source = TRUE\nGROUP BY \n    r.id;", "raw_model_output": "To determine how many menu items contain ingredients sourced from local suppliers for each restaurant, we need to join the `restaurants`, `menu_items`, and `ingredients` tables. We will use a combination of aggregation functions (`COUNT`) and filtering conditions to achieve this.\n\nHere is the corresponding SQL query:\n\n```sql\nSELECT \n    r.id AS restaurant_id,\n    COUNT(DISTINCT mi.id) AS menu_items_with_local_ingredients\nFROM \n    restaurants r\nJOIN \n    menu_items mi ON r.id = mi.restaurant_id\nJOIN \n    ingredients i ON mi.id = i.menu_item_id\nWHERE \n    i.local_source = TRUE\nGROUP BY \n    r.id;\n```\n\nThis query joins the `restaurants` table with the `menu_items` and `ingredients` tables, filters for menu items that have at least one ingredient sourced locally (`i.local_source = TRUE`), counts distinct menu item IDs per restaurant, and groups by restaurant ID.", "latency_sec": 5.051892995834351, "total_duration_sec": 5.047640158, "load_duration_sec": 0.025238545, "tokens_prompt": 326, "prompt_eval_sec": 0.083901795, "tokens_completion": 194, "completion_eval_sec": 4.936181069, "tokens_total": 520, "tokens_per_sec": 102.93171300911904, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their GROUP BY clauses (r.name vs. r.id) and selected columns (name vs. id). While the data in the example has unique restaurant names, semantically, grouping by name could aggregate multiple restaurants with the same name (if they existed), whereas grouping by id ensures unique per-restaurant grouping. The output structure also differs (name vs. id)."}
{"example_id": 2265, "sql_complexity": "aggregation", "prompt": "Hourly revenue for a specific movie?", "context": "CREATE TABLE Movie_Revenue (id INT, movie_title VARCHAR(100), revenue_time TIME, revenue DECIMAL(10,2));", "reference_sql": "SELECT revenue_time, SUM(revenue) FROM Movie_Revenue WHERE movie_title = 'Spider-Man: No Way Home' GROUP BY revenue_time;", "generated_sql": "SELECT revenue_time, SUM(revenue) AS total_revenue\nFROM Movie_Revenue\nWHERE movie_title = 'Specific Movie Title'\nGROUP BY revenue_time;", "raw_model_output": "To retrieve the hourly revenue for a specific movie, you need to specify the movie title. Assuming you have the movie title, here is an example SQL query:\n\n```sql\nSELECT revenue_time, SUM(revenue) AS total_revenue\nFROM Movie_Revenue\nWHERE movie_title = 'Specific Movie Title'\nGROUP BY revenue_time;\n```\n\nReplace `'Specific Movie Title'` with the actual movie title for which you want to retrieve the hourly revenue.", "latency_sec": 2.2863290309906006, "total_duration_sec": 2.279386541, "load_duration_sec": 0.014156137, "tokens_prompt": 107, "prompt_eval_sec": 0.022391193, "tokens_completion": 92, "completion_eval_sec": 2.240796724, "tokens_total": 199, "tokens_per_sec": 87.03909074442318, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the movie title filter. The reference query uses 'Spider-Man: No Way Home' while the generated query uses 'Specific Movie Title'. This would filter different movies, leading to different results unless the placeholder title coincidentally matches the exact movie title in the data."}
{"example_id": 1763, "sql_complexity": "multiple_joins", "prompt": "What is the total food and beverage revenue last month for hotels in 'Bangkok'?", "context": "CREATE TABLE revenue (hotel_id INT, revenue_source VARCHAR(50), revenue INT, revenue_date DATE); INSERT INTO revenue (hotel_id, revenue_source, revenue, revenue_date) VALUES (5, 'Room revenue', 12000, '2022-03-01'), (5, 'Food and beverage', 4000, '2022-03-02'), (5, 'Other revenue', 1000, '2022-03-03'); CREATE TABLE hotels (hotel_id INT, city VARCHAR(50)); INSERT INTO hotels (hotel_id, city) VALUES (5, 'Bangkok'); CREATE TABLE dates (date DATE); INSERT INTO dates (date) VALUES ('2022-03-01'), ('2022-03-02'), ('2022-03-03');", "reference_sql": "SELECT SUM(revenue) FROM revenue JOIN hotels ON revenue.hotel_id = hotels.hotel_id JOIN dates ON revenue.revenue_date = dates.date WHERE hotels.city = 'Bangkok' AND revenue_source = 'Food and beverage' AND dates.date >= DATEADD(month, -1, GETDATE());", "generated_sql": "SELECT SUM(revenue) AS total_food_and_beverage_revenue\nFROM revenue r\nJOIN hotels h ON r.hotel_id = h.hotel_id\nWHERE r.revenue_source = 'Food and beverage'\n  AND h.city = 'Bangkok'\n  AND DATE_TRUNC('month', r.revenue_date) = DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month');", "raw_model_output": "```sql\nSELECT SUM(revenue) AS total_food_and_beverage_revenue\nFROM revenue r\nJOIN hotels h ON r.hotel_id = h.hotel_id\nWHERE r.revenue_source = 'Food and beverage'\n  AND h.city = 'Bangkok'\n  AND DATE_TRUNC('month', r.revenue_date) = DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month');\n```", "latency_sec": 2.2731246948242188, "total_duration_sec": 2.268334464, "load_duration_sec": 0.014004433, "tokens_prompt": 283, "prompt_eval_sec": 0.063987798, "tokens_completion": 84, "completion_eval_sec": 2.188317797, "tokens_total": 367, "tokens_per_sec": 161.451767619981, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their date filtering logic. The Reference SQL uses `dates.date >= DATEADD(month, -1, GETDATE())` to include all dates from the last month (up to current date), while the Generated SQL uses `DATE_TRUNC('month', r.revenue_date) = DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month')` to specifically target the entire previous month (e.g., February if current date is March). This makes the Generated SQL more restrictive, excluding dates from the current month's partial period. Additionally, the Generated SQL omits the unnecessary `dates` table join present in the Reference SQL."}
{"example_id": 5499, "sql_complexity": "set operations", "prompt": "How many legal aid clinics and community mediation centers are there in total, and what is the sum of cases handled by each type of center, for centers located in the state of California?", "context": "CREATE TABLE LegalAidClinics (ClinicName text, State text, NumCases int); INSERT INTO LegalAidClinics VALUES ('Clinic1', 'CA', 30, '2022-01-01'), ('Clinic2', 'CA', 25, '2022-01-01'); CREATE TABLE CommunityMediationCenters (CenterName text, State text, NumCases int); INSERT INTO CommunityMediationCenters VALUES ('CM1', 'CA', 22, '2022-01-01'), ('CM2', 'CA', 28, '2022-01-01');", "reference_sql": "SELECT State, 'Legal Aid Clinics' AS CenterType, COUNT(*) AS NumCenters, SUM(NumCases) AS TotalCases FROM LegalAidClinics WHERE State = 'CA' UNION ALL SELECT State, 'Community Mediation Centers', COUNT(*), SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA';", "generated_sql": "SELECT \n    (SELECT COUNT(*) FROM LegalAidClinics WHERE State = 'CA') AS NumLegalAidClinics,\n    (SELECT SUM(NumCases) FROM LegalAidClinics WHERE State = 'CA') AS TotalCasesLegalAidClinics,\n    (SELECT COUNT(*) FROM CommunityMediationCenters WHERE State = 'CA') AS NumCommunityMediationCenters,\n    (SELECT SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA') AS TotalCasesCommunityMediationCenters;", "raw_model_output": "To answer the question, we need to calculate the number of legal aid clinics and community mediation centers in California, along with the sum of cases handled by each type of center. Here's the corresponding SQL query:\n\n```sql\nSELECT \n    (SELECT COUNT(*) FROM LegalAidClinics WHERE State = 'CA') AS NumLegalAidClinics,\n    (SELECT SUM(NumCases) FROM LegalAidClinics WHERE State = 'CA') AS TotalCasesLegalAidClinics,\n    (SELECT COUNT(*) FROM CommunityMediationCenters WHERE State = 'CA') AS NumCommunityMediationCenters,\n    (SELECT SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA') AS TotalCasesCommunityMediationCenters;\n```\n\nThis query provides the count and total cases for both legal aid clinics and community mediation centers in California.", "latency_sec": 4.574207067489624, "total_duration_sec": 4.566556838, "load_duration_sec": 0.014531298, "tokens_prompt": 255, "prompt_eval_sec": 0.06125762, "tokens_completion": 178, "completion_eval_sec": 4.488521552, "tokens_total": 433, "tokens_per_sec": 94.66121529072693, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL returns two rows (one for each center type) with columns State, CenterType, NumCenters, TotalCases. The Generated SQL returns a single row with four separate columns for counts and sums of each center type. The structure and number of rows differ, so the results cannot be considered equivalent."}
{"example_id": 2408, "sql_complexity": "aggregation", "prompt": "What is the average number of victories for players from Japan and South Korea, partitioned by game mode?", "context": "CREATE TABLE PlayerVictories (PlayerID INT, GameMode VARCHAR(255), Victories INT, Country VARCHAR(255)); INSERT INTO PlayerVictories (PlayerID, GameMode, Victories, Country) VALUES (1, 'Battle Royale', 25, 'Japan'), (2, 'Team Deathmatch', 18, 'South Korea');", "reference_sql": "SELECT GameMode, AVG(Victories) as AvgVictories FROM PlayerVictories WHERE Country IN ('Japan', 'South Korea') GROUP BY GameMode, Country WITH ROLLUP;", "generated_sql": "SELECT GameMode, AVG(Victories) AS AverageVictories\nFROM PlayerVictories\nWHERE Country IN ('Japan', 'South Korea')\nGROUP BY GameMode;", "raw_model_output": "```sql\nSELECT GameMode, AVG(Victories) AS AverageVictories\nFROM PlayerVictories\nWHERE Country IN ('Japan', 'South Korea')\nGROUP BY GameMode;\n```", "latency_sec": 1.0380339622497559, "total_duration_sec": 1.033679909, "load_duration_sec": 0.023714794, "tokens_prompt": 167, "prompt_eval_sec": 0.035423096, "tokens_completion": 39, "completion_eval_sec": 0.972464089, "tokens_total": 206, "tokens_per_sec": 198.45208104129009, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL groups by both GameMode and Country with ROLLUP, producing subtotals for each country-mode combination and a final total. The Generated SQL only groups by GameMode, aggregating all victories across both countries for each game mode. This difference in grouping logic leads to distinct result sets."}
{"example_id": 2729, "sql_complexity": "subqueries", "prompt": "Find the total number of trips made by shared autonomous vehicles in Seattle", "context": "CREATE TABLE shared_vehicles (id INT, vehicle_type VARCHAR(20), is_autonomous BOOLEAN, trip_count INT); INSERT INTO shared_vehicles (id, vehicle_type, is_autonomous, trip_count) VALUES (1, 'ebike', false, 1200), (2, 'escooter', false, 800), (3, 'car', true, 1500); CREATE TABLE city_data (city VARCHAR(20), has_autonomous_vehicles BOOLEAN); INSERT INTO city_data (city, has_autonomous_vehicles) VALUES ('Seattle', true), ('Denver', false), ('Portland', true);", "reference_sql": "SELECT SUM(trip_count) FROM shared_vehicles WHERE is_autonomous = true AND vehicle_type != 'ebike' AND vehicle_type != 'escooter' AND city IN (SELECT city FROM city_data WHERE has_autonomous_vehicles = true AND city = 'Seattle');", "generated_sql": "SELECT SUM(sv.trip_count) AS total_trips\nFROM shared_vehicles sv\nJOIN city_data cd ON cd.has_autonomous_vehicles = sv.is_autonomous AND cd.city = 'Seattle';", "raw_model_output": "To find the total number of trips made by shared autonomous vehicles in Seattle, you need to join the `shared_vehicles` and `city_data` tables based on whether a city supports autonomous vehicles. Here is the corresponding SQL query:\n\n```sql\nSELECT SUM(sv.trip_count) AS total_trips\nFROM shared_vehicles sv\nJOIN city_data cd ON cd.has_autonomous_vehicles = sv.is_autonomous AND cd.city = 'Seattle';\n```\n\nThis query sums up the `trip_count` for all autonomous vehicles in Seattle.", "latency_sec": 2.814410924911499, "total_duration_sec": 2.809846834, "load_duration_sec": 0.014287144, "tokens_prompt": 217, "prompt_eval_sec": 0.050876623, "tokens_completion": 109, "completion_eval_sec": 2.741682119, "tokens_total": 326, "tokens_per_sec": 115.83240994214492, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes conditions to exclude 'ebike' and 'escooter' vehicle types, while the Generated SQL does not apply these filters. Additionally, the Reference SQL references a 'city' column in shared_vehicles that does not exist in the schema, making it invalid. The Generated SQL correctly joins on city_data but lacks the vehicle_type exclusions, leading to different results."}
{"example_id": 2952, "sql_complexity": "aggregation", "prompt": "Show the total budget allocated for each program category in 2023.", "context": "CREATE TABLE Budget (id INT, category TEXT, year INT, allocated_amount INT); INSERT INTO Budget (id, category, year, allocated_amount) VALUES (1, 'Education', 2023, 30000); INSERT INTO Budget (id, category, year, allocated_amount) VALUES (2, 'Healthcare', 2023, 50000);", "reference_sql": "SELECT category, SUM(allocated_amount) FROM Budget WHERE year = 2023 GROUP BY category;", "generated_sql": "SELECT category, SUM(allocated_amount) AS total_allocated_amount\nFROM Budget\nWHERE year = 2023\nGROUP BY category;", "raw_model_output": "```sql\nSELECT category, SUM(allocated_amount) AS total_allocated_amount\nFROM Budget\nWHERE year = 2023\nGROUP BY category;\n```", "latency_sec": 0.8981192111968994, "total_duration_sec": 0.892775128, "load_duration_sec": 0.013743095, "tokens_prompt": 169, "prompt_eval_sec": 0.048019715, "tokens_completion": 34, "completion_eval_sec": 0.827993171, "tokens_total": 203, "tokens_per_sec": 226.0279008278504, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (category and summed allocated_amount) from the Budget table where year is 2023, grouped by category. The only difference is the alias name for the aggregated column, which doesn't affect the semantic meaning of the query."}
{"example_id": 4328, "sql_complexity": "aggregation", "prompt": "What is the average cargo handling time in hours for each port?", "context": "CREATE TABLE cargo_handling (id INT, port_id INT, time_in_hours DECIMAL(5,2)); INSERT INTO cargo_handling (id, port_id, time_in_hours) VALUES (1, 1, 20.5), (2, 1, 22.3), (3, 2, 18.7);", "reference_sql": "SELECT port_id, AVG(time_in_hours) FROM cargo_handling GROUP BY port_id;", "generated_sql": "SELECT port_id, AVG(time_in_hours) AS avg_handling_time\nFROM cargo_handling\nGROUP BY port_id;", "raw_model_output": "```sql\nSELECT port_id, AVG(time_in_hours) AS avg_handling_time\nFROM cargo_handling\nGROUP BY port_id;\n```", "latency_sec": 0.7420957088470459, "total_duration_sec": 0.737107942, "load_duration_sec": 0.024880579, "tokens_prompt": 155, "prompt_eval_sec": 0.030663853, "tokens_completion": 28, "completion_eval_sec": 0.679440711, "tokens_total": 183, "tokens_per_sec": 246.59891954410736, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average time_in_hours per port_id. The generated query adds an alias (avg_handling_time) for the calculated column, but this does not affect the semantic result set structure or values. The GROUP BY clause and aggregation logic are identical."}
{"example_id": 4915, "sql_complexity": "window functions", "prompt": "Calculate the percentage of total Europium production for each country.", "context": "CREATE TABLE europium_production (country VARCHAR(50), quantity INT);", "reference_sql": "SELECT country, quantity * 100.0 / SUM(quantity) OVER (PARTITION BY NULL) AS percentage FROM europium_production;", "generated_sql": "SELECT \n    country,\n    (quantity * 100.0 / (SELECT SUM(quantity) FROM europium_production)) AS percentage_of_total\nFROM \n    europium_production;", "raw_model_output": "To calculate the percentage of total Europium production for each country, you can use a subquery to find the total production and then compute the percentage in the main query. Here is the corresponding SQL statement:\n\n```sql\nSELECT \n    country,\n    (quantity * 100.0 / (SELECT SUM(quantity) FROM europium_production)) AS percentage_of_total\nFROM \n    europium_production;\n```\n\nThis query calculates the total production of Europium across all countries in a subquery and then computes the percentage for each country's production relative to this total.", "latency_sec": 2.822416305541992, "total_duration_sec": 2.818576893, "load_duration_sec": 0.013974697, "tokens_prompt": 96, "prompt_eval_sec": 0.021170355, "tokens_completion": 116, "completion_eval_sec": 2.780985243, "tokens_total": 212, "tokens_per_sec": 75.1129447430291, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the percentage of each country's production relative to the total production. The reference query uses a window function SUM(quantity) OVER (PARTITION BY NULL) which computes the total sum across all rows, while the generated query uses a scalar subquery (SELECT SUM(quantity) FROM europium_production) to achieve the same total. Both approaches result in the same division of each row's quantity by the total sum, producing identical output."}
{"example_id": 5030, "sql_complexity": "subqueries", "prompt": "What is the success rate of diverse-led startups (at least 1 female or underrepresented racial or ethnic group executive) in the past 3 years?", "context": "CREATE TABLE DiverseStartups(id INT, name TEXT, country TEXT, year INT, success BOOLEAN);   INSERT INTO DiverseStartups VALUES (1, 'FemTech', 'USA', 2020, true), (2, 'GreenCity', 'Canada', 2019, false), (3, 'AI-Health', 'UK', 2021, true), (4, 'SolarEnergy', 'USA', 2020, false), (5, 'DataAnalytics', 'Germany', 2019, true), (6, 'SmartGrid', 'USA', 2021, true), (7, 'CloudServices', 'India', 2020, false), (8, 'RenewableEnergy', 'USA', 2019, true);", "reference_sql": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3) AS success_rate FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3 AND success = true;", "generated_sql": "SELECT \n    COUNT(CASE WHEN success = true THEN id END) * 100.0 / COUNT(id) AS success_rate_percent\nFROM \n    DiverseStartups\nWHERE \n    year >= (CURRENT_DATE - INTERVAL '3 YEAR')::DATE;", "raw_model_output": "To calculate the success rate of diverse-led startups over the past three years, we need to filter out startups based on their year and then compute the ratio of successful startups to the total number of startups. Given that the schema does not provide specific columns for diversity metrics (such as gender or ethnicity), I'll assume all startups in the table are diverse-led.\n\nHere is the SQL query:\n\n```sql\nSELECT \n    COUNT(CASE WHEN success = true THEN id END) * 100.0 / COUNT(id) AS success_rate_percent\nFROM \n    DiverseStartups\nWHERE \n    year >= (CURRENT_DATE - INTERVAL '3 YEAR')::DATE;\n```\n\nThis query calculates the percentage of successful startups from the past three years.\n\nIf you want to filter based on a specific range, for example 2019-2021:\n\n```sql\nSELECT \n    COUNT(CASE WHEN success = true THEN id END) * 100.0 / COUNT(id) AS success_rate_percent\nFROM \n    DiverseStartups\nWHERE \n    year BETWEEN (CURRENT_DATE - INTERVAL '3 YEAR')::DATE AND CURRENT_DATE;\n```\n\nFor a fixed range like the last three years specifically:\n\n```sql\nSELECT \n    COUNT(CASE WHEN success = true THEN id END) * 100.0 / COUNT(id) AS success_rate_percent\nFROM \n    DiverseStartups\nWHERE \n    year BETWEEN (EXTRACT(YEAR FROM CURRENT_DATE) - 3)::INT AND EXTRACT(YEAR FROM CURRENT_DATE);\n```\n\nIf you want to use a fixed range of years, for example from 2019 to 2021:\n\n```sql\nSELECT \n    COUNT(CASE WHEN success = true THEN id END) * 100.0 / COUNT(id) AS success_rate_percent\nFROM \n    DiverseStartups\nWHERE \n    year BETWEEN 2019 AND 2021;\n```\n\nThis query will give you the success rate of diverse-led startups from 2019 to 2021.", "latency_sec": 10.749366760253906, "total_duration_sec": 10.744650036, "load_duration_sec": 0.018741844, "tokens_prompt": 277, "prompt_eval_sec": 0.06484917, "tokens_completion": 432, "completion_eval_sec": 10.657654479, "tokens_total": 709, "tokens_per_sec": 65.95737365865568, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the success rate of startups in the last 3 years. The Reference SQL uses a subquery to get the total count and explicitly filters for success=true. The Generated SQL uses a CASE statement to count successes and divides by total count in the same filter. The year conditions (YEAR(CURRENT_DATE)-3 vs CURRENT_DATE - INTERVAL '3 YEAR') are equivalent in this context, and both queries use the same denominator and numerator logic."}
{"example_id": 4626, "sql_complexity": "aggregation", "prompt": "What was the maximum number of training hours for farmers in each country in 2020?", "context": "CREATE TABLE training (id INT, country_id INT, farmer_id INT, hours INT, date DATE);", "reference_sql": "SELECT country_id, MAX(hours) FROM training WHERE YEAR(date) = 2020 GROUP BY country_id;", "generated_sql": "SELECT \n    t.country_id,\n    MAX(t.hours) AS max_hours\nFROM \n    training t\nWHERE \n    YEAR(t.date) = 2020\nGROUP BY \n    t.country_id;", "raw_model_output": "To find the maximum number of training hours for farmers in each country in 2020, you can use the following SQL query:\n\n```sql\nSELECT \n    t.country_id,\n    MAX(t.hours) AS max_hours\nFROM \n    training t\nWHERE \n    YEAR(t.date) = 2020\nGROUP BY \n    t.country_id;\n```\n\nThis query selects the `country_id` and calculates the maximum number of hours (`MAX(t.hours)`) for each country where the year of the `date` is 2020. The results are grouped by `country_id`.", "latency_sec": 3.0794198513031006, "total_duration_sec": 3.072530744, "load_duration_sec": 0.01417383, "tokens_prompt": 110, "prompt_eval_sec": 0.025614479, "tokens_completion": 126, "completion_eval_sec": 3.030548797, "tokens_total": 236, "tokens_per_sec": 76.63781211910198, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select country_id and the maximum hours from the training table where the date is in 2020, grouped by country_id. The generated query uses a table alias and explicit column aliases, but these do not affect the semantic result. The logical structure, filtering, grouping, and aggregation are identical."}
{"example_id": 2703, "sql_complexity": "set operations", "prompt": "Identify the species unique to 'MarineResearchAreaA' and 'MarineResearchAreaB'", "context": "CREATE TABLE ResearchAreaSpecies (area VARCHAR(255), species VARCHAR(255)); INSERT INTO ResearchAreaSpecies (area, species) VALUES ('MarineResearchAreaA', 'Coral'), ('MarineResearchAreaA', 'Starfish'), ('MarineResearchAreaB', 'Jellyfish');", "reference_sql": "(SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB') UNION (SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA');", "generated_sql": "SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA'\nINTERSECT\nSELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB';", "raw_model_output": "To identify the species that are unique to both 'MarineResearchAreaA' and 'MarineResearchAreaB', you can use an INTERSECT operation or a combination of JOINs and GROUP BY with HAVING clause. Here, I'll demonstrate using INTERSECT:\n\n```sql\nSELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA'\nINTERSECT\nSELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB';\n```\n\nThis query will return the species that are present in both 'MarineResearchAreaA' and 'MarineResearchAreaB'. However, if you want to find species unique to each area (i.e., not shared between them), you can use:\n\n```sql\nSELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA'\nEXCEPT\nSELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB'\n\nUNION\n\nSELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB'\nEXCEPT\nSELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA';\n```\n\nThis query will return the species that are unique to either 'MarineResearchAreaA' or 'MarineResearchAreaB'.", "latency_sec": 6.243410110473633, "total_duration_sec": 6.238353763, "load_duration_sec": 0.01871875, "tokens_prompt": 155, "prompt_eval_sec": 0.035511994, "tokens_completion": 253, "completion_eval_sec": 6.180220338, "tokens_total": 408, "tokens_per_sec": 65.34890272794344, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL computes the symmetric difference (species unique to each area) using EXCEPT and UNION, while the Generated SQL finds the intersection (species common to both areas) with INTERSECT. The Reference SQL returns Coral, Starfish, and Jellyfish, whereas the Generated SQL returns no rows. They produce different results."}
{"example_id": 200, "sql_complexity": "window functions", "prompt": "List the top three categories of workforce development programs with the highest budget increases.", "context": "CREATE TABLE programs (program_id INT, program_name VARCHAR(50), budget DECIMAL(10, 2), category VARCHAR(50), budget_date DATE);", "reference_sql": "SELECT category, SUM(budget - LAG(budget) OVER (PARTITION BY category ORDER BY budget_date)) as total_budget_increase FROM programs GROUP BY category ORDER BY total_budget_increase DESC LIMIT 3;", "generated_sql": "WITH yearly_budgets AS (\n    SELECT \n        program_id, \n        category,\n        EXTRACT(YEAR FROM budget_date) AS year,\n        SUM(budget) AS total_budget\n    FROM programs\n    WHERE category LIKE '%workforce development%'\n    GROUP BY program_id, category, EXTRACT(YEAR FROM budget_date)\n),\nbudget_changes AS (\n    SELECT \n        category,\n        LAG(total_budget) OVER (PARTITION BY program_id ORDER BY year) AS prev_year_budget,\n        total_budget,\n        year\n    FROM yearly_budgets\n)\nSELECT \n    bc.category,\n    SUM(bc.total_budget - COALESCE(bc.prev_year_budget, 0)) AS budget_increase\nFROM budget_changes bc\nGROUP BY bc.category\nORDER BY budget_increase DESC\nLIMIT 3;", "raw_model_output": "To list the top three categories of workforce development programs with the highest budget increases, we need to follow these steps:\n\n1. Filter for workforce development programs.\n2. Calculate the budget increase (assuming there is a way to compare budgets over time, e.g., by comparing different years).\n3. Group by category and sum up the budget increases.\n4. Order the results in descending order of total budget increase.\n5. Limit the result to the top three categories.\n\nHere's an example SQL statement assuming we have data for multiple years:\n\n```sql\nWITH yearly_budgets AS (\n    SELECT \n        program_id, \n        category,\n        EXTRACT(YEAR FROM budget_date) AS year,\n        SUM(budget) AS total_budget\n    FROM programs\n    WHERE category LIKE '%workforce development%'\n    GROUP BY program_id, category, EXTRACT(YEAR FROM budget_date)\n),\nbudget_changes AS (\n    SELECT \n        category,\n        LAG(total_budget) OVER (PARTITION BY program_id ORDER BY year) AS prev_year_budget,\n        total_budget,\n        year\n    FROM yearly_budgets\n)\nSELECT \n    bc.category,\n    SUM(bc.total_budget - COALESCE(bc.prev_year_budget, 0)) AS budget_increase\nFROM budget_changes bc\nGROUP BY bc.category\nORDER BY budget_increase DESC\nLIMIT 3;\n```\n\nThis query assumes that the `budget_date` column contains a date from which we can extract the year to compare budgets over different years. If there is no such temporal data and you have separate columns for each year's budget, adjust accordingly.", "latency_sec": 7.916093826293945, "total_duration_sec": 7.911878613, "load_duration_sec": 0.022516806, "tokens_prompt": 119, "prompt_eval_sec": 0.025452166, "tokens_completion": 322, "completion_eval_sec": 7.861438726, "tokens_total": 441, "tokens_per_sec": 55.7092942146773, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in several key aspects.  The generated query includes a WHERE clause filtering for 'workforce development' categories, while the reference query does not.  The generated query calculates budget changes per program_id, whereas the reference query calculates budget changes per category.  Additionally, the generated query uses a different approach to calculate the budget increase, summing the differences between consecutive years for each program, while the reference query uses a window function to calculate the difference between the current and previous budget within each category, then sums those differences. These differences in logic and data aggregation will lead to different results."}
{"example_id": 5131, "sql_complexity": "basic SQL", "prompt": "How many wells were drilled in the Eagle Ford Shale and Bakken Formation?", "context": "CREATE TABLE wells (id INT, region VARCHAR(255), well_type VARCHAR(255), num_drilled INT); INSERT INTO wells (id, region, well_type, num_drilled) VALUES (1, 'Eagle Ford Shale', 'Oil', 2000), (2, 'Eagle Ford Shale', 'Gas', 1500), (3, 'Bakken Formation', 'Oil', 1000), (4, 'Bakken Formation', 'Gas', 1200);", "reference_sql": "SELECT SUM(num_drilled) as total_wells FROM wells WHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "generated_sql": "SELECT SUM(num_drilled) AS total_wells_drilled\nFROM wells\nWHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "raw_model_output": "```sql\nSELECT SUM(num_drilled) AS total_wells_drilled\nFROM wells\nWHERE region IN ('Eagle Ford Shale', 'Bakken Formation');\n```", "latency_sec": 0.9843299388885498, "total_duration_sec": 0.977570798, "load_duration_sec": 0.013641322, "tokens_prompt": 202, "prompt_eval_sec": 0.047346322, "tokens_completion": 37, "completion_eval_sec": 0.914430072, "tokens_total": 239, "tokens_per_sec": 242.80476551375182, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of num_drilled for wells in the 'Eagle Ford Shale' and 'Bakken Formation' regions. The only difference is the alias name (total_wells vs. total_wells_drilled), which does not affect the semantic result."}
{"example_id": 1160, "sql_complexity": "subqueries", "prompt": "What is the total revenue generated from ads on Instagram in March 2021, for users in the 'brand' category who have posted more than 10 times?", "context": "CREATE TABLE ads (ad_id INT, user_id INT, platform VARCHAR(255), ad_revenue DECIMAL(10,2), post_count INT); INSERT INTO ads (ad_id, user_id, platform, ad_revenue, post_count) VALUES (1, 1, 'Instagram', 150.50, 12), (2, 2, 'Twitter', 80.00, 15), (3, 3, 'Instagram', 120.75, 8);", "reference_sql": "SELECT SUM(ad_revenue) FROM ads WHERE platform = 'Instagram' AND MONTH(ad_date) = 3 AND YEAR(ad_date) = 2021 AND user_id IN (SELECT user_id FROM users WHERE category = 'brand' AND post_count > 10);", "generated_sql": "CREATE TABLE users (user_id INT, category VARCHAR(255));\nINSERT INTO users (user_id, category) VALUES (1, 'brand'), (2, 'individual'), (3, 'brand');\n\nCREATE TABLE ad_logs (ad_log_id INT, ad_id INT, log_date DATE);\nINSERT INTO ad_logs (ad_log_id, ad_id, log_date) \nVALUES (1, 1, '2021-03-05'), (2, 2, '2021-04-10'), (3, 3, '2021-03-15');", "raw_model_output": "To answer this question with the given schema, we need to make some assumptions since the provided schema does not include columns like `category` or date information. Let's assume there is a table called `users` that contains user categories and another table called `ad_logs` which includes dates.\n\nHere\u2019s an example of how you might structure your tables:\n\n```sql\nCREATE TABLE users (user_id INT, category VARCHAR(255));\nINSERT INTO users (user_id, category) VALUES (1, 'brand'), (2, 'individual'), (3, 'brand');\n\nCREATE TABLE ad_logs (ad_log_id INT, ad_id INT, log_date DATE);\nINSERT INTO ad_logs (ad_log_id, ad_id, log_date) \nVALUES (1, 1, '2021-03-05'), (2, 2, '2021-04-10'), (3, 3, '2021-03-15');\n```\n\nGiven these assumptions, the SQL query to find the total revenue generated from ads on Instagram in March 2021 for users in the 'brand' category who have posted more than 10 times would be:\n\n```sql\nSELECT SUM(a.ad_revenue) AS total_revenue\nFROM ads a\nJOIN users u ON a.user_id = u.user_id\nJOIN ad_logs al ON a.ad_id = al.ad_id\nWHERE u.category = 'brand'\nAND a.platform = 'Instagram'\nAND a.post_count > 10\nAND MONTH(al.log_date) = 3\nAND YEAR(al.log_date) = 2021;\n```\n\nThis query joins the `ads`, `users`, and `ad_logs` tables to filter for users in the 'brand' category, ads on Instagram with more than 10 posts, and logs from March 2021. It then sums up the ad revenue that meets these criteria.", "latency_sec": 9.961666107177734, "total_duration_sec": 9.956473038, "load_duration_sec": 0.013542788, "tokens_prompt": 220, "prompt_eval_sec": 0.048761088, "tokens_completion": 404, "completion_eval_sec": 9.891681743, "tokens_total": 624, "tokens_per_sec": 62.6401239799019, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Generated SQL contains DDL and DML statements (table creation and data insertion) rather than a query. The Reference SQL is a SELECT query, so the two cannot be semantically equivalent as they serve entirely different purposes (schema/data definition vs. data retrieval)."}
{"example_id": 4708, "sql_complexity": "subqueries", "prompt": "What is the maximum number of high-level threats reported by a single agency in a month?", "context": "CREATE TABLE Threat_Intelligence (Threat_ID INT, Threat_Type VARCHAR(50), Threat_Level VARCHAR(50), Reported_Date DATE, Reporting_Agency VARCHAR(50)); CREATE VIEW High_Level_Threats AS SELECT Threat_Type, Threat_Level, Reported_Date FROM Threat_Intelligence WHERE Threat_Level = 'High';", "reference_sql": "SELECT Reporting_Agency, MAX(Number_of_High_Level_Threats) as Max_High_Level_Threats_in_a_Month FROM (SELECT Reporting_Agency, TO_CHAR(Reported_Date, 'YYYY-MM') as Month, COUNT(*) as Number_of_High_Level_Threats FROM High_Level_Threats GROUP BY Reporting_Agency, Month) GROUP BY Reporting_Agency;", "generated_sql": "SELECT MAX(monthly_count) AS max_threats_per_month\nFROM (\n    SELECT Reporting_Agency, DATE_TRUNC('month', Reported_Date) AS month, COUNT(*) AS monthly_count\n    FROM Threat_Intelligence\n    WHERE Threat_Level = 'High'\n    GROUP BY Reporting_Agency, DATE_TRUNC('month', Reported_Date)\n) AS threat_counts;", "raw_model_output": "To find the maximum number of high-level threats reported by a single agency in a month, we need to follow these steps:\n\n1. Filter out only the high-level threats.\n2. Group them by Reporting_Agency and the month of Reported_Date.\n3. Count the number of threats for each group.\n4. Find the maximum count.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT MAX(monthly_count) AS max_threats_per_month\nFROM (\n    SELECT Reporting_Agency, DATE_TRUNC('month', Reported_Date) AS month, COUNT(*) AS monthly_count\n    FROM Threat_Intelligence\n    WHERE Threat_Level = 'High'\n    GROUP BY Reporting_Agency, DATE_TRUNC('month', Reported_Date)\n) AS threat_counts;\n```\n\nThis query uses `DATE_TRUNC` to group the threats by month and then counts the number of high-level threats reported each month for each agency. The outer query finds the maximum count from these grouped results.", "latency_sec": 4.901733160018921, "total_duration_sec": 4.895223921, "load_duration_sec": 0.020276578, "tokens_prompt": 153, "prompt_eval_sec": 0.03325152, "tokens_completion": 198, "completion_eval_sec": 4.83691182, "tokens_total": 351, "tokens_per_sec": 71.6073251116438, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their aggregation scope. The Reference SQL calculates the maximum monthly high-level threats per Reporting_Agency, while the Generated SQL finds the overall maximum monthly count across all agencies. The Generated SQL lacks grouping by Reporting_Agency in the outer query, leading to a single maximum value instead of per-agency maxima."}
{"example_id": 5608, "sql_complexity": "set operations", "prompt": "List the suppliers that provide materials for both product A and product C.", "context": "CREATE TABLE products (product_id INT, product_name TEXT); CREATE TABLE materials (material_id INT, material_name TEXT, product_id INT, supplier_id INT); INSERT INTO products (product_id, product_name) VALUES (1, 'Product A'), (2, 'Product B'), (3, 'Product C'); INSERT INTO materials (material_id, material_name, product_id, supplier_id) VALUES (1, 'Material 1', 1, 101), (2, 'Material 2', 1, 102), (3, 'Material 3', 2, 103), (4, 'Material 4', 3, 101), (5, 'Material 5', 3, 102);", "reference_sql": "SELECT supplier_id FROM materials WHERE product_id = 1 INTERSECT SELECT supplier_id FROM materials WHERE product_id = 3;", "generated_sql": "SELECT m.supplier_id \nFROM materials m\nJOIN products p ON m.product_id = p.product_id\nWHERE p.product_name IN ('Product A', 'Product C')\nGROUP BY m.supplier_id\nHAVING COUNT(DISTINCT p.product_name) = 2;", "raw_model_output": "```sql\nSELECT m.supplier_id \nFROM materials m\nJOIN products p ON m.product_id = p.product_id\nWHERE p.product_name IN ('Product A', 'Product C')\nGROUP BY m.supplier_id\nHAVING COUNT(DISTINCT p.product_name) = 2;\n```", "latency_sec": 1.5983431339263916, "total_duration_sec": 1.59396018, "load_duration_sec": 0.023799925, "tokens_prompt": 244, "prompt_eval_sec": 0.052723605, "tokens_completion": 61, "completion_eval_sec": 1.515184462, "tokens_total": 305, "tokens_per_sec": 190.82260468736504, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve supplier_ids that have materials for both Product A (product_id=1) and Product C (product_id=3). The Reference SQL uses INTERSECT to find common supplier_ids between the two product_id conditions, while the Generated SQL uses a JOIN and HAVING clause to ensure suppliers have materials for both products. The result sets are identical given the data constraints."}
{"example_id": 1506, "sql_complexity": "basic SQL", "prompt": "How many habitats are in the 'animal_habitats' table?", "context": "CREATE TABLE animal_habitats (id INT PRIMARY KEY, habitat_name VARCHAR, num_animals INT);", "reference_sql": "SELECT COUNT(*) FROM animal_habitats;", "generated_sql": "SELECT COUNT(*) AS number_of_habitats FROM animal_habitats;", "raw_model_output": "```sql\nSELECT COUNT(*) AS number_of_habitats FROM animal_habitats;\n```", "latency_sec": 0.5273616313934326, "total_duration_sec": 0.521048368, "load_duration_sec": 0.019390199, "tokens_prompt": 104, "prompt_eval_sec": 0.021824823, "tokens_completion": 20, "completion_eval_sec": 0.477774299, "tokens_total": 124, "tokens_per_sec": 235.1327677600631, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries count all rows in the animal_habitats table. The generated query adds an alias (number_of_habitats) to the COUNT(*) result, but this doesn't change the actual value returned. The semantic result (total row count) remains identical."}
{"example_id": 3117, "sql_complexity": "aggregation", "prompt": "What is the percentage of the population that has access to clean water in each continent?", "context": "CREATE TABLE water_data (id INT, country VARCHAR(50), continent CHAR(2), access_to_clean_water BOOLEAN); INSERT INTO water_data VALUES (1, 'Canada', 'NA', true), (2, 'Mexico', 'NA', false), (3, 'Brazil', 'SA', true), (4, 'Russia', 'EU', true);", "reference_sql": "SELECT continent, COUNT(*) FILTER (WHERE access_to_clean_water) * 100.0 / COUNT(*) AS percentage FROM water_data GROUP BY continent;", "generated_sql": "SELECT \n    continent,\n    SUM(CASE WHEN access_to_clean_water = true THEN 1 ELSE 0 END) * 100 / COUNT(*) AS percentage_with_access\nFROM \n    water_data\nGROUP BY \n    continent;", "raw_model_output": "To calculate the percentage of the population with access to clean water for each continent, we need to count the number of people who have access and those who do not, and then compute the ratio. Assuming each row represents an individual or a significant portion of the population (which is often the case in such datasets), we can use the following SQL query:\n\n```sql\nSELECT \n    continent,\n    SUM(CASE WHEN access_to_clean_water = true THEN 1 ELSE 0 END) * 100 / COUNT(*) AS percentage_with_access\nFROM \n    water_data\nGROUP BY \n    continent;\n```\n\nThis query calculates the percentage of entries (representing population segments) that have `access_to_clean_water` set to `true` for each continent.", "latency_sec": 3.816267967224121, "total_duration_sec": 3.81182931, "load_duration_sec": 0.01480365, "tokens_prompt": 160, "prompt_eval_sec": 0.034639404, "tokens_completion": 155, "completion_eval_sec": 3.75904568, "tokens_total": 315, "tokens_per_sec": 82.54137358942455, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses COUNT(*) FILTER (WHERE access_to_clean_water) * 100.0 / COUNT(*) which ensures floating-point division by multiplying by 100.0. The Generated SQL uses SUM(CASE WHEN access_to_clean_water = true THEN 1 ELSE 0 END) * 100 / COUNT(*), which performs integer division (since 100 is an integer). This leads to different results when the division is not exact (e.g., 100 / 3 = 33 vs 33.333...). The data type of the constant (100 vs 100.0) affects the calculation, making the queries non-equivalent."}
{"example_id": 3542, "sql_complexity": "window functions", "prompt": "What is the average yield of crops for each country, ranked by average yield?", "context": "CREATE TABLE farming (id INT, name TEXT, country TEXT, crop TEXT, yield INT); INSERT INTO farming VALUES (1, 'Smith Farm', 'USA', 'Corn', 120), (2, 'Brown Farm', 'Canada', 'Soybeans', 45), (3, 'Jones Farm', 'Mexico', 'Wheat', 80);", "reference_sql": "SELECT country, AVG(yield) as avg_yield, ROW_NUMBER() OVER (ORDER BY AVG(yield) DESC) as rank FROM farming GROUP BY country;", "generated_sql": "SELECT country, AVG(yield) AS avg_yield\nFROM farming\nGROUP BY country\nORDER BY avg_yield;", "raw_model_output": "```sql\nSELECT country, AVG(yield) AS avg_yield\nFROM farming\nGROUP BY country\nORDER BY avg_yield;\n```", "latency_sec": 0.7590179443359375, "total_duration_sec": 0.751760261, "load_duration_sec": 0.025279546, "tokens_prompt": 163, "prompt_eval_sec": 0.042661331, "tokens_completion": 28, "completion_eval_sec": 0.681763166, "tokens_total": 191, "tokens_per_sec": 251.64095450616168, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a ROW_NUMBER() window function to assign ranks based on average yield, while the Generated SQL only calculates averages and orders results. The Reference query adds a 'rank' column not present in the Generated query, and the Generated query's ORDER BY clause alters the output ordering compared to the Reference's implicit ordering via the window function."}
{"example_id": 2274, "sql_complexity": "subqueries", "prompt": "Add a new crop 'amaranth' to farm 'Nourishing Harvest' with yield 50 in 2023", "context": "CREATE TABLE farms (id INT, name TEXT, location TEXT, size FLOAT); INSERT INTO farms (id, name, location, size) VALUES (1, 'Nourishing Harvest', 'Mexico', 120.0); CREATE TABLE crops (id INT, farm_id INT, crop TEXT, yield INT, year INT);", "reference_sql": "INSERT INTO crops (id, farm_id, crop, yield, year) VALUES (5, (SELECT id FROM farms WHERE name = 'Nourishing Harvest'), 'amaranth', 50, 2023);", "generated_sql": "INSERT INTO crops (id, farm_id, crop, yield, year)\nSELECT \n    (SELECT MAX(id) + 1 FROM crops), -- Generate a new ID for the crop entry.\n    f.id,                            -- Use the farm's id from farms table.\n    'amaranth',                      -- The name of the new crop.\n    50,                              -- Yield value.\n    2023                             -- Year\nFROM \n    farms AS f\nWHERE \n    f.name = 'Nourishing Harvest';   -- Filter for the specific farm.", "raw_model_output": "To add the new crop 'amaranth' for the farm 'Nourishing Harvest', we need to follow these steps:\n\n1. Find the `farm_id` of 'Nourishing Harvest'.\n2. Insert a new row into the `crops` table with the appropriate values.\n\nHere is the SQL statement that accomplishes this:\n\n```sql\nINSERT INTO crops (id, farm_id, crop, yield, year)\nSELECT \n    (SELECT MAX(id) + 1 FROM crops), -- Generate a new ID for the crop entry.\n    f.id,                            -- Use the farm's id from farms table.\n    'amaranth',                      -- The name of the new crop.\n    50,                              -- Yield value.\n    2023                             -- Year\nFROM \n    farms AS f\nWHERE \n    f.name = 'Nourishing Harvest';   -- Filter for the specific farm.\n```\n\nThis statement first finds the `farm_id` for 'Nourishing Harvest' and then inserts a new row into the `crops` table with the appropriate values.", "latency_sec": 5.5112199783325195, "total_duration_sec": 5.506457371, "load_duration_sec": 0.021677211, "tokens_prompt": 165, "prompt_eval_sec": 0.033987635, "tokens_completion": 223, "completion_eval_sec": 5.44868819, "tokens_total": 388, "tokens_per_sec": 70.40183507924387, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL inserts a specific row with a fixed ID (5) and uses a subquery to get the farm_id. The Generated SQL dynamically calculates the ID as MAX(id) + 1 from the crops table and uses a SELECT statement that could insert multiple rows if multiple farms share the same name. Additionally, the Generated SQL's ID generation depends on the current state of the crops table, while the Reference SQL uses a hard-coded value."}
{"example_id": 3705, "sql_complexity": "subqueries", "prompt": "What is the percentage of unions with collective bargaining agreements in the Midwest region?", "context": "CREATE TABLE collective_bargaining (bargaining_id INT, union_name VARCHAR(50), contract_start_date DATE, contract_end_date DATE, region VARCHAR(50));CREATE VIEW union_region AS SELECT DISTINCT union_name, region FROM collective_bargaining;", "reference_sql": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM union_region) as percentage FROM union_region ur WHERE ur.region = 'Midwest' AND EXISTS (SELECT 1 FROM collective_bargaining cb WHERE cb.union_name = ur.union_name);", "generated_sql": "WITH union_count AS (\n    SELECT COUNT(DISTINCT union_name) AS total_unions\n    FROM collective_bargaining\n),\nmidwest_union_count AS (\n    SELECT COUNT(DISTINCT union_name) AS midwest_unions\n    FROM union_region\n    WHERE region = 'Midwest'\n)\nSELECT \n    (midwest_union_count.midwest_unions * 100.0 / union_count.total_unions) AS percentage_midwest\nFROM \n    union_count, midwest_union_count;", "raw_model_output": "To calculate the percentage of unions with collective bargaining agreements in the Midwest region, we need to follow these steps:\n\n1. Count the total number of distinct unions.\n2. Count the number of distinct unions in the Midwest region.\n3. Calculate the percentage.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nWITH union_count AS (\n    SELECT COUNT(DISTINCT union_name) AS total_unions\n    FROM collective_bargaining\n),\nmidwest_union_count AS (\n    SELECT COUNT(DISTINCT union_name) AS midwest_unions\n    FROM union_region\n    WHERE region = 'Midwest'\n)\nSELECT \n    (midwest_union_count.midwest_unions * 100.0 / union_count.total_unions) AS percentage_midwest\nFROM \n    union_count, midwest_union_count;\n```\n\nThis query uses Common Table Expressions (CTEs) to calculate the total number of unions and the number of unions in the Midwest region separately before computing the percentage.", "latency_sec": 5.014122009277344, "total_duration_sec": 5.007540912, "load_duration_sec": 0.026700856, "tokens_prompt": 137, "prompt_eval_sec": 0.031472755, "tokens_completion": 204, "completion_eval_sec": 4.946112668, "tokens_total": 341, "tokens_per_sec": 68.00791830934052, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the percentage of (union_name, region) pairs in the Midwest relative to all (union_name, region) pairs in union_region. The Generated SQL calculates the percentage of distinct union_names in the Midwest relative to all distinct union_names in collective_bargaining. The denominators differ: the Reference uses total rows in union_region (which includes all (union_name, region) pairs), while the Generated uses distinct union_names from collective_bargaining. This leads to different results when a union has multiple entries in different regions."}
{"example_id": 240, "sql_complexity": "aggregation", "prompt": "What is the average capacity of renewable energy projects for each country?", "context": "CREATE TABLE projects (name TEXT, type TEXT, capacity INTEGER, country TEXT); INSERT INTO projects (name, type, capacity, country) VALUES ('Project 1', 'Wind', 100, 'USA'), ('Project 2', 'Solar', 200, 'Germany'), ('Project 3', 'Wind', 300, 'France');", "reference_sql": "SELECT country, AVG(capacity) FROM projects GROUP BY country", "generated_sql": "SELECT country, AVG(capacity) AS avg_capacity\nFROM projects\nGROUP BY country;", "raw_model_output": "To find the average capacity of renewable energy projects for each country, you can use the following SQL query:\n\n```sql\nSELECT country, AVG(capacity) AS avg_capacity\nFROM projects\nGROUP BY country;\n```", "latency_sec": 1.1917810440063477, "total_duration_sec": 1.184892995, "load_duration_sec": 0.023018305, "tokens_prompt": 159, "prompt_eval_sec": 0.033798285, "tokens_completion": 44, "completion_eval_sec": 1.125961872, "tokens_total": 203, "tokens_per_sec": 170.3333015916964, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average capacity per country using GROUP BY. The Generated SQL adds an alias (avg_capacity) to the computed column, but this does not affect the result set's data. The grouping logic, aggregation function, and output values remain identical."}
{"example_id": 2132, "sql_complexity": "set operations", "prompt": "What is the average caseload per attorney in community legal clinics in California, and how does it compare to the state average?", "context": "CREATE TABLE cali_community_legal_clinics(id INT, attorney_count INT, cases_handled INT, state VARCHAR(255));", "reference_sql": "SELECT state, AVG(cases_handled/attorney_count) AS avg_caseload FROM cali_community_legal_clinics WHERE state = 'California' GROUP BY state UNION ALL SELECT 'California', AVG(cases_handled/attorney_count) FROM cali_community_legal_clinics WHERE state = 'California';", "generated_sql": "WITH clinic_stats AS (\n    SELECT AVG(cases_handled / NULLIF(attorney_count, 0)) AS avg_caseload_per_attorney\n    FROM cali_community_legal_clinics\n)\nSELECT \n    (SELECT avg_caseload_per_attorney FROM clinic_stats) AS state_avg,\n    (SELECT SUM(cases_handled) / SUM(NULLIF(attorney_count, 0)) FROM cali_community_legal_clinics) AS clinic_avg;", "raw_model_output": "To answer this question, we need to calculate two values: \n1. The average caseload per attorney for all community legal clinics in California.\n2. The overall state average of cases handled per attorney.\n\nHere is a single SQL statement that calculates both:\n\n```sql\nWITH clinic_stats AS (\n    SELECT AVG(cases_handled / NULLIF(attorney_count, 0)) AS avg_caseload_per_attorney\n    FROM cali_community_legal_clinics\n)\nSELECT \n    (SELECT avg_caseload_per_attorney FROM clinic_stats) AS state_avg,\n    (SELECT SUM(cases_handled) / SUM(NULLIF(attorney_count, 0)) FROM cali_community_legal_clinics) AS clinic_avg;\n```\n\nThis query uses a Common Table Expression (CTE) to calculate the average caseload per attorney for all clinics in California. Then it selects both this value and the overall state average directly from the table.", "latency_sec": 4.704483985900879, "total_duration_sec": 4.697531287, "load_duration_sec": 0.015056043, "tokens_prompt": 122, "prompt_eval_sec": 0.0260843, "tokens_completion": 193, "completion_eval_sec": 4.654255147, "tokens_total": 315, "tokens_per_sec": 66.9573965910056, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL returns two rows with the same average caseload for California, while the Generated SQL returns a single row with two different calculated values (average per attorney and total caseload ratio). Additionally, the Generated SQL uses SUM-based calculations and NULLIF handling, which differ from the Reference SQL's AVG(cases_handled/attorney_count) approach."}
{"example_id": 3276, "sql_complexity": "basic SQL", "prompt": "What is the total energy consumption of the Chemical Plant B in the last quarter?", "context": "CREATE TABLE EnergyConsumption (EnergyID INT, Plant VARCHAR(255), EnergyQuantity DECIMAL(5,2), Timestamp DATETIME);", "reference_sql": "SELECT SUM(EnergyQuantity) FROM EnergyConsumption WHERE Plant = 'Chemical Plant B' AND Timestamp BETWEEN DATE_SUB(CURRENT_DATE(), INTERVAL 3 MONTH) AND CURRENT_DATE();", "generated_sql": "SELECT SUM(EnergyQuantity) AS TotalEnergyConsumption\nFROM EnergyConsumption\nWHERE Plant = 'Chemical Plant B'\n  AND Timestamp >= DATE_TRUNC('quarter', CURRENT_DATE - INTERVAL '1' QUARTER)\n  AND Timestamp < DATE_TRUNC('quarter', CURRENT_DATE);", "raw_model_output": "To calculate the total energy consumption of the Chemical Plant B in the last quarter, you can use the following SQL query:\n\n```sql\nSELECT SUM(EnergyQuantity) AS TotalEnergyConsumption\nFROM EnergyConsumption\nWHERE Plant = 'Chemical Plant B'\n  AND Timestamp >= DATE_TRUNC('quarter', CURRENT_DATE - INTERVAL '1' QUARTER)\n  AND Timestamp < DATE_TRUNC('quarter', CURRENT_DATE);\n```\n\nThis query sums up the `EnergyQuantity` for entries where the `Plant` is 'Chemical Plant B' and the `Timestamp` falls within the last quarter. The use of `DATE_TRUNC` ensures that we are considering the correct quarter boundaries.", "latency_sec": 3.4020819664001465, "total_duration_sec": 3.394779978, "load_duration_sec": 0.021099947, "tokens_prompt": 115, "prompt_eval_sec": 0.027269513, "tokens_completion": 139, "completion_eval_sec": 3.342853382, "tokens_total": 254, "tokens_per_sec": 74.66016471930148, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their date range calculations. The reference uses a fixed 3-month window from CURRENT_DATE - 3 MONTH, while the generated query uses quarter-based truncation. DATE_TRUNC('quarter', ...) aligns dates to the start of their respective quarters, which may not correspond to exact 3-month periods. Additionally, the generated query uses an exclusive upper bound (<) instead of BETWEEN, potentially excluding records on the last day of the quarter. These differences in date logic make the queries non-equivalent."}
{"example_id": 3074, "sql_complexity": "multiple_joins", "prompt": "Find the top 5 players with the highest scores in the 'historical_tournaments' view, including their scores and the names of the tournaments they participated in.", "context": "CREATE VIEW historical_tournaments AS SELECT tournaments.tournament_name, players.player_name, players.score FROM tournaments JOIN players_scores ON tournaments.tournament_id = players_scores.tournament_id JOIN players ON players_scores.player_id = players.player_id;  CREATE TABLE tournaments (tournament_id INT, tournament_name TEXT);  CREATE TABLE players_scores (player_id INT, tournament_id INT, score INT);  CREATE TABLE players (player_id INT, player_name TEXT);", "reference_sql": "SELECT players.player_name, MAX(players_scores.score) as high_score, tournaments.tournament_name FROM historical_tournaments JOIN players ON historical_tournaments.player_id = players.player_id JOIN players_scores ON historical_tournaments.player_id = players_scores.player_id JOIN tournaments ON players_scores.tournament_id = tournaments.tournament_id GROUP BY players.player_id, tournaments.tournament_name ORDER BY high_score DESC LIMIT 5;", "generated_sql": "SELECT player_name, score, tournament_name\nFROM (\n    SELECT player_name, score, tournament_name,\n           RANK() OVER (ORDER BY score DESC) as rank\n    FROM historical_tournaments\n) ranked_players\nWHERE rank <= 5;", "raw_model_output": "To find the top 5 players with the highest scores from the `historical_tournaments` view, along with their tournament details, you can use a query that ranks the players by score and then selects the top 5. Here's how you could write this query:\n\n```sql\nSELECT player_name, score, tournament_name\nFROM (\n    SELECT player_name, score, tournament_name,\n           RANK() OVER (ORDER BY score DESC) as rank\n    FROM historical_tournaments\n) ranked_players\nWHERE rank <= 5;\n```\n\nThis SQL statement uses a subquery to assign ranks based on the scores in descending order and then selects only those players with a rank of 1 through 5.", "latency_sec": 3.625131130218506, "total_duration_sec": 3.619448753, "load_duration_sec": 0.021996415, "tokens_prompt": 191, "prompt_eval_sec": 0.045565283, "tokens_completion": 145, "completion_eval_sec": 3.549732644, "tokens_total": 336, "tokens_per_sec": 92.6863023517021, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL groups by player_id and tournament_name, then selects the maximum score for each group, ordering by high_score and limiting 5 results. The Generated SQL ranks all rows in historical_tournaments by score and selects the top 5 based on rank. The key differences are: 1) The Reference SQL may return 5 distinct player-tournament pairs with their highest scores, while the Generated SQL could return more than 5 rows if there are ties in scores (due to RANK()). 2) The Generated SQL does not explicitly group by player-tournament pairs, potentially returning multiple entries for the same player in different tournaments with the same score. 3) The Reference SQL's GROUP BY ensures each player-tournament combination is unique, whereas the Generated SQL's ranking approach may include duplicates."}
{"example_id": 2219, "sql_complexity": "window functions", "prompt": "What is the average population of cities with a UNESCO World Heritage designation, ordered by designation date?", "context": "CREATE TABLE cities (name VARCHAR(255), population INT, designation_date DATE); INSERT INTO cities (name, population, designation_date) VALUES ('Paris', 2141000, '1991-09-16'); INSERT INTO cities (name, population, designation_date) VALUES ('Rio de Janeiro', 6727000, '2012-07-01');", "reference_sql": "SELECT AVG(population) FROM (SELECT population, ROW_NUMBER() OVER (ORDER BY designation_date) rn FROM cities WHERE name IN (SELECT name FROM heritagesites)) t WHERE rn % 2 = 1;", "generated_sql": "SELECT AVG(population) AS average_population\nFROM cities\nWHERE designation_date IS NOT NULL\nGROUP BY designation_date\nORDER BY designation_date;", "raw_model_output": "```sql\nSELECT AVG(population) AS average_population\nFROM cities\nWHERE designation_date IS NOT NULL\nGROUP BY designation_date\nORDER BY designation_date;\n``` \n\nNote: The question asks for an average population but ordering by the `designation_date` might not make sense in a single aggregate query since GROUP BY would be needed to calculate averages per date, and typically we don't order groups. However, if the intent is to get the overall average population of cities with UNESCO designation dates:\n\n```sql\nSELECT AVG(population) AS average_population\nFROM cities\nWHERE designation_date IS NOT NULL;\n```\n\nThis will give you the average population without ordering by `designation_date`. If there's a specific requirement for grouping or further aggregation based on date, please clarify.", "latency_sec": 3.866441011428833, "total_duration_sec": 3.859779493, "load_duration_sec": 0.014070145, "tokens_prompt": 180, "prompt_eval_sec": 0.039224671, "tokens_completion": 156, "completion_eval_sec": 3.804209702, "tokens_total": 336, "tokens_per_sec": 86.90162322580788, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates the average of populations from cities in heritagesites, using row numbers to select odd-ranked entries by designation_date. The generated query groups cities by designation_date (with non-null values) and calculates averages per group, which fundamentally changes the result structure and logic. The generated query lacks the heritagesites filter and row-numbering logic, and its grouping alters the aggregation behavior."}
{"example_id": 3786, "sql_complexity": "aggregation", "prompt": "Display the names and average co-owner percentages for all properties in the 'property_coownership' table where the co-owner percentage is greater than 60.", "context": "CREATE TABLE property_coownership (property_id INT, owner VARCHAR(255), percentage INT); INSERT INTO property_coownership (property_id, owner, percentage) VALUES (1, 'Mohammed', 70), (1, 'Fatima', 30), (2, 'Jamal', 65), (2, 'Aisha', 35), (3, 'Ali', 75), (3, 'Khadija', 25);", "reference_sql": "SELECT owner, AVG(percentage) FROM property_coownership WHERE percentage > 60 GROUP BY owner;", "generated_sql": "SELECT \n    owner,\n    AVG(percentage) AS avg_percentage\nFROM \n    property_coownership\nWHERE \n    percentage > 60\nGROUP BY \n    owner;", "raw_model_output": "To display the names of owners who are co-owners with a percentage greater than 60, along with their average co-owner percentage, you can use the following SQL query:\n\n```sql\nSELECT \n    owner,\n    AVG(percentage) AS avg_percentage\nFROM \n    property_coownership\nWHERE \n    percentage > 60\nGROUP BY \n    owner;\n```\n\nThis query selects the `owner` and calculates the average of their `percentage` where the `percentage` is greater than 60. The results are grouped by each unique `owner`.", "latency_sec": 2.9212958812713623, "total_duration_sec": 2.91584647, "load_duration_sec": 0.027005324, "tokens_prompt": 200, "prompt_eval_sec": 0.04669488, "tokens_completion": 116, "completion_eval_sec": 2.839929608, "tokens_total": 316, "tokens_per_sec": 108.17117226156333, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the 'owner' and average 'percentage' from the property_coownership table where percentage > 60, grouping by owner. The only difference is the column alias (AVG(percentage) vs. AVG(percentage) AS avg_percentage), which does not affect the semantic result."}
{"example_id": 2357, "sql_complexity": "basic SQL", "prompt": "What is the total amount of climate finance invested in renewable energy projects by public and private sectors in Africa?", "context": "CREATE TABLE renewable_energy_projects (project_id INT, sector TEXT, investor_type TEXT, region TEXT, amount FLOAT); INSERT INTO renewable_energy_projects (project_id, sector, investor_type, region, amount) VALUES (1, 'Renewable Energy', 'Public', 'Africa', 5000000); INSERT INTO renewable_energy_projects (project_id, sector, investor_type, region, amount) VALUES (2, 'Renewable Energy', 'Private', 'Africa', 7000000);", "reference_sql": "SELECT SUM(amount) FROM renewable_energy_projects WHERE sector = 'Renewable Energy' AND region = 'Africa';", "generated_sql": "SELECT SUM(amount) AS total_investment\nFROM renewable_energy_projects\nWHERE sector = 'Renewable Energy' AND region = 'Africa';", "raw_model_output": "```sql\nSELECT SUM(amount) AS total_investment\nFROM renewable_energy_projects\nWHERE sector = 'Renewable Energy' AND region = 'Africa';\n```", "latency_sec": 0.9197900295257568, "total_duration_sec": 0.914688745, "load_duration_sec": 0.023727021, "tokens_prompt": 199, "prompt_eval_sec": 0.047112641, "tokens_completion": 34, "completion_eval_sec": 0.841686928, "tokens_total": 233, "tokens_per_sec": 253.31868417853437, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of 'amount' for projects in the 'Renewable Energy' sector located in 'Africa'. The only difference is that the generated query adds an alias ('total_investment') to the aggregated column. This does not affect the semantic result, as the value being summed remains the same."}
{"example_id": 1009, "sql_complexity": "multiple_joins", "prompt": "Find the number of IoT sensors installed in each farm that use Sprinkler irrigation.", "context": "CREATE TABLE IoT_Sensors (id INT, sensor_type VARCHAR(50), Farm_id INT); INSERT INTO IoT_Sensors (id, sensor_type, Farm_id) VALUES (1, 'Soil Moisture', 1), (2, 'Temperature', 1), (3, 'Humidity', 2); CREATE TABLE Irrigation (id INT, Farm_id INT, irrigation_type VARCHAR(50), duration INT); INSERT INTO Irrigation (id, Farm_id, irrigation_type, duration) VALUES (1, 1, 'Sprinkler', 30), (2, 2, 'Drip', 45);", "reference_sql": "SELECT f.id, COUNT(s.id) FROM Farmers f JOIN Irrigation i ON f.id = i.Farm_id JOIN IoT_Sensors s ON f.id = s.Farm_id WHERE i.irrigation_type = 'Sprinkler' GROUP BY f.id;", "generated_sql": "SELECT \n    i.Farm_id, \n    COUNT(i.id) AS sensor_count\nFROM \n    IoT_Sensors i\nJOIN \n    Irrigation ir\nON \n    i.Farm_id = ir.Farm_id\nWHERE \n    ir.irrigation_type = 'Sprinkler'\nGROUP BY \n    i.Farm_id;", "raw_model_output": "To find the number of IoT sensors installed in each farm that uses Sprinkler irrigation, you can join the `IoT_Sensors` and `Irrigation` tables on the `Farm_id`, filter for the `irrigation_type` 'Sprinkler', and then group by `Farm_id` to count the number of sensors.\n\nHere is the SQL query:\n\n```sql\nSELECT \n    i.Farm_id, \n    COUNT(i.id) AS sensor_count\nFROM \n    IoT_Sensors i\nJOIN \n    Irrigation ir\nON \n    i.Farm_id = ir.Farm_id\nWHERE \n    ir.irrigation_type = 'Sprinkler'\nGROUP BY \n    i.Farm_id;\n```", "latency_sec": 3.7588701248168945, "total_duration_sec": 3.754232014, "load_duration_sec": 0.023951368, "tokens_prompt": 219, "prompt_eval_sec": 0.046866771, "tokens_completion": 150, "completion_eval_sec": 3.681161695, "tokens_total": 369, "tokens_per_sec": 98.16779716962822, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL joins with the Farmers table, ensuring only valid Farm_id values (from Farmers) are considered. The Generated SQL directly joins IoT_Sensors and Irrigation, which could include Farm_id values not present in the Farmers table. This difference in join logic may lead to different results when Farm_id values in Irrigation or IoT_Sensors do not exist in Farmers."}
{"example_id": 4217, "sql_complexity": "subqueries", "prompt": "Show consumer preference data for foundations, excluding products from the USA.", "context": "CREATE TABLE cosmetics (product_id INT, product_name VARCHAR(100), product_type VARCHAR(50), is_cruelty_free BOOLEAN, consumer_preference_score INT); INSERT INTO cosmetics (product_id, product_name, product_type, is_cruelty_free, consumer_preference_score) VALUES (1, 'Lipstick A', 'Lipstick', TRUE, 80), (2, 'Foundation B', 'Foundation', FALSE, 90), (3, 'Mascara C', 'Mascara', TRUE, 85), (4, 'Eyeshadow D', 'Eyeshadow', TRUE, 70), (5, 'Blush E', 'Blush', FALSE, 95); CREATE TABLE ingredient_sourcing (ingredient_id INT, ingredient_name VARCHAR(100), sourcing_country VARCHAR(50), is_organic BOOLEAN); INSERT INTO ingredient_sourcing (ingredient_id, ingredient_name, sourcing_country, is_organic) VALUES (1, 'Rosehip Oil', 'Chile', TRUE), (2, 'Shea Butter', 'Ghana', TRUE), (3, 'Jojoba Oil', 'India', TRUE), (4, 'Coconut Oil', 'Philippines', FALSE), (5, 'Aloe Vera', 'USA', TRUE);", "reference_sql": "SELECT * FROM cosmetics WHERE product_type = 'Foundation' AND product_id NOT IN (SELECT cosmetics.product_id FROM cosmetics INNER JOIN ingredient_sourcing ON cosmetics.product_id = ingredient_sourcing.ingredient_id WHERE ingredient_sourcing.sourcing_country = 'USA');", "generated_sql": "SELECT c.product_id, c.product_name, c.consumer_preference_score\nFROM cosmetics AS c\nJOIN ingredient_sourcing AS i ON i.ingredient_id = c.product_id  -- Assuming a direct join condition based on product_id and ingredient_id for simplicity.\nWHERE c.product_type = 'Foundation' AND NOT EXISTS (\n    SELECT 1 FROM ingredient_sourcing WHERE sourcing_country = 'USA' AND ingredient_id = c.product_id\n);", "raw_model_output": "To show consumer preference data for foundations while excluding products that contain ingredients sourced from the USA, we need to join the `cosmetics` and `ingredient_sourcing` tables based on a common relationship (e.g., an ingredient used in the foundation). However, since there is no direct foreign key linking these two tables, let's assume that each cosmetic product has a list of ingredients associated with it. For simplicity, we'll consider only one ingredient per cosmetic for this example.\n\nHere\u2019s how you can write the SQL query:\n\n```sql\nSELECT c.product_id, c.product_name, c.consumer_preference_score\nFROM cosmetics AS c\nJOIN ingredient_sourcing AS i ON i.ingredient_id = c.product_id  -- Assuming a direct join condition based on product_id and ingredient_id for simplicity.\nWHERE c.product_type = 'Foundation' AND NOT EXISTS (\n    SELECT 1 FROM ingredient_sourcing WHERE sourcing_country = 'USA' AND ingredient_id = c.product_id\n);\n```\n\nIf there is no direct relationship between `cosmetics` and `ingredient_sourcing`, you would need to join through an intermediate table that links products with their ingredients. Assuming such a table exists, the query might look like this:\n\n```sql\nSELECT c.product_id, c.product_name, c.consumer_preference_score\nFROM cosmetics AS c\nJOIN product_ingredients AS pi ON c.product_id = pi.product_id  -- Intermediate linking table.\nJOIN ingredient_sourcing AS i ON pi.ingredient_id = i.ingredient_id\nWHERE c.product_type = 'Foundation' AND i.sourcing_country != 'USA';\n```\n\nIn this query, `product_ingredients` is an assumed intermediate table that links products to their ingredients.\n\nIf you have more specific information about the relationship between these tables, please provide it for a more accurate solution.", "latency_sec": 9.14535403251648, "total_duration_sec": 9.136597486, "load_duration_sec": 0.014672016, "tokens_prompt": 356, "prompt_eval_sec": 0.104409824, "tokens_completion": 365, "completion_eval_sec": 9.01403326, "tokens_total": 721, "tokens_per_sec": 78.83784459699109, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects all columns from the cosmetics table, while the Generated SQL selects only specific columns (product_id, product_name, consumer_preference_score). Additionally, the Generated SQL uses a JOIN and NOT EXISTS, which may behave differently in edge cases (e.g., NULL values) compared to the NOT IN clause in the Reference SQL. The filtering logic is similar but not identical due to these differences."}
{"example_id": 5620, "sql_complexity": "basic SQL", "prompt": "What is the recycling rate of plastic in the residential sector in the state of New York?", "context": "CREATE TABLE recycling_rates_city (sector VARCHAR(20), city VARCHAR(20), material VARCHAR(20), recycling_rate DECIMAL(5,2)); INSERT INTO recycling_rates_city (sector, city, material, recycling_rate) VALUES ('residential', 'New York City', 'plastic', 0.25), ('commercial', 'New York City', 'plastic', 0.30), ('residential', 'New York City', 'paper', 0.45), ('commercial', 'New York City', 'paper', 0.50), ('residential', 'Los Angeles', 'plastic', 0.20), ('commercial', 'Los Angeles', 'plastic', 0.35), ('residential', 'Los Angeles', 'paper', 0.40), ('commercial', 'Los Angeles', 'paper', 0.50);", "reference_sql": "SELECT recycling_rate FROM recycling_rates_city WHERE sector = 'residential' AND material = 'plastic' AND city = 'New York City';", "generated_sql": "SELECT recycling_rate \nFROM recycling_rates_city \nWHERE sector = 'residential' AND city = 'New York City' AND material = 'plastic';", "raw_model_output": "```sql\nSELECT recycling_rate \nFROM recycling_rates_city \nWHERE sector = 'residential' AND city = 'New York City' AND material = 'plastic';\n```", "latency_sec": 1.0038647651672363, "total_duration_sec": 0.99597593, "load_duration_sec": 0.024418955, "tokens_prompt": 276, "prompt_eval_sec": 0.060715329, "tokens_completion": 36, "completion_eval_sec": 0.908592592, "tokens_total": 312, "tokens_per_sec": 310.7988354865938, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select the same column from the same table with identical WHERE conditions. The order of conditions in the WHERE clause does not affect the result because logical AND is commutative. Both will return the recycling_rate for 'residential' sector, 'plastic' material, and 'New York City' as per the data."}
{"example_id": 3151, "sql_complexity": "basic SQL", "prompt": "List all biotech startups that received funding in 2022 and their respective funding amounts.", "context": "CREATE TABLE biotech_startups (name TEXT, funding FLOAT, date DATE); INSERT INTO biotech_startups (name, funding, date) VALUES ('StartupA', 3500000, '2022-02-28'); INSERT INTO biotech_startups (name, funding, date) VALUES ('StartupB', 4500000, '2022-07-12');", "reference_sql": "SELECT name, funding FROM biotech_startups WHERE date BETWEEN '2022-01-01' AND '2022-12-31';", "generated_sql": "SELECT name, funding \nFROM biotech_startups \nWHERE date >= '2022-01-01' AND date < '2023-01-01';", "raw_model_output": "```sql\nSELECT name, funding \nFROM biotech_startups \nWHERE date >= '2022-01-01' AND date < '2023-01-01';\n```", "latency_sec": 1.1949889659881592, "total_duration_sec": 1.189810204, "load_duration_sec": 0.024251054, "tokens_prompt": 183, "prompt_eval_sec": 0.044218916, "tokens_completion": 46, "completion_eval_sec": 1.117603346, "tokens_total": 229, "tokens_per_sec": 191.6335686084227, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select startups with dates in 2022. The reference uses BETWEEN '2022-01-01' AND '2022-12-31' (inclusive), while the generated query uses date >= '2022-01-01' AND date < '2023-01-01'. Since the date column is of DATE type (no time component), both conditions cover the same range of dates."}
{"example_id": 2136, "sql_complexity": "window functions", "prompt": "What is the total military equipment sales revenue for each sales representative by fiscal year?", "context": "CREATE TABLE SalesReps (SalesRepID INT, SalesRepName VARCHAR(50), FiscalYear INT, Revenue DECIMAL(10,2)); INSERT INTO SalesReps (SalesRepID, SalesRepName, FiscalYear, Revenue) VALUES (1, 'John Doe', 2020, 150000.00), (2, 'Jane Smith', 2020, 200000.00), (1, 'John Doe', 2021, 180000.00), (2, 'Jane Smith', 2021, 250000.00);", "reference_sql": "SELECT SalesRepName, FiscalYear, SUM(Revenue) OVER (PARTITION BY SalesRepName ORDER BY FiscalYear) AS TotalRevenue FROM SalesReps;", "generated_sql": "SELECT SalesRepID, SalesRepName, FiscalYear, SUM(Revenue) AS TotalRevenue\nFROM SalesReps\nGROUP BY SalesRepID, SalesRepName, FiscalYear\nORDER BY SalesRepID, FiscalYear;", "raw_model_output": "The provided context and question suggest that we need to calculate the total revenue for each sales representative in each fiscal year. Given the schema, here's the corresponding SQL query:\n\n```sql\nSELECT SalesRepID, SalesRepName, FiscalYear, SUM(Revenue) AS TotalRevenue\nFROM SalesReps\nGROUP BY SalesRepID, SalesRepName, FiscalYear\nORDER BY SalesRepID, FiscalYear;\n```\n\nThis query groups the data by `SalesRepID`, `SalesRepName`, and `FiscalYear` to calculate the total revenue for each sales representative in each fiscal year.", "latency_sec": 3.109952926635742, "total_duration_sec": 3.103005707, "load_duration_sec": 0.014119493, "tokens_prompt": 233, "prompt_eval_sec": 0.05613214, "tokens_completion": 123, "completion_eval_sec": 3.029499624, "tokens_total": 356, "tokens_per_sec": 114.4711860269572, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL uses a window function to calculate a running total of Revenue per SalesRepName across FiscalYears, while the Generated SQL aggregates Revenue by unique SalesRepID/FiscalYear combinations. The Reference query returns cumulative sums with partitioning, whereas the Generated query returns individual year totals without ordering or windowing. Additionally, the selected columns differ (SalesRepID is missing in Reference, SalesRepName/FiscalYear are missing in Generated)."}
{"example_id": 5452, "sql_complexity": "basic SQL", "prompt": "What is the name of the farms with a size greater than 150 acres located in 'Texas'?", "context": "CREATE TABLE farms (id INT PRIMARY KEY, name VARCHAR(50), size INT, location VARCHAR(50)); INSERT INTO farms (id, name, size, location) VALUES (1, 'Smith Farms', 200, 'Texas'), (2, 'Johnson Farms', 100, 'California');", "reference_sql": "SELECT name FROM farms WHERE size > 150 AND location = 'Texas'", "generated_sql": "SELECT name FROM farms WHERE size > 150 AND location = 'Texas';", "raw_model_output": "```sql\nSELECT name FROM farms WHERE size > 150 AND location = 'Texas';\n```", "latency_sec": 0.6039879322052002, "total_duration_sec": 0.598545265, "load_duration_sec": 0.026899558, "tokens_prompt": 159, "prompt_eval_sec": 0.033306158, "tokens_completion": 22, "completion_eval_sec": 0.536306289, "tokens_total": 181, "tokens_per_sec": 299.67486161380236, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and conditions. Both select the 'name' column from the 'farms' table where 'size' is greater than 150 and 'location' is 'Texas'. The whitespace differences (e.g., trailing semicolon) do not affect semantic equivalence."}
{"example_id": 5152, "sql_complexity": "aggregation", "prompt": "How many international tourists visited Portugal in 2020, broken down by continent?", "context": "CREATE TABLE international_tourists(tourist_id INT, country TEXT, arrival_year INT, continent TEXT);INSERT INTO international_tourists (tourist_id, country, arrival_year, continent) VALUES (1, 'Spain', 2020, 'Europe'), (2, 'France', 2020, 'Europe'), (3, 'Brazil', 2020, 'South America'), (4, 'United States', 2020, 'North America'), (5, 'China', 2020, 'Asia');", "reference_sql": "SELECT continent, COUNT(*) FROM international_tourists WHERE arrival_year = 2020 GROUP BY continent;", "generated_sql": "SELECT continent, COUNT(*) AS tourist_count\nFROM international_tourists\nWHERE arrival_year = 2020\nGROUP BY continent;", "raw_model_output": "It seems there is a mistake in the question because \"Portugal\" is not mentioned in the provided data. However, if you want to know how many international tourists visited each country in 2020, broken down by continent, here's the SQL query:\n\n```sql\nSELECT continent, COUNT(*) AS tourist_count\nFROM international_tourists\nWHERE arrival_year = 2020\nGROUP BY continent;\n```\n\nIf you specifically want to count tourists for a particular country like \"Portugal\" (assuming it was mistakenly omitted), and if there were data for Portugal, the query would look something like this:\n\n```sql\nSELECT continent, COUNT(*) AS tourist_count\nFROM international_tourists\nWHERE arrival_year = 2020 AND country = 'Portugal'\nGROUP BY continent;\n```\n\nSince \"Portugal\" is not in your dataset, you can modify the query to count tourists for any other specific country or remove the `country` condition if you want counts by continent without filtering by a particular country.", "latency_sec": 5.2899041175842285, "total_duration_sec": 5.286928132, "load_duration_sec": 0.014971852, "tokens_prompt": 206, "prompt_eval_sec": 0.048428367, "tokens_completion": 212, "completion_eval_sec": 5.220155424, "tokens_total": 418, "tokens_per_sec": 79.01844545925164, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries group tourists by continent, filter for arrival_year = 2020, and count the number of tourists per continent. The generated query adds an alias (tourist_count) to the COUNT(*) column, which doesn't affect the semantic result - the data returned (continent names and counts) remains identical."}
{"example_id": 2477, "sql_complexity": "set operations", "prompt": "What is the carbon price in Europe and Australia for the last quarter of 2020?", "context": "CREATE TABLE CarbonPrices (Country TEXT, Year INT, Quarter INT, CarbonPrice NUMBER); INSERT INTO CarbonPrices (Country, Year, Quarter, CarbonPrice) VALUES ('Europe', 2020, 4, 25), ('Australia', 2020, 4, 15); CREATE TABLE CarbonTaxes (Country TEXT, Year INT, Quarter INT, CarbonPrice NUMBER); INSERT INTO CarbonTaxes (Country, Year, Quarter, CarbonPrice) VALUES ('Europe', 2019, 4, 20), ('Australia', 2019, 4, 10);", "reference_sql": "SELECT Context.Country, Context.CarbonPrice FROM ( SELECT * FROM CarbonPrices WHERE CarbonPrices.Country IN ('Europe', 'Australia') AND CarbonPrices.Year = 2020 AND CarbonPrices.Quarter = 4 UNION SELECT * FROM CarbonTaxes WHERE CarbonTaxes.Country IN ('Europe', 'Australia') AND CarbonTaxes.Year = 2020 AND CarbonTaxes.Quarter = 4 ) AS Context;", "generated_sql": "SELECT Country, CarbonPrice \nFROM CarbonPrices \nWHERE Year = 2020 AND Quarter = 4;", "raw_model_output": "```sql\nSELECT Country, CarbonPrice \nFROM CarbonPrices \nWHERE Year = 2020 AND Quarter = 4;\n```", "latency_sec": 0.7953071594238281, "total_duration_sec": 0.790589355, "load_duration_sec": 0.014269571, "tokens_prompt": 221, "prompt_eval_sec": 0.050702583, "tokens_completion": 29, "completion_eval_sec": 0.72338179, "tokens_total": 250, "tokens_per_sec": 314.34395759886803, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The Reference SQL combines data from CarbonPrices and CarbonTaxes tables with a UNION, but the CarbonTaxes subquery has no matching data (Year=2020 doesn't exist in CarbonTaxes). Thus, the effective result is identical to the Generated SQL, which only queries CarbonPrices for 2020 Q4."}
{"example_id": 4573, "sql_complexity": "subqueries", "prompt": "Find the names of all the indigenous communities in the 'Arctic_Communities' table that have a population size greater than the average population size in the 'Antarctic_Communities' table.", "context": "CREATE TABLE Arctic_Communities (name TEXT, population INTEGER); CREATE TABLE Antarctic_Communities (name TEXT, population INTEGER);", "reference_sql": "SELECT name FROM Arctic_Communities WHERE Arctic_Communities.population > (SELECT AVG(population) FROM Antarctic_Communities)", "generated_sql": "SELECT name FROM Arctic_Communities WHERE population > (SELECT AVG(population) FROM Antarctic_Communities);", "raw_model_output": "```sql\nSELECT name FROM Arctic_Communities WHERE population > (SELECT AVG(population) FROM Antarctic_Communities);\n```", "latency_sec": 0.6542263031005859, "total_duration_sec": 0.645035501, "load_duration_sec": 0.013968328, "tokens_prompt": 132, "prompt_eval_sec": 0.027513687, "tokens_completion": 25, "completion_eval_sec": 0.6012662, "tokens_total": 157, "tokens_per_sec": 239.97812264032677, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select names from Arctic_Communities where population exceeds the average population of Antarctic_Communities. The generated SQL omits the table alias in the WHERE clause, but since the query only references Arctic_Communities, the population column is unambiguous. The subquery and logical condition remain identical, ensuring equivalent results."}
{"example_id": 3596, "sql_complexity": "window functions", "prompt": "What is the total revenue for each game in the \"Gaming\" category?", "context": "CREATE TABLE Games (GameID int, GameName varchar(50), Category varchar(50), Revenue decimal(10,2));", "reference_sql": "SELECT Category, SUM(Revenue) OVER(PARTITION BY Category) as TotalRevenue FROM Games;", "generated_sql": "SELECT GameName, SUM(Revenue) AS TotalRevenue\nFROM Games\nWHERE Category = 'Gaming'\nGROUP BY GameName;", "raw_model_output": "```sql\nSELECT GameName, SUM(Revenue) AS TotalRevenue\nFROM Games\nWHERE Category = 'Gaming'\nGROUP BY GameName;\n```", "latency_sec": 0.812981128692627, "total_duration_sec": 0.806955348, "load_duration_sec": 0.014956858, "tokens_prompt": 114, "prompt_eval_sec": 0.025460553, "tokens_completion": 32, "completion_eval_sec": 0.764496548, "tokens_total": 146, "tokens_per_sec": 179.58596435662147, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates total revenue per category using a window function, returning Category and TotalRevenue for all games. The generated query filters to only 'Gaming' category, groups by GameName, and sums revenue per game, resulting in different columns, filtering, and aggregation logic."}
{"example_id": 5039, "sql_complexity": "subqueries", "prompt": "What is the total number of community policing events in 'City Park' in 2021?", "context": "CREATE TABLE locations (id INT, name VARCHAR(255)); CREATE TABLE community_policing (id INT, location_id INT, year INT, events INT); INSERT INTO locations (id, name) VALUES (1, 'City Park'); INSERT INTO community_policing (id, location_id, year, events) VALUES (1, 1, 2021, 5);", "reference_sql": "SELECT SUM(events) FROM community_policing WHERE location_id = (SELECT id FROM locations WHERE name = 'City Park') AND year = 2021;", "generated_sql": "SELECT SUM(events) AS total_events\nFROM community_policing cp\nJOIN locations l ON cp.location_id = l.id\nWHERE l.name = 'City Park' AND cp.year = 2021;", "raw_model_output": "```sql\nSELECT SUM(events) AS total_events\nFROM community_policing cp\nJOIN locations l ON cp.location_id = l.id\nWHERE l.name = 'City Park' AND cp.year = 2021;\n```", "latency_sec": 1.2527718544006348, "total_duration_sec": 1.247375576, "load_duration_sec": 0.025097851, "tokens_prompt": 172, "prompt_eval_sec": 0.033761815, "tokens_completion": 49, "completion_eval_sec": 1.186349439, "tokens_total": 221, "tokens_per_sec": 176.4088163568564, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of 'events' from the community_policing table where the associated location's name is 'City Park' and the year is 2021. The reference query uses a subquery to get the location_id, while the generated query uses a JOIN. Since the subquery in the reference returns a single value (as per the given data) and the JOIN ensures the same filter, both produce identical results."}
{"example_id": 2724, "sql_complexity": "basic SQL", "prompt": "What is the earliest installation date for solar panels in Italy?", "context": "CREATE TABLE solar_panels_italy (id INT, installation_date DATE); INSERT INTO solar_panels_italy (id, installation_date) VALUES (1, '2018-01-01'), (2, '2019-01-01'), (3, '2020-01-01');", "reference_sql": "SELECT MIN(installation_date) as earliest_date FROM solar_panels_italy;", "generated_sql": "SELECT MIN(installation_date) AS earliest_installation_date \nFROM solar_panels_italy;", "raw_model_output": "```sql\nSELECT MIN(installation_date) AS earliest_installation_date \nFROM solar_panels_italy;\n```", "latency_sec": 0.6898989677429199, "total_duration_sec": 0.68269132, "load_duration_sec": 0.013671489, "tokens_prompt": 157, "prompt_eval_sec": 0.033833885, "tokens_completion": 26, "completion_eval_sec": 0.63216591, "tokens_total": 183, "tokens_per_sec": 265.25623106627415, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the minimum installation_date from the same table. The only difference is the column alias name ('earliest_date' vs 'earliest_installation_date'), which does not affect the semantic result set content."}
{"example_id": 2200, "sql_complexity": "single join", "prompt": "Which diversity programs are currently being participated in by employees in the HR department?", "context": "CREATE TABLE Employees (Employee_ID INT, First_Name VARCHAR(20), Last_Name VARCHAR(20), Department VARCHAR(20), Salary DECIMAL(10,2), Date_Hired DATE); CREATE TABLE Diversity_Programs (Program_ID INT, Program_Name VARCHAR(50), Participant_ID INT, Date_Started DATE, Date_Ended DATE);", "reference_sql": "SELECT dp.Program_Name FROM Diversity_Programs dp JOIN Employees e ON dp.Participant_ID = e.Employee_ID WHERE e.Department = 'HR' AND dp.Date_Ended IS NULL;", "generated_sql": "SELECT dp.Program_Name\nFROM Employees e\nJOIN Diversity_Programs dp ON e.Employee_ID = dp.Participant_ID\nWHERE e.Department = 'HR'\n  AND CURRENT_DATE BETWEEN dp.Date_Started AND COALESCE(dp.Date_Ended, CURRENT_DATE);", "raw_model_output": "To determine which diversity programs are currently being participated in by employees in the HR department, we need to join the `Employees` and `Diversity_Programs` tables based on the employee ID. We also need to filter for employees who work in the HR department and whose participation dates overlap with the current date.\n\nHere is the SQL query:\n\n```sql\nSELECT dp.Program_Name\nFROM Employees e\nJOIN Diversity_Programs dp ON e.Employee_ID = dp.Participant_ID\nWHERE e.Department = 'HR'\n  AND CURRENT_DATE BETWEEN dp.Date_Started AND COALESCE(dp.Date_Ended, CURRENT_DATE);\n```\n\nThis query selects the names of diversity programs where employees in the HR department are currently participating. The `COALESCE` function is used to handle cases where a program has not ended yet by considering the current date as its end date.", "latency_sec": 4.2617480754852295, "total_duration_sec": 4.256793448, "load_duration_sec": 0.014910364, "tokens_prompt": 157, "prompt_eval_sec": 0.0336188, "tokens_completion": 173, "completion_eval_sec": 4.206150617, "tokens_total": 330, "tokens_per_sec": 77.43301437695311, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference query explicitly requires Date_Ended IS NULL (ongoing programs), while the Generated query uses a date range condition that includes programs with Date_Ended in the future (since COALESCE replaces NULL with CURRENT_DATE, making the condition CURRENT_DATE BETWEEN Date_Started AND CURRENT_DATE). This makes the Generated query more inclusive, potentially returning additional rows where Date_Ended is not NULL but falls in the future."}
{"example_id": 4359, "sql_complexity": "window functions", "prompt": "Which destinations have the least hotel awards?", "context": "CREATE TABLE Destinations (destination_id INT, destination_name TEXT, country TEXT, awards INT); INSERT INTO Destinations (destination_id, destination_name, country, awards) VALUES (1, 'City A', 'Germany', 3), (2, 'City B', 'Switzerland', 5), (3, 'City C', 'Norway', 2);", "reference_sql": "SELECT destination_name, country, awards, RANK() OVER (PARTITION BY country ORDER BY awards ASC) AS rank FROM Destinations;", "generated_sql": "SELECT destination_name \nFROM Destinations \nWHERE awards = (SELECT MIN(awards) FROM Destinations);", "raw_model_output": "To find which destinations have the least number of hotel awards, you can use a query that identifies the minimum value in the `awards` column and then selects all rows where the `awards` column matches this minimum value. Here is the corresponding SQL statement:\n\n```sql\nSELECT destination_name \nFROM Destinations \nWHERE awards = (SELECT MIN(awards) FROM Destinations);\n```\n\nThis query will return the names of destinations that have the least number of hotel awards.", "latency_sec": 2.4259400367736816, "total_duration_sec": 2.417874001, "load_duration_sec": 0.013990079, "tokens_prompt": 153, "prompt_eval_sec": 0.03444828, "tokens_completion": 98, "completion_eval_sec": 2.367138819, "tokens_total": 251, "tokens_per_sec": 103.46504703134013, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates ranks within each country based on awards, returning all destinations with their respective ranks. The Generated SQL selects only destinations with the absolute minimum awards in the entire table. They differ in both output structure (ranked vs. filtered) and logic (partitioned ranking vs. global minimum comparison)."}
{"example_id": 1373, "sql_complexity": "subqueries", "prompt": "What is the total value of military equipment sales to Africa in the last 12 months?", "context": "CREATE TABLE Military_Equipment_Sales(sale_id INT, sale_date DATE, equipment_type VARCHAR(50), country VARCHAR(50), sale_value DECIMAL(10,2));", "reference_sql": "SELECT SUM(sale_value) FROM Military_Equipment_Sales WHERE country IN (SELECT country FROM World_Countries WHERE continent = 'Africa') AND sale_date >= DATE_SUB(CURRENT_DATE, INTERVAL 12 MONTH);", "generated_sql": "SELECT SUM(sale_value) AS total_sale_value\nFROM Military_Equipment_Sales\nWHERE country IN ('Egypt', 'Algeria', 'Nigeria', 'South Africa', 'Morocco') -- Assuming these are African countries relevant to the sales data\n  AND sale_date >= DATEADD(month, -12, CURRENT_DATE);", "raw_model_output": "```sql\nSELECT SUM(sale_value) AS total_sale_value\nFROM Military_Equipment_Sales\nWHERE country IN ('Egypt', 'Algeria', 'Nigeria', 'South Africa', 'Morocco') -- Assuming these are African countries relevant to the sales data\n  AND sale_date >= DATEADD(month, -12, CURRENT_DATE);\n```\n\nNote: The `DATEADD` function used here is specific to some SQL dialects (like T-SQL). For ANSI standard SQL, you can use:\n\n```sql\nSELECT SUM(sale_value) AS total_sale_value\nFROM Military_Equipment_Sales\nWHERE country IN ('Egypt', 'Algeria', 'Nigeria', 'South Africa', 'Morocco') -- Assuming these are African countries relevant to the sales data\n  AND sale_date >= CURRENT_DATE - INTERVAL '12 MONTH';\n```", "latency_sec": 4.355956792831421, "total_duration_sec": 4.350936224, "load_duration_sec": 0.014797584, "tokens_prompt": 127, "prompt_eval_sec": 0.027487128, "tokens_completion": 178, "completion_eval_sec": 4.306567538, "tokens_total": 305, "tokens_per_sec": 70.0190599920406, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query uses a subquery to dynamically select all countries in Africa from the World_Countries table, while the generated query hardcodes a specific list of African countries. Unless the hardcoded list exactly matches the countries returned by the subquery, the results will differ. Additionally, the generated query includes a comment that implies assumptions about the data not present in the original query."}
{"example_id": 904, "sql_complexity": "basic SQL", "prompt": "What is the minimum Shariah-compliant loan amount issued in the last quarter of 2021?", "context": "CREATE TABLE loans (id INT, amount DECIMAL, date DATE, loan_type VARCHAR); INSERT INTO loans (id, amount, date, loan_type) VALUES (1, 5000, '2021-09-05', 'Shariah-compliant'), (2, 7000, '2021-10-07', 'socially responsible'), (3, 9000, '2021-11-03', 'Shariah-compliant'), (4, 11000, '2021-12-31', 'Shariah-compliant');", "reference_sql": "SELECT MIN(amount) FROM loans WHERE EXTRACT(YEAR FROM date) = 2021 AND EXTRACT(QUARTER FROM date) = 4 AND loan_type = 'Shariah-compliant';", "generated_sql": "SELECT MIN(amount) AS min_shariah_compliant_loan_amount\nFROM loans\nWHERE loan_type = 'Shariah-compliant' AND date >= '2021-10-01' AND date <= '2021-12-31';", "raw_model_output": "```sql\nSELECT MIN(amount) AS min_shariah_compliant_loan_amount\nFROM loans\nWHERE loan_type = 'Shariah-compliant' AND date >= '2021-10-01' AND date <= '2021-12-31';\n```", "latency_sec": 1.6299986839294434, "total_duration_sec": 1.62357915, "load_duration_sec": 0.013325726, "tokens_prompt": 234, "prompt_eval_sec": 0.053730883, "tokens_completion": 63, "completion_eval_sec": 1.554365466, "tokens_total": 297, "tokens_per_sec": 182.20873607334522, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter loans with 'Shariah-compliant' type and dates in the fourth quarter of 2021. The Reference SQL uses EXTRACT(QUARTER) = 4, which corresponds to October-December, while the Generated SQL uses date range conditions (>= '2021-10-01' and <= '2021-12-31') that achieve the same result. Both correctly exclude the 2021-09-05 loan and return the minimum amount (9000) from the Q4 loans."}
{"example_id": 3299, "sql_complexity": "set operations", "prompt": "How many schools and hospitals are there in Colombia and which ones need repairs?", "context": "CREATE TABLE schools (id INT, country VARCHAR(20), name VARCHAR(50), needs_repair BOOLEAN); CREATE TABLE hospitals (id INT, country VARCHAR(20), name VARCHAR(50), needs_repair BOOLEAN);", "reference_sql": "SELECT 'Schools' as facility_type, COUNT(*) as total, SUM(needs_repair) as repairs_needed FROM schools WHERE country = 'Colombia' UNION ALL SELECT 'Hospitals' as facility_type, COUNT(*) as total, SUM(needs_repair) as repairs_needed FROM hospitals WHERE country = 'Colombia';", "generated_sql": "SELECT \n    SUM(CASE WHEN table_name = 'schools' THEN 1 ELSE 0 END) AS school_count,\n    SUM(CASE WHEN table_name = 'hospitals' THEN 1 ELSE 0 END) AS hospital_count,\n    GROUP_CONCAT(DISTINCT CASE WHEN table_name = 'schools' AND needs_repair THEN CONCAT(table_name, ': ', name) END SEPARATOR '; ') AS schools_needing_repairs,\n    GROUP_CONCAT(DISTINCT CASE WHEN table_name = 'hospitals' AND needs_repair THEN CONCAT(table_name, ': ', name) END SEPARATOR '; ') AS hospitals_needing_repairs\nFROM (\n    SELECT 'schools' AS table_name, id, country, name, needs_repair FROM schools WHERE country = 'Colombia'\n    UNION ALL\n    SELECT 'hospitals', id, country, name, needs_repair FROM hospitals WHERE country = 'Colombia'\n) AS facilities\nWHERE needs_repair;", "raw_model_output": "```sql\nSELECT \n    SUM(CASE WHEN table_name = 'schools' THEN 1 ELSE 0 END) AS school_count,\n    SUM(CASE WHEN table_name = 'hospitals' THEN 1 ELSE 0 END) AS hospital_count,\n    GROUP_CONCAT(DISTINCT CASE WHEN table_name = 'schools' AND needs_repair THEN CONCAT(table_name, ': ', name) END SEPARATOR '; ') AS schools_needing_repairs,\n    GROUP_CONCAT(DISTINCT CASE WHEN table_name = 'hospitals' AND needs_repair THEN CONCAT(table_name, ': ', name) END SEPARATOR '; ') AS hospitals_needing_repairs\nFROM (\n    SELECT 'schools' AS table_name, id, country, name, needs_repair FROM schools WHERE country = 'Colombia'\n    UNION ALL\n    SELECT 'hospitals', id, country, name, needs_repair FROM hospitals WHERE country = 'Colombia'\n) AS facilities\nWHERE needs_repair;\n```", "latency_sec": 5.050565958023071, "total_duration_sec": 5.041229538, "load_duration_sec": 0.016432673, "tokens_prompt": 132, "prompt_eval_sec": 0.027168584, "tokens_completion": 206, "completion_eval_sec": 4.995633003, "tokens_total": 338, "tokens_per_sec": 66.92319292713532, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL returns two rows (Schools/Hospitals) with aggregated counts/sums per facility type, while the Generated SQL returns a single row with combined counts and concatenated lists of facilities needing repairs. The Generated SQL also includes detailed facility names in text format, whereas the Reference SQL only provides summary statistics. The output structure and data granularity differ significantly."}
{"example_id": 907, "sql_complexity": "set operations", "prompt": "What is the total quantity of items with type 'E' or type 'F' in warehouse O and warehouse P?", "context": "CREATE TABLE warehouse_o(item_id INT, item_type VARCHAR(10), quantity INT);CREATE TABLE warehouse_p(item_id INT, item_type VARCHAR(10), quantity INT);INSERT INTO warehouse_o(item_id, item_type, quantity) VALUES (1, 'E', 200), (2, 'F', 300), (3, 'E', 50), (4, 'F', 400);INSERT INTO warehouse_p(item_id, item_type, quantity) VALUES (1, 'E', 150), (2, 'F', 250), (3, 'E', 40), (4, 'F', 350);", "reference_sql": "SELECT quantity FROM warehouse_o WHERE item_type IN ('E', 'F') UNION ALL SELECT quantity FROM warehouse_p WHERE item_type IN ('E', 'F');", "generated_sql": "SELECT SUM(quantity) AS total_quantity\nFROM (\n    SELECT quantity FROM warehouse_o WHERE item_type IN ('E', 'F')\n    UNION ALL\n    SELECT quantity FROM warehouse_p WHERE item_type IN ('E', 'F')\n) combined_quantities;", "raw_model_output": "To find the total quantity of items with types 'E' or 'F' in both warehouses O and P, you can use a `UNION ALL` to combine the results from both tables and then sum up the quantities. Here is the corresponding SQL query:\n\n```sql\nSELECT SUM(quantity) AS total_quantity\nFROM (\n    SELECT quantity FROM warehouse_o WHERE item_type IN ('E', 'F')\n    UNION ALL\n    SELECT quantity FROM warehouse_p WHERE item_type IN ('E', 'F')\n) combined_quantities;\n```\n\nThis query first selects the quantities of items with types 'E' or 'F' from both `warehouse_o` and `warehouse_p`, combines them using `UNION ALL`, and then calculates the sum of these quantities.", "latency_sec": 3.8851499557495117, "total_duration_sec": 3.879904395, "load_duration_sec": 0.013991257, "tokens_prompt": 241, "prompt_eval_sec": 0.053746839, "tokens_completion": 155, "completion_eval_sec": 3.809926089, "tokens_total": 396, "tokens_per_sec": 101.92656770274002, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns a list of individual quantities from both tables using UNION ALL, while the Generated SQL aggregates all quantities into a single summed value. The first produces multiple rows of raw data, the second a single summary value. Their result structures and outputs differ fundamentally."}
{"example_id": 1400, "sql_complexity": "single join", "prompt": "What is the maximum co-ownership duration for properties in the neighborhood of 'Chinatown' in San Francisco?'", "context": "CREATE TABLE sf_neighborhoods (neighborhood_id INT, name VARCHAR(255), city VARCHAR(255)); INSERT INTO sf_neighborhoods (neighborhood_id, name, city) VALUES (1, 'Chinatown', 'San Francisco'); CREATE TABLE co_ownership (co_ownership_id INT, property_id INT, co_owner_id INT, start_date DATE, end_date DATE); INSERT INTO co_ownership (co_ownership_id, property_id, co_owner_id, start_date, end_date) VALUES (1, 1, 2, '2010-01-01', '2020-01-01'), (2, 2, 3, '2015-01-01', '2022-01-01'); CREATE TABLE properties (property_id INT, city VARCHAR(255)); INSERT INTO properties (property_id, city) VALUES (1, 'San Francisco'), (2, 'San Francisco');", "reference_sql": "SELECT MAX(DATEDIFF(end_date, start_date)) as max_duration FROM co_ownership JOIN properties ON co_ownership.property_id = properties.property_id WHERE properties.city = 'San Francisco' AND name = 'Chinatown';", "generated_sql": "SELECT MAX(DATEDIFF(co.end_date, co.start_date)) AS max_duration\nFROM co_ownership co\nJOIN properties p ON co.property_id = p.property_id\nJOIN sf_neighborhoods n ON p.city = n.city AND n.name = 'Chinatown';", "raw_model_output": "To find the maximum co-ownership duration for properties in the neighborhood of 'Chinatown' in San Francisco, you need to join multiple tables and calculate the duration between `start_date` and `end_date`. Here is the corresponding SQL query:\n\n```sql\nSELECT MAX(DATEDIFF(co.end_date, co.start_date)) AS max_duration\nFROM co_ownership co\nJOIN properties p ON co.property_id = p.property_id\nJOIN sf_neighborhoods n ON p.city = n.city AND n.name = 'Chinatown';\n```\n\nThis SQL statement calculates the maximum duration of co-ownership in days for properties located in the neighborhood of 'Chinatown' in San Francisco.", "latency_sec": 3.6320252418518066, "total_duration_sec": 3.622185378, "load_duration_sec": 0.020008216, "tokens_prompt": 305, "prompt_eval_sec": 0.067592185, "tokens_completion": 141, "completion_eval_sec": 3.532461092, "tokens_total": 446, "tokens_per_sec": 122.79650341102933, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references 'name' in the WHERE clause, but the 'name' column exists only in sf_neighborhoods, not in the joined tables (co_ownership and properties). The Generated SQL correctly joins with sf_neighborhoods and filters on n.name, making it valid. The Reference SQL would throw an error due to invalid column reference."}
{"example_id": 5248, "sql_complexity": "window functions", "prompt": "Find the top 5 games by rating", "context": "CREATE TABLE games (game_id INT PRIMARY KEY, name VARCHAR(50), genre VARCHAR(50), rating DECIMAL(3,2));", "reference_sql": "SELECT * FROM (SELECT name, rating, ROW_NUMBER() OVER (ORDER BY rating DESC) as rn FROM games) t WHERE rn <= 5;", "generated_sql": "SELECT game_id, name, genre, rating \nFROM games \nORDER BY rating DESC \nLIMIT 5;", "raw_model_output": "```sql\nSELECT game_id, name, genre, rating \nFROM games \nORDER BY rating DESC \nLIMIT 5;\n```", "latency_sec": 0.6869688034057617, "total_duration_sec": 0.679800528, "load_duration_sec": 0.013865952, "tokens_prompt": 108, "prompt_eval_sec": 0.023346581, "tokens_completion": 27, "completion_eval_sec": 0.640522981, "tokens_total": 135, "tokens_per_sec": 196.5154739643418, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query returns only 'name', 'rating', and 'rn' columns with a row number, while the generated query returns all columns (game_id, name, genre, rating). Additionally, the reference query uses ROW_NUMBER() for ranking whereas the generated query uses LIMIT 5, which could behave differently with tied ratings but the column mismatch alone makes them non-equivalent."}
{"example_id": 778, "sql_complexity": "single join", "prompt": "What is the maximum property price in wheelchair-accessible neighborhoods in Singapore?", "context": "CREATE TABLE Singapore_Neighborhoods (Neighborhood_Name TEXT, Wheelchair_Accessibility BOOLEAN); INSERT INTO Singapore_Neighborhoods (Neighborhood_Name, Wheelchair_Accessibility) VALUES ('Orchard', true), ('Marina Bay', true), ('Chinatown', false), ('Little India', false), ('Bugis', true); CREATE TABLE Singapore_Properties (Neighborhood_Name TEXT, Property_Price INTEGER); INSERT INTO Singapore_Properties (Neighborhood_Name, Property_Price) VALUES ('Orchard', 2000000), ('Marina Bay', 3000000), ('Chinatown', 1500000), ('Little India', 1200000), ('Bugis', 1800000);", "reference_sql": "SELECT MAX(Singapore_Properties.Property_Price) FROM Singapore_Properties INNER JOIN Singapore_Neighborhoods ON Singapore_Properties.Neighborhood_Name = Singapore_Neighborhoods.Neighborhood_Name WHERE Singapore_Neighborhoods.Wheelchair_Accessibility = true;", "generated_sql": "SELECT MAX(Property_Price) AS Max_Property_Price\nFROM Singapore_Properties SP\nJOIN Singapore_Neighborhoods SN ON SP.Neighborhood_Name = SN.Neighborhood_Name\nWHERE SN.Wheelchair_Accessibility = true;", "raw_model_output": "```sql\nSELECT MAX(Property_Price) AS Max_Property_Price\nFROM Singapore_Properties SP\nJOIN Singapore_Neighborhoods SN ON SP.Neighborhood_Name = SN.Neighborhood_Name\nWHERE SN.Wheelchair_Accessibility = true;\n```", "latency_sec": 1.3656210899353027, "total_duration_sec": 1.362930797, "load_duration_sec": 0.01415777, "tokens_prompt": 252, "prompt_eval_sec": 0.054866674, "tokens_completion": 52, "completion_eval_sec": 1.291649183, "tokens_total": 304, "tokens_per_sec": 222.60933302838947, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the maximum property price from Singapore_Properties joined with Singapore_Neighborhoods on Neighborhood_Name, filtered by Wheelchair_Accessibility = true. The generated query uses table aliases (SP/SN) and an alias for the MAX column, but these syntactic variations do not affect the semantic result."}
{"example_id": 3859, "sql_complexity": "aggregation", "prompt": "What is the total number of mental health parity violations by month and year?", "context": "CREATE TABLE mental_health_parity_reports (report_id INT, violation_date DATE); INSERT INTO mental_health_parity_reports (report_id, violation_date) VALUES (1, '2022-01-01'), (2, '2022-02-15'), (3, '2022-03-05'), (4, '2022-04-20'), (5, '2021-06-12'), (6, '2021-07-28');", "reference_sql": "SELECT EXTRACT(MONTH FROM violation_date) AS month, EXTRACT(YEAR FROM violation_date) AS year, COUNT(*) FROM mental_health_parity_reports GROUP BY month, year;", "generated_sql": "SELECT \n    EXTRACT(YEAR FROM violation_date) AS year,\n    EXTRACT(MONTH FROM violation_date) AS month,\n    COUNT(*) AS total_violations\nFROM \n    mental_health_parity_reports\nGROUP BY \n    EXTRACT(YEAR FROM violation_date), \n    EXTRACT(MONTH FROM violation_date)\nORDER BY \n    year, month;", "raw_model_output": "To get the total number of mental health parity violations by month and year, you can use the `EXTRACT` function to extract the year and month from the `violation_date`, and then group by these extracted values. Here is the corresponding SQL query:\n\n```sql\nSELECT \n    EXTRACT(YEAR FROM violation_date) AS year,\n    EXTRACT(MONTH FROM violation_date) AS month,\n    COUNT(*) AS total_violations\nFROM \n    mental_health_parity_reports\nGROUP BY \n    EXTRACT(YEAR FROM violation_date), \n    EXTRACT(MONTH FROM violation_date)\nORDER BY \n    year, month;\n```", "latency_sec": 3.319922924041748, "total_duration_sec": 3.316703225, "load_duration_sec": 0.015980629, "tokens_prompt": 205, "prompt_eval_sec": 0.050683802, "tokens_completion": 133, "completion_eval_sec": 3.247297567, "tokens_total": 338, "tokens_per_sec": 101.8095924915363, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries group by the same expressions (year and month) and select the same aggregated data. The order of columns in the SELECT list does not affect semantic equivalence. The Generated SQL includes an ORDER BY clause, but this only affects the result's ordering (not its content), which is not part of semantic equivalence. The GROUP BY in the Reference SQL uses aliases, but in practice, the grouping logic is equivalent to the Generated SQL's explicit expressions."}
{"example_id": 3551, "sql_complexity": "multiple_joins", "prompt": "List all artists who have performed in New York and Chicago, along with their highest-earning performance.", "context": "CREATE TABLE artist_events (artist_id INT, event_id INT, earnings DECIMAL(5,2)); CREATE TABLE artists (id INT, name VARCHAR(50)); CREATE TABLE events (id INT, city VARCHAR(20));", "reference_sql": "SELECT artists.name, MAX(artist_events.earnings) FROM artists INNER JOIN artist_events ON artists.id = artist_events.artist_id INNER JOIN events ON artist_events.event_id = events.id WHERE city IN ('New York', 'Chicago') GROUP BY artists.name;", "generated_sql": "WITH artist_events_filtered AS (\n    SELECT a.id AS artist_id, e.city, ae.earnings\n    FROM artists a\n    JOIN artist_events ae ON a.id = ae.artist_id\n    JOIN events e ON ae.event_id = e.id\n    WHERE e.city IN ('New York', 'Chicago')\n),\nartist_max_earnings AS (\n    SELECT artist_id, MAX(earnings) AS max_earning\n    FROM artist_events_filtered\n    GROUP BY artist_id\n)\nSELECT a.name, ame.max_earning, ae.city\nFROM artists a\nJOIN artist_max_earnings ame ON a.id = ame.artist_id\nJOIN artist_events_filtered ae ON a.id = ae.artist_id AND ame.max_earning = ae.earnings;", "raw_model_output": "To list all artists who have performed in both New York and Chicago, along with their highest-earning performance, you can use the following SQL query:\n\n```sql\nWITH artist_events_filtered AS (\n    SELECT a.id AS artist_id, e.city, ae.earnings\n    FROM artists a\n    JOIN artist_events ae ON a.id = ae.artist_id\n    JOIN events e ON ae.event_id = e.id\n    WHERE e.city IN ('New York', 'Chicago')\n),\nartist_max_earnings AS (\n    SELECT artist_id, MAX(earnings) AS max_earning\n    FROM artist_events_filtered\n    GROUP BY artist_id\n)\nSELECT a.name, ame.max_earning, ae.city\nFROM artists a\nJOIN artist_max_earnings ame ON a.id = ame.artist_id\nJOIN artist_events_filtered ae ON a.id = ae.artist_id AND ame.max_earning = ae.earnings;\n```\n\nThis query uses Common Table Expressions (CTEs) to first filter the events in New York and Chicago, then find the maximum earnings for each artist across these cities, and finally join back to get the city where the highest earning occurred along with the artist's name.", "latency_sec": 6.062871932983398, "total_duration_sec": 6.055189692, "load_duration_sec": 0.024489714, "tokens_prompt": 136, "prompt_eval_sec": 0.028875312, "tokens_completion": 248, "completion_eval_sec": 5.999665793, "tokens_total": 384, "tokens_per_sec": 63.33632051684168, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query returns only artist names and their maximum earnings, while the generated query includes an additional 'city' column. Additionally, the generated query may return multiple rows per artist if they have multiple events with the same maximum earnings, whereas the reference query groups by name (which could lead to incorrect aggregation if names are not unique). The output structure and potential result set differences make them non-equivalent."}
{"example_id": 5168, "sql_complexity": "aggregation", "prompt": "Get the number of renewable energy projects in Australia for each project type.", "context": "CREATE TABLE renewable_projects (id INT PRIMARY KEY, project_name VARCHAR(255), project_location VARCHAR(255), project_type VARCHAR(255), capacity_mw FLOAT);", "reference_sql": "SELECT project_type, COUNT(*) FROM renewable_projects WHERE project_location = 'Australia' GROUP BY project_type;", "generated_sql": "SELECT project_type, COUNT(id) AS project_count\nFROM renewable_projects\nWHERE project_location = 'Australia'\nGROUP BY project_type;", "raw_model_output": "```sql\nSELECT project_type, COUNT(id) AS project_count\nFROM renewable_projects\nWHERE project_location = 'Australia'\nGROUP BY project_type;\n```", "latency_sec": 0.8135380744934082, "total_duration_sec": 0.806392999, "load_duration_sec": 0.013826236, "tokens_prompt": 122, "prompt_eval_sec": 0.025623277, "tokens_completion": 32, "completion_eval_sec": 0.764702864, "tokens_total": 154, "tokens_per_sec": 189.2966104824241, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of projects per type in Australia. COUNT(*) and COUNT(id) yield the same result here because the id column is a primary key (non-null). The column alias difference (project_count) doesn't affect semantic equivalence."}
{"example_id": 4916, "sql_complexity": "aggregation", "prompt": "What is the maximum revenue generated from selling Yttrium in India in the past 3 years?", "context": "CREATE TABLE Yttrium_Sales (id INT PRIMARY KEY, year INT, country VARCHAR(20), quantity INT, price PER_KG); INSERT INTO Yttrium_Sales (id, year, country, quantity, price) VALUES (1, 2019, 'India', 120, 40), (2, 2020, 'India', 130, 45), (3, 2021, 'India', 140, 50), (4, 2019, 'China', 150, 35), (5, 2020, 'China', 160, 40), (6, 2021, 'China', 170, 45);", "reference_sql": "SELECT MAX(quantity * price) FROM Yttrium_Sales WHERE country = 'India' GROUP BY year ORDER BY year DESC LIMIT 3;", "generated_sql": "SELECT MAX(quantity * price) AS max_revenue\nFROM Yttrium_Sales\nWHERE country = 'India';", "raw_model_output": "To find the maximum revenue generated from selling yttrium in India over the last three years, you need to calculate the revenue for each year and then determine the highest value. Revenue can be calculated as `quantity * price`.\n\nHere is the corresponding SQL query:\n\n```sql\nSELECT MAX(quantity * price) AS max_revenue\nFROM Yttrium_Sales\nWHERE country = 'India';\n```\n\nThis query calculates the total revenue (`quantity * price`) for each row where the country is India and then finds the maximum value of this calculation.", "latency_sec": 2.868062973022461, "total_duration_sec": 2.862859645, "load_duration_sec": 0.01482214, "tokens_prompt": 267, "prompt_eval_sec": 0.061855285, "tokens_completion": 112, "completion_eval_sec": 2.783838336, "tokens_total": 379, "tokens_per_sec": 132.14493669244547, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL groups by 'year' and returns multiple rows (up to 3) with the maximum quantity*price per year, ordered by year descending. The Generated SQL calculates a single maximum value across all India entries without grouping, resulting in a single row. The absence of GROUP BY and the presence of ORDER BY/LIMIT in the Reference SQL make them non-equivalent."}
{"example_id": 812, "sql_complexity": "multiple_joins", "prompt": "What is the average salary of 'engineer' workers in each factory?", "context": "CREATE TABLE factories (factory_id INT, factory_name VARCHAR(20)); INSERT INTO factories VALUES (1, 'Factory X'), (2, 'Factory Y'), (3, 'Factory Z'); CREATE TABLE roles (role_id INT, role_name VARCHAR(20)); INSERT INTO roles VALUES (1, 'engineer'), (2, 'manager'), (3, 'assistant'); CREATE TABLE workers (worker_id INT, factory_id INT, role_id INT, salary DECIMAL(5,2)); INSERT INTO workers VALUES (1, 1, 1, 50000.00), (2, 1, 2, 70000.00), (3, 2, 1, 55000.00), (4, 2, 3, 40000.00), (5, 3, 1, 60000.00);", "reference_sql": "SELECT f.factory_name, AVG(salary) FROM workers w INNER JOIN factories f ON w.factory_id = f.factory_id INNER JOIN roles r ON w.role_id = r.role_id WHERE r.role_name = 'engineer' GROUP BY f.factory_name;", "generated_sql": "SELECT f.factory_name, AVG(w.salary) AS avg_salary\nFROM workers w\nJOIN factories f ON w.factory_id = f.factory_id\nJOIN roles r ON w.role_id = r.role_id\nWHERE r.role_name = 'engineer'\nGROUP BY f.factory_name;", "raw_model_output": "To find the average salary of 'engineer' workers in each factory, you can use a combination of `JOIN`, `WHERE`, and `GROUP BY` clauses to filter and aggregate the data appropriately. Here's the corresponding SQL query:\n\n```sql\nSELECT f.factory_name, AVG(w.salary) AS avg_salary\nFROM workers w\nJOIN factories f ON w.factory_id = f.factory_id\nJOIN roles r ON w.role_id = r.role_id\nWHERE r.role_name = 'engineer'\nGROUP BY f.factory_name;\n```\n\nThis SQL statement joins the `workers`, `factories`, and `roles` tables, filters for workers with the role of 'engineer', groups by factory name, and calculates the average salary for each group.", "latency_sec": 3.8992371559143066, "total_duration_sec": 3.893983575, "load_duration_sec": 0.012364295, "tokens_prompt": 285, "prompt_eval_sec": 0.063618074, "tokens_completion": 153, "completion_eval_sec": 3.814746245, "tokens_total": 438, "tokens_per_sec": 112.32966410766986, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same data by joining the same tables with identical conditions, filtering for 'engineer' roles, and grouping by factory name. The only difference is the column alias ('avg_salary' vs. implicit name) and explicit table alias usage, which do not affect the semantic result."}
{"example_id": 5784, "sql_complexity": "set operations", "prompt": "List the number of users who have completed a workout of a specific type (e.g. Running) and have a membership status of 'Active'.", "context": "CREATE TABLE workouts (id INT, user_id INT, workout_type VARCHAR(20)); CREATE TABLE members (id INT, name VARCHAR(50), membership_status VARCHAR(20), state VARCHAR(20)); INSERT INTO workouts (id, user_id, workout_type) VALUES (1, 1, 'Running'), (2, 1, 'Cycling'), (3, 2, 'Running'), (4, 3, 'Cycling'), (5, 3, 'Swimming'), (6, 4, 'Running'), (7, 4, 'Swimming'); INSERT INTO members (id, name, membership_status, state) VALUES (1, 'John Doe', 'Active', 'Texas'), (2, 'Jane Doe', 'Inactive', 'California'), (3, 'Bob Smith', 'Active', 'Texas'), (4, 'Alice Johnson', 'Active', 'California');", "reference_sql": "SELECT COUNT(*) FROM (SELECT user_id FROM workouts WHERE workout_type = 'Running' INTERSECT SELECT id FROM members WHERE membership_status = 'Active') AS user_set;", "generated_sql": "SELECT COUNT(DISTINCT w.user_id) AS active_users_count\nFROM workouts w\nJOIN members m ON w.user_id = m.id\nWHERE w.workout_type = 'Running' AND m.membership_status = 'Active';", "raw_model_output": "To list the number of users who have completed a workout of a specific type (e.g., \"Running\") and have a membership status of 'Active', you can use the following SQL query:\n\n```sql\nSELECT COUNT(DISTINCT w.user_id) AS active_users_count\nFROM workouts w\nJOIN members m ON w.user_id = m.id\nWHERE w.workout_type = 'Running' AND m.membership_status = 'Active';\n```\n\nThis query counts distinct user IDs from the `workouts` table where the workout type is \"Running\" and the corresponding member's membership status in the `members` table is \"Active\".", "latency_sec": 3.340574026107788, "total_duration_sec": 3.332385969, "load_duration_sec": 0.019588648, "tokens_prompt": 288, "prompt_eval_sec": 0.067702964, "tokens_completion": 130, "completion_eval_sec": 3.242871563, "tokens_total": 418, "tokens_per_sec": 125.12819555357241, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of active members who have at least one 'Running' workout. The Reference SQL uses INTERSECT to find the intersection of user_ids from workouts and active members, while the Generated SQL joins the tables and counts distinct user_ids. Both approaches ensure each user is counted once, resulting in the same final count."}
{"example_id": 3038, "sql_complexity": "subqueries", "prompt": "What is the total assets of clients who have invested in mutual funds but not in stocks?", "context": "CREATE TABLE clients (client_id INT, name TEXT, age INT, gender TEXT, total_assets DECIMAL(10,2)); INSERT INTO clients VALUES (1, 'John Doe', 35, 'Male', 250000.00), (2, 'Jane Smith', 45, 'Female', 500000.00); CREATE TABLE investments (client_id INT, investment_type TEXT); INSERT INTO investments VALUES (1, 'Stocks'), (1, 'Bonds'), (2, 'Stocks'), (3, 'Mutual Funds');", "reference_sql": "SELECT c.total_assets FROM clients c INNER JOIN investments i ON c.client_id = i.client_id WHERE i.investment_type = 'Mutual Funds' AND c.client_id NOT IN (SELECT client_id FROM investments WHERE investment_type = 'Stocks');", "generated_sql": "SELECT SUM(c.total_assets) AS total_assets\nFROM clients c\nJOIN investments i ON c.client_id = i.client_id\nWHERE i.investment_type = 'Mutual Funds'\nAND c.client_id NOT IN (\n    SELECT client_id \n    FROM investments \n    WHERE investment_type = 'Stocks'\n);", "raw_model_output": "To find the total assets of clients who have invested in mutual funds but not in stocks, you can use a combination of `JOIN`, `GROUP BY`, and `HAVING` clauses to filter out the relevant clients. Here is the corresponding SQL query:\n\n```sql\nSELECT SUM(c.total_assets) AS total_assets\nFROM clients c\nJOIN investments i ON c.client_id = i.client_id\nWHERE i.investment_type = 'Mutual Funds'\nAND c.client_id NOT IN (\n    SELECT client_id \n    FROM investments \n    WHERE investment_type = 'Stocks'\n);\n```\n\nThis query first identifies the clients who have invested in mutual funds and then excludes those who also have stocks. Finally, it sums up the total assets of the remaining clients.", "latency_sec": 3.8535361289978027, "total_duration_sec": 3.84466235, "load_duration_sec": 0.021504201, "tokens_prompt": 213, "prompt_eval_sec": 0.047957882, "tokens_completion": 154, "completion_eval_sec": 3.773291494, "tokens_total": 367, "tokens_per_sec": 95.2372023291362, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL selects individual client.total_assets values, while the Generated SQL aggregates them using SUM(). The presence of the SUM() function changes the output format from multiple rows to a single summed value, making them semantically different."}
{"example_id": 1078, "sql_complexity": "basic SQL", "prompt": "What is the maximum and minimum temperature difference between any two Arctic research stations?", "context": "CREATE TABLE arctic_stations (id INT, name TEXT, location TEXT, temperature DECIMAL(5,2)); INSERT INTO arctic_stations (id, name, location, temperature) VALUES (1, 'Station A', 'Greenland', 2.3), (2, 'Station B', 'Canada', -5.2);", "reference_sql": "SELECT a.name as station1, b.name as station2, MAX(ABS(a.temperature - b.temperature)) as temp_diff FROM arctic_stations a, arctic_stations b ORDER BY temp_diff DESC LIMIT 1", "generated_sql": "SELECT MAX(temp_diff) AS max_temp_diff, MIN(temp_diff) AS min_temp_diff\nFROM (\n    SELECT \n        s1.temperature - s2.temperature AS temp_diff\n    FROM arctic_stations s1\n    JOIN arctic_stations s2 ON s1.id != s2.id\n) AS temperature_differences;", "raw_model_output": "To find the maximum and minimum temperature difference between any two Arctic research stations, you can use a self-join on the `arctic_stations` table to compare temperatures of different stations. Here's how you can write the SQL query:\n\n```sql\nSELECT MAX(temp_diff) AS max_temp_diff, MIN(temp_diff) AS min_temp_diff\nFROM (\n    SELECT \n        s1.temperature - s2.temperature AS temp_diff\n    FROM arctic_stations s1\n    JOIN arctic_stations s2 ON s1.id != s2.id\n) AS temperature_differences;\n```\n\nThis query calculates the temperature difference between every pair of stations and then finds the maximum and minimum differences.", "latency_sec": 3.497081995010376, "total_duration_sec": 3.490045679, "load_duration_sec": 0.014563241, "tokens_prompt": 155, "prompt_eval_sec": 0.03153293, "tokens_completion": 142, "completion_eval_sec": 3.440816821, "tokens_total": 297, "tokens_per_sec": 84.9279486222395, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in structure and output. The reference query returns the maximum absolute temperature difference between any two stations with their names, while the generated query calculates both max and min temperature differences (without absolute value) and excludes station names. Additionally, the reference query uses a Cartesian product (including same-station pairs) whereas the generated query explicitly excludes them. The generated query's temp_diff is not absolute, leading to different numerical results in general cases."}
{"example_id": 5015, "sql_complexity": "basic SQL", "prompt": "Calculate the average recycling rate", "context": "CREATE TABLE recycling_rates (id INT PRIMARY KEY, location VARCHAR(50), rate FLOAT);", "reference_sql": "SELECT AVG(rate) FROM recycling_rates;", "generated_sql": "SELECT AVG(rate) AS average_recycling_rate FROM recycling_rates;", "raw_model_output": "```sql\nSELECT AVG(rate) AS average_recycling_rate FROM recycling_rates;\n```", "latency_sec": 0.4725069999694824, "total_duration_sec": 0.466637858, "load_duration_sec": 0.013929675, "tokens_prompt": 94, "prompt_eval_sec": 0.021897666, "tokens_completion": 18, "completion_eval_sec": 0.42870569, "tokens_total": 112, "tokens_per_sec": 237.03352544456206, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average of the 'rate' column. The generated query adds an alias ('average_recycling_rate') to the result column, but this does not affect the semantic value of the output. The core computation (AVG(rate)) remains identical."}
{"example_id": 1533, "sql_complexity": "subqueries", "prompt": "Which programs had the highest volunteer participation rate in the last quarter?", "context": "CREATE TABLE Programs (ProgramID INT, ProgramName TEXT, Budget DECIMAL(10,2), NumVolunteers INT); CREATE TABLE VolunteerEvents (EventID INT, ProgramID INT, EventDate DATE, NumVolunteers INT);", "reference_sql": "SELECT p.ProgramName, COUNT(v.EventID) / (SELECT COUNT(*) FROM VolunteerEvents WHERE EventDate >= DATEADD(quarter, -1, GETDATE())) * 100.0 AS VolunteerParticipationRate FROM Programs p INNER JOIN VolunteerEvents v ON p.ProgramID = v.ProgramID WHERE v.EventDate >= DATEADD(quarter, -1, GETDATE()) GROUP BY p.ProgramName ORDER BY VolunteerParticipationRate DESC;", "generated_sql": "WITH LastQuarter AS (\n    SELECT \n        DATE_TRUNC('quarter', CURRENT_DATE) - INTERVAL '3 months' AS start_date,\n        DATE_TRUNC('quarter', CURRENT_DATE) - INTERVAL '1 day' AS end_date\n),\nProgramVolunteers AS (\n    SELECT \n        p.ProgramID, \n        SUM(v.NumVolunteers) AS TotalEventVolunteers\n    FROM \n        Programs p\n    JOIN \n        VolunteerEvents v ON p.ProgramID = v.ProgramID\n    CROSS JOIN \n        LastQuarter lq\n    WHERE \n        v.EventDate BETWEEN lq.start_date AND lq.end_date\n    GROUP BY \n        p.ProgramID\n),\nProgramDetails AS (\n    SELECT \n        p.ProgramID, \n        p.NumVolunteers AS TotalProgramVolunteers,\n        pv.TotalEventVolunteers\n    FROM \n        Programs p\n    LEFT JOIN \n        ProgramVolunteers pv ON p.ProgramID = pv.ProgramID\n)\nSELECT \n    pd.ProgramID, \n    pd.TotalProgramVolunteers, \n    COALESCE(pd.TotalEventVolunteers, 0) AS TotalEventVolunteers,\n    (COALESCE(pd.TotalEventVolunteers, 0) / pd.TotalProgramVolunteers::DECIMAL(10,2)) * 100 AS ParticipationRate\nFROM \n    ProgramDetails pd\nORDER BY \n    ParticipationRate DESC;", "raw_model_output": "To determine which programs had the highest volunteer participation rate in the last quarter, we need to calculate the total number of volunteers involved in events for each program during that period and then compare it against the overall number of volunteers associated with each program. Here's a step-by-step approach:\n\n1. Identify the start and end dates of the last quarter.\n2. Calculate the total number of volunteers participating in events for each program within this period.\n3. Join this information with the `Programs` table to get the total number of volunteers associated with each program.\n4. Compute the participation rate (total event volunteers / total program volunteers).\n5. Rank or filter based on the highest participation rates.\n\nAssuming today's date is used to determine the last quarter, here\u2019s a SQL query that accomplishes this:\n\n```sql\nWITH LastQuarter AS (\n    SELECT \n        DATE_TRUNC('quarter', CURRENT_DATE) - INTERVAL '3 months' AS start_date,\n        DATE_TRUNC('quarter', CURRENT_DATE) - INTERVAL '1 day' AS end_date\n),\nProgramVolunteers AS (\n    SELECT \n        p.ProgramID, \n        SUM(v.NumVolunteers) AS TotalEventVolunteers\n    FROM \n        Programs p\n    JOIN \n        VolunteerEvents v ON p.ProgramID = v.ProgramID\n    CROSS JOIN \n        LastQuarter lq\n    WHERE \n        v.EventDate BETWEEN lq.start_date AND lq.end_date\n    GROUP BY \n        p.ProgramID\n),\nProgramDetails AS (\n    SELECT \n        p.ProgramID, \n        p.NumVolunteers AS TotalProgramVolunteers,\n        pv.TotalEventVolunteers\n    FROM \n        Programs p\n    LEFT JOIN \n        ProgramVolunteers pv ON p.ProgramID = pv.ProgramID\n)\nSELECT \n    pd.ProgramID, \n    pd.TotalProgramVolunteers, \n    COALESCE(pd.TotalEventVolunteers, 0) AS TotalEventVolunteers,\n    (COALESCE(pd.TotalEventVolunteers, 0) / pd.TotalProgramVolunteers::DECIMAL(10,2)) * 100 AS ParticipationRate\nFROM \n    ProgramDetails pd\nORDER BY \n    ParticipationRate DESC;\n```\n\nThis query first calculates the start and end dates of the last quarter. Then it computes the total number of volunteers involved in events for each program during this period. Finally, it joins these results with the `Programs` table to get the overall number of volunteers associated with each program and calculates the participation rate. The result is ordered by the highest participation rates.", "latency_sec": 12.72029995918274, "total_duration_sec": 12.716060015, "load_duration_sec": 0.024616432, "tokens_prompt": 130, "prompt_eval_sec": 0.026634262, "tokens_completion": 519, "completion_eval_sec": 12.662801363, "tokens_total": 649, "tokens_per_sec": 51.02080942136032, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries calculate different metrics. The reference query computes the percentage of program-specific events relative to total events in the last quarter (using COUNT(EventID)), while the generated query calculates the ratio of volunteers engaged in events to the program's total volunteers (using SUM(NumVolunteers) / NumVolunteers). Additionally, the generated query uses a different date calculation method and includes program-specific volunteer counts from the Programs table, which the reference query does not reference."}
{"example_id": 4021, "sql_complexity": "subqueries", "prompt": "What is the percentage of energy efficiency improvement, per sector, compared to 2015 levels?", "context": "CREATE TABLE energy_efficiency (id INT, sector VARCHAR(50), year INT, efficiency FLOAT); INSERT INTO energy_efficiency (id, sector, year, efficiency) VALUES (1, 'Industry', 2015, 100.0), (2, 'Industry', 2020, 105.0), (3, 'Residential', 2015, 100.0), (4, 'Residential', 2020, 103.0);", "reference_sql": "SELECT sector, (SUM(efficiency) / (SELECT SUM(efficiency) FROM energy_efficiency WHERE year = 2015 AND sector = e.sector) * 100.0) - 100.0 AS improvement FROM energy_efficiency e WHERE year = 2020 GROUP BY sector;", "generated_sql": "SELECT \n    e1.sector,\n    ((e2.efficiency - e1.efficiency) / e1.efficiency * 100) AS improvement_percentage\nFROM \n    energy_efficiency e1\nJOIN \n    energy_efficiency e2 ON e1.sector = e2.sector AND e1.year = 2015 AND e2.year = 2020;", "raw_model_output": "To calculate the percentage of energy efficiency improvement for each sector compared to the 2015 level, you can use a self-join on the `energy_efficiency` table. Here is the corresponding SQL query:\n\n```sql\nSELECT \n    e1.sector,\n    ((e2.efficiency - e1.efficiency) / e1.efficiency * 100) AS improvement_percentage\nFROM \n    energy_efficiency e1\nJOIN \n    energy_efficiency e2 ON e1.sector = e2.sector AND e1.year = 2015 AND e2.year = 2020;\n```\n\nThis query calculates the percentage increase in efficiency from 2015 to 2020 for each sector.", "latency_sec": 3.9900410175323486, "total_duration_sec": 3.983335828, "load_duration_sec": 0.014221118, "tokens_prompt": 204, "prompt_eval_sec": 0.04867901, "tokens_completion": 160, "completion_eval_sec": 3.91748094, "tokens_total": 364, "tokens_per_sec": 91.22713235291921, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the percentage improvement in efficiency from 2015 to 2020 per sector. The Reference SQL uses a subquery to get 2015 totals and computes (sum_2020/sum_2015 * 100) - 100. The Generated SQL directly calculates ((e2.efficiency - e1.efficiency)/e1.efficiency * 100) which mathematically simplifies to the same formula. With the given data (one entry per sector/year), both produce identical results."}
{"example_id": 1551, "sql_complexity": "single join", "prompt": "How many unique donors made donations in the healthcare industry in Q3 2022?", "context": "CREATE TABLE donations (id INT, donor_id INT, amount FLOAT, donation_date DATE); INSERT INTO donations (id, donor_id, amount, donation_date) VALUES (1, 7, 100, '2022-07-01'); INSERT INTO donations (id, donor_id, amount, donation_date) VALUES (2, 8, 200, '2022-09-15'); INSERT INTO donors (id, name, industry, first_donation_date DATE) VALUES (7, 'Charlie Davis', 'Healthcare', '2022-07-01'); INSERT INTO donors (id, name, industry, first_donation_date DATE) VALUES (8, 'Dana Wilson', 'Healthcare', '2022-09-15');", "reference_sql": "SELECT COUNT(DISTINCT donor_id) FROM donations d JOIN donors don ON d.donor_id = don.id WHERE industry = 'Healthcare' AND donation_date BETWEEN '2022-07-01' AND '2022-09-30';", "generated_sql": "SELECT COUNT(DISTINCT d.id)\nFROM donations don\nJOIN donors d ON don.donor_id = d.id\nWHERE d.industry = 'Healthcare'\nAND don.donation_date BETWEEN '2022-07-01' AND '2022-09-30';", "raw_model_output": "To determine how many unique donors from the healthcare industry made donations in Q3 (July to September) of 2022, you can use the following SQL query:\n\n```sql\nSELECT COUNT(DISTINCT d.id)\nFROM donations don\nJOIN donors d ON don.donor_id = d.id\nWHERE d.industry = 'Healthcare'\nAND don.donation_date BETWEEN '2022-07-01' AND '2022-09-30';\n```\n\nThis query joins the `donations` and `donors` tables, filters for donors in the healthcare industry who made donations between July 1, 2022, and September 30, 2022, and counts the distinct donor IDs.", "latency_sec": 4.049562931060791, "total_duration_sec": 4.042162621, "load_duration_sec": 0.023876928, "tokens_prompt": 263, "prompt_eval_sec": 0.060240961, "tokens_completion": 160, "completion_eval_sec": 3.955829587, "tokens_total": 423, "tokens_per_sec": 104.45571712332776, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count distinct donor IDs from a join between donations and donors tables, filtered by 'Healthcare' industry and donation dates between 2022-07-01 and 2022-09-30. The differences are purely syntactic (table aliases and column naming in COUNT), but the semantic logic remains identical."}
{"example_id": 2592, "sql_complexity": "window functions", "prompt": "What is the third highest account balance for Shariah-compliant finance customers?", "context": "CREATE TABLE shariah_compliant_finance(customer_id INT, account_balance DECIMAL(10, 2)); INSERT INTO shariah_compliant_finance VALUES (1, 5000), (2, 7000), (3, 6000), (4, 8000), (5, 9000);", "reference_sql": "SELECT account_balance FROM (SELECT account_balance, RANK() OVER (ORDER BY account_balance DESC) as rn FROM shariah_compliant_finance) t WHERE rn = 3;", "generated_sql": "SELECT account_balance\nFROM (\n    SELECT account_balance,\n           DENSE_RANK() OVER (ORDER BY account_balance DESC) AS rank\n    FROM shariah_compliant_finance\n) ranked_accounts\nWHERE rank = 3;", "raw_model_output": "To find the third highest account balance in the `shariah_compliant_finance` table, you can use a subquery with the `DENSE_RANK()` window function or a combination of sorting and limiting rows. Here is an example using both methods:\n\n**Method 1: Using DENSE_RANK()**\n\n```sql\nSELECT account_balance\nFROM (\n    SELECT account_balance,\n           DENSE_RANK() OVER (ORDER BY account_balance DESC) AS rank\n    FROM shariah_compliant_finance\n) ranked_accounts\nWHERE rank = 3;\n```\n\n**Method 2: Without window functions, using LIMIT and ORDER BY**\n\n```sql\nSELECT DISTINCT account_balance\nFROM (\n    SELECT account_balance,\n           (SELECT COUNT(DISTINCT account_balance)\n            FROM shariah_compliant_finance AS sf1\n            WHERE sf1.account_balance >= sf2.account_balance) AS rank\n    FROM shariah_compliant_finance AS sf2\n) ranked_accounts\nWHERE rank = 3;\n```\n\n**Method 3: Using a simpler subquery with LIMIT and OFFSET**\n\n```sql\nSELECT account_balance\nFROM (\n    SELECT DISTINCT account_balance\n    FROM shariah_compliant_finance\n    ORDER BY account_balance DESC\n    LIMIT 1 OFFSET 2\n) ranked_accounts;\n```\n\nThe simplest method is the third one, which uses `LIMIT` and `OFFSET`. Here's the final SQL statement:\n\n```sql\nSELECT account_balance\nFROM (\n    SELECT DISTINCT account_balance\n    FROM shariah_compliant_finance\n    ORDER BY account_balance DESC\n    LIMIT 1 OFFSET 2\n) ranked_accounts;\n```\n\nThis query will return the third highest account balance in the `shariah_compliant_finance` table.", "latency_sec": 9.052979946136475, "total_duration_sec": 9.047873116, "load_duration_sec": 0.013208939, "tokens_prompt": 163, "prompt_eval_sec": 0.035403063, "tokens_completion": 362, "completion_eval_sec": 8.99696814, "tokens_total": 525, "tokens_per_sec": 57.9919543756477, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the account_balance with the 3rd rank when ordered descending. Since all account_balance values are unique in the table, RANK() and DENSE_RANK() produce identical results in this specific case. The third highest balance (7000) will be returned by both queries."}
{"example_id": 3795, "sql_complexity": "single join", "prompt": "What is the total quantity of unsold garments for each manufacturer based in 'Italy' or 'Spain'?", "context": "CREATE TABLE manufacturers (id INT PRIMARY KEY, name VARCHAR(255), country VARCHAR(255)); CREATE TABLE garments (id INT PRIMARY KEY, manufacturer_id INT, quantity_manufactured INT, quantity_sold INT);", "reference_sql": "SELECT m.name, SUM(g.quantity_manufactured - g.quantity_sold) as total_unsold_quantity FROM manufacturers m JOIN garments g ON m.id = g.manufacturer_id WHERE m.country IN ('Italy', 'Spain') GROUP BY m.name;", "generated_sql": "SELECT m.name, SUM(g.quantity_manufactured - g.quantity_sold) AS total_unsold_quantity\nFROM manufacturers m\nJOIN garments g ON m.id = g.manufacturer_id\nWHERE m.country IN ('Italy', 'Spain')\nGROUP BY m.name;", "raw_model_output": "```sql\nSELECT m.name, SUM(g.quantity_manufactured - g.quantity_sold) AS total_unsold_quantity\nFROM manufacturers m\nJOIN garments g ON m.id = g.manufacturer_id\nWHERE m.country IN ('Italy', 'Spain')\nGROUP BY m.name;\n```", "latency_sec": 1.4175231456756592, "total_duration_sec": 1.398798661, "load_duration_sec": 0.014534968, "tokens_prompt": 137, "prompt_eval_sec": 0.028185046, "tokens_completion": 57, "completion_eval_sec": 1.353556844, "tokens_total": 194, "tokens_per_sec": 136.85843549844142, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure, logic, and syntax. They perform the same JOIN operation, apply the same WHERE condition, group by the same column, and calculate the same aggregate expression. The only difference is formatting (whitespace and line breaks), which does not affect semantic equivalence."}
{"example_id": 4138, "sql_complexity": "window functions", "prompt": "How many lifelong learning courses has a student with ID '2' completed, in chronological order?", "context": "CREATE TABLE lifelong_learning (student_id INT, course_id INT, completion_date DATE); INSERT INTO lifelong_learning VALUES (2, 1001, '2015-01-01'), (2, 1002, '2016-01-01');", "reference_sql": "SELECT student_id, course_id, COUNT(course_id) OVER (PARTITION BY student_id ORDER BY completion_date) as completed_courses FROM lifelong_learning WHERE student_id = 2;", "generated_sql": "SELECT COUNT(course_id) AS number_of_courses_completed, completion_date\nFROM lifelong_learning\nWHERE student_id = 2\nORDER BY completion_date;", "raw_model_output": "```sql\nSELECT COUNT(course_id) AS number_of_courses_completed, completion_date\nFROM lifelong_learning\nWHERE student_id = 2\nORDER BY completion_date;\n```", "latency_sec": 0.8871657848358154, "total_duration_sec": 0.88151669, "load_duration_sec": 0.013793196, "tokens_prompt": 152, "prompt_eval_sec": 0.031129727, "tokens_completion": 35, "completion_eval_sec": 0.834358743, "tokens_total": 187, "tokens_per_sec": 210.7836023394516, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses a window function to calculate a running count of courses per student, returning multiple rows with incremental counts. The Generated SQL attempts to aggregate counts but lacks a GROUP BY clause, leading to ambiguous results. Even if executed, it would return a single total count (not per-row) and may not match the structure or values of the Reference SQL's output."}
{"example_id": 312, "sql_complexity": "aggregation", "prompt": "List the top 3 most represented ethnicities in movies produced in the USA.", "context": "CREATE TABLE movies (title VARCHAR(255), production_country VARCHAR(64), lead_actor_ethnicity VARCHAR(64));", "reference_sql": "SELECT lead_actor_ethnicity, COUNT(*) AS count FROM movies WHERE production_country = 'USA' GROUP BY lead_actor_ethnicity ORDER BY count DESC LIMIT 3;", "generated_sql": "SELECT lead_actor_ethnicity, COUNT(*) AS movie_count\nFROM movies\nWHERE production_country = 'USA'\nGROUP BY lead_actor_ethnicity\nORDER BY movie_count DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT lead_actor_ethnicity, COUNT(*) AS movie_count\nFROM movies\nWHERE production_country = 'USA'\nGROUP BY lead_actor_ethnicity\nORDER BY movie_count DESC\nLIMIT 3;\n```", "latency_sec": 1.130652904510498, "total_duration_sec": 1.122528897, "load_duration_sec": 0.015056436, "tokens_prompt": 113, "prompt_eval_sec": 0.02352394, "tokens_completion": 46, "completion_eval_sec": 1.081946504, "tokens_total": 159, "tokens_per_sec": 140.6267116687212, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. The only difference is the column alias name ('count' vs 'movie_count'), which does not affect the result's content or structure. Both queries filter by production_country = 'USA', group by lead_actor_ethnicity, order by count descending, and limit to 3 results."}
{"example_id": 4298, "sql_complexity": "single join", "prompt": "How many users joined the gym in Q1 2023?", "context": "CREATE TABLE memberships (id INT, user_id INT, join_date DATE); INSERT INTO memberships (id, user_id, join_date) VALUES (1, 5, '2023-01-15'), (2, 6, '2023-02-03'), (3, 7, '2023-03-20'), (4, 8, '2022-12-31');", "reference_sql": "SELECT COUNT(*) FROM memberships WHERE join_date BETWEEN '2023-01-01' AND '2023-03-31';", "generated_sql": "SELECT COUNT(*) \nFROM memberships \nWHERE join_date >= '2023-01-01' AND join_date <= '2023-03-31';", "raw_model_output": "```sql\nSELECT COUNT(*) \nFROM memberships \nWHERE join_date >= '2023-01-01' AND join_date <= '2023-03-31';\n```", "latency_sec": 1.12186598777771, "total_duration_sec": 1.116431138, "load_duration_sec": 0.014026168, "tokens_prompt": 184, "prompt_eval_sec": 0.038267574, "tokens_completion": 44, "completion_eval_sec": 1.062059188, "tokens_total": 228, "tokens_per_sec": 203.23283037722027, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter memberships where join_date is between '2023-01-01' and '2023-03-31' inclusive. The BETWEEN operator (reference) and explicit >=/<= conditions (generated) are logically equivalent for this date range. The sample data contains 3 entries within this range."}
{"example_id": 5211, "sql_complexity": "multiple_joins", "prompt": "What is the average transaction value in the last week, split by product category and customer demographics?", "context": "CREATE TABLE transactions (transaction_id INT, customer_id INT, product_id INT, category_id INT, transaction_date DATE, amount DECIMAL(10,2)); CREATE TABLE customers (customer_id INT, age INT, gender VARCHAR(10), location VARCHAR(255)); CREATE TABLE products (product_id INT, name VARCHAR(255), category_id INT);", "reference_sql": "SELECT c.age, c.gender, p.category_id, AVG(t.amount) as avg_transaction_value FROM transactions t INNER JOIN customers c ON t.customer_id = c.customer_id INNER JOIN products p ON t.product_id = p.product_id WHERE t.transaction_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 WEEK) GROUP BY c.age, c.gender, p.category_id;", "generated_sql": "SELECT \n    p.category_id,\n    c.age,\n    c.gender,\n    AVG(t.amount) AS avg_transaction_value\nFROM \n    transactions t\nJOIN \n    customers c ON t.customer_id = c.customer_id\nJOIN \n    products p ON t.product_id = p.product_id\nWHERE \n    t.transaction_date >= CURRENT_DATE - INTERVAL '7 days'\nGROUP BY \n    p.category_id, c.age, c.gender;", "raw_model_output": "To calculate the average transaction value for each product category and customer demographic over the last week, you can use the following SQL query:\n\n```sql\nSELECT \n    p.category_id,\n    c.age,\n    c.gender,\n    AVG(t.amount) AS avg_transaction_value\nFROM \n    transactions t\nJOIN \n    customers c ON t.customer_id = c.customer_id\nJOIN \n    products p ON t.product_id = p.product_id\nWHERE \n    t.transaction_date >= CURRENT_DATE - INTERVAL '7 days'\nGROUP BY \n    p.category_id, c.age, c.gender;\n```\n\nThis query joins the `transactions`, `customers`, and `products` tables to get the necessary data. It filters transactions that occurred in the last week and then groups by product category ID, customer age, and gender to calculate the average transaction amount for each group.", "latency_sec": 4.225276947021484, "total_duration_sec": 4.221443458, "load_duration_sec": 0.013981599, "tokens_prompt": 164, "prompt_eval_sec": 0.033325341, "tokens_completion": 173, "completion_eval_sec": 4.171744464, "tokens_total": 337, "tokens_per_sec": 79.75808549959328, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same data by joining the same tables with identical conditions. The date filter uses equivalent expressions (DATE_SUB(...) vs. CURRENT_DATE - INTERVAL '7 days') to capture transactions from the last week. The SELECT list contains the same columns in different order, and the GROUP BY clause includes identical columns (order doesn't affect grouping semantics). The aggregate function (AVG(amount)) is applied consistently."}
{"example_id": 382, "sql_complexity": "window functions", "prompt": "What is the average annual precipitation in the past 10 years for each weather station?", "context": "CREATE TABLE WeatherStation (ID INT, Name VARCHAR(100), Location VARCHAR(100), Elevation FLOAT, AnnualPrecipitation FLOAT); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (1, 'Station A', 'Arctic Circle', 100, 450); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (2, 'Station B', 'North Pole', 200, 300);", "reference_sql": "SELECT Name, AVG(AnnualPrecipitation) OVER (PARTITION BY Name ORDER BY Name ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS AvgAnnualPrecipitation FROM WeatherStation WHERE YEAR(CurrentDate) - YEAR(DateInstalled) BETWEEN 1 AND 10;", "generated_sql": "SELECT \n    ws.Name,\n    AVG(awd.Precipitation) AS AverageAnnualPrecipitation\nFROM \n    WeatherStation ws\nJOIN \n    AnnualWeatherData awd ON ws.ID = awd.StationID\nWHERE \n    awd.Year >= YEAR(CURRENT_DATE()) - 10\nGROUP BY \n    ws.Name;", "raw_model_output": "The provided schema and data do not include any temporal information or historical records of annual precipitation. Therefore, it's impossible to calculate the \"average annual precipitation in the past 10 years\" based on just this table structure.\n\nHowever, if we assume there is a way to get historical data for each year (e.g., another table `AnnualWeatherData` with columns like `StationID`, `Year`, and `Precipitation`), then you could write an SQL query to calculate the average annual precipitation over the past 10 years.\n\nSince no such additional information or tables are provided, I'll assume a hypothetical scenario where we have this data in another table. Here's how you might structure that query:\n\n```sql\nSELECT \n    ws.Name,\n    AVG(awd.Precipitation) AS AverageAnnualPrecipitation\nFROM \n    WeatherStation ws\nJOIN \n    AnnualWeatherData awd ON ws.ID = awd.StationID\nWHERE \n    awd.Year >= YEAR(CURRENT_DATE()) - 10\nGROUP BY \n    ws.Name;\n```\n\nThis query assumes:\n- `AnnualWeatherData` is a table with columns `StationID`, `Year`, and `Precipitation`.\n- The current date is used to calculate the past 10 years.\n\nIf you have more specific details or additional tables, please provide them so I can refine the SQL statement accordingly.", "latency_sec": 7.128981828689575, "total_duration_sec": 7.121300037, "load_duration_sec": 0.016319938, "tokens_prompt": 202, "prompt_eval_sec": 0.048750359, "tokens_completion": 287, "completion_eval_sec": 7.054209894, "tokens_total": 489, "tokens_per_sec": 68.59324539615025, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL references a non-existent 'DateInstalled' column and uses a window function on WeatherStation.AnnualPrecipitation, while the Generated SQL joins with an undefined AnnualWeatherData table, averages a different 'Precipitation' column, and uses a GROUP BY. The schema inconsistencies and differing logic (window function vs. aggregation) ensure they produce different results."}
{"example_id": 2190, "sql_complexity": "single join", "prompt": "What is the total number of humanitarian assistance events by each country in the last 3 years?", "context": "CREATE TABLE Humanitarian_Assistance (id INT, country VARCHAR(50), year INT, events INT); CREATE TABLE Countries (id INT, name VARCHAR(50), region VARCHAR(50));", "reference_sql": "SELECT co.name, SUM(ha.events) FROM Humanitarian_Assistance ha INNER JOIN Countries co ON ha.country = co.name WHERE ha.year BETWEEN (YEAR(CURRENT_DATE) - 3) AND YEAR(CURRENT_DATE) GROUP BY co.name;", "generated_sql": "SELECT \n    H.country,\n    SUM(H.events) AS total_events\nFROM \n    Humanitarian_Assistance H\nWHERE \n    H.year >= (YEAR(CURRENT_DATE) - 3)\nGROUP BY \n    H.country;", "raw_model_output": "To find the total number of humanitarian assistance events by each country in the last 3 years, you can use the following SQL query:\n\n```sql\nSELECT \n    H.country,\n    SUM(H.events) AS total_events\nFROM \n    Humanitarian_Assistance H\nWHERE \n    H.year >= (YEAR(CURRENT_DATE) - 3)\nGROUP BY \n    H.country;\n```\n\nThis query sums up the `events` for each country where the year is within the last three years from the current date.", "latency_sec": 2.5720362663269043, "total_duration_sec": 2.564503844, "load_duration_sec": 0.023084133, "tokens_prompt": 129, "prompt_eval_sec": 0.027443357, "tokens_completion": 105, "completion_eval_sec": 2.511786583, "tokens_total": 234, "tokens_per_sec": 90.9784994339029, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL joins Humanitarian_Assistance with Countries to group by country names from the Countries table, while the Generated SQL directly groups by the country column in Humanitarian_Assistance without a join. This could lead to different results if there are countries in Humanitarian_Assistance that don't exist in the Countries table (due to the join filter in Reference SQL). Additionally, the Reference SQL uses co.name in the SELECT, whereas the Generated SQL uses H.country, which may not always be equivalent if country names differ between tables."}
{"example_id": 1852, "sql_complexity": "set operations", "prompt": "Compare coal production and employment rates in China and India between 2018 and 2020.", "context": "CREATE TABLE china_coal_production (year INT, production FLOAT); INSERT INTO china_coal_production (year, production) VALUES (2018, 3500.0), (2019, 3600.0), (2020, 3700.0); CREATE TABLE china_employment (year INT, employment FLOAT); INSERT INTO china_employment (year, employment) VALUES (2018, 8000000.0), (2019, 8100000.0), (2020, 8200000.0); CREATE TABLE india_coal_production (year INT, production FLOAT); INSERT INTO india_coal_production (year, production) VALUES (2018, 700.0), (2019, 750.0), (2020, 800.0); CREATE TABLE india_employment (year INT, employment FLOAT); INSERT INTO india_employment (year, employment) VALUES (2018, 1000000.0), (2019, 1050000.0), (2020, 1100000.0);", "reference_sql": "SELECT 'China' AS country, china_coal_production.production, china_employment.employment FROM china_coal_production INNER JOIN china_employment ON china_coal_production.year = china_employment.year WHERE china_coal_production.year BETWEEN 2018 AND 2020 UNION ALL SELECT 'India', india_coal_production.production, india_employment.employment FROM india_coal_production INNER JOIN india_employment ON india_coal_production.year = india_employment.year WHERE india_coal_production.year BETWEEN 2018 AND 2020;", "generated_sql": "SELECT \n    c.year AS year,\n    c.production AS china_production,\n    e.employment AS china_employment,\n    i.production AS india_production,\n    ie.employment AS india_employment\nFROM \n    china_coal_production c\nJOIN \n    china_employment e ON c.year = e.year\nJOIN \n    india_coal_production i ON c.year = i.year\nJOIN \n    india_employment ie ON c.year = ie.year\nWHERE \n    c.year BETWEEN 2018 AND 2020;", "raw_model_output": "To compare the coal production and employment rates in China and India between 2018 and 2020, we can join the relevant tables on the year column and then select the required data. Here is the corresponding SQL query:\n\n```sql\nSELECT \n    c.year AS year,\n    c.production AS china_production,\n    e.employment AS china_employment,\n    i.production AS india_production,\n    ie.employment AS india_employment\nFROM \n    china_coal_production c\nJOIN \n    china_employment e ON c.year = e.year\nJOIN \n    india_coal_production i ON c.year = i.year\nJOIN \n    india_employment ie ON c.year = ie.year\nWHERE \n    c.year BETWEEN 2018 AND 2020;\n```\n\nThis query will provide a comparison of coal production and employment rates for both China and India over the specified years.", "latency_sec": 4.762655019760132, "total_duration_sec": 4.755652906, "load_duration_sec": 0.024121585, "tokens_prompt": 371, "prompt_eval_sec": 0.089295494, "tokens_completion": 187, "completion_eval_sec": 4.639983237, "tokens_total": 558, "tokens_per_sec": 117.16154071308388, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two rows per year (China and India) with separate production/employment values, while the Generated SQL returns one row per year with combined China/India data. The structure and number of rows differ: Reference produces 6 rows (3 years \u00d7 2 countries), while Generated produces 3 rows (1 per year with merged data). The JOIN logic in Generated also combines all four tables into a single row per year, which is fundamentally different from the UNION ALL approach in Reference."}
{"example_id": 2535, "sql_complexity": "subqueries", "prompt": "What is the maximum safety rating for vehicles in the vehiclesafety schema?", "context": "CREATE TABLE VehicleSafety (id INT, vehicle_id INT, safetyrating INT, PRIMARY KEY (id)); CREATE TABLE Vehicles (id INT, make VARCHAR(50), model VARCHAR(50), PRIMARY KEY (id)); CREATE TABLE LuxuryVehicles (id INT, vehicle_id INT, PRIMARY KEY (id), FOREIGN KEY (vehicle_id) REFERENCES Vehicles(id));", "reference_sql": "SELECT MAX(safetyrating) FROM vehicleSafety JOIN Vehicles ON vehicleSafety.vehicle_id = Vehicles.id WHERE EXISTS (SELECT * FROM LuxuryVehicles WHERE Vehicles.id = LuxuryVehicles.vehicle_id);", "generated_sql": "SELECT MAX(safetyrating) AS max_safety_rating\nFROM VehicleSafety;", "raw_model_output": "To find the maximum safety rating for vehicles in the `VehicleSafety` table, you can use the following SQL query:\n\n```sql\nSELECT MAX(safetyrating) AS max_safety_rating\nFROM VehicleSafety;\n```", "latency_sec": 1.1329400539398193, "total_duration_sec": 1.125205113, "load_duration_sec": 0.014334872, "tokens_prompt": 156, "prompt_eval_sec": 0.032060749, "tokens_completion": 45, "completion_eval_sec": 1.076633512, "tokens_total": 201, "tokens_per_sec": 177.41450600234222, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters VehicleSafety records to only those vehicles that exist in LuxuryVehicles (via the EXISTS clause), while the Generated SQL selects the maximum safetyrating from all VehicleSafety records without any filtering. The presence of the LuxuryVehicles constraint in the Reference SQL means it could return a different maximum value than the Generated SQL if there are VehicleSafety records not linked to luxury vehicles."}
{"example_id": 2140, "sql_complexity": "aggregation", "prompt": "What was the total amount of minerals extracted in the 'north' region for each month in 2020?", "context": "CREATE TABLE extraction(id INT, location TEXT, month INT, year INT, minerals_extracted FLOAT);INSERT INTO extraction(id, location, month, year, minerals_extracted) VALUES (1, 'north', 1, 2020, 1500), (2, 'north', 2, 2020, 1800), (3, 'south', 1, 2020, 1200);", "reference_sql": "SELECT month, SUM(minerals_extracted) FROM extraction WHERE location = 'north' AND year = 2020 GROUP BY month;", "generated_sql": "SELECT month, SUM(minerals_extracted) AS total_minerals_extracted\nFROM extraction\nWHERE location = 'north' AND year = 2020\nGROUP BY month;", "raw_model_output": "```sql\nSELECT month, SUM(minerals_extracted) AS total_minerals_extracted\nFROM extraction\nWHERE location = 'north' AND year = 2020\nGROUP BY month;\n```", "latency_sec": 1.109246015548706, "total_duration_sec": 1.10543102, "load_duration_sec": 0.014582335, "tokens_prompt": 192, "prompt_eval_sec": 0.046100166, "tokens_completion": 43, "completion_eval_sec": 1.042623692, "tokens_total": 235, "tokens_per_sec": 211.85561787549315, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. The only difference is the alias 'total_minerals_extracted' in the generated query, which does not affect the result's content. Both queries select the same columns, apply identical filters (location = 'north' and year = 2020), and group by month, producing identical aggregated results."}
{"example_id": 4779, "sql_complexity": "window functions", "prompt": "What is the average CO2 emission for the top 3 highest emitting countries since 2015?", "context": "CREATE TABLE emissions (country VARCHAR(50), year INT, co2_emission INT); INSERT INTO emissions (country, year, co2_emission) VALUES ('USA', 2015, 5373978000); INSERT INTO emissions (country, year, co2_emission) VALUES ('China', 2015, 10498600000); INSERT INTO emissions (country, year, co2_emission) VALUES ('India', 2015, 2633830000); INSERT INTO emissions (country, year, co2_emission) VALUES ('USA', 2016, 5518004000); INSERT INTO emissions (country, year, co2_emission) VALUES ('China', 2016, 10813000000); INSERT INTO emissions (country, year, co2_emission) VALUES ('India', 2016, 2799280000);", "reference_sql": "SELECT AVG(co2_emission) as avg_emission FROM (SELECT country, year, co2_emission, ROW_NUMBER() OVER (ORDER BY co2_emission DESC) as rn FROM emissions WHERE year >= 2015) t WHERE rn <= 3 GROUP BY country;", "generated_sql": "WITH ranked_emissions AS (\n    SELECT \n        country,\n        SUM(co2_emission) AS total_co2_emission\n    FROM \n        emissions\n    WHERE \n        year >= 2015\n    GROUP BY \n        country\n    ORDER BY \n        total_co2_emission DESC\n),\ntop_countries AS (\n    SELECT \n        country, \n        total_co2_emission,\n        ROW_NUMBER() OVER (ORDER BY total_co2_emission DESC) as rank\n    FROM \n        ranked_emissions\n)\nSELECT AVG(total_co2_emission) AS avg_top3_co2_emission\nFROM top_countries\nWHERE rank <= 3;", "raw_model_output": "To find the average CO2 emission for the top 3 highest emitting countries since 2015, you can use a combination of window functions and aggregation. Here's how you can write the query:\n\n```sql\nWITH ranked_emissions AS (\n    SELECT \n        country,\n        SUM(co2_emission) AS total_co2_emission\n    FROM \n        emissions\n    WHERE \n        year >= 2015\n    GROUP BY \n        country\n    ORDER BY \n        total_co2_emission DESC\n),\ntop_countries AS (\n    SELECT \n        country, \n        total_co2_emission,\n        ROW_NUMBER() OVER (ORDER BY total_co2_emission DESC) as rank\n    FROM \n        ranked_emissions\n)\nSELECT AVG(total_co2_emission) AS avg_top3_co2_emission\nFROM top_countries\nWHERE rank <= 3;\n```\n\nThis query first calculates the total CO2 emissions for each country since 2015, ranks them in descending order of their total emissions, and then computes the average of the top 3 countries' total emissions.", "latency_sec": 5.735079288482666, "total_duration_sec": 5.728099128, "load_duration_sec": 0.016076555, "tokens_prompt": 322, "prompt_eval_sec": 0.081990133, "tokens_completion": 228, "completion_eval_sec": 5.627583699, "tokens_total": 550, "tokens_per_sec": 95.9010280999121, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the average of the top 3 individual co2_emission values (per country-year) across all years >=2015, grouping by country. The Generated SQL first aggregates emissions per country (summing all years >=2015), then selects the top 3 countries by total emissions and averages their totals. The two queries operate on different data granularities (individual rows vs. aggregated country totals) and produce different results."}
{"example_id": 1015, "sql_complexity": "subqueries", "prompt": "List the top 3 most expensive eco-friendly products in Europe and their suppliers.", "context": "CREATE TABLE Suppliers (supplierID INT, supplierName VARCHAR(50), country VARCHAR(50)); CREATE TABLE Products (productID INT, productName VARCHAR(50), price DECIMAL(10,2), ecoFriendly BOOLEAN, supplierID INT);", "reference_sql": "SELECT P.productName, P.price, S.supplierName FROM (SELECT * FROM Products WHERE ecoFriendly = TRUE ORDER BY price DESC LIMIT 3) P JOIN Suppliers S ON P.supplierID = S.supplierID;", "generated_sql": "SELECT p.productName, p.price, s.supplierName, s.country\nFROM Products p\nJOIN Suppliers s ON p.supplierID = s.supplierID\nWHERE p.ecoFriendly = TRUE AND s.country IN ('Austria', 'Belgium', 'Bulgaria', 'Croatia', 'Cyprus', 'Czech Republic', 'Denmark', 'Estonia', 'Finland', 'France', 'Germany', 'Greece', 'Hungary', 'Ireland', 'Italy', 'Latvia', 'Lithuania', 'Luxembourg', 'Malta', 'Netherlands', 'Poland', 'Portugal', 'Romania', 'Slovakia', 'Slovenia', 'Spain', 'Sweden')\nORDER BY p.price DESC\nLIMIT 3;", "raw_model_output": "To list the top 3 most expensive eco-friendly products in Europe along with their suppliers, you can use a combination of JOINs, WHERE clauses, and an ORDER BY clause to sort by price. Here is the corresponding SQL query:\n\n```sql\nSELECT p.productName, p.price, s.supplierName, s.country\nFROM Products p\nJOIN Suppliers s ON p.supplierID = s.supplierID\nWHERE p.ecoFriendly = TRUE AND s.country IN ('Austria', 'Belgium', 'Bulgaria', 'Croatia', 'Cyprus', 'Czech Republic', 'Denmark', 'Estonia', 'Finland', 'France', 'Germany', 'Greece', 'Hungary', 'Ireland', 'Italy', 'Latvia', 'Lithuania', 'Luxembourg', 'Malta', 'Netherlands', 'Poland', 'Portugal', 'Romania', 'Slovakia', 'Slovenia', 'Spain', 'Sweden')\nORDER BY p.price DESC\nLIMIT 3;\n```\n\nThis query ensures that only eco-friendly products from European countries are selected and orders them by price in descending order to get the most expensive ones. The `LIMIT 3` clause restricts the result set to just the top three entries.", "latency_sec": 6.4757020473480225, "total_duration_sec": 6.469263775, "load_duration_sec": 0.015630761, "tokens_prompt": 137, "prompt_eval_sec": 0.028060195, "tokens_completion": 266, "completion_eval_sec": 6.423318402, "tokens_total": 403, "tokens_per_sec": 62.23263470947363, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL filters eco-friendly products and limits to top 3 by price before joining with suppliers, while the Generated SQL applies a country filter on suppliers and includes an extra 'country' column. The Generated SQL also performs the join first, which could yield different results due to the additional country condition and column selection."}
{"example_id": 3715, "sql_complexity": "aggregation", "prompt": "What is the average age of engines still in service for each engine type?", "context": "CREATE TABLE Engine (id INT, aircraft_id INT, engine_type VARCHAR(255), hours_since_last_service INT, manufacture_year INT); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (1, 1, 'GE90-115B', 500, 2000); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (2, 2, 'CFM56-5B', 1000, 1995); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (3, 1, 'GE90-115B', 700, 2002);", "reference_sql": "SELECT engine_type, AVG(YEAR(CURRENT_DATE) - manufacture_year) as avg_age FROM Engine GROUP BY engine_type;", "generated_sql": "SELECT \n    engine_type, \n    AVG(2023 - manufacture_year) AS average_age\nFROM \n    Engine\nGROUP BY \n    engine_type;", "raw_model_output": "To find the average age of engines still in service for each engine type, we need to calculate the age of each engine based on its `manufacture_year` and then compute the average age per engine type. Assuming that \"age\" is calculated as the current year minus the manufacture year (and assuming the current year is 2023), here's how you can write the SQL query:\n\n```sql\nSELECT \n    engine_type, \n    AVG(2023 - manufacture_year) AS average_age\nFROM \n    Engine\nGROUP BY \n    engine_type;\n```\n\nThis query calculates the age of each engine by subtracting `manufacture_year` from 2023 and then computes the average age for each distinct `engine_type`.", "latency_sec": 3.8898391723632812, "total_duration_sec": 3.884920046, "load_duration_sec": 0.014688928, "tokens_prompt": 257, "prompt_eval_sec": 0.060506846, "tokens_completion": 155, "completion_eval_sec": 3.80752741, "tokens_total": 412, "tokens_per_sec": 105.91697541821206, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average age of engines by subtracting the manufacture_year from a fixed year. The Reference SQL uses YEAR(CURRENT_DATE) which would evaluate to 2023 (assuming current year is 2023), making it equivalent to the Generated SQL's hardcoded 2023 value. The grouping and aggregation logic are identical."}
{"example_id": 1957, "sql_complexity": "set operations", "prompt": "What is the average temperature recorded for the 'polar_bear' species in the 'Arctic_Animals' table compared to the 'penguin' species in the 'Antarctic_Animals' table?", "context": "CREATE TABLE Arctic_Animals (species TEXT, avg_temp FLOAT); CREATE TABLE Antarctic_Animals (species TEXT, avg_temp FLOAT);", "reference_sql": "SELECT AVG(Arctic_Animals.avg_temp) FROM Arctic_Animals WHERE Arctic_Animals.species = 'polar_bear' INTERSECT SELECT AVG(Antarctic_Animals.avg_temp) FROM Antarctic_Animals WHERE Antarctic_Animals.species = 'penguin'", "generated_sql": "SELECT a.avg_temp AS polar_bear_avg_temp, b.avg_temp AS penguin_avg_temp \nFROM Arctic_Animals a \nJOIN Antarctic_Animals b ON 1=1 \nWHERE a.species = 'polar_bear' AND b.species = 'penguin';", "raw_model_output": "SELECT a.avg_temp AS polar_bear_avg_temp, b.avg_temp AS penguin_avg_temp \nFROM Arctic_Animals a \nJOIN Antarctic_Animals b ON 1=1 \nWHERE a.species = 'polar_bear' AND b.species = 'penguin';", "latency_sec": 1.3890559673309326, "total_duration_sec": 1.379335606, "load_duration_sec": 0.014601896, "tokens_prompt": 138, "prompt_eval_sec": 0.028735882, "tokens_completion": 56, "completion_eval_sec": 1.333040914, "tokens_total": 194, "tokens_per_sec": 139.66319900901507, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query calculates the average temperature for polar bears and penguins separately and uses INTERSECT to find if their averages are equal (returning a single value if so). The generated query returns both averages as separate columns in a Cartesian product, which cannot produce the same result structure or logic. The INTERSECT operation enforces equality between the two averages, while the JOIN returns paired values without comparison."}
{"example_id": 1311, "sql_complexity": "basic SQL", "prompt": "What is the total number of veteran job applications in Texas in the last year?", "context": "CREATE TABLE veteran_jobs (id INT, state VARCHAR(50), application_date DATE); INSERT INTO veteran_jobs (id, state, application_date) VALUES (1, 'Texas', '2021-02-15'), (2, 'California', '2021-04-10'), (3, 'Texas', '2022-01-05');", "reference_sql": "SELECT COUNT(*) FROM veteran_jobs WHERE state = 'Texas' AND application_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR);", "generated_sql": "SELECT COUNT(*) AS total_applications\nFROM veteran_jobs\nWHERE state = 'Texas' AND application_date >= DATEADD(year, -1, CURRENT_DATE);", "raw_model_output": "```sql\nSELECT COUNT(*) AS total_applications\nFROM veteran_jobs\nWHERE state = 'Texas' AND application_date >= DATEADD(year, -1, CURRENT_DATE);\n``` \n\nNote: The `DATEADD` function used here is specific to some SQL dialects (like T-SQL). For ANSI SQL compliance, you can use:\n\n```sql\nSELECT COUNT(*) AS total_applications\nFROM veteran_jobs\nWHERE state = 'Texas' AND application_date >= CURRENT_DATE - INTERVAL '1 YEAR';\n```", "latency_sec": 2.562847137451172, "total_duration_sec": 2.553793793, "load_duration_sec": 0.014203454, "tokens_prompt": 170, "prompt_eval_sec": 0.035202191, "tokens_completion": 104, "completion_eval_sec": 2.502045016, "tokens_total": 274, "tokens_per_sec": 106.91234603734549, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count records where state is 'Texas' and application_date is within the last year. DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR) and DATEADD(year, -1, CURRENT_DATE) produce the same date value (current date minus one year). The alias 'total_applications' in the generated query doesn't affect the result's semantic equivalence."}
{"example_id": 2997, "sql_complexity": "window functions", "prompt": "What is the earliest capture time for each satellite image in the 'satellite_images' table?", "context": "CREATE TABLE satellite_images (image_id INT, image_url TEXT, capture_time TIMESTAMP); INSERT INTO satellite_images (image_id, image_url, capture_time) VALUES (1, 'image1.jpg', '2022-01-01 10:00:00'), (2, 'image2.jpg', '2021-05-01 10:00:00');", "reference_sql": "SELECT image_id, MIN(capture_time) OVER (PARTITION BY image_id) FROM satellite_images;", "generated_sql": "SELECT image_id, MIN(capture_time) AS earliest_capture_time\nFROM satellite_images\nGROUP BY image_id;", "raw_model_output": "To find the earliest capture time for each satellite image, we need to understand that there might be a misunderstanding in the question. The `capture_time` column already contains the timestamp when each individual image was captured. If you want to verify or extract these timestamps, here is how you can do it:\n\n```sql\nSELECT image_id, MIN(capture_time) AS earliest_capture_time\nFROM satellite_images\nGROUP BY image_id;\n```\n\nThis query will return the earliest capture time for each `image_id` in the table. However, since there's only one entry per `image_id` in your example data, this would simply return the existing `capture_time`.", "latency_sec": 3.321194887161255, "total_duration_sec": 3.316857758, "load_duration_sec": 0.014022866, "tokens_prompt": 178, "prompt_eval_sec": 0.037228999, "tokens_completion": 135, "completion_eval_sec": 3.263217354, "tokens_total": 313, "tokens_per_sec": 94.2431897658172, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries return the same result because the window function in the reference query computes the minimum capture_time within each image_id partition (which contains a single row due to unique image_ids), producing the same value as the GROUP BY aggregation in the generated query. The output structure and values match exactly."}
{"example_id": 3743, "sql_complexity": "aggregation", "prompt": "What is the maximum budget spent on peacekeeping operations by each department?", "context": "CREATE TABLE DepartmentPeacekeeping (id INT, department VARCHAR(50), budget INT);", "reference_sql": "SELECT department, MAX(budget) FROM DepartmentPeacekeeping GROUP BY department;", "generated_sql": "SELECT department, MAX(budget) AS max_budget\nFROM DepartmentPeacekeeping\nGROUP BY department;", "raw_model_output": "To find the maximum budget spent on peacekeeping operations by each department, you can use the `MAX` aggregation function along with the `GROUP BY` clause. Here's the corresponding SQL query:\n\n```sql\nSELECT department, MAX(budget) AS max_budget\nFROM DepartmentPeacekeeping\nGROUP BY department;\n```", "latency_sec": 1.5477077960968018, "total_duration_sec": 1.541536672, "load_duration_sec": 0.013911505, "tokens_prompt": 101, "prompt_eval_sec": 0.020171186, "tokens_completion": 64, "completion_eval_sec": 1.505349339, "tokens_total": 165, "tokens_per_sec": 106.60927108858476, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries group by 'department' and calculate the maximum 'budget' for each group. The generated query adds an explicit alias 'max_budget' for the MAX(budget) column, but this does not affect the semantic result set. The data returned (department names and corresponding max budgets) remains identical."}
{"example_id": 4664, "sql_complexity": "multiple_joins", "prompt": "Calculate the total number of volunteer hours contributed by volunteers from 'California' in 'Health' projects in 2021.", "context": "CREATE TABLE volunteers (volunteer_id INT, name VARCHAR(255), state VARCHAR(255));", "reference_sql": "SELECT SUM(vh.hours) as total_hours FROM volunteer_projects vp JOIN volunteer_hours vh ON vp.project_id = vh.project_id JOIN volunteers vol ON vh.volunteer_id = vol.volunteer_id WHERE vp.cause = 'Health' AND vol.state = 'California' AND vh.volunteer_date BETWEEN '2021-01-01' AND '2021-12-31';", "generated_sql": "SELECT SUM(vh.hours) AS total_volunteer_hours\nFROM volunteer_hours vh\nJOIN projects p ON vh.project_id = p.project_id\nJOIN volunteers v ON vh.volunteer_id = v.volunteer_id\nWHERE v.state = 'California' AND p.category = 'Health' AND p.year = 2021;", "raw_model_output": "To provide an accurate SQL statement for calculating the total number of volunteer hours contributed by volunteers from 'California' in 'Health' projects in 2021, we need to assume there are additional tables and columns that contain project details and volunteer hour records. Since these aren't provided in your schema, I'll create a hypothetical table structure.\n\nLet's assume:\n- A `projects` table with columns: `project_id`, `name`, `category`, `year`.\n- A `volunteer_hours` table with columns: `hour_id`, `volunteer_id`, `project_id`, `hours`.\n\nGiven this schema, the SQL query would look like:\n\n```sql\nSELECT SUM(vh.hours) AS total_volunteer_hours\nFROM volunteer_hours vh\nJOIN projects p ON vh.project_id = p.project_id\nJOIN volunteers v ON vh.volunteer_id = v.volunteer_id\nWHERE v.state = 'California' AND p.category = 'Health' AND p.year = 2021;\n```\n\nThis query sums up the hours contributed by volunteers from California in Health projects during the year 2021.", "latency_sec": 5.547727108001709, "total_duration_sec": 5.542274005, "load_duration_sec": 0.013358283, "tokens_prompt": 118, "prompt_eval_sec": 0.026038516, "tokens_completion": 229, "completion_eval_sec": 5.50071906, "tokens_total": 347, "tokens_per_sec": 62.54813786703892, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in table joins and filtering conditions. The Reference SQL uses 'volunteer_projects' with 'cause' = 'Health' and 'volunteer_date' between 2021 dates, while the Generated SQL uses 'projects' with 'category' = 'Health' and 'year' = 2021. The date range condition in the Reference is not equivalent to the 'year' filter in the Generated query. Additionally, the tables joined (volunteer_projects vs. projects) and columns used (cause vs. category) may represent different data structures."}
{"example_id": 251, "sql_complexity": "set operations", "prompt": "Compare the number of economic diversification projects in two regions, one in Europe and one in Oceania, by showing the project type and the number of projects in each region.", "context": "CREATE TABLE economic_diversification (region VARCHAR(50), project_type VARCHAR(50), project_start_date DATE);", "reference_sql": "SELECT 'Europe' as region, project_type, COUNT(*) as project_count FROM economic_diversification WHERE region = 'Europe' UNION ALL SELECT 'Oceania' as region, project_type, COUNT(*) as project_count FROM economic_diversification WHERE region = 'Oceania';", "generated_sql": "SELECT \n    project_type,\n    SUM(CASE WHEN region = 'Europe' THEN 1 ELSE 0 END) AS europe_projects,\n    SUM(CASE WHEN region = 'Oceania' THEN 1 ELSE 0 END) AS oceania_projects\nFROM \n    economic_diversification\nWHERE \n    region IN ('Europe', 'Oceania')\nGROUP BY \n    project_type;", "raw_model_output": "To compare the number of economic diversification projects in a region from Europe with a region from Oceania, we can use the following SQL query. This query will count the number of projects for each project type in both regions:\n\n```sql\nSELECT \n    project_type,\n    SUM(CASE WHEN region = 'Europe' THEN 1 ELSE 0 END) AS europe_projects,\n    SUM(CASE WHEN region = 'Oceania' THEN 1 ELSE 0 END) AS oceania_projects\nFROM \n    economic_diversification\nWHERE \n    region IN ('Europe', 'Oceania')\nGROUP BY \n    project_type;\n```\n\nThis query groups the projects by `project_type` and counts how many projects are in Europe versus Oceania for each type.", "latency_sec": 3.8883981704711914, "total_duration_sec": 3.880579072, "load_duration_sec": 0.013027524, "tokens_prompt": 130, "prompt_eval_sec": 0.029577537, "tokens_completion": 160, "completion_eval_sec": 3.834622661, "tokens_total": 290, "tokens_per_sec": 74.58083953497442, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries produce different result structures. The Reference query returns two rows per project_type (one for Europe and one for Oceania), while the Generated query returns one row per project_type with separate columns for Europe and Oceania counts. The column names and row organization differ, making them non-equivalent."}
{"example_id": 610, "sql_complexity": "subqueries", "prompt": "What is the percentage of community development projects completed in 'Caribbean' in 2020?", "context": "CREATE TABLE community_projects (project_id INT, project_name TEXT, location TEXT, completion_year INT); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (1, 'Community Center', 'Southern Region, Caribbean', 2020); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (2, 'Park Renovation', 'Northern Region, Caribbean', 2019); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (3, 'Library Construction', 'Caribbean', 2020);", "reference_sql": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM community_projects WHERE location = 'Caribbean')) FROM community_projects WHERE completion_year = 2020 AND location = 'Caribbean';", "generated_sql": "SELECT \n    (COUNT(CASE WHEN location LIKE '%Caribbean%' AND completion_year = 2020 THEN project_id END) * 100.0 / COUNT(project_id)) AS percentage_caribbean_2020\nFROM community_projects;", "raw_model_output": "To calculate the percentage of community development projects completed in 'Caribbean' in 2020, we need to follow these steps:\n\n1. Count the total number of projects.\n2. Count the number of projects completed in 'Caribbean' in 2020.\n3. Calculate the percentage.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT \n    (COUNT(CASE WHEN location LIKE '%Caribbean%' AND completion_year = 2020 THEN project_id END) * 100.0 / COUNT(project_id)) AS percentage_caribbean_2020\nFROM community_projects;\n```\n\nThis query uses conditional aggregation to count the number of projects in 'Caribbean' completed in 2020 and divides it by the total number of projects, then multiplies by 100 to get the percentage.", "latency_sec": 4.43487286567688, "total_duration_sec": 4.429318895, "load_duration_sec": 0.014606696, "tokens_prompt": 217, "prompt_eval_sec": 0.04717017, "tokens_completion": 179, "completion_eval_sec": 4.365244712, "tokens_total": 396, "tokens_per_sec": 89.29230036441187, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Reference SQL uses exact location matching ('Caribbean') while the Generated SQL uses a LIKE pattern ('%Caribbean%') which includes locations with 'Caribbean' as a substring. Second, the Reference SQL calculates the percentage of Caribbean projects completed in 2020 relative to all Caribbean projects (denominator: COUNT(*) from Caribbean), whereas the Generated SQL calculates the percentage of all projects that meet the criteria (denominator: total project count). This leads to different results."}
{"example_id": 421, "sql_complexity": "set operations", "prompt": "What is the combined landfill capacity for 'City A' and 'City B'?", "context": "CREATE TABLE landfill_capacity (city VARCHAR(255), capacity INT); INSERT INTO landfill_capacity (city, capacity) VALUES ('City A', 500000), ('City B', 600000);", "reference_sql": "SELECT SUM(capacity) FROM (SELECT capacity FROM landfill_capacity WHERE city = 'City A' UNION ALL SELECT capacity FROM landfill_capacity WHERE city = 'City B') AS combined_capacity;", "generated_sql": "SELECT SUM(capacity) AS total_capacity \nFROM landfill_capacity \nWHERE city IN ('City A', 'City B');", "raw_model_output": "```sql\nSELECT SUM(capacity) AS total_capacity \nFROM landfill_capacity \nWHERE city IN ('City A', 'City B');\n```", "latency_sec": 0.7507319450378418, "total_duration_sec": 0.744174877, "load_duration_sec": 0.024357763, "tokens_prompt": 135, "prompt_eval_sec": 0.02666237, "tokens_completion": 29, "completion_eval_sec": 0.6910265, "tokens_total": 164, "tokens_per_sec": 218.453472086809, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of capacities for 'City A' and 'City B'. The reference query uses a subquery with UNION ALL to combine the two cities' capacities before summing, while the generated query directly filters using WHERE city IN. Since both approaches sum the same values (500000 + 600000), they produce identical results."}
{"example_id": 880, "sql_complexity": "aggregation", "prompt": "Show veteran employment statistics for each state in the 'veteran_employment' table", "context": "CREATE TABLE veteran_employment (employee_id INT, state VARCHAR(2), job_title VARCHAR(50), employment_date DATE);", "reference_sql": "SELECT state, COUNT(*) as veteran_employees FROM veteran_employment WHERE state IN ('CA', 'NY', 'TX', 'FL', 'PA') GROUP BY state;", "generated_sql": "SELECT state, COUNT(employee_id) AS employment_count\nFROM veteran_employment\nGROUP BY state;", "raw_model_output": "To show veteran employment statistics for each state, you can use a `GROUP BY` clause to aggregate data by state. Assuming that \"statistics\" means counting the number of employees per state, here is the corresponding SQL query:\n\n```sql\nSELECT state, COUNT(employee_id) AS employment_count\nFROM veteran_employment\nGROUP BY state;\n```\n\nThis query will return the count of employees for each state in the `veteran_employment` table.", "latency_sec": 2.2936103343963623, "total_duration_sec": 2.288178319, "load_duration_sec": 0.023688442, "tokens_prompt": 113, "prompt_eval_sec": 0.024064772, "tokens_completion": 93, "completion_eval_sec": 2.238340601, "tokens_total": 206, "tokens_per_sec": 89.8147330916241, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query filters results to only include records where state is in ('CA', 'NY', 'TX', 'FL', 'PA'), while the generated query includes all states. The generated query also uses COUNT(employee_id) instead of COUNT(*), but this difference is negligible if employee_id is non-nullable. However, the absence of the WHERE clause makes them non-equivalent."}
{"example_id": 454, "sql_complexity": "single join", "prompt": "Which excavation sites have more than 10 artifacts?", "context": "CREATE TABLE ExcavationSite (SiteID INT, SiteName VARCHAR(50)); INSERT INTO ExcavationSite (SiteID, SiteName) VALUES (1, 'Site A'), (2, 'Site B'), (3, 'Site C'); CREATE TABLE Artifact (ArtifactID INT, SiteID INT, ObjectType VARCHAR(50)); INSERT INTO Artifact (ArtifactID, SiteID, ObjectType) VALUES (1, 1, 'Pottery'), (2, 1, 'Tool'), (3, 2, 'Statue'), (4, 2, 'Bead'), (5, 3, 'Bead'), (6, 3, 'Bead'), (7, 3, 'Bead'), (8, 3, 'Bead'), (9, 3, 'Bead'), (10, 3, 'Bead'), (11, 3, 'Bead');", "reference_sql": "SELECT e.SiteName FROM ExcavationSite e JOIN Artifact a ON e.SiteID = a.SiteID GROUP BY e.SiteName HAVING COUNT(a.ArtifactID) > 10;", "generated_sql": "SELECT E.SiteName\nFROM ExcavationSite E\nJOIN Artifact A ON E.SiteID = A.SiteID\nGROUP BY E.SiteName\nHAVING COUNT(A.ArtifactID) > 10;", "raw_model_output": "To determine which excavation sites have more than 10 artifacts, you can use the following SQL query:\n\n```sql\nSELECT E.SiteName\nFROM ExcavationSite E\nJOIN Artifact A ON E.SiteID = A.SiteID\nGROUP BY E.SiteName\nHAVING COUNT(A.ArtifactID) > 10;\n```\n\nThis query joins the `ExcavationSite` and `Artifact` tables on the `SiteID`, groups by the site name, and filters to include only those sites where the count of artifacts is greater than 10.", "latency_sec": 2.943856954574585, "total_duration_sec": 2.939899012, "load_duration_sec": 0.023959656, "tokens_prompt": 275, "prompt_eval_sec": 0.058622868, "tokens_completion": 116, "completion_eval_sec": 2.855179847, "tokens_total": 391, "tokens_per_sec": 132.81895351348794, "match_exact": true, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. The only differences are alias naming (e/a vs E/A) and case sensitivity in identifiers, which do not affect the logical execution. Both queries join the same tables on SiteID, group by SiteName, and filter groups with more than 10 artifacts. The dataset shows no site has >10 artifacts, so both return identical results (empty set)."}
{"example_id": 1086, "sql_complexity": "aggregation", "prompt": "What is the total CO2 emission for each equipment type, excluding equipment that is older than 8 years?", "context": "CREATE TABLE EmissionData (EquipmentID INT, EquipmentType VARCHAR(50), CO2Emission INT, Age INT); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (1, 'Excavator', 50, 8); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (2, 'Haul Truck', 70, 7); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (3, 'Shovel', 30, 6); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (4, 'Drilling Rig', 40, 3);", "reference_sql": "SELECT EquipmentType, SUM(CO2Emission) as TotalCO2Emission FROM EmissionData WHERE Age <= 8 GROUP BY EquipmentType;", "generated_sql": "SELECT EquipmentType, SUM(CO2Emission) AS TotalCO2Emission\nFROM EmissionData\nWHERE Age <= 8\nGROUP BY EquipmentType;", "raw_model_output": "```sql\nSELECT EquipmentType, SUM(CO2Emission) AS TotalCO2Emission\nFROM EmissionData\nWHERE Age <= 8\nGROUP BY EquipmentType;\n```", "latency_sec": 1.0581610202789307, "total_duration_sec": 1.053762527, "load_duration_sec": 0.014234508, "tokens_prompt": 256, "prompt_eval_sec": 0.058732115, "tokens_completion": 39, "completion_eval_sec": 0.978594421, "tokens_total": 295, "tokens_per_sec": 278.78554808439094, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select EquipmentType and sum CO2Emission where Age <= 8, grouping by EquipmentType. The only differences are formatting (line breaks, capitalization of keywords) which do not affect semantic meaning."}
{"example_id": 3455, "sql_complexity": "basic SQL", "prompt": "What are the names of all innovation projects in the 'rural_infrastructure' table, excluding those with a budget over 50000?", "context": "CREATE TABLE rural_infrastructure (name VARCHAR(255), budget INT); INSERT INTO rural_infrastructure (name, budget) VALUES ('Dam Construction', 40000), ('Well Digging', 30000), ('Irrigation System', 70000);", "reference_sql": "SELECT name FROM rural_infrastructure WHERE budget <= 50000;", "generated_sql": "SELECT name FROM rural_infrastructure WHERE budget <= 50000;", "raw_model_output": "```sql\nSELECT name FROM rural_infrastructure WHERE budget <= 50000;\n```", "latency_sec": 0.5672099590301514, "total_duration_sec": 0.562786256, "load_duration_sec": 0.022730774, "tokens_prompt": 163, "prompt_eval_sec": 0.033210509, "tokens_completion": 21, "completion_eval_sec": 0.504734288, "tokens_total": 184, "tokens_per_sec": 324.39486837398607, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure and logic. Both select the 'name' column from the 'rural_infrastructure' table where the 'budget' is less than or equal to 50000. The queries are syntactically and semantically identical."}
{"example_id": 3936, "sql_complexity": "window functions", "prompt": "What is the total investment per client for each investment type?", "context": "CREATE TABLE clients (client_id INT, name TEXT, investment_type TEXT, investment FLOAT); INSERT INTO clients (client_id, name, investment_type, investment) VALUES (1, 'John Doe', 'Stocks', 3000.00), (1, 'John Doe', 'Bonds', 2000.00), (2, 'Jane Smith', 'Stocks', 5000.00);", "reference_sql": "SELECT client_id, name, investment_type, SUM(investment) OVER (PARTITION BY client_id, investment_type ORDER BY client_id) as total_investment FROM clients;", "generated_sql": "SELECT client_id, investment_type, SUM(investment) AS total_investment\nFROM clients\nGROUP BY client_id, investment_type;", "raw_model_output": "```sql\nSELECT client_id, investment_type, SUM(investment) AS total_investment\nFROM clients\nGROUP BY client_id, investment_type;\n```", "latency_sec": 0.8375227451324463, "total_duration_sec": 0.832859006, "load_duration_sec": 0.019451685, "tokens_prompt": 174, "prompt_eval_sec": 0.035366435, "tokens_completion": 32, "completion_eval_sec": 0.775901046, "tokens_total": 206, "tokens_per_sec": 245.96346928753923, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL includes the 'name' column and uses a window function to show cumulative sums per client/investment type, while the Generated SQL aggregates data by client_id/investment_type, omitting the 'name' column and returning one row per group. The result sets differ in structure and content."}
{"example_id": 1838, "sql_complexity": "window functions", "prompt": "What are the top 3 species with the most sightings across all arctic research stations?", "context": "CREATE TABLE research_station (id INT, name TEXT); INSERT INTO research_station (id, name) VALUES (1, 'Station A'); INSERT INTO research_station (id, name) VALUES (2, 'Station B'); CREATE TABLE species_observations (station_id INT, species_name TEXT, sightings INT); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (1, 'Species 1', 10); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (1, 'Species 2', 5); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (2, 'Species 1', 8); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (2, 'Species 3', 15);", "reference_sql": "SELECT species_name, SUM(sightings) as total_sightings, RANK() OVER (ORDER BY SUM(sightings) DESC) as rank FROM species_observations GROUP BY species_name HAVING rank <= 3;", "generated_sql": "SELECT species_name, SUM(sightings) AS total_sightings\nFROM species_observations\nGROUP BY species_name\nORDER BY total_sightings DESC\nLIMIT 3;", "raw_model_output": "To find the top 3 species with the most sightings across all Arctic research stations, you can use the following SQL query:\n\n```sql\nSELECT species_name, SUM(sightings) AS total_sightings\nFROM species_observations\nGROUP BY species_name\nORDER BY total_sightings DESC\nLIMIT 3;\n```\n\nThis query groups the data by `species_name`, sums up the sightings for each species, orders the results in descending order based on the total number of sightings, and limits the output to the top 3 species.", "latency_sec": 2.7573769092559814, "total_duration_sec": 2.75188368, "load_duration_sec": 0.008809237, "tokens_prompt": 255, "prompt_eval_sec": 0.054217587, "tokens_completion": 111, "completion_eval_sec": 2.686776778, "tokens_total": 366, "tokens_per_sec": 132.73484621250316, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL includes a RANK() column and uses HAVING rank <= 3, which is invalid syntax because RANK() is an analytic function and cannot be used in HAVING. The Generated SQL correctly orders and limits results without the rank column. Even if the Reference SQL were valid, the output structure differs (includes rank vs. excludes it), making them semantically distinct."}
{"example_id": 3091, "sql_complexity": "single join", "prompt": "Find the number of hybrid vehicles sold in the US, Germany, and Japan.", "context": "CREATE TABLE vehicle_sales (sale_id INT, vehicle_id INT, country VARCHAR(20), quantity INT); CREATE TABLE vehicles (vehicle_id INT, model VARCHAR(20), manufacture VARCHAR(20), vehicle_type VARCHAR(20));", "reference_sql": "SELECT SUM(vs.quantity) FROM vehicle_sales vs JOIN vehicles v ON vs.vehicle_id = v.vehicle_id WHERE v.vehicle_type = 'hybrid' AND vs.country IN ('US', 'Germany', 'Japan');", "generated_sql": "SELECT vs.country, SUM(vs.quantity) AS total_quantity_sold\nFROM vehicle_sales vs\nJOIN vehicles v ON vs.vehicle_id = v.vehicle_id\nWHERE v.vehicle_type = 'hybrid' AND vs.country IN ('US', 'Germany', 'Japan')\nGROUP BY vs.country;", "raw_model_output": "To find the number of hybrid vehicles sold in the US, Germany, and Japan, you need to join the `vehicle_sales` table with the `vehicles` table on the `vehicle_id`, filter for hybrid vehicles, and then aggregate the sales quantity by country. Here is the corresponding SQL query:\n\n```sql\nSELECT vs.country, SUM(vs.quantity) AS total_quantity_sold\nFROM vehicle_sales vs\nJOIN vehicles v ON vs.vehicle_id = v.vehicle_id\nWHERE v.vehicle_type = 'hybrid' AND vs.country IN ('US', 'Germany', 'Japan')\nGROUP BY vs.country;\n```\n\nThis query will provide the total quantity of hybrid vehicles sold in each of the specified countries.", "latency_sec": 3.583239793777466, "total_duration_sec": 3.577729107, "load_duration_sec": 0.012942953, "tokens_prompt": 134, "prompt_eval_sec": 0.029885225, "tokens_completion": 141, "completion_eval_sec": 3.532754902, "tokens_total": 275, "tokens_per_sec": 76.74618943380675, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns a single aggregated sum of quantities for all specified countries, while the Generated SQL groups the results by country, producing separate sums for each country. The output structure and values differ."}
{"example_id": 2399, "sql_complexity": "set operations", "prompt": "What is the average duration of criminal trials for Indigenous defendants compared to non-Indigenous defendants in Canada and New Zealand?", "context": "CREATE TABLE canada_criminal_trials (id INT, defendant_type VARCHAR(255), days_to_completion INT); INSERT INTO canada_criminal_trials (id, defendant_type, days_to_completion) VALUES (1, 'Indigenous', 60), (2, 'Non-Indigenous', 45);CREATE TABLE nz_criminal_trials (id INT, defendant_type VARCHAR(255), days_to_completion INT); INSERT INTO nz_criminal_trials (id, defendant_type, days_to_completion) VALUES (1, 'Indigenous', 70), (2, 'Non-Indigenous', 50);", "reference_sql": "SELECT AVG(days_to_completion) AS avg_duration FROM canada_criminal_trials WHERE defendant_type = 'Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM canada_criminal_trials WHERE defendant_type = 'Non-Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM nz_criminal_trials WHERE defendant_type = 'Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM nz_criminal_trials WHERE defendant_type = 'Non-Indigenous';", "generated_sql": "SELECT \n    'Canada' AS country,\n    defendant_type,\n    AVG(days_to_completion) AS avg_days_to_completion\nFROM canada_criminal_trials\nGROUP BY defendant_type\n\nUNION ALL\n\nSELECT \n    'New Zealand' AS country,\n    defendant_type,\n    AVG(days_to_completion) AS avg_days_to_completion\nFROM nz_criminal_trials\nGROUP BY defendant_type;", "raw_model_output": "To find the average duration of criminal trials for both Indigenous and Non-Indigenous defendants in Canada and New Zealand, you can use the following SQL query:\n\n```sql\nSELECT \n    'Canada' AS country,\n    defendant_type,\n    AVG(days_to_completion) AS avg_days_to_completion\nFROM canada_criminal_trials\nGROUP BY defendant_type\n\nUNION ALL\n\nSELECT \n    'New Zealand' AS country,\n    defendant_type,\n    AVG(days_to_completion) AS avg_days_to_completion\nFROM nz_criminal_trials\nGROUP BY defendant_type;\n```\n\nThis query calculates the average duration of criminal trials for each type of defendant in both Canada and New Zealand, then combines the results using `UNION ALL`.", "latency_sec": 3.649914264678955, "total_duration_sec": 3.645957018, "load_duration_sec": 0.020063306, "tokens_prompt": 221, "prompt_eval_sec": 0.050253371, "tokens_completion": 145, "completion_eval_sec": 3.572913308, "tokens_total": 366, "tokens_per_sec": 100.27632800634927, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL returns four rows with only the average duration values, while the Generated SQL returns four rows with additional 'country' and 'defendant_type' columns. The structure of the result sets differs, making them non-equivalent despite calculating similar averages."}
{"example_id": 2972, "sql_complexity": "set operations", "prompt": "How many indigenous communities are in the Arctic Research Station 13 and 14?", "context": "CREATE TABLE Arctic_Research_Station_13 (id INT, community TEXT); CREATE TABLE Arctic_Research_Station_14 (id INT, community TEXT);", "reference_sql": "SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_13; SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_14; SELECT COUNT(DISTINCT community) FROM (SELECT * FROM Arctic_Research_Station_13 UNION ALL SELECT * FROM Arctic_Research_Station_14) AS Arctic_Communities;", "generated_sql": "SELECT COUNT(DISTINCT community) \nFROM (\n    SELECT community FROM Arctic_Research_Station_13\n    UNION\n    SELECT community FROM Arctic_Research_Station_14\n) AS Combined_Communities;", "raw_model_output": "To determine how many unique indigenous communities are present in both `Arctic_Research_Station_13` and `Arctic_Research_Station_14`, you can use a combination of UNION to merge the community names from both tables and then count the distinct values. Here is the SQL query:\n\n```sql\nSELECT COUNT(DISTINCT community) \nFROM (\n    SELECT community FROM Arctic_Research_Station_13\n    UNION\n    SELECT community FROM Arctic_Research_Station_14\n) AS Combined_Communities;\n```\n\nThis query first combines all unique communities from both tables and then counts the distinct number of communities.", "latency_sec": 3.230978012084961, "total_duration_sec": 3.224921796, "load_duration_sec": 0.014500716, "tokens_prompt": 121, "prompt_eval_sec": 0.025268995, "tokens_completion": 132, "completion_eval_sec": 3.18253197, "tokens_total": 253, "tokens_per_sec": 78.3044635567601, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count distinct communities across both tables. The Reference SQL's third query uses UNION ALL (which includes duplicates) but applies COUNT(DISTINCT), while the Generated SQL uses UNION (which removes duplicates between the two tables). Since COUNT(DISTINCT) inherently eliminates duplicates, both approaches yield the same result."}
{"example_id": 5576, "sql_complexity": "window functions", "prompt": "Who are the top 5 users with the most followers, and what is their location?", "context": "CREATE TABLE user_data (user_id INT, name VARCHAR(50), followers INT, location VARCHAR(50)); INSERT INTO user_data (user_id, name, followers, location) VALUES (1, 'Alice', 10000, 'New York'), (2, 'Bob', 15000, 'California'), (3, 'Charlie', 12000, 'Texas'), (4, 'David', 8000, 'Florida'), (5, 'Eve', 9000, 'Illinois');", "reference_sql": "SELECT name, location FROM (SELECT name, location, ROW_NUMBER() OVER (ORDER BY followers DESC) AS rank FROM user_data) AS user_ranks WHERE rank <= 5;", "generated_sql": "SELECT name, location FROM user_data ORDER BY followers DESC LIMIT 5;", "raw_model_output": "```sql\nSELECT name, location FROM user_data ORDER BY followers DESC LIMIT 5;\n```", "latency_sec": 0.5796689987182617, "total_duration_sec": 0.571189978, "load_duration_sec": 0.013838899, "tokens_prompt": 207, "prompt_eval_sec": 0.048565529, "tokens_completion": 20, "completion_eval_sec": 0.506524194, "tokens_total": 227, "tokens_per_sec": 391.6027948741994, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses ROW_NUMBER() to assign ranks and filters by rank <= 5, which could include more rows than the Generated SQL's LIMIT 5 if there are ties in followers. While they produce the same result in the provided sample data (no ties), they are not semantically equivalent in general cases with duplicate follower counts."}
{"example_id": 1560, "sql_complexity": "basic SQL", "prompt": "What is the average media literacy score for users in the 'Young Adult' age group who have completed at least one disinformation detection course?", "context": "CREATE TABLE users (id INT, age VARCHAR(20), media_literacy_score INT, courses_completed INT);", "reference_sql": "SELECT AVG(media_literacy_score) FROM users WHERE age = 'Young Adult' AND courses_completed > 0;", "generated_sql": "SELECT AVG(media_literacy_score) AS avg_media_literacy_score\nFROM users\nWHERE age = 'Young Adult' AND courses_completed > 0;", "raw_model_output": "To determine the average media literacy score for users in the 'Young Adult' age group who have completed at least one disinformation detection course, you can use the following SQL query:\n\n```sql\nSELECT AVG(media_literacy_score) AS avg_media_literacy_score\nFROM users\nWHERE age = 'Young Adult' AND courses_completed > 0;\n```\n\nThis query calculates the average `media_literacy_score` for users who are in the 'Young Adult' age group and have completed at least one course (`courses_completed > 0`).", "latency_sec": 2.7872886657714844, "total_duration_sec": 2.77991405, "load_duration_sec": 0.020276806, "tokens_prompt": 121, "prompt_eval_sec": 0.031041787, "tokens_completion": 113, "completion_eval_sec": 2.724733429, "tokens_total": 234, "tokens_per_sec": 83.95255320109871, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. The generated query adds an alias (AS avg_media_literacy_score) to the computed average, but this does not affect the actual calculation or result set. Both queries compute the same average value from the same subset of data."}
{"example_id": 1201, "sql_complexity": "basic SQL", "prompt": "What is the maximum energy efficiency rating of hydroelectric dams in Canada?", "context": "CREATE TABLE hydro_dams (id INT, name TEXT, country TEXT, energy_efficiency_rating FLOAT); INSERT INTO hydro_dams (id, name, country, energy_efficiency_rating) VALUES (1, 'Robert-Bourassa', 'Canada', 0.94), (2, 'Churchill Falls', 'Canada', 0.92);", "reference_sql": "SELECT MAX(energy_efficiency_rating) FROM hydro_dams WHERE country = 'Canada';", "generated_sql": "SELECT MAX(energy_efficiency_rating) AS max_energy_efficiency_rating \nFROM hydro_dams \nWHERE country = 'Canada';", "raw_model_output": "```sql\nSELECT MAX(energy_efficiency_rating) AS max_energy_efficiency_rating \nFROM hydro_dams \nWHERE country = 'Canada';\n```", "latency_sec": 0.8031637668609619, "total_duration_sec": 0.798381844, "load_duration_sec": 0.014037561, "tokens_prompt": 157, "prompt_eval_sec": 0.031377973, "tokens_completion": 31, "completion_eval_sec": 0.750811215, "tokens_total": 188, "tokens_per_sec": 234.07430434115344, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the maximum energy efficiency rating for dams in Canada. The generated query adds an alias to the result column, but the scalar value returned remains the same. Semantic equivalence focuses on the result set, not column naming conventions."}
{"example_id": 4243, "sql_complexity": "single join", "prompt": "How many orders were placed by new and returning customers in each month of the year 2021?'", "context": "CREATE TABLE customer (id INT, first_order_date DATE, last_order_date DATE);", "reference_sql": "INSERT INTO customer (id, first_order_date, last_order_date) SELECT customer_id, MIN(order_date) AS first_order_date, MAX(order_date) AS last_order_date FROM orders GROUP BY customer_id; SELECT YEAR(order_date) AS year, MONTH(order_date) AS month, CASE WHEN DATEDIFF(last_order_date, first_order_date) > 30 THEN 'returning' ELSE 'new' END AS customer_type, COUNT(DISTINCT id) AS num_orders FROM orders JOIN customer ON orders.customer_id = customer.id WHERE YEAR(order_date) = 2021 GROUP BY year, month, customer_type;", "generated_sql": "SELECT \n    EXTRACT(YEAR FROM last_order_date) AS year,\n    EXTRACT(MONTH FROM last_order_date) AS month,\n    COUNT(CASE WHEN first_order_date < '2021-01-01' THEN 1 END) AS returning_customers,\n    COUNT(CASE WHEN first_order_date >= '2021-01-01' THEN 1 END) AS new_customers\nFROM \n    customer\nWHERE \n    last_order_date BETWEEN '2021-01-01' AND '2021-12-31'\nGROUP BY \n    year, month;", "raw_model_output": "To determine how many orders were placed by new and returning customers in each month of the year 2021, we need to categorize customers based on whether their `first_order_date` is before or within the year 2021. However, since the schema does not provide a direct way to count orders (such as an order table), I'll assume that the number of months between `first_order_date` and `last_order_date` can be used to infer the activity.\n\nHere's how you could write the SQL query:\n\n```sql\nSELECT \n    EXTRACT(YEAR FROM last_order_date) AS year,\n    EXTRACT(MONTH FROM last_order_date) AS month,\n    COUNT(CASE WHEN first_order_date < '2021-01-01' THEN 1 END) AS returning_customers,\n    COUNT(CASE WHEN first_order_date >= '2021-01-01' THEN 1 END) AS new_customers\nFROM \n    customer\nWHERE \n    last_order_date BETWEEN '2021-01-01' AND '2021-12-31'\nGROUP BY \n    year, month;\n```\n\nThis query extracts the year and month from `last_order_date` for each customer who had an order in 2021. It then counts how many of those customers are new (first order date is in or after January 1, 2021) and returning (first order date is before January 1, 2021).", "latency_sec": 7.965619802474976, "total_duration_sec": 7.959804644, "load_duration_sec": 0.017143099, "tokens_prompt": 108, "prompt_eval_sec": 0.023717108, "tokens_completion": 325, "completion_eval_sec": 7.916582213, "tokens_total": 433, "tokens_per_sec": 54.358607457697616, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates customer type based on the date difference between first and last orders, while the generated query uses a fixed date ('2021-01-01') to categorize customers. Additionally, the reference query counts distinct orders per month, whereas the generated query counts customers directly. The filtering conditions and aggregation logic differ significantly."}
{"example_id": 2321, "sql_complexity": "subqueries", "prompt": "What are the names and types of vessels used in research expeditions in the regions with the lowest ocean acidification levels?", "context": "CREATE TABLE ocean_acidification (id INT PRIMARY KEY, region VARCHAR(255), year INT, acidification_level INT); INSERT INTO ocean_acidification (id, region, year, acidification_level) VALUES (1, 'Arctic Ocean', 2018, 20), (2, 'Southern Ocean', 2019, 22); CREATE TABLE expedition_vessels (id INT PRIMARY KEY, name VARCHAR(255), type VARCHAR(255), region VARCHAR(255)); INSERT INTO expedition_vessels (id, name, type, region) VALUES (1, 'Sea Researcher', 'Research Vessel', 'Arctic Ocean');", "reference_sql": "SELECT v.name, v.type FROM expedition_vessels v INNER JOIN ocean_acidification oa ON v.region = oa.region WHERE oa.acidification_level = (SELECT MIN(acidification_level) FROM ocean_acidification);", "generated_sql": "SELECT ev.name, ev.type \nFROM expedition_vessels ev\nJOIN (\n    SELECT region, MIN(acidification_level) AS min_acidification\n    FROM ocean_acidification\n    GROUP BY region\n    HAVING acidification_level = (\n        SELECT MIN(acidification_level)\n        FROM ocean_acidification\n    )\n) oa ON ev.region = oa.region;", "raw_model_output": "To find the names and types of vessels used in research expeditions in the regions with the lowest ocean acidification levels, we need to follow these steps:\n\n1. Identify the minimum acidification level across all regions.\n2. Find the regions that have this minimum acidification level.\n3. Retrieve the vessel details from the `expedition_vessels` table for those regions.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT ev.name, ev.type \nFROM expedition_vessels ev\nJOIN (\n    SELECT region, MIN(acidification_level) AS min_acidification\n    FROM ocean_acidification\n    GROUP BY region\n    HAVING acidification_level = (\n        SELECT MIN(acidification_level)\n        FROM ocean_acidification\n    )\n) oa ON ev.region = oa.region;\n```\n\nThis query first finds the regions with the lowest acidification levels and then retrieves the names and types of vessels from those regions.", "latency_sec": 4.883481979370117, "total_duration_sec": 4.878009271, "load_duration_sec": 0.013662951, "tokens_prompt": 240, "prompt_eval_sec": 0.05379472, "tokens_completion": 194, "completion_eval_sec": 4.808124619, "tokens_total": 434, "tokens_per_sec": 88.8710149506845, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The generated SQL contains a syntax error in the HAVING clause. It references 'acidification_level' which is not part of the grouped columns or aggregate functions. The subquery selects 'region' and 'MIN(acidification_level)', but the HAVING condition incorrectly uses 'acidification_level' (a non-aggregated column) instead of 'min_acidification'. This makes the generated query invalid, while the reference query is valid. Even if the HAVING clause were corrected to use 'min_acidification', the semantic equivalence would depend on whether the subquery's logic matches the reference. However, as written, the generated query is not valid and thus not equivalent."}
{"example_id": 4349, "sql_complexity": "multiple_joins", "prompt": "Show the research grants awarded to professors in the Computer Science department.", "context": "CREATE TABLE departments (id INT, name VARCHAR(50)); INSERT INTO departments (id, name) VALUES (1, 'Computer Science'), (2, 'Mathematics'); CREATE TABLE professors (id INT, name VARCHAR(50), department_id INT); INSERT INTO professors (id, name, department_id) VALUES (1, 'John Smith', 1), (2, 'Jane Doe', 2); CREATE TABLE grants (id INT, professor_id INT, year INT, amount FLOAT); INSERT INTO grants (id, professor_id, year, amount) VALUES (1, 1, 2021, 5000.0), (2, 2, 2020, 7000.0);", "reference_sql": "SELECT professors.name, grants.amount FROM professors INNER JOIN grants ON professors.id = grants.professor_id INNER JOIN departments ON professors.department_id = departments.id WHERE departments.name = 'Computer Science';", "generated_sql": "SELECT g.id AS grant_id, p.name AS professor_name, g.year, g.amount\nFROM grants g\nJOIN professors p ON g.professor_id = p.id\nJOIN departments d ON p.department_id = d.id\nWHERE d.name = 'Computer Science';", "raw_model_output": "```sql\nSELECT g.id AS grant_id, p.name AS professor_name, g.year, g.amount\nFROM grants g\nJOIN professors p ON g.professor_id = p.id\nJOIN departments d ON p.department_id = d.id\nWHERE d.name = 'Computer Science';\n```", "latency_sec": 1.5539848804473877, "total_duration_sec": 1.547417234, "load_duration_sec": 0.013814406, "tokens_prompt": 238, "prompt_eval_sec": 0.065506326, "tokens_completion": 59, "completion_eval_sec": 1.46560091, "tokens_total": 297, "tokens_per_sec": 191.12155062570145, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects only 'professors.name' and 'grants.amount', while the Generated SQL includes additional columns 'g.id' (grant_id) and 'g.year'. Although both filter for 'Computer Science' department, the result sets differ in column structure, making them non-equivalent."}
{"example_id": 476, "sql_complexity": "basic SQL", "prompt": "Insert new food safety records for locations \"A123\", \"B456\", and \"C789\"", "context": "CREATE TABLE food_safety_records (id INT, location VARCHAR(255), inspection_date DATE, violation_count INT);", "reference_sql": "INSERT INTO food_safety_records (location, inspection_date, violation_count) VALUES ('A123', '2022-03-01', 0), ('B456', '2022-03-05', 2), ('C789', '2022-03-10', 1);", "generated_sql": "INSERT INTO food_safety_records (location) VALUES ('A123'), ('B456'), ('C789');", "raw_model_output": "INSERT INTO food_safety_records (location) VALUES ('A123'), ('B456'), ('C789'); \n\nNote: This assumes that `inspection_date` and `violation_count` can be NULL or have default values, as they are not provided in the question. If these columns require specific values, please provide them.", "latency_sec": 1.8077168464660645, "total_duration_sec": 1.799103962, "load_duration_sec": 0.023898993, "tokens_prompt": 120, "prompt_eval_sec": 0.024902598, "tokens_completion": 73, "completion_eval_sec": 1.748079013, "tokens_total": 193, "tokens_per_sec": 106.76450815695992, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL inserts values for all columns (location, inspection_date, violation_count), while the Generated SQL only inserts values for the 'location' column. The other columns (id, inspection_date, violation_count) would either be null or use default values, leading to different data being stored. The generated query is missing required data for inspection_date and violation_count, making them semantically different."}
{"example_id": 2908, "sql_complexity": "single join", "prompt": "List all co-owners and the properties they own in New York, NY.", "context": "CREATE TABLE properties (id INT, city VARCHAR(50), price INT); CREATE TABLE co_owners (property_id INT, owner_name VARCHAR(50)); INSERT INTO properties (id, city, price) VALUES (1, 'New York', 800000), (2, 'Los Angeles', 600000); INSERT INTO co_owners (property_id, owner_name) VALUES (1, 'David'), (1, 'Ella'), (2, 'Frank');", "reference_sql": "SELECT properties.city, co_owners.owner_name FROM properties INNER JOIN co_owners ON properties.id = co_owners.property_id WHERE properties.city = 'New York';", "generated_sql": "SELECT co.owner_name, p.id AS property_id, p.city, p.price \nFROM co_owners co\nJOIN properties p ON co.property_id = p.id\nWHERE p.city = 'New York';", "raw_model_output": "```sql\nSELECT co.owner_name, p.id AS property_id, p.city, p.price \nFROM co_owners co\nJOIN properties p ON co.property_id = p.id\nWHERE p.city = 'New York';\n```", "latency_sec": 1.2233726978302002, "total_duration_sec": 1.218725788, "load_duration_sec": 0.014113567, "tokens_prompt": 191, "prompt_eval_sec": 0.048074794, "tokens_completion": 47, "completion_eval_sec": 1.153362843, "tokens_total": 238, "tokens_per_sec": 194.54414866550633, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL selects only 'city' and 'owner_name', while the Generated SQL includes additional columns ('owner_name', 'property_id', 'city', 'price'). The column names and quantities differ, leading to different result structures even though both filter properties in 'New York'."}
{"example_id": 636, "sql_complexity": "set operations", "prompt": "Insert new data into the 'cosmetic_ingredients' table for a vegan eyeshadow product by brand 'Ara' with ingredients 'Mica', 'Iron Oxide', 'Titanium Dioxide' and 'Zinc Oxide'.", "context": "CREATE TABLE cosmetic_ingredients (ingredient_id INT, product_name TEXT, brand_name TEXT, ingredient_type TEXT);", "reference_sql": "INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type) VALUES (NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient'); INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type, ingredient_name) SELECT ingredient_id, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Mica' FROM cosmetic_ingredients WHERE ingredient_name = 'Mica' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Iron Oxide' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Titanium Dioxide' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Zinc Oxide';", "generated_sql": "INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type) VALUES \n(NEXT VALUE FOR cosmetic_ingredients_ingredient_id_seq, 'Vegan Eyeshadow', 'Ara', 'Mica'),\n(NEXT VALUE FOR cosmetic_ingredients_ingredient_id_seq, 'Vegan Eyeshadow', 'Ara', 'Iron Oxide'),\n(NEXT VALUE FOR cosmetic_ingredients_ingredient_id_seq, 'Vegan Eyeshadow', 'Ara', 'Titanium Dioxide'),\n(NEXT VALUE FOR cosmetic_ingredients_ingredient_id_seq, 'Vegan Eyeshadow', 'Ara', 'Zinc Oxide');", "raw_model_output": "INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type) VALUES \n(NEXT VALUE FOR cosmetic_ingredients_ingredient_id_seq, 'Vegan Eyeshadow', 'Ara', 'Mica'),\n(NEXT VALUE FOR cosmetic_ingredients_ingredient_id_seq, 'Vegan Eyeshadow', 'Ara', 'Iron Oxide'),\n(NEXT VALUE FOR cosmetic_ingredients_ingredient_id_seq, 'Vegan Eyashadow', 'Ara', 'Titanium Dioxide'),\n(NEXT VALUE FOR cosmetic_ingredients_ingredient_id_seq, 'Vegan Eyeshadow', 'Ara', 'Zinc Oxide');\n\nNote: The `NEXT VALUE FOR cosmetic_ingredients_ingredient_id_seq` is used to generate the next value for an auto-incrementing primary key. If your database does not use sequences or if you have a different method of generating unique IDs, please adjust accordingly.\n\nAlso, there was a typo in one of the rows ('Vegan Eyashadow' instead of 'Vegan Eyeshadow'). Here is the corrected version:\n\n```sql\nINSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type) VALUES \n(NEXT VALUE FOR cosmetic_ingredients_ingredient_id_seq, 'Vegan Eyeshadow', 'Ara', 'Mica'),\n(NEXT VALUE FOR cosmetic_ingredients_ingredient_id_seq, 'Vegan Eyeshadow', 'Ara', 'Iron Oxide'),\n(NEXT VALUE FOR cosmetic_ingredients_ingredient_id_seq, 'Vegan Eyeshadow', 'Ara', 'Titanium Dioxide'),\n(NEXT VALUE FOR cosmetic_ingredients_ingredient_id_seq, 'Vegan Eyeshadow', 'Ara', 'Zinc Oxide');\n```", "latency_sec": 8.822597980499268, "total_duration_sec": 8.816964405, "load_duration_sec": 0.013590629, "tokens_prompt": 140, "prompt_eval_sec": 0.029511433, "tokens_completion": 358, "completion_eval_sec": 8.771450424, "tokens_total": 498, "tokens_per_sec": 56.445958560135864, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL contains invalid column references (e.g., 'ingredient_name' not in the schema) and attempts to insert into a table with mismatched column counts. The Generated SQL correctly inserts four rows with ingredient_type values, while the Reference SQL's structure is invalid and would fail execution. Additionally, the Generated SQL uses a sequence for ingredient_id, whereas the Reference SQL uses NULL, which may lead to different data outcomes."}
{"example_id": 3404, "sql_complexity": "multiple_joins", "prompt": "What are the names of startups that have received funding from investors with over 3 million funds, and are involved in Genetic Research or Bioprocess Engineering?", "context": "CREATE TABLE public.investors ( id SERIAL PRIMARY KEY, name VARCHAR(100), type VARCHAR(50), funds INTEGER ); CREATE TABLE public.investments ( id SERIAL PRIMARY KEY, investor_id INTEGER, startup_id INTEGER ); CREATE TABLE public.startups ( id SERIAL PRIMARY KEY, name VARCHAR(100), industry VARCHAR(50), funding INTEGER );", "reference_sql": "SELECT startups.name FROM public.startups JOIN public.investments ON startups.id = investments.startup_id JOIN public.investors ON investments.investor_id = investors.id WHERE (startups.industry = 'Genetic Research' OR startups.industry = 'Bioprocess Engineering') AND investors.funds > 3000000;", "generated_sql": "SELECT s.name\nFROM public.startups s\nJOIN public.investments i ON s.id = i.startup_id\nJOIN public.investors iv ON i.investor_id = iv.id\nWHERE iv.funds > 3000000 AND (s.industry = 'Genetic Research' OR s.industry = 'Bioprocess Engineering');", "raw_model_output": "```sql\nSELECT s.name\nFROM public.startups s\nJOIN public.investments i ON s.id = i.startup_id\nJOIN public.investors iv ON i.investor_id = iv.id\nWHERE iv.funds > 3000000 AND (s.industry = 'Genetic Research' OR s.industry = 'Bioprocess Engineering');\n```", "latency_sec": 2.027156114578247, "total_duration_sec": 2.019154729, "load_duration_sec": 0.015080012, "tokens_prompt": 175, "prompt_eval_sec": 0.039139973, "tokens_completion": 81, "completion_eval_sec": 1.96168346, "tokens_total": 256, "tokens_per_sec": 126.2852910829027, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select startup names joined with investments and investors, applying the same industry filters and funds condition. The differences are purely syntactic (alias names and WHERE clause order), which do not affect the semantic result."}
{"example_id": 134, "sql_complexity": "subqueries", "prompt": "Who are the top 3 authors with the most citations in the Mathematics department in the past 5 years?", "context": "CREATE TABLE authors (id INT, name VARCHAR(50), department VARCHAR(50)); INSERT INTO authors (id, name, department) VALUES (1, 'Author Name', 'Mathematics'); CREATE TABLE publications (id INT, title VARCHAR(100), author VARCHAR(50), journal VARCHAR(50), year INT, cites INT); INSERT INTO publications (id, title, author, journal, year, cites) VALUES (1, 'Publication Title', 'Author Name', 'Journal Name', 2021, 10);", "reference_sql": "SELECT author, SUM(cites) as total_cites FROM publications WHERE author IN (SELECT name FROM authors WHERE department = 'Mathematics') AND year BETWEEN YEAR(CURRENT_DATE) - 5 AND YEAR(CURRENT_DATE) GROUP BY author ORDER BY total_cites DESC LIMIT 3;", "generated_sql": "SELECT a.name, SUM(p.cites) AS total_citations\nFROM authors a\nJOIN publications p ON a.name = p.author\nWHERE a.department = 'Mathematics' AND p.year >= YEAR(CURRENT_DATE) - 5\nGROUP BY a.id, a.name\nORDER BY total_citations DESC\nLIMIT 3;", "raw_model_output": "To find the top 3 authors with the most citations in the Mathematics department in the past 5 years, you can use the following SQL query:\n\n```sql\nSELECT a.name, SUM(p.cites) AS total_citations\nFROM authors a\nJOIN publications p ON a.name = p.author\nWHERE a.department = 'Mathematics' AND p.year >= YEAR(CURRENT_DATE) - 5\nGROUP BY a.id, a.name\nORDER BY total_citations DESC\nLIMIT 3;\n```\n\nThis query joins the `authors` and `publications` tables on the author name, filters for authors in the Mathematics department who have publications from the past 5 years, groups by author ID and name to sum up their citations, orders the results by total citations in descending order, and limits the output to the top 3 authors.", "latency_sec": 4.30398416519165, "total_duration_sec": 4.298578832, "load_duration_sec": 0.02684554, "tokens_prompt": 206, "prompt_eval_sec": 0.049585876, "tokens_completion": 172, "completion_eval_sec": 4.218937371, "tokens_total": 378, "tokens_per_sec": 87.82560192880455, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the year condition: the Reference uses BETWEEN (inclusive of both ends) while the Generated uses >=, which may include years beyond the current year. Second, the GROUP BY clause in the Reference uses only 'author' (name), whereas the Generated groups by both 'id' and 'name'. This could lead to different aggregation results if there are authors with the same name but different IDs. Additionally, the Generated query's year condition may include more years than intended."}
{"example_id": 592, "sql_complexity": "set operations", "prompt": "How many public healthcare facilities and public parks are there in total, in the 'StateData' schema's 'StateHealthcare' and 'StateParks' tables?", "context": "CREATE SCHEMA StateData; CREATE TABLE StateHealthcare (Name varchar(255), Type varchar(255)); INSERT INTO StateHealthcare (Name, Type) VALUES ('FacilityA', 'Public'), ('FacilityB', 'Public'), ('FacilityC', 'Private'); CREATE TABLE StateParks (Name varchar(255), Type varchar(255)); INSERT INTO StateParks (Name, Type) VALUES ('ParkA', 'Public'), ('ParkB', 'Public'), ('ParkC', 'Private');", "reference_sql": "SELECT COUNT(*) FROM StateData.StateHealthcare WHERE Type = 'Public' UNION ALL SELECT COUNT(*) FROM StateData.StateParks WHERE Type = 'Public';", "generated_sql": "SELECT \n    (SELECT COUNT(*) FROM StateHealthcare WHERE Type = 'Public') + \n    (SELECT COUNT(*) FROM StateParks WHERE Type = 'Public') AS Total_Public_Facilities;", "raw_model_output": "```sql\nSELECT \n    (SELECT COUNT(*) FROM StateHealthcare WHERE Type = 'Public') + \n    (SELECT COUNT(*) FROM StateParks WHERE Type = 'Public') AS Total_Public_Facilities;\n```", "latency_sec": 1.2088840007781982, "total_duration_sec": 1.200859428, "load_duration_sec": 0.014520008, "tokens_prompt": 216, "prompt_eval_sec": 0.047832534, "tokens_completion": 46, "completion_eval_sec": 1.136408387, "tokens_total": 262, "tokens_per_sec": 216.72881751379126, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate counts (one for StateHealthcare and one for StateParks) as two rows via UNION ALL, while the Generated SQL returns a single row with the summed total of both counts. The output structure and values differ."}
{"example_id": 1989, "sql_complexity": "single join", "prompt": "What are the names and production dates of garments made from fabrics with a sustainability score over 70, produced after 2021-01-01?", "context": "CREATE TABLE fabrics (id INT, name VARCHAR(50), type VARCHAR(50), sustainability_score INT); INSERT INTO fabrics (id, name, type, sustainability_score) VALUES (1, 'Organic Linen', 'Natural', 80); INSERT INTO fabrics (id, name, type, sustainability_score) VALUES (2, 'Recycled Nylon', 'Synthetic', 72);", "reference_sql": "SELECT garments.name, garments.production_date FROM garments JOIN fabrics ON garments.fabric_id = fabrics.id WHERE fabrics.sustainability_score > 70 AND garments.production_date > '2021-01-01';", "generated_sql": "CREATE TABLE garments (id INT, name VARCHAR(50), production_date DATE);\nCREATE TABLE fabric_usage (garment_id INT, fabric_id INT, usage_amount DECIMAL(10, 2));", "raw_model_output": "It seems there is an issue with the provided schema as it does not include any tables related to garments or their production dates. However, I will assume that there are two additional tables: `garments` and `fabric_usage`. Here's a possible schema for these tables:\n\n```sql\nCREATE TABLE garments (id INT, name VARCHAR(50), production_date DATE);\nCREATE TABLE fabric_usage (garment_id INT, fabric_id INT, usage_amount DECIMAL(10, 2));\n```\n\nGiven this assumed schema, the SQL query to answer the question would be:\n\n```sql\nSELECT g.name AS garment_name, g.production_date\nFROM garments g\nJOIN fabric_usage fu ON g.id = fu.garment_id\nJOIN fabrics f ON fu.fabric_id = f.id\nWHERE f.sustainability_score > 70 AND g.production_date >= '2021-01-01';\n```\n\nThis query joins the `garments`, `fabric_usage`, and `fabrics` tables to find garments made from sustainable fabrics (with a sustainability score over 70) produced after January 1, 2021.", "latency_sec": 5.893407106399536, "total_duration_sec": 5.887268704, "load_duration_sec": 0.024315281, "tokens_prompt": 187, "prompt_eval_sec": 0.037535743, "tokens_completion": 237, "completion_eval_sec": 5.822831875, "tokens_total": 424, "tokens_per_sec": 71.94480074854945, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL is a SELECT query joining 'garments' and 'fabrics' tables, while the Generated SQL contains DDL statements creating tables ('garments' and 'fabric_usage') without any query logic. They serve entirely different purposes and cannot be semantically equivalent."}
{"example_id": 1388, "sql_complexity": "aggregation", "prompt": "What was the total donation amount by each organization in the last 30 days?", "context": "CREATE TABLE organization_donations (id INT, organization TEXT, donation_date DATE, donation_amount DECIMAL(10,2)); INSERT INTO organization_donations (id, organization, donation_date, donation_amount) VALUES (1, 'Organization A', '2021-03-15', 100.00), (2, 'Organization B', '2021-03-25', 200.00);", "reference_sql": "SELECT organization, SUM(donation_amount) FROM organization_donations WHERE donation_date >= DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY) GROUP BY organization;", "generated_sql": "SELECT organization, SUM(donation_amount) AS total_donation\nFROM organization_donations\nWHERE donation_date >= CURRENT_DATE - INTERVAL '30 DAYS'\nGROUP BY organization;", "raw_model_output": "```sql\nSELECT organization, SUM(donation_amount) AS total_donation\nFROM organization_donations\nWHERE donation_date >= CURRENT_DATE - INTERVAL '30 DAYS'\nGROUP BY organization;\n```", "latency_sec": 1.034134864807129, "total_duration_sec": 1.028876262, "load_duration_sec": 0.014418741, "tokens_prompt": 183, "prompt_eval_sec": 0.038891635, "tokens_completion": 40, "completion_eval_sec": 0.973297799, "tokens_total": 223, "tokens_per_sec": 215.639185553995, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of donation_amount for each organization where donation_date is within the last 30 days. The date calculation syntax differs (DATE_SUB vs. CURRENT_DATE - INTERVAL '30 DAYS'), but both achieve the same logical result of filtering records from the past 30 days."}
{"example_id": 1628, "sql_complexity": "window functions", "prompt": "What is the ranking of national security measures for Russia based on the publication date?", "context": "CREATE TABLE national_security (id INT, title VARCHAR(255), description TEXT, agency VARCHAR(255), date DATE); INSERT INTO national_security (id, title, description, agency, date) VALUES (1, 'National Cyber Strategy', 'Outlines the approach to protecting the American people and the American way of life in the digital age', 'White House', '2018-09-20'); INSERT INTO national_security (id, title, description, agency, date) VALUES (2, 'Cybersecurity and Infrastructure Security Agency Act of 2018', 'Establishes the Cybersecurity and Infrastructure Security Agency within the Department of Homeland Security', 'Congress', '2018-11-16'); INSERT INTO national_security (id, title, description, agency, date) VALUES (3, 'Russian Military Doctrine', 'Outlines the country\u2019s stance on military security', 'Russian Government', '2014-12-26');", "reference_sql": "SELECT title, description, agency, date, ROW_NUMBER() OVER (PARTITION BY agency ORDER BY date DESC) as ranking FROM national_security WHERE agency = 'Russian Government';", "generated_sql": "SELECT id, title, description, agency, date,\n       RANK() OVER (PARTITION BY agency ORDER BY date) AS rank\nFROM national_security\nWHERE agency = 'Russian Government'\nORDER BY date;", "raw_model_output": "To determine the ranking of national security measures for Russia based on the publication date, you can use the `RANK()` window function. Here's the corresponding SQL query:\n\n```sql\nSELECT id, title, description, agency, date,\n       RANK() OVER (PARTITION BY agency ORDER BY date) AS rank\nFROM national_security\nWHERE agency = 'Russian Government'\nORDER BY date;\n```\n\nThis query ranks all entries from the \"national_security\" table where the `agency` is 'Russian Government' based on their publication dates.", "latency_sec": 2.8674161434173584, "total_duration_sec": 2.86172828, "load_duration_sec": 0.014570901, "tokens_prompt": 292, "prompt_eval_sec": 0.068357978, "tokens_completion": 111, "completion_eval_sec": 2.775493982, "tokens_total": 403, "tokens_per_sec": 140.5446505995145, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL uses ROW_NUMBER() with DESC ordering and excludes the 'id' column, while the Generated SQL uses RANK() with ASC ordering and includes the 'id' column. Although both filter for 'Russian Government', the ranking function, ordering direction, and selected columns differ, leading to different result sets."}
{"example_id": 2300, "sql_complexity": "aggregation", "prompt": "What is the minimum capacity for schools in each location ('community_development')?", "context": "CREATE TABLE community_development.schools (id INT, name VARCHAR(50), capacity INT, location VARCHAR(50));", "reference_sql": "SELECT location, MIN(capacity) FROM community_development.schools GROUP BY location;", "generated_sql": "SELECT location, MIN(capacity) AS min_capacity\nFROM community_development.schools\nGROUP BY location;", "raw_model_output": "```sql\nSELECT location, MIN(capacity) AS min_capacity\nFROM community_development.schools\nGROUP BY location;\n```", "latency_sec": 0.7006161212921143, "total_duration_sec": 0.692887837, "load_duration_sec": 0.023736709, "tokens_prompt": 111, "prompt_eval_sec": 0.024410103, "tokens_completion": 27, "completion_eval_sec": 0.642394905, "tokens_total": 138, "tokens_per_sec": 196.96948986199877, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries group schools by location and calculate the minimum capacity per location. The generated query adds an alias 'min_capacity' for the MIN(capacity) column, but this does not affect the semantic result. The GROUP BY clause and aggregate function remain identical."}
{"example_id": 4976, "sql_complexity": "set operations", "prompt": "What is the most common hashtag used in posts made by users from Brazil?", "context": "CREATE TABLE posts (id INT, user_id INT, content TEXT, hashtags TEXT, post_date DATE); INSERT INTO posts (id, user_id, content, hashtags, post_date) VALUES (1, 1, 'Hello World', '#datascience', '2022-06-01'), (2, 1, 'I love data', '#ai', '2022-06-02'), (3, 2, 'Ol\u00e1 Mundo', '#brasil', '2022-06-03'); CREATE TABLE users (id INT, name VARCHAR(100), country VARCHAR(50)); INSERT INTO users (id, name, country) VALUES (1, 'Jo\u00e3o Silva', 'Brazil'), (2, 'Maria Souza', 'Brazil');", "reference_sql": "SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(hashtags, ' ', n.n), ' ', -1) hashtag, COUNT(*) count FROM posts JOIN users ON posts.user_id = users.id CROSS JOIN (SELECT 1 n UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5) n WHERE users.country = 'Brazil' GROUP BY hashtag ORDER BY count DESC LIMIT 1;", "generated_sql": "SELECT hashtags, COUNT(*) AS count\nFROM posts p\nJOIN users u ON p.user_id = u.id\nWHERE u.country = 'Brazil'\nGROUP BY hashtags\nORDER BY count DESC\nLIMIT 1;", "raw_model_output": "To find the most common hashtag used in posts made by users from Brazil, you can use a combination of `JOIN`, `GROUP BY`, and aggregate functions like `COUNT` to determine the frequency of each hashtag. Here is the corresponding SQL query:\n\n```sql\nSELECT hashtags, COUNT(*) AS count\nFROM posts p\nJOIN users u ON p.user_id = u.id\nWHERE u.country = 'Brazil'\nGROUP BY hashtags\nORDER BY count DESC\nLIMIT 1;\n```\n\nThis query joins the `posts` and `users` tables on the user ID, filters for users from Brazil, groups by hashtag, counts the occurrences of each hashtag, orders them in descending order, and limits the result to just one row (the most common hashtag).", "latency_sec": 3.8779890537261963, "total_duration_sec": 3.87292897, "load_duration_sec": 0.013881241, "tokens_prompt": 255, "prompt_eval_sec": 0.060563403, "tokens_completion": 153, "completion_eval_sec": 3.796110608, "tokens_total": 408, "tokens_per_sec": 105.20916752149417, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL splits multi-tag entries in the 'hashtags' column into individual rows using SUBSTRING_INDEX, while the Generated SQL treats the entire 'hashtags' string as a single group. If any post contains multiple hashtags (e.g., '#a #b'), the Reference SQL would count them separately, but the Generated SQL would count the entire string as one hashtag. The sample data only has single hashtags, but semantically the queries differ in handling multi-tag cases."}
{"example_id": 4637, "sql_complexity": "single join", "prompt": "What is the total value of transactions for each customer in the last 30 days?", "context": "CREATE TABLE transactions (id INT, customer_id INT, value DECIMAL(10, 2), transaction_date DATE); INSERT INTO transactions (id, customer_id, value, transaction_date) VALUES (1, 1, 100, '2022-01-01'), (2, 1, 200, '2022-01-15'), (3, 2, 50, '2022-01-05'), (4, 2, 150, '2022-01-30'), (5, 3, 300, '2022-01-20');", "reference_sql": "SELECT c.id, SUM(t.value) FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE t.transaction_date >= CURDATE() - INTERVAL 30 DAY GROUP BY c.id;", "generated_sql": "SELECT \n    customer_id,\n    SUM(value) AS total_value\nFROM \n    transactions\nWHERE \n    transaction_date >= CURRENT_DATE - INTERVAL '30 DAYS'\nGROUP BY \n    customer_id;", "raw_model_output": "To calculate the total value of transactions for each customer in the last 30 days, you can use a `WHERE` clause to filter transactions that occurred within the last 30 days and then group by `customer_id` to sum up the transaction values. Here is the corresponding SQL query:\n\n```sql\nSELECT \n    customer_id,\n    SUM(value) AS total_value\nFROM \n    transactions\nWHERE \n    transaction_date >= CURRENT_DATE - INTERVAL '30 DAYS'\nGROUP BY \n    customer_id;\n```\n\nThis query will return the total value of transactions for each customer who has made a transaction in the last 30 days.", "latency_sec": 3.338754892349243, "total_duration_sec": 3.332911749, "load_duration_sec": 0.020812368, "tokens_prompt": 241, "prompt_eval_sec": 0.053534468, "tokens_completion": 132, "completion_eval_sec": 3.25653734, "tokens_total": 373, "tokens_per_sec": 111.71829380309693, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the total transaction value per customer for the last 30 days. The Reference query uses an INNER JOIN with customers (which is redundant since transactions.customer_id references customers.id) and groups by c.id. The Generated query directly groups by customer_id from transactions. The date conditions (CURDATE() - INTERVAL 30 DAY vs CURRENT_DATE - INTERVAL '30 DAYS') are functionally equivalent in most SQL dialects. Both return the same customer_id and SUM(value) results, assuming foreign key constraints ensure all customer_ids in transactions exist in customers."}
{"example_id": 4947, "sql_complexity": "aggregation", "prompt": "What is the total revenue for drugs approved between 2017 and 2019?", "context": "CREATE TABLE drug_sales_3 (drug_name TEXT, revenue FLOAT, year INT); INSERT INTO drug_sales_3 (drug_name, revenue, year) VALUES ('DrugG', 20000000, 2019), ('DrugG', 19000000, 2018), ('DrugH', 15000000, 2017), ('DrugH', 16000000, 2018);", "reference_sql": "SELECT drug_name, SUM(revenue) FROM drug_sales_3 WHERE year BETWEEN 2017 AND 2019 GROUP BY drug_name;", "generated_sql": "SELECT SUM(revenue) AS total_revenue\nFROM drug_sales_3\nWHERE year BETWEEN 2017 AND 2019;", "raw_model_output": "To find the total revenue for drugs approved between 2017 and 2019, you can use a `WHERE` clause to filter the years and then sum up the revenues. Here is the corresponding SQL query:\n\n```sql\nSELECT SUM(revenue) AS total_revenue\nFROM drug_sales_3\nWHERE year BETWEEN 2017 AND 2019;\n```\n\nThis query sums up the revenue for all entries in the `drug_sales_3` table where the `year` is between 2017 and 2019.", "latency_sec": 3.0286641120910645, "total_duration_sec": 3.021305474, "load_duration_sec": 0.013393573, "tokens_prompt": 202, "prompt_eval_sec": 0.046996953, "tokens_completion": 121, "completion_eval_sec": 2.958566677, "tokens_total": 323, "tokens_per_sec": 106.64767965206707, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query groups results by drug_name and calculates per-drug revenue sums, while the generated query calculates a single total revenue for all drugs combined. The absence of a GROUP BY clause in the generated query changes the result structure from per-drug totals to a single aggregate value."}
{"example_id": 4767, "sql_complexity": "window functions", "prompt": "List the top 2 AI algorithms with the highest explainability scores, by algorithm subtype, ordered by scores in descending order for the European region.", "context": "CREATE TABLE ai_algorithms (algorithm_id INT, algorithm_name VARCHAR(50), algorithm_subtype VARCHAR(50), region VARCHAR(50), explainability_score FLOAT); INSERT INTO ai_algorithms (algorithm_id, algorithm_name, algorithm_subtype, region, explainability_score) VALUES (1, 'AlgoA', 'Tree-based', 'Europe', 0.85), (2, 'AlgoB', 'Computer Vision', 'Europe', 0.92), (3, 'AlgoC', 'Tree-based', 'Europe', 0.78), (4, 'AlgoD', 'Transformer', 'Europe', 0.90), (5, 'AlgoE', 'Tree-based', 'Europe', 0.80);", "reference_sql": "SELECT algorithm_subtype, region, * FROM (SELECT algorithm_subtype, region, algorithm_id, algorithm_name, explainability_score, RANK() OVER (PARTITION BY algorithm_subtype ORDER BY explainability_score DESC) AS rank FROM ai_algorithms WHERE region = 'Europe') ranked WHERE rank <= 2 ORDER BY algorithm_subtype, region, explainability_score DESC;", "generated_sql": "SELECT algorithm_name, algorithm_subtype, explainability_score\nFROM ai_algorithms\nWHERE region = 'Europe'\nORDER BY explainability_score DESC\nLIMIT 2;", "raw_model_output": "```sql\nSELECT algorithm_name, algorithm_subtype, explainability_score\nFROM ai_algorithms\nWHERE region = 'Europe'\nORDER BY explainability_score DESC\nLIMIT 2;\n```", "latency_sec": 1.0405378341674805, "total_duration_sec": 1.035858249, "load_duration_sec": 0.014730335, "tokens_prompt": 259, "prompt_eval_sec": 0.062314843, "tokens_completion": 38, "completion_eval_sec": 0.956328289, "tokens_total": 297, "tokens_per_sec": 285.42931381022345, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL selects top 2 algorithms per subtype in Europe using window function ranking, while the Generated SQL returns only the top 2 overall algorithms in Europe without considering subtypes. The Reference includes multiple subtypes' top entries, whereas the Generated focuses on global top 2."}
{"example_id": 4495, "sql_complexity": "basic SQL", "prompt": "Which countries are the top 3 sources of sustainable textiles?", "context": "CREATE TABLE Textile_Sources (Source_ID INT, Source_Country TEXT, Sustainable BOOLEAN, Quantity INT); INSERT INTO Textile_Sources (Source_ID, Source_Country, Sustainable, Quantity) VALUES (1, 'India', true, 1000), (2, 'Bangladesh', false, 800), (3, 'China', true, 1200), (4, 'Vietnam', false, 900), (5, 'Italy', true, 1100), (6, 'USA', false, 700);", "reference_sql": "SELECT Source_Country FROM Textile_Sources WHERE Sustainable = true ORDER BY Quantity DESC LIMIT 3;", "generated_sql": "SELECT Source_Country, Quantity \nFROM Textile_Sources \nWHERE Sustainable = true \nORDER BY Quantity DESC \nLIMIT 3;", "raw_model_output": "```sql\nSELECT Source_Country, Quantity \nFROM Textile_Sources \nWHERE Sustainable = true \nORDER BY Quantity DESC \nLIMIT 3;\n```", "latency_sec": 0.876885175704956, "total_duration_sec": 0.872013557, "load_duration_sec": 0.026929629, "tokens_prompt": 205, "prompt_eval_sec": 0.046268448, "tokens_completion": 32, "completion_eval_sec": 0.79662966, "tokens_total": 237, "tokens_per_sec": 270.2748393590622, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL selects only 'Source_Country', while the Generated SQL includes both 'Source_Country' and 'Quantity'. Although both filter and sort identically, the additional column in the Generated SQL makes the result sets structurally different."}
{"example_id": 2513, "sql_complexity": "single join", "prompt": "What is the total number of concert ticket sales for artists who released their first album between 2015 and 2017?", "context": "CREATE TABLE ConcertTicketSales (id INT, year INT, artist_id INT); CREATE TABLE ArtistAlbums (id INT, artist_id INT, year INT);", "reference_sql": "SELECT COUNT(DISTINCT cts.artist_id) FROM ConcertTicketSales cts JOIN ArtistAlbums a ON cts.artist_id = a.artist_id WHERE a.year BETWEEN 2015 AND 2017;", "generated_sql": "SELECT SUM(T1.id) AS total_ticket_sales\nFROM ConcertTicketSales T1\nJOIN (\n    SELECT artist_id, MIN(year) AS min_album_year\n    FROM ArtistAlbums\n    WHERE year BETWEEN 2015 AND 2017\n    GROUP BY artist_id\n) T2 ON T1.artist_id = T2.artist_id;", "raw_model_output": "To find the total number of concert ticket sales for artists who released their first album between 2015 and 2017, we need to follow these steps:\n\n1. Identify the artists who released their first album in the specified years.\n2. Calculate the total number of concert ticket sales for those artists.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT SUM(T1.id) AS total_ticket_sales\nFROM ConcertTicketSales T1\nJOIN (\n    SELECT artist_id, MIN(year) AS min_album_year\n    FROM ArtistAlbums\n    WHERE year BETWEEN 2015 AND 2017\n    GROUP BY artist_id\n) T2 ON T1.artist_id = T2.artist_id;\n```\n\nThis query first finds the artists who released their first album between 2015 and 2017, then sums up the concert ticket sales for those artists.", "latency_sec": 4.670628786087036, "total_duration_sec": 4.665694579, "load_duration_sec": 0.023400147, "tokens_prompt": 130, "prompt_eval_sec": 0.02738677, "tokens_completion": 191, "completion_eval_sec": 4.612807097, "tokens_total": 321, "tokens_per_sec": 68.72736299579219, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query counts distinct artist_ids from ConcertTicketSales joined with ArtistAlbums where album year is between 2015-2017. The generated query sums T1.id (ticket sales IDs) from ConcertTicketSales joined with a subquery that finds minimum album years for artists with albums in 2015-2017. The aggregation (COUNT(DISTINCT) vs SUM) and target columns (artist_ids vs ticket sales IDs) differ, making them semantically distinct."}
{"example_id": 873, "sql_complexity": "subqueries", "prompt": "Identify attorneys who have never handled cases in the 'West' region but have in the 'North' or 'South'.", "context": "CREATE TABLE attorney_regions(attorney_id INT, region VARCHAR(20)); INSERT INTO attorney_regions(attorney_id, region) VALUES (1, 'North'), (2, 'South'), (3, 'East'), (4, 'West'), (5, 'West'), (6, 'North'); CREATE TABLE handled_cases(attorney_id INT, case_id INT); INSERT INTO handled_cases(attorney_id, case_id) VALUES (1, 101), (2, 102), (3, 103), (4, 104), (5, 105), (6, 106), (1, 107), (1, 108);", "reference_sql": "SELECT h.attorney_id FROM attorney_regions h LEFT JOIN handled_cases i ON h.attorney_id = i.attorney_id WHERE h.region IN ('North', 'South') AND h.region != 'West' AND i.attorney_id IS NOT NULL AND h.attorney_id NOT IN (SELECT attorney_id FROM attorney_regions WHERE region = 'West');", "generated_sql": "SELECT a.attorney_id\nFROM attorney_regions a\nJOIN handled_cases h ON a.attorney_id = h.attorney_id\nWHERE a.region IN ('North', 'South')\nEXCEPT\nSELECT a.attorney_id\nFROM attorney_regions a\nJOIN handled_cases h ON a.attorney_id = h.attorney_id\nWHERE a.region = 'West';", "raw_model_output": "To identify attorneys who have never handled cases in the 'West' region but have handled cases in either the 'North' or 'South' regions, we need to follow these steps:\n\n1. Identify attorneys who have handled cases in the 'North' or 'South'.\n2. Identify attorneys who have not handled any cases in the 'West'.\n3. Find the intersection of these two groups.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT a.attorney_id\nFROM attorney_regions a\nJOIN handled_cases h ON a.attorney_id = h.attorney_id\nWHERE a.region IN ('North', 'South')\nEXCEPT\nSELECT a.attorney_id\nFROM attorney_regions a\nJOIN handled_cases h ON a.attorney_id = h.attorney_id\nWHERE a.region = 'West';\n```\n\nThis query uses the `EXCEPT` operator to find attorneys who are in the first set (handled cases in 'North' or 'South') but not in the second set (handled cases in 'West').", "latency_sec": 5.438238143920898, "total_duration_sec": 5.433135054, "load_duration_sec": 0.018430653, "tokens_prompt": 245, "prompt_eval_sec": 0.056985139, "tokens_completion": 209, "completion_eval_sec": 5.355052161, "tokens_total": 454, "tokens_per_sec": 83.48292001656844, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve attorney_ids from North/South regions who have handled cases, excluding those in the West region. The Reference SQL uses a LEFT JOIN with explicit NOT IN and region filters, while the Generated SQL uses EXCEPT to subtract West-region cases. Both achieve the same result by ensuring only North/South attorneys with cases are included, and those also in West are excluded."}
{"example_id": 471, "sql_complexity": "set operations", "prompt": "Find the number of donations made by first-time donors in the last quarter.", "context": "CREATE TABLE Donations (DonationID INT, DonorID INT, DonationDate DATE, DonationType TEXT, DonationAmount FLOAT); INSERT INTO Donations (DonationID, DonorID, DonationDate, DonationType, DonationAmount) VALUES (1, 1, '2021-01-01', 'Individual', 100), (2, 2, '2021-02-01', 'Corporate', 5000);", "reference_sql": "SELECT COUNT(*) FROM (SELECT DonationID FROM Donations WHERE DonationType = 'Individual' AND DonationDate >= DATEADD(quarter, -1, CURRENT_DATE) EXCEPT SELECT DonationID FROM PreviousDonations) AS FirstTimeDonors;", "generated_sql": "WITH FirstTimeDonors AS (\n    SELECT DonorID, MIN(DonationDate) AS FirstDonationDate\n    FROM Donations\n    WHERE DonationDate >= '2023-07-01' AND DonationDate <= '2023-09-30'\n    GROUP BY DonorID\n)\nSELECT COUNT(*) AS NumberOfFirstTimeDonors\nFROM (\n    SELECT D.DonorID, D.DonationDate\n    FROM Donations D\n    JOIN FirstTimeDonors FT ON D.DonorID = FT.DonorID AND D.DonationDate = FT.FirstDonationDate\n) AS FirstQuarterDonations;", "raw_model_output": "To find the number of donations made by first-time donors in the last quarter, we need to follow these steps:\n\n1. Identify the start and end dates for the last quarter.\n2. Determine which donors are making their first donation within this period.\n3. Count the number of such donations.\n\nAssuming today's date is `2023-10-15`, the last quarter would be from `2023-07-01` to `2023-09-30`.\n\nHere\u2019s how we can write the SQL query:\n\n```sql\nWITH FirstTimeDonors AS (\n    SELECT DonorID, MIN(DonationDate) AS FirstDonationDate\n    FROM Donations\n    WHERE DonationDate >= '2023-07-01' AND DonationDate <= '2023-09-30'\n    GROUP BY DonorID\n)\nSELECT COUNT(*) AS NumberOfFirstTimeDonors\nFROM (\n    SELECT D.DonorID, D.DonationDate\n    FROM Donations D\n    JOIN FirstTimeDonors FT ON D.DonorID = FT.DonorID AND D.DonationDate = FT.FirstDonationDate\n) AS FirstQuarterDonations;\n```\n\nThis query uses a Common Table Expression (CTE) to find the first donation date for each donor within the last quarter. Then, it counts the number of donations that match these first-time donation dates.", "latency_sec": 7.740746974945068, "total_duration_sec": 7.735031454, "load_duration_sec": 0.018443891, "tokens_prompt": 187, "prompt_eval_sec": 0.050620748, "tokens_completion": 301, "completion_eval_sec": 7.662724509, "tokens_total": 488, "tokens_per_sec": 63.04301142764882, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL counts unique 'Individual' donations in the last quarter not present in PreviousDonations, while the Generated SQL identifies first-time donors in a specific Q3 2023 period. Key differences include: 1) Different date ranges (dynamic vs. fixed dates), 2) Different logic (EXCEPT with PreviousDonations vs. first donation date calculation), 3) Different focus (donation IDs vs. donor IDs)."}
{"example_id": 1301, "sql_complexity": "multiple_joins", "prompt": "What is the total quantity of corn sold by farmers in 'Summerfield'?", "context": "CREATE TABLE farmers (id INT, name VARCHAR(50), location VARCHAR(50), crops VARCHAR(50)); CREATE TABLE crops (id INT, name VARCHAR(50), yield INT); CREATE TABLE sales (id INT, farmer_id INT, crop_name VARCHAR(50), quantity INT, price DECIMAL(5,2)); INSERT INTO farmers VALUES (1, 'Jane Doe', 'Summerfield', 'Corn'); INSERT INTO crops VALUES (1, 'Corn', 100); INSERT INTO sales VALUES (1, 1, 'Corn', 50, 2.50);", "reference_sql": "SELECT SUM(quantity) FROM sales INNER JOIN farmers ON sales.farmer_id = farmers.id INNER JOIN crops ON sales.crop_name = crops.name WHERE farmers.location = 'Summerfield' AND crops.name = 'Corn';", "generated_sql": "SELECT SUM(s.quantity) AS total_quantity_sold\nFROM sales s\nJOIN farmers f ON s.farmer_id = f.id\nWHERE f.location = 'Summerfield' AND s.crop_name = 'Corn';", "raw_model_output": "```sql\nSELECT SUM(s.quantity) AS total_quantity_sold\nFROM sales s\nJOIN farmers f ON s.farmer_id = f.id\nWHERE f.location = 'Summerfield' AND s.crop_name = 'Corn';\n```", "latency_sec": 1.2933118343353271, "total_duration_sec": 1.288066951, "load_duration_sec": 0.014019752, "tokens_prompt": 211, "prompt_eval_sec": 0.048507849, "tokens_completion": 48, "completion_eval_sec": 1.22353717, "tokens_total": 259, "tokens_per_sec": 200.26106088568199, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the total quantity sold for 'Corn' by farmers in 'Summerfield'. The Reference SQL joins with the crops table but filters on crops.name = 'Corn', while the Generated SQL directly uses sales.crop_name = 'Corn'. Since the sales.crop_name is equivalent to crops.name (as per the data and schema), the WHERE conditions are functionally identical. The missing join in the Generated SQL does not affect the result because the filter on sales.crop_name achieves the same outcome."}
{"example_id": 4667, "sql_complexity": "aggregation", "prompt": "Find the number of unique organizations in each country in the Philanthropy Trends table?", "context": "CREATE TABLE PhilanthropyTrends (OrgID INT, Name TEXT, Country TEXT);", "reference_sql": "SELECT Country, COUNT(DISTINCT OrgID) as UniqueOrganizations FROM PhilanthropyTrends GROUP BY Country;", "generated_sql": "SELECT Country, COUNT(DISTINCT OrgID) AS UniqueOrganizationsCount\nFROM PhilanthropyTrends\nGROUP BY Country;", "raw_model_output": "```sql\nSELECT Country, COUNT(DISTINCT OrgID) AS UniqueOrganizationsCount\nFROM PhilanthropyTrends\nGROUP BY Country;\n```", "latency_sec": 0.8495790958404541, "total_duration_sec": 0.844204148, "load_duration_sec": 0.021149639, "tokens_prompt": 104, "prompt_eval_sec": 0.026850156, "tokens_completion": 32, "completion_eval_sec": 0.792281529, "tokens_total": 136, "tokens_per_sec": 160.07926827043775, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are semantically equivalent. The only difference is the column alias name ('UniqueOrganizations' vs 'UniqueOrganizationsCount'), which does not affect the query's logic or result set. Both queries group by Country and count distinct OrgID values, producing identical data output."}
{"example_id": 1006, "sql_complexity": "subqueries", "prompt": "What is the average word count of news articles written by investigative journalists?", "context": "CREATE TABLE reporters (id INT, name VARCHAR(50), gender VARCHAR(10), age INT, position VARCHAR(20), country VARCHAR(50)); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (1, 'Anna Smith', 'Female', 35, 'News Reporter', 'USA'); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (2, 'Mike Johnson', 'Male', 40, 'Investigative Journalist', 'Canada'); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (3, 'Sofia Rodriguez', 'Female', 32, 'Investigative Journalist', 'Mexico'); CREATE TABLE news_articles (id INT, title VARCHAR(100), content TEXT, publication_date DATE, reporter_id INT); INSERT INTO news_articles (id, title, content, publication_date, reporter_id) VALUES (1, 'News Article 1', 'Content of News Article 1', '2021-01-01', 2); INSERT INTO news_articles (id, title, content, publication_date, reporter_id) VALUES (2, 'News Article 2', 'Content of News Article 2', '2021-02-01', 3);", "reference_sql": "SELECT AVG(LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1) AS avg_word_count FROM news_articles WHERE reporter_id IN (SELECT id FROM reporters WHERE position = 'Investigative Journalist');", "generated_sql": "SELECT AVG(LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1) AS avg_word_count\nFROM news_articles na\nJOIN reporters r ON na.reporter_id = r.id\nWHERE r.position = 'Investigative Journalist';", "raw_model_output": "To find the average word count of news articles written by investigative journalists, we need to follow these steps:\n\n1. Identify reporters who are investigative journalists.\n2. Retrieve their corresponding news articles.\n3. Calculate the word count for each article's content.\n4. Compute the average word count.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT AVG(LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1) AS avg_word_count\nFROM news_articles na\nJOIN reporters r ON na.reporter_id = r.id\nWHERE r.position = 'Investigative Journalist';\n```\n\nExplanation:\n- `LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1` calculates the word count of each article's content by counting spaces and adding one.\n- The query joins the `news_articles` table with the `reporters` table on `reporter_id`.\n- It filters for reporters whose position is \"Investigative Journalist\".\n- Finally, it computes the average word count using `AVG`.", "latency_sec": 5.6979758739471436, "total_duration_sec": 5.693800003, "load_duration_sec": 0.015026932, "tokens_prompt": 365, "prompt_eval_sec": 0.095120752, "tokens_completion": 216, "completion_eval_sec": 5.581390349, "tokens_total": 581, "tokens_per_sec": 101.96603370268843, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average word count of news articles written by investigative journalists. The Reference SQL uses a subquery with IN to filter reporter_ids, while the Generated SQL uses a JOIN to achieve the same filtering. Since both approaches ultimately select the same subset of news_articles based on the reporter's position, the result will be identical."}
{"example_id": 3635, "sql_complexity": "set operations", "prompt": "Which brands have certifications related to cruelty-free, vegan, or organic products?", "context": "CREATE TABLE brands (brand_name VARCHAR(50), is_cruelty_free BOOLEAN, is_vegan BOOLEAN, is_organic BOOLEAN); INSERT INTO brands (brand_name, is_cruelty_free, is_vegan, is_organic) VALUES ('Lush', TRUE, TRUE, FALSE), ('The Body Shop', TRUE, FALSE, FALSE), ('Est\u00e9e Lauder', FALSE, FALSE, FALSE), ('Urban Decay', TRUE, TRUE, FALSE), ('Maybelline', FALSE, FALSE, FALSE), ('Kat Von D', TRUE, TRUE, FALSE), ('Tarte', TRUE, TRUE, TRUE);", "reference_sql": "SELECT brand_name, 'Cruelty-free' as certification FROM brands WHERE is_cruelty_free = TRUE UNION SELECT brand_name, 'Vegan' as certification FROM brands WHERE is_vegan = TRUE UNION SELECT brand_name, 'Organic' as certification FROM brands WHERE is_organic = TRUE;", "generated_sql": "SELECT brand_name\nFROM brands\nWHERE is_cruelty_free = TRUE \n   OR is_vegan = TRUE \n   OR is_organic = TRUE;", "raw_model_output": "To determine which brands have any of the certifications (cruelty-free, vegan, or organic), you can use a `WHERE` clause with logical OR conditions. Here is the corresponding SQL query:\n\n```sql\nSELECT brand_name\nFROM brands\nWHERE is_cruelty_free = TRUE \n   OR is_vegan = TRUE \n   OR is_organic = TRUE;\n```\n\nThis query selects the names of all brands that have at least one of the specified certifications (cruelty-free, vegan, or organic).", "latency_sec": 2.8444440364837646, "total_duration_sec": 2.840817777, "load_duration_sec": 0.027604123, "tokens_prompt": 211, "prompt_eval_sec": 0.04811059, "tokens_completion": 109, "completion_eval_sec": 2.763048433, "tokens_total": 320, "tokens_per_sec": 112.50001613516592, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns a list of brand names with their corresponding certification type (Cruelty-free/Vegan/Organic) as separate rows, allowing multiple certifications per brand. The Generated SQL returns only brand names where any certification is true, but collapses all certifications into a single column without indicating which certification applies. The output structures differ (two columns vs one) and the Generated SQL loses certification type information."}
{"example_id": 4932, "sql_complexity": "basic SQL", "prompt": "Delete the workout row with the id of 2.", "context": "CREATE TABLE Workouts (id INT, user_id INT, workout_name TEXT, calories INT); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (1, 1, 'Running', 300); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (2, 1, 'Cycling', 400); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (3, 2, 'Yoga', 200);", "reference_sql": "DELETE FROM Workouts WHERE id = 2;", "generated_sql": "DELETE FROM Workouts WHERE id = 2;", "raw_model_output": "```sql\nDELETE FROM Workouts WHERE id = 2;\n```", "latency_sec": 0.48299169540405273, "total_duration_sec": 0.478515608, "load_duration_sec": 0.024311619, "tokens_prompt": 191, "prompt_eval_sec": 0.048021983, "tokens_completion": 15, "completion_eval_sec": 0.403731346, "tokens_total": 206, "tokens_per_sec": 426.50836848792636, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They both delete the record with id = 2 from the Workouts table, producing the same result."}
{"example_id": 365, "sql_complexity": "aggregation", "prompt": "Identify the total number of military personnel and their corresponding rank for each branch and country in the 'military_personnel' table, sorted by the total number of personnel in descending order.", "context": "CREATE TABLE military_personnel (id INT, branch VARCHAR(255), rank VARCHAR(255), country VARCHAR(255), personnel INT);", "reference_sql": "SELECT branch, country, SUM(personnel) as total_personnel FROM military_personnel GROUP BY branch, country ORDER BY total_personnel DESC;", "generated_sql": "SELECT branch, country, rank, SUM(personnel) AS total_personnel\nFROM military_personnel\nGROUP BY branch, country, rank\nORDER BY total_personnel DESC;", "raw_model_output": "```sql\nSELECT branch, country, rank, SUM(personnel) AS total_personnel\nFROM military_personnel\nGROUP BY branch, country, rank\nORDER BY total_personnel DESC;\n```", "latency_sec": 1.0744009017944336, "total_duration_sec": 1.069567949, "load_duration_sec": 0.014018254, "tokens_prompt": 140, "prompt_eval_sec": 0.030118563, "tokens_completion": 41, "completion_eval_sec": 1.022986894, "tokens_total": 181, "tokens_per_sec": 168.46597922404848, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their GROUP BY clauses. The reference query groups by (branch, country), while the generated query groups by (branch, country, rank). This makes the generated query more granular, aggregating personnel counts within each rank, whereas the reference query aggregates all ranks within each branch/country combination. The additional 'rank' column in the generated query's SELECT and GROUP BY clauses changes the semantic meaning and results."}
{"example_id": 521, "sql_complexity": "subqueries", "prompt": "How many vessels have not had an inspection in the past year?", "context": "CREATE TABLE safety_records(id INT, vessel_name VARCHAR(50), inspection_date DATE); CREATE TABLE vessels(id INT, name VARCHAR(50), country VARCHAR(50)); INSERT INTO vessels(id, name, country) VALUES (1, 'Vessel A', 'Philippines'), (2, 'Vessel B', 'Philippines'); INSERT INTO safety_records(id, vessel_name, inspection_date) VALUES (1, 'Vessel A', '2022-01-01');", "reference_sql": "SELECT COUNT(*) FROM vessels WHERE name NOT IN (SELECT vessel_name FROM safety_records WHERE inspection_date BETWEEN DATE_SUB(NOW(), INTERVAL 1 YEAR) AND NOW());", "generated_sql": "SELECT COUNT(v.id) AS vessels_without_inspection\nFROM vessels v\nLEFT JOIN safety_records sr ON v.name = sr.vessel_name AND sr.inspection_date >= DATEADD(YEAR, -1, GETDATE())\nWHERE sr.id IS NULL;", "raw_model_output": "To determine how many vessels have not had an inspection in the past year, we need to compare the `inspection_date` from the `safety_records` table with the current date minus one year. We also need to link the `vessel_name` in `safety_records` to the `name` in the `vessels` table.\n\nHere is the SQL query:\n\n```sql\nSELECT COUNT(v.id) AS vessels_without_inspection\nFROM vessels v\nLEFT JOIN safety_records sr ON v.name = sr.vessel_name AND sr.inspection_date >= DATEADD(YEAR, -1, GETDATE())\nWHERE sr.id IS NULL;\n```\n\nNote: The `GETDATE()` function is used to get the current date. If you are using a different SQL database system (e.g., PostgreSQL), you might need to use `CURRENT_DATE` or another equivalent function.\n\nFor compatibility across databases, here's an ANSI-compliant version:\n\n```sql\nSELECT COUNT(v.id) AS vessels_without_inspection\nFROM vessels v\nLEFT JOIN safety_records sr ON v.name = sr.vessel_name AND sr.inspection_date >= CURRENT_DATE - INTERVAL '1 YEAR'\nWHERE sr.id IS NULL;\n```\n\nThis query will count the number of vessels that do not have an inspection record in the last year.", "latency_sec": 6.794198989868164, "total_duration_sec": 6.789841881, "load_duration_sec": 0.014334566, "tokens_prompt": 185, "prompt_eval_sec": 0.040853993, "tokens_completion": 265, "completion_eval_sec": 6.731414369, "tokens_total": 450, "tokens_per_sec": 66.23297325719508, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count vessels without an inspection in the last year. The Reference uses a NOT IN subquery to exclude vessels present in safety_records with recent inspections, while the Generated uses a LEFT JOIN with a date filter and checks for NULL. Both achieve the same result by identifying vessels lacking matching records in safety_records within the specified timeframe."}
{"example_id": 5687, "sql_complexity": "multiple_joins", "prompt": "List organizations with more than 200 volunteers, and their average donation amounts, excluding donations less than $10.", "context": "CREATE TABLE organizations (org_id INT, org_name TEXT, social_impact_score INT);CREATE TABLE volunteers (vol_id INT, org_id INT, vol_country TEXT);CREATE TABLE donations (donation_id INT, donor_id INT, donation_amount INT, donation_date DATE);", "reference_sql": "SELECT o.org_name, AVG(donation_amount) AS avg_donation_amount FROM organizations o JOIN volunteers v ON o.org_id = v.org_id JOIN donations don ON o.org_id = don.org_id WHERE donation_amount >= 10 GROUP BY o.org_name HAVING COUNT(v.vol_id) > 200;", "generated_sql": "SELECT \n    o.org_id,\n    o.org_name,\n    AVG(d.donation_amount) AS avg_donation_amount\nFROM \n    organizations o\nJOIN \n    volunteers v ON o.org_id = v.org_id\nLEFT JOIN \n    donations d ON o.org_id = (SELECT org_id FROM volunteers WHERE vol_id = d.donor_id)\nWHERE \n    d.donation_amount >= 10\nGROUP BY \n    o.org_id, o.org_name\nHAVING \n    COUNT(v.vol_id) > 200;", "raw_model_output": "To list the organizations with more than 200 volunteers along with their average donation amount (excluding donations less than $10), you can use the following SQL query:\n\n```sql\nSELECT \n    o.org_id,\n    o.org_name,\n    AVG(d.donation_amount) AS avg_donation_amount\nFROM \n    organizations o\nJOIN \n    volunteers v ON o.org_id = v.org_id\nLEFT JOIN \n    donations d ON o.org_id = (SELECT org_id FROM volunteers WHERE vol_id = d.donor_id)\nWHERE \n    d.donation_amount >= 10\nGROUP BY \n    o.org_id, o.org_name\nHAVING \n    COUNT(v.vol_id) > 200;\n```\n\nThis query joins the `organizations` and `volunteers` tables to count volunteers for each organization. It then left joins with the `donations` table by mapping donors back to their respective organizations through the `volunteers` table, ensuring that only donations of $10 or more are considered in calculating the average donation amount. The `HAVING` clause filters out organizations with fewer than 200 volunteers.", "latency_sec": 5.990399122238159, "total_duration_sec": 5.983509581, "load_duration_sec": 0.018258873, "tokens_prompt": 149, "prompt_eval_sec": 0.034741148, "tokens_completion": 235, "completion_eval_sec": 5.927078277, "tokens_total": 384, "tokens_per_sec": 64.10257349539144, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in several key aspects. 1) The Generated SQL uses a LEFT JOIN with a subquery in the ON clause that incorrectly attempts to link donations to volunteers via donor_id, which is not a valid relationship. 2) The Generated SQL selects org_id and org_name, while the Reference SQL only selects org_name. 3) The JOIN conditions and subquery structure in the Generated SQL would likely produce different results due to the incorrect relationship between donations and volunteers."}
{"example_id": 1281, "sql_complexity": "subqueries", "prompt": "Find the top 3 contributors with the lowest recycling rate in the 'waste_contributors' table.", "context": "CREATE TABLE waste_contributors (contributor VARCHAR(20), recycling_rate FLOAT); INSERT INTO waste_contributors (contributor, recycling_rate) VALUES ('Manufacturing', 0.4), ('Commercial', 0.38), ('Residential', 0.35), ('Institutional', 0.32), ('Agricultural', 0.2), ('Industrial', 0.15);", "reference_sql": "SELECT contributor FROM waste_contributors WHERE recycling_rate IN (SELECT MIN(recycling_rate) FROM waste_contributors) LIMIT 3;", "generated_sql": "SELECT contributor, recycling_rate\nFROM waste_contributors\nORDER BY recycling_rate ASC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT contributor, recycling_rate\nFROM waste_contributors\nORDER BY recycling_rate ASC\nLIMIT 3;\n```", "latency_sec": 0.7244548797607422, "total_duration_sec": 0.717503021, "load_duration_sec": 0.014196151, "tokens_prompt": 178, "prompt_eval_sec": 0.040007681, "tokens_completion": 26, "completion_eval_sec": 0.660128312, "tokens_total": 204, "tokens_per_sec": 281.59103582458147, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query selects contributors with the minimum recycling rate (only 'Industrial' in this case) and limits to 3 rows. The generated query returns the top 3 contributors with the lowest recycling rates (Industrial, Agricultural, Institutional). While both target low recycling rates, the reference query focuses on the absolute minimum value, whereas the generated query retrieves a ranked subset. The results differ in both content and quantity."}
{"example_id": 5669, "sql_complexity": "window functions", "prompt": "What is the total number of new and returning volunteers in each program in each month?", "context": "CREATE TABLE Volunteers (VolunteerID INT, VolunteerName TEXT, ProgramID INT, VolunteerDate DATE, IsReturning BOOLEAN); INSERT INTO Volunteers (VolunteerID, VolunteerName, ProgramID, VolunteerDate, IsReturning) VALUES (6, 'David Kim', 1, '2022-03-01', FALSE), (7, 'Emily Chen', 2, '2022-03-15', TRUE), (8, 'James Lee', 2, '2022-04-01', FALSE), (9, 'Grace Park', 3, '2022-04-15', TRUE), (10, 'Daniel Kim', 1, '2022-04-01', FALSE);", "reference_sql": "SELECT ProgramID, EXTRACT(MONTH FROM VolunteerDate) AS Month, SUM(CASE WHEN IsReturning THEN 1 ELSE 0 END) OVER (PARTITION BY ProgramID, EXTRACT(MONTH FROM VolunteerDate) ORDER BY ProgramID, EXTRACT(MONTH FROM VolunteerDate)) + COUNT(DISTINCT VolunteerID) OVER (PARTITION BY ProgramID, EXTRACT(MONTH FROM VolunteerDate) ORDER BY ProgramID, EXTRACT(MONTH FROM VolunteerDate)) AS TotalVolunteers FROM Volunteers;", "generated_sql": "SELECT \n    ProgramID,\n    DATE_FORMAT(VolunteerDate, '%Y-%m') AS MonthYear,\n    SUM(CASE WHEN IsReturning THEN 0 ELSE 1 END) AS NewVolunteers,\n    SUM(CASE WHEN IsReturning THEN 1 ELSE 0 END) AS ReturningVolunteers\nFROM \n    Volunteers\nGROUP BY \n    ProgramID, \n    DATE_FORMAT(VolunteerDate, '%Y-%m')\nORDER BY \n    MonthYear;", "raw_model_output": "To determine the total number of new and returning volunteers in each program for each month, we need to group the data by `ProgramID` and `VolunteerDate` (extracted as year-month). We also need to count the number of new (`IsReturning = FALSE`) and returning (`IsReturning = TRUE`) volunteers separately.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT \n    ProgramID,\n    DATE_FORMAT(VolunteerDate, '%Y-%m') AS MonthYear,\n    SUM(CASE WHEN IsReturning THEN 0 ELSE 1 END) AS NewVolunteers,\n    SUM(CASE WHEN IsReturning THEN 1 ELSE 0 END) AS ReturningVolunteers\nFROM \n    Volunteers\nGROUP BY \n    ProgramID, \n    DATE_FORMAT(VolunteerDate, '%Y-%m')\nORDER BY \n    MonthYear;\n```\n\nThis query uses `DATE_FORMAT` to extract the year and month from `VolunteerDate`, and then uses conditional aggregation (`SUM(CASE WHEN ... THEN ...)`) to count new and returning volunteers separately.", "latency_sec": 5.742138147354126, "total_duration_sec": 5.737497342, "load_duration_sec": 0.014083224, "tokens_prompt": 253, "prompt_eval_sec": 0.056424134, "tokens_completion": 220, "completion_eval_sec": 5.664878502, "tokens_total": 473, "tokens_per_sec": 82.37349709497148, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL calculates a cumulative total using window functions that combine returning volunteer counts and distinct volunteer counts, while the Generated SQL aggregates new and returning volunteers separately. The Reference SQL's 'TotalVolunteers' column combines returning counts with distinct counts (resulting in NewVolunteers + 2*ReturningVolunteers), whereas the Generated SQL provides separate counts. Additionally, the Reference SQL retains individual rows with cumulative values, while the Generated SQL groups data, leading to different output structures and values."}
{"example_id": 3576, "sql_complexity": "window functions", "prompt": "What is the difference in the number of eco-friendly hotels between the top 2 countries?", "context": "CREATE TABLE eco_hotel_count (country TEXT, num_hotels INT); INSERT INTO eco_hotel_count (country, num_hotels) VALUES ('France', 100), ('Italy', 120), ('Germany', 150), ('Spain', 110), ('UK', 160);", "reference_sql": "SELECT (MAX(num_hotels) OVER (PARTITION BY num_hotels <= 2) - MIN(num_hotels) OVER (PARTITION BY num_hotels <= 2)) AS hotel_difference FROM eco_hotel_count WHERE country IN ('France', 'Italy');", "generated_sql": "SELECT \n    MAX(num_hotels) - SUBQUERY.second_max AS hotel_difference\nFROM \n    (\n        SELECT \n            num_hotels,\n            DENSE_RANK() OVER (ORDER BY num_hotels DESC) AS rank_num\n        FROM \n            eco_hotel_count\n    ) AS SUBQUERY\nWHERE \n    SUBQUERY.rank_num = 1 OR SUBQUERY.rank_num = 2;", "raw_model_output": "To find the difference in the number of eco-friendly hotels between the top 2 countries, you can use a subquery to first identify the top two countries based on the number of eco-friendly hotels and then calculate the difference. Here's how you can write this as an SQL query:\n\n```sql\nSELECT \n    MAX(num_hotels) - SUBQUERY.second_max AS hotel_difference\nFROM \n    (\n        SELECT \n            num_hotels,\n            DENSE_RANK() OVER (ORDER BY num_hotels DESC) AS rank_num\n        FROM \n            eco_hotel_count\n    ) AS SUBQUERY\nWHERE \n    SUBQUERY.rank_num = 1 OR SUBQUERY.rank_num = 2;\n```\n\nThis query uses a window function `DENSE_RANK()` to assign ranks based on the number of hotels in descending order. Then, it calculates the difference between the top two ranked countries' hotel counts.", "latency_sec": 4.7039759159088135, "total_duration_sec": 4.695953729, "load_duration_sec": 0.020022066, "tokens_prompt": 156, "prompt_eval_sec": 0.04577719, "tokens_completion": 184, "completion_eval_sec": 4.62734626, "tokens_total": 340, "tokens_per_sec": 72.27928162857347, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL filters to only 'France' and 'Italy' and calculates MAX/MIN over a partition based on a boolean condition, while the Generated SQL processes all countries and attempts to subtract a non-existent 'second_max' column. Additionally, the Generated SQL contains a syntax error (missing 'second_max' column) and operates on different data subsets, leading to different results."}
{"example_id": 1970, "sql_complexity": "multiple_joins", "prompt": "List all players who have played a specific VR game, 'CyberSphere', and their ages.", "context": "CREATE TABLE Players (PlayerID INT, Age INT, Gender VARCHAR(10), Country VARCHAR(50)); CREATE TABLE VRPlayers (PlayerID INT, VRGameID INT); CREATE TABLE VRGames (VRGameID INT, Title VARCHAR(50)); INSERT INTO Players (PlayerID, Age, Gender, Country) VALUES (1, 25, 'Male', 'USA'); INSERT INTO Players (PlayerID, Age, Gender, Country) VALUES (2, 28, 'Female', 'Canada'); INSERT INTO VRPlayers (PlayerID, VRGameID) VALUES (1, 1); INSERT INTO VRPlayers (PlayerID, VRGameID) VALUES (2, 1); INSERT INTO VRGames (VRGameID, Title) VALUES (1, 'CyberSphere');", "reference_sql": "SELECT Players.Age, Players.PlayerID FROM Players INNER JOIN VRPlayers ON Players.PlayerID = VRPlayers.PlayerID INNER JOIN VRGames ON VRPlayers.VRGameID = VRGames.VRGameID WHERE VRGames.Title = 'CyberSphere';", "generated_sql": "SELECT p.PlayerID, p.Age \nFROM Players p\nJOIN VRPlayers vp ON p.PlayerID = vp.PlayerID\nJOIN VRGames vg ON vp.VRGameID = vg.VRGameID\nWHERE vg.Title = 'CyberSphere';", "raw_model_output": "To list all players who have played the specific VR game \"CyberSphere\" along with their ages, you can use the following SQL query:\n\n```sql\nSELECT p.PlayerID, p.Age \nFROM Players p\nJOIN VRPlayers vp ON p.PlayerID = vp.PlayerID\nJOIN VRGames vg ON vp.VRGameID = vg.VRGameID\nWHERE vg.Title = 'CyberSphere';\n```\n\nThis query joins the `Players`, `VRPlayers`, and `VRGames` tables to find players who have played the game \"CyberSphere\" and retrieves their player IDs and ages.", "latency_sec": 3.2820849418640137, "total_duration_sec": 3.274931894, "load_duration_sec": 0.02121605, "tokens_prompt": 254, "prompt_eval_sec": 0.070908329, "tokens_completion": 124, "completion_eval_sec": 3.179979263, "tokens_total": 378, "tokens_per_sec": 115.17069384112901, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (PlayerID and Age) from the Players table, join with VRPlayers and VRGames on identical conditions, and apply the same WHERE filter on VRGames.Title. The differences are purely syntactic (alias names and column order in SELECT) and do not affect the result."}
{"example_id": 2414, "sql_complexity": "window functions", "prompt": "List the policy areas with the lowest citizen satisfaction scores.", "context": "CREATE TABLE Policy (Area VARCHAR(20), Score INT); INSERT INTO Policy (Area, Score) VALUES ('Transportation', 70), ('Education', 85), ('Healthcare', 75), ('PublicSafety', 80);", "reference_sql": "SELECT Area, Score FROM (SELECT Area, Score, ROW_NUMBER() OVER (ORDER BY Score) AS RN FROM Policy) X WHERE RN IN (1, 2);", "generated_sql": "SELECT Area FROM Policy WHERE Score = (SELECT MIN(Score) FROM Policy);", "raw_model_output": "```sql\nSELECT Area FROM Policy WHERE Score = (SELECT MIN(Score) FROM Policy);\n```", "latency_sec": 0.578364372253418, "total_duration_sec": 0.573645403, "load_duration_sec": 0.014991592, "tokens_prompt": 133, "prompt_eval_sec": 0.029884726, "tokens_completion": 21, "completion_eval_sec": 0.526186143, "tokens_total": 154, "tokens_per_sec": 266.26813024458374, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query selects the top 2 rows with the lowest scores (using ROW_NUMBER()), while the generated query only selects the row with the absolute minimum score. In the sample data, the reference query returns two rows (Transportation:70, Healthcare:75) but the generated query only returns one row (Transportation:70)."}
{"example_id": 1898, "sql_complexity": "single join", "prompt": "What are the total sales for each drug in Q2 2020?", "context": "CREATE TABLE drugs (drug_id INT, drug_name TEXT); INSERT INTO drugs (drug_id, drug_name) VALUES (1001, 'Ibuprofen'), (1002, 'Paracetamol'), (1003, 'Aspirin'); CREATE TABLE sales (sale_id INT, drug_id INT, sale_date DATE, revenue FLOAT); INSERT INTO sales (sale_id, drug_id, sale_date, revenue) VALUES (1, 1001, '2020-04-05', 1800.0), (2, 1002, '2020-04-10', 2300.0), (3, 1003, '2020-04-15', 1400.0), (4, 1001, '2020-05-20', 1900.0), (5, 1002, '2020-06-25', 2400.0);", "reference_sql": "SELECT drug_name, SUM(revenue) as total_sales FROM sales JOIN drugs ON sales.drug_id = drugs.drug_id WHERE sale_date BETWEEN '2020-04-01' AND '2020-06-30' GROUP BY drug_name;", "generated_sql": "SELECT d.drug_name, SUM(s.revenue) AS total_sales\nFROM drugs d\nJOIN sales s ON d.drug_id = s.drug_id\nWHERE s.sale_date BETWEEN '2020-04-01' AND '2020-06-30'\nGROUP BY d.drug_name;", "raw_model_output": "```sql\nSELECT d.drug_name, SUM(s.revenue) AS total_sales\nFROM drugs d\nJOIN sales s ON d.drug_id = s.drug_id\nWHERE s.sale_date BETWEEN '2020-04-01' AND '2020-06-30'\nGROUP BY d.drug_name;\n```", "latency_sec": 2.079218864440918, "total_duration_sec": 2.074841639, "load_duration_sec": 0.014896253, "tokens_prompt": 324, "prompt_eval_sec": 0.090468028, "tokens_completion": 75, "completion_eval_sec": 1.964876281, "tokens_total": 399, "tokens_per_sec": 191.89898996385224, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between 'drugs' and 'sales' on drug_id, filter sales within the date range '2020-04-01' to '2020-06-30', and group by drug_name to calculate total sales. The differences are purely syntactic (table aliases and join order), which do not affect the result set."}
{"example_id": 2403, "sql_complexity": "multiple_joins", "prompt": "Who is the most frequent customer ordering vegetarian items?", "context": "CREATE TABLE customers (customer_id INT, customer_name VARCHAR(50)); INSERT INTO customers VALUES (1, 'John Doe'), (2, 'Jane Smith'), (3, 'Alice Johnson'); CREATE TABLE orders (order_id INT, customer_id INT, menu_id INT, order_date DATE); INSERT INTO orders VALUES (1, 1, 1, '2022-01-01'), (2, 2, 3, '2022-01-02'), (3, 3, 2, '2022-01-03'); CREATE TABLE menu (menu_id INT, item_name VARCHAR(50), is_vegetarian BOOLEAN, price DECIMAL(5,2)); INSERT INTO menu VALUES (1, 'Veggie Burger', true, 8.99), (2, 'Cheeseburger', false, 7.99), (3, 'Tofu Stir Fry', true, 11.99);", "reference_sql": "SELECT customers.customer_name, COUNT(orders.order_id) as order_count FROM customers INNER JOIN orders ON customers.customer_id = orders.customer_id INNER JOIN menu ON orders.menu_id = menu.menu_id WHERE menu.is_vegetarian = true GROUP BY customers.customer_name ORDER BY order_count DESC LIMIT 1;", "generated_sql": "SELECT c.customer_name\nFROM customers c\nJOIN (\n    SELECT o.customer_id, COUNT(*) AS veg_order_count\n    FROM orders o\n    JOIN menu m ON o.menu_id = m.menu_id\n    WHERE m.is_vegetarian = true\n    GROUP BY o.customer_id\n) v ON c.customer_id = v.customer_id\nORDER BY v.veg_order_count DESC\nLIMIT 1;", "raw_model_output": "To determine who the most frequent customer is among those ordering vegetarian items, we need to follow these steps:\n\n1. Identify orders that contain vegetarian menu items.\n2. Count how many times each customer has ordered vegetarian items.\n3. Find the customer with the highest count of such orders.\n\nHere's the SQL query to achieve this:\n\n```sql\nSELECT c.customer_name\nFROM customers c\nJOIN (\n    SELECT o.customer_id, COUNT(*) AS veg_order_count\n    FROM orders o\n    JOIN menu m ON o.menu_id = m.menu_id\n    WHERE m.is_vegetarian = true\n    GROUP BY o.customer_id\n) v ON c.customer_id = v.customer_id\nORDER BY v.veg_order_count DESC\nLIMIT 1;\n```\n\nThis query first finds the count of vegetarian orders for each customer, then joins this result with the `customers` table to get the name of the most frequent vegetarian-ordering customer.", "latency_sec": 5.150713920593262, "total_duration_sec": 5.143913981, "load_duration_sec": 0.023977402, "tokens_prompt": 291, "prompt_eval_sec": 0.070516988, "tokens_completion": 192, "completion_eval_sec": 5.047221916, "tokens_total": 483, "tokens_per_sec": 93.77340839468867, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL groups by customer_name, which could combine multiple customers with the same name, while the Generated SQL groups by customer_id (via the subquery) ensuring accurate per-customer aggregation. Although the sample data has unique names, the schema allows non-unique customer_names, making the grouping strategies fundamentally different in general cases."}
{"example_id": 124, "sql_complexity": "set operations", "prompt": "Find the intersection of AI and accessibility research projects in the EU and those in Africa.", "context": "CREATE SCHEMA if not exists accessibility; CREATE TABLE if not exists accessibility.research (id INT PRIMARY KEY, project_name VARCHAR(255), region VARCHAR(255)); INSERT INTO accessibility.research (id, project_name, region) VALUES (1, 'AI for Accessibility EU', 'EU'), (2, 'Accessibility Africa', 'Africa'), (3, 'AI for Accessibility Africa', 'Africa'), (4, 'Accessibility EU', 'EU');", "reference_sql": "SELECT project_name FROM accessibility.research WHERE region = 'EU' INTERSECT SELECT project_name FROM accessibility.research WHERE region = 'Africa';", "generated_sql": "SELECT \n    project_name \nFROM \n    accessibility.research \nWHERE \n    region = 'EU' AND project_name LIKE '%AI%' AND project_name LIKE '%Accessibility%'\nINTERSECT\nSELECT \n    project_name \nFROM \n    accessibility.research \nWHERE \n    region = 'Africa' AND project_name LIKE '%AI%' AND project_name LIKE '%Accessibility%';", "raw_model_output": "To find the intersection of AI and accessibility research projects in both the EU and Africa, we need to identify projects that contain the word \"AI\" and also contain the word \"Accessibility\". We then filter these projects by their regions. The intersection will be the project names that appear in both regions.\n\nHere is the SQL query:\n\n```sql\nSELECT \n    project_name \nFROM \n    accessibility.research \nWHERE \n    region = 'EU' AND project_name LIKE '%AI%' AND project_name LIKE '%Accessibility%'\nINTERSECT\nSELECT \n    project_name \nFROM \n    accessibility.research \nWHERE \n    region = 'Africa' AND project_name LIKE '%AI%' AND project_name LIKE '%Accessibility%';\n```\n\nThis query will return the names of projects that contain both \"AI\" and \"Accessibility\" in both regions.", "latency_sec": 4.414112091064453, "total_duration_sec": 4.407242235, "load_duration_sec": 0.014511109, "tokens_prompt": 181, "prompt_eval_sec": 0.041516374, "tokens_completion": 168, "completion_eval_sec": 4.349183688, "tokens_total": 349, "tokens_per_sec": 79.06459845151767, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns project names present in both EU and Africa regions without any name restrictions. The Generated SQL adds LIKE conditions filtering project_names to include both 'AI' and 'Accessibility' in both regions. This makes the Generated SQL more restrictive, potentially excluding results that would be in the intersection of the Reference SQL. While both return empty sets in this specific data, they are not semantically equivalent due to differing filters."}
{"example_id": 1231, "sql_complexity": "basic SQL", "prompt": "What is the average ticket price for performances at the 'Downtown Theater'?", "context": "CREATE TABLE DowntownTheater (show_name TEXT, date DATE, ticket_price FLOAT); INSERT INTO DowntownTheater (show_name, date, ticket_price) VALUES ('Play 1', '2022-01-01', 30.0), ('Play 2', '2022-01-02', 40.0), ('Concert 1', '2022-01-03', 50.0);", "reference_sql": "SELECT AVG(ticket_price) FROM DowntownTheater WHERE show_name = 'Downtown Theater'", "generated_sql": "SELECT AVG(ticket_price) AS average_ticket_price FROM DowntownTheater;", "raw_model_output": "```sql\nSELECT AVG(ticket_price) AS average_ticket_price FROM DowntownTheater;\n```", "latency_sec": 0.5692098140716553, "total_duration_sec": 0.564178378, "load_duration_sec": 0.013907293, "tokens_prompt": 187, "prompt_eval_sec": 0.041539594, "tokens_completion": 19, "completion_eval_sec": 0.506233368, "tokens_total": 206, "tokens_per_sec": 361.90521475103657, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters for show_name = 'Downtown Theater' which doesn't exist in the data, returning NULL. The Generated SQL calculates the average of all tickets. The first returns NULL (no matching rows) while the second returns 40.0 (average of 30, 40, 50)."}
{"example_id": 1485, "sql_complexity": "set operations", "prompt": "How many public schools and public libraries exist in total, in the 'CityData' schema's 'CityEducation' and 'CityLibrary' tables?", "context": "CREATE SCHEMA CityData; CREATE TABLE CityEducation (Name varchar(255), Type varchar(255)); INSERT INTO CityEducation (Name, Type) VALUES ('SchoolA', 'Public'), ('SchoolB', 'Public'), ('SchoolC', 'Private'); CREATE TABLE CityLibrary (Name varchar(255), Type varchar(255)); INSERT INTO CityLibrary (Name, Type) VALUES ('LibraryA', 'Public'), ('LibraryB', 'Public'), ('LibraryC', 'Private');", "reference_sql": "SELECT COUNT(*) FROM CityData.CityEducation WHERE Type = 'Public' UNION ALL SELECT COUNT(*) FROM CityData.CityLibrary WHERE Type = 'Public';", "generated_sql": "SELECT (SELECT COUNT(*) FROM CityData.CityEducation WHERE Type = 'Public') + \n       (SELECT COUNT(*) FROM CityData.CityLibrary WHERE Type = 'Public') AS Total_Public;", "raw_model_output": "```sql\nSELECT (SELECT COUNT(*) FROM CityData.CityEducation WHERE Type = 'Public') + \n       (SELECT COUNT(*) FROM CityData.CityLibrary WHERE Type = 'Public') AS Total_Public;\n```", "latency_sec": 1.2107481956481934, "total_duration_sec": 1.205368942, "load_duration_sec": 0.018188446, "tokens_prompt": 205, "prompt_eval_sec": 0.04972347, "tokens_completion": 43, "completion_eval_sec": 1.13540487, "tokens_total": 248, "tokens_per_sec": 204.8320211348564, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate counts (one for CityEducation and one for CityLibrary) as two rows, while the Generated SQL returns a single row with the sum of both counts. The result set structure and values differ."}
{"example_id": 5806, "sql_complexity": "single join", "prompt": "List the top 3 countries with the most veteran employment in the IT industry", "context": "CREATE TABLE veteran_employment (employee_id INT, industry VARCHAR(255), salary DECIMAL(10,2), state VARCHAR(2), country VARCHAR(255)); CREATE TABLE countries (country_id INT, country VARCHAR(255));", "reference_sql": "SELECT country, COUNT(*) as num_veterans FROM veteran_employment JOIN countries ON veteran_employment.country = countries.country WHERE industry = 'IT' GROUP BY country ORDER BY num_veterans DESC LIMIT 3;", "generated_sql": "SELECT c.country, COUNT(ve.employee_id) AS employment_count\nFROM veteran_employment ve\nJOIN countries c ON ve.country = c.country\nWHERE ve.industry = 'IT'\nGROUP BY c.country\nORDER BY employment_count DESC\nLIMIT 3;", "raw_model_output": "To list the top 3 countries with the most veteran employment in the IT industry, you need to join the `veteran_employment` and `countries` tables on the country name, filter for the IT industry, group by country, count the number of employees, order the results by this count in descending order, and limit the result to the top 3 countries.\n\nHere is the SQL query:\n\n```sql\nSELECT c.country, COUNT(ve.employee_id) AS employment_count\nFROM veteran_employment ve\nJOIN countries c ON ve.country = c.country\nWHERE ve.industry = 'IT'\nGROUP BY c.country\nORDER BY employment_count DESC\nLIMIT 3;\n```\n\nThis query will give you the top 3 countries with the highest number of veteran employees in the IT industry.", "latency_sec": 4.257798194885254, "total_duration_sec": 4.252940753, "load_duration_sec": 0.018072383, "tokens_prompt": 138, "prompt_eval_sec": 0.028781358, "tokens_completion": 163, "completion_eval_sec": 4.20411259, "tokens_total": 301, "tokens_per_sec": 70.69381549402246, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same data by joining veteran_employment with countries on country, filtering for 'IT' industry, grouping by country, and ordering by count descending. The generated query uses table aliases and explicit column references, but the semantic logic remains identical. COUNT(*) in the reference matches COUNT(ve.employee_id) in the generated query since employee_id is non-null."}
{"example_id": 4126, "sql_complexity": "window functions", "prompt": "What is the average crime rate per capita in each neighborhood?", "context": "CREATE TABLE neighborhoods (name VARCHAR(255), population INT, crime_count INT); INSERT INTO neighborhoods (name, population, crime_count) VALUES ('Central Park', 1000, 25), ('Harlem', 2500, 75), ('Brooklyn', 5000, 120);", "reference_sql": "SELECT name, AVG(crime_count/population) OVER (PARTITION BY name) FROM neighborhoods;", "generated_sql": "SELECT name, (crime_count * 1.0 / population) AS avg_crime_rate_per_capita\nFROM neighborhoods;", "raw_model_output": "```sql\nSELECT name, (crime_count * 1.0 / population) AS avg_crime_rate_per_capita\nFROM neighborhoods;\n```", "latency_sec": 0.8567419052124023, "total_duration_sec": 0.852162931, "load_duration_sec": 0.013610638, "tokens_prompt": 154, "prompt_eval_sec": 0.035812247, "tokens_completion": 31, "completion_eval_sec": 0.800560279, "tokens_total": 185, "tokens_per_sec": 215.93434250672615, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query uses an AVG() window function that calculates the average of crime_count/population within each name group, while the generated query directly computes the ratio. If there are multiple rows with the same name, the reference query would return the average of the ratios, whereas the generated query returns individual ratios. Thus, they are not semantically equivalent."}
{"example_id": 4559, "sql_complexity": "basic SQL", "prompt": "List the top 3 energy efficient appliances in the US by energy star rating?", "context": "CREATE TABLE appliances (id INT, name VARCHAR(255), country VARCHAR(255), energy_star_rating INT); INSERT INTO appliances (id, name, country, energy_star_rating) VALUES (1, 'Fridge A', 'USA', 5), (2, 'TV B', 'USA', 4), (3, 'Laptop C', 'USA', 5), (4, 'Microwave D', 'USA', 3);", "reference_sql": "SELECT name, energy_star_rating FROM appliances WHERE country = 'USA' ORDER BY energy_star_rating DESC LIMIT 3;", "generated_sql": "SELECT name, energy_star_rating \nFROM appliances \nWHERE country = 'USA' \nORDER BY energy_star_rating DESC \nLIMIT 3;", "raw_model_output": "```sql\nSELECT name, energy_star_rating \nFROM appliances \nWHERE country = 'USA' \nORDER BY energy_star_rating DESC \nLIMIT 3;\n```", "latency_sec": 0.9344267845153809, "total_duration_sec": 0.928525577, "load_duration_sec": 0.026475835, "tokens_prompt": 181, "prompt_eval_sec": 0.03949962, "tokens_completion": 33, "completion_eval_sec": 0.860314414, "tokens_total": 214, "tokens_per_sec": 229.01740783360165, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and syntax. Both select the same columns (name, energy_star_rating) from the appliances table where country is 'USA', order by energy_star_rating descending, and limit to 3 results. The formatting differences (e.g., line breaks) do not affect semantic equivalence."}
{"example_id": 456, "sql_complexity": "window functions", "prompt": "List the intelligence operations and their corresponding threat levels, and rank them based on their threat level and budget.", "context": "CREATE TABLE intel_ops_threat (id INT, operation VARCHAR, threat VARCHAR, budget INT); INSERT INTO intel_ops_threat (id, operation, threat, budget) VALUES (1, 'Operation Red Folder', 'High', 5000000), (2, 'Operation Black Vault', 'Medium', 7000000), (3, 'Operation Blue Sail', 'Low', 6000000);", "reference_sql": "SELECT operation, threat, budget, ROW_NUMBER() OVER (PARTITION BY threat ORDER BY budget DESC) as rank FROM intel_ops_threat;", "generated_sql": "SELECT operation, threat, budget\nFROM intel_ops_threat\nORDER BY threat DESC, budget DESC;", "raw_model_output": "```sql\nSELECT operation, threat, budget\nFROM intel_ops_threat\nORDER BY threat DESC, budget DESC;\n```", "latency_sec": 0.7423090934753418, "total_duration_sec": 0.737501626, "load_duration_sec": 0.013897493, "tokens_prompt": 185, "prompt_eval_sec": 0.039929698, "tokens_completion": 26, "completion_eval_sec": 0.681388672, "tokens_total": 211, "tokens_per_sec": 284.2481681210996, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a ROW_NUMBER() window function that adds a 'rank' column based on budget ordering within threat partitions, while the Generated SQL omits this column and orders results by threat and budget. The presence of the rank column and differing ordering logic make the queries non-equivalent."}
{"example_id": 459, "sql_complexity": "set operations", "prompt": "What is the total installed capacity of hydroelectric power plants in Brazil and Canada?", "context": "CREATE TABLE hydroelectric_power (country TEXT, capacity INTEGER); INSERT INTO hydroelectric_power (country, capacity) VALUES ('Brazil', 104000), ('Canada', 78000), ('China', 350000), ('United States', 100000), ('Russia', 45000);", "reference_sql": "(SELECT capacity FROM hydroelectric_power WHERE country = 'Brazil') UNION (SELECT capacity FROM hydroelectric_power WHERE country = 'Canada');", "generated_sql": "SELECT SUM(capacity) AS total_capacity\nFROM hydroelectric_power\nWHERE country IN ('Brazil', 'Canada');", "raw_model_output": "```sql\nSELECT SUM(capacity) AS total_capacity\nFROM hydroelectric_power\nWHERE country IN ('Brazil', 'Canada');\n```", "latency_sec": 0.7987399101257324, "total_duration_sec": 0.792595447, "load_duration_sec": 0.024426094, "tokens_prompt": 162, "prompt_eval_sec": 0.036588576, "tokens_completion": 28, "completion_eval_sec": 0.729468546, "tokens_total": 190, "tokens_per_sec": 237.87467934348172, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate rows with individual capacities of Brazil and Canada, while the Generated SQL returns a single row with the summed capacity of both countries. The result structures differ (two rows vs. one row with aggregate value)."}
{"example_id": 2356, "sql_complexity": "window functions", "prompt": "Find the total billing amount for attorneys in the 'Criminal Law' practice area, for the year 2020, partitioned by attorney's last name and ordered by the total billing amount in descending order.", "context": "CREATE TABLE Attorneys (AttorneyID INT, FirstName VARCHAR(50), LastName VARCHAR(50), PracticeArea VARCHAR(50), TotalBilling FLOAT, BillingYear INT); INSERT INTO Attorneys (AttorneyID, FirstName, LastName, PracticeArea, TotalBilling, BillingYear) VALUES (1, 'Clara', 'Rivera', 'Personal Injury', 8000.00, 2020), (2, 'Jamal', 'Lee', 'Personal Injury', 6000.00, 2019), (3, 'Sophia', 'Gomez', 'Criminal Law', 9000.00, 2020);", "reference_sql": "SELECT LastName, SUM(TotalBilling) OVER (PARTITION BY PracticeArea, LastName, BillingYear) AS TotalBilling FROM Attorneys WHERE PracticeArea = 'Criminal Law' AND BillingYear = 2020 ORDER BY TotalBilling DESC;", "generated_sql": "SELECT LastName, SUM(TotalBilling) AS TotalBillingSum\nFROM Attorneys\nWHERE PracticeArea = 'Criminal Law' AND BillingYear = 2020\nGROUP BY LastName\nORDER BY TotalBillingSum DESC;", "raw_model_output": "```sql\nSELECT LastName, SUM(TotalBilling) AS TotalBillingSum\nFROM Attorneys\nWHERE PracticeArea = 'Criminal Law' AND BillingYear = 2020\nGROUP BY LastName\nORDER BY TotalBillingSum DESC;\n```", "latency_sec": 1.4916672706604004, "total_duration_sec": 1.486846152, "load_duration_sec": 0.013257155, "tokens_prompt": 263, "prompt_eval_sec": 0.065332787, "tokens_completion": 52, "completion_eval_sec": 1.405800391, "tokens_total": 315, "tokens_per_sec": 211.17309885102003, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses a window function to calculate the sum per (PracticeArea, LastName, BillingYear) partition, returning all rows with aggregated values. The Generated SQL groups by LastName, collapsing multiple rows into one per LastName. If there are multiple entries per LastName, the Reference SQL would return multiple rows with the same sum, while the Generated SQL would return a single row per LastName. Thus, they are not semantically equivalent."}
