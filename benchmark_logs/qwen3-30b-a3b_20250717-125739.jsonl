{"example_id": 2656, "sql_complexity": "multiple_joins", "prompt": "Find the drugs and their respective total sales for rare diseases indication with sales greater than the average sales for infectious diseases.", "context": "CREATE TABLE sales (id INT, drug_id INT, quarter INT, year INT, revenue FLOAT); INSERT INTO sales (id, drug_id, quarter, year, revenue) VALUES (1, 1, 1, 2022, 1500000); CREATE TABLE drugs (id INT, name VARCHAR(50), company VARCHAR(50), indication VARCHAR(50)); INSERT INTO drugs (id, name, company, indication) VALUES (1, 'DrugA', 'ABC Corp', 'Rare_Diseases');", "reference_sql": "SELECT s.drug_id, d.name, SUM(s.revenue) as total_sales FROM sales s JOIN drugs d ON s.drug_id = d.id WHERE d.indication = 'Rare_Diseases' GROUP BY s.drug_id HAVING total_sales > (SELECT AVG(s2.revenue) FROM sales s2 JOIN drugs d2 ON s2.drug_id = d2.id WHERE d2.indication = 'Infectious_Diseases')", "generated_sql": "SELECT d.name, SUM(s.revenue) AS total_sales\nFROM sales s\nJOIN drugs d ON s.drug_id = d.id\nWHERE d.indication = 'Rare_Diseases'\nGROUP BY d.name\nHAVING SUM(s.revenue) > (\n    SELECT AVG(s2.revenue)\n    FROM sales s2\n    JOIN drugs d2 ON s2.drug_id = d2.id\n    WHERE d2.indication = 'Infectious_Diseases'\n);", "raw_model_output": "\n\n```sql\nSELECT d.name, SUM(s.revenue) AS total_sales\nFROM sales s\nJOIN drugs d ON s.drug_id = d.id\nWHERE d.indication = 'Rare_Diseases'\nGROUP BY d.name\nHAVING SUM(s.revenue) > (\n    SELECT AVG(s2.revenue)\n    FROM sales s2\n    JOIN drugs d2 ON s2.drug_id = d2.id\n    WHERE d2.indication = 'Infectious_Diseases'\n);\n```", "latency_sec": 1.242159128189087, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 210, "prompt_eval_sec": null, "tokens_completion": 109, "completion_eval_sec": null, "tokens_total": 319, "tokens_per_sec": 256.81089705878685, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Reference SQL selects 'drug_id' and 'name' while the Generated SQL only selects 'name'. Second, the Reference groups by 'drug_id' (primary key) whereas the Generated groups by 'name' (which may not be unique). These differences in grouping and selected columns make the results structurally and semantically distinct."}
{"example_id": 3008, "sql_complexity": "multiple_joins", "prompt": "Who are the users who used electric vehicles and their trip details?", "context": "CREATE TABLE users (id INT, name VARCHAR(50), age INT, gender VARCHAR(10), city VARCHAR(50));CREATE TABLE vehicles (id INT, vehicle_type VARCHAR(20), is_electric BOOLEAN);CREATE TABLE trips (id INT, user_id INT, vehicle_id INT, trip_distance FLOAT, trip_duration INT, departure_time TIMESTAMP, arrival_time TIMESTAMP);INSERT INTO users (id, name, age, gender, city) VALUES (3, 'Alex', 30, 'Female', 'New York');INSERT INTO vehicles (id, vehicle_type, is_electric) VALUES (1, 'Tesla', true), (2, 'Bike', false);INSERT INTO trips (id, user_id, vehicle_id, trip_distance, trip_duration, departure_time, arrival_time) VALUES (3, 3, 1, 15.3, 25, '2022-01-03 12:00:00', '2022-01-03 12:25:00');", "reference_sql": "SELECT u.name, v.vehicle_type, t.trip_distance, t.trip_duration FROM users u JOIN trips t ON u.id = t.user_id JOIN vehicles v ON t.vehicle_id = v.id WHERE v.is_electric = true;", "generated_sql": "SELECT u.name, t.trip_distance, t.trip_duration, t.departure_time, t.arrival_time\nFROM users u\nJOIN trips t ON u.id = t.user_id\nJOIN vehicles v ON t.vehicle_id = v.id\nWHERE v.is_electric = true;", "raw_model_output": "\n\nSELECT u.name, t.trip_distance, t.trip_duration, t.departure_time, t.arrival_time\nFROM users u\nJOIN trips t ON u.id = t.user_id\nJOIN vehicles v ON t.vehicle_id = v.id\nWHERE v.is_electric = true;", "latency_sec": 0.7074182033538818, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 312, "prompt_eval_sec": null, "tokens_completion": 61, "completion_eval_sec": null, "tokens_total": 373, "tokens_per_sec": 527.2694401014854, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects 'vehicle_type' from the vehicles table, while the Generated SQL includes 'departure_time' and 'arrival_time' from the trips table instead. The selected columns differ, resulting in different output structures."}
{"example_id": 2531, "sql_complexity": "basic SQL", "prompt": "Who is the top customer by sales in 2022?", "context": "CREATE TABLE customers (customer_id INT, total_sales_2022 FLOAT); INSERT INTO customers (customer_id, total_sales_2022) VALUES (1, 25000.0), (2, 30000.0), (3, 22000.0), (4, 35000.0);", "reference_sql": "SELECT customer_id, total_sales_2022 FROM customers ORDER BY total_sales_2022 DESC LIMIT 1;", "generated_sql": "SELECT customer_id FROM customers ORDER BY total_sales_2022 DESC LIMIT 1;", "raw_model_output": "\n\nSELECT customer_id FROM customers ORDER BY total_sales_2022 DESC LIMIT 1;", "latency_sec": 0.3658878803253174, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 167, "prompt_eval_sec": null, "tokens_completion": 24, "completion_eval_sec": null, "tokens_total": 191, "tokens_per_sec": 522.0178373500061, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query returns both customer_id and total_sales_2022 columns, while the generated query only returns customer_id. The additional column in the reference query makes the result sets structurally different, even though both would identify the same customer_id (4) as the top sales performer."}
{"example_id": 3792, "sql_complexity": "single join", "prompt": "What is the maximum distance traveled by an electric vehicle in a single trip, grouped by vehicle model?", "context": "CREATE TABLE Trips (trip_id INT, vehicle_id INT, distance FLOAT); CREATE TABLE ElectricVehicleModels (vehicle_id INT, vehicle_model TEXT);", "reference_sql": "SELECT evm.vehicle_model, MAX(trips.distance) AS max_distance_traveled FROM Trips trips INNER JOIN ElectricVehicleModels evm ON trips.vehicle_id = evm.vehicle_id GROUP BY 1;", "generated_sql": "SELECT vehicle_model, MAX(distance) AS max_distance\nFROM Trips\nJOIN ElectricVehicleModels ON Trips.vehicle_id = ElectricVehicleModels.vehicle_id\nGROUP BY vehicle_model;", "raw_model_output": "\n\n```sql\nSELECT vehicle_model, MAX(distance) AS max_distance\nFROM Trips\nJOIN ElectricVehicleModels ON Trips.vehicle_id = ElectricVehicleModels.vehicle_id\nGROUP BY vehicle_model;\n```", "latency_sec": 0.6064817905426025, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 122, "prompt_eval_sec": null, "tokens_completion": 45, "completion_eval_sec": null, "tokens_total": 167, "tokens_per_sec": 275.3586383040284, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the maximum distance traveled per vehicle model by joining the Trips and ElectricVehicleModels tables on vehicle_id. The Reference SQL uses GROUP BY 1 (the first column, vehicle_model) while the Generated SQL explicitly groups by vehicle_model. Since the select list contains only vehicle_model and MAX(distance), the grouping logic is equivalent. Column aliases (max_distance_traveled vs. max_distance) do not affect semantic equivalence."}
{"example_id": 2311, "sql_complexity": "subqueries", "prompt": "Determine the percentage of sales from each ingredient category", "context": "CREATE TABLE Sales_Details (sale_id INT, ingredient_id INT, quantity INT); INSERT INTO Sales_Details (sale_id, ingredient_id, quantity) VALUES (1, 1, 2), (1, 2, 8), (2, 1, 3), (2, 2, 7); CREATE TABLE Ingredient_Categories (ingredient_id INT, ingredient_category VARCHAR(255)); INSERT INTO Ingredient_Categories (ingredient_id, ingredient_category) VALUES (1, 'Legumes'), (2, 'Poultry');", "reference_sql": "SELECT ingredient_category, SUM(quantity) AS total_quantity, SUM(quantity) * 100.0 / (SELECT SUM(quantity) FROM Sales_Details) AS percentage_of_sales FROM Sales_Details, Ingredient_Categories WHERE Sales_Details.ingredient_id = Ingredient_Categories.ingredient_id GROUP BY ingredient_category;", "generated_sql": "SELECT \n    ic.ingredient_category,\n    (COUNT(sd.sale_id) * 100.0 / (SELECT COUNT(*) FROM Sales_Details)) AS percentage_of_sales\nFROM \n    Sales_Details sd\nJOIN \n    Ingredient_Categories ic ON sd.ingredient_id = ic.ingredient_id\nGROUP BY \n    ic.ingredient_category;", "raw_model_output": "\n\n```sql\nSELECT \n    ic.ingredient_category,\n    (COUNT(sd.sale_id) * 100.0 / (SELECT COUNT(*) FROM Sales_Details)) AS percentage_of_sales\nFROM \n    Sales_Details sd\nJOIN \n    Ingredient_Categories ic ON sd.ingredient_id = ic.ingredient_id\nGROUP BY \n    ic.ingredient_category;\n```", "latency_sec": 0.7123410701751709, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 194, "prompt_eval_sec": null, "tokens_completion": 79, "completion_eval_sec": null, "tokens_total": 273, "tokens_per_sec": 383.24338077666494, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates percentages based on total quantity sold, while the Generated SQL calculates percentages based on the count of sales. The Reference uses SUM(quantity) and divides by total quantity, whereas the Generated uses COUNT(sale_id) and divides by total rows in Sales_Details. This leads to different results for the percentage_of_sales column."}
{"example_id": 3329, "sql_complexity": "set operations", "prompt": "Which causes received funding from donors in both the United States and Canada?", "context": "CREATE TABLE donor_location (donor_id INT, country VARCHAR(50), cause VARCHAR(50), donation DECIMAL(10,2)); INSERT INTO donor_location (donor_id, country, cause, donation) VALUES (1, 'United States', 'Global Health', 1000.00), (2, 'Canada', 'Education', 2000.00), (3, 'United States', 'Environment', 1500.00), (4, 'Canada', 'Animal Welfare', 2500.00);", "reference_sql": "SELECT cause FROM donor_location WHERE country = 'United States' INTERSECT SELECT cause FROM donor_location WHERE country = 'Canada';", "generated_sql": "SELECT cause\nFROM donor_location\nWHERE country IN ('United States', 'Canada')\nGROUP BY cause\nHAVING COUNT(DISTINCT country) = 2;", "raw_model_output": "\n\n```sql\nSELECT cause\nFROM donor_location\nWHERE country IN ('United States', 'Canada')\nGROUP BY cause\nHAVING COUNT(DISTINCT country) = 2;\n```", "latency_sec": 0.4157900810241699, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 209, "prompt_eval_sec": null, "tokens_completion": 42, "completion_eval_sec": null, "tokens_total": 251, "tokens_per_sec": 603.670004300582, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve causes that appear in both 'United States' and 'Canada'. The reference uses INTERSECT to find common causes, while the generated query groups by cause and checks for exactly two distinct countries. Since each cause in the result must exist in both countries, they produce identical results."}
{"example_id": 2912, "sql_complexity": "single join", "prompt": "Which company has manufactured the most satellites?", "context": "CREATE TABLE manufacturers (id INT, name TEXT); CREATE TABLE satellites (id INT, manufacturer_id INT, name TEXT, launch_date DATE); INSERT INTO manufacturers (id, name) VALUES (1, 'SpaceX'), (2, 'Blue Origin'), (3, 'ISRO'), (4, 'CAST'); INSERT INTO satellites (id, manufacturer_id, name, launch_date) VALUES (1, 1, 'StarDragon', '2012-05-25'), (2, 1, 'Falcon', '2015-12-21'), (3, 2, 'New Glenn', '2022-01-11'), (4, 3, 'ChinaSat 1E', '2000-12-05'), (5, 3, 'ChinaSat 2A', '2003-08-13'), (6, 4, 'Shijian 9', '2017-11-19'), (7, 1, 'StarLink', '2020-05-24'), (8, 1, 'StarLink', '2020-06-13');", "reference_sql": "SELECT m.name, COUNT(s.id) FROM manufacturers m JOIN satellites s ON m.id = s.manufacturer_id GROUP BY m.name ORDER BY COUNT(s.id) DESC;", "generated_sql": "SELECT m.name\nFROM manufacturers m\nJOIN satellites s ON m.id = s.manufacturer_id\nGROUP BY m.id\nORDER BY COUNT(*) DESC\nLIMIT 1;", "raw_model_output": "\n\n```sql\nSELECT m.name\nFROM manufacturers m\nJOIN satellites s ON m.id = s.manufacturer_id\nGROUP BY m.id\nORDER BY COUNT(*) DESC\nLIMIT 1;\n```", "latency_sec": 0.5525460243225098, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 344, "prompt_eval_sec": null, "tokens_completion": 44, "completion_eval_sec": null, "tokens_total": 388, "tokens_per_sec": 702.2039484868909, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns manufacturer names with their satellite counts, ordered by count descending, while the Generated SQL only returns the name of the manufacturer with the highest count (due to LIMIT 1). Additionally, the GROUP BY clauses differ (name vs. id), which could produce different results if manufacturer names were not unique. The column outputs also differ (count included vs. excluded)."}
{"example_id": 3170, "sql_complexity": "aggregation", "prompt": "Determine the total production quantity of silver for mining sites in Mexico, between the dates '2017-05-01' and '2017-09-30', having less than 40 employees.", "context": "CREATE TABLE silver_mine_2 (site_id INT, country VARCHAR(50), num_employees INT, extraction_date DATE, quantity INT); INSERT INTO silver_mine_2 (site_id, country, num_employees, extraction_date, quantity) VALUES (1, 'Mexico', 35, '2017-05-02', 1200), (2, 'Mexico', 30, '2017-08-31', 1800), (3, 'Mexico', 37, '2017-07-04', 2200);", "reference_sql": "SELECT country, SUM(quantity) as total_silver_prod FROM silver_mine_2 WHERE num_employees < 40 AND country = 'Mexico' AND extraction_date >= '2017-05-01' AND extraction_date <= '2017-09-30' GROUP BY country;", "generated_sql": "SELECT SUM(quantity) AS total_production\nFROM silver_mine_2\nWHERE country = 'Mexico'\n  AND extraction_date BETWEEN '2017-05-01' AND '2017-09-30'\n  AND num_employees < 40;", "raw_model_output": "\n\n```sql\nSELECT SUM(quantity) AS total_production\nFROM silver_mine_2\nWHERE country = 'Mexico'\n  AND extraction_date BETWEEN '2017-05-01' AND '2017-09-30'\n  AND num_employees < 40;\n```", "latency_sec": 0.9877779483795166, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 259, "prompt_eval_sec": null, "tokens_completion": 70, "completion_eval_sec": null, "tokens_total": 329, "tokens_per_sec": 333.0708086161831, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter the same rows (Mexico sites with employees <40 and dates between 2017-05-01 and 2017-09-30) and calculate the sum of quantity. The Reference query includes a GROUP BY country, but since all filtered rows are from Mexico, the aggregation produces the same single value as the Generated query which directly sums without grouping."}
{"example_id": 3518, "sql_complexity": "basic SQL", "prompt": "Insert new records of ticket sales for a new event, including event and salesperson information.", "context": "CREATE TABLE salesperson (salesperson_id INT, name VARCHAR(50), position VARCHAR(50)); CREATE TABLE tickets (ticket_id INT, salesperson_id INT, event_id INT, price DECIMAL(5,2), quantity INT); CREATE TABLE events (event_id INT, name VARCHAR(50), date DATE); INSERT INTO salesperson VALUES (1, 'John Doe', 'Senior Salesperson'); INSERT INTO events VALUES (2, 'New Event', '2023-04-15');", "reference_sql": "INSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity) VALUES (2, 1, 2, 75, 50), (3, 2, 2, 65, 75); INSERT INTO events (event_id, name, date) VALUES (2, 'New Event', '2023-04-15');", "generated_sql": "INSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity) VALUES (1, 1, 2, 50.00, 10);", "raw_model_output": "\n\nINSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity) VALUES (1, 1, 2, 50.00, 10);", "latency_sec": 0.48344898223876953, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 197, "prompt_eval_sec": null, "tokens_completion": 44, "completion_eval_sec": null, "tokens_total": 241, "tokens_per_sec": 498.5014114291238, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL inserts two tickets and an event, while the Generated SQL only inserts one ticket. The values for the ticket_id, price, and quantity differ between the queries. Additionally, the Reference SQL includes an event insertion that the Generated SQL omits."}
{"example_id": 3925, "sql_complexity": "set operations", "prompt": "What is the total number of students and staff with accommodations in the \"disability_services\" schema, excluding the \"accessibility_parking\" type?", "context": "CREATE SCHEMA disability_services; CREATE TABLE staff (id INT, name VARCHAR(50), accommodation VARCHAR(50)); CREATE TABLE students (id INT, name VARCHAR(50), accommodation VARCHAR(50));", "reference_sql": "SELECT COUNT(*) FROM disability_services.staff WHERE accommodation != 'accessibility_parking' UNION SELECT COUNT(*) FROM disability_services.students WHERE accommodation != 'accessibility_parking';", "generated_sql": "SELECT \n  (SELECT COUNT(*) FROM disability_services.students WHERE accommodation != 'accessibility_parking') + \n  (SELECT COUNT(*) FROM disability_services.staff WHERE accommodation != 'accessibility_parking') AS total;", "raw_model_output": "\n\n```sql\nSELECT \n  (SELECT COUNT(*) FROM disability_services.students WHERE accommodation != 'accessibility_parking') + \n  (SELECT COUNT(*) FROM disability_services.staff WHERE accommodation != 'accessibility_parking') AS total;\n```", "latency_sec": 0.4745368957519531, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 146, "prompt_eval_sec": null, "tokens_completion": 52, "completion_eval_sec": null, "tokens_total": 198, "tokens_per_sec": 417.24890471635166, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate counts (staff and students) as individual rows via UNION, while the Generated SQL combines the counts into a single row with a summed total. The output structure differs (two rows vs. one row with a single value), making them non-equivalent."}
{"example_id": 3340, "sql_complexity": "subqueries", "prompt": "Calculate the total revenue for garments manufactured in the US and sold in California.", "context": "CREATE TABLE garment_manufacturing(id INT PRIMARY KEY, garment_id INT, country VARCHAR(50), material VARCHAR(50), manufacturing_date DATE, quantity INT); CREATE TABLE garment_sales(id INT PRIMARY KEY, garment_id INT, store_id INT, sale_date DATE, units INT, revenue DECIMAL(10,2));", "reference_sql": "SELECT SUM(gs.revenue) FROM garment_manufacturing gm JOIN garment_sales gs ON gm.garment_id = gs.garment_id WHERE gm.country = 'United States' AND gs.store_id IN (SELECT id FROM stores WHERE region = 'California');", "generated_sql": "SELECT SUM(gs.revenue) AS total_revenue\nFROM garment_sales gs\nJOIN garment_manufacturing gm ON gs.garment_id = gm.garment_id\nWHERE gm.country = 'US' AND gs.store_id IN (SELECT id FROM store WHERE state = 'California');", "raw_model_output": "\n\n```sql\nSELECT SUM(gs.revenue) AS total_revenue\nFROM garment_sales gs\nJOIN garment_manufacturing gm ON gs.garment_id = gm.garment_id\nWHERE gm.country = 'US' AND gs.store_id IN (SELECT id FROM store WHERE state = 'California');\n```", "latency_sec": 0.7202060222625732, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 154, "prompt_eval_sec": null, "tokens_completion": 67, "completion_eval_sec": null, "tokens_total": 221, "tokens_per_sec": 306.85663986218054, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in three key aspects: 1) The Reference SQL uses 'stores' with 'region = 'California'' while the Generated SQL uses 'store' with 'state = 'California'' (different table names and column names). 2) The country condition uses 'United States' vs 'US' (different string values). These differences would produce different results if the referenced tables exist with those structures."}
{"example_id": 596, "sql_complexity": "basic SQL", "prompt": "What is the minimum energy production cost of wind farms in Spain?", "context": "CREATE TABLE wind_farm_costs (id INT, name TEXT, country TEXT, energy_production_cost FLOAT); INSERT INTO wind_farm_costs (id, name, country, energy_production_cost) VALUES (1, 'Las Tiesas', 'Spain', 0.045), (2, 'Eolo', 'Spain', 0.050);", "reference_sql": "SELECT MIN(energy_production_cost) FROM wind_farm_costs WHERE country = 'Spain';", "generated_sql": "SELECT MIN(energy_production_cost) FROM wind_farm_costs WHERE country = 'Spain';", "raw_model_output": "\n\nSELECT MIN(energy_production_cost) FROM wind_farm_costs WHERE country = 'Spain';", "latency_sec": 0.35712504386901855, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 160, "prompt_eval_sec": null, "tokens_completion": 23, "completion_eval_sec": null, "tokens_total": 183, "tokens_per_sec": 512.425558335019, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They both select the minimum energy_production_cost from the wind_farm_costs table where the country is 'Spain'. The sample data shows two entries for Spain, and both queries would return the same result (0.045)."}
{"example_id": 2604, "sql_complexity": "subqueries", "prompt": "What is the maximum number of virtual tours taken by a single user in the UK?", "context": "CREATE TABLE virtual_tour_data (user_id INT, hotel_id INT, tour_date DATE); INSERT INTO virtual_tour_data (user_id, hotel_id, tour_date) VALUES (1, 10, '2022-01-01'), (2, 11, '2022-01-03'), (3, 12, '2022-01-05'), (4, 10, '2022-01-07'), (5, 10, '2022-01-09'); CREATE TABLE hotels (hotel_id INT, hotel_name TEXT, country TEXT); INSERT INTO hotels (hotel_id, hotel_name, country) VALUES (10, 'Royal Park Hotel', 'UK'), (11, 'The Ritz London', 'UK'), (12, 'Hotel de Crillon', 'France');", "reference_sql": "SELECT MAX(vt.user_tours) FROM (SELECT user_id, COUNT(DISTINCT hotel_id) as user_tours FROM virtual_tour_data WHERE country = 'UK' GROUP BY user_id) as vt;", "generated_sql": "SELECT MAX(tour_count) AS max_tours\nFROM (\n    SELECT COUNT(*) AS tour_count\n    FROM virtual_tour_data\n    WHERE hotel_id IN (\n        SELECT hotel_id\n        FROM hotels\n        WHERE country = 'UK'\n    )\n    GROUP BY user_id\n);", "raw_model_output": "\n\n```sql\nSELECT MAX(tour_count) AS max_tours\nFROM (\n    SELECT COUNT(*) AS tour_count\n    FROM virtual_tour_data\n    WHERE hotel_id IN (\n        SELECT hotel_id\n        FROM hotels\n        WHERE country = 'UK'\n    )\n    GROUP BY user_id\n);\n```", "latency_sec": 0.9572618007659912, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 286, "prompt_eval_sec": null, "tokens_completion": 68, "completion_eval_sec": null, "tokens_total": 354, "tokens_per_sec": 369.8047908281024, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references a 'country' column in virtual_tour_data which does not exist, making it invalid. The Generated SQL correctly filters UK hotels via a subquery. Additionally, even if the Reference SQL were corrected, it would count distinct hotel_ids per user, while the Generated SQL counts total tours per user, leading to different results."}
{"example_id": 5812, "sql_complexity": "single join", "prompt": "Calculate the percentage of Shariah-compliant investments held by each investor in the top 5 countries with the highest percentage?", "context": "CREATE TABLE investors (investor_id INT, investor_name TEXT, country TEXT); INSERT INTO investors (investor_id, investor_name, country) VALUES (1, 'Al Thani', 'Qatar'), (2, 'Saudi Investment Group', 'Saudi Arabia'), (3, 'Temasek Holdings', 'Singapore'); CREATE TABLE investments (investment_id INT, investor_id INT, investment_type TEXT, investment_value DECIMAL, is_shariah_compliant BOOLEAN); INSERT INTO investments (investment_id, investor_id, investment_type, investment_value, is_shariah_compliant) VALUES (1, 1, 'Real Estate', 15000000, true), (2, 2, 'Stocks', 20000000, false);", "reference_sql": "SELECT investor_name, ROUND((SUM(CASE WHEN is_shariah_compliant THEN investment_value ELSE 0 END) / SUM(investment_value)) * 100, 2) AS percentage FROM investments JOIN investors ON investments.investor_id = investors.investor_id GROUP BY investor_name ORDER BY percentage DESC LIMIT 5;", "generated_sql": "WITH country_investment_summary AS (\n    SELECT \n        i.country,\n        SUM(CASE WHEN inv.is_shariah_compliant THEN inv.investment_value ELSE 0 END) AS shariah_compliant_total,\n        SUM(inv.investment_value) AS total_investment\n    FROM investors i\n    JOIN investments inv ON i.investor_id = inv.investor_id\n    GROUP BY i.country\n),\ncountry_percentage AS (\n    SELECT \n        country,\n        (shariah_compliant_total * 100.0 / total_investment) AS shariah_percentage\n    FROM country_investment_summary\n)\nSELECT *\nFROM country_percentage\nORDER BY shariah_percentage DESC\nLIMIT 5;", "raw_model_output": "\n\n```sql\nWITH country_investment_summary AS (\n    SELECT \n        i.country,\n        SUM(CASE WHEN inv.is_shariah_compliant THEN inv.investment_value ELSE 0 END) AS shariah_compliant_total,\n        SUM(inv.investment_value) AS total_investment\n    FROM investors i\n    JOIN investments inv ON i.investor_id = inv.investor_id\n    GROUP BY i.country\n),\ncountry_percentage AS (\n    SELECT \n        country,\n        (shariah_compliant_total * 100.0 / total_investment) AS shariah_percentage\n    FROM country_investment_summary\n)\nSELECT *\nFROM country_percentage\nORDER BY shariah_percentage DESC\nLIMIT 5;\n```", "latency_sec": 1.593580961227417, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 259, "prompt_eval_sec": null, "tokens_completion": 156, "completion_eval_sec": null, "tokens_total": 415, "tokens_per_sec": 260.41977790720864, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL calculates the shariah-compliant investment percentage per investor (grouped by investor_name), while the Generated SQL calculates it per country (grouped by country). The output columns and grouping criteria differ, leading to different results."}
{"example_id": 4706, "sql_complexity": "multiple_joins", "prompt": "Who are the top 3 customers by total spend on makeup products from Italy and Spain?", "context": "CREATE TABLE customers (customer_id INT, customer_name TEXT, country TEXT); INSERT INTO customers (customer_id, customer_name, country) VALUES (1, 'Alessandro Martini', 'IT'), (2, 'Laura Rossi', 'ES'), (3, 'Daniela Gonzalez', 'MX'), (4, 'Jose Hernandez', 'ES'), (5, 'Sophia Rodriguez', 'IT'); CREATE TABLE sales (sale_id INT, customer_id INT, product_id INT, sale_quantity INT, sale_country TEXT); INSERT INTO sales (sale_id, customer_id, product_id, sale_quantity, sale_country) VALUES (1, 1, 1, 100, 'IT'), (2, 2, 2, 150, 'ES'), (3, 3, 3, 200, 'MX'), (4, 4, 4, 250, 'ES'), (5, 5, 5, 300, 'IT'); CREATE TABLE products (product_id INT, product_name TEXT, category TEXT); INSERT INTO products (product_id, product_name, category) VALUES (1, 'Eyeshadow Palette', 'makeup'), (2, 'Liquid Lipstick', 'makeup'), (3, 'BB Cream', 'makeup'), (4, 'Volumizing Mascara', 'makeup'), (5, 'Nourishing Lip Balm', 'makeup');", "reference_sql": "SELECT c.customer_name, SUM(s.sale_quantity) as total_spent_on_makeup FROM sales s JOIN customers c ON s.customer_id = c.customer_id JOIN products p ON s.product_id = p.product_id WHERE c.country IN ('IT', 'ES') AND p.category = 'makeup' GROUP BY c.customer_name ORDER BY total_spent_on_makeup DESC LIMIT 3;", "generated_sql": "SELECT c.customer_name, SUM(s.sale_quantity) AS total_spend\nFROM customers c\nJOIN sales s ON c.customer_id = s.customer_id\nWHERE s.sale_country IN ('IT', 'ES')\nGROUP BY c.customer_id, c.customer_name\nORDER BY total_spend DESC\nLIMIT 3;", "raw_model_output": "\n\n```sql\nSELECT c.customer_name, SUM(s.sale_quantity) AS total_spend\nFROM customers c\nJOIN sales s ON c.customer_id = s.customer_id\nWHERE s.sale_country IN ('IT', 'ES')\nGROUP BY c.customer_id, c.customer_name\nORDER BY total_spend DESC\nLIMIT 3;\n```", "latency_sec": 0.841864824295044, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 395, "prompt_eval_sec": null, "tokens_completion": 72, "completion_eval_sec": null, "tokens_total": 467, "tokens_per_sec": 554.7208845446819, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects: 1) The Reference SQL filters by 'customers.country' and joins with 'products' to restrict to 'makeup' category, while the Generated SQL uses 'sale_country' and omits the products table entirely. 2) The Generated SQL groups by both customer_id and customer_name (redundant but not equivalent to the Reference's GROUP BY customer_name). These differences would produce different results."}
{"example_id": 1515, "sql_complexity": "multiple_joins", "prompt": "What is the average age of clients who lost cases in the 'personal injury' category?", "context": "CREATE TABLE Cases (CaseID int, ClientID int, Category varchar(50)); INSERT INTO Cases (CaseID, ClientID, Category) VALUES (701, 7, 'Personal Injury'); CREATE TABLE Clients (ClientID int, Age int, Gender varchar(10)); INSERT INTO Clients (ClientID, Age, Gender) VALUES (7, 45, 'Male'); CREATE TABLE CaseOutcomes (CaseID int, Outcome varchar(50)); INSERT INTO CaseOutcomes (CaseID, Outcome) VALUES (701, 'Lost');", "reference_sql": "SELECT AVG(C.Age) as AvgAge FROM Clients C INNER JOIN Cases CA ON C.ClientID = CA.ClientID INNER JOIN CaseOutcomes CO ON CA.CaseID = CO.CaseID WHERE CA.Category = 'Personal Injury' AND CO.Outcome = 'Lost';", "generated_sql": "SELECT AVG(Clients.Age)\nFROM Clients\nJOIN Cases ON Clients.ClientID = Cases.ClientID\nJOIN CaseOutcomes ON Cases.CaseID = CaseOutcomes.CaseID\nWHERE Cases.Category = 'Personal Injury' AND CaseOutcomes.Outcome = 'Lost';", "raw_model_output": "\n\n```sql\nSELECT AVG(Clients.Age)\nFROM Clients\nJOIN Cases ON Clients.ClientID = Cases.ClientID\nJOIN CaseOutcomes ON Cases.CaseID = CaseOutcomes.CaseID\nWHERE Cases.Category = 'Personal Injury' AND CaseOutcomes.Outcome = 'Lost';\n```", "latency_sec": 0.9094090461730957, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 208, "prompt_eval_sec": null, "tokens_completion": 64, "completion_eval_sec": null, "tokens_total": 272, "tokens_per_sec": 299.0953313523867, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average age of clients with 'Personal Injury' cases that resulted in a 'Lost' outcome. The only differences are table aliasing (reference uses 'C'/'CA' vs generated uses full names) and column reference style (C.Age vs Clients.Age). These syntactic variations do not affect the semantic result."}
{"example_id": 4388, "sql_complexity": "subqueries", "prompt": "Insert a new drug with a price 10% higher than the average price", "context": "CREATE TABLE drugs (drug_id INT, drug_name VARCHAR(50), price DECIMAL(10, 2)); INSERT INTO drugs (drug_id, drug_name, price) VALUES (1, 'DrugA', 50), (2, 'DrugB', 75), (3, 'DrugC', 100)", "reference_sql": "INSERT INTO drugs (drug_id, drug_name, price) VALUES ((SELECT MAX(drug_id) FROM drugs) + 1, 'DrugD', (SELECT AVG(price) * 1.1 FROM drugs))", "generated_sql": "INSERT INTO drugs (drug_name, price)\nSELECT 'NewDrug', AVG(price) * 1.10 FROM drugs;", "raw_model_output": "\n\n```sql\nINSERT INTO drugs (drug_name, price)\nSELECT 'NewDrug', AVG(price) * 1.10 FROM drugs;\n```", "latency_sec": 0.5077619552612305, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 161, "prompt_eval_sec": null, "tokens_completion": 35, "completion_eval_sec": null, "tokens_total": 196, "tokens_per_sec": 386.0076517531981, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL explicitly specifies all three columns (drug_id, drug_name, price) and calculates drug_id as MAX(drug_id) + 1, while the Generated SQL omits drug_id entirely. Since the drugs table requires drug_id (no default or auto-increment defined), the Generated SQL would fail. Additionally, the Generated SQL uses a SELECT statement that would insert a single row with 'NewDrug' and the average price, but it doesn't replicate the exact drug_id calculation or the 'DrugD' name. The price calculation is equivalent (AVG(price)*1.1 vs AVG(price)*1.10), but the missing drug_id and different drug_name make them non-equivalent."}
{"example_id": 5431, "sql_complexity": "basic SQL", "prompt": "What is the average CO2 emission of ride-hailing vehicles in San Francisco?", "context": "CREATE TABLE SFRideHailing (id INT, company VARCHAR(20), co2_emission DECIMAL(5,2));", "reference_sql": "SELECT AVG(co2_emission) FROM SFRideHailing WHERE company = 'Uber';", "generated_sql": "SELECT AVG(co2_emission) FROM SFRideHailing;", "raw_model_output": "\n\nSELECT AVG(co2_emission) FROM SFRideHailing;", "latency_sec": 0.3616189956665039, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 116, "prompt_eval_sec": null, "tokens_completion": 19, "completion_eval_sec": null, "tokens_total": 135, "tokens_per_sec": 373.321096562364, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query filters results to only include rows where company = 'Uber' before calculating the average, while the generated query calculates the average for all rows in the table without any filtering. These will produce different results unless all rows in SFRideHailing have company = 'Uber'."}
{"example_id": 3531, "sql_complexity": "single join", "prompt": "What is the total number of workouts and total workout time per user for users with a membership type of 'Basic'?", "context": "CREATE TABLE Members (id INT, user_name VARCHAR, membership_type VARCHAR, signup_date DATE); CREATE TABLE Workouts (id INT, user_id INT, workout_date DATE, workout_duration INT); INSERT INTO Members (id, user_name, membership_type, signup_date) VALUES (1, 'John Doe', 'Premium', '2020-01-01'), (2, 'Jane Smith', 'Basic', '2019-06-15'), (3, 'Alice Johnson', 'Premium', '2020-03-20'); INSERT INTO Workouts (id, user_id, workout_date, workout_duration) VALUES (1, 1, '2020-01-01', 60), (2, 1, '2020-01-02', 70), (3, 2, '2019-06-15', 90), (4, 3, '2020-03-20', 65), (5, 3, '2020-03-21', 70);", "reference_sql": "SELECT Members.user_name, SUM(Workouts.workout_duration) AS total_workout_time, COUNT(Workouts.id) AS total_workouts FROM Members JOIN Workouts ON Members.id = Workouts.user_id WHERE Members.membership_type = 'Basic' GROUP BY Members.user_name;", "generated_sql": "SELECT m.user_name, COUNT(w.id) AS total_workouts, SUM(w.workout_duration) AS total_workout_time\nFROM Members m\nJOIN Workouts w ON m.id = w.user_id\nWHERE m.membership_type = 'Basic'\nGROUP BY m.id, m.user_name;", "raw_model_output": "\n\n```sql\nSELECT m.user_name, COUNT(w.id) AS total_workouts, SUM(w.workout_duration) AS total_workout_time\nFROM Members m\nJOIN Workouts w ON m.id = w.user_id\nWHERE m.membership_type = 'Basic'\nGROUP BY m.id, m.user_name;\n```", "latency_sec": 0.9931938648223877, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 344, "prompt_eval_sec": null, "tokens_completion": 69, "completion_eval_sec": null, "tokens_total": 413, "tokens_per_sec": 415.8301965285061, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their GROUP BY clauses. The Reference SQL groups by Members.user_name, which may combine multiple users with the same name. The Generated SQL groups by both m.id and m.user_name, ensuring each user is uniquely grouped. While the data provided has unique user_names, the schema does not enforce uniqueness, making the queries non-equivalent in general cases."}
{"example_id": 5678, "sql_complexity": "set operations", "prompt": "How many public works projects are there in 'Sydney' and 'Melbourne' combined?", "context": "CREATE TABLE PublicWorksC(id INT, city VARCHAR(20), project VARCHAR(30)); INSERT INTO PublicWorksC(id, city, project) VALUES (1, 'Sydney', 'Park Renovation'), (2, 'Melbourne', 'Sidewalk Repair');", "reference_sql": "SELECT COUNT(*) FROM (SELECT city FROM PublicWorksC WHERE city = 'Sydney' UNION ALL SELECT city FROM PublicWorksC WHERE city = 'Melbourne') AS Total;", "generated_sql": "SELECT COUNT(*) FROM PublicWorksC WHERE city IN ('Sydney', 'Melbourne');", "raw_model_output": "\n\nSELECT COUNT(*) FROM PublicWorksC WHERE city IN ('Sydney', 'Melbourne');", "latency_sec": 0.3759479522705078, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 148, "prompt_eval_sec": null, "tokens_completion": 23, "completion_eval_sec": null, "tokens_total": 171, "tokens_per_sec": 454.8501965957231, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of rows where the city is either 'Sydney' or 'Melbourne'. The Reference SQL uses a UNION ALL to combine results from two separate selects, while the Generated SQL uses IN. Since UNION ALL includes all rows (including duplicates) and the IN clause achieves the same filtering, the final count will be identical in both cases."}
{"example_id": 5792, "sql_complexity": "multiple_joins", "prompt": "How many cases were handled by attorneys in the 'Los Angeles' office?", "context": "CREATE TABLE offices (office_id INT, office_name VARCHAR(20), city VARCHAR(20), state VARCHAR(20)); INSERT INTO offices (office_id, office_name, city, state) VALUES (1, 'Boston', 'Boston', 'MA'), (2, 'New York', 'New York', 'NY'), (3, 'Los Angeles', 'Los Angeles', 'CA'); CREATE TABLE attorneys (attorney_id INT, office_id INT); INSERT INTO attorneys (attorney_id, office_id) VALUES (1, 1), (2, 2), (3, 3); CREATE TABLE cases (case_id INT, attorney_id INT); INSERT INTO cases (case_id, attorney_id) VALUES (1, 1), (2, 2), (3, 3);", "reference_sql": "SELECT COUNT(*) FROM cases JOIN attorneys ON cases.attorney_id = attorneys.attorney_id JOIN offices ON attorneys.office_id = offices.office_id WHERE offices.city = 'Los Angeles';", "generated_sql": "SELECT COUNT(*) FROM cases WHERE attorney_id IN (SELECT attorney_id FROM attorneys WHERE office_id = (SELECT office_id FROM offices WHERE office_name = 'Los Angeles'));", "raw_model_output": "\n\nSELECT COUNT(*) FROM cases WHERE attorney_id IN (SELECT attorney_id FROM attorneys WHERE office_id = (SELECT office_id FROM offices WHERE office_name = 'Los Angeles'));", "latency_sec": 0.44447898864746094, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 253, "prompt_eval_sec": null, "tokens_completion": 38, "completion_eval_sec": null, "tokens_total": 291, "tokens_per_sec": 654.6991138670157, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count cases where the attorney is associated with the 'Los Angeles' office. The Reference SQL filters offices by city, while the Generated SQL filters by office_name. In the provided data, the office_name and city for Los Angeles are identical, making both conditions equivalent in this context. Thus, both queries return the same result."}
{"example_id": 5148, "sql_complexity": "window functions", "prompt": "List the unique types of smart city technologies that have been implemented in the top 3 most populous countries in the world.", "context": "CREATE TABLE smart_city_tech (tech_type VARCHAR(255), country VARCHAR(255)); CREATE TABLE country_populations (country VARCHAR(255), population INT);", "reference_sql": "SELECT DISTINCT tech_type FROM smart_city_tech SCT WHERE country IN (SELECT country FROM (SELECT country, ROW_NUMBER() OVER (ORDER BY population DESC) as rank FROM country_populations) CP WHERE rank <= 3);", "generated_sql": "SELECT DISTINCT st.tech_type\nFROM smart_city_tech st\nWHERE st.country IN (\n    SELECT country\n    FROM country_populations\n    ORDER BY population DESC\n    LIMIT 3\n);", "raw_model_output": "\n\n```sql\nSELECT DISTINCT st.tech_type\nFROM smart_city_tech st\nWHERE st.country IN (\n    SELECT country\n    FROM country_populations\n    ORDER BY population DESC\n    LIMIT 3\n);\n```", "latency_sec": 0.5236918926239014, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 134, "prompt_eval_sec": null, "tokens_completion": 49, "completion_eval_sec": null, "tokens_total": 183, "tokens_per_sec": 349.4421100985512, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the top 3 countries by population. The reference query uses ROW_NUMBER() with a subquery to assign ranks and filter top 3, while the generated query uses ORDER BY ... LIMIT 3. Both approaches effectively select the same set of countries when ordered by population descending, assuming deterministic ordering. The DISTINCT clause in the outer query ensures unique tech_types, making the results equivalent."}
{"example_id": 5547, "sql_complexity": "multiple_joins", "prompt": "Which species have a population growth rate higher than the average for protected areas?", "context": "CREATE TABLE species (id INT, name VARCHAR(50), population DECIMAL(5,2), protected_area_id INT, growth_rate DECIMAL(5,2)); INSERT INTO species (id, name, population, protected_area_id, growth_rate) VALUES (1, 'Species 1', 500.00, 1, 0.05), (2, 'Species 2', 800.00, 1, 0.03), (3, 'Species 3', 1200.00, 2, 0.07), (4, 'Species 4', 700.00, 2, 0.02); CREATE TABLE protected_areas (id INT, name VARCHAR(50)); INSERT INTO protected_areas (id, name) VALUES (1, 'Area 1'), (2, 'Area 2');", "reference_sql": "SELECT s.name, s.growth_rate FROM species s INNER JOIN protected_areas pa ON s.protected_area_id = pa.id GROUP BY s.name, s.growth_rate HAVING s.growth_rate > (SELECT AVG(s.growth_rate) FROM species s INNER JOIN protected_areas pa ON s.protected_area_id = pa.id);", "generated_sql": "SELECT s.name\nFROM species s\nWHERE s.growth_rate > (\n    SELECT AVG(growth_rate)\n    FROM species\n    WHERE protected_area_id = s.protected_area_id\n);", "raw_model_output": "\n\n```sql\nSELECT s.name\nFROM species s\nWHERE s.growth_rate > (\n    SELECT AVG(growth_rate)\n    FROM species\n    WHERE protected_area_id = s.protected_area_id\n);\n```", "latency_sec": 0.7667262554168701, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 281, "prompt_eval_sec": null, "tokens_completion": 48, "completion_eval_sec": null, "tokens_total": 329, "tokens_per_sec": 429.097083444889, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL compares species growth rates to the overall average growth rate across all protected areas (subquery calculates global average). The Generated SQL compares each species' growth rate to the average growth rate within its specific protected area (correlated subquery). The HAVING clause in Reference uses a global average while the Generated SQL's WHERE clause uses a per-group average."}
{"example_id": 5498, "sql_complexity": "aggregation", "prompt": "Identify the destinations with the highest number of repeat visitors from the US.", "context": "CREATE TABLE RepeatTravelers (Visitor VARCHAR(20), Destination VARCHAR(20), VisitCount INT); INSERT INTO RepeatTravelers (Visitor, Destination, VisitCount) VALUES ('David', 'Paris', 3), ('Ella', 'London', 4), ('Fiona', 'Paris', 2);", "reference_sql": "SELECT Destination, AVG(VisitCount) AS AvgVisitCount FROM RepeatTravelers WHERE Visitor LIKE '%USA%' GROUP BY Destination ORDER BY AvgVisitCount DESC;", "generated_sql": "None of the tables or columns in the provided schema contain information about the origin (e.g., \"from the US\") of the visitors. Therefore, it is not possible to identify destinations with the highest number of repeat visitors from the US based on the given schema.", "raw_model_output": "\n\nNone of the tables or columns in the provided schema contain information about the origin (e.g., \"from the US\") of the visitors. Therefore, it is not possible to identify destinations with the highest number of repeat visitors from the US based on the given schema.", "latency_sec": 0.5996780395507812, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 152, "prompt_eval_sec": null, "tokens_completion": 58, "completion_eval_sec": null, "tokens_total": 210, "tokens_per_sec": 350.1879110952787, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL is a valid query attempting to filter visitors from the US (though no such data exists in the sample), while the Generated SQL is not a query but an explanation about schema limitations. They are not semantically equivalent as one is a query and the other is a descriptive statement."}
{"example_id": 3546, "sql_complexity": "window functions", "prompt": "What are the cryptocurrency exchanges with their corresponding blockchain companies, ranked by exchange ID in ascending order, for the Bitcoin platform?", "context": "CREATE TABLE cryptocurrency_exchanges (exchange_id INT, exchange_name VARCHAR(50), company_id INT); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (1, 'Binance', 1); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (2, 'Coinbase', 2); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (3, 'Kraken', 3); CREATE TABLE blockchain_companies (company_id INT, company_name VARCHAR(50), platform VARCHAR(50)); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (1, 'Binance', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (2, 'Blockstream', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (3, 'Blockchair', 'Bitcoin');", "reference_sql": "SELECT ce.exchange_name, bc.company_name, ce.exchange_id, ROW_NUMBER() OVER (PARTITION BY bc.platform ORDER BY ce.exchange_id ASC) as rank FROM cryptocurrency_exchanges ce JOIN blockchain_companies bc ON ce.company_id = bc.company_id WHERE bc.platform = 'Bitcoin';", "generated_sql": "SELECT ce.exchange_name, bc.company_name\nFROM cryptocurrency_exchanges ce\nJOIN blockchain_companies bc ON ce.company_id = bc.company_id\nWHERE bc.platform = 'Bitcoin'\nORDER BY ce.exchange_id ASC;", "raw_model_output": "\n\n```sql\nSELECT ce.exchange_name, bc.company_name\nFROM cryptocurrency_exchanges ce\nJOIN blockchain_companies bc ON ce.company_id = bc.company_id\nWHERE bc.platform = 'Bitcoin'\nORDER BY ce.exchange_id ASC;\n```", "latency_sec": 0.7666730880737305, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 293, "prompt_eval_sec": null, "tokens_completion": 52, "completion_eval_sec": null, "tokens_total": 345, "tokens_per_sec": 449.9962309448138, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL includes an additional 'exchange_id' column and a 'rank' column generated by ROW_NUMBER(), while the Generated SQL omits these. Additionally, the Generated SQL includes an ORDER BY clause not present in the Reference SQL, which could affect result ordering. The differing column sets and ordering behavior prevent them from producing identical results."}
{"example_id": 486, "sql_complexity": "single join", "prompt": "What is the average price of paintings from African artists in our collection?", "context": "CREATE TABLE Artworks (id INT, title VARCHAR(50), price DECIMAL(10,2), medium VARCHAR(50), artist_nationality VARCHAR(50)); CREATE TABLE Collections (id INT, name VARCHAR(50), continent VARCHAR(50));", "reference_sql": "SELECT AVG(Artworks.price) FROM Artworks INNER JOIN Collections ON Artworks.artist_nationality = Collections.continent WHERE Artworks.medium = 'Painting' AND Collections.continent = 'Africa';", "generated_sql": "SELECT AVG(Artworks.price) \nFROM Artworks \nWHERE Artworks.medium = 'painting' AND Artworks.artist_nationality = 'African';", "raw_model_output": "\n\nSELECT AVG(Artworks.price) \nFROM Artworks \nWHERE Artworks.medium = 'painting' AND Artworks.artist_nationality = 'African';", "latency_sec": 0.6873860359191895, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 143, "prompt_eval_sec": null, "tokens_completion": 38, "completion_eval_sec": null, "tokens_total": 181, "tokens_per_sec": 263.31637615821273, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Reference SQL uses 'Painting' (capitalized) and 'Africa' (continent name), while the Generated SQL uses 'painting' (lowercase) and 'African' (adjective). Second, the Reference SQL joins Artworks with Collections on artist_nationality = continent, but the Generated SQL directly filters artist_nationality = 'African' without a join. These differences in conditions and logic make the queries non-equivalent."}
{"example_id": 794, "sql_complexity": "multiple_joins", "prompt": "Which suppliers have provided raw materials for the production of chemicals with high environmental impact?", "context": "CREATE TABLE suppliers (id INT, name TEXT); INSERT INTO suppliers (id, name) VALUES (1, 'Supplier1'), (2, 'Supplier2'), (3, 'Supplier3'); CREATE TABLE chemicals (id INT, name TEXT, environmental_impact INT); INSERT INTO chemicals (id, name, environmental_impact) VALUES (1, 'ChemA', 10), (2, 'ChemB', 20), (3, 'ChemC', 15); CREATE TABLE raw_materials (chemical_id INT, supplier_id INT); INSERT INTO raw_materials (chemical_id, supplier_id) VALUES (1, 1), (1, 2), (2, 3), (3, 1);", "reference_sql": "SELECT s.name FROM suppliers s INNER JOIN raw_materials rm ON s.id = rm.supplier_id INNER JOIN chemicals c ON rm.chemical_id = c.id WHERE c.environmental_impact > 10;", "generated_sql": "SELECT DISTINCT s.name\nFROM suppliers s\nJOIN raw_materials rm ON s.id = rm.supplier_id\nJOIN chemicals c ON rm.chemical_id = c.id\nWHERE c.environmental_impact > 15;", "raw_model_output": "\n\nSELECT DISTINCT s.name\nFROM suppliers s\nJOIN raw_materials rm ON s.id = rm.supplier_id\nJOIN chemicals c ON rm.chemical_id = c.id\nWHERE c.environmental_impact > 15;", "latency_sec": 0.7757010459899902, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 240, "prompt_eval_sec": null, "tokens_completion": 51, "completion_eval_sec": null, "tokens_total": 291, "tokens_per_sec": 375.14452443287684, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the environmental impact threshold (10 vs. 15) and the use of DISTINCT. The Reference SQL filters chemicals with environmental_impact > 10 (including 15 and 20), while the Generated SQL filters >15 (only 20). This changes the result set. Additionally, the Generated SQL uses DISTINCT, which could eliminate duplicates but doesn't fully compensate for the filtering difference."}
{"example_id": 3164, "sql_complexity": "set operations", "prompt": "What is the average age of patients who received therapy in 'clinic_a' and 'clinic_b'?", "context": "CREATE TABLE clinic_a (patient_id INT, age INT, therapy_received BOOLEAN); INSERT INTO clinic_a (patient_id, age, therapy_received) VALUES (1, 35, true), (2, 42, true), (3, 28, false); CREATE TABLE clinic_b (patient_id INT, age INT, therapy_received BOOLEAN); INSERT INTO clinic_b (patient_id, age, therapy_received) VALUES (4, 50, true), (5, 32, false), (6, 45, true);", "reference_sql": "SELECT AVG(age) FROM (SELECT age FROM clinic_a WHERE therapy_received = true UNION ALL SELECT age FROM clinic_b WHERE therapy_received = true) AS combined_clinics;", "generated_sql": "SELECT AVG(a.age) + AVG(b.age) / 2 AS average_age\nFROM clinic_a a\nJOIN clinic_b b ON true\nWHERE a.therapy_received = true AND b.therapy_received = true;", "raw_model_output": "\n\n```sql\nSELECT AVG(a.age) + AVG(b.age) / 2 AS average_age\nFROM clinic_a a\nJOIN clinic_b b ON true\nWHERE a.therapy_received = true AND b.therapy_received = true;\n```", "latency_sec": 0.7441446781158447, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 207, "prompt_eval_sec": null, "tokens_completion": 53, "completion_eval_sec": null, "tokens_total": 260, "tokens_per_sec": 349.3944224103213, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the average age of all patients who received therapy across both clinics by combining their ages first. The Generated SQL performs a Cartesian product between clinic_a and clinic_b, then computes a weighted sum of averages that does not represent the true combined average. For example, Reference SQL averages [35,42,50,45] = 43, while Generated SQL computes (38.5 + 47.5/2) = 62.25, producing different results."}
{"example_id": 3704, "sql_complexity": "aggregation", "prompt": "What is the total sales revenue for each category of garments in the South America region in Q1 2022?", "context": "CREATE TABLE sales_category (sale_id INT, garment_category VARCHAR(50), sale_date DATE, total_sales DECIMAL(10, 2), region VARCHAR(50));", "reference_sql": "SELECT garment_category, SUM(total_sales) FROM sales_category WHERE sale_date BETWEEN '2022-01-01' AND '2022-03-31' AND region = 'South America' GROUP BY garment_category;", "generated_sql": "SELECT garment_category, SUM(total_sales) AS total_sales_revenue\nFROM sales_category\nWHERE region = 'South America' AND sale_date BETWEEN '2022-01-01' AND '2022-03-31'\nGROUP BY garment_category;", "raw_model_output": "\n\n```sql\nSELECT garment_category, SUM(total_sales) AS total_sales_revenue\nFROM sales_category\nWHERE region = 'South America' AND sale_date BETWEEN '2022-01-01' AND '2022-03-31'\nGROUP BY garment_category;\n```", "latency_sec": 0.6664807796478271, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 134, "prompt_eval_sec": null, "tokens_completion": 68, "completion_eval_sec": null, "tokens_total": 202, "tokens_per_sec": 303.0845092138113, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (garment_category and summed total_sales), apply identical WHERE conditions (region = 'South America' and sale_date between 2022-01-01 and 2022-03-31), and group by the same column (garment_category). The only difference is the column alias (total_sales_revenue) in the generated query, which doesn't affect the semantic result."}
{"example_id": 2851, "sql_complexity": "single join", "prompt": "How many cases were handled by attorneys who joined the firm in 2015 or later?", "context": "CREATE TABLE attorneys (attorney_id INT, join_year INT); CREATE TABLE cases (case_id INT, attorney_id INT, billing_amount INT);", "reference_sql": "SELECT COUNT(DISTINCT cases.case_id) FROM cases INNER JOIN attorneys ON cases.attorney_id = attorneys.attorney_id WHERE attorneys.join_year >= 2015;", "generated_sql": "SELECT COUNT(*) \nFROM cases \nWHERE attorney_id IN (SELECT attorney_id FROM attorneys WHERE join_year >= 2015);", "raw_model_output": "\n\n```sql\nSELECT COUNT(*) \nFROM cases \nWHERE attorney_id IN (SELECT attorney_id FROM attorneys WHERE join_year >= 2015);\n```", "latency_sec": 0.4680929183959961, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 121, "prompt_eval_sec": null, "tokens_completion": 36, "completion_eval_sec": null, "tokens_total": 157, "tokens_per_sec": 335.4034932593907, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of cases handled by attorneys who joined in 2015 or later. The reference query uses an INNER JOIN with a WHERE clause, while the generated query uses a subquery with IN. Since both ensure only cases with matching attorney_ids (from eligible attorneys) are counted, and assuming case_id is unique, the result is the same."}
{"example_id": 3246, "sql_complexity": "single join", "prompt": "What is the average eco-friendliness score of accommodations in Oceania by year?", "context": "CREATE TABLE Accommodations (Accommodation_ID INT, Accommodation_Name VARCHAR(50), City VARCHAR(30), Country VARCHAR(50), Eco_Friendliness_Score INT, Visit_Year INT); INSERT INTO Accommodations (Accommodation_ID, Accommodation_Name, City, Country, Eco_Friendliness_Score, Visit_Year) VALUES (1, 'EcoLodge', 'Sydney', 'Australia', 85, 2019), (2, 'GreenHotel', 'Melbourne', 'Australia', 90, 2019), (3, 'SustainableResort', 'Auckland', 'New Zealand', 80, 2019), (4, 'EcoVilla', 'Wellington', 'New Zealand', 88, 2019); CREATE TABLE Countries (Country VARCHAR(50), Continent VARCHAR(30)); INSERT INTO Countries (Country, Continent) VALUES ('Australia', 'Oceania'), ('New Zealand', 'Oceania');", "reference_sql": "SELECT C.Continent, V.Visit_Year, AVG(A.Eco_Friendliness_Score) AS Avg_Eco_Score  FROM Accommodations A  JOIN Countries C  ON A.Country = C.Country  WHERE C.Continent = 'Oceania'  GROUP BY C.Continent, V.Visit_Year  ORDER BY V.Visit_Year;", "generated_sql": "SELECT Visit_Year, AVG(Eco_Friendliness_Score) AS Average_Eco_Score\nFROM Accommodations\nWHERE Country IN (SELECT Country FROM Countries WHERE Continent = 'Oceania')\nGROUP BY Visit_Year;", "raw_model_output": "\n\n```sql\nSELECT Visit_Year, AVG(Eco_Friendliness_Score) AS Average_Eco_Score\nFROM Accommodations\nWHERE Country IN (SELECT Country FROM Countries WHERE Continent = 'Oceania')\nGROUP BY Visit_Year;\n```", "latency_sec": 0.5995819568634033, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 312, "prompt_eval_sec": null, "tokens_completion": 57, "completion_eval_sec": null, "tokens_total": 369, "tokens_per_sec": 615.4287929716096, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes 'Continent' in the SELECT and GROUP BY clauses, while the Generated SQL omits it. Although both filter for 'Oceania' (via JOIN or subquery) and group by 'Visit_Year', the Reference query's output structure differs by including the 'Continent' column. Additionally, the Reference groups by both 'Continent' and 'Visit_Year' (though 'Continent' is fixed to 'Oceania'), while the Generated SQL only groups by 'Visit_Year'. These differences in output columns and grouping logic make them non-equivalent."}
{"example_id": 3056, "sql_complexity": "multiple_joins", "prompt": "Identify all suppliers who provide non-GMO ingredients to restaurants with Michelin stars.", "context": "CREATE TABLE Suppliers (id INT, name VARCHAR(50), isNonGMO BOOLEAN); CREATE TABLE Restaurants (id INT, name VARCHAR(50), numStars INT); CREATE TABLE Ingredients (supplierId INT, restaurantId INT, isNonGMO BOOLEAN);", "reference_sql": "SELECT Suppliers.name FROM Suppliers INNER JOIN Ingredients ON Suppliers.id = Ingredients.supplierId INNER JOIN Restaurants ON Ingredients.restaurantId = Restaurants.id WHERE Restaurants.numStars > 2 AND Ingredients.isNonGMO = TRUE;", "generated_sql": "SELECT DISTINCT s.id, s.name\nFROM Suppliers s\nJOIN Ingredients i ON s.id = i.supplierId\nJOIN Restaurants r ON i.restaurantId = r.id\nWHERE i.isNonGMO = TRUE AND r.numStars > 0;", "raw_model_output": "\n\nSELECT DISTINCT s.id, s.name\nFROM Suppliers s\nJOIN Ingredients i ON s.id = i.supplierId\nJOIN Restaurants r ON i.restaurantId = r.id\nWHERE i.isNonGMO = TRUE AND r.numStars > 0;", "latency_sec": 0.5604920387268066, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 143, "prompt_eval_sec": null, "tokens_completion": 56, "completion_eval_sec": null, "tokens_total": 199, "tokens_per_sec": 355.04518574793883, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in three key aspects: 1) The Reference selects only 'Suppliers.name', while the Generated includes 's.id' and 's.name' (additional columns). 2) The WHERE clause in the Reference uses 'Restaurants.numStars > 2' whereas the Generated uses 'r.numStars > 0' (different filtering thresholds). 3) The Generated includes 'DISTINCT' which may eliminate duplicates not present in the Reference. These differences ensure the result sets are not identical."}
{"example_id": 264, "sql_complexity": "set operations", "prompt": "List the number of community health centers and infectious disease tracking facilities in 'southwest' regions.", "context": "CREATE TABLE centers (id INT, name TEXT, region TEXT); INSERT INTO centers (id, name, region) VALUES (1, 'Center A', 'southwest'); INSERT INTO centers (id, name, region) VALUES (2, 'Center B', 'northeast'); INSERT INTO centers (id, name, region) VALUES (3, 'Center C', 'northwest'); CREATE TABLE diseases (id INT, name TEXT, region TEXT); INSERT INTO diseases (id, name, region) VALUES (1, 'Disease A', 'southwest'); INSERT INTO diseases (id, name, region) VALUES (2, 'Disease B', 'southeast');", "reference_sql": "SELECT COUNT(*) FROM ( (SELECT * FROM centers WHERE region = 'southwest') UNION (SELECT * FROM diseases WHERE region = 'southwest') );", "generated_sql": "SELECT \n    SUM(CASE WHEN c.region = 'southwest' THEN 1 ELSE 0 END) AS health_centers,\n    SUM(CASE WHEN d.region = 'southwest' THEN 1 ELSE 0 END) AS infectious_disease_facilities\nFROM centers c, diseases d;", "raw_model_output": "\n\n```sql\nSELECT \n    SUM(CASE WHEN c.region = 'southwest' THEN 1 ELSE 0 END) AS health_centers,\n    SUM(CASE WHEN d.region = 'southwest' THEN 1 ELSE 0 END) AS infectious_disease_facilities\nFROM centers c, diseases d;\n```", "latency_sec": 1.021244764328003, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 230, "prompt_eval_sec": null, "tokens_completion": 69, "completion_eval_sec": null, "tokens_total": 299, "tokens_per_sec": 292.77995877584476, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL counts the total number of unique rows from both centers and diseases tables where region = 'southwest' using UNION. The Generated SQL performs a Cartesian product between centers and diseases, then separately counts matching regions in each table. This leads to inflated counts due to the cross-join (e.g., 1 center * 2 diseases = 2 for health_centers, 3 centers * 1 disease = 3 for infectious_disease_facilities), whereas the Reference SQL returns a simple combined count of 2."}
{"example_id": 2838, "sql_complexity": "basic SQL", "prompt": "What is the minimum safety rating of electric vehicles in the 'green_cars' table?", "context": "CREATE TABLE green_cars (id INT, make VARCHAR(50), model VARCHAR(50), type VARCHAR(50), safety_rating INT);", "reference_sql": "SELECT MIN(safety_rating) FROM green_cars WHERE type = 'Electric';", "generated_sql": "SELECT MIN(safety_rating) FROM green_cars WHERE type = 'electric';", "raw_model_output": "\n\nSELECT MIN(safety_rating) FROM green_cars WHERE type = 'electric';", "latency_sec": 0.4058268070220947, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 121, "prompt_eval_sec": null, "tokens_completion": 21, "completion_eval_sec": null, "tokens_total": 142, "tokens_per_sec": 349.9029574758204, "match_exact": true, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The two queries are semantically equivalent because SQL string comparisons are case-insensitive by default (assuming standard database settings). The WHERE clause conditions 'type = 'Electric'' and 'type = 'electric'' would match the same rows in the green_cars table, resulting in the same MIN(safety_rating) output."}
{"example_id": 1187, "sql_complexity": "multiple_joins", "prompt": "Who are the top 3 authors with the highest number of articles published in The Guardian?", "context": "CREATE TABLE authors (id INT, name VARCHAR(100), publisher VARCHAR(50)); CREATE TABLE articles_authors (article_id INT, author_id INT); INSERT INTO authors (id, name, publisher) VALUES (1, 'Author1', 'The Guardian'), (2, 'Author2', 'The Guardian'), (3, 'Author3', 'The Guardian'); INSERT INTO articles_authors (article_id, author_id) VALUES (1, 1), (2, 2), (3, 1), (3, 2), (3, 3); INSERT INTO articles (id, title, publication_date, publisher) VALUES (1, 'Article1', '2021-01-01', 'The Guardian'), (2, 'Article2', '2021-01-02', 'The Guardian'), (3, 'Article3', '2021-01-03', 'The Guardian');", "reference_sql": "SELECT a.name, COUNT(aa.article_id) AS articles_count FROM authors a JOIN articles_authors aa ON a.id = aa.author_id JOIN articles ar ON aa.article_id = ar.id WHERE ar.publisher = 'The Guardian' GROUP BY a.name ORDER BY articles_count DESC LIMIT 3;", "generated_sql": "SELECT a.name, COUNT(*) AS article_count\nFROM authors a\nJOIN articles_authors aa ON a.id = aa.author_id\nJOIN articles ar ON aa.article_id = ar.id\nWHERE ar.publisher = 'The Guardian'\nGROUP BY a.id, a.name\nORDER BY article_count DESC\nLIMIT 3;", "raw_model_output": "\n\n```sql\nSELECT a.name, COUNT(*) AS article_count\nFROM authors a\nJOIN articles_authors aa ON a.id = aa.author_id\nJOIN articles ar ON aa.article_id = ar.id\nWHERE ar.publisher = 'The Guardian'\nGROUP BY a.id, a.name\nORDER BY article_count DESC\nLIMIT 3;\n```", "latency_sec": 1.0629401206970215, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 294, "prompt_eval_sec": null, "tokens_completion": 73, "completion_eval_sec": null, "tokens_total": 367, "tokens_per_sec": 345.2687436046165, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their GROUP BY clauses. The Reference SQL groups by 'a.name' alone, which could combine authors with the same name (if duplicates exist). The Generated SQL groups by both 'a.id' and 'a.name', ensuring each author is uniquely identified. While the sample data has unique names, the schema allows non-unique names, making the grouping behavior potentially different. Additionally, the COUNT(*) vs COUNT(aa.article_id) is functionally equivalent here but not semantically identical in all contexts."}
{"example_id": 360, "sql_complexity": "window functions", "prompt": "What is the change in crime rate for each category, between this year and last year, for the same time period?", "context": "CREATE TABLE CrimeStatistics (ID INT, CrimeType VARCHAR(50), Date TIMESTAMP, Count INT); INSERT INTO CrimeStatistics (ID, CrimeType, Date, Count) VALUES (1, 'Theft', '2022-01-01 00:00:00', 100), (2, 'Vandalism', '2022-01-01 00:00:00', 50), (3, 'Theft', '2022-01-02 00:00:00', 120), (4, 'Vandalism', '2022-01-02 00:00:00', 60), (5, 'Theft', '2021-01-01 00:00:00', 80), (6, 'Vandalism', '2021-01-01 00:00:00', 40), (7, 'Theft', '2021-01-02 00:00:00', 90), (8, 'Vandalism', '2021-01-02 00:00:00', 45);", "reference_sql": "SELECT CrimeType, (SUM(Count) OVER (PARTITION BY CrimeType ORDER BY EXTRACT(YEAR FROM Date) ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)) - SUM(Count) OVER (PARTITION BY CrimeType ORDER BY EXTRACT(YEAR FROM Date)) AS CrimeRateChange FROM CrimeStatistics WHERE Date BETWEEN DATE_TRUNC('year', CURRENT_DATE - INTERVAL '1 year') AND CURRENT_DATE;", "generated_sql": "SELECT \n    cs1.CrimeType,\n    SUM(cs1.Count) - SUM(cs2.Count) AS ChangeInCrimeRate\nFROM \n    CrimeStatistics cs1\nJOIN \n    CrimeStatistics cs2\nON \n    cs1.CrimeType = cs2.CrimeType\n    AND EXTRACT(YEAR FROM cs1.Date) = EXTRACT(YEAR FROM CURRENT_DATE)\n    AND EXTRACT(YEAR FROM cs2.Date) = EXTRACT(YEAR FROM CURRENT_DATE) - 1\n    AND EXTRACT(MONTH FROM cs1.Date) = EXTRACT(MONTH FROM cs2.Date)\n    AND EXTRACT(DAY FROM cs1.Date) = EXTRACT(DAY FROM cs2.Date)\nGROUP BY \n    cs1.CrimeType;", "raw_model_output": "\n\n```sql\nSELECT \n    cs1.CrimeType,\n    SUM(cs1.Count) - SUM(cs2.Count) AS ChangeInCrimeRate\nFROM \n    CrimeStatistics cs1\nJOIN \n    CrimeStatistics cs2\nON \n    cs1.CrimeType = cs2.CrimeType\n    AND EXTRACT(YEAR FROM cs1.Date) = EXTRACT(YEAR FROM CURRENT_DATE)\n    AND EXTRACT(YEAR FROM cs2.Date) = EXTRACT(YEAR FROM CURRENT_DATE) - 1\n    AND EXTRACT(MONTH FROM cs1.Date) = EXTRACT(MONTH FROM cs2.Date)\n    AND EXTRACT(DAY FROM cs1.Date) = EXTRACT(DAY FROM cs2.Date)\nGROUP BY \n    cs1.CrimeType;\n```", "latency_sec": 1.6921348571777344, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 394, "prompt_eval_sec": null, "tokens_completion": 165, "completion_eval_sec": null, "tokens_total": 559, "tokens_per_sec": 330.3519206101226, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL uses window functions to calculate a difference between cumulative sums across years, but its logic is flawed (e.g., subtracting cumulative sums instead of year-specific totals). The Generated SQL performs a self-join on exact date matches (same month/day) between current and previous years, aggregating daily differences. The Reference SQL's WHERE clause filters dates within a year range, while the Generated SQL's join conditions focus on specific date matches. The two approaches differ in how they aggregate and compare data (yearly vs. daily)."}
{"example_id": 335, "sql_complexity": "single join", "prompt": "List the policy numbers, claim amounts, and claim dates for policies that have more than two claims and the total claim amount exceeds $5000", "context": "CREATE TABLE policies (policy_number INT);CREATE TABLE claims (claim_id INT, policy_number INT, claim_amount DECIMAL(10,2), claim_date DATE);", "reference_sql": "SELECT p.policy_number, c.claim_amount, c.claim_date FROM policies p INNER JOIN claims c ON p.policy_number = c.policy_number GROUP BY p.policy_number, c.claim_amount, c.claim_date HAVING COUNT(c.claim_id) > 2 AND SUM(c.claim_amount) > 5000;", "generated_sql": "SELECT p.policy_number, c.claim_amount, c.claim_date\nFROM policies p\nJOIN claims c ON p.policy_number = c.policy_number\nWHERE p.policy_number IN (\n    SELECT policy_number\n    FROM claims\n    GROUP BY policy_number\n    HAVING COUNT(*) > 2 AND SUM(claim_amount) > 5000\n);", "raw_model_output": "\n\n```sql\nSELECT p.policy_number, c.claim_amount, c.claim_date\nFROM policies p\nJOIN claims c ON p.policy_number = c.policy_number\nWHERE p.policy_number IN (\n    SELECT policy_number\n    FROM claims\n    GROUP BY policy_number\n    HAVING COUNT(*) > 2 AND SUM(claim_amount) > 5000\n);\n```", "latency_sec": 0.9200470447540283, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 137, "prompt_eval_sec": null, "tokens_completion": 83, "completion_eval_sec": null, "tokens_total": 220, "tokens_per_sec": 239.1182073290788, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their grouping and filtering logic. The reference query groups by policy_number, claim_amount, and claim_date, requiring each unique (policy, amount, date) combination to have >2 claims and sum >5000. The generated query filters policies with >2 total claims and sum >5000 (via subquery), then returns all claims for those policies. This means the generated query returns all claims for qualifying policies, while the reference query only returns aggregated groups meeting the criteria. The HAVING conditions and grouping fields differ, leading to different result sets."}
{"example_id": 2866, "sql_complexity": "basic SQL", "prompt": "What is the number of hospitals in 'rural_healthcare' table?", "context": "CREATE TABLE rural_healthcare (name VARCHAR(255), type VARCHAR(255), location VARCHAR(255)); INSERT INTO rural_healthcare (name, type, location) VALUES ('Rural General Hospital', 'Hospital', 'Bushland'), ('Rural Community Hospital', 'Hospital', 'Forest Region');", "reference_sql": "SELECT COUNT(*) FROM rural_healthcare WHERE type = 'Hospital';", "generated_sql": "SELECT COUNT(*) FROM rural_healthcare;", "raw_model_output": "\n\nSELECT COUNT(*) FROM rural_healthcare;", "latency_sec": 0.27964091300964355, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 153, "prompt_eval_sec": null, "tokens_completion": 13, "completion_eval_sec": null, "tokens_total": 166, "tokens_per_sec": 593.6184309134887, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query counts only rows where type = 'Hospital', while the generated query counts all rows without filtering. Although the inserted data contains only 'Hospital' entries, the queries are not semantically equivalent because the generated query lacks the WHERE clause and would return different results if other types existed in the table."}
{"example_id": 4440, "sql_complexity": "multiple_joins", "prompt": "What is the average session length for each game genre in the last month, sorted by average session length.", "context": "CREATE TABLE game_sessions(id INT, user_id INT, game_name VARCHAR(50), start_time DATETIME, end_time DATETIME); CREATE TABLE games(id INT, name VARCHAR(50), genre VARCHAR(50));", "reference_sql": "SELECT genres.genre, AVG(TIMESTAMPDIFF(SECOND, start_time, end_time)) as avg_session_length FROM game_sessions JOIN games ON game_sessions.game_name = games.name JOIN (SELECT DISTINCT game_name, genre FROM game_sessions JOIN games ON game_sessions.game_name = games.name) genres ON games.name = genres.game_name WHERE start_time >= DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH) GROUP BY genres.genre ORDER BY avg_session_length DESC;", "generated_sql": "SELECT g.genre, AVG(TIMESTAMPDIFF(SECOND, gs.start_time, gs.end_time)) AS avg_session_length\nFROM game_sessions gs\nJOIN games g ON gs.game_name = g.name\nWHERE gs.start_time >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH)\nGROUP BY g.genre\nORDER BY avg_session_length;", "raw_model_output": "\n\n```sql\nSELECT g.genre, AVG(TIMESTAMPDIFF(SECOND, gs.start_time, gs.end_time)) AS avg_session_length\nFROM game_sessions gs\nJOIN games g ON gs.game_name = g.name\nWHERE gs.start_time >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH)\nGROUP BY g.genre\nORDER BY avg_session_length;\n```", "latency_sec": 1.081106185913086, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 139, "prompt_eval_sec": null, "tokens_completion": 76, "completion_eval_sec": null, "tokens_total": 215, "tokens_per_sec": 198.87038183803773, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Reference SQL uses a subquery to ensure distinct (game_name, genre) pairs before joining, which could affect aggregation if duplicates exist. The Generated SQL skips this step, potentially including duplicate game_name entries. Second, the Reference SQL orders results in descending order (ORDER BY avg_session_length DESC), while the Generated SQL uses ascending order (ORDER BY avg_session_length). These differences in logic and sorting make the queries non-equivalent."}
{"example_id": 451, "sql_complexity": "single join", "prompt": "Which customers have made a transaction over 500 in the \"risk_management\" category?", "context": "CREATE TABLE customers (id INT, name VARCHAR(50), category VARCHAR(50)); INSERT INTO customers (id, name, category) VALUES (1, 'John Doe', 'risk_management'); INSERT INTO customers (id, name, category) VALUES (2, 'Jane Smith', 'compliance'); INSERT INTO customers (id, name, category) VALUES (3, 'Jim Brown', 'risk_management'); CREATE TABLE transactions (id INT, customer_id INT, amount DECIMAL(10, 2)); INSERT INTO transactions (id, customer_id, amount) VALUES (1, 1, 500.00); INSERT INTO transactions (id, customer_id, amount) VALUES (2, 1, 200.00); INSERT INTO transactions (id, customer_id, amount) VALUES (3, 2, 100.00); INSERT INTO transactions (id, customer_id, amount) VALUES (4, 3, 750.00);", "reference_sql": "SELECT c.name FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE c.category = 'risk_management' AND t.amount > 500;", "generated_sql": "SELECT c.name\nFROM customers c\nJOIN transactions t ON c.id = t.customer_id\nWHERE c.category = 'risk_management' AND t.amount > 500.00;", "raw_model_output": "\n\n```sql\nSELECT c.name\nFROM customers c\nJOIN transactions t ON c.id = t.customer_id\nWHERE c.category = 'risk_management' AND t.amount > 500.00;\n```", "latency_sec": 0.5932009220123291, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 301, "prompt_eval_sec": null, "tokens_completion": 48, "completion_eval_sec": null, "tokens_total": 349, "tokens_per_sec": 588.3335427330073, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an INNER JOIN between customers and transactions on customer_id, filter for 'risk_management' category and transactions with amount greater than 500. The only difference is the explicit 'INNER' keyword in the Reference and the decimal literal 500.00 vs integer 500 in the amount condition, which are semantically equivalent in SQL."}
{"example_id": 2879, "sql_complexity": "basic SQL", "prompt": "Update the FoodSafetyRecords.OrganicFarms table to include a new record for a certified organic farm in Kenya.", "context": "CREATE TABLE FoodSafetyRecords.OrganicFarms (farmName TEXT, country TEXT, certified BOOLEAN);", "reference_sql": "INSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('Ngong Organic Farm', 'Kenya', TRUE);", "generated_sql": "INSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('New Farm', 'Kenya', TRUE);", "raw_model_output": "\n\nINSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('New Farm', 'Kenya', TRUE);", "latency_sec": 0.39694905281066895, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 117, "prompt_eval_sec": null, "tokens_completion": 34, "completion_eval_sec": null, "tokens_total": 151, "tokens_per_sec": 380.4014619277145, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The two queries differ in the farmName value inserted. The reference query inserts 'Ngong Organic Farm' while the generated query inserts 'New Farm'. Since the semantic equivalence requires identical data production and the farmName values differ, they are not equivalent."}
{"example_id": 5688, "sql_complexity": "single join", "prompt": "What is the total amount donated to a specific cause?", "context": "CREATE TABLE causes (id INT, name TEXT); CREATE TABLE donations (id INT, donor_id INT, cause_id INT, donation_amount DECIMAL(10,2)); INSERT INTO causes (id, name) VALUES (1, 'Cause A'), (2, 'Cause B'); INSERT INTO donations (id, donor_id, cause_id, donation_amount) VALUES (1, 1, 1, 50.00), (2, 2, 1, 100.00);", "reference_sql": "SELECT SUM(donation_amount) FROM donations JOIN causes ON donations.cause_id = causes.id WHERE causes.name = 'Cause A';", "generated_sql": "SELECT SUM(donation_amount) AS total_donated\nFROM donations\nWHERE cause_id = 1;", "raw_model_output": "\n\nSELECT SUM(donation_amount) AS total_donated\nFROM donations\nWHERE cause_id = 1;", "latency_sec": 0.2833900451660156, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 190, "prompt_eval_sec": null, "tokens_completion": 26, "completion_eval_sec": null, "tokens_total": 216, "tokens_per_sec": 762.2003795985946, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the total donations for 'Cause A'. The Reference SQL uses a JOIN with the causes table to filter by name, while the Generated SQL directly uses the known cause_id (1) for 'Cause A'. Since the cause_id 1 corresponds to 'Cause A' in the data, both queries sum the same donations."}
{"example_id": 3273, "sql_complexity": "multiple_joins", "prompt": "List all departments, the number of chemicals they handle, and the number of machines used in their manufacturing processes.", "context": "CREATE TABLE Departments (DepartmentID INT, DepartmentName VARCHAR(20)); INSERT INTO Departments (DepartmentID, DepartmentName) VALUES (1, 'Manufacturing'), (2, 'Engineering'), (3, 'Chemical Safety'), (4, 'Product Development'); CREATE TABLE Chemicals (ChemicalID INT, ChemicalName VARCHAR(20), DepartmentID INT); INSERT INTO Chemicals (ChemicalID, ChemicalName, DepartmentID) VALUES (1, 'Hydrochloric Acid', 1), (2, 'Nitric Acid', 2), (3, 'Sodium Hydroxide', 3), (4, 'New Chemical', 4); CREATE TABLE Machinery (MachineID INT, MachineName VARCHAR(20), DepartmentID INT); INSERT INTO Machinery (MachineID, MachineName, DepartmentID) VALUES (1, 'Mixer 1', 1), (2, 'Cutter 2', 2), (3, 'Dispenser 3', 3), (4, 'Innovator 4', 4);", "reference_sql": "SELECT D.DepartmentName, COUNT(C.ChemicalID) AS ChemicalCount, COUNT(M.MachineID) AS MachineCount FROM Departments D LEFT JOIN Chemicals C ON D.DepartmentID = C.DepartmentID LEFT JOIN Machinery M ON D.DepartmentID = M.DepartmentID GROUP BY D.DepartmentName;", "generated_sql": "SELECT d.DepartmentID, d.DepartmentName, \n       COUNT(c.ChemicalID) AS NumberOfChemicals, \n       COUNT(m.MachineID) AS NumberOfMachines\nFROM Departments d\nLEFT JOIN Chemicals c ON d.DepartmentID = c.DepartmentID\nLEFT JOIN Machinery m ON d.DepartmentID = m.DepartmentID\nGROUP BY d.DepartmentID, d.DepartmentName;", "raw_model_output": "\n\n```sql\nSELECT d.DepartmentID, d.DepartmentName, \n       COUNT(c.ChemicalID) AS NumberOfChemicals, \n       COUNT(m.MachineID) AS NumberOfMachines\nFROM Departments d\nLEFT JOIN Chemicals c ON d.DepartmentID = c.DepartmentID\nLEFT JOIN Machinery m ON d.DepartmentID = m.DepartmentID\nGROUP BY d.DepartmentID, d.DepartmentName;\n```", "latency_sec": 0.7385427951812744, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 314, "prompt_eval_sec": null, "tokens_completion": 86, "completion_eval_sec": null, "tokens_total": 400, "tokens_per_sec": 541.607070856091, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects DepartmentName and groups by it, while the Generated SQL includes DepartmentID in the SELECT and groups by both DepartmentID and DepartmentName. This difference in selected columns and grouping keys leads to different result structures. Additionally, if DepartmentName were not unique, the GROUP BY in the Reference SQL could produce different aggregation results compared to the Generated SQL."}
{"example_id": 1895, "sql_complexity": "window functions", "prompt": "What is the average safety score of chemical production sites in the United States, partitioned by state and ranked in descending order?", "context": "CREATE TABLE production_sites (site_id INT, site_name TEXT, country TEXT, state TEXT, safety_score FLOAT); INSERT INTO production_sites (site_id, site_name, country, state, safety_score) VALUES (1, 'Site A', 'USA', 'NY', 92.5), (2, 'Site B', 'USA', 'CA', 87.4), (3, 'Site C', 'USA', 'TX', 95.3), (4, 'Site D', 'USA', 'FL', 89.2);", "reference_sql": "SELECT state, AVG(safety_score) as avg_safety_score, ROW_NUMBER() OVER (ORDER BY AVG(safety_score) DESC) as rank FROM production_sites WHERE country = 'USA' GROUP BY state ORDER BY rank;", "generated_sql": "SELECT state, AVG(safety_score) AS average_safety_score\nFROM production_sites\nWHERE country = 'USA'\nGROUP BY state\nORDER BY average_safety_score DESC;", "raw_model_output": "\n\n```sql\nSELECT state, AVG(safety_score) AS average_safety_score\nFROM production_sites\nWHERE country = 'USA'\nGROUP BY state\nORDER BY average_safety_score DESC;\n```", "latency_sec": 0.5633950233459473, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 215, "prompt_eval_sec": null, "tokens_completion": 45, "completion_eval_sec": null, "tokens_total": 260, "tokens_per_sec": 461.4879245043482, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a ROW_NUMBER() column based on safety score averages, while the Generated SQL only returns state and average safety score. The Reference SQL also orders by the generated 'rank' column, which would produce the same ordering as the Generated SQL's ORDER BY average_safety_score DESC. However, the additional 'rank' column in the Reference SQL makes the result sets structurally different, so they are not semantically equivalent."}
{"example_id": 4669, "sql_complexity": "set operations", "prompt": "Identify the number of IoT devices in each country and the total number of devices.", "context": "CREATE TABLE device_country (device_id INT, country TEXT); INSERT INTO device_country (device_id, country) VALUES (1, 'USA'), (2, 'Canada'), (3, 'Mexico'), (4, 'Brazil'); CREATE TABLE device_info (device_id INT, device_type TEXT); INSERT INTO device_info (device_id, device_type) VALUES (1, 'Soil Sensor'), (2, 'Temperature Sensor'), (3, 'Humidity Sensor'), (4, 'Precision Sprayer');", "reference_sql": "SELECT country, COUNT(*) AS device_count FROM device_country GROUP BY country UNION SELECT 'Total' AS country, COUNT(*) FROM device_country;", "generated_sql": "SELECT country, COUNT(*) AS num_devices, (SELECT COUNT(*) FROM device_info) AS total_devices\nFROM device_country\nGROUP BY country;", "raw_model_output": "\n\n```sql\nSELECT country, COUNT(*) AS num_devices, (SELECT COUNT(*) FROM device_info) AS total_devices\nFROM device_country\nGROUP BY country;\n```", "latency_sec": 0.509984016418457, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 192, "prompt_eval_sec": null, "tokens_completion": 38, "completion_eval_sec": null, "tokens_total": 230, "tokens_per_sec": 450.9945264858618, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL produces a list of countries with device counts and a separate 'Total' row, while the Generated SQL adds a total_devices column (from device_info) to each country row. The structure and data sources differ: the Reference's total is a standalone row from device_country, whereas the Generated's total is a scalar subquery from device_info. The output formats and semantics are not equivalent."}
{"example_id": 5302, "sql_complexity": "multiple_joins", "prompt": "Find the supplier with the lowest average delivery time for orders in the last month.", "context": "CREATE TABLE Suppliers (SupplierID int, SupplierName varchar(50)); CREATE TABLE Products (ProductID int, ProductName varchar(50), SupplierID int); CREATE TABLE Orders (OrderID int, ProductID int, OrderDate date, DeliveryTime int); INSERT INTO Suppliers VALUES (1, 'SupplierA'), (2, 'SupplierB'); INSERT INTO Products VALUES (1, 'Organic Apples', 1), (2, 'Bananas', 2); INSERT INTO Orders VALUES (1, 1, '2022-01-01', 2), (2, 2, '2022-01-03', 3);", "reference_sql": "SELECT SupplierName, AVG(DeliveryTime) as AvgDeliveryTime FROM Orders o JOIN Products p ON o.ProductID = p.ProductID JOIN Suppliers sp ON p.SupplierID = sp.SupplierID WHERE OrderDate >= DATEADD(month, -1, GETDATE()) GROUP BY SupplierName ORDER BY AvgDeliveryTime ASC;", "generated_sql": "SELECT s.SupplierID, s.SupplierName, AVG(o.DeliveryTime) AS AvgDeliveryTime\nFROM Suppliers s\nJOIN Products p ON s.SupplierID = p.SupplierID\nJOIN Orders o ON p.ProductID = o.ProductID\nWHERE o.OrderDate >= CURRENT_DATE - INTERVAL '1 month'\nGROUP BY s.SupplierID, s.SupplierName\nORDER BY AvgDeliveryTime ASC\nLIMIT 1;", "raw_model_output": "\n\n```sql\nSELECT s.SupplierID, s.SupplierName, AVG(o.DeliveryTime) AS AvgDeliveryTime\nFROM Suppliers s\nJOIN Products p ON s.SupplierID = p.SupplierID\nJOIN Orders o ON p.ProductID = o.ProductID\nWHERE o.OrderDate >= CURRENT_DATE - INTERVAL '1 month'\nGROUP BY s.SupplierID, s.SupplierName\nORDER BY AvgDeliveryTime ASC\nLIMIT 1;\n```", "latency_sec": 1.0217671394348145, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 232, "prompt_eval_sec": null, "tokens_completion": 97, "completion_eval_sec": null, "tokens_total": 329, "tokens_per_sec": 321.9911732354054, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in three key aspects: 1) The Generated query includes a LIMIT 1 clause which restricts output to a single row, while the Reference query returns all suppliers. 2) The GROUP BY clause in the Reference uses only SupplierName (which could be ambiguous if multiple suppliers had the same name), whereas the Generated query groups by both SupplierID and SupplierName (more precise). 3) The date filtering syntax differs (DATEADD vs CURRENT_DATE - INTERVAL) but would produce equivalent results. The LIMIT 1 makes them non-equivalent as they return different quantities of data."}
{"example_id": 267, "sql_complexity": "subqueries", "prompt": "What is the total number of disability support programs offered in urban and rural areas, and the percentage of total programs for each area type?", "context": "CREATE TABLE programs (program_id INT, program_name VARCHAR(255), area_type VARCHAR(255));", "reference_sql": "SELECT area_type, COUNT(*) as total_programs, ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM programs) , 2) as percentage_of_total FROM programs WHERE area_type IN ('urban', 'rural') GROUP BY area_type;", "generated_sql": "SELECT \n    area_type,\n    COUNT(*) AS total_programs,\n    (COUNT(*) * 100.0 / SUM(COUNT(*)) OVER ()) AS percentage_of_total\nFROM \n    programs\nWHERE \n    program_name LIKE '%disability support%'\nGROUP BY \n    area_type;", "raw_model_output": "\n\n```sql\nSELECT \n    area_type,\n    COUNT(*) AS total_programs,\n    (COUNT(*) * 100.0 / SUM(COUNT(*)) OVER ()) AS percentage_of_total\nFROM \n    programs\nWHERE \n    program_name LIKE '%disability support%'\nGROUP BY \n    area_type;\n```", "latency_sec": 0.770263671875, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 123, "prompt_eval_sec": null, "tokens_completion": 70, "completion_eval_sec": null, "tokens_total": 193, "tokens_per_sec": 250.5635499207607, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates percentages based on all programs (total count from the entire programs table) and filters by area_type ('urban'/'rural'). The Generated SQL calculates percentages based on a filtered subset (programs with 'disability support' in program_name) and uses a window function. The WHERE clauses filter different columns (area_type vs. program_name), and the percentage calculations reference different totals (global count vs. subset total)."}
{"example_id": 3028, "sql_complexity": "basic SQL", "prompt": "What is the number of startups founded by non-binary individuals in the technology industry?", "context": "CREATE TABLE company (id INT, name TEXT, founder_gender TEXT, industry TEXT); INSERT INTO company (id, name, founder_gender, industry) VALUES (1, 'CodeForAll', 'Non-binary', 'Technology'); INSERT INTO company (id, name, founder_gender, industry) VALUES (2, 'TechVillage', 'Male', 'Technology');", "reference_sql": "SELECT COUNT(*) FROM company WHERE founder_gender = 'Non-binary' AND industry = 'Technology';", "generated_sql": "SELECT COUNT(*) FROM company WHERE founder_gender = 'Non-binary' AND industry = 'Technology';", "raw_model_output": "\n\n```sql\nSELECT COUNT(*) FROM company WHERE founder_gender = 'Non-binary' AND industry = 'Technology';\n```", "latency_sec": 0.2784841060638428, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 162, "prompt_eval_sec": null, "tokens_completion": 28, "completion_eval_sec": null, "tokens_total": 190, "tokens_per_sec": 682.2651485770692, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure and conditions. Both queries count rows from the 'company' table where founder_gender is 'Non-binary' and industry is 'Technology', producing the same result."}
{"example_id": 3282, "sql_complexity": "aggregation", "prompt": "Which marine species have been observed in both the Arctic and Antarctic oceans?", "context": "CREATE TABLE marine_species (id INT, species_name VARCHAR(50), common_name VARCHAR(50), region VARCHAR(20));INSERT INTO marine_species (id, species_name, common_name, region) VALUES (1, 'Orcinus_orca', 'Killer Whale', 'Arctic');INSERT INTO marine_species (id, species_name, common_name, region) VALUES (2, 'Balaenoptera_bonaerensis', 'Antarctic Minke Whale', 'Antarctic');", "reference_sql": "SELECT species_name FROM marine_species WHERE region IN ('Arctic', 'Antarctic') GROUP BY species_name HAVING COUNT(DISTINCT region) = 2;", "generated_sql": "SELECT ms1.species_name\nFROM marine_species ms1\nWHERE ms1.region = 'Arctic'\nAND ms1.species_name IN (\n    SELECT species_name\n    FROM marine_species\n    WHERE region = 'Antarctic'\n);", "raw_model_output": "\n\n```sql\nSELECT ms1.species_name\nFROM marine_species ms1\nWHERE ms1.region = 'Arctic'\nAND ms1.species_name IN (\n    SELECT species_name\n    FROM marine_species\n    WHERE region = 'Antarctic'\n);\n```", "latency_sec": 0.8570108413696289, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 192, "prompt_eval_sec": null, "tokens_completion": 57, "completion_eval_sec": null, "tokens_total": 249, "tokens_per_sec": 290.5447492380161, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve species present in both 'Arctic' and 'Antarctic' regions. The Reference SQL uses GROUP BY and HAVING to ensure a species appears in both regions, while the Generated SQL uses a subquery to find species in the Arctic that also exist in the Antarctic. Both approaches effectively identify species with entries in both regions."}
{"example_id": 3474, "sql_complexity": "subqueries", "prompt": "What is the total transaction volume for the top 3 digital assets by market capitalization in the 'developed_markets' schema?", "context": "CREATE SCHEMA developed_markets; CREATE TABLE developed_markets.digital_assets (asset_name VARCHAR(10), market_cap BIGINT, daily_transaction_volume BIGINT); INSERT INTO developed_markets.digital_assets (asset_name, market_cap, daily_transaction_volume) VALUES ('AssetG', 30000000, 15000000), ('AssetH', 25000000, 12000000), ('AssetI', 20000000, 10000000), ('AssetJ', 15000000, 8000000), ('AssetK', 10000000, 6000000);", "reference_sql": "SELECT SUM(daily_transaction_volume) FROM (SELECT daily_transaction_volume FROM developed_markets.digital_assets ORDER BY market_cap DESC FETCH NEXT 3 ROWS ONLY) t;", "generated_sql": "SELECT SUM(daily_transaction_volume) AS total_transaction_volume\nFROM developed_markets.digital_assets\nORDER BY market_cap DESC\nLIMIT 3;", "raw_model_output": "\n\n```sql\nSELECT SUM(daily_transaction_volume) AS total_transaction_volume\nFROM developed_markets.digital_assets\nORDER BY market_cap DESC\nLIMIT 3;\n```", "latency_sec": 0.4657599925994873, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 269, "prompt_eval_sec": null, "tokens_completion": 38, "completion_eval_sec": null, "tokens_total": 307, "tokens_per_sec": 659.1377638224781, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of the top 3 daily_transaction_volume values based on descending market_cap. The Reference SQL uses a subquery with FETCH NEXT 3 ROWS ONLY, while the Generated SQL uses LIMIT 3. Both achieve the same result by ordering the assets by market_cap descending, selecting the top 3 rows, and summing their daily_transaction_volume. The syntax differs (FETCH NEXT vs. LIMIT), but the semantic outcome is identical."}
{"example_id": 1626, "sql_complexity": "aggregation", "prompt": "Find the total value of social impact bonds issued by each organization.", "context": "CREATE TABLE social_impact_bonds (id INT, organization_name VARCHAR(255), issue_year INT, value FLOAT); INSERT INTO social_impact_bonds (id, organization_name, issue_year, value) VALUES (1, 'Acme Corp', 2018, 2000000), (2, 'XYZ Foundation', 2019, 3000000), (3, 'Global Giving', 2018, 1500000), (4, 'Acme Corp', 2019, 2500000), (5, 'XYZ Foundation', 2018, 1000000);", "reference_sql": "SELECT organization_name, SUM(value) as total_value FROM social_impact_bonds GROUP BY organization_name;", "generated_sql": "SELECT organization_name, SUM(value) AS total_value\nFROM social_impact_bonds\nGROUP BY organization_name;", "raw_model_output": "\n\nSELECT organization_name, SUM(value) AS total_value\nFROM social_impact_bonds\nGROUP BY organization_name;", "latency_sec": 0.3878629207611084, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 242, "prompt_eval_sec": null, "tokens_completion": 28, "completion_eval_sec": null, "tokens_total": 270, "tokens_per_sec": 696.1222265592585, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select organization_name and sum the value column, grouping by organization_name. The only differences are whitespace and formatting, which do not affect semantic equivalence."}
{"example_id": 1315, "sql_complexity": "single join", "prompt": "List all the transactions made by clients living in New York with a transaction amount greater than $1000.", "context": "CREATE TABLE transactions (id INT, client_id INT, transaction_amount DECIMAL(10,2), transaction_date DATE); INSERT INTO transactions (id, client_id, transaction_amount, transaction_date) VALUES (1, 3, 1500.00, '2022-01-01'), (2, 4, 800.00, '2022-01-02'), (3, 3, 1200.00, '2022-01-03'); CREATE TABLE clients (id INT, name VARCHAR(255), state VARCHAR(255)); INSERT INTO clients (id, name, state) VALUES (3, 'Mike Johnson', 'New York'), (4, 'Sara Lee', 'California');", "reference_sql": "SELECT transactions.id, transactions.client_id, transactions.transaction_amount, transactions.transaction_date FROM transactions INNER JOIN clients ON transactions.client_id = clients.id WHERE clients.state = 'New York' AND transactions.transaction_amount > 1000.00;", "generated_sql": "SELECT t.*\nFROM transactions t\nJOIN clients c ON t.client_id = c.id\nWHERE c.state = 'New York' AND t.transaction_amount > 1000;", "raw_model_output": "\n\n```sql\nSELECT t.*\nFROM transactions t\nJOIN clients c ON t.client_id = c.id\nWHERE c.state = 'New York' AND t.transaction_amount > 1000;\n```", "latency_sec": 0.5131940841674805, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 270, "prompt_eval_sec": null, "tokens_completion": 46, "completion_eval_sec": null, "tokens_total": 316, "tokens_per_sec": 615.75144715985, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same data by joining transactions with clients on client_id, filtering for 'New York' state and transaction_amount > 1000. The Reference SQL explicitly lists columns while the Generated SQL uses t.*, but since transactions has exactly those columns, the result sets are identical. The numeric comparison 1000.00 vs 1000 is functionally equivalent due to implicit type conversion."}
{"example_id": 520, "sql_complexity": "multiple_joins", "prompt": "What is the total number of electric vehicles sold in 'California' in the 'sales' schema?", "context": "CREATE TABLE sales_regions (id INT, name VARCHAR(50));   CREATE TABLE sales (id INT, region_id INT, vehicle_count INT);   CREATE TABLE vehicles (id INT, type VARCHAR(50));   INSERT INTO sales_regions VALUES (1, 'California');   INSERT INTO sales VALUES (1, 1, 5000);   INSERT INTO vehicles VALUES (1, 'electric');", "reference_sql": "SELECT SUM(sales.vehicle_count) FROM sales INNER JOIN sales_regions ON sales.region_id = sales_regions.id INNER JOIN vehicles ON sales.id = vehicles.id WHERE vehicles.type = 'electric' AND sales_regions.name = 'California';", "generated_sql": "SELECT SUM(s.vehicle_count)  \nFROM sales s  \nJOIN sales_regions sr ON s.region_id = sr.id  \nJOIN vehicles v ON s.id = v.id  \nWHERE sr.name = 'California' AND v.type = 'electric';", "raw_model_output": "\n\nSELECT SUM(s.vehicle_count)  \nFROM sales s  \nJOIN sales_regions sr ON s.region_id = sr.id  \nJOIN vehicles v ON s.id = v.id  \nWHERE sr.name = 'California' AND v.type = 'electric';", "latency_sec": 0.5373361110687256, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 176, "prompt_eval_sec": null, "tokens_completion": 52, "completion_eval_sec": null, "tokens_total": 228, "tokens_per_sec": 424.31542437474235, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform the same operations: joining the sales, sales_regions, and vehicles tables on identical conditions, filtering with the same WHERE clause (sr.name = 'California' AND v.type = 'electric'), and summing the vehicle_count column. The generated query uses table aliases (s, sr, v) but references the same columns as the original query. The semantic meaning remains unchanged."}
{"example_id": 3999, "sql_complexity": "single join", "prompt": "What is the total number of tickets sold for performances with a rating of 5?", "context": "CREATE TABLE performance (id INT PRIMARY KEY, name VARCHAR(255), date DATE, artist_id INT, rating INT); INSERT INTO performance (id, name, date, artist_id, rating) VALUES (1, 'Dance Recital', '2022-03-01', 1, 5);", "reference_sql": "SELECT SUM(t.quantity) as total_tickets_sold FROM performance p INNER JOIN ticket t ON p.id = t.performance_id WHERE p.rating = 5;", "generated_sql": "None of the provided tables contain information about tickets sold. Therefore, it is not possible to determine the total number of tickets sold for performances with a rating of 5 based on the given schema.", "raw_model_output": "\n\nNone of the provided tables contain information about tickets sold. Therefore, it is not possible to determine the total number of tickets sold for performances with a rating of 5 based on the given schema.", "latency_sec": 0.490415096282959, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 158, "prompt_eval_sec": null, "tokens_completion": 44, "completion_eval_sec": null, "tokens_total": 202, "tokens_per_sec": 411.89596635795715, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references a 'ticket' table that does not exist in the provided schema. The Generated SQL correctly states that the necessary data (tickets sold) cannot be determined from the given tables. Since the Reference SQL is invalid due to missing schema elements, the queries are not equivalent."}
{"example_id": 2261, "sql_complexity": "multiple_joins", "prompt": "What is the total number of animals that have been released into 'protected' habitats, and the average weight of those animals?", "context": "CREATE TABLE habitats (habitat_id INT, habitat_name VARCHAR(50), habitat_status VARCHAR(50)); INSERT INTO habitats (habitat_id, habitat_name, habitat_status) VALUES (1, 'Habitat A', 'protected'), (2, 'Habitat B', 'unprotected'); CREATE TABLE animal_habitats (animal_id INT, habitat_id INT, animal_weight FLOAT); INSERT INTO animal_habitats (animal_id, habitat_id, animal_weight) VALUES (101, 1, 25.5), (102, 2, 15.2); CREATE TABLE animals (animal_id INT, animal_name VARCHAR(50)); INSERT INTO animals (animal_id, animal_name) VALUES (101, 'Dog'), (102, 'Cat');", "reference_sql": "SELECT COUNT(*), AVG(animal_habitats.animal_weight) FROM animal_habitats INNER JOIN animals ON animal_habitats.animal_id = animals.animal_id INNER JOIN habitats ON animal_habitats.habitat_id = habitats.habitat_id WHERE habitats.habitat_status = 'protected';", "generated_sql": "SELECT COUNT(a.animal_id) AS total_animals, AVG(ah.animal_weight) AS average_weight\nFROM animals a\nJOIN animal_habitats ah ON a.animal_id = ah.animal_id\nJOIN habitats h ON ah.habitat_id = h.habitat_id\nWHERE h.habitat_status = 'protected';", "raw_model_output": "\n\n```sql\nSELECT COUNT(a.animal_id) AS total_animals, AVG(ah.animal_weight) AS average_weight\nFROM animals a\nJOIN animal_habitats ah ON a.animal_id = ah.animal_id\nJOIN habitats h ON ah.habitat_id = h.habitat_id\nWHERE h.habitat_status = 'protected';\n```", "latency_sec": 1.1175041198730469, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 266, "prompt_eval_sec": null, "tokens_completion": 79, "completion_eval_sec": null, "tokens_total": 345, "tokens_per_sec": 308.7236940470461, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform the same inner joins between animals, animal_habitats, and habitats tables, filter on 'protected' habitat status, and calculate COUNT(*) and AVG(animal_weight). The generated query uses table aliases (a, ah, h) and explicit column aliases, but these are syntactic variations that do not affect the semantic result. The aggregation functions and join conditions are identical in logic."}
{"example_id": 3439, "sql_complexity": "multiple_joins", "prompt": "How many menu items contain ingredients sourced from local suppliers for each restaurant?", "context": "CREATE TABLE restaurants (id INT, name VARCHAR(50), location VARCHAR(50)); INSERT INTO restaurants VALUES (1, 'Restaurant A', 'City A'); INSERT INTO restaurants VALUES (2, 'Restaurant B', 'City B'); CREATE TABLE menu_items (id INT, name VARCHAR(50), restaurant_id INT, price DECIMAL(5,2)); INSERT INTO menu_items VALUES (1, 'Item A', 1, 10.99); INSERT INTO menu_items VALUES (2, 'Item B', 1, 12.99); INSERT INTO menu_items VALUES (3, 'Item C', 2, 11.99); CREATE TABLE ingredients (id INT, name VARCHAR(50), local_source BOOLEAN, menu_item_id INT); INSERT INTO ingredients VALUES (1, 'Ingredient A', TRUE, 1); INSERT INTO ingredients VALUES (2, 'Ingredient B', FALSE, 1); INSERT INTO ingredients VALUES (3, 'Ingredient C', TRUE, 2); INSERT INTO ingredients VALUES (4, 'Ingredient D', FALSE, 2); INSERT INTO ingredients VALUES (5, 'Ingredient E', TRUE, 3);", "reference_sql": "SELECT r.name, COUNT(DISTINCT mi.id) as num_local_items FROM restaurants r JOIN menu_items mi ON r.id = mi.restaurant_id JOIN ingredients i ON mi.id = i.menu_item_id WHERE i.local_source = TRUE GROUP BY r.name;", "generated_sql": "SELECT r.name AS restaurant_name, COUNT(DISTINCT mi.id) AS local_ingredient_menu_items\nFROM restaurants r\nJOIN menu_items mi ON r.id = mi.restaurant_id\nJOIN ingredients i ON mi.id = i.menu_item_id\nWHERE i.local_source = TRUE\nGROUP BY r.name;", "raw_model_output": "\n\n```sql\nSELECT r.name AS restaurant_name, COUNT(DISTINCT mi.id) AS local_ingredient_menu_items\nFROM restaurants r\nJOIN menu_items mi ON r.id = mi.restaurant_id\nJOIN ingredients i ON mi.id = i.menu_item_id\nWHERE i.local_source = TRUE\nGROUP BY r.name;\n```", "latency_sec": 0.6156620979309082, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 329, "prompt_eval_sec": null, "tokens_completion": 70, "completion_eval_sec": null, "tokens_total": 399, "tokens_per_sec": 648.0827735554012, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries perform the same operations: joining restaurants, menu_items, and ingredients tables; filtering on local_source = TRUE; grouping by restaurant name; and counting distinct menu item IDs. The only differences are column aliases (e.g., 'num_local_items' vs 'local_ingredient_menu_items' and 'r.name' vs 'restaurant_name'), which do not affect the semantic result."}
{"example_id": 2265, "sql_complexity": "aggregation", "prompt": "Hourly revenue for a specific movie?", "context": "CREATE TABLE Movie_Revenue (id INT, movie_title VARCHAR(100), revenue_time TIME, revenue DECIMAL(10,2));", "reference_sql": "SELECT revenue_time, SUM(revenue) FROM Movie_Revenue WHERE movie_title = 'Spider-Man: No Way Home' GROUP BY revenue_time;", "generated_sql": "SELECT revenue_time, revenue \nFROM Movie_Revenue \nWHERE movie_title = 'specific_movie';", "raw_model_output": "\n\nSELECT revenue_time, revenue \nFROM Movie_Revenue \nWHERE movie_title = 'specific_movie';", "latency_sec": 0.33083319664001465, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 110, "prompt_eval_sec": null, "tokens_completion": 24, "completion_eval_sec": null, "tokens_total": 134, "tokens_per_sec": 405.0379507284081, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query aggregates revenue by revenue_time using SUM(), while the generated query retrieves individual revenue records without aggregation. The WHERE clause also uses a different movie title placeholder ('specific_movie' vs 'Spider-Man: No Way Home')."}
{"example_id": 1763, "sql_complexity": "multiple_joins", "prompt": "What is the total food and beverage revenue last month for hotels in 'Bangkok'?", "context": "CREATE TABLE revenue (hotel_id INT, revenue_source VARCHAR(50), revenue INT, revenue_date DATE); INSERT INTO revenue (hotel_id, revenue_source, revenue, revenue_date) VALUES (5, 'Room revenue', 12000, '2022-03-01'), (5, 'Food and beverage', 4000, '2022-03-02'), (5, 'Other revenue', 1000, '2022-03-03'); CREATE TABLE hotels (hotel_id INT, city VARCHAR(50)); INSERT INTO hotels (hotel_id, city) VALUES (5, 'Bangkok'); CREATE TABLE dates (date DATE); INSERT INTO dates (date) VALUES ('2022-03-01'), ('2022-03-02'), ('2022-03-03');", "reference_sql": "SELECT SUM(revenue) FROM revenue JOIN hotels ON revenue.hotel_id = hotels.hotel_id JOIN dates ON revenue.revenue_date = dates.date WHERE hotels.city = 'Bangkok' AND revenue_source = 'Food and beverage' AND dates.date >= DATEADD(month, -1, GETDATE());", "generated_sql": "SELECT SUM(r.revenue) AS total_food_and_beverage_revenue\nFROM revenue r\nJOIN hotels h ON r.hotel_id = h.hotel_id\nWHERE h.city = 'Bangkok'\n  AND r.revenue_source = 'Food and beverage'\n  AND r.revenue_date >= DATEADD(MONTH, -1, CURRENT_DATE);", "raw_model_output": "\n\n```sql\nSELECT SUM(r.revenue) AS total_food_and_beverage_revenue\nFROM revenue r\nJOIN hotels h ON r.hotel_id = h.hotel_id\nWHERE h.city = 'Bangkok'\n  AND r.revenue_source = 'Food and beverage'\n  AND r.revenue_date >= DATEADD(MONTH, -1, CURRENT_DATE);\n```", "latency_sec": 1.0757050514221191, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 286, "prompt_eval_sec": null, "tokens_completion": 82, "completion_eval_sec": null, "tokens_total": 368, "tokens_per_sec": 342.101210283889, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of 'Food and beverage' revenue for hotels in Bangkok within the last month. The Reference query includes an unnecessary join with the dates table, but since the dates.date column is directly compared to revenue_date and the WHERE clause filters dates.date, this join doesn't affect the result. The Generated query simplifies this by directly using revenue_date. Both use equivalent date functions (DATEADD with month offset) and filter conditions. The semantic result remains the same."}
{"example_id": 5499, "sql_complexity": "set operations", "prompt": "How many legal aid clinics and community mediation centers are there in total, and what is the sum of cases handled by each type of center, for centers located in the state of California?", "context": "CREATE TABLE LegalAidClinics (ClinicName text, State text, NumCases int); INSERT INTO LegalAidClinics VALUES ('Clinic1', 'CA', 30, '2022-01-01'), ('Clinic2', 'CA', 25, '2022-01-01'); CREATE TABLE CommunityMediationCenters (CenterName text, State text, NumCases int); INSERT INTO CommunityMediationCenters VALUES ('CM1', 'CA', 22, '2022-01-01'), ('CM2', 'CA', 28, '2022-01-01');", "reference_sql": "SELECT State, 'Legal Aid Clinics' AS CenterType, COUNT(*) AS NumCenters, SUM(NumCases) AS TotalCases FROM LegalAidClinics WHERE State = 'CA' UNION ALL SELECT State, 'Community Mediation Centers', COUNT(*), SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA';", "generated_sql": "SELECT \n    (SELECT COUNT(*) FROM LegalAidClinics WHERE State = 'CA') + \n    (SELECT COUNT(*) FROM CommunityMediationCenters WHERE State = 'CA') AS TotalCenters,\n    (SELECT SUM(NumCases) FROM LegalAidClinics WHERE State = 'CA') + \n    (SELECT SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA') AS TotalCases;", "raw_model_output": "\n\n```sql\nSELECT \n    (SELECT COUNT(*) FROM LegalAidClinics WHERE State = 'CA') + \n    (SELECT COUNT(*) FROM CommunityMediationCenters WHERE State = 'CA') AS TotalCenters,\n    (SELECT SUM(NumCases) FROM LegalAidClinics WHERE State = 'CA') + \n    (SELECT SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA') AS TotalCases;\n```", "latency_sec": 1.3772847652435303, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 258, "prompt_eval_sec": null, "tokens_completion": 98, "completion_eval_sec": null, "tokens_total": 356, "tokens_per_sec": 258.47958895926104, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two rows (one for each center type) with State, CenterType, NumCenters, and TotalCases, while the Generated SQL returns a single row with aggregated totals for all centers. The structure and grouping differ: the Reference distinguishes between center types, whereas the Generated combines them into overall totals."}
{"example_id": 2408, "sql_complexity": "aggregation", "prompt": "What is the average number of victories for players from Japan and South Korea, partitioned by game mode?", "context": "CREATE TABLE PlayerVictories (PlayerID INT, GameMode VARCHAR(255), Victories INT, Country VARCHAR(255)); INSERT INTO PlayerVictories (PlayerID, GameMode, Victories, Country) VALUES (1, 'Battle Royale', 25, 'Japan'), (2, 'Team Deathmatch', 18, 'South Korea');", "reference_sql": "SELECT GameMode, AVG(Victories) as AvgVictories FROM PlayerVictories WHERE Country IN ('Japan', 'South Korea') GROUP BY GameMode, Country WITH ROLLUP;", "generated_sql": "SELECT GameMode, AVG(Victories) AS AverageVictories\nFROM PlayerVictories\nWHERE Country IN ('Japan', 'South Korea')\nGROUP BY GameMode;", "raw_model_output": "\n\n```sql\nSELECT GameMode, AVG(Victories) AS AverageVictories\nFROM PlayerVictories\nWHERE Country IN ('Japan', 'South Korea')\nGROUP BY GameMode;\n```", "latency_sec": 0.5026712417602539, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 170, "prompt_eval_sec": null, "tokens_completion": 43, "completion_eval_sec": null, "tokens_total": 213, "tokens_per_sec": 423.7361963539364, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses GROUP BY GameMode, Country WITH ROLLUP which adds summary rows for each GameMode/Country combination and overall totals, while the Generated SQL only groups by GameMode. This results in different row counts and aggregation levels. The Reference query's output includes more detailed grouping and rollup summaries that the Generated query lacks."}
{"example_id": 2729, "sql_complexity": "subqueries", "prompt": "Find the total number of trips made by shared autonomous vehicles in Seattle", "context": "CREATE TABLE shared_vehicles (id INT, vehicle_type VARCHAR(20), is_autonomous BOOLEAN, trip_count INT); INSERT INTO shared_vehicles (id, vehicle_type, is_autonomous, trip_count) VALUES (1, 'ebike', false, 1200), (2, 'escooter', false, 800), (3, 'car', true, 1500); CREATE TABLE city_data (city VARCHAR(20), has_autonomous_vehicles BOOLEAN); INSERT INTO city_data (city, has_autonomous_vehicles) VALUES ('Seattle', true), ('Denver', false), ('Portland', true);", "reference_sql": "SELECT SUM(trip_count) FROM shared_vehicles WHERE is_autonomous = true AND vehicle_type != 'ebike' AND vehicle_type != 'escooter' AND city IN (SELECT city FROM city_data WHERE has_autonomous_vehicles = true AND city = 'Seattle');", "generated_sql": "SELECT SUM(sv.trip_count) \nFROM shared_vehicles sv \nJOIN city_data cd ON sv.vehicle_type = 'car' \nWHERE cd.city = 'Seattle' AND sv.is_autonomous = true;", "raw_model_output": "\n\n```sql\nSELECT SUM(sv.trip_count) \nFROM shared_vehicles sv \nJOIN city_data cd ON sv.vehicle_type = 'car' \nWHERE cd.city = 'Seattle' AND sv.is_autonomous = true;\n```", "latency_sec": 0.7603621482849121, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 220, "prompt_eval_sec": null, "tokens_completion": 50, "completion_eval_sec": null, "tokens_total": 270, "tokens_per_sec": 355.093951755775, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references a non-existent 'city' column in the shared_vehicles table, making it invalid. The Generated SQL incorrectly joins shared_vehicles with city_data on a constant ('car') instead of a proper relationship. Even if both queries were valid, the Reference SQL would filter autonomous vehicles with non-ebike/escooter types and check against cities with autonomous vehicles, while the Generated SQL only considers 'car' types in Seattle. The logic and structure differ significantly."}
{"example_id": 2952, "sql_complexity": "aggregation", "prompt": "Show the total budget allocated for each program category in 2023.", "context": "CREATE TABLE Budget (id INT, category TEXT, year INT, allocated_amount INT); INSERT INTO Budget (id, category, year, allocated_amount) VALUES (1, 'Education', 2023, 30000); INSERT INTO Budget (id, category, year, allocated_amount) VALUES (2, 'Healthcare', 2023, 50000);", "reference_sql": "SELECT category, SUM(allocated_amount) FROM Budget WHERE year = 2023 GROUP BY category;", "generated_sql": "SELECT category, SUM(allocated_amount) AS total_budget\nFROM Budget\nWHERE year = 2023\nGROUP BY category;", "raw_model_output": "\n\nSELECT category, SUM(allocated_amount) AS total_budget\nFROM Budget\nWHERE year = 2023\nGROUP BY category;", "latency_sec": 0.4951019287109375, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 172, "prompt_eval_sec": null, "tokens_completion": 33, "completion_eval_sec": null, "tokens_total": 205, "tokens_per_sec": 414.05615311122756, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (category and summed allocated_amount) from the Budget table where year is 2023, grouped by category. The only difference is the alias 'total_budget' in the generated query, which doesn't affect the semantic meaning of the result."}
{"example_id": 4328, "sql_complexity": "aggregation", "prompt": "What is the average cargo handling time in hours for each port?", "context": "CREATE TABLE cargo_handling (id INT, port_id INT, time_in_hours DECIMAL(5,2)); INSERT INTO cargo_handling (id, port_id, time_in_hours) VALUES (1, 1, 20.5), (2, 1, 22.3), (3, 2, 18.7);", "reference_sql": "SELECT port_id, AVG(time_in_hours) FROM cargo_handling GROUP BY port_id;", "generated_sql": "SELECT port_id, AVG(time_in_hours) AS average_time_in_hours\nFROM cargo_handling\nGROUP BY port_id;", "raw_model_output": "\n\nSELECT port_id, AVG(time_in_hours) AS average_time_in_hours\nFROM cargo_handling\nGROUP BY port_id;", "latency_sec": 0.354205846786499, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 158, "prompt_eval_sec": null, "tokens_completion": 29, "completion_eval_sec": null, "tokens_total": 187, "tokens_per_sec": 527.9415958165029, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries compute the average time_in_hours per port_id. The generated query adds an alias (average_time_in_hours) for the computed column, but this does not affect the semantic result. The GROUP BY logic and aggregation function remain identical."}
{"example_id": 4915, "sql_complexity": "window functions", "prompt": "Calculate the percentage of total Europium production for each country.", "context": "CREATE TABLE europium_production (country VARCHAR(50), quantity INT);", "reference_sql": "SELECT country, quantity * 100.0 / SUM(quantity) OVER (PARTITION BY NULL) AS percentage FROM europium_production;", "generated_sql": "SELECT country, (quantity * 100.0 / SUM(quantity) OVER ()) AS percentage_of_total\nFROM europium_production;", "raw_model_output": "\n\n```sql\nSELECT country, (quantity * 100.0 / SUM(quantity) OVER ()) AS percentage_of_total\nFROM europium_production;\n```", "latency_sec": 0.41255688667297363, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 99, "prompt_eval_sec": null, "tokens_completion": 37, "completion_eval_sec": null, "tokens_total": 136, "tokens_per_sec": 329.65150841804933, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the percentage of each country's quantity relative to the total quantity. The window function SUM(quantity) OVER (PARTITION BY NULL) in the reference query is equivalent to SUM(quantity) OVER () in the generated query, as PARTITION BY NULL defines the entire result set as a single partition. The column alias difference ('percentage' vs 'percentage_of_total') does not affect semantic equivalence."}
{"example_id": 5030, "sql_complexity": "subqueries", "prompt": "What is the success rate of diverse-led startups (at least 1 female or underrepresented racial or ethnic group executive) in the past 3 years?", "context": "CREATE TABLE DiverseStartups(id INT, name TEXT, country TEXT, year INT, success BOOLEAN);   INSERT INTO DiverseStartups VALUES (1, 'FemTech', 'USA', 2020, true), (2, 'GreenCity', 'Canada', 2019, false), (3, 'AI-Health', 'UK', 2021, true), (4, 'SolarEnergy', 'USA', 2020, false), (5, 'DataAnalytics', 'Germany', 2019, true), (6, 'SmartGrid', 'USA', 2021, true), (7, 'CloudServices', 'India', 2020, false), (8, 'RenewableEnergy', 'USA', 2019, true);", "reference_sql": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3) AS success_rate FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3 AND success = true;", "generated_sql": "SELECT \n    COUNT(*) FILTER (WHERE success = true) * 1.0 / COUNT(*) AS success_rate\nFROM DiverseStartups\nWHERE year >= EXTRACT(YEAR FROM CURRENT_DATE) - 2;", "raw_model_output": "\n\n```sql\nSELECT \n    COUNT(*) FILTER (WHERE success = true) * 1.0 / COUNT(*) AS success_rate\nFROM DiverseStartups\nWHERE year >= EXTRACT(YEAR FROM CURRENT_DATE) - 2;\n```", "latency_sec": 0.5736780166625977, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 280, "prompt_eval_sec": null, "tokens_completion": 54, "completion_eval_sec": null, "tokens_total": 334, "tokens_per_sec": 582.2081207557206, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Reference SQL uses `YEAR(CURRENT_DATE) - 3` (3 years ago) while the Generated SQL uses `EXTRACT(YEAR FROM CURRENT_DATE) - 2` (2 years ago), resulting in different time frames. Second, the Reference calculates a percentage (multiplied by 100.0) while the Generated returns a decimal (multiplied by 1.0). These differences in time range and scaling factor make the queries non-equivalent."}
{"example_id": 4626, "sql_complexity": "aggregation", "prompt": "What was the maximum number of training hours for farmers in each country in 2020?", "context": "CREATE TABLE training (id INT, country_id INT, farmer_id INT, hours INT, date DATE);", "reference_sql": "SELECT country_id, MAX(hours) FROM training WHERE YEAR(date) = 2020 GROUP BY country_id;", "generated_sql": "SELECT country_id, MAX(hours) AS max_hours\nFROM training\nWHERE YEAR(date) = 2020\nGROUP BY country_id;", "raw_model_output": "\n\n```sql\nSELECT country_id, MAX(hours) AS max_hours\nFROM training\nWHERE YEAR(date) = 2020\nGROUP BY country_id;\n```", "latency_sec": 0.7109229564666748, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 113, "prompt_eval_sec": null, "tokens_completion": 39, "completion_eval_sec": null, "tokens_total": 152, "tokens_per_sec": 213.80657160861446, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. The generated SQL adds an alias 'max_hours' for the MAX(hours) column, but the selection of country_id, filtering by YEAR(date) = 2020, and grouping by country_id remain identical. The result set structure and data will be the same, with only the column name differing."}
{"example_id": 2703, "sql_complexity": "set operations", "prompt": "Identify the species unique to 'MarineResearchAreaA' and 'MarineResearchAreaB'", "context": "CREATE TABLE ResearchAreaSpecies (area VARCHAR(255), species VARCHAR(255)); INSERT INTO ResearchAreaSpecies (area, species) VALUES ('MarineResearchAreaA', 'Coral'), ('MarineResearchAreaA', 'Starfish'), ('MarineResearchAreaB', 'Jellyfish');", "reference_sql": "(SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB') UNION (SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA');", "generated_sql": "SELECT r1.species\nFROM ResearchAreaSpecies r1\nWHERE r1.area = 'MarineResearchAreaA'\nAND r1.species NOT IN (\n    SELECT r2.species\n    FROM ResearchAreaSpecies r2\n    WHERE r2.area = 'MarineResearchAreaB'\n);", "raw_model_output": "\n\n```sql\nSELECT r1.species\nFROM ResearchAreaSpecies r1\nWHERE r1.area = 'MarineResearchAreaA'\nAND r1.species NOT IN (\n    SELECT r2.species\n    FROM ResearchAreaSpecies r2\n    WHERE r2.area = 'MarineResearchAreaB'\n);\n```", "latency_sec": 1.0762159824371338, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 158, "prompt_eval_sec": null, "tokens_completion": 68, "completion_eval_sec": null, "tokens_total": 226, "tokens_per_sec": 209.99502301407384, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL computes the symmetric difference between the two areas (species in A not in B OR species in B not in A), while the Generated SQL only returns species present in A but not in B. The Generated SQL lacks the reverse EXCEPT clause to capture species in B not in A."}
{"example_id": 200, "sql_complexity": "window functions", "prompt": "List the top three categories of workforce development programs with the highest budget increases.", "context": "CREATE TABLE programs (program_id INT, program_name VARCHAR(50), budget DECIMAL(10, 2), category VARCHAR(50), budget_date DATE);", "reference_sql": "SELECT category, SUM(budget - LAG(budget) OVER (PARTITION BY category ORDER BY budget_date)) as total_budget_increase FROM programs GROUP BY category ORDER BY total_budget_increase DESC LIMIT 3;", "generated_sql": "SELECT category, SUM(budget) AS total_budget\nFROM programs\nWHERE category = 'Workforce Development'\nGROUP BY category\nORDER BY total_budget DESC\nLIMIT 3;", "raw_model_output": "\n\n```sql\nSELECT category, SUM(budget) AS total_budget\nFROM programs\nWHERE category = 'Workforce Development'\nGROUP BY category\nORDER BY total_budget DESC\nLIMIT 3;\n```", "latency_sec": 0.41789913177490234, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 122, "prompt_eval_sec": null, "tokens_completion": 45, "completion_eval_sec": null, "tokens_total": 167, "tokens_per_sec": 399.61796352798615, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates the total budget increase per category using the LAG function to compare consecutive budgets over time, while the generated query simply sums budgets for a specific category ('Workforce Development') without any temporal analysis. The generated query also lacks the window function and includes a hard-coded category filter not present in the reference."}
{"example_id": 5131, "sql_complexity": "basic SQL", "prompt": "How many wells were drilled in the Eagle Ford Shale and Bakken Formation?", "context": "CREATE TABLE wells (id INT, region VARCHAR(255), well_type VARCHAR(255), num_drilled INT); INSERT INTO wells (id, region, well_type, num_drilled) VALUES (1, 'Eagle Ford Shale', 'Oil', 2000), (2, 'Eagle Ford Shale', 'Gas', 1500), (3, 'Bakken Formation', 'Oil', 1000), (4, 'Bakken Formation', 'Gas', 1200);", "reference_sql": "SELECT SUM(num_drilled) as total_wells FROM wells WHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "generated_sql": "SELECT SUM(num_drilled) AS total_wells_drilled\nFROM wells\nWHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "raw_model_output": "\n\nSELECT SUM(num_drilled) AS total_wells_drilled\nFROM wells\nWHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "latency_sec": 0.5274889469146729, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 205, "prompt_eval_sec": null, "tokens_completion": 37, "completion_eval_sec": null, "tokens_total": 242, "tokens_per_sec": 458.77738560301276, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of num_drilled for wells in the specified regions. The only difference is the alias name (total_wells vs. total_wells_drilled), which doesn't affect the semantic result."}
{"example_id": 1160, "sql_complexity": "subqueries", "prompt": "What is the total revenue generated from ads on Instagram in March 2021, for users in the 'brand' category who have posted more than 10 times?", "context": "CREATE TABLE ads (ad_id INT, user_id INT, platform VARCHAR(255), ad_revenue DECIMAL(10,2), post_count INT); INSERT INTO ads (ad_id, user_id, platform, ad_revenue, post_count) VALUES (1, 1, 'Instagram', 150.50, 12), (2, 2, 'Twitter', 80.00, 15), (3, 3, 'Instagram', 120.75, 8);", "reference_sql": "SELECT SUM(ad_revenue) FROM ads WHERE platform = 'Instagram' AND MONTH(ad_date) = 3 AND YEAR(ad_date) = 2021 AND user_id IN (SELECT user_id FROM users WHERE category = 'brand' AND post_count > 10);", "generated_sql": "None of the columns in the provided schema include information about the date (e.g., month or year) or user category (e.g., 'brand'). Therefore, it is not possible to construct a valid SQL query to answer the question based on the given schema.", "raw_model_output": "\n\nNone of the columns in the provided schema include information about the date (e.g., month or year) or user category (e.g., 'brand'). Therefore, it is not possible to construct a valid SQL query to answer the question based on the given schema.", "latency_sec": 0.8153769969940186, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 223, "prompt_eval_sec": null, "tokens_completion": 58, "completion_eval_sec": null, "tokens_total": 281, "tokens_per_sec": 344.6258614554236, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references columns 'ad_date' and 'users.category' which do not exist in the provided schema. The Generated SQL correctly states these columns are missing, making the Reference SQL invalid. Since one query is invalid and the other is not a valid query, they cannot be semantically equivalent."}
{"example_id": 4708, "sql_complexity": "subqueries", "prompt": "What is the maximum number of high-level threats reported by a single agency in a month?", "context": "CREATE TABLE Threat_Intelligence (Threat_ID INT, Threat_Type VARCHAR(50), Threat_Level VARCHAR(50), Reported_Date DATE, Reporting_Agency VARCHAR(50)); CREATE VIEW High_Level_Threats AS SELECT Threat_Type, Threat_Level, Reported_Date FROM Threat_Intelligence WHERE Threat_Level = 'High';", "reference_sql": "SELECT Reporting_Agency, MAX(Number_of_High_Level_Threats) as Max_High_Level_Threats_in_a_Month FROM (SELECT Reporting_Agency, TO_CHAR(Reported_Date, 'YYYY-MM') as Month, COUNT(*) as Number_of_High_Level_Threats FROM High_Level_Threats GROUP BY Reporting_Agency, Month) GROUP BY Reporting_Agency;", "generated_sql": "SELECT Reporting_Agency, MAX(Threat_Count) AS Max_Threats_In_Month\nFROM (\n    SELECT Reporting_Agency, DATE_FORMAT(Reported_Date, '%Y-%m') AS Report_Month, COUNT(*) AS Threat_Count\n    FROM Threat_Intelligence\n    WHERE Threat_Level = 'High'\n    GROUP BY Reporting_Agency, DATE_FORMAT(Reported_Date, '%Y-%m')\n) AS Monthly_Threats\nGROUP BY Reporting_Agency;", "raw_model_output": "\n\n```sql\nSELECT Reporting_Agency, MAX(Threat_Count) AS Max_Threats_In_Month\nFROM (\n    SELECT Reporting_Agency, DATE_FORMAT(Reported_Date, '%Y-%m') AS Report_Month, COUNT(*) AS Threat_Count\n    FROM Threat_Intelligence\n    WHERE Threat_Level = 'High'\n    GROUP BY Reporting_Agency, DATE_FORMAT(Reported_Date, '%Y-%m')\n) AS Monthly_Threats\nGROUP BY Reporting_Agency;\n```", "latency_sec": 0.9001171588897705, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 156, "prompt_eval_sec": null, "tokens_completion": 108, "completion_eval_sec": null, "tokens_total": 264, "tokens_per_sec": 293.29515318386433, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the maximum number of high-level threats per month per reporting agency. The reference query uses a view (High_Level_Threats) to filter 'High' threat levels, while the generated query applies the WHERE Threat_Level = 'High' condition directly. The date formatting functions (TO_CHAR vs DATE_FORMAT) both produce 'YYYY-MM' format, and the grouping/aggregation logic is identical. The column name differences (Month/Report_Month, Number_of_High_Level_Threats/Threat_Count) are syntactic but do not affect semantic equivalence."}
{"example_id": 5608, "sql_complexity": "set operations", "prompt": "List the suppliers that provide materials for both product A and product C.", "context": "CREATE TABLE products (product_id INT, product_name TEXT); CREATE TABLE materials (material_id INT, material_name TEXT, product_id INT, supplier_id INT); INSERT INTO products (product_id, product_name) VALUES (1, 'Product A'), (2, 'Product B'), (3, 'Product C'); INSERT INTO materials (material_id, material_name, product_id, supplier_id) VALUES (1, 'Material 1', 1, 101), (2, 'Material 2', 1, 102), (3, 'Material 3', 2, 103), (4, 'Material 4', 3, 101), (5, 'Material 5', 3, 102);", "reference_sql": "SELECT supplier_id FROM materials WHERE product_id = 1 INTERSECT SELECT supplier_id FROM materials WHERE product_id = 3;", "generated_sql": "SELECT m1.supplier_id\nFROM materials m1\nWHERE m1.product_id = (SELECT product_id FROM products WHERE product_name = 'Product A')\n  AND EXISTS (\n    SELECT 1\n    FROM materials m2\n    WHERE m2.supplier_id = m1.supplier_id\n      AND m2.product_id = (SELECT product_id FROM products WHERE product_name = 'Product C')\n  );", "raw_model_output": "\n\n```sql\nSELECT m1.supplier_id\nFROM materials m1\nWHERE m1.product_id = (SELECT product_id FROM products WHERE product_name = 'Product A')\n  AND EXISTS (\n    SELECT 1\n    FROM materials m2\n    WHERE m2.supplier_id = m1.supplier_id\n      AND m2.product_id = (SELECT product_id FROM products WHERE product_name = 'Product C')\n  );\n```", "latency_sec": 1.0804321765899658, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 247, "prompt_eval_sec": null, "tokens_completion": 93, "completion_eval_sec": null, "tokens_total": 340, "tokens_per_sec": 314.6888878051558, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses INTERSECT, which returns distinct supplier_ids present in both result sets. The Generated SQL may return duplicate supplier_ids if multiple materials in product 1 share the same supplier_id that also exists in product 3. While the sample data produces the same result, the Generated SQL does not enforce uniqueness, making them semantically non-equivalent in general cases."}
{"example_id": 1506, "sql_complexity": "basic SQL", "prompt": "How many habitats are in the 'animal_habitats' table?", "context": "CREATE TABLE animal_habitats (id INT PRIMARY KEY, habitat_name VARCHAR, num_animals INT);", "reference_sql": "SELECT COUNT(*) FROM animal_habitats;", "generated_sql": "SELECT COUNT(*) FROM animal_habitats;", "raw_model_output": "\n\nSELECT COUNT(*) FROM animal_habitats;", "latency_sec": 0.30065298080444336, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 107, "prompt_eval_sec": null, "tokens_completion": 14, "completion_eval_sec": null, "tokens_total": 121, "tokens_per_sec": 402.45734360007293, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical: they select the count of all rows from the 'animal_habitats' table using the same syntax. The result will always be the same."}
{"example_id": 3117, "sql_complexity": "aggregation", "prompt": "What is the percentage of the population that has access to clean water in each continent?", "context": "CREATE TABLE water_data (id INT, country VARCHAR(50), continent CHAR(2), access_to_clean_water BOOLEAN); INSERT INTO water_data VALUES (1, 'Canada', 'NA', true), (2, 'Mexico', 'NA', false), (3, 'Brazil', 'SA', true), (4, 'Russia', 'EU', true);", "reference_sql": "SELECT continent, COUNT(*) FILTER (WHERE access_to_clean_water) * 100.0 / COUNT(*) AS percentage FROM water_data GROUP BY continent;", "generated_sql": "SELECT continent, \n       (SUM(CASE WHEN access_to_clean_water THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage_with_access \nFROM water_data \nGROUP BY continent;", "raw_model_output": "\n\nSELECT continent, \n       (SUM(CASE WHEN access_to_clean_water THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage_with_access \nFROM water_data \nGROUP BY continent;", "latency_sec": 0.5046238899230957, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 163, "prompt_eval_sec": null, "tokens_completion": 51, "completion_eval_sec": null, "tokens_total": 214, "tokens_per_sec": 424.0782180023491, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the percentage of countries with access to clean water per continent. The Reference SQL uses COUNT(*) FILTER (WHERE access_to_clean_water) to count qualifying rows, while the Generated SQL uses SUM(CASE WHEN access_to_clean_water THEN 1 ELSE 0 END) to achieve the same count. Both methods produce identical numerical results, and the grouping logic is equivalent."}
{"example_id": 3542, "sql_complexity": "window functions", "prompt": "What is the average yield of crops for each country, ranked by average yield?", "context": "CREATE TABLE farming (id INT, name TEXT, country TEXT, crop TEXT, yield INT); INSERT INTO farming VALUES (1, 'Smith Farm', 'USA', 'Corn', 120), (2, 'Brown Farm', 'Canada', 'Soybeans', 45), (3, 'Jones Farm', 'Mexico', 'Wheat', 80);", "reference_sql": "SELECT country, AVG(yield) as avg_yield, ROW_NUMBER() OVER (ORDER BY AVG(yield) DESC) as rank FROM farming GROUP BY country;", "generated_sql": "SELECT country, AVG(yield) AS average_yield\nFROM farming\nGROUP BY country\nORDER BY average_yield;", "raw_model_output": "\n\n```sql\nSELECT country, AVG(yield) AS average_yield\nFROM farming\nGROUP BY country\nORDER BY average_yield;\n```", "latency_sec": 0.3770790100097656, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 166, "prompt_eval_sec": null, "tokens_completion": 32, "completion_eval_sec": null, "tokens_total": 198, "tokens_per_sec": 525.0888931602748, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a ROW_NUMBER() column ordered by average yield descending, while the Generated SQL only calculates average yield and orders by it ascending. The output structures differ (columns and ordering), making them non-equivalent."}
{"example_id": 2274, "sql_complexity": "subqueries", "prompt": "Add a new crop 'amaranth' to farm 'Nourishing Harvest' with yield 50 in 2023", "context": "CREATE TABLE farms (id INT, name TEXT, location TEXT, size FLOAT); INSERT INTO farms (id, name, location, size) VALUES (1, 'Nourishing Harvest', 'Mexico', 120.0); CREATE TABLE crops (id INT, farm_id INT, crop TEXT, yield INT, year INT);", "reference_sql": "INSERT INTO crops (id, farm_id, crop, yield, year) VALUES (5, (SELECT id FROM farms WHERE name = 'Nourishing Harvest'), 'amaranth', 50, 2023);", "generated_sql": "INSERT INTO crops (farm_id, crop, yield, year) SELECT id, 'amaranth', 50, 2023 FROM farms WHERE name = 'Nourishing Harvest';", "raw_model_output": "\n\nINSERT INTO crops (farm_id, crop, yield, year) SELECT id, 'amaranth', 50, 2023 FROM farms WHERE name = 'Nourishing Harvest';", "latency_sec": 0.39156079292297363, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 168, "prompt_eval_sec": null, "tokens_completion": 45, "completion_eval_sec": null, "tokens_total": 213, "tokens_per_sec": 543.976832843682, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL explicitly sets the 'id' column to 5, while the Generated SQL omits the 'id' column in the INSERT, relying on the database's default behavior (e.g., auto-increment). Additionally, the Generated SQL could insert multiple rows if multiple farms match the name, whereas the Reference SQL inserts a single row. The two queries differ in column specification, value assignment, and potential row count."}
{"example_id": 3705, "sql_complexity": "subqueries", "prompt": "What is the percentage of unions with collective bargaining agreements in the Midwest region?", "context": "CREATE TABLE collective_bargaining (bargaining_id INT, union_name VARCHAR(50), contract_start_date DATE, contract_end_date DATE, region VARCHAR(50));CREATE VIEW union_region AS SELECT DISTINCT union_name, region FROM collective_bargaining;", "reference_sql": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM union_region) as percentage FROM union_region ur WHERE ur.region = 'Midwest' AND EXISTS (SELECT 1 FROM collective_bargaining cb WHERE cb.union_name = ur.union_name);", "generated_sql": "SELECT \n    (COUNT(DISTINCT union_name) * 100.0 / (SELECT COUNT(DISTINCT union_name) FROM union_region)) AS percentage \nFROM \n    union_region \nWHERE \n    region = 'Midwest';", "raw_model_output": "\n\nSELECT \n    (COUNT(DISTINCT union_name) * 100.0 / (SELECT COUNT(DISTINCT union_name) FROM union_region)) AS percentage \nFROM \n    union_region \nWHERE \n    region = 'Midwest';", "latency_sec": 0.47562193870544434, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 140, "prompt_eval_sec": null, "tokens_completion": 55, "completion_eval_sec": null, "tokens_total": 195, "tokens_per_sec": 409.9894982362551, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their denominator calculations. The reference query uses COUNT(*) on the entire union_region table (total (union_name, region) pairs), while the generated query uses COUNT(DISTINCT union_name) which counts unique union names across all regions. This leads to different percentage calculations. Additionally, the reference query's EXISTS clause is redundant since union_region is derived from collective_bargaining, making the WHERE condition effectively just filtering by region."}
{"example_id": 240, "sql_complexity": "aggregation", "prompt": "What is the average capacity of renewable energy projects for each country?", "context": "CREATE TABLE projects (name TEXT, type TEXT, capacity INTEGER, country TEXT); INSERT INTO projects (name, type, capacity, country) VALUES ('Project 1', 'Wind', 100, 'USA'), ('Project 2', 'Solar', 200, 'Germany'), ('Project 3', 'Wind', 300, 'France');", "reference_sql": "SELECT country, AVG(capacity) FROM projects GROUP BY country", "generated_sql": "SELECT country, AVG(capacity) AS average_capacity\nFROM projects\nWHERE type IN ('Wind', 'Solar')\nGROUP BY country;", "raw_model_output": "\n\nSELECT country, AVG(capacity) AS average_capacity\nFROM projects\nWHERE type IN ('Wind', 'Solar')\nGROUP BY country;", "latency_sec": 0.47818803787231445, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 162, "prompt_eval_sec": null, "tokens_completion": 32, "completion_eval_sec": null, "tokens_total": 194, "tokens_per_sec": 405.6981451547765, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "In the given dataset, all projects have type 'Wind' or 'Solar', so the WHERE clause in the Generated SQL does not filter out any rows. Both queries calculate the average capacity per country using the same grouping, resulting in identical outputs."}
{"example_id": 2132, "sql_complexity": "set operations", "prompt": "What is the average caseload per attorney in community legal clinics in California, and how does it compare to the state average?", "context": "CREATE TABLE cali_community_legal_clinics(id INT, attorney_count INT, cases_handled INT, state VARCHAR(255));", "reference_sql": "SELECT state, AVG(cases_handled/attorney_count) AS avg_caseload FROM cali_community_legal_clinics WHERE state = 'California' GROUP BY state UNION ALL SELECT 'California', AVG(cases_handled/attorney_count) FROM cali_community_legal_clinics WHERE state = 'California';", "generated_sql": "SELECT \n    AVG(cases_handled / attorney_count) AS california_avg_caseload_per_attorney,\n    (SELECT AVG(cases_handled / attorney_count) FROM cali_community_legal_clinics) AS state_avg_caseload_per_attorney\nFROM cali_community_legal_clinics\nWHERE state = 'California';", "raw_model_output": "\n\n```sql\nSELECT \n    AVG(cases_handled / attorney_count) AS california_avg_caseload_per_attorney,\n    (SELECT AVG(cases_handled / attorney_count) FROM cali_community_legal_clinics) AS state_avg_caseload_per_attorney\nFROM cali_community_legal_clinics\nWHERE state = 'California';\n```", "latency_sec": 0.756303071975708, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 125, "prompt_eval_sec": null, "tokens_completion": 77, "completion_eval_sec": null, "tokens_total": 202, "tokens_per_sec": 267.08869431445083, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two rows with state and average caseload for California, while the Generated SQL returns a single row with two columns: California's average and the overall average. The structure and data differ significantly."}
{"example_id": 3276, "sql_complexity": "basic SQL", "prompt": "What is the total energy consumption of the Chemical Plant B in the last quarter?", "context": "CREATE TABLE EnergyConsumption (EnergyID INT, Plant VARCHAR(255), EnergyQuantity DECIMAL(5,2), Timestamp DATETIME);", "reference_sql": "SELECT SUM(EnergyQuantity) FROM EnergyConsumption WHERE Plant = 'Chemical Plant B' AND Timestamp BETWEEN DATE_SUB(CURRENT_DATE(), INTERVAL 3 MONTH) AND CURRENT_DATE();", "generated_sql": "SELECT SUM(EnergyQuantity) AS TotalEnergyConsumption\nFROM EnergyConsumption\nWHERE Plant = 'Chemical Plant B'\n  AND Timestamp >= DATEADD(QUARTER, -1, CAST(GETDATE() AS DATE));", "raw_model_output": "\n\n```sql\nSELECT SUM(EnergyQuantity) AS TotalEnergyConsumption\nFROM EnergyConsumption\nWHERE Plant = 'Chemical Plant B'\n  AND Timestamp >= DATEADD(QUARTER, -1, CAST(GETDATE() AS DATE));\n```", "latency_sec": 0.4498469829559326, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 118, "prompt_eval_sec": null, "tokens_completion": 56, "completion_eval_sec": null, "tokens_total": 174, "tokens_per_sec": 386.79819270243985, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their upper bound condition. The reference query uses BETWEEN with CURRENT_DATE() (which includes all timestamps up to the end of the current day), while the generated query only enforces a lower bound with DATEADD. This makes the generated query include records from three months ago up to the current moment (not the end of the day), leading to potential discrepancies in results."}
{"example_id": 3074, "sql_complexity": "multiple_joins", "prompt": "Find the top 5 players with the highest scores in the 'historical_tournaments' view, including their scores and the names of the tournaments they participated in.", "context": "CREATE VIEW historical_tournaments AS SELECT tournaments.tournament_name, players.player_name, players.score FROM tournaments JOIN players_scores ON tournaments.tournament_id = players_scores.tournament_id JOIN players ON players_scores.player_id = players.player_id;  CREATE TABLE tournaments (tournament_id INT, tournament_name TEXT);  CREATE TABLE players_scores (player_id INT, tournament_id INT, score INT);  CREATE TABLE players (player_id INT, player_name TEXT);", "reference_sql": "SELECT players.player_name, MAX(players_scores.score) as high_score, tournaments.tournament_name FROM historical_tournaments JOIN players ON historical_tournaments.player_id = players.player_id JOIN players_scores ON historical_tournaments.player_id = players_scores.player_id JOIN tournaments ON players_scores.tournament_id = tournaments.tournament_id GROUP BY players.player_id, tournaments.tournament_name ORDER BY high_score DESC LIMIT 5;", "generated_sql": "SELECT player_name, score, tournament_name\nFROM historical_tournaments\nORDER BY score DESC\nLIMIT 5;", "raw_model_output": "\n\n```sql\nSELECT player_name, score, tournament_name\nFROM historical_tournaments\nORDER BY score DESC\nLIMIT 5;\n```", "latency_sec": 0.42619872093200684, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 194, "prompt_eval_sec": null, "tokens_completion": 32, "completion_eval_sec": null, "tokens_total": 226, "tokens_per_sec": 530.2690714457932, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL includes a GROUP BY clause and calculates MAX(score) as 'high_score', while the Generated SQL directly selects 'score' without aggregation. Additionally, the Reference SQL's GROUP BY introduces a different structure, and the column names differ (high_score vs. score). The Generated SQL also lacks the explicit joins present in the Reference SQL, though both ultimately reference the same view. The differing column names and aggregation logic result in different output structures."}
{"example_id": 2219, "sql_complexity": "window functions", "prompt": "What is the average population of cities with a UNESCO World Heritage designation, ordered by designation date?", "context": "CREATE TABLE cities (name VARCHAR(255), population INT, designation_date DATE); INSERT INTO cities (name, population, designation_date) VALUES ('Paris', 2141000, '1991-09-16'); INSERT INTO cities (name, population, designation_date) VALUES ('Rio de Janeiro', 6727000, '2012-07-01');", "reference_sql": "SELECT AVG(population) FROM (SELECT population, ROW_NUMBER() OVER (ORDER BY designation_date) rn FROM cities WHERE name IN (SELECT name FROM heritagesites)) t WHERE rn % 2 = 1;", "generated_sql": "SELECT AVG(population) AS average_population\nFROM cities\nORDER BY designation_date;", "raw_model_output": "\n\n```sql\nSELECT AVG(population) AS average_population\nFROM cities\nORDER BY designation_date;\n```", "latency_sec": 0.38040709495544434, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 183, "prompt_eval_sec": null, "tokens_completion": 26, "completion_eval_sec": null, "tokens_total": 209, "tokens_per_sec": 549.411414170599, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the average of populations from a subset of cities (those in heritagesites) ordered by designation_date, selecting only odd-numbered rows. The Generated SQL averages all cities' populations without filtering or row-number-based selection. The presence of an undefined 'heritagesites' table in the Reference SQL and the absence of filtering/ordering effects on the average in the Generated SQL make them non-equivalent."}
{"example_id": 3786, "sql_complexity": "aggregation", "prompt": "Display the names and average co-owner percentages for all properties in the 'property_coownership' table where the co-owner percentage is greater than 60.", "context": "CREATE TABLE property_coownership (property_id INT, owner VARCHAR(255), percentage INT); INSERT INTO property_coownership (property_id, owner, percentage) VALUES (1, 'Mohammed', 70), (1, 'Fatima', 30), (2, 'Jamal', 65), (2, 'Aisha', 35), (3, 'Ali', 75), (3, 'Khadija', 25);", "reference_sql": "SELECT owner, AVG(percentage) FROM property_coownership WHERE percentage > 60 GROUP BY owner;", "generated_sql": "SELECT property_id, owner, percentage\nFROM property_coownership\nWHERE percentage > 60;", "raw_model_output": "\n\n```sql\nSELECT property_id, owner, percentage\nFROM property_coownership\nWHERE percentage > 60;\n```", "latency_sec": 0.5161218643188477, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 203, "prompt_eval_sec": null, "tokens_completion": 29, "completion_eval_sec": null, "tokens_total": 232, "tokens_per_sec": 449.50624268976134, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates the average percentage per owner for entries where percentage > 60, while the Generated SQL simply filters rows where percentage > 60 without aggregation. The Reference SQL groups results by owner and returns averaged values, whereas the Generated SQL returns individual rows with property details. The output structure and logic differ fundamentally."}
{"example_id": 2357, "sql_complexity": "basic SQL", "prompt": "What is the total amount of climate finance invested in renewable energy projects by public and private sectors in Africa?", "context": "CREATE TABLE renewable_energy_projects (project_id INT, sector TEXT, investor_type TEXT, region TEXT, amount FLOAT); INSERT INTO renewable_energy_projects (project_id, sector, investor_type, region, amount) VALUES (1, 'Renewable Energy', 'Public', 'Africa', 5000000); INSERT INTO renewable_energy_projects (project_id, sector, investor_type, region, amount) VALUES (2, 'Renewable Energy', 'Private', 'Africa', 7000000);", "reference_sql": "SELECT SUM(amount) FROM renewable_energy_projects WHERE sector = 'Renewable Energy' AND region = 'Africa';", "generated_sql": "SELECT SUM(amount) AS total_climate_finance\nFROM renewable_energy_projects\nWHERE region = 'Africa' AND investor_type IN ('Public', 'Private');", "raw_model_output": "\n\n```sql\nSELECT SUM(amount) AS total_climate_finance\nFROM renewable_energy_projects\nWHERE region = 'Africa' AND investor_type IN ('Public', 'Private');\n```", "latency_sec": 0.5428550243377686, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 202, "prompt_eval_sec": null, "tokens_completion": 41, "completion_eval_sec": null, "tokens_total": 243, "tokens_per_sec": 447.6333258523984, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query filters by both 'sector = 'Renewable Energy'' and 'region = 'Africa'', while the generated query filters by 'region = 'Africa'' and 'investor_type IN ('Public', 'Private')'. The absence of the sector filter in the generated query means it could include projects from other sectors in Africa with public/private investors, making the results potentially different."}
{"example_id": 1009, "sql_complexity": "multiple_joins", "prompt": "Find the number of IoT sensors installed in each farm that use Sprinkler irrigation.", "context": "CREATE TABLE IoT_Sensors (id INT, sensor_type VARCHAR(50), Farm_id INT); INSERT INTO IoT_Sensors (id, sensor_type, Farm_id) VALUES (1, 'Soil Moisture', 1), (2, 'Temperature', 1), (3, 'Humidity', 2); CREATE TABLE Irrigation (id INT, Farm_id INT, irrigation_type VARCHAR(50), duration INT); INSERT INTO Irrigation (id, Farm_id, irrigation_type, duration) VALUES (1, 1, 'Sprinkler', 30), (2, 2, 'Drip', 45);", "reference_sql": "SELECT f.id, COUNT(s.id) FROM Farmers f JOIN Irrigation i ON f.id = i.Farm_id JOIN IoT_Sensors s ON f.id = s.Farm_id WHERE i.irrigation_type = 'Sprinkler' GROUP BY f.id;", "generated_sql": "SELECT i.Farm_id, COUNT(ios.id) AS num_sensors\nFROM IoT_Sensors ios\nJOIN Irrigation i ON ios.Farm_id = i.Farm_id\nWHERE i.irrigation_type = 'Sprinkler'\nGROUP BY i.Farm_id;", "raw_model_output": "\n\n```sql\nSELECT i.Farm_id, COUNT(ios.id) AS num_sensors\nFROM IoT_Sensors ios\nJOIN Irrigation i ON ios.Farm_id = i.Farm_id\nWHERE i.irrigation_type = 'Sprinkler'\nGROUP BY i.Farm_id;\n```", "latency_sec": 0.7023622989654541, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 222, "prompt_eval_sec": null, "tokens_completion": 65, "completion_eval_sec": null, "tokens_total": 287, "tokens_per_sec": 408.62102140552986, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of IoT_Sensors per Farm_id where there is at least one Irrigation entry with 'Sprinkler' type. The Reference SQL joins Farmers, Irrigation, and IoT_Sensors, while the Generated SQL directly joins IoT_Sensors and Irrigation. Since the Farm_id in both tables must match, the grouping and counting logic produce identical results. The only difference is column aliases and table references, which do not affect the output."}
{"example_id": 4217, "sql_complexity": "subqueries", "prompt": "Show consumer preference data for foundations, excluding products from the USA.", "context": "CREATE TABLE cosmetics (product_id INT, product_name VARCHAR(100), product_type VARCHAR(50), is_cruelty_free BOOLEAN, consumer_preference_score INT); INSERT INTO cosmetics (product_id, product_name, product_type, is_cruelty_free, consumer_preference_score) VALUES (1, 'Lipstick A', 'Lipstick', TRUE, 80), (2, 'Foundation B', 'Foundation', FALSE, 90), (3, 'Mascara C', 'Mascara', TRUE, 85), (4, 'Eyeshadow D', 'Eyeshadow', TRUE, 70), (5, 'Blush E', 'Blush', FALSE, 95); CREATE TABLE ingredient_sourcing (ingredient_id INT, ingredient_name VARCHAR(100), sourcing_country VARCHAR(50), is_organic BOOLEAN); INSERT INTO ingredient_sourcing (ingredient_id, ingredient_name, sourcing_country, is_organic) VALUES (1, 'Rosehip Oil', 'Chile', TRUE), (2, 'Shea Butter', 'Ghana', TRUE), (3, 'Jojoba Oil', 'India', TRUE), (4, 'Coconut Oil', 'Philippines', FALSE), (5, 'Aloe Vera', 'USA', TRUE);", "reference_sql": "SELECT * FROM cosmetics WHERE product_type = 'Foundation' AND product_id NOT IN (SELECT cosmetics.product_id FROM cosmetics INNER JOIN ingredient_sourcing ON cosmetics.product_id = ingredient_sourcing.ingredient_id WHERE ingredient_sourcing.sourcing_country = 'USA');", "generated_sql": "SELECT product_id, product_name, product_type, is_cruelty_free, consumer_preference_score\nFROM cosmetics\nWHERE product_type = 'Foundation';", "raw_model_output": "\n\n```sql\nSELECT product_id, product_name, product_type, is_cruelty_free, consumer_preference_score\nFROM cosmetics\nWHERE product_type = 'Foundation';\n```", "latency_sec": 0.5903971195220947, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 359, "prompt_eval_sec": null, "tokens_completion": 40, "completion_eval_sec": null, "tokens_total": 399, "tokens_per_sec": 675.8163053420318, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes an additional condition that excludes Foundation products linked to ingredients sourced from the USA, while the Generated SQL retrieves all Foundation products without any such exclusion. The Generated SQL lacks the NOT IN clause and subquery filtering, making them non-equivalent."}
{"example_id": 5620, "sql_complexity": "basic SQL", "prompt": "What is the recycling rate of plastic in the residential sector in the state of New York?", "context": "CREATE TABLE recycling_rates_city (sector VARCHAR(20), city VARCHAR(20), material VARCHAR(20), recycling_rate DECIMAL(5,2)); INSERT INTO recycling_rates_city (sector, city, material, recycling_rate) VALUES ('residential', 'New York City', 'plastic', 0.25), ('commercial', 'New York City', 'plastic', 0.30), ('residential', 'New York City', 'paper', 0.45), ('commercial', 'New York City', 'paper', 0.50), ('residential', 'Los Angeles', 'plastic', 0.20), ('commercial', 'Los Angeles', 'plastic', 0.35), ('residential', 'Los Angeles', 'paper', 0.40), ('commercial', 'Los Angeles', 'paper', 0.50);", "reference_sql": "SELECT recycling_rate FROM recycling_rates_city WHERE sector = 'residential' AND material = 'plastic' AND city = 'New York City';", "generated_sql": "SELECT recycling_rate\nFROM recycling_rates_city\nWHERE sector = 'residential' AND city = 'New York City' AND material = 'plastic';", "raw_model_output": "\n\nSELECT recycling_rate\nFROM recycling_rates_city\nWHERE sector = 'residential' AND city = 'New York City' AND material = 'plastic';", "latency_sec": 0.6202969551086426, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 279, "prompt_eval_sec": null, "tokens_completion": 36, "completion_eval_sec": null, "tokens_total": 315, "tokens_per_sec": 507.8212901187448, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select the same column from the same table with identical WHERE conditions. The order of conditions in the WHERE clause does not affect the result since logical AND is commutative. Both queries filter for 'residential' sector, 'plastic' material, and 'New York City' city."}
{"example_id": 3151, "sql_complexity": "basic SQL", "prompt": "List all biotech startups that received funding in 2022 and their respective funding amounts.", "context": "CREATE TABLE biotech_startups (name TEXT, funding FLOAT, date DATE); INSERT INTO biotech_startups (name, funding, date) VALUES ('StartupA', 3500000, '2022-02-28'); INSERT INTO biotech_startups (name, funding, date) VALUES ('StartupB', 4500000, '2022-07-12');", "reference_sql": "SELECT name, funding FROM biotech_startups WHERE date BETWEEN '2022-01-01' AND '2022-12-31';", "generated_sql": "SELECT name, funding  \nFROM biotech_startups  \nWHERE EXTRACT(YEAR FROM date) = 2022;", "raw_model_output": "\n\nSELECT name, funding  \nFROM biotech_startups  \nWHERE EXTRACT(YEAR FROM date) = 2022;", "latency_sec": 0.41253209114074707, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 186, "prompt_eval_sec": null, "tokens_completion": 31, "completion_eval_sec": null, "tokens_total": 217, "tokens_per_sec": 526.0196834625509, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select startups with dates in 2022. The first uses BETWEEN '2022-01-01' AND '2022-12-31' (inclusive), while the second checks EXTRACT(YEAR FROM date) = 2022. Since the date column is of DATE type (no time component), both approaches capture all dates in 2022."}
{"example_id": 2136, "sql_complexity": "window functions", "prompt": "What is the total military equipment sales revenue for each sales representative by fiscal year?", "context": "CREATE TABLE SalesReps (SalesRepID INT, SalesRepName VARCHAR(50), FiscalYear INT, Revenue DECIMAL(10,2)); INSERT INTO SalesReps (SalesRepID, SalesRepName, FiscalYear, Revenue) VALUES (1, 'John Doe', 2020, 150000.00), (2, 'Jane Smith', 2020, 200000.00), (1, 'John Doe', 2021, 180000.00), (2, 'Jane Smith', 2021, 250000.00);", "reference_sql": "SELECT SalesRepName, FiscalYear, SUM(Revenue) OVER (PARTITION BY SalesRepName ORDER BY FiscalYear) AS TotalRevenue FROM SalesReps;", "generated_sql": "None of the columns in the provided schema relate to \"military equipment sales revenue.\" Therefore, it is not possible to calculate this value with the given data.", "raw_model_output": "\n\nNone of the columns in the provided schema relate to \"military equipment sales revenue.\" Therefore, it is not possible to calculate this value with the given data.", "latency_sec": 0.7184479236602783, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 236, "prompt_eval_sec": null, "tokens_completion": 37, "completion_eval_sec": null, "tokens_total": 273, "tokens_per_sec": 379.9857874306968, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates a running total of Revenue per sales rep across fiscal years using a window function. The Generated SQL incorrectly references a non-existent 'military equipment sales revenue' column, which does not exist in the provided schema. Since the Generated SQL cannot execute or produce meaningful results with the given data, the queries are not semantically equivalent."}
{"example_id": 5452, "sql_complexity": "basic SQL", "prompt": "What is the name of the farms with a size greater than 150 acres located in 'Texas'?", "context": "CREATE TABLE farms (id INT PRIMARY KEY, name VARCHAR(50), size INT, location VARCHAR(50)); INSERT INTO farms (id, name, size, location) VALUES (1, 'Smith Farms', 200, 'Texas'), (2, 'Johnson Farms', 100, 'California');", "reference_sql": "SELECT name FROM farms WHERE size > 150 AND location = 'Texas'", "generated_sql": "SELECT name FROM farms WHERE size > 150 AND location = 'Texas';", "raw_model_output": "\n\nSELECT name FROM farms WHERE size > 150 AND location = 'Texas';", "latency_sec": 0.24289417266845703, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 162, "prompt_eval_sec": null, "tokens_completion": 22, "completion_eval_sec": null, "tokens_total": 184, "tokens_per_sec": 757.5315536744237, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. The only difference is the presence of a semicolon at the end of the generated SQL, which does not affect the query's semantics or result."}
{"example_id": 5152, "sql_complexity": "aggregation", "prompt": "How many international tourists visited Portugal in 2020, broken down by continent?", "context": "CREATE TABLE international_tourists(tourist_id INT, country TEXT, arrival_year INT, continent TEXT);INSERT INTO international_tourists (tourist_id, country, arrival_year, continent) VALUES (1, 'Spain', 2020, 'Europe'), (2, 'France', 2020, 'Europe'), (3, 'Brazil', 2020, 'South America'), (4, 'United States', 2020, 'North America'), (5, 'China', 2020, 'Asia');", "reference_sql": "SELECT continent, COUNT(*) FROM international_tourists WHERE arrival_year = 2020 GROUP BY continent;", "generated_sql": "SELECT continent, COUNT(*) AS num_tourists\nFROM international_tourists\nWHERE country = 'Portugal' AND arrival_year = 2020\nGROUP BY continent;", "raw_model_output": "\n\n```sql\nSELECT continent, COUNT(*) AS num_tourists\nFROM international_tourists\nWHERE country = 'Portugal' AND arrival_year = 2020\nGROUP BY continent;\n```", "latency_sec": 0.8246581554412842, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 209, "prompt_eval_sec": null, "tokens_completion": 47, "completion_eval_sec": null, "tokens_total": 256, "tokens_per_sec": 310.4316598469961, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL counts all tourists from 2020 grouped by continent, while the Generated SQL adds a filter for 'country = 'Portugal'' which doesn't exist in the data. Since there are no tourists from Portugal, the Generated SQL returns an empty result set, making them non-equivalent."}
{"example_id": 2477, "sql_complexity": "set operations", "prompt": "What is the carbon price in Europe and Australia for the last quarter of 2020?", "context": "CREATE TABLE CarbonPrices (Country TEXT, Year INT, Quarter INT, CarbonPrice NUMBER); INSERT INTO CarbonPrices (Country, Year, Quarter, CarbonPrice) VALUES ('Europe', 2020, 4, 25), ('Australia', 2020, 4, 15); CREATE TABLE CarbonTaxes (Country TEXT, Year INT, Quarter INT, CarbonPrice NUMBER); INSERT INTO CarbonTaxes (Country, Year, Quarter, CarbonPrice) VALUES ('Europe', 2019, 4, 20), ('Australia', 2019, 4, 10);", "reference_sql": "SELECT Context.Country, Context.CarbonPrice FROM ( SELECT * FROM CarbonPrices WHERE CarbonPrices.Country IN ('Europe', 'Australia') AND CarbonPrices.Year = 2020 AND CarbonPrices.Quarter = 4 UNION SELECT * FROM CarbonTaxes WHERE CarbonTaxes.Country IN ('Europe', 'Australia') AND CarbonTaxes.Year = 2020 AND CarbonTaxes.Quarter = 4 ) AS Context;", "generated_sql": "SELECT Country, CarbonPrice FROM CarbonPrices WHERE Country IN ('Europe', 'Australia') AND Year = 2020 AND Quarter = 4;", "raw_model_output": "\n\nSELECT Country, CarbonPrice FROM CarbonPrices WHERE Country IN ('Europe', 'Australia') AND Year = 2020 AND Quarter = 4;", "latency_sec": 0.48360204696655273, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 224, "prompt_eval_sec": null, "tokens_completion": 36, "completion_eval_sec": null, "tokens_total": 260, "tokens_per_sec": 537.6321329301204, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL combines results from both CarbonPrices and CarbonTaxes tables using UNION, while the Generated SQL only queries the CarbonPrices table. Although in the given data the CarbonTaxes table has no entries matching the 2020 Q4 filter, the queries are not equivalent because the Reference SQL could return additional rows from CarbonTaxes if such data existed. The Generated SQL explicitly excludes CarbonTaxes entirely."}
{"example_id": 4573, "sql_complexity": "subqueries", "prompt": "Find the names of all the indigenous communities in the 'Arctic_Communities' table that have a population size greater than the average population size in the 'Antarctic_Communities' table.", "context": "CREATE TABLE Arctic_Communities (name TEXT, population INTEGER); CREATE TABLE Antarctic_Communities (name TEXT, population INTEGER);", "reference_sql": "SELECT name FROM Arctic_Communities WHERE Arctic_Communities.population > (SELECT AVG(population) FROM Antarctic_Communities)", "generated_sql": "SELECT name\nFROM Arctic_Communities\nWHERE population > (SELECT AVG(population) FROM Antarctic_Communities);", "raw_model_output": "\n\n```sql\nSELECT name\nFROM Arctic_Communities\nWHERE population > (SELECT AVG(population) FROM Antarctic_Communities);\n```", "latency_sec": 0.5524539947509766, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 135, "prompt_eval_sec": null, "tokens_completion": 31, "completion_eval_sec": null, "tokens_total": 166, "tokens_per_sec": 300.47750867441175, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select names from Arctic_Communities where population exceeds the average population of Antarctic_Communities. The generated query omits the table alias in the WHERE clause, but since the column is unambiguous (only exists in Arctic_Communities), the semantic meaning remains identical."}
{"example_id": 3596, "sql_complexity": "window functions", "prompt": "What is the total revenue for each game in the \"Gaming\" category?", "context": "CREATE TABLE Games (GameID int, GameName varchar(50), Category varchar(50), Revenue decimal(10,2));", "reference_sql": "SELECT Category, SUM(Revenue) OVER(PARTITION BY Category) as TotalRevenue FROM Games;", "generated_sql": "SELECT GameName, Revenue AS TotalRevenue\nFROM Games\nWHERE Category = 'Gaming';", "raw_model_output": "\n\nSELECT GameName, Revenue AS TotalRevenue\nFROM Games\nWHERE Category = 'Gaming';", "latency_sec": 0.4268679618835449, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 117, "prompt_eval_sec": null, "tokens_completion": 24, "completion_eval_sec": null, "tokens_total": 141, "tokens_per_sec": 330.3129131027796, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates total revenue per category using a window function and returns Category and TotalRevenue columns. The generated query selects specific GameName entries with Revenue renamed as TotalRevenue, but filters only 'Gaming' category and lacks aggregation. The column structures, data returned, and purposes differ significantly."}
{"example_id": 5039, "sql_complexity": "subqueries", "prompt": "What is the total number of community policing events in 'City Park' in 2021?", "context": "CREATE TABLE locations (id INT, name VARCHAR(255)); CREATE TABLE community_policing (id INT, location_id INT, year INT, events INT); INSERT INTO locations (id, name) VALUES (1, 'City Park'); INSERT INTO community_policing (id, location_id, year, events) VALUES (1, 1, 2021, 5);", "reference_sql": "SELECT SUM(events) FROM community_policing WHERE location_id = (SELECT id FROM locations WHERE name = 'City Park') AND year = 2021;", "generated_sql": "SELECT SUM(events) AS total_events\nFROM community_policing\nWHERE location_id = (SELECT id FROM locations WHERE name = 'City Park') AND year = 2021;", "raw_model_output": "\n\n```sql\nSELECT SUM(events) AS total_events\nFROM community_policing\nWHERE location_id = (SELECT id FROM locations WHERE name = 'City Park') AND year = 2021;\n```", "latency_sec": 0.8069238662719727, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 175, "prompt_eval_sec": null, "tokens_completion": 48, "completion_eval_sec": null, "tokens_total": 223, "tokens_per_sec": 276.35816626699966, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of 'events' from the community_policing table where the location_id corresponds to 'City Park' (via a subquery) and the year is 2021. The only difference is the alias 'total_events' in the Generated SQL, which does not affect the semantic result since it only renames the output column."}
{"example_id": 2724, "sql_complexity": "basic SQL", "prompt": "What is the earliest installation date for solar panels in Italy?", "context": "CREATE TABLE solar_panels_italy (id INT, installation_date DATE); INSERT INTO solar_panels_italy (id, installation_date) VALUES (1, '2018-01-01'), (2, '2019-01-01'), (3, '2020-01-01');", "reference_sql": "SELECT MIN(installation_date) as earliest_date FROM solar_panels_italy;", "generated_sql": "SELECT MIN(installation_date) FROM solar_panels_italy;", "raw_model_output": "\n\nSELECT MIN(installation_date) FROM solar_panels_italy;", "latency_sec": 0.21602320671081543, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 160, "prompt_eval_sec": null, "tokens_completion": 20, "completion_eval_sec": null, "tokens_total": 180, "tokens_per_sec": 833.2438108881573, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the minimum installation_date from the solar_panels_italy table. The only difference is the presence of an alias ('earliest_date') in the reference query, which does not affect the semantic result set. The generated query produces the same data value (the earliest date) even without the alias."}
{"example_id": 2200, "sql_complexity": "single join", "prompt": "Which diversity programs are currently being participated in by employees in the HR department?", "context": "CREATE TABLE Employees (Employee_ID INT, First_Name VARCHAR(20), Last_Name VARCHAR(20), Department VARCHAR(20), Salary DECIMAL(10,2), Date_Hired DATE); CREATE TABLE Diversity_Programs (Program_ID INT, Program_Name VARCHAR(50), Participant_ID INT, Date_Started DATE, Date_Ended DATE);", "reference_sql": "SELECT dp.Program_Name FROM Diversity_Programs dp JOIN Employees e ON dp.Participant_ID = e.Employee_ID WHERE e.Department = 'HR' AND dp.Date_Ended IS NULL;", "generated_sql": "SELECT DISTINCT dp.Program_Name\nFROM Diversity_Programs dp\nJOIN Employees e ON dp.Participant_ID = e.Employee_ID\nWHERE e.Department = 'HR' AND dp.Date_Ended IS NULL;", "raw_model_output": "\n\n```sql\nSELECT DISTINCT dp.Program_Name\nFROM Diversity_Programs dp\nJOIN Employees e ON dp.Participant_ID = e.Employee_ID\nWHERE e.Department = 'HR' AND dp.Date_Ended IS NULL;\n```", "latency_sec": 0.751209020614624, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 160, "prompt_eval_sec": null, "tokens_completion": 49, "completion_eval_sec": null, "tokens_total": 209, "tokens_per_sec": 278.21817132733634, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Generated SQL includes 'DISTINCT' which ensures unique Program_Name values, while the Reference SQL may return duplicates. If multiple Diversity_Programs entries exist for the same program name under the given conditions, the two queries would produce different results."}
{"example_id": 4359, "sql_complexity": "window functions", "prompt": "Which destinations have the least hotel awards?", "context": "CREATE TABLE Destinations (destination_id INT, destination_name TEXT, country TEXT, awards INT); INSERT INTO Destinations (destination_id, destination_name, country, awards) VALUES (1, 'City A', 'Germany', 3), (2, 'City B', 'Switzerland', 5), (3, 'City C', 'Norway', 2);", "reference_sql": "SELECT destination_name, country, awards, RANK() OVER (PARTITION BY country ORDER BY awards ASC) AS rank FROM Destinations;", "generated_sql": "SELECT destination_name FROM Destinations ORDER BY awards ASC LIMIT 1;", "raw_model_output": "\n\nSELECT destination_name FROM Destinations ORDER BY awards ASC LIMIT 1;", "latency_sec": 0.5221366882324219, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 156, "prompt_eval_sec": null, "tokens_completion": 19, "completion_eval_sec": null, "tokens_total": 175, "tokens_per_sec": 335.1612785388128, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates a rank for each destination within its country based on awards, returning all rows with their respective ranks. The Generated SQL selects only the destination with the lowest awards (LIMIT 1), returning a single row. The two queries differ in both output structure (multiple rows vs. single row) and purpose (ranking vs. selection)."}
{"example_id": 1373, "sql_complexity": "subqueries", "prompt": "What is the total value of military equipment sales to Africa in the last 12 months?", "context": "CREATE TABLE Military_Equipment_Sales(sale_id INT, sale_date DATE, equipment_type VARCHAR(50), country VARCHAR(50), sale_value DECIMAL(10,2));", "reference_sql": "SELECT SUM(sale_value) FROM Military_Equipment_Sales WHERE country IN (SELECT country FROM World_Countries WHERE continent = 'Africa') AND sale_date >= DATE_SUB(CURRENT_DATE, INTERVAL 12 MONTH);", "generated_sql": "SELECT SUM(sale_value) AS total_sales_to_africa\nFROM Military_Equipment_Sales\nWHERE country = 'Africa'\n  AND sale_date >= CURRENT_DATE - INTERVAL '12 months';", "raw_model_output": "\n\n```sql\nSELECT SUM(sale_value) AS total_sales_to_africa\nFROM Military_Equipment_Sales\nWHERE country = 'Africa'\n  AND sale_date >= CURRENT_DATE - INTERVAL '12 months';\n```", "latency_sec": 0.7251288890838623, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 130, "prompt_eval_sec": null, "tokens_completion": 49, "completion_eval_sec": null, "tokens_total": 179, "tokens_per_sec": 246.85266673922072, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their country filtering logic. The Reference SQL uses a subquery to select countries in Africa from World_Countries, while the Generated SQL incorrectly filters for a country named 'Africa' (a continent, not a country). This would produce different results unless 'Africa' is a valid country name in the dataset, which is unlikely. The date calculations are functionally equivalent but not identical in syntax."}
{"example_id": 904, "sql_complexity": "basic SQL", "prompt": "What is the minimum Shariah-compliant loan amount issued in the last quarter of 2021?", "context": "CREATE TABLE loans (id INT, amount DECIMAL, date DATE, loan_type VARCHAR); INSERT INTO loans (id, amount, date, loan_type) VALUES (1, 5000, '2021-09-05', 'Shariah-compliant'), (2, 7000, '2021-10-07', 'socially responsible'), (3, 9000, '2021-11-03', 'Shariah-compliant'), (4, 11000, '2021-12-31', 'Shariah-compliant');", "reference_sql": "SELECT MIN(amount) FROM loans WHERE EXTRACT(YEAR FROM date) = 2021 AND EXTRACT(QUARTER FROM date) = 4 AND loan_type = 'Shariah-compliant';", "generated_sql": "SELECT MIN(amount) AS min_shariah_compliant_loan\nFROM loans\nWHERE loan_type = 'Shariah-compliant'\n  AND date >= '2021-10-01'\n  AND date <= '2021-12-31';", "raw_model_output": "\n\n```sql\nSELECT MIN(amount) AS min_shariah_compliant_loan\nFROM loans\nWHERE loan_type = 'Shariah-compliant'\n  AND date >= '2021-10-01'\n  AND date <= '2021-12-31';\n```", "latency_sec": 0.7959790229797363, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 237, "prompt_eval_sec": null, "tokens_completion": 68, "completion_eval_sec": null, "tokens_total": 305, "tokens_per_sec": 383.1759269964638, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter loans with 'Shariah-compliant' type and dates in Q4 2021. The reference query uses EXTRACT(QUARTER) to target Q4, while the generated query uses a date range from 2021-10-01 to 2021-12-31, which covers the same period. The sample data shows both queries would return the same minimum amount (9000)."}
{"example_id": 3299, "sql_complexity": "set operations", "prompt": "How many schools and hospitals are there in Colombia and which ones need repairs?", "context": "CREATE TABLE schools (id INT, country VARCHAR(20), name VARCHAR(50), needs_repair BOOLEAN); CREATE TABLE hospitals (id INT, country VARCHAR(20), name VARCHAR(50), needs_repair BOOLEAN);", "reference_sql": "SELECT 'Schools' as facility_type, COUNT(*) as total, SUM(needs_repair) as repairs_needed FROM schools WHERE country = 'Colombia' UNION ALL SELECT 'Hospitals' as facility_type, COUNT(*) as total, SUM(needs_repair) as repairs_needed FROM hospitals WHERE country = 'Colombia';", "generated_sql": "SELECT \n  (SELECT COUNT(*) FROM schools WHERE country = 'Colombia') + \n  (SELECT COUNT(*) FROM hospitals WHERE country = 'Colombia') AS total_count,\n  (SELECT COUNT(*) FROM schools WHERE country = 'Colombia' AND needs_repair = TRUE) AS schools_needing_repairs,\n  (SELECT COUNT(*) FROM hospitals WHERE country = 'Colombia' AND needs_repair = TRUE) AS hospitals_needing_repairs;", "raw_model_output": "\n\nSELECT \n  (SELECT COUNT(*) FROM schools WHERE country = 'Colombia') + \n  (SELECT COUNT(*) FROM hospitals WHERE country = 'Colombia') AS total_count,\n  (SELECT COUNT(*) FROM schools WHERE country = 'Colombia' AND needs_repair = TRUE) AS schools_needing_repairs,\n  (SELECT COUNT(*) FROM hospitals WHERE country = 'Colombia' AND needs_repair = TRUE) AS hospitals_needing_repairs;", "latency_sec": 0.9171750545501709, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 135, "prompt_eval_sec": null, "tokens_completion": 101, "completion_eval_sec": null, "tokens_total": 236, "tokens_per_sec": 257.31183903136827, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries have different output structures. The Reference SQL returns two rows (Schools/Hospitals) with facility_type, total, and repairs_needed columns. The Generated SQL returns one row with total_count, schools_needing_repairs, and hospitals_needing_repairs columns. The semantic meaning is different: the first compares facilities by type while the second aggregates totals and separates repair counts by facility type."}
{"example_id": 907, "sql_complexity": "set operations", "prompt": "What is the total quantity of items with type 'E' or type 'F' in warehouse O and warehouse P?", "context": "CREATE TABLE warehouse_o(item_id INT, item_type VARCHAR(10), quantity INT);CREATE TABLE warehouse_p(item_id INT, item_type VARCHAR(10), quantity INT);INSERT INTO warehouse_o(item_id, item_type, quantity) VALUES (1, 'E', 200), (2, 'F', 300), (3, 'E', 50), (4, 'F', 400);INSERT INTO warehouse_p(item_id, item_type, quantity) VALUES (1, 'E', 150), (2, 'F', 250), (3, 'E', 40), (4, 'F', 350);", "reference_sql": "SELECT quantity FROM warehouse_o WHERE item_type IN ('E', 'F') UNION ALL SELECT quantity FROM warehouse_p WHERE item_type IN ('E', 'F');", "generated_sql": "SELECT SUM(w.o_quantity + w.p_quantity) AS total_quantity\nFROM (\n    SELECT \n        SUM(CASE WHEN item_type = 'E' THEN quantity ELSE 0 END) AS o_quantity,\n        SUM(CASE WHEN item_type = 'E' THEN quantity ELSE 0 END) AS p_quantity\n    FROM warehouse_o\n    WHERE item_type IN ('E', 'F')\n    UNION ALL\n    SELECT \n        SUM(CASE WHEN item_type = 'F' THEN quantity ELSE 0 END),\n        SUM(CASE WHEN item_type = 'F' THEN quantity ELSE 0 END)\n    FROM warehouse_p\n    WHERE item_type IN ('E', 'F')\n) AS w;", "raw_model_output": "\n\n```sql\nSELECT SUM(w.o_quantity + w.p_quantity) AS total_quantity\nFROM (\n    SELECT \n        SUM(CASE WHEN item_type = 'E' THEN quantity ELSE 0 END) AS o_quantity,\n        SUM(CASE WHEN item_type = 'E' THEN quantity ELSE 0 END) AS p_quantity\n    FROM warehouse_o\n    WHERE item_type IN ('E', 'F')\n    UNION ALL\n    SELECT \n        SUM(CASE WHEN item_type = 'F' THEN quantity ELSE 0 END),\n        SUM(CASE WHEN item_type = 'F' THEN quantity ELSE 0 END)\n    FROM warehouse_p\n    WHERE item_type IN ('E', 'F')\n) AS w;\n```", "latency_sec": 1.416057825088501, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 244, "prompt_eval_sec": null, "tokens_completion": 151, "completion_eval_sec": null, "tokens_total": 395, "tokens_per_sec": 278.9434110681979, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query returns individual quantities from both tables where item_type is 'E' or 'F', producing multiple rows. The generated query aggregates sums in a nested structure and incorrectly adds identical sums (e.g., summing E quantities twice in the same row). Additionally, the generated query's final result is a single value (1700) whereas the reference query's total would be 1740. The structure and output differ significantly."}
{"example_id": 1400, "sql_complexity": "single join", "prompt": "What is the maximum co-ownership duration for properties in the neighborhood of 'Chinatown' in San Francisco?'", "context": "CREATE TABLE sf_neighborhoods (neighborhood_id INT, name VARCHAR(255), city VARCHAR(255)); INSERT INTO sf_neighborhoods (neighborhood_id, name, city) VALUES (1, 'Chinatown', 'San Francisco'); CREATE TABLE co_ownership (co_ownership_id INT, property_id INT, co_owner_id INT, start_date DATE, end_date DATE); INSERT INTO co_ownership (co_ownership_id, property_id, co_owner_id, start_date, end_date) VALUES (1, 1, 2, '2010-01-01', '2020-01-01'), (2, 2, 3, '2015-01-01', '2022-01-01'); CREATE TABLE properties (property_id INT, city VARCHAR(255)); INSERT INTO properties (property_id, city) VALUES (1, 'San Francisco'), (2, 'San Francisco');", "reference_sql": "SELECT MAX(DATEDIFF(end_date, start_date)) as max_duration FROM co_ownership JOIN properties ON co_ownership.property_id = properties.property_id WHERE properties.city = 'San Francisco' AND name = 'Chinatown';", "generated_sql": "SELECT MAX(DATEDIFF(day, co.start_date, co.end_date)) AS max_co_ownership_duration\nFROM co_ownership co\nJOIN properties p ON co.property_id = p.property_id\nJOIN sf_neighborhoods n ON p.city = n.city AND p.city = 'San Francisco'\nWHERE n.name = 'Chinatown';", "raw_model_output": "\n\n```sql\nSELECT MAX(DATEDIFF(day, co.start_date, co.end_date)) AS max_co_ownership_duration\nFROM co_ownership co\nJOIN properties p ON co.property_id = p.property_id\nJOIN sf_neighborhoods n ON p.city = n.city AND p.city = 'San Francisco'\nWHERE n.name = 'Chinatown';\n```", "latency_sec": 0.9217369556427002, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 308, "prompt_eval_sec": null, "tokens_completion": 78, "completion_eval_sec": null, "tokens_total": 386, "tokens_per_sec": 418.7745729809146, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL is missing a critical join with sf_neighborhoods table, which is required to access the 'name' column. The Generated SQL correctly joins all three tables (co_ownership, properties, sf_neighborhoods) and applies the necessary filters. Additionally, the DATEDIFF syntax differs between the queries (DATEDIFF(end_date, start_date) vs DATEDIFF(day, start_date, end_date)), which may produce different results depending on the SQL dialect."}
{"example_id": 5248, "sql_complexity": "window functions", "prompt": "Find the top 5 games by rating", "context": "CREATE TABLE games (game_id INT PRIMARY KEY, name VARCHAR(50), genre VARCHAR(50), rating DECIMAL(3,2));", "reference_sql": "SELECT * FROM (SELECT name, rating, ROW_NUMBER() OVER (ORDER BY rating DESC) as rn FROM games) t WHERE rn <= 5;", "generated_sql": "SELECT name, rating\nFROM games\nORDER BY rating DESC\nLIMIT 5;", "raw_model_output": "\n\nSELECT name, rating\nFROM games\nORDER BY rating DESC\nLIMIT 5;", "latency_sec": 0.5047619342803955, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 111, "prompt_eval_sec": null, "tokens_completion": 22, "completion_eval_sec": null, "tokens_total": 133, "tokens_per_sec": 263.49055062880086, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a row number column (rn) in the result set, while the Generated SQL does not. The Reference SQL returns three columns (name, rating, rn) whereas the Generated SQL returns only two (name, rating). This difference in output columns makes them semantically distinct."}
{"example_id": 778, "sql_complexity": "single join", "prompt": "What is the maximum property price in wheelchair-accessible neighborhoods in Singapore?", "context": "CREATE TABLE Singapore_Neighborhoods (Neighborhood_Name TEXT, Wheelchair_Accessibility BOOLEAN); INSERT INTO Singapore_Neighborhoods (Neighborhood_Name, Wheelchair_Accessibility) VALUES ('Orchard', true), ('Marina Bay', true), ('Chinatown', false), ('Little India', false), ('Bugis', true); CREATE TABLE Singapore_Properties (Neighborhood_Name TEXT, Property_Price INTEGER); INSERT INTO Singapore_Properties (Neighborhood_Name, Property_Price) VALUES ('Orchard', 2000000), ('Marina Bay', 3000000), ('Chinatown', 1500000), ('Little India', 1200000), ('Bugis', 1800000);", "reference_sql": "SELECT MAX(Singapore_Properties.Property_Price) FROM Singapore_Properties INNER JOIN Singapore_Neighborhoods ON Singapore_Properties.Neighborhood_Name = Singapore_Neighborhoods.Neighborhood_Name WHERE Singapore_Neighborhoods.Wheelchair_Accessibility = true;", "generated_sql": "SELECT MAX(Property_Price) \nFROM Singapore_Properties \nWHERE Neighborhood_Name IN (SELECT Neighborhood_Name FROM Singapore_Neighborhoods WHERE Wheelchair_Accessibility = true);", "raw_model_output": "\n\nSELECT MAX(Property_Price) \nFROM Singapore_Properties \nWHERE Neighborhood_Name IN (SELECT Neighborhood_Name FROM Singapore_Neighborhoods WHERE Wheelchair_Accessibility = true);", "latency_sec": 0.5635309219360352, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 255, "prompt_eval_sec": null, "tokens_completion": 39, "completion_eval_sec": null, "tokens_total": 294, "tokens_per_sec": 521.7105016880886, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the maximum property price from neighborhoods with wheelchair accessibility. The Reference SQL uses an INNER JOIN to combine tables and filter on accessibility, while the Generated SQL uses a subquery with IN to filter neighborhoods. Both approaches effectively restrict to the same set of neighborhoods (Orchard, Marina Bay, Bugis) and will return the same MAX(Property_Price) value (3000000)."}
{"example_id": 3859, "sql_complexity": "aggregation", "prompt": "What is the total number of mental health parity violations by month and year?", "context": "CREATE TABLE mental_health_parity_reports (report_id INT, violation_date DATE); INSERT INTO mental_health_parity_reports (report_id, violation_date) VALUES (1, '2022-01-01'), (2, '2022-02-15'), (3, '2022-03-05'), (4, '2022-04-20'), (5, '2021-06-12'), (6, '2021-07-28');", "reference_sql": "SELECT EXTRACT(MONTH FROM violation_date) AS month, EXTRACT(YEAR FROM violation_date) AS year, COUNT(*) FROM mental_health_parity_reports GROUP BY month, year;", "generated_sql": "SELECT \n    DATE_FORMAT(violation_date, '%Y-%m') AS month_year, \n    COUNT(*) AS total_violations\nFROM \n    mental_health_parity_reports\nGROUP BY \n    DATE_FORMAT(violation_date, '%Y-%m');", "raw_model_output": "\n\n```sql\nSELECT \n    DATE_FORMAT(violation_date, '%Y-%m') AS month_year, \n    COUNT(*) AS total_violations\nFROM \n    mental_health_parity_reports\nGROUP BY \n    DATE_FORMAT(violation_date, '%Y-%m');\n```", "latency_sec": 0.9871749877929688, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 208, "prompt_eval_sec": null, "tokens_completion": 63, "completion_eval_sec": null, "tokens_total": 271, "tokens_per_sec": 274.5207317355921, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries group records by the combination of year and month from the violation_date. The Reference SQL uses EXTRACT(MONTH) and EXTRACT(YEAR) to separate the values, while the Generated SQL uses DATE_FORMAT to combine them into a 'YYYY-MM' string. Since grouping is based on the same logical key (year and month), the aggregation results (counts per group) will be identical. The difference in column names and data types (separate vs. combined) does not affect semantic equivalence as the underlying grouping logic is the same."}
{"example_id": 3551, "sql_complexity": "multiple_joins", "prompt": "List all artists who have performed in New York and Chicago, along with their highest-earning performance.", "context": "CREATE TABLE artist_events (artist_id INT, event_id INT, earnings DECIMAL(5,2)); CREATE TABLE artists (id INT, name VARCHAR(50)); CREATE TABLE events (id INT, city VARCHAR(20));", "reference_sql": "SELECT artists.name, MAX(artist_events.earnings) FROM artists INNER JOIN artist_events ON artists.id = artist_events.artist_id INNER JOIN events ON artist_events.event_id = events.id WHERE city IN ('New York', 'Chicago') GROUP BY artists.name;", "generated_sql": "SELECT a.name, MAX(ae.earnings) AS highest_earning_performance\nFROM artists a\nJOIN artist_events ae ON a.id = ae.artist_id\nJOIN events e ON ae.event_id = e.id\nWHERE e.city IN ('New York', 'Chicago')\nGROUP BY a.name\nHAVING COUNT(DISTINCT e.city) = 2;", "raw_model_output": "\n\n```sql\nSELECT a.name, MAX(ae.earnings) AS highest_earning_performance\nFROM artists a\nJOIN artist_events ae ON a.id = ae.artist_id\nJOIN events e ON ae.event_id = e.id\nWHERE e.city IN ('New York', 'Chicago')\nGROUP BY a.name\nHAVING COUNT(DISTINCT e.city) = 2;\n```", "latency_sec": 1.1091690063476562, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 139, "prompt_eval_sec": null, "tokens_completion": 82, "completion_eval_sec": null, "tokens_total": 221, "tokens_per_sec": 199.24826490394204, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The generated query includes a HAVING clause filtering for artists with events in both 'New York' and 'Chicago' (COUNT(DISTINCT e.city) = 2), while the reference query only filters events in those cities without requiring multiple cities. This makes the generated query more restrictive, as it excludes artists who only performed in one of the two cities."}
{"example_id": 5168, "sql_complexity": "aggregation", "prompt": "Get the number of renewable energy projects in Australia for each project type.", "context": "CREATE TABLE renewable_projects (id INT PRIMARY KEY, project_name VARCHAR(255), project_location VARCHAR(255), project_type VARCHAR(255), capacity_mw FLOAT);", "reference_sql": "SELECT project_type, COUNT(*) FROM renewable_projects WHERE project_location = 'Australia' GROUP BY project_type;", "generated_sql": "SELECT project_type, COUNT(*) AS number_of_projects\nFROM renewable_projects\nWHERE project_location = 'Australia'\nGROUP BY project_type;", "raw_model_output": "\n\nSELECT project_type, COUNT(*) AS number_of_projects\nFROM renewable_projects\nWHERE project_location = 'Australia'\nGROUP BY project_type;", "latency_sec": 0.2850761413574219, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 125, "prompt_eval_sec": null, "tokens_completion": 32, "completion_eval_sec": null, "tokens_total": 157, "tokens_per_sec": 550.7300584764021, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (project_type and count of projects) from the same table with the same filter and grouping. The generated query adds an alias 'number_of_projects' to the count column, but this does not affect the semantic result set's data. The core logic of filtering, grouping, and aggregating remains identical."}
{"example_id": 4916, "sql_complexity": "aggregation", "prompt": "What is the maximum revenue generated from selling Yttrium in India in the past 3 years?", "context": "CREATE TABLE Yttrium_Sales (id INT PRIMARY KEY, year INT, country VARCHAR(20), quantity INT, price PER_KG); INSERT INTO Yttrium_Sales (id, year, country, quantity, price) VALUES (1, 2019, 'India', 120, 40), (2, 2020, 'India', 130, 45), (3, 2021, 'India', 140, 50), (4, 2019, 'China', 150, 35), (5, 2020, 'China', 160, 40), (6, 2021, 'China', 170, 45);", "reference_sql": "SELECT MAX(quantity * price) FROM Yttrium_Sales WHERE country = 'India' GROUP BY year ORDER BY year DESC LIMIT 3;", "generated_sql": "SELECT MAX(total_revenue) AS max_revenue\nFROM (\n    SELECT year, quantity * price AS total_revenue\n    FROM Yttrium_Sales\n    WHERE country = 'India'\n    ORDER BY year DESC\n    LIMIT 3\n) AS last_three_years;", "raw_model_output": "\n\n```sql\nSELECT MAX(total_revenue) AS max_revenue\nFROM (\n    SELECT year, quantity * price AS total_revenue\n    FROM Yttrium_Sales\n    WHERE country = 'India'\n    ORDER BY year DESC\n    LIMIT 3\n) AS last_three_years;\n```", "latency_sec": 0.5333559513092041, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 270, "prompt_eval_sec": null, "tokens_completion": 67, "completion_eval_sec": null, "tokens_total": 337, "tokens_per_sec": 631.8482041360592, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns three rows (one per year) with the MAX(quantity * price) for each year, ordered descending. The Generated SQL returns a single row with the MAX(total_revenue) from the top 3 years. The first query produces multiple rows, while the second produces a single aggregated value, making them semantically different."}
{"example_id": 812, "sql_complexity": "multiple_joins", "prompt": "What is the average salary of 'engineer' workers in each factory?", "context": "CREATE TABLE factories (factory_id INT, factory_name VARCHAR(20)); INSERT INTO factories VALUES (1, 'Factory X'), (2, 'Factory Y'), (3, 'Factory Z'); CREATE TABLE roles (role_id INT, role_name VARCHAR(20)); INSERT INTO roles VALUES (1, 'engineer'), (2, 'manager'), (3, 'assistant'); CREATE TABLE workers (worker_id INT, factory_id INT, role_id INT, salary DECIMAL(5,2)); INSERT INTO workers VALUES (1, 1, 1, 50000.00), (2, 1, 2, 70000.00), (3, 2, 1, 55000.00), (4, 2, 3, 40000.00), (5, 3, 1, 60000.00);", "reference_sql": "SELECT f.factory_name, AVG(salary) FROM workers w INNER JOIN factories f ON w.factory_id = f.factory_id INNER JOIN roles r ON w.role_id = r.role_id WHERE r.role_name = 'engineer' GROUP BY f.factory_name;", "generated_sql": "SELECT f.factory_name, AVG(w.salary) AS average_salary\nFROM workers w\nJOIN factories f ON w.factory_id = f.factory_id\nJOIN roles r ON w.role_id = r.role_id\nWHERE r.role_name = 'engineer'\nGROUP BY f.factory_name;", "raw_model_output": "\n\n```sql\nSELECT f.factory_name, AVG(w.salary) AS average_salary\nFROM workers w\nJOIN factories f ON w.factory_id = f.factory_id\nJOIN roles r ON w.role_id = r.role_id\nWHERE r.role_name = 'engineer'\nGROUP BY f.factory_name;\n```", "latency_sec": 0.5810887813568115, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 288, "prompt_eval_sec": null, "tokens_completion": 65, "completion_eval_sec": null, "tokens_total": 353, "tokens_per_sec": 607.4803219841273, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the average salary per factory for workers with the 'engineer' role. The differences are purely syntactic: the generated query uses an explicit table alias (w.salary) where the reference uses an unqualified column name (salary), and the generated query adds an alias (average_salary). Since the underlying data, joins, filters, and grouping logic are identical, the results will be the same."}
{"example_id": 5784, "sql_complexity": "set operations", "prompt": "List the number of users who have completed a workout of a specific type (e.g. Running) and have a membership status of 'Active'.", "context": "CREATE TABLE workouts (id INT, user_id INT, workout_type VARCHAR(20)); CREATE TABLE members (id INT, name VARCHAR(50), membership_status VARCHAR(20), state VARCHAR(20)); INSERT INTO workouts (id, user_id, workout_type) VALUES (1, 1, 'Running'), (2, 1, 'Cycling'), (3, 2, 'Running'), (4, 3, 'Cycling'), (5, 3, 'Swimming'), (6, 4, 'Running'), (7, 4, 'Swimming'); INSERT INTO members (id, name, membership_status, state) VALUES (1, 'John Doe', 'Active', 'Texas'), (2, 'Jane Doe', 'Inactive', 'California'), (3, 'Bob Smith', 'Active', 'Texas'), (4, 'Alice Johnson', 'Active', 'California');", "reference_sql": "SELECT COUNT(*) FROM (SELECT user_id FROM workouts WHERE workout_type = 'Running' INTERSECT SELECT id FROM members WHERE membership_status = 'Active') AS user_set;", "generated_sql": "SELECT COUNT(DISTINCT w.user_id) \nFROM workouts w \nJOIN members m ON w.user_id = m.id \nWHERE w.workout_type = 'Running' AND m.membership_status = 'Active';", "raw_model_output": "\n\n```sql\nSELECT COUNT(DISTINCT w.user_id) \nFROM workouts w \nJOIN members m ON w.user_id = m.id \nWHERE w.workout_type = 'Running' AND m.membership_status = 'Active';\n```", "latency_sec": 0.9181950092315674, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 291, "prompt_eval_sec": null, "tokens_completion": 52, "completion_eval_sec": null, "tokens_total": 343, "tokens_per_sec": 373.5589897042186, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of distinct user_ids that have at least one 'Running' workout and are active members. The Reference SQL uses INTERSECT to find common user_ids between workouts (for 'Running') and members (with 'Active' status), while the Generated SQL uses a JOIN to combine matching rows and COUNT(DISTINCT) to ensure uniqueness. Both approaches yield the same result by filtering for users present in both datasets with the required conditions."}
{"example_id": 3038, "sql_complexity": "subqueries", "prompt": "What is the total assets of clients who have invested in mutual funds but not in stocks?", "context": "CREATE TABLE clients (client_id INT, name TEXT, age INT, gender TEXT, total_assets DECIMAL(10,2)); INSERT INTO clients VALUES (1, 'John Doe', 35, 'Male', 250000.00), (2, 'Jane Smith', 45, 'Female', 500000.00); CREATE TABLE investments (client_id INT, investment_type TEXT); INSERT INTO investments VALUES (1, 'Stocks'), (1, 'Bonds'), (2, 'Stocks'), (3, 'Mutual Funds');", "reference_sql": "SELECT c.total_assets FROM clients c INNER JOIN investments i ON c.client_id = i.client_id WHERE i.investment_type = 'Mutual Funds' AND c.client_id NOT IN (SELECT client_id FROM investments WHERE investment_type = 'Stocks');", "generated_sql": "SELECT SUM(clients.total_assets) \nFROM clients \nWHERE clients.client_id IN (\n    SELECT client_id \n    FROM investments \n    WHERE investment_type = 'Mutual Funds'\n) \nAND clients.client_id NOT IN (\n    SELECT client_id \n    FROM investments \n    WHERE investment_type = 'Stocks'\n);", "raw_model_output": "\n\n```sql\nSELECT SUM(clients.total_assets) \nFROM clients \nWHERE clients.client_id IN (\n    SELECT client_id \n    FROM investments \n    WHERE investment_type = 'Mutual Funds'\n) \nAND clients.client_id NOT IN (\n    SELECT client_id \n    FROM investments \n    WHERE investment_type = 'Stocks'\n);\n```", "latency_sec": 0.842336893081665, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 216, "prompt_eval_sec": null, "tokens_completion": 73, "completion_eval_sec": null, "tokens_total": 289, "tokens_per_sec": 343.0931286206661, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns individual client assets, while the Generated SQL aggregates them with SUM. Additionally, the Reference uses an INNER JOIN which excludes clients without matching investments, whereas the Generated SQL uses IN clauses that could behave differently with missing client IDs. The sample data shows no matching clients, but semantically, the queries differ in output structure (rows vs. single sum) and logic (JOIN vs. IN clauses)."}
{"example_id": 1078, "sql_complexity": "basic SQL", "prompt": "What is the maximum and minimum temperature difference between any two Arctic research stations?", "context": "CREATE TABLE arctic_stations (id INT, name TEXT, location TEXT, temperature DECIMAL(5,2)); INSERT INTO arctic_stations (id, name, location, temperature) VALUES (1, 'Station A', 'Greenland', 2.3), (2, 'Station B', 'Canada', -5.2);", "reference_sql": "SELECT a.name as station1, b.name as station2, MAX(ABS(a.temperature - b.temperature)) as temp_diff FROM arctic_stations a, arctic_stations b ORDER BY temp_diff DESC LIMIT 1", "generated_sql": "SELECT MAX(temperature) - MIN(temperature) AS temperature_difference FROM arctic_stations;", "raw_model_output": "\n\n```sql\nSELECT MAX(temperature) - MIN(temperature) AS temperature_difference FROM arctic_stations;\n```", "latency_sec": 0.4406740665435791, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 158, "prompt_eval_sec": null, "tokens_completion": 28, "completion_eval_sec": null, "tokens_total": 186, "tokens_per_sec": 422.080658067511, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the maximum absolute temperature difference between any two stations (returning station names and the difference), while the Generated SQL computes the overall temperature range (max - min). Although both capture the same numerical value (max - min = max absolute difference between any pair), the Reference SQL returns additional columns (station names) and the Generated SQL returns a single value. The result structures differ, making them non-equivalent."}
{"example_id": 5015, "sql_complexity": "basic SQL", "prompt": "Calculate the average recycling rate", "context": "CREATE TABLE recycling_rates (id INT PRIMARY KEY, location VARCHAR(50), rate FLOAT);", "reference_sql": "SELECT AVG(rate) FROM recycling_rates;", "generated_sql": "SELECT AVG(rate) FROM recycling_rates;", "raw_model_output": "\n\nSELECT AVG(rate) FROM recycling_rates;", "latency_sec": 0.2756829261779785, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 97, "prompt_eval_sec": null, "tokens_completion": 13, "completion_eval_sec": null, "tokens_total": 110, "tokens_per_sec": 399.00911356760975, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both calculate the average of the 'rate' column from the 'recycling_rates' table without any differences in syntax, conditions, or clauses."}
{"example_id": 1533, "sql_complexity": "subqueries", "prompt": "Which programs had the highest volunteer participation rate in the last quarter?", "context": "CREATE TABLE Programs (ProgramID INT, ProgramName TEXT, Budget DECIMAL(10,2), NumVolunteers INT); CREATE TABLE VolunteerEvents (EventID INT, ProgramID INT, EventDate DATE, NumVolunteers INT);", "reference_sql": "SELECT p.ProgramName, COUNT(v.EventID) / (SELECT COUNT(*) FROM VolunteerEvents WHERE EventDate >= DATEADD(quarter, -1, GETDATE())) * 100.0 AS VolunteerParticipationRate FROM Programs p INNER JOIN VolunteerEvents v ON p.ProgramID = v.ProgramID WHERE v.EventDate >= DATEADD(quarter, -1, GETDATE()) GROUP BY p.ProgramName ORDER BY VolunteerParticipationRate DESC;", "generated_sql": "SELECT p.ProgramID, p.ProgramName, SUM(ve.NumVolunteers) AS TotalVolunteers\nFROM Programs p\nJOIN VolunteerEvents ve ON p.ProgramID = ve.ProgramID\nWHERE ve.EventDate >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH)\nGROUP BY p.ProgramID, p.ProgramName\nORDER BY TotalVolunteers DESC\nLIMIT 1;", "raw_model_output": "\n\n```sql\nSELECT p.ProgramID, p.ProgramName, SUM(ve.NumVolunteers) AS TotalVolunteers\nFROM Programs p\nJOIN VolunteerEvents ve ON p.ProgramID = ve.ProgramID\nWHERE ve.EventDate >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH)\nGROUP BY p.ProgramID, p.ProgramName\nORDER BY TotalVolunteers DESC\nLIMIT 1;\n```", "latency_sec": 0.610292911529541, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 133, "prompt_eval_sec": null, "tokens_completion": 84, "completion_eval_sec": null, "tokens_total": 217, "tokens_per_sec": 355.5669677633085, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates a participation rate percentage by dividing event counts in the last quarter by total events in the same period, while the generated query sums volunteer numbers and limits results to 1 row. They also use different date functions (DATEADD vs DATE_SUB) and group by different columns (ProgramName vs ProgramID/ProgramName)."}
