{"example_id": 2656, "sql_complexity": "multiple_joins", "prompt": "Find the drugs and their respective total sales for rare diseases indication with sales greater than the average sales for infectious diseases.", "context": "CREATE TABLE sales (id INT, drug_id INT, quarter INT, year INT, revenue FLOAT); INSERT INTO sales (id, drug_id, quarter, year, revenue) VALUES (1, 1, 1, 2022, 1500000); CREATE TABLE drugs (id INT, name VARCHAR(50), company VARCHAR(50), indication VARCHAR(50)); INSERT INTO drugs (id, name, company, indication) VALUES (1, 'DrugA', 'ABC Corp', 'Rare_Diseases');", "reference_sql": "SELECT s.drug_id, d.name, SUM(s.revenue) as total_sales FROM sales s JOIN drugs d ON s.drug_id = d.id WHERE d.indication = 'Rare_Diseases' GROUP BY s.drug_id HAVING total_sales > (SELECT AVG(s2.revenue) FROM sales s2 JOIN drugs d2 ON s2.drug_id = d2.id WHERE d2.indication = 'Infectious_Diseases')", "generated_sql": "SELECT d.name, SUM(s.revenue) AS total_sales\nFROM sales s\nJOIN drugs d ON s.drug_id = d.id\nWHERE d.indication = 'Rare_Diseases'\nGROUP BY d.name\nHAVING SUM(s.revenue) > (\n    SELECT AVG(revenue)\n    FROM sales s2\n    JOIN drugs d2 ON s2.drug_id = d2.id\n    WHERE d2.indication = 'Infectious Diseases'\n);", "raw_model_output": "To find the drugs and their respective total sales for rare diseases indication with sales greater than the average sales for infectious diseases, we need to follow these steps:\n\n1. Calculate the total sales for each drug.\n2. Determine the average sales of all drugs indicated for infectious diseases.\n3. Filter out the drugs that are indicated for rare diseases and have sales greater than the calculated average sales for infectious diseases.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT d.name, SUM(s.revenue) AS total_sales\nFROM sales s\nJOIN drugs d ON s.drug_id = d.id\nWHERE d.indication = 'Rare_Diseases'\nGROUP BY d.name\nHAVING SUM(s.revenue) > (\n    SELECT AVG(revenue)\n    FROM sales s2\n    JOIN drugs d2 ON s2.drug_id = d2.id\n    WHERE d2.indication = 'Infectious Diseases'\n);\n```\n\nThis query first calculates the total revenue for each drug indicated as \"Rare_Diseases\". Then, it compares this total revenue against the average revenue of all drugs indicated as \"Infectious Diseases\" and filters out those that do not meet the criteria.", "latency_sec": 11.509449243545532, "total_duration_sec": 11.445907928, "load_duration_sec": 5.41530688, "tokens_prompt": 782, "prompt_eval_sec": 0.514174426, "tokens_completion": 242, "completion_eval_sec": 5.507122118, "tokens_total": 1024, "tokens_per_sec": 88.97037367572183, "retrieval_latency_sec": 0.6878058910369873, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Reference SQL groups by `s.drug_id` while the Generated SQL groups by `d.name`, which could produce different results if multiple drugs share the same name. Second, the subquery in the HAVING clause uses different indication values: 'Infectious_Diseases' (Reference) vs. 'Infectious Diseases' (Generated), which would affect the average revenue calculation. These differences make the queries semantically non-equivalent."}
{"example_id": 3008, "sql_complexity": "multiple_joins", "prompt": "Who are the users who used electric vehicles and their trip details?", "context": "CREATE TABLE users (id INT, name VARCHAR(50), age INT, gender VARCHAR(10), city VARCHAR(50));CREATE TABLE vehicles (id INT, vehicle_type VARCHAR(20), is_electric BOOLEAN);CREATE TABLE trips (id INT, user_id INT, vehicle_id INT, trip_distance FLOAT, trip_duration INT, departure_time TIMESTAMP, arrival_time TIMESTAMP);INSERT INTO users (id, name, age, gender, city) VALUES (3, 'Alex', 30, 'Female', 'New York');INSERT INTO vehicles (id, vehicle_type, is_electric) VALUES (1, 'Tesla', true), (2, 'Bike', false);INSERT INTO trips (id, user_id, vehicle_id, trip_distance, trip_duration, departure_time, arrival_time) VALUES (3, 3, 1, 15.3, 25, '2022-01-03 12:00:00', '2022-01-03 12:25:00');", "reference_sql": "SELECT u.name, v.vehicle_type, t.trip_distance, t.trip_duration FROM users u JOIN trips t ON u.id = t.user_id JOIN vehicles v ON t.vehicle_id = v.id WHERE v.is_electric = true;", "generated_sql": "SELECT u.name AS user_name, v.vehicle_type, t.trip_distance, t.trip_duration, t.departure_time, t.arrival_time \nFROM users u \nJOIN trips t ON u.id = t.user_id \nJOIN vehicles v ON v.id = t.vehicle_id \nWHERE v.is_electric = true;", "raw_model_output": "To find the users who used electric vehicles and their trip details, we need to join three tables: `users`, `vehicles`, and `trips`. We will filter the results to include only those trips where the vehicle is electric.\n\nHere's the SQL query:\n\n```sql\nSELECT u.name AS user_name, v.vehicle_type, t.trip_distance, t.trip_duration, t.departure_time, t.arrival_time \nFROM users u \nJOIN trips t ON u.id = t.user_id \nJOIN vehicles v ON v.id = t.vehicle_id \nWHERE v.is_electric = true;\n```", "latency_sec": 3.4334492683410645, "total_duration_sec": 3.165869186, "load_duration_sec": 0.015809175, "tokens_prompt": 803, "prompt_eval_sec": 0.330723753, "tokens_completion": 121, "completion_eval_sec": 2.81595117, "tokens_total": 924, "tokens_per_sec": 269.1171261856005, "retrieval_latency_sec": 0.10422492027282715, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The generated query includes additional columns (departure_time, arrival_time) and renames the 'name' column to 'user_name' compared to the reference query. The reference query only selects four columns while the generated query selects six columns, making their result sets different."}
{"example_id": 2531, "sql_complexity": "basic SQL", "prompt": "Who is the top customer by sales in 2022?", "context": "CREATE TABLE customers (customer_id INT, total_sales_2022 FLOAT); INSERT INTO customers (customer_id, total_sales_2022) VALUES (1, 25000.0), (2, 30000.0), (3, 22000.0), (4, 35000.0);", "reference_sql": "SELECT customer_id, total_sales_2022 FROM customers ORDER BY total_sales_2022 DESC LIMIT 1;", "generated_sql": "SELECT customer_id \nFROM customers \nORDER BY total_sales_2022 DESC \nLIMIT 1;", "raw_model_output": "```sql\nSELECT customer_id \nFROM customers \nORDER BY total_sales_2022 DESC \nLIMIT 1;\n```", "latency_sec": 1.3841009140014648, "total_duration_sec": 1.353499731, "load_duration_sec": 0.015124299, "tokens_prompt": 1433, "prompt_eval_sec": 0.630162286, "tokens_completion": 27, "completion_eval_sec": 0.704082183, "tokens_total": 1460, "tokens_per_sec": 1054.836381676181, "retrieval_latency_sec": 0.11362195014953613, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The reference query selects both 'customer_id' and 'total_sales_2022' columns, while the generated query only selects 'customer_id'. Although both order by 'total_sales_2022' descending and limit to 1 result, the first query returns an additional column that changes the result set structure."}
{"example_id": 3792, "sql_complexity": "single join", "prompt": "What is the maximum distance traveled by an electric vehicle in a single trip, grouped by vehicle model?", "context": "CREATE TABLE Trips (trip_id INT, vehicle_id INT, distance FLOAT); CREATE TABLE ElectricVehicleModels (vehicle_id INT, vehicle_model TEXT);", "reference_sql": "SELECT evm.vehicle_model, MAX(trips.distance) AS max_distance_traveled FROM Trips trips INNER JOIN ElectricVehicleModels evm ON trips.vehicle_id = evm.vehicle_id GROUP BY 1;", "generated_sql": "SELECT evm.vehicle_model, MAX(t.distance) as max_distance\nFROM Trips t\nJOIN ElectricVehicleModels evm ON t.vehicle_id = evm.vehicle_id\nGROUP BY evm.vehicle_model;", "raw_model_output": "To find the maximum distance traveled by an electric vehicle in a single trip, grouped by vehicle model, you can use the following SQL query:\n\n```sql\nSELECT evm.vehicle_model, MAX(t.distance) as max_distance\nFROM Trips t\nJOIN ElectricVehicleModels evm ON t.vehicle_id = evm.vehicle_id\nGROUP BY evm.vehicle_model;\n```\n\nThis query joins the `Trips` and `ElectricVehicleModels` tables on the `vehicle_id`, groups by `vehicle_model`, and calculates the maximum distance for each vehicle model.", "latency_sec": 3.0728628635406494, "total_duration_sec": 3.031692277, "load_duration_sec": 0.014704758, "tokens_prompt": 924, "prompt_eval_sec": 0.352724566, "tokens_completion": 113, "completion_eval_sec": 2.660547825, "tokens_total": 1037, "tokens_per_sec": 337.47031548460836, "retrieval_latency_sec": 0.11016178131103516, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the maximum distance traveled per vehicle model by joining the Trips and ElectricVehicleModels tables. The Reference SQL uses 'GROUP BY 1' (aliasing the first column) while the Generated SQL explicitly groups by 'evm.vehicle_model'. The table aliases ('trips' vs 't') and column alias ('max_distance_traveled' vs 'max_distance') differ but do not affect the semantic result. The aggregation logic and join conditions are identical."}
{"example_id": 2311, "sql_complexity": "subqueries", "prompt": "Determine the percentage of sales from each ingredient category", "context": "CREATE TABLE Sales_Details (sale_id INT, ingredient_id INT, quantity INT); INSERT INTO Sales_Details (sale_id, ingredient_id, quantity) VALUES (1, 1, 2), (1, 2, 8), (2, 1, 3), (2, 2, 7); CREATE TABLE Ingredient_Categories (ingredient_id INT, ingredient_category VARCHAR(255)); INSERT INTO Ingredient_Categories (ingredient_id, ingredient_category) VALUES (1, 'Legumes'), (2, 'Poultry');", "reference_sql": "SELECT ingredient_category, SUM(quantity) AS total_quantity, SUM(quantity) * 100.0 / (SELECT SUM(quantity) FROM Sales_Details) AS percentage_of_sales FROM Sales_Details, Ingredient_Categories WHERE Sales_Details.ingredient_id = Ingredient_Categories.ingredient_id GROUP BY ingredient_category;", "generated_sql": "SELECT \n    ic.ingredient_category,\n    100.0 * SUM(sd.quantity) / (SELECT SUM(quantity) FROM Sales_Details) AS percentage\nFROM \n    Sales_Details sd\nJOIN \n    Ingredient_Categories ic ON sd.ingredient_id = ic.ingredient_id\nGROUP BY \n    ic.ingredient_category;", "raw_model_output": "To determine the percentage of sales from each ingredient category, we need to follow these steps:\n\n1. Calculate the total quantity sold for all ingredients.\n2. Group the data by `ingredient_category` and calculate the sum of quantities for each category.\n3. Compute the percentage of each category's total quantity relative to the overall total quantity.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT \n    ic.ingredient_category,\n    100.0 * SUM(sd.quantity) / (SELECT SUM(quantity) FROM Sales_Details) AS percentage\nFROM \n    Sales_Details sd\nJOIN \n    Ingredient_Categories ic ON sd.ingredient_id = ic.ingredient_id\nGROUP BY \n    ic.ingredient_category;\n```", "latency_sec": 4.8165600299835205, "total_duration_sec": 3.803900157, "load_duration_sec": 0.027566865, "tokens_prompt": 789, "prompt_eval_sec": 0.323946299, "tokens_completion": 149, "completion_eval_sec": 3.446618233, "tokens_total": 938, "tokens_per_sec": 194.74479590431042, "retrieval_latency_sec": 0.11056303977966309, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the total quantity and percentage of sales per ingredient category. They use equivalent JOIN logic (implicit vs explicit), same aggregation calculations (SUM(quantity) * 100.0 / total), and group by ingredient_category. The column aliases differ but the computed values are identical. The subquery for total sales is also the same."}
{"example_id": 3329, "sql_complexity": "set operations", "prompt": "Which causes received funding from donors in both the United States and Canada?", "context": "CREATE TABLE donor_location (donor_id INT, country VARCHAR(50), cause VARCHAR(50), donation DECIMAL(10,2)); INSERT INTO donor_location (donor_id, country, cause, donation) VALUES (1, 'United States', 'Global Health', 1000.00), (2, 'Canada', 'Education', 2000.00), (3, 'United States', 'Environment', 1500.00), (4, 'Canada', 'Animal Welfare', 2500.00);", "reference_sql": "SELECT cause FROM donor_location WHERE country = 'United States' INTERSECT SELECT cause FROM donor_location WHERE country = 'Canada';", "generated_sql": "SELECT cause \nFROM donor_location \nWHERE country = 'United States'\nINTERSECT\nSELECT cause \nFROM donor_location \nWHERE country = 'Canada';", "raw_model_output": "To find which causes received funding from donors in both the United States and Canada, we need to filter the `donor_location` table for each country separately and then identify the common causes between these two sets.\n\nHere is the SQL query:\n\n```sql\nSELECT cause \nFROM donor_location \nWHERE country = 'United States'\nINTERSECT\nSELECT cause \nFROM donor_location \nWHERE country = 'Canada';\n```\n\nThis query uses the `INTERSECT` operator to find the causes that appear in both filtered results.", "latency_sec": 3.0928900241851807, "total_duration_sec": 2.897287276, "load_duration_sec": 0.014515082, "tokens_prompt": 949, "prompt_eval_sec": 0.369790778, "tokens_completion": 106, "completion_eval_sec": 2.508180571, "tokens_total": 1055, "tokens_per_sec": 341.1049186199043, "retrieval_latency_sec": 0.11437511444091797, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They select the 'cause' column from the donor_location table where country is 'United States' and 'Canada' respectively, then apply the INTERSECT operator to find common causes between the two countries. Since the queries are exactly the same, they will produce identical results."}
{"example_id": 2912, "sql_complexity": "single join", "prompt": "Which company has manufactured the most satellites?", "context": "CREATE TABLE manufacturers (id INT, name TEXT); CREATE TABLE satellites (id INT, manufacturer_id INT, name TEXT, launch_date DATE); INSERT INTO manufacturers (id, name) VALUES (1, 'SpaceX'), (2, 'Blue Origin'), (3, 'ISRO'), (4, 'CAST'); INSERT INTO satellites (id, manufacturer_id, name, launch_date) VALUES (1, 1, 'StarDragon', '2012-05-25'), (2, 1, 'Falcon', '2015-12-21'), (3, 2, 'New Glenn', '2022-01-11'), (4, 3, 'ChinaSat 1E', '2000-12-05'), (5, 3, 'ChinaSat 2A', '2003-08-13'), (6, 4, 'Shijian 9', '2017-11-19'), (7, 1, 'StarLink', '2020-05-24'), (8, 1, 'StarLink', '2020-06-13');", "reference_sql": "SELECT m.name, COUNT(s.id) FROM manufacturers m JOIN satellites s ON m.id = s.manufacturer_id GROUP BY m.name ORDER BY COUNT(s.id) DESC;", "generated_sql": "SELECT m.name \nFROM manufacturers m \nJOIN (\n    SELECT manufacturer_id, COUNT(*) AS satellite_count \n    FROM satellites \n    GROUP BY manufacturer_id\n) s ON m.id = s.manufacturer_id \nORDER BY s.satellite_count DESC \nLIMIT 1;", "raw_model_output": "To determine which company has manufactured the most satellites, we need to count the number of satellites each manufacturer has produced and then find the maximum count. Here is the corresponding SQL query:\n\n```sql\nSELECT m.name \nFROM manufacturers m \nJOIN (\n    SELECT manufacturer_id, COUNT(*) AS satellite_count \n    FROM satellites \n    GROUP BY manufacturer_id\n) s ON m.id = s.manufacturer_id \nORDER BY s.satellite_count DESC \nLIMIT 1;\n```\n\nThis query first counts the number of satellites each manufacturer has produced and then joins this count with the manufacturers table to get the name of the company. Finally, it orders the results by the satellite count in descending order and limits the result to one row to find the manufacturer that has made the most satellites.", "latency_sec": 4.143293142318726, "total_duration_sec": 4.116826303, "load_duration_sec": 0.014289742, "tokens_prompt": 1025, "prompt_eval_sec": 0.401995985, "tokens_completion": 156, "completion_eval_sec": 3.696201662, "tokens_total": 1181, "tokens_per_sec": 285.0389676601721, "retrieval_latency_sec": 0.1158909797668457, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns all manufacturers with their satellite counts ordered by count descending, while the Generated SQL only returns the top manufacturer (LIMIT 1) with the highest satellite count. The Generated SQL also uses a subquery to pre-aggregate satellite counts, but the final result set size and purpose differ."}
{"example_id": 3170, "sql_complexity": "aggregation", "prompt": "Determine the total production quantity of silver for mining sites in Mexico, between the dates '2017-05-01' and '2017-09-30', having less than 40 employees.", "context": "CREATE TABLE silver_mine_2 (site_id INT, country VARCHAR(50), num_employees INT, extraction_date DATE, quantity INT); INSERT INTO silver_mine_2 (site_id, country, num_employees, extraction_date, quantity) VALUES (1, 'Mexico', 35, '2017-05-02', 1200), (2, 'Mexico', 30, '2017-08-31', 1800), (3, 'Mexico', 37, '2017-07-04', 2200);", "reference_sql": "SELECT country, SUM(quantity) as total_silver_prod FROM silver_mine_2 WHERE num_employees < 40 AND country = 'Mexico' AND extraction_date >= '2017-05-01' AND extraction_date <= '2017-09-30' GROUP BY country;", "generated_sql": "SELECT SUM(quantity) AS total_production\nFROM silver_mine_2\nWHERE country = 'Mexico'\nAND extraction_date BETWEEN '2017-05-01' AND '2017-09-30'\nAND num_employees < 40;", "raw_model_output": "To determine the total production quantity of silver for mining sites in Mexico between the dates '2017-05-01' and '2017-09-30', having less than 40 employees, you can use the following SQL query:\n\n```sql\nSELECT SUM(quantity) AS total_production\nFROM silver_mine_2\nWHERE country = 'Mexico'\nAND extraction_date BETWEEN '2017-05-01' AND '2017-09-30'\nAND num_employees < 40;\n```\n\nThis query sums up the `quantity` of silver extracted from sites in Mexico that meet the specified date and employee criteria.", "latency_sec": 4.046813011169434, "total_duration_sec": 3.880603066, "load_duration_sec": 0.015723204, "tokens_prompt": 1027, "prompt_eval_sec": 0.403321425, "tokens_completion": 146, "completion_eval_sec": 3.457420992, "tokens_total": 1173, "tokens_per_sec": 289.85772180786546, "retrieval_latency_sec": 0.1216425895690918, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a GROUP BY clause on 'country', which returns a row with both 'country' and 'total_silver_prod' columns. The Generated SQL omits the GROUP BY and selects only the aggregated value, resulting in a single column. While the numerical result (sum) may be the same, the structure of the result set differs, making them not semantically equivalent."}
{"example_id": 3518, "sql_complexity": "basic SQL", "prompt": "Insert new records of ticket sales for a new event, including event and salesperson information.", "context": "CREATE TABLE salesperson (salesperson_id INT, name VARCHAR(50), position VARCHAR(50)); CREATE TABLE tickets (ticket_id INT, salesperson_id INT, event_id INT, price DECIMAL(5,2), quantity INT); CREATE TABLE events (event_id INT, name VARCHAR(50), date DATE); INSERT INTO salesperson VALUES (1, 'John Doe', 'Senior Salesperson'); INSERT INTO events VALUES (2, 'New Event', '2023-04-15');", "reference_sql": "INSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity) VALUES (2, 1, 2, 75, 50), (3, 2, 2, 65, 75); INSERT INTO events (event_id, name, date) VALUES (2, 'New Event', '2023-04-15');", "generated_sql": "INSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity) \nVALUES (3, 1, 2, 75.00, 50);", "raw_model_output": "To insert new records of ticket sales for a new event with the provided information, we need to ensure that all necessary details are included in the `tickets` table and possibly update or confirm details in the `events` table if needed.\n\nGiven:\n- A new event has been added: `(2, 'New Event', '2023-04-15')`\n- A salesperson is available: `(1, 'John Doe', 'Senior Salesperson')`\n\nLet's assume we want to insert ticket sales for this event with the following details:\n- `ticket_id`: 3\n- `salesperson_id`: 1 (John Doe)\n- `event_id`: 2 ('New Event')\n- `price`: 75.00\n- `quantity`: 50\n\nThe SQL statement to insert these records into the `tickets` table would be:\n\n```sql\nINSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity) \nVALUES (3, 1, 2, 75.00, 50);\n```\n\nIf there are any additional details or updates required for the event in the `events` table, those would be handled separately based on specific requirements. However, since no changes to the existing event record are mentioned, this single insert statement is sufficient.", "latency_sec": 7.096123218536377, "total_duration_sec": 6.844767608, "load_duration_sec": 0.02083132, "tokens_prompt": 956, "prompt_eval_sec": 0.369737541, "tokens_completion": 275, "completion_eval_sec": 6.446840429, "tokens_total": 1231, "tokens_per_sec": 173.4750034757573, "retrieval_latency_sec": 0.09624195098876953, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL inserts two rows into the tickets table and an additional row into the events table, while the Generated SQL only inserts a single row into the tickets table. The tickets data also differs: the Generated SQL uses ticket_id 3 with salesperson_id 1, whereas the Reference SQL includes two distinct ticket entries with different salesperson_ids and prices. The events insertion in the Reference SQL is also absent in the Generated SQL."}
{"example_id": 3925, "sql_complexity": "set operations", "prompt": "What is the total number of students and staff with accommodations in the \"disability_services\" schema, excluding the \"accessibility_parking\" type?", "context": "CREATE SCHEMA disability_services; CREATE TABLE staff (id INT, name VARCHAR(50), accommodation VARCHAR(50)); CREATE TABLE students (id INT, name VARCHAR(50), accommodation VARCHAR(50));", "reference_sql": "SELECT COUNT(*) FROM disability_services.staff WHERE accommodation != 'accessibility_parking' UNION SELECT COUNT(*) FROM disability_services.students WHERE accommodation != 'accessibility_parking';", "generated_sql": "SELECT SUM(cnt) AS total_count\nFROM (\n    SELECT COUNT(*) AS cnt FROM disability_services.staff WHERE accommodation != 'accessibility_parking'\n    UNION ALL\n    SELECT COUNT(*) AS cnt FROM disability_services.students WHERE accommodation != 'accessibility_parking'\n) subquery;", "raw_model_output": "To find the total number of students and staff with accommodations excluding the \"accessibility_parking\" type, you can use the following SQL query:\n\n```sql\nSELECT SUM(cnt) AS total_count\nFROM (\n    SELECT COUNT(*) AS cnt FROM disability_services.staff WHERE accommodation != 'accessibility_parking'\n    UNION ALL\n    SELECT COUNT(*) AS cnt FROM disability_services.students WHERE accommodation != 'accessibility_parking'\n) subquery;\n```\n\nThis query first counts the number of staff and students with accommodations excluding \"accessibility_parking\" in separate queries, then combines these counts using `UNION ALL`, and finally sums up the results to get the total count.", "latency_sec": 3.4910330772399902, "total_duration_sec": 3.388234183, "load_duration_sec": 0.016201099, "tokens_prompt": 625, "prompt_eval_sec": 0.282302431, "tokens_completion": 136, "completion_eval_sec": 3.085836691, "tokens_total": 761, "tokens_per_sec": 217.9870494385709, "retrieval_latency_sec": 0.10050773620605469, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate counts (staff and students) as individual rows with possible duplication removal via UNION, while the Generated SQL sums the two counts into a single total. The Reference SQL could return 1 or 2 rows depending on duplicate values, whereas the Generated SQL always returns a single row with the summed total. Their output structures and results differ."}
{"example_id": 3340, "sql_complexity": "subqueries", "prompt": "Calculate the total revenue for garments manufactured in the US and sold in California.", "context": "CREATE TABLE garment_manufacturing(id INT PRIMARY KEY, garment_id INT, country VARCHAR(50), material VARCHAR(50), manufacturing_date DATE, quantity INT); CREATE TABLE garment_sales(id INT PRIMARY KEY, garment_id INT, store_id INT, sale_date DATE, units INT, revenue DECIMAL(10,2));", "reference_sql": "SELECT SUM(gs.revenue) FROM garment_manufacturing gm JOIN garment_sales gs ON gm.garment_id = gs.garment_id WHERE gm.country = 'United States' AND gs.store_id IN (SELECT id FROM stores WHERE region = 'California');", "generated_sql": "SELECT SUM(garment_sales.revenue) AS total_revenue\nFROM garment_manufacturing\nJOIN garment_sales ON garment_manufacturing.garment_id = garment_sales.garment_id\nWHERE garment_manufacturing.country = 'US' AND garment_sales.store_id IN (\n    SELECT id FROM stores WHERE state = 'California'\n);", "raw_model_output": "To calculate the total revenue for garments manufactured in the US and sold in California, we need to join two tables (`garment_manufacturing` and `garment_sales`) on the `garment_id`, filter by the manufacturing country and sale location, and then sum up the revenue.\n\nHere is the SQL query:\n\n```sql\nSELECT SUM(garment_sales.revenue) AS total_revenue\nFROM garment_manufacturing\nJOIN garment_sales ON garment_manufacturing.garment_id = garment_sales.garment_id\nWHERE garment_manufacturing.country = 'US' AND garment_sales.store_id IN (\n    SELECT id FROM stores WHERE state = 'California'\n);\n```\n\nNote: The above query assumes there is a `stores` table with columns `id`, and `state`. If the schema does not include such a table, you would need to adjust the subquery accordingly or provide additional information about how store locations are stored.", "latency_sec": 4.938640117645264, "total_duration_sec": 4.855699452, "load_duration_sec": 0.015638214, "tokens_prompt": 933, "prompt_eval_sec": 0.366642196, "tokens_completion": 191, "completion_eval_sec": 4.469195887, "tokens_total": 1124, "tokens_per_sec": 227.59301613900985, "retrieval_latency_sec": 0.11172819137573242, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects: 1) The country condition uses 'United States' vs 'US' (different values), and 2) The subquery references 'region' vs 'state' columns in the stores table (assuming stores table exists with these columns). These differences would produce different results unless the database explicitly maps 'US' to 'United States' and 'region' to 'state', which is not indicated in the provided schema."}
{"example_id": 596, "sql_complexity": "basic SQL", "prompt": "What is the minimum energy production cost of wind farms in Spain?", "context": "CREATE TABLE wind_farm_costs (id INT, name TEXT, country TEXT, energy_production_cost FLOAT); INSERT INTO wind_farm_costs (id, name, country, energy_production_cost) VALUES (1, 'Las Tiesas', 'Spain', 0.045), (2, 'Eolo', 'Spain', 0.050);", "reference_sql": "SELECT MIN(energy_production_cost) FROM wind_farm_costs WHERE country = 'Spain';", "generated_sql": "SELECT MIN(energy_production_cost) AS min_cost \nFROM wind_farm_costs \nWHERE country = 'Spain';", "raw_model_output": "To find the minimum energy production cost of wind farms in Spain, you can use the following SQL query:\n\n```sql\nSELECT MIN(energy_production_cost) AS min_cost \nFROM wind_farm_costs \nWHERE country = 'Spain';\n```", "latency_sec": 1.7214789390563965, "total_duration_sec": 1.455315478, "load_duration_sec": 0.019761397, "tokens_prompt": 705, "prompt_eval_sec": 0.304011594, "tokens_completion": 49, "completion_eval_sec": 1.126848794, "tokens_total": 754, "tokens_per_sec": 437.9954833564761, "retrieval_latency_sec": 0.10755276679992676, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the minimum energy_production_cost for Spain. The generated query adds an alias (min_cost) to the result column, but this does not affect the semantic output. The WHERE clause and aggregate function are identical."}
{"example_id": 2604, "sql_complexity": "subqueries", "prompt": "What is the maximum number of virtual tours taken by a single user in the UK?", "context": "CREATE TABLE virtual_tour_data (user_id INT, hotel_id INT, tour_date DATE); INSERT INTO virtual_tour_data (user_id, hotel_id, tour_date) VALUES (1, 10, '2022-01-01'), (2, 11, '2022-01-03'), (3, 12, '2022-01-05'), (4, 10, '2022-01-07'), (5, 10, '2022-01-09'); CREATE TABLE hotels (hotel_id INT, hotel_name TEXT, country TEXT); INSERT INTO hotels (hotel_id, hotel_name, country) VALUES (10, 'Royal Park Hotel', 'UK'), (11, 'The Ritz London', 'UK'), (12, 'Hotel de Crillon', 'France');", "reference_sql": "SELECT MAX(vt.user_tours) FROM (SELECT user_id, COUNT(DISTINCT hotel_id) as user_tours FROM virtual_tour_data WHERE country = 'UK' GROUP BY user_id) as vt;", "generated_sql": "SELECT MAX(tour_count) AS max_tours_per_user\nFROM (\n    SELECT v.user_id, COUNT(v.tour_date) AS tour_count\n    FROM virtual_tour_data v\n    JOIN hotels h ON v.hotel_id = h.hotel_id\n    WHERE h.country = 'UK'\n    GROUP BY v.user_id\n) AS user_tour_counts;", "raw_model_output": "To find the maximum number of virtual tours taken by a single user in the UK, we need to follow these steps:\n\n1. Join the `virtual_tour_data` and `hotels` tables on the `hotel_id` column.\n2. Filter for hotels located in the UK.\n3. Group the data by `user_id`.\n4. Count the number of tours each user has taken.\n5. Find the maximum count.\n\nHere is the SQL query:\n\n```sql\nSELECT MAX(tour_count) AS max_tours_per_user\nFROM (\n    SELECT v.user_id, COUNT(v.tour_date) AS tour_count\n    FROM virtual_tour_data v\n    JOIN hotels h ON v.hotel_id = h.hotel_id\n    WHERE h.country = 'UK'\n    GROUP BY v.user_id\n) AS user_tour_counts;\n```", "latency_sec": 4.6752119064331055, "total_duration_sec": 4.443576331, "load_duration_sec": 0.023190902, "tokens_prompt": 874, "prompt_eval_sec": 0.351491952, "tokens_completion": 174, "completion_eval_sec": 4.060871925, "tokens_total": 1048, "tokens_per_sec": 224.1609623208627, "retrieval_latency_sec": 0.1064000129699707, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references a 'country' column that does not exist in the virtual_tour_data table, making it invalid. The Generated SQL correctly joins with the hotels table to filter by country, resulting in different semantics."}
{"example_id": 5812, "sql_complexity": "single join", "prompt": "Calculate the percentage of Shariah-compliant investments held by each investor in the top 5 countries with the highest percentage?", "context": "CREATE TABLE investors (investor_id INT, investor_name TEXT, country TEXT); INSERT INTO investors (investor_id, investor_name, country) VALUES (1, 'Al Thani', 'Qatar'), (2, 'Saudi Investment Group', 'Saudi Arabia'), (3, 'Temasek Holdings', 'Singapore'); CREATE TABLE investments (investment_id INT, investor_id INT, investment_type TEXT, investment_value DECIMAL, is_shariah_compliant BOOLEAN); INSERT INTO investments (investment_id, investor_id, investment_type, investment_value, is_shariah_compliant) VALUES (1, 1, 'Real Estate', 15000000, true), (2, 2, 'Stocks', 20000000, false);", "reference_sql": "SELECT investor_name, ROUND((SUM(CASE WHEN is_shariah_compliant THEN investment_value ELSE 0 END) / SUM(investment_value)) * 100, 2) AS percentage FROM investments JOIN investors ON investments.investor_id = investors.investor_id GROUP BY investor_name ORDER BY percentage DESC LIMIT 5;", "generated_sql": "WITH investor_shariah_percentage AS (\n    SELECT \n        i.investor_id, \n        i.country,\n        SUM(i1.is_shariah_compliant) * 100.0 / COUNT(*) AS shariah_percentage\n    FROM \n        investors i\n    JOIN \n        investments i1 ON i.investor_id = i1.investor_id\n    GROUP BY \n        i.investor_id, i.country\n),\ncountry_shariah_average AS (\n    SELECT \n        country,\n        AVG(shariah_percentage) AS avg_shariah_percentage\n    FROM \n        investor_shariah_percentage\n    GROUP BY \n        country\n),\ntop_countries AS (\n    SELECT \n        country\n    FROM \n        country_shariah_average\n    ORDER BY \n        avg_shariah_percentage DESC\n    LIMIT 5\n)\nSELECT \n    isp.investor_id, \n    isp.country,\n    isp.shariah_percentage\nFROM \n    investor_shariah_percentage isp\nJOIN \n    top_countries tc ON isp.country = tc.country;", "raw_model_output": "To calculate the percentage of Shariah-compliant investments held by each investor in the top 5 countries with the highest percentage, we need to follow these steps:\n\n1. Calculate the total number of investments and the number of Shariah-compliant investments for each investor.\n2. Compute the percentage of Shariah-compliant investments for each investor.\n3. Aggregate this data at the country level to find the average percentage of Shariah-compliant investments per country.\n4. Rank countries by their average percentage of Shariah-compliant investments and select the top 5 countries.\n5. Calculate the percentage of Shariah-compliant investments for each investor in these top 5 countries.\n\nHere is the SQL statement that accomplishes this:\n\n```sql\nWITH investor_shariah_percentage AS (\n    SELECT \n        i.investor_id, \n        i.country,\n        SUM(i1.is_shariah_compliant) * 100.0 / COUNT(*) AS shariah_percentage\n    FROM \n        investors i\n    JOIN \n        investments i1 ON i.investor_id = i1.investor_id\n    GROUP BY \n        i.investor_id, i.country\n),\ncountry_shariah_average AS (\n    SELECT \n        country,\n        AVG(shariah_percentage) AS avg_shariah_percentage\n    FROM \n        investor_shariah_percentage\n    GROUP BY \n        country\n),\ntop_countries AS (\n    SELECT \n        country\n    FROM \n        country_shariah_average\n    ORDER BY \n        avg_shariah_percentage DESC\n    LIMIT 5\n)\nSELECT \n    isp.investor_id, \n    isp.country,\n    isp.shariah_percentage\nFROM \n    investor_shariah_percentage isp\nJOIN \n    top_countries tc ON isp.country = tc.country;\n```\n\nThis SQL statement first calculates the percentage of Shariah-compliant investments for each investor in a CTE (`investor_shariah_percentage`). Then, it computes the average percentage per country in another CTE (`country_shariah_average`) and selects the top 5 countries based on this average. Finally, it retrieves the percentages of Shariah-compliant investments for investors from these top countries.", "latency_sec": 11.283164024353027, "total_duration_sec": 11.110550531, "load_duration_sec": 0.024750607, "tokens_prompt": 1168, "prompt_eval_sec": 0.561323006, "tokens_completion": 449, "completion_eval_sec": 10.51581582, "tokens_total": 1617, "tokens_per_sec": 143.3108653308546, "retrieval_latency_sec": 0.09807395935058594, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL calculates the percentage of investment value that is shariah-compliant per investor, while the Generated SQL calculates the percentage of shariah-compliant investments (by count) per investor, then averages this at the country level. Key differences: 1) Calculation method (value-based vs count-based), 2) Grouping (investor-level vs country-level), 3) Output structure (investor names with percentages vs investor-country pairs from top countries)."}
{"example_id": 4706, "sql_complexity": "multiple_joins", "prompt": "Who are the top 3 customers by total spend on makeup products from Italy and Spain?", "context": "CREATE TABLE customers (customer_id INT, customer_name TEXT, country TEXT); INSERT INTO customers (customer_id, customer_name, country) VALUES (1, 'Alessandro Martini', 'IT'), (2, 'Laura Rossi', 'ES'), (3, 'Daniela Gonzalez', 'MX'), (4, 'Jose Hernandez', 'ES'), (5, 'Sophia Rodriguez', 'IT'); CREATE TABLE sales (sale_id INT, customer_id INT, product_id INT, sale_quantity INT, sale_country TEXT); INSERT INTO sales (sale_id, customer_id, product_id, sale_quantity, sale_country) VALUES (1, 1, 1, 100, 'IT'), (2, 2, 2, 150, 'ES'), (3, 3, 3, 200, 'MX'), (4, 4, 4, 250, 'ES'), (5, 5, 5, 300, 'IT'); CREATE TABLE products (product_id INT, product_name TEXT, category TEXT); INSERT INTO products (product_id, product_name, category) VALUES (1, 'Eyeshadow Palette', 'makeup'), (2, 'Liquid Lipstick', 'makeup'), (3, 'BB Cream', 'makeup'), (4, 'Volumizing Mascara', 'makeup'), (5, 'Nourishing Lip Balm', 'makeup');", "reference_sql": "SELECT c.customer_name, SUM(s.sale_quantity) as total_spent_on_makeup FROM sales s JOIN customers c ON s.customer_id = c.customer_id JOIN products p ON s.product_id = p.product_id WHERE c.country IN ('IT', 'ES') AND p.category = 'makeup' GROUP BY c.customer_name ORDER BY total_spent_on_makeup DESC LIMIT 3;", "generated_sql": "SELECT c.customer_name, SUM(s.sale_quantity * p.product_price) AS total_spend\nFROM customers c\nJOIN sales s ON c.customer_id = s.customer_id\nJOIN products p ON s.product_id = p.product_id\nWHERE s.sale_country IN ('IT', 'ES')\nGROUP BY c.customer_id, c.customer_name\nORDER BY total_spend DESC\nLIMIT 3;", "raw_model_output": "To find the top 3 customers by total spend on makeup products from Italy and Spain, we need to join the `customers`, `sales`, and `products` tables. We will filter for sales in Italy and Spain and then group by customer to calculate the total spend per customer. Finally, we order the results by total spend in descending order and limit the output to the top 3 customers.\n\nHere is the SQL query:\n\n```sql\nSELECT c.customer_name, SUM(s.sale_quantity * p.product_price) AS total_spend\nFROM customers c\nJOIN sales s ON c.customer_id = s.customer_id\nJOIN products p ON s.product_id = p.product_id\nWHERE s.sale_country IN ('IT', 'ES')\nGROUP BY c.customer_id, c.customer_name\nORDER BY total_spend DESC\nLIMIT 3;\n```\n\nNote: The above query assumes that `product_price` is a column in the `products` table. If there's no such column and you need to calculate it from another source or if prices are stored elsewhere, please provide additional details for accurate calculation.", "latency_sec": 6.099321126937866, "total_duration_sec": 5.955835635, "load_duration_sec": 0.02225794, "tokens_prompt": 1405, "prompt_eval_sec": 0.634155254, "tokens_completion": 222, "completion_eval_sec": 5.29055019, "tokens_total": 1627, "tokens_per_sec": 266.7509983716544, "retrieval_latency_sec": 0.10636615753173828, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in multiple critical aspects. 1) The Reference SQL uses `c.country` while the Generated SQL uses `s.sale_country` in the WHERE clause, potentially filtering different data. 2) The Reference SQL sums `sale_quantity`, while the Generated SQL multiplies `sale_quantity` by `product_price` (a column not present in the provided schema, causing a syntax error). 3) The Generated SQL groups by both `customer_id` and `customer_name`, while the Reference SQL only groups by `customer_name`. These differences ensure the queries will not produce the same results."}
{"example_id": 1515, "sql_complexity": "multiple_joins", "prompt": "What is the average age of clients who lost cases in the 'personal injury' category?", "context": "CREATE TABLE Cases (CaseID int, ClientID int, Category varchar(50)); INSERT INTO Cases (CaseID, ClientID, Category) VALUES (701, 7, 'Personal Injury'); CREATE TABLE Clients (ClientID int, Age int, Gender varchar(10)); INSERT INTO Clients (ClientID, Age, Gender) VALUES (7, 45, 'Male'); CREATE TABLE CaseOutcomes (CaseID int, Outcome varchar(50)); INSERT INTO CaseOutcomes (CaseID, Outcome) VALUES (701, 'Lost');", "reference_sql": "SELECT AVG(C.Age) as AvgAge FROM Clients C INNER JOIN Cases CA ON C.ClientID = CA.ClientID INNER JOIN CaseOutcomes CO ON CA.CaseID = CO.CaseID WHERE CA.Category = 'Personal Injury' AND CO.Outcome = 'Lost';", "generated_sql": "SELECT AVG(Clients.Age) AS AvgAge \nFROM Clients \nJOIN Cases ON Clients.ClientID = Cases.ClientID \nJOIN CaseOutcomes ON Cases.CaseID = CaseOutcomes.CaseID \nWHERE Cases.Category = 'Personal Injury' AND CaseOutcomes.Outcome = 'Lost';", "raw_model_output": "```sql\nSELECT AVG(Clients.Age) AS AvgAge \nFROM Clients \nJOIN Cases ON Clients.ClientID = Cases.ClientID \nJOIN CaseOutcomes ON Cases.CaseID = CaseOutcomes.CaseID \nWHERE Cases.Category = 'Personal Injury' AND CaseOutcomes.Outcome = 'Lost';\n```", "latency_sec": 1.9389369487762451, "total_duration_sec": 1.818752585, "load_duration_sec": 0.017484162, "tokens_prompt": 747, "prompt_eval_sec": 0.313734312, "tokens_completion": 64, "completion_eval_sec": 1.483017161, "tokens_total": 811, "tokens_per_sec": 418.27043448311224, "retrieval_latency_sec": 0.09464192390441895, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average age of clients with 'Personal Injury' cases that resulted in 'Lost'. They use identical JOIN conditions (Clients.ClientID = Cases.ClientID and Cases.CaseID = CaseOutcomes.CaseID), same WHERE filters (Cases.Category = 'Personal Injury' and CaseOutcomes.Outcome = 'Lost'), and average the same column (Clients.Age). The only difference is aliasing/qualification of table names, which doesn't affect semantic meaning."}
{"example_id": 4388, "sql_complexity": "subqueries", "prompt": "Insert a new drug with a price 10% higher than the average price", "context": "CREATE TABLE drugs (drug_id INT, drug_name VARCHAR(50), price DECIMAL(10, 2)); INSERT INTO drugs (drug_id, drug_name, price) VALUES (1, 'DrugA', 50), (2, 'DrugB', 75), (3, 'DrugC', 100)", "reference_sql": "INSERT INTO drugs (drug_id, drug_name, price) VALUES ((SELECT MAX(drug_id) FROM drugs) + 1, 'DrugD', (SELECT AVG(price) * 1.1 FROM drugs))", "generated_sql": "INSERT INTO drugs (drug_name, price)\nVALUES ('NewDrug', (SELECT 1.1 * AVG(price) FROM drugs));", "raw_model_output": "To insert a new drug with a price that is 10% higher than the average price of existing drugs, you can use the following SQL statement:\n\n```sql\nINSERT INTO drugs (drug_name, price)\nVALUES ('NewDrug', (SELECT 1.1 * AVG(price) FROM drugs));\n```\n\nThis query calculates the average price of all existing drugs and then multiplies it by 1.1 to get a price that is 10% higher than the average. The new drug is inserted with this calculated price.", "latency_sec": 2.974722146987915, "total_duration_sec": 2.915696036, "load_duration_sec": 0.015533789, "tokens_prompt": 773, "prompt_eval_sec": 0.324497355, "tokens_completion": 109, "completion_eval_sec": 2.572008407, "tokens_total": 882, "tokens_per_sec": 296.4982799798892, "retrieval_latency_sec": 0.11404585838317871, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL explicitly sets drug_id as (MAX(drug_id) + 1) and uses 'DrugD' as the drug_name, while the Generated SQL omits drug_id (assuming auto-increment) and uses 'NewDrug' as the drug_name. Although both calculate price as 1.1\u00d7AVG(price), the drug_name and drug_id values differ, leading to different inserted data."}
{"example_id": 5431, "sql_complexity": "basic SQL", "prompt": "What is the average CO2 emission of ride-hailing vehicles in San Francisco?", "context": "CREATE TABLE SFRideHailing (id INT, company VARCHAR(20), co2_emission DECIMAL(5,2));", "reference_sql": "SELECT AVG(co2_emission) FROM SFRideHailing WHERE company = 'Uber';", "generated_sql": "SELECT AVG(co2_emission) FROM SFRideHailing;", "raw_model_output": "```sql\nSELECT AVG(co2_emission) FROM SFRideHailing;\n```", "latency_sec": 0.8161540031433105, "total_duration_sec": 0.725405119, "load_duration_sec": 0.01900443, "tokens_prompt": 580, "prompt_eval_sec": 0.278790527, "tokens_completion": 19, "completion_eval_sec": 0.424962521, "tokens_total": 599, "tokens_per_sec": 733.9301133034081, "retrieval_latency_sec": 0.1083526611328125, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query filters results to only include rows where company = 'Uber' before calculating the average, while the generated query calculates the average for all rows in the table without any filtering. This difference in filtering criteria means they will produce different results unless all rows in the table are already from Uber, which is not guaranteed by the schema."}
{"example_id": 3531, "sql_complexity": "single join", "prompt": "What is the total number of workouts and total workout time per user for users with a membership type of 'Basic'?", "context": "CREATE TABLE Members (id INT, user_name VARCHAR, membership_type VARCHAR, signup_date DATE); CREATE TABLE Workouts (id INT, user_id INT, workout_date DATE, workout_duration INT); INSERT INTO Members (id, user_name, membership_type, signup_date) VALUES (1, 'John Doe', 'Premium', '2020-01-01'), (2, 'Jane Smith', 'Basic', '2019-06-15'), (3, 'Alice Johnson', 'Premium', '2020-03-20'); INSERT INTO Workouts (id, user_id, workout_date, workout_duration) VALUES (1, 1, '2020-01-01', 60), (2, 1, '2020-01-02', 70), (3, 2, '2019-06-15', 90), (4, 3, '2020-03-20', 65), (5, 3, '2020-03-21', 70);", "reference_sql": "SELECT Members.user_name, SUM(Workouts.workout_duration) AS total_workout_time, COUNT(Workouts.id) AS total_workouts FROM Members JOIN Workouts ON Members.id = Workouts.user_id WHERE Members.membership_type = 'Basic' GROUP BY Members.user_name;", "generated_sql": "SELECT m.user_name, COUNT(w.id) AS total_workouts, SUM(w.workout_duration) AS total_workout_time\nFROM Members m\nJOIN Workouts w ON m.id = w.user_id\nWHERE m.membership_type = 'Basic'\nGROUP BY m.user_name;", "raw_model_output": "To find the total number of workouts and total workout time per user for users with a membership type of 'Basic', you can use the following SQL query:\n\n```sql\nSELECT m.user_name, COUNT(w.id) AS total_workouts, SUM(w.workout_duration) AS total_workout_time\nFROM Members m\nJOIN Workouts w ON m.id = w.user_id\nWHERE m.membership_type = 'Basic'\nGROUP BY m.user_name;\n```", "latency_sec": 3.022979974746704, "total_duration_sec": 2.696797533, "load_duration_sec": 0.01414705, "tokens_prompt": 1121, "prompt_eval_sec": 0.541355936, "tokens_completion": 93, "completion_eval_sec": 2.136718798, "tokens_total": 1214, "tokens_per_sec": 401.59048691737405, "retrieval_latency_sec": 0.10965418815612793, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same data by joining Members and Workouts tables on user_id, filtering for 'Basic' membership type, and grouping by user_name. The generated query uses table aliases (m/w) and swaps the order of COUNT and SUM in the SELECT clause, but these are syntactic variations that do not affect the semantic result."}
{"example_id": 5678, "sql_complexity": "set operations", "prompt": "How many public works projects are there in 'Sydney' and 'Melbourne' combined?", "context": "CREATE TABLE PublicWorksC(id INT, city VARCHAR(20), project VARCHAR(30)); INSERT INTO PublicWorksC(id, city, project) VALUES (1, 'Sydney', 'Park Renovation'), (2, 'Melbourne', 'Sidewalk Repair');", "reference_sql": "SELECT COUNT(*) FROM (SELECT city FROM PublicWorksC WHERE city = 'Sydney' UNION ALL SELECT city FROM PublicWorksC WHERE city = 'Melbourne') AS Total;", "generated_sql": "SELECT COUNT(*) AS TotalProjects \nFROM PublicWorksC \nWHERE city IN ('Sydney', 'Melbourne');", "raw_model_output": "To find the total number of public works projects in both 'Sydney' and 'Melbourne', you can use a `COUNT` function combined with a `WHERE` clause to filter by these cities. Here is the corresponding SQL query:\n\n```sql\nSELECT COUNT(*) AS TotalProjects \nFROM PublicWorksC \nWHERE city IN ('Sydney', 'Melbourne');\n```", "latency_sec": 2.1975951194763184, "total_duration_sec": 2.07007607, "load_duration_sec": 0.014295416, "tokens_prompt": 744, "prompt_eval_sec": 0.303148054, "tokens_completion": 76, "completion_eval_sec": 1.749280812, "tokens_total": 820, "tokens_per_sec": 373.1351570326585, "retrieval_latency_sec": 0.11506414413452148, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the total number of rows where the city is either 'Sydney' or 'Melbourne'. The Reference SQL uses a UNION ALL to combine results from two subqueries (which preserves duplicates) and then counts them. The Generated SQL directly filters rows with city IN ('Sydney', 'Melbourne') and counts them. Since both approaches count all matching rows (including duplicates), they produce the same result."}
{"example_id": 5792, "sql_complexity": "multiple_joins", "prompt": "How many cases were handled by attorneys in the 'Los Angeles' office?", "context": "CREATE TABLE offices (office_id INT, office_name VARCHAR(20), city VARCHAR(20), state VARCHAR(20)); INSERT INTO offices (office_id, office_name, city, state) VALUES (1, 'Boston', 'Boston', 'MA'), (2, 'New York', 'New York', 'NY'), (3, 'Los Angeles', 'Los Angeles', 'CA'); CREATE TABLE attorneys (attorney_id INT, office_id INT); INSERT INTO attorneys (attorney_id, office_id) VALUES (1, 1), (2, 2), (3, 3); CREATE TABLE cases (case_id INT, attorney_id INT); INSERT INTO cases (case_id, attorney_id) VALUES (1, 1), (2, 2), (3, 3);", "reference_sql": "SELECT COUNT(*) FROM cases JOIN attorneys ON cases.attorney_id = attorneys.attorney_id JOIN offices ON attorneys.office_id = offices.office_id WHERE offices.city = 'Los Angeles';", "generated_sql": "SELECT COUNT(c.case_id) AS case_count\nFROM cases c\nJOIN attorneys a ON c.attorney_id = a.attorney_id\nJOIN offices o ON a.office_id = o.office_id\nWHERE o.office_name = 'Los Angeles';", "raw_model_output": "To find out how many cases were handled by attorneys in the 'Los Angeles' office, we need to join three tables: `cases`, `attorneys`, and `offices`. We will filter for the 'Los Angeles' office and then count the number of cases.\n\nHere is the SQL query:\n\n```sql\nSELECT COUNT(c.case_id) AS case_count\nFROM cases c\nJOIN attorneys a ON c.attorney_id = a.attorney_id\nJOIN offices o ON a.office_id = o.office_id\nWHERE o.office_name = 'Los Angeles';\n```\n\nThis query joins the `cases` table with the `attorneys` and `offices` tables to filter for the 'Los Angeles' office, then counts the number of cases handled by attorneys in that office.", "latency_sec": 4.379658937454224, "total_duration_sec": 4.062273412, "load_duration_sec": 0.015535401, "tokens_prompt": 895, "prompt_eval_sec": 0.349840007, "tokens_completion": 159, "completion_eval_sec": 3.692329625, "tokens_total": 1054, "tokens_per_sec": 240.65800900301645, "retrieval_latency_sec": 0.11652398109436035, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their WHERE clause conditions: the Reference SQL filters on 'offices.city = 'Los Angeles'', while the Generated SQL filters on 'offices.office_name = 'Los Angeles''. Although the sample data makes them produce the same result, semantically they are not equivalent because they check different columns. If an office's name differed from its city (e.g., 'LA Office' vs. 'Los Angeles'), the queries would yield different results."}
{"example_id": 5148, "sql_complexity": "window functions", "prompt": "List the unique types of smart city technologies that have been implemented in the top 3 most populous countries in the world.", "context": "CREATE TABLE smart_city_tech (tech_type VARCHAR(255), country VARCHAR(255)); CREATE TABLE country_populations (country VARCHAR(255), population INT);", "reference_sql": "SELECT DISTINCT tech_type FROM smart_city_tech SCT WHERE country IN (SELECT country FROM (SELECT country, ROW_NUMBER() OVER (ORDER BY population DESC) as rank FROM country_populations) CP WHERE rank <= 3);", "generated_sql": "WITH TopPopulousCountries AS (\n    SELECT country\n    FROM country_populations\n    ORDER BY population DESC\n    LIMIT 3\n)\nSELECT DISTINCT tech_type\nFROM smart_city_tech\nWHERE country IN (SELECT country FROM TopPopulousCountries);", "raw_model_output": "To list the unique types of smart city technologies that have been implemented in the top 3 most populous countries in the world, you can use the following SQL query:\n\n```sql\nWITH TopPopulousCountries AS (\n    SELECT country\n    FROM country_populations\n    ORDER BY population DESC\n    LIMIT 3\n)\nSELECT DISTINCT tech_type\nFROM smart_city_tech\nWHERE country IN (SELECT country FROM TopPopulousCountries);\n```\n\nThis query first identifies the top 3 most populous countries using a Common Table Expression (CTE) named `TopPopulousCountries`. Then, it selects distinct types of technologies from the `smart_city_tech` table where the country is one of those in the CTE.", "latency_sec": 3.8099207878112793, "total_duration_sec": 3.675769173, "load_duration_sec": 0.01455001, "tokens_prompt": 741, "prompt_eval_sec": 0.31159198, "tokens_completion": 147, "completion_eval_sec": 3.345416131, "tokens_total": 888, "tokens_per_sec": 233.07571192579508, "retrieval_latency_sec": 0.10844588279724121, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in how they select top populous countries. The Reference SQL uses ROW_NUMBER() to assign ranks and explicitly picks top 3, while the Generated SQL uses LIMIT 3. In cases of tied populations, ROW_NUMBER() ensures unique ranks but LIMIT 3 may return different results depending on database ordering, leading to potential discrepancies in country selection."}
{"example_id": 5547, "sql_complexity": "multiple_joins", "prompt": "Which species have a population growth rate higher than the average for protected areas?", "context": "CREATE TABLE species (id INT, name VARCHAR(50), population DECIMAL(5,2), protected_area_id INT, growth_rate DECIMAL(5,2)); INSERT INTO species (id, name, population, protected_area_id, growth_rate) VALUES (1, 'Species 1', 500.00, 1, 0.05), (2, 'Species 2', 800.00, 1, 0.03), (3, 'Species 3', 1200.00, 2, 0.07), (4, 'Species 4', 700.00, 2, 0.02); CREATE TABLE protected_areas (id INT, name VARCHAR(50)); INSERT INTO protected_areas (id, name) VALUES (1, 'Area 1'), (2, 'Area 2');", "reference_sql": "SELECT s.name, s.growth_rate FROM species s INNER JOIN protected_areas pa ON s.protected_area_id = pa.id GROUP BY s.name, s.growth_rate HAVING s.growth_rate > (SELECT AVG(s.growth_rate) FROM species s INNER JOIN protected_areas pa ON s.protected_area_id = pa.id);", "generated_sql": "SELECT s.name \nFROM species s\nJOIN (\n    SELECT pa.id AS area_id, AVG(s.growth_rate) AS avg_growth_rate\n    FROM protected_areas pa\n    JOIN species s ON pa.id = s.protected_area_id\n    GROUP BY pa.id\n) t ON s.protected_area_id = t.area_id\nWHERE s.growth_rate > t.avg_growth_rate;", "raw_model_output": "To find the species with a population growth rate higher than the average for their respective protected areas, we need to follow these steps:\n\n1. Calculate the average growth rate of all species in each protected area.\n2. Join this information back to the `species` table to filter out those species whose growth rates are above the average.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT s.name \nFROM species s\nJOIN (\n    SELECT pa.id AS area_id, AVG(s.growth_rate) AS avg_growth_rate\n    FROM protected_areas pa\n    JOIN species s ON pa.id = s.protected_area_id\n    GROUP BY pa.id\n) t ON s.protected_area_id = t.area_id\nWHERE s.growth_rate > t.avg_growth_rate;\n```\n\nThis query first calculates the average growth rate for each protected area and then filters out the species whose growth rates are higher than these averages.", "latency_sec": 4.97950005531311, "total_duration_sec": 4.921217441, "load_duration_sec": 0.022432313, "tokens_prompt": 1179, "prompt_eval_sec": 0.557335567, "tokens_completion": 188, "completion_eval_sec": 4.332026501, "tokens_total": 1367, "tokens_per_sec": 274.52555172510046, "retrieval_latency_sec": 0.0976099967956543, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL compares each species' growth rate to the overall average growth rate of all species, while the Generated SQL compares each species' growth rate to the average growth rate of its specific protected area. The HAVING clause in the Reference SQL uses a scalar subquery for the global average, whereas the Generated SQL uses a correlated subquery that calculates area-specific averages. This difference in aggregation logic leads to different results in general cases (e.g., a species in Area 1 with growth rate between 0.04 and 0.0425 would be excluded by the Reference SQL but included by the Generated SQL)."}
{"example_id": 5498, "sql_complexity": "aggregation", "prompt": "Identify the destinations with the highest number of repeat visitors from the US.", "context": "CREATE TABLE RepeatTravelers (Visitor VARCHAR(20), Destination VARCHAR(20), VisitCount INT); INSERT INTO RepeatTravelers (Visitor, Destination, VisitCount) VALUES ('David', 'Paris', 3), ('Ella', 'London', 4), ('Fiona', 'Paris', 2);", "reference_sql": "SELECT Destination, AVG(VisitCount) AS AvgVisitCount FROM RepeatTravelers WHERE Visitor LIKE '%USA%' GROUP BY Destination ORDER BY AvgVisitCount DESC;", "generated_sql": "CREATE TABLE Traveler (id INT PRIMARY KEY, name VARCHAR(20), nationality VARCHAR(50));\nCREATE TABLE Visitor (visitor_id INT, destination VARCHAR(20), visit_date DATE);", "raw_model_output": "To identify the destinations with the highest number of repeat visitors from the US, we need to assume there are related tables that contain information about travelers and their visits. Since the schema provided in the examples is different from the initial context, let's use a similar approach based on the given schema.\n\nAssuming there are `Traveler` and `Visitor` tables with relevant columns:\n\n```sql\nCREATE TABLE Traveler (id INT PRIMARY KEY, name VARCHAR(20), nationality VARCHAR(50));\nCREATE TABLE Visitor (visitor_id INT, destination VARCHAR(20), visit_date DATE);\n```\n\nWe can write the following SQL query to find destinations visited by repeat US travelers:\n\n```sql\nSELECT v.destination, COUNT(v.visitor_id) AS visitor_count\nFROM (\n    SELECT visitor_id, destination\n    FROM Visitor v\n    JOIN Traveler t ON v.visitor_id = t.id\n    WHERE t.nationality = 'United States'\n    GROUP BY visitor_id, destination\n    HAVING COUNT(*) > 1\n) v\nGROUP BY v.destination\nORDER BY visitor_count DESC;\n```\n\nThis query first identifies US travelers who have visited a particular destination more than once and then counts the number of such repeat visits for each destination.", "latency_sec": 6.345012903213501, "total_duration_sec": 6.24314539, "load_duration_sec": 0.01708089, "tokens_prompt": 856, "prompt_eval_sec": 0.342398803, "tokens_completion": 254, "completion_eval_sec": 5.880473634, "tokens_total": 1110, "tokens_per_sec": 174.94054258547345, "retrieval_latency_sec": 0.10820984840393066, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL queries the 'RepeatTravelers' table with a specific structure (Visitor, Destination, VisitCount) while the Generated SQL defines entirely different tables ('Traveler' and 'Visitor') with unrelated columns. The Generated SQL does not contain any query logic to compare against the Reference SQL. The schemas and objectives of the two statements are incompatible."}
{"example_id": 3546, "sql_complexity": "window functions", "prompt": "What are the cryptocurrency exchanges with their corresponding blockchain companies, ranked by exchange ID in ascending order, for the Bitcoin platform?", "context": "CREATE TABLE cryptocurrency_exchanges (exchange_id INT, exchange_name VARCHAR(50), company_id INT); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (1, 'Binance', 1); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (2, 'Coinbase', 2); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (3, 'Kraken', 3); CREATE TABLE blockchain_companies (company_id INT, company_name VARCHAR(50), platform VARCHAR(50)); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (1, 'Binance', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (2, 'Blockstream', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (3, 'Blockchair', 'Bitcoin');", "reference_sql": "SELECT ce.exchange_name, bc.company_name, ce.exchange_id, ROW_NUMBER() OVER (PARTITION BY bc.platform ORDER BY ce.exchange_id ASC) as rank FROM cryptocurrency_exchanges ce JOIN blockchain_companies bc ON ce.company_id = bc.company_id WHERE bc.platform = 'Bitcoin';", "generated_sql": "SELECT ce.exchange_name, bc.company_name, ce.exchange_id \nFROM cryptocurrency_exchanges ce \nJOIN blockchain_companies bc ON ce.company_id = bc.company_id \nWHERE bc.platform = 'Bitcoin' \nORDER BY ce.exchange_id ASC;", "raw_model_output": "To retrieve the cryptocurrency exchanges with their corresponding blockchain companies and rank them by exchange ID in ascending order for the Bitcoin platform, you can use a `JOIN` operation between the `cryptocurrency_exchanges` and `blockchain_companies` tables. The query will filter the results to include only those companies on the Bitcoin platform.\n\nHere is the SQL statement:\n\n```sql\nSELECT ce.exchange_name, bc.company_name, ce.exchange_id \nFROM cryptocurrency_exchanges ce \nJOIN blockchain_companies bc ON ce.company_id = bc.company_id \nWHERE bc.platform = 'Bitcoin' \nORDER BY ce.exchange_id ASC;\n```\n\nThis query selects the exchange name and company name from the `cryptocurrency_exchanges` and `blockchain_companies` tables, respectively. It filters for companies on the Bitcoin platform and orders the results by exchange ID in ascending order.", "latency_sec": 4.724710702896118, "total_duration_sec": 4.494111007, "load_duration_sec": 0.018902658, "tokens_prompt": 1034, "prompt_eval_sec": 0.399017529, "tokens_completion": 172, "completion_eval_sec": 4.072822264, "tokens_total": 1206, "tokens_per_sec": 255.25372363238137, "retrieval_latency_sec": 0.10994696617126465, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a ROW_NUMBER() column in its output, which is absent in the Generated SQL. Additionally, the Generated SQL adds an ORDER BY clause not present in the Reference. While both queries join the same tables and filter on 'Bitcoin', the presence of an extra column and different ordering behavior makes them non-equivalent."}
{"example_id": 486, "sql_complexity": "single join", "prompt": "What is the average price of paintings from African artists in our collection?", "context": "CREATE TABLE Artworks (id INT, title VARCHAR(50), price DECIMAL(10,2), medium VARCHAR(50), artist_nationality VARCHAR(50)); CREATE TABLE Collections (id INT, name VARCHAR(50), continent VARCHAR(50));", "reference_sql": "SELECT AVG(Artworks.price) FROM Artworks INNER JOIN Collections ON Artworks.artist_nationality = Collections.continent WHERE Artworks.medium = 'Painting' AND Collections.continent = 'Africa';", "generated_sql": "SELECT AVG(price) AS AveragePrice \nFROM Artworks \nWHERE medium = 'Painting' AND artist_nationality = 'African';", "raw_model_output": "To find the average price of paintings from African artists in the collection, we need to filter the `Artworks` table based on the medium and artist's nationality. Here is the corresponding SQL query:\n\n```sql\nSELECT AVG(price) AS AveragePrice \nFROM Artworks \nWHERE medium = 'Painting' AND artist_nationality = 'African';\n```", "latency_sec": 2.3820998668670654, "total_duration_sec": 2.128339694, "load_duration_sec": 0.014344701, "tokens_prompt": 877, "prompt_eval_sec": 0.348915095, "tokens_completion": 74, "completion_eval_sec": 1.761746791, "tokens_total": 951, "tokens_per_sec": 399.22759462253526, "retrieval_latency_sec": 0.10892295837402344, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL joins Artworks with Collections on artist_nationality = continent and filters for Collections.continent = 'Africa', effectively requiring Artworks.artist_nationality to be 'Africa'. The Generated SQL directly filters Artworks.artist_nationality = 'African', which is a different value. Additionally, the Generated SQL omits the join with Collections, which may be critical for filtering. The conditions on the artist's nationality/continent are not equivalent."}
{"example_id": 794, "sql_complexity": "multiple_joins", "prompt": "Which suppliers have provided raw materials for the production of chemicals with high environmental impact?", "context": "CREATE TABLE suppliers (id INT, name TEXT); INSERT INTO suppliers (id, name) VALUES (1, 'Supplier1'), (2, 'Supplier2'), (3, 'Supplier3'); CREATE TABLE chemicals (id INT, name TEXT, environmental_impact INT); INSERT INTO chemicals (id, name, environmental_impact) VALUES (1, 'ChemA', 10), (2, 'ChemB', 20), (3, 'ChemC', 15); CREATE TABLE raw_materials (chemical_id INT, supplier_id INT); INSERT INTO raw_materials (chemical_id, supplier_id) VALUES (1, 1), (1, 2), (2, 3), (3, 1);", "reference_sql": "SELECT s.name FROM suppliers s INNER JOIN raw_materials rm ON s.id = rm.supplier_id INNER JOIN chemicals c ON rm.chemical_id = c.id WHERE c.environmental_impact > 10;", "generated_sql": "SELECT DISTINCT s.name \nFROM suppliers s\nJOIN raw_materials rm ON s.id = rm.supplier_id\nJOIN chemicals c ON rm.chemical_id = c.id\nWHERE c.environmental_impact > 15;", "raw_model_output": "To find which suppliers have provided raw materials for chemicals with high environmental impact, we need to join the `suppliers`, `raw_materials`, and `chemicals` tables. We will filter out chemicals that have a high environmental impact score (assuming \"high\" means an impact greater than 15).\n\nHere is the SQL query:\n\n```sql\nSELECT DISTINCT s.name \nFROM suppliers s\nJOIN raw_materials rm ON s.id = rm.supplier_id\nJOIN chemicals c ON rm.chemical_id = c.id\nWHERE c.environmental_impact > 15;\n```\n\nThis query retrieves distinct supplier names who have provided raw materials for chemicals with an environmental impact greater than 15.", "latency_sec": 3.9373059272766113, "total_duration_sec": 3.754250442, "load_duration_sec": 0.023828689, "tokens_prompt": 920, "prompt_eval_sec": 0.361015746, "tokens_completion": 143, "completion_eval_sec": 3.366355888, "tokens_total": 1063, "tokens_per_sec": 269.98156090331156, "retrieval_latency_sec": 0.11508417129516602, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their WHERE conditions (10 vs. 15) and the use of DISTINCT. The Reference query filters chemicals with environmental_impact > 10 (including ChemB (20) and ChemC (15)), while the Generated query filters >15 (only ChemB (20)). This results in different supplier sets: Reference returns Supplier1 (ChemC) and Supplier3 (ChemB), while Generated only returns Supplier3 (ChemB). The DISTINCT clause in Generated also affects potential duplicates but the core discrepancy is the environmental impact threshold."}
{"example_id": 3164, "sql_complexity": "set operations", "prompt": "What is the average age of patients who received therapy in 'clinic_a' and 'clinic_b'?", "context": "CREATE TABLE clinic_a (patient_id INT, age INT, therapy_received BOOLEAN); INSERT INTO clinic_a (patient_id, age, therapy_received) VALUES (1, 35, true), (2, 42, true), (3, 28, false); CREATE TABLE clinic_b (patient_id INT, age INT, therapy_received BOOLEAN); INSERT INTO clinic_b (patient_id, age, therapy_received) VALUES (4, 50, true), (5, 32, false), (6, 45, true);", "reference_sql": "SELECT AVG(age) FROM (SELECT age FROM clinic_a WHERE therapy_received = true UNION ALL SELECT age FROM clinic_b WHERE therapy_received = true) AS combined_clinics;", "generated_sql": "SELECT AVG(age) AS avg_age\nFROM (\n    SELECT age FROM clinic_a WHERE therapy_received = true\n    UNION ALL\n    SELECT age FROM clinic_b WHERE therapy_received = true\n) AS combined_therapy_patients;", "raw_model_output": "To calculate the average age of patients who received therapy in both 'clinic_a' and 'clinic_b', we need to filter for patients with `therapy_received` set to `true` in each table, union the results from both tables, and then compute the average age.\n\nHere is the corresponding SQL query:\n\n```sql\nSELECT AVG(age) AS avg_age\nFROM (\n    SELECT age FROM clinic_a WHERE therapy_received = true\n    UNION ALL\n    SELECT age FROM clinic_b WHERE therapy_received = true\n) AS combined_therapy_patients;\n```\n\nThis query first selects the ages of patients who received therapy from both clinics, combines these results using `UNION ALL`, and then calculates the average age.", "latency_sec": 3.742945909500122, "total_duration_sec": 3.714941266, "load_duration_sec": 0.025792973, "tokens_prompt": 756, "prompt_eval_sec": 0.32250251, "tokens_completion": 145, "completion_eval_sec": 3.360097355, "tokens_total": 901, "tokens_per_sec": 240.71948186938408, "retrieval_latency_sec": 0.10929489135742188, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average age of patients who received therapy by combining results from clinic_a and clinic_b using UNION ALL. The only difference is the alias name for the subquery (combined_clinics vs. combined_therapy_patients), which does not affect the semantic result."}
{"example_id": 3704, "sql_complexity": "aggregation", "prompt": "What is the total sales revenue for each category of garments in the South America region in Q1 2022?", "context": "CREATE TABLE sales_category (sale_id INT, garment_category VARCHAR(50), sale_date DATE, total_sales DECIMAL(10, 2), region VARCHAR(50));", "reference_sql": "SELECT garment_category, SUM(total_sales) FROM sales_category WHERE sale_date BETWEEN '2022-01-01' AND '2022-03-31' AND region = 'South America' GROUP BY garment_category;", "generated_sql": "SELECT garment_category, SUM(total_sales) AS total_revenue \nFROM sales_category \nWHERE region = 'South America' AND sale_date BETWEEN '2022-01-01' AND '2022-03-31'\nGROUP BY garment_category;", "raw_model_output": "```sql\nSELECT garment_category, SUM(total_sales) AS total_revenue \nFROM sales_category \nWHERE region = 'South America' AND sale_date BETWEEN '2022-01-01' AND '2022-03-31'\nGROUP BY garment_category;\n```", "latency_sec": 1.9618780612945557, "total_duration_sec": 1.857930624, "load_duration_sec": 0.016336244, "tokens_prompt": 837, "prompt_eval_sec": 0.34253198, "tokens_completion": 63, "completion_eval_sec": 1.493230361, "tokens_total": 900, "tokens_per_sec": 458.7441073713471, "retrieval_latency_sec": 0.11390376091003418, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (garment_category and SUM(total_sales)), apply identical WHERE conditions (region = 'South America' and sale_date between '2022-01-01' and '2022-03-31'), and group by the same column (garment_category). The generated query adds an alias (total_revenue) for the aggregated column, but this does not affect the semantic result. The order of conditions in the WHERE clause is irrelevant since AND is commutative."}
{"example_id": 2851, "sql_complexity": "single join", "prompt": "How many cases were handled by attorneys who joined the firm in 2015 or later?", "context": "CREATE TABLE attorneys (attorney_id INT, join_year INT); CREATE TABLE cases (case_id INT, attorney_id INT, billing_amount INT);", "reference_sql": "SELECT COUNT(DISTINCT cases.case_id) FROM cases INNER JOIN attorneys ON cases.attorney_id = attorneys.attorney_id WHERE attorneys.join_year >= 2015;", "generated_sql": "SELECT COUNT(case_id) \nFROM cases \nWHERE attorney_id IN (SELECT attorney_id FROM attorneys WHERE join_year >= 2015);", "raw_model_output": "```sql\nSELECT COUNT(case_id) \nFROM cases \nWHERE attorney_id IN (SELECT attorney_id FROM attorneys WHERE join_year >= 2015);\n```", "latency_sec": 1.5410959720611572, "total_duration_sec": 1.218372116, "load_duration_sec": 0.022227208, "tokens_prompt": 909, "prompt_eval_sec": 0.352480953, "tokens_completion": 34, "completion_eval_sec": 0.840542026, "tokens_total": 943, "tokens_per_sec": 611.9021898024777, "retrieval_latency_sec": 0.11148285865783691, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query uses COUNT(DISTINCT cases.case_id) while the generated query uses COUNT(case_id). If a case has multiple attorneys meeting the join_year condition, the generated query would count the same case_id multiple times, whereas the reference query would count it once. This difference in handling duplicates makes them non-equivalent."}
{"example_id": 3246, "sql_complexity": "single join", "prompt": "What is the average eco-friendliness score of accommodations in Oceania by year?", "context": "CREATE TABLE Accommodations (Accommodation_ID INT, Accommodation_Name VARCHAR(50), City VARCHAR(30), Country VARCHAR(50), Eco_Friendliness_Score INT, Visit_Year INT); INSERT INTO Accommodations (Accommodation_ID, Accommodation_Name, City, Country, Eco_Friendliness_Score, Visit_Year) VALUES (1, 'EcoLodge', 'Sydney', 'Australia', 85, 2019), (2, 'GreenHotel', 'Melbourne', 'Australia', 90, 2019), (3, 'SustainableResort', 'Auckland', 'New Zealand', 80, 2019), (4, 'EcoVilla', 'Wellington', 'New Zealand', 88, 2019); CREATE TABLE Countries (Country VARCHAR(50), Continent VARCHAR(30)); INSERT INTO Countries (Country, Continent) VALUES ('Australia', 'Oceania'), ('New Zealand', 'Oceania');", "reference_sql": "SELECT C.Continent, V.Visit_Year, AVG(A.Eco_Friendliness_Score) AS Avg_Eco_Score  FROM Accommodations A  JOIN Countries C  ON A.Country = C.Country  WHERE C.Continent = 'Oceania'  GROUP BY C.Continent, V.Visit_Year  ORDER BY V.Visit_Year;", "generated_sql": "SELECT a.Visit_Year, AVG(a.Eco_Friendliness_Score) AS Average_Eco_Friendliness_Score\nFROM Accommodations a\nJOIN Countries c ON a.Country = c.Country\nWHERE c.Continent = 'Oceania'\nGROUP BY a.Visit_Year;", "raw_model_output": "To find the average eco-friendliness score of accommodations in Oceania by year, we need to join the `Accommodations` and `Countries` tables on the `Country` column. Then, filter for countries in Oceania and group by the `Visit_Year`. Finally, calculate the average `Eco_Friendliness_Score` for each year.\n\nHere is the SQL query:\n\n```sql\nSELECT a.Visit_Year, AVG(a.Eco_Friendliness_Score) AS Average_Eco_Friendliness_Score\nFROM Accommodations a\nJOIN Countries c ON a.Country = c.Country\nWHERE c.Continent = 'Oceania'\nGROUP BY a.Visit_Year;\n```", "latency_sec": 4.152178049087524, "total_duration_sec": 3.918032168, "load_duration_sec": 0.022616345, "tokens_prompt": 985, "prompt_eval_sec": 0.383926099, "tokens_completion": 149, "completion_eval_sec": 3.506974574, "tokens_total": 1134, "tokens_per_sec": 273.10967559524715, "retrieval_latency_sec": 0.11300778388977051, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes 'Continent' in both SELECT and GROUP BY clauses, while the Generated SQL omits it. Although the WHERE clause restricts to 'Oceania', the output structure differs (extra column in Reference). Additionally, the Generated SQL lacks the ORDER BY clause present in the Reference. These differences in selected columns and ordering make them non-equivalent."}
{"example_id": 3056, "sql_complexity": "multiple_joins", "prompt": "Identify all suppliers who provide non-GMO ingredients to restaurants with Michelin stars.", "context": "CREATE TABLE Suppliers (id INT, name VARCHAR(50), isNonGMO BOOLEAN); CREATE TABLE Restaurants (id INT, name VARCHAR(50), numStars INT); CREATE TABLE Ingredients (supplierId INT, restaurantId INT, isNonGMO BOOLEAN);", "reference_sql": "SELECT Suppliers.name FROM Suppliers INNER JOIN Ingredients ON Suppliers.id = Ingredients.supplierId INNER JOIN Restaurants ON Ingredients.restaurantId = Restaurants.id WHERE Restaurants.numStars > 2 AND Ingredients.isNonGMO = TRUE;", "generated_sql": "SELECT DISTINCT S.id, S.name \nFROM Suppliers S\nJOIN Ingredients I ON S.id = I.supplierId\nJOIN Restaurants R ON R.id = I.restaurantId\nWHERE R.numStars >= 1 AND I.isNonGMO = true;", "raw_model_output": "To identify all suppliers who provide non-GMO ingredients to restaurants with Michelin stars, we need to join the `Suppliers`, `Restaurants`, and `Ingredients` tables. We will filter for restaurants that have at least one star (`numStars >= 1`) and ingredients that are non-GMO (`isNonGMO = true`). Finally, we can use a GROUP BY clause on the supplier ID to list all such suppliers.\n\nHere is the SQL query:\n\n```sql\nSELECT DISTINCT S.id, S.name \nFROM Suppliers S\nJOIN Ingredients I ON S.id = I.supplierId\nJOIN Restaurants R ON R.id = I.restaurantId\nWHERE R.numStars >= 1 AND I.isNonGMO = true;\n```\n\nThis query will return all suppliers who provide non-GMO ingredients to restaurants with at least one Michelin star.", "latency_sec": 4.398705959320068, "total_duration_sec": 4.340039534, "load_duration_sec": 0.009130559, "tokens_prompt": 793, "prompt_eval_sec": 0.31850169, "tokens_completion": 173, "completion_eval_sec": 4.009384452, "tokens_total": 966, "tokens_per_sec": 219.6100418927115, "retrieval_latency_sec": 0.10770201683044434, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in three key aspects: 1) The Reference query selects only 'Suppliers.name' while the Generated query selects 'S.id' and 'S.name' (different columns). 2) The WHERE clause in Reference uses 'numStars > 2' whereas Generated uses 'numStars >= 1' (different filtering conditions). 3) The Generated query includes 'DISTINCT' which the Reference does not, potentially affecting result uniqueness. These differences ensure they do not produce the same results."}
{"example_id": 264, "sql_complexity": "set operations", "prompt": "List the number of community health centers and infectious disease tracking facilities in 'southwest' regions.", "context": "CREATE TABLE centers (id INT, name TEXT, region TEXT); INSERT INTO centers (id, name, region) VALUES (1, 'Center A', 'southwest'); INSERT INTO centers (id, name, region) VALUES (2, 'Center B', 'northeast'); INSERT INTO centers (id, name, region) VALUES (3, 'Center C', 'northwest'); CREATE TABLE diseases (id INT, name TEXT, region TEXT); INSERT INTO diseases (id, name, region) VALUES (1, 'Disease A', 'southwest'); INSERT INTO diseases (id, name, region) VALUES (2, 'Disease B', 'southeast');", "reference_sql": "SELECT COUNT(*) FROM ( (SELECT * FROM centers WHERE region = 'southwest') UNION (SELECT * FROM diseases WHERE region = 'southwest') );", "generated_sql": "SELECT \n    (SELECT COUNT(*) FROM centers WHERE region = 'southwest') AS center_count,\n    (SELECT COUNT(*) FROM diseases WHERE region = 'southwest') AS disease_count;", "raw_model_output": "To list the number of community health centers and infectious disease tracking facilities in 'southwest' regions, we need to count entries from both `centers` and `diseases` tables where the region is 'southwest'. We can achieve this by using two separate COUNT functions with appropriate WHERE clauses.\n\nHere's the SQL query:\n\n```sql\nSELECT \n    (SELECT COUNT(*) FROM centers WHERE region = 'southwest') AS center_count,\n    (SELECT COUNT(*) FROM diseases WHERE region = 'southwest') AS disease_count;\n```\n\nThis query returns a single row with two columns: `center_count` and `disease_count`, representing the number of community health centers and infectious disease tracking facilities in the 'southwest' region, respectively.", "latency_sec": 4.249270915985107, "total_duration_sec": 3.954188981, "load_duration_sec": 0.008967829, "tokens_prompt": 917, "prompt_eval_sec": 0.361736105, "tokens_completion": 152, "completion_eval_sec": 3.580482098, "tokens_total": 1069, "tokens_per_sec": 251.57256883259325, "retrieval_latency_sec": 0.11094403266906738, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns a single count of all unique rows from both tables where region = 'southwest', while the Generated SQL returns two separate counts (one for centers and one for diseases). The Reference SQL's UNION combines results into a single count, whereas the Generated SQL provides separate counts for each table. The output structure and values would differ when there are rows in both tables."}
{"example_id": 2838, "sql_complexity": "basic SQL", "prompt": "What is the minimum safety rating of electric vehicles in the 'green_cars' table?", "context": "CREATE TABLE green_cars (id INT, make VARCHAR(50), model VARCHAR(50), type VARCHAR(50), safety_rating INT);", "reference_sql": "SELECT MIN(safety_rating) FROM green_cars WHERE type = 'Electric';", "generated_sql": "SELECT MIN(safety_rating) FROM green_cars WHERE type = 'electric';", "raw_model_output": "```sql\nSELECT MIN(safety_rating) FROM green_cars WHERE type = 'electric';\n```", "latency_sec": 0.8959689140319824, "total_duration_sec": 0.772445146, "load_duration_sec": 0.018122751, "tokens_prompt": 604, "prompt_eval_sec": 0.278673325, "tokens_completion": 21, "completion_eval_sec": 0.467819527, "tokens_total": 625, "tokens_per_sec": 697.5688444227542, "retrieval_latency_sec": 0.1090240478515625, "match_exact": true, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the case of the string literal in the WHERE clause ('Electric' vs 'electric'). SQL string comparisons are case-sensitive by default in most databases (e.g., PostgreSQL, MySQL with certain collations), so they would filter different sets of rows if the 'type' column contains values with exact case matching. This makes them semantically non-equivalent."}
{"example_id": 1187, "sql_complexity": "multiple_joins", "prompt": "Who are the top 3 authors with the highest number of articles published in The Guardian?", "context": "CREATE TABLE authors (id INT, name VARCHAR(100), publisher VARCHAR(50)); CREATE TABLE articles_authors (article_id INT, author_id INT); INSERT INTO authors (id, name, publisher) VALUES (1, 'Author1', 'The Guardian'), (2, 'Author2', 'The Guardian'), (3, 'Author3', 'The Guardian'); INSERT INTO articles_authors (article_id, author_id) VALUES (1, 1), (2, 2), (3, 1), (3, 2), (3, 3); INSERT INTO articles (id, title, publication_date, publisher) VALUES (1, 'Article1', '2021-01-01', 'The Guardian'), (2, 'Article2', '2021-01-02', 'The Guardian'), (3, 'Article3', '2021-01-03', 'The Guardian');", "reference_sql": "SELECT a.name, COUNT(aa.article_id) AS articles_count FROM authors a JOIN articles_authors aa ON a.id = aa.author_id JOIN articles ar ON aa.article_id = ar.id WHERE ar.publisher = 'The Guardian' GROUP BY a.name ORDER BY articles_count DESC LIMIT 3;", "generated_sql": "SELECT a.name AS author_name, COUNT(aa.article_id) AS article_count\nFROM authors a\nJOIN articles_authors aa ON a.id = aa.author_id\nJOIN articles ar ON aa.article_id = ar.id AND ar.publisher = 'The Guardian'\nGROUP BY a.name\nORDER BY article_count DESC\nLIMIT 3;", "raw_model_output": "To find the top 3 authors with the highest number of articles published in The Guardian, we need to join the `articles` and `authors` tables via the `articles_authors` table. Here is the corresponding SQL query:\n\n```sql\nSELECT a.name AS author_name, COUNT(aa.article_id) AS article_count\nFROM authors a\nJOIN articles_authors aa ON a.id = aa.author_id\nJOIN articles ar ON aa.article_id = ar.id AND ar.publisher = 'The Guardian'\nGROUP BY a.name\nORDER BY article_count DESC\nLIMIT 3;\n```", "latency_sec": 3.5197370052337646, "total_duration_sec": 3.254752227, "load_duration_sec": 0.015577543, "tokens_prompt": 1081, "prompt_eval_sec": 0.402886331, "tokens_completion": 118, "completion_eval_sec": 2.831644082, "tokens_total": 1199, "tokens_per_sec": 340.650451501665, "retrieval_latency_sec": 0.11371111869812012, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries produce the same result by joining authors with articles through articles_authors, counting articles per author, and filtering by 'The Guardian' publisher. The difference lies in where the publisher filter is applied (WHERE clause vs JOIN condition), but since both are inner joins and the filter condition is identical, the final result set remains the same."}
{"example_id": 360, "sql_complexity": "window functions", "prompt": "What is the change in crime rate for each category, between this year and last year, for the same time period?", "context": "CREATE TABLE CrimeStatistics (ID INT, CrimeType VARCHAR(50), Date TIMESTAMP, Count INT); INSERT INTO CrimeStatistics (ID, CrimeType, Date, Count) VALUES (1, 'Theft', '2022-01-01 00:00:00', 100), (2, 'Vandalism', '2022-01-01 00:00:00', 50), (3, 'Theft', '2022-01-02 00:00:00', 120), (4, 'Vandalism', '2022-01-02 00:00:00', 60), (5, 'Theft', '2021-01-01 00:00:00', 80), (6, 'Vandalism', '2021-01-01 00:00:00', 40), (7, 'Theft', '2021-01-02 00:00:00', 90), (8, 'Vandalism', '2021-01-02 00:00:00', 45);", "reference_sql": "SELECT CrimeType, (SUM(Count) OVER (PARTITION BY CrimeType ORDER BY EXTRACT(YEAR FROM Date) ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)) - SUM(Count) OVER (PARTITION BY CrimeType ORDER BY EXTRACT(YEAR FROM Date)) AS CrimeRateChange FROM CrimeStatistics WHERE Date BETWEEN DATE_TRUNC('year', CURRENT_DATE - INTERVAL '1 year') AND CURRENT_DATE;", "generated_sql": "SELECT \n    CrimeType,\n    SUM(CASE WHEN EXTRACT(YEAR FROM Date) = YEAR(CURRENT_DATE) THEN Count ELSE 0 END) AS ThisYearCount,\n    SUM(CASE WHEN EXTRACT(YEAR FROM Date) = YEAR(CURRENT_DATE) - 1 THEN Count ELSE 0 END) AS LastYearCount,\n    (SUM(CASE WHEN EXTRACT(YEAR FROM Date) = YEAR(CURRENT_DATE) THEN Count ELSE 0 END) -\n     SUM(CASE WHEN EXTRACT(YEAR FROM Date) = YEAR(CURRENT_DATE) - 1 THEN Count ELSE 0 END)) AS Change\nFROM \n    CrimeStatistics\nGROUP BY \n    CrimeType;", "raw_model_output": "To calculate the change in crime rate for each category between this year and last year for the same time period, we need to:\n\n1. Extract data for both years.\n2. Group by `CrimeType` and aggregate counts for each year separately.\n3. Calculate the difference in counts between the two years.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT \n    CrimeType,\n    SUM(CASE WHEN EXTRACT(YEAR FROM Date) = YEAR(CURRENT_DATE) THEN Count ELSE 0 END) AS ThisYearCount,\n    SUM(CASE WHEN EXTRACT(YEAR FROM Date) = YEAR(CURRENT_DATE) - 1 THEN Count ELSE 0 END) AS LastYearCount,\n    (SUM(CASE WHEN EXTRACT(YEAR FROM Date) = YEAR(CURRENT_DATE) THEN Count ELSE 0 END) -\n     SUM(CASE WHEN EXTRACT(YEAR FROM Date) = YEAR(CURRENT_DATE) - 1 THEN Count ELSE 0 END)) AS Change\nFROM \n    CrimeStatistics\nGROUP BY \n    CrimeType;\n```\n\nThis query uses conditional aggregation to sum the counts for each `CrimeType` in both this year and last year, then calculates the difference between these sums.", "latency_sec": 6.353100061416626, "total_duration_sec": 6.228215989, "load_duration_sec": 0.014213178, "tokens_prompt": 984, "prompt_eval_sec": 0.382256925, "tokens_completion": 249, "completion_eval_sec": 5.828932963, "tokens_total": 1233, "tokens_per_sec": 194.07847949510548, "retrieval_latency_sec": 0.11289215087890625, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL uses window functions to calculate a year-over-year change based on ordered rows, but its logic is flawed (e.g., subtracting cumulative sums). The Generated SQL aggregates counts for 'ThisYear' and 'LastYear' directly, which is more straightforward. Additionally, the Reference SQL includes a WHERE clause filtering dates to the last two years, while the Generated SQL lacks this filter, potentially including more data. The output columns also differ (e.g., CrimeRateChange vs. ThisYearCount/LastYearCount/Change)."}
{"example_id": 335, "sql_complexity": "single join", "prompt": "List the policy numbers, claim amounts, and claim dates for policies that have more than two claims and the total claim amount exceeds $5000", "context": "CREATE TABLE policies (policy_number INT);CREATE TABLE claims (claim_id INT, policy_number INT, claim_amount DECIMAL(10,2), claim_date DATE);", "reference_sql": "SELECT p.policy_number, c.claim_amount, c.claim_date FROM policies p INNER JOIN claims c ON p.policy_number = c.policy_number GROUP BY p.policy_number, c.claim_amount, c.claim_date HAVING COUNT(c.claim_id) > 2 AND SUM(c.claim_amount) > 5000;", "generated_sql": "SELECT c.policy_number, c.claim_amount, c.claim_date\nFROM claims c\nJOIN (\n    SELECT policy_number\n    FROM claims\n    GROUP BY policy_number\n    HAVING COUNT(*) > 2 AND SUM(claim_amount) > 5000\n) AS filtered_policies ON c.policy_number = filtered_policies.policy_number;", "raw_model_output": "To list the policy numbers, claim amounts, and claim dates for policies that have more than two claims and where the total claim amount exceeds $5000, you can use a combination of `GROUP BY`, `HAVING` clauses, and a subquery to filter based on the conditions. Here is the SQL statement:\n\n```sql\nSELECT c.policy_number, c.claim_amount, c.claim_date\nFROM claims c\nJOIN (\n    SELECT policy_number\n    FROM claims\n    GROUP BY policy_number\n    HAVING COUNT(*) > 2 AND SUM(claim_amount) > 5000\n) AS filtered_policies ON c.policy_number = filtered_policies.policy_number;\n```\n\nThis query first identifies the policies that meet the criteria (more than two claims and total claim amount exceeding $5000) using a subquery. Then, it joins this result with the `claims` table to retrieve the specific details of each claim for those policies.", "latency_sec": 5.244550943374634, "total_duration_sec": 5.213713896, "load_duration_sec": 0.020910543, "tokens_prompt": 1093, "prompt_eval_sec": 0.550458955, "tokens_completion": 200, "completion_eval_sec": 4.635542321, "tokens_total": 1293, "tokens_per_sec": 246.54160364929402, "retrieval_latency_sec": 0.09850788116455078, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their grouping and filtering logic. The reference query groups by policy_number, claim_amount, and claim_date, then checks if each group has >2 claims and sum >5000. The generated query first filters policies with >2 claims and sum >5000, then retrieves all claims for those policies. This means the generated query returns all claims for qualifying policies, while the reference query only returns claims (or groups of claims) that meet the HAVING conditions on their specific (policy, amount, date) combinations. The two approaches produce different result sets."}
{"example_id": 2866, "sql_complexity": "basic SQL", "prompt": "What is the number of hospitals in 'rural_healthcare' table?", "context": "CREATE TABLE rural_healthcare (name VARCHAR(255), type VARCHAR(255), location VARCHAR(255)); INSERT INTO rural_healthcare (name, type, location) VALUES ('Rural General Hospital', 'Hospital', 'Bushland'), ('Rural Community Hospital', 'Hospital', 'Forest Region');", "reference_sql": "SELECT COUNT(*) FROM rural_healthcare WHERE type = 'Hospital';", "generated_sql": "SELECT COUNT(*) \nFROM rural_healthcare \nWHERE type = 'Hospital';", "raw_model_output": "To find the number of hospitals in the `rural_healthcare` table, you can use the following SQL statement:\n\n```sql\nSELECT COUNT(*) \nFROM rural_healthcare \nWHERE type = 'Hospital';\n```\n\nThis query counts only the rows where the `type` column is 'Hospital'.", "latency_sec": 1.701653003692627, "total_duration_sec": 1.675595587, "load_duration_sec": 0.021110999, "tokens_prompt": 588, "prompt_eval_sec": 0.277897203, "tokens_completion": 61, "completion_eval_sec": 1.372911055, "tokens_total": 649, "tokens_per_sec": 381.3938556166591, "retrieval_latency_sec": 0.09491825103759766, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both count the number of rows in the 'rural_healthcare' table where the 'type' column equals 'Hospital'. The formatting differences (e.g., line breaks) do not affect semantic equivalence."}
{"example_id": 4440, "sql_complexity": "multiple_joins", "prompt": "What is the average session length for each game genre in the last month, sorted by average session length.", "context": "CREATE TABLE game_sessions(id INT, user_id INT, game_name VARCHAR(50), start_time DATETIME, end_time DATETIME); CREATE TABLE games(id INT, name VARCHAR(50), genre VARCHAR(50));", "reference_sql": "SELECT genres.genre, AVG(TIMESTAMPDIFF(SECOND, start_time, end_time)) as avg_session_length FROM game_sessions JOIN games ON game_sessions.game_name = games.name JOIN (SELECT DISTINCT game_name, genre FROM game_sessions JOIN games ON game_sessions.game_name = games.name) genres ON games.name = genres.game_name WHERE start_time >= DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH) GROUP BY genres.genre ORDER BY avg_session_length DESC;", "generated_sql": "SELECT g.genre, AVG(TIMESTAMPDIFF(SECOND, gs.start_time, gs.end_time)) AS avg_session_length\nFROM game_sessions gs\nJOIN games g ON gs.game_name = g.name\nWHERE gs.start_time >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH)\nGROUP BY g.genre\nORDER BY avg_session_length DESC;", "raw_model_output": "To find the average session length for each game genre in the last month, sorted by average session length, you can use the following SQL query:\n\n```sql\nSELECT g.genre, AVG(TIMESTAMPDIFF(SECOND, gs.start_time, gs.end_time)) AS avg_session_length\nFROM game_sessions gs\nJOIN games g ON gs.game_name = g.name\nWHERE gs.start_time >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH)\nGROUP BY g.genre\nORDER BY avg_session_length DESC;\n```", "latency_sec": 2.751720905303955, "total_duration_sec": 2.705522925, "load_duration_sec": 0.015484417, "tokens_prompt": 779, "prompt_eval_sec": 0.320808499, "tokens_completion": 102, "completion_eval_sec": 2.365229525, "tokens_total": 881, "tokens_per_sec": 320.1632833845425, "retrieval_latency_sec": 0.10905694961547852, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a subquery that selects distinct (game_name, genre) pairs and joins it with the main query, which may introduce unnecessary complexity and potential data filtering. The Generated SQL directly joins game_sessions with games and groups by genre without this subquery. If the games.name is not unique, the subquery in the Reference SQL could deduplicate game_name/genre pairs, leading to different averages compared to the Generated SQL, which might include duplicates. This discrepancy could result in different aggregation outcomes."}
{"example_id": 451, "sql_complexity": "single join", "prompt": "Which customers have made a transaction over 500 in the \"risk_management\" category?", "context": "CREATE TABLE customers (id INT, name VARCHAR(50), category VARCHAR(50)); INSERT INTO customers (id, name, category) VALUES (1, 'John Doe', 'risk_management'); INSERT INTO customers (id, name, category) VALUES (2, 'Jane Smith', 'compliance'); INSERT INTO customers (id, name, category) VALUES (3, 'Jim Brown', 'risk_management'); CREATE TABLE transactions (id INT, customer_id INT, amount DECIMAL(10, 2)); INSERT INTO transactions (id, customer_id, amount) VALUES (1, 1, 500.00); INSERT INTO transactions (id, customer_id, amount) VALUES (2, 1, 200.00); INSERT INTO transactions (id, customer_id, amount) VALUES (3, 2, 100.00); INSERT INTO transactions (id, customer_id, amount) VALUES (4, 3, 750.00);", "reference_sql": "SELECT c.name FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE c.category = 'risk_management' AND t.amount > 500;", "generated_sql": "SELECT DISTINCT c.name \nFROM customers c\nJOIN transactions t ON c.id = t.customer_id\nWHERE c.category = 'risk_management' AND t.amount > 500;", "raw_model_output": "To find which customers in the \"risk_management\" category have made a transaction over 500, you can use the following SQL query:\n\n```sql\nSELECT DISTINCT c.name \nFROM customers c\nJOIN transactions t ON c.id = t.customer_id\nWHERE c.category = 'risk_management' AND t.amount > 500;\n```\n\nThis query joins the `customers` and `transactions` tables on the customer ID, filters for customers in the \"risk_management\" category who have made a transaction over 500, and returns distinct names of such customers.", "latency_sec": 3.623400926589966, "total_duration_sec": 3.414588383, "load_duration_sec": 0.017833505, "tokens_prompt": 1294, "prompt_eval_sec": 0.600997442, "tokens_completion": 118, "completion_eval_sec": 2.790928664, "tokens_total": 1412, "tokens_per_sec": 389.6891424954327, "retrieval_latency_sec": 0.09942889213562012, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The generated query adds DISTINCT which ensures unique names, while the reference query may return duplicate names if a customer has multiple qualifying transactions. Although the sample data produces the same result, the DISTINCT clause changes the semantics for cases with multiple matching transactions per customer."}
{"example_id": 2879, "sql_complexity": "basic SQL", "prompt": "Update the FoodSafetyRecords.OrganicFarms table to include a new record for a certified organic farm in Kenya.", "context": "CREATE TABLE FoodSafetyRecords.OrganicFarms (farmName TEXT, country TEXT, certified BOOLEAN);", "reference_sql": "INSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('Ngong Organic Farm', 'Kenya', TRUE);", "generated_sql": "INSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('Green Acres Farm', 'Kenya', TRUE);", "raw_model_output": "INSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('Green Acres Farm', 'Kenya', TRUE);", "latency_sec": 1.0729620456695557, "total_duration_sec": 0.99229908, "load_duration_sec": 0.020056373, "tokens_prompt": 578, "prompt_eval_sec": 0.273862638, "tokens_completion": 31, "completion_eval_sec": 0.690681783, "tokens_total": 609, "tokens_per_sec": 567.5876443700005, "retrieval_latency_sec": 0.11817097663879395, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries insert different farm names ('Ngong Organic Farm' vs 'Green Acres Farm') into the same table, resulting in distinct records. While the structure and other values (country 'Kenya', certified TRUE) are identical, the semantic content differs due to the variation in farmName."}
{"example_id": 5688, "sql_complexity": "single join", "prompt": "What is the total amount donated to a specific cause?", "context": "CREATE TABLE causes (id INT, name TEXT); CREATE TABLE donations (id INT, donor_id INT, cause_id INT, donation_amount DECIMAL(10,2)); INSERT INTO causes (id, name) VALUES (1, 'Cause A'), (2, 'Cause B'); INSERT INTO donations (id, donor_id, cause_id, donation_amount) VALUES (1, 1, 1, 50.00), (2, 2, 1, 100.00);", "reference_sql": "SELECT SUM(donation_amount) FROM donations JOIN causes ON donations.cause_id = causes.id WHERE causes.name = 'Cause A';", "generated_sql": "SELECT c.name AS cause_name, SUM(d.donation_amount) AS total_donation_amount \nFROM donations d \nJOIN causes c ON d.cause_id = c.id \nWHERE c.id = <specific_cause_id> \nGROUP BY c.name;", "raw_model_output": "To find the total amount donated to a specific cause, you can use the following SQL query:\n\n```sql\nSELECT c.name AS cause_name, SUM(d.donation_amount) AS total_donation_amount \nFROM donations d \nJOIN causes c ON d.cause_id = c.id \nWHERE c.id = <specific_cause_id> \nGROUP BY c.name;\n```\n\nReplace `<specific_cause_id>` with the actual ID of the specific cause you are interested in. For example, if you want to find the total amount donated to 'Cause A' (which has an `id` of 1), the query would be:\n\n```sql\nSELECT c.name AS cause_name, SUM(d.donation_amount) AS total_donation_amount \nFROM donations d \nJOIN causes c ON d.cause_id = c.id \nWHERE c.id = 1 \nGROUP BY c.name;\n```", "latency_sec": 4.946589946746826, "total_duration_sec": 4.649398559, "load_duration_sec": 0.016484544, "tokens_prompt": 951, "prompt_eval_sec": 0.365561764, "tokens_completion": 180, "completion_eval_sec": 4.262989809, "tokens_total": 1131, "tokens_per_sec": 228.64236012605278, "retrieval_latency_sec": 0.10858798027038574, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL returns a single aggregated sum, while the Generated SQL returns a grouped result with cause names and total donations. Additionally, the Generated SQL uses a placeholder for cause ID instead of filtering by cause name, which could lead to different results if the ID doesn't correspond to 'Cause A'."}
{"example_id": 3273, "sql_complexity": "multiple_joins", "prompt": "List all departments, the number of chemicals they handle, and the number of machines used in their manufacturing processes.", "context": "CREATE TABLE Departments (DepartmentID INT, DepartmentName VARCHAR(20)); INSERT INTO Departments (DepartmentID, DepartmentName) VALUES (1, 'Manufacturing'), (2, 'Engineering'), (3, 'Chemical Safety'), (4, 'Product Development'); CREATE TABLE Chemicals (ChemicalID INT, ChemicalName VARCHAR(20), DepartmentID INT); INSERT INTO Chemicals (ChemicalID, ChemicalName, DepartmentID) VALUES (1, 'Hydrochloric Acid', 1), (2, 'Nitric Acid', 2), (3, 'Sodium Hydroxide', 3), (4, 'New Chemical', 4); CREATE TABLE Machinery (MachineID INT, MachineName VARCHAR(20), DepartmentID INT); INSERT INTO Machinery (MachineID, MachineName, DepartmentID) VALUES (1, 'Mixer 1', 1), (2, 'Cutter 2', 2), (3, 'Dispenser 3', 3), (4, 'Innovator 4', 4);", "reference_sql": "SELECT D.DepartmentName, COUNT(C.ChemicalID) AS ChemicalCount, COUNT(M.MachineID) AS MachineCount FROM Departments D LEFT JOIN Chemicals C ON D.DepartmentID = C.DepartmentID LEFT JOIN Machinery M ON D.DepartmentID = M.DepartmentID GROUP BY D.DepartmentName;", "generated_sql": "SELECT \n    d.DepartmentName,\n    COUNT(c.ChemicalID) AS NumberOfChemicals,\n    COUNT(m.MachineID) AS NumberOfMachines\nFROM \n    Departments d\nLEFT JOIN \n    Chemicals c ON d.DepartmentID = c.DepartmentID\nLEFT JOIN \n    Machinery m ON d.DepartmentID = m.DepartmentID\nGROUP BY \n    d.DepartmentName;", "raw_model_output": "To list all departments along with the number of chemicals they handle and the number of machines used in their manufacturing processes, we need to join the `Departments` table with both the `Chemicals` and `Machinery` tables. We then group by department and count the relevant items.\n\nHere is the SQL query:\n\n```sql\nSELECT \n    d.DepartmentName,\n    COUNT(c.ChemicalID) AS NumberOfChemicals,\n    COUNT(m.MachineID) AS NumberOfMachines\nFROM \n    Departments d\nLEFT JOIN \n    Chemicals c ON d.DepartmentID = c.DepartmentID\nLEFT JOIN \n    Machinery m ON d.DepartmentID = m.DepartmentID\nGROUP BY \n    d.DepartmentName;\n```", "latency_sec": 4.640974760055542, "total_duration_sec": 4.030977138, "load_duration_sec": 0.016037843, "tokens_prompt": 1256, "prompt_eval_sec": 0.58401057, "tokens_completion": 146, "completion_eval_sec": 3.425835641, "tokens_total": 1402, "tokens_per_sec": 302.0917097129874, "retrieval_latency_sec": 0.10309696197509766, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform the same operations: left joining Departments with Chemicals and Machinery on DepartmentID, then grouping by DepartmentName to count chemical and machine entries. The differences are purely syntactic (table aliases and column aliases) and do not affect the result set's content."}
{"example_id": 1895, "sql_complexity": "window functions", "prompt": "What is the average safety score of chemical production sites in the United States, partitioned by state and ranked in descending order?", "context": "CREATE TABLE production_sites (site_id INT, site_name TEXT, country TEXT, state TEXT, safety_score FLOAT); INSERT INTO production_sites (site_id, site_name, country, state, safety_score) VALUES (1, 'Site A', 'USA', 'NY', 92.5), (2, 'Site B', 'USA', 'CA', 87.4), (3, 'Site C', 'USA', 'TX', 95.3), (4, 'Site D', 'USA', 'FL', 89.2);", "reference_sql": "SELECT state, AVG(safety_score) as avg_safety_score, ROW_NUMBER() OVER (ORDER BY AVG(safety_score) DESC) as rank FROM production_sites WHERE country = 'USA' GROUP BY state ORDER BY rank;", "generated_sql": "SELECT state, AVG(safety_score) AS avg_safety_score \nFROM production_sites \nWHERE country = 'USA' \nGROUP BY state \nORDER BY avg_safety_score DESC;", "raw_model_output": "To find the average safety score of production sites in the United States partitioned by state and ranked in descending order:\n\n```sql\nSELECT state, AVG(safety_score) AS avg_safety_score \nFROM production_sites \nWHERE country = 'USA' \nGROUP BY state \nORDER BY avg_safety_score DESC;\n```", "latency_sec": 2.0725135803222656, "total_duration_sec": 1.972282563, "load_duration_sec": 0.025754422, "tokens_prompt": 910, "prompt_eval_sec": 0.363494408, "tokens_completion": 65, "completion_eval_sec": 1.579253035, "tokens_total": 975, "tokens_per_sec": 470.4432382288141, "retrieval_latency_sec": 0.10057282447814941, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a 'rank' column generated by ROW_NUMBER() and orders by this rank, while the Generated SQL only calculates the average safety score and orders by it directly. Although both queries group by state and filter for USA, the Reference SQL's additional ranking column and different ordering mechanism make the result sets structurally and semantically different."}
{"example_id": 4669, "sql_complexity": "set operations", "prompt": "Identify the number of IoT devices in each country and the total number of devices.", "context": "CREATE TABLE device_country (device_id INT, country TEXT); INSERT INTO device_country (device_id, country) VALUES (1, 'USA'), (2, 'Canada'), (3, 'Mexico'), (4, 'Brazil'); CREATE TABLE device_info (device_id INT, device_type TEXT); INSERT INTO device_info (device_id, device_type) VALUES (1, 'Soil Sensor'), (2, 'Temperature Sensor'), (3, 'Humidity Sensor'), (4, 'Precision Sprayer');", "reference_sql": "SELECT country, COUNT(*) AS device_count FROM device_country GROUP BY country UNION SELECT 'Total' AS country, COUNT(*) FROM device_country;", "generated_sql": "SELECT \n    dc.country,\n    COUNT(di.device_id) AS device_count\nFROM \n    device_country dc\nJOIN \n    device_info di ON dc.device_id = di.device_id\nGROUP BY \n    dc.country;\n\n-- To get the total number of devices:\nSELECT \n    SUM(device_count) AS total_device_count\nFROM (\n    SELECT \n        COUNT(di.device_id) AS device_count\n    FROM \n        device_country dc\n    JOIN \n        device_info di ON dc.device_id = di.device_id\n    GROUP BY \n        dc.country\n) subquery;", "raw_model_output": "To identify the number of IoT devices in each country and the total number of devices, we need to join the `device_country` and `device_info` tables on the `device_id` column. Then, we can use a combination of `GROUP BY` and aggregate functions like `COUNT`.\n\nHere is the SQL statement:\n\n```sql\nSELECT \n    dc.country,\n    COUNT(di.device_id) AS device_count\nFROM \n    device_country dc\nJOIN \n    device_info di ON dc.device_id = di.device_id\nGROUP BY \n    dc.country;\n\n-- To get the total number of devices:\nSELECT \n    SUM(device_count) AS total_device_count\nFROM (\n    SELECT \n        COUNT(di.device_id) AS device_count\n    FROM \n        device_country dc\n    JOIN \n        device_info di ON dc.device_id = di.device_id\n    GROUP BY \n        dc.country\n) subquery;\n```\n\nAlternatively, to get both the number of devices per country and the total in a single query:\n\n```sql\nWITH device_counts AS (\n    SELECT \n        dc.country,\n        COUNT(di.device_id) AS device_count\n    FROM \n        device_country dc\n    JOIN \n        device_info di ON dc.device_id = di.device_id\n    GROUP BY \n        dc.country\n)\nSELECT \n    country, \n    device_count,\n    (SELECT SUM(device_count) FROM device_counts) AS total_device_count\nFROM \n    device_counts;\n```", "latency_sec": 7.601214170455933, "total_duration_sec": 7.290775533, "load_duration_sec": 0.015650889, "tokens_prompt": 852, "prompt_eval_sec": 0.34098062, "tokens_completion": 298, "completion_eval_sec": 6.930293152, "tokens_total": 1150, "tokens_per_sec": 151.29161923495982, "retrieval_latency_sec": 0.12106084823608398, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns country-specific device counts and a 'Total' row from device_country, while the Generated SQL joins device_country with device_info (unnecessary for counting devices) and splits results into two separate queries. The first part of Generated SQL may produce same counts as Reference SQL's grouped results (if device_info has 1:1 mapping), but the second part sums those counts instead of directly counting all devices. Additionally, the output structure differs (single UNION query vs two separate queries)."}
{"example_id": 5302, "sql_complexity": "multiple_joins", "prompt": "Find the supplier with the lowest average delivery time for orders in the last month.", "context": "CREATE TABLE Suppliers (SupplierID int, SupplierName varchar(50)); CREATE TABLE Products (ProductID int, ProductName varchar(50), SupplierID int); CREATE TABLE Orders (OrderID int, ProductID int, OrderDate date, DeliveryTime int); INSERT INTO Suppliers VALUES (1, 'SupplierA'), (2, 'SupplierB'); INSERT INTO Products VALUES (1, 'Organic Apples', 1), (2, 'Bananas', 2); INSERT INTO Orders VALUES (1, 1, '2022-01-01', 2), (2, 2, '2022-01-03', 3);", "reference_sql": "SELECT SupplierName, AVG(DeliveryTime) as AvgDeliveryTime FROM Orders o JOIN Products p ON o.ProductID = p.ProductID JOIN Suppliers sp ON p.SupplierID = sp.SupplierID WHERE OrderDate >= DATEADD(month, -1, GETDATE()) GROUP BY SupplierName ORDER BY AvgDeliveryTime ASC;", "generated_sql": "SELECT s.SupplierID, s.SupplierName, AVG(o.DeliveryTime) AS AvgDeliveryTime\nFROM Orders o\nJOIN Products p ON o.ProductID = p.ProductID\nJOIN Suppliers s ON p.SupplierID = s.SupplierID\nWHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH)\nGROUP BY s.SupplierID, s.SupplierName\nORDER BY AvgDeliveryTime ASC\nLIMIT 1;", "raw_model_output": "To find the supplier with the lowest average delivery time for orders in the last month, we need to follow these steps:\n\n1. Filter the `Orders` table to include only those orders placed within the last month.\n2. Join the filtered `Orders` table with the `Products` and `Suppliers` tables to get the necessary information about suppliers.\n3. Calculate the average delivery time for each supplier.\n4. Find the supplier with the lowest average delivery time.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT s.SupplierID, s.SupplierName, AVG(o.DeliveryTime) AS AvgDeliveryTime\nFROM Orders o\nJOIN Products p ON o.ProductID = p.ProductID\nJOIN Suppliers s ON p.SupplierID = s.SupplierID\nWHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH)\nGROUP BY s.SupplierID, s.SupplierName\nORDER BY AvgDeliveryTime ASC\nLIMIT 1;\n```\n\nThis query filters orders placed in the last month, calculates the average delivery time for each supplier, and returns the supplier with the lowest average delivery time.", "latency_sec": 5.937105178833008, "total_duration_sec": 5.805205792, "load_duration_sec": 0.02123024, "tokens_prompt": 903, "prompt_eval_sec": 0.357892783, "tokens_completion": 231, "completion_eval_sec": 5.41932224, "tokens_total": 1134, "tokens_per_sec": 191.00217460235362, "retrieval_latency_sec": 0.09382295608520508, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Generated SQL includes an extra column (SupplierID) and a LIMIT 1 clause, which restricts output to a single row. Second, while both use similar date logic (last month filter), the functions (DATEADD/GETDATE vs DATE_SUB/CURDATE) may behave differently across databases. These differences in column selection, result set size, and date functions make the queries non-equivalent."}
{"example_id": 267, "sql_complexity": "subqueries", "prompt": "What is the total number of disability support programs offered in urban and rural areas, and the percentage of total programs for each area type?", "context": "CREATE TABLE programs (program_id INT, program_name VARCHAR(255), area_type VARCHAR(255));", "reference_sql": "SELECT area_type, COUNT(*) as total_programs, ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM programs) , 2) as percentage_of_total FROM programs WHERE area_type IN ('urban', 'rural') GROUP BY area_type;", "generated_sql": "SELECT \n    area_type,\n    COUNT(program_id) AS num_programs,\n    (COUNT(program_id) * 100.0 / SUM(COUNT(program_id)) OVER ()) AS percent_of_total\nFROM \n    programs\nWHERE \n    program_name LIKE '%disability%'\nGROUP BY \n    area_type;", "raw_model_output": "To find the total number of disability support programs offered in urban and rural areas, and the percentage of total programs for each area type, we can use the following SQL query:\n\n```sql\nSELECT \n    area_type,\n    COUNT(program_id) AS num_programs,\n    (COUNT(program_id) * 100.0 / SUM(COUNT(program_id)) OVER ()) AS percent_of_total\nFROM \n    programs\nWHERE \n    program_name LIKE '%disability%'\nGROUP BY \n    area_type;\n```\n\nThis query counts the number of disability support programs for each `area_type` and calculates the percentage of total programs offered in each area type. The `SUM(COUNT(program_id)) OVER ()` part computes the overall count of all disability support programs to calculate the percentage.", "latency_sec": 4.580743074417114, "total_duration_sec": 4.252334396, "load_duration_sec": 0.018357794, "tokens_prompt": 1031, "prompt_eval_sec": 0.403159564, "tokens_completion": 160, "completion_eval_sec": 3.82262403, "tokens_total": 1191, "tokens_per_sec": 260.0014846175478, "retrieval_latency_sec": 0.09037494659423828, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL filters by area_type ('urban'/'rural') and calculates percentages based on the total program count, while the Generated SQL filters by program_name containing 'disability' and uses a window function for percentages. The WHERE conditions, aggregation criteria, and percentage calculation methods differ, leading to different results."}
{"example_id": 3028, "sql_complexity": "basic SQL", "prompt": "What is the number of startups founded by non-binary individuals in the technology industry?", "context": "CREATE TABLE company (id INT, name TEXT, founder_gender TEXT, industry TEXT); INSERT INTO company (id, name, founder_gender, industry) VALUES (1, 'CodeForAll', 'Non-binary', 'Technology'); INSERT INTO company (id, name, founder_gender, industry) VALUES (2, 'TechVillage', 'Male', 'Technology');", "reference_sql": "SELECT COUNT(*) FROM company WHERE founder_gender = 'Non-binary' AND industry = 'Technology';", "generated_sql": "SELECT COUNT(*) FROM company WHERE founder_gender = 'Non-binary' AND industry = 'Technology';", "raw_model_output": "```sql\nSELECT COUNT(*) FROM company WHERE founder_gender = 'Non-binary' AND industry = 'Technology';\n```", "latency_sec": 1.0574872493743896, "total_duration_sec": 0.922434286, "load_duration_sec": 0.015740198, "tokens_prompt": 767, "prompt_eval_sec": 0.32130539, "tokens_completion": 24, "completion_eval_sec": 0.581224129, "tokens_total": 791, "tokens_per_sec": 747.9995626121793, "retrieval_latency_sec": 0.11280202865600586, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure and conditions. Both queries count rows from the 'company' table where founder_gender is 'Non-binary' and industry is 'Technology', producing the same result."}
{"example_id": 3282, "sql_complexity": "aggregation", "prompt": "Which marine species have been observed in both the Arctic and Antarctic oceans?", "context": "CREATE TABLE marine_species (id INT, species_name VARCHAR(50), common_name VARCHAR(50), region VARCHAR(20));INSERT INTO marine_species (id, species_name, common_name, region) VALUES (1, 'Orcinus_orca', 'Killer Whale', 'Arctic');INSERT INTO marine_species (id, species_name, common_name, region) VALUES (2, 'Balaenoptera_bonaerensis', 'Antarctic Minke Whale', 'Antarctic');", "reference_sql": "SELECT species_name FROM marine_species WHERE region IN ('Arctic', 'Antarctic') GROUP BY species_name HAVING COUNT(DISTINCT region) = 2;", "generated_sql": "SELECT species_name \nFROM marine_species \nWHERE region IN ('Arctic', 'Antarctic') \nGROUP BY species_name \nHAVING COUNT(DISTINCT region) = 2;", "raw_model_output": "```sql\nSELECT species_name \nFROM marine_species \nWHERE region IN ('Arctic', 'Antarctic') \nGROUP BY species_name \nHAVING COUNT(DISTINCT region) = 2;\n```", "latency_sec": 1.5605039596557617, "total_duration_sec": 1.480224596, "load_duration_sec": 0.013907152, "tokens_prompt": 979, "prompt_eval_sec": 0.384894896, "tokens_completion": 43, "completion_eval_sec": 1.076656033, "tokens_total": 1022, "tokens_per_sec": 654.9166336145968, "retrieval_latency_sec": 0.10934782028198242, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select species_name from marine_species where region is 'Arctic' or 'Antarctic', group by species_name, and filter with HAVING COUNT(DISTINCT region) = 2. Since they are exactly the same, they will produce identical results."}
{"example_id": 3474, "sql_complexity": "subqueries", "prompt": "What is the total transaction volume for the top 3 digital assets by market capitalization in the 'developed_markets' schema?", "context": "CREATE SCHEMA developed_markets; CREATE TABLE developed_markets.digital_assets (asset_name VARCHAR(10), market_cap BIGINT, daily_transaction_volume BIGINT); INSERT INTO developed_markets.digital_assets (asset_name, market_cap, daily_transaction_volume) VALUES ('AssetG', 30000000, 15000000), ('AssetH', 25000000, 12000000), ('AssetI', 20000000, 10000000), ('AssetJ', 15000000, 8000000), ('AssetK', 10000000, 6000000);", "reference_sql": "SELECT SUM(daily_transaction_volume) FROM (SELECT daily_transaction_volume FROM developed_markets.digital_assets ORDER BY market_cap DESC FETCH NEXT 3 ROWS ONLY) t;", "generated_sql": "SELECT SUM(daily_transaction_volume) AS total_transaction_volume\nFROM (\n    SELECT daily_transaction_volume\n    FROM developed_markets.digital_assets\n    ORDER BY market_cap DESC\n    FETCH NEXT 3 ROWS ONLY\n) t;", "raw_model_output": "To find the total transaction volume for the top 3 digital assets by market capitalization in the `developed_markets` schema, you can use a subquery to first identify these top assets and then sum their daily transaction volumes. Here is the corresponding SQL statement:\n\n```sql\nSELECT SUM(daily_transaction_volume) AS total_transaction_volume\nFROM (\n    SELECT daily_transaction_volume\n    FROM developed_markets.digital_assets\n    ORDER BY market_cap DESC\n    FETCH NEXT 3 ROWS ONLY\n) t;\n```\n\nThis query first orders the digital assets by their market capitalization in descending order and fetches the top 3 rows. Then, it sums up the `daily_transaction_volume` for these top 3 assets to get the total transaction volume.", "latency_sec": 4.371554851531982, "total_duration_sec": 4.177654257, "load_duration_sec": 0.018288993, "tokens_prompt": 1134, "prompt_eval_sec": 0.552304564, "tokens_completion": 155, "completion_eval_sec": 3.60265524, "tokens_total": 1289, "tokens_per_sec": 294.8607632243888, "retrieval_latency_sec": 0.11382722854614258, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of the top 3 daily_transaction_volume values from the digital_assets table ordered by market_cap descending. The only difference is the column alias in the outer SELECT (total_transaction_volume vs. implicit name), which doesn't affect the semantic result."}
{"example_id": 1626, "sql_complexity": "aggregation", "prompt": "Find the total value of social impact bonds issued by each organization.", "context": "CREATE TABLE social_impact_bonds (id INT, organization_name VARCHAR(255), issue_year INT, value FLOAT); INSERT INTO social_impact_bonds (id, organization_name, issue_year, value) VALUES (1, 'Acme Corp', 2018, 2000000), (2, 'XYZ Foundation', 2019, 3000000), (3, 'Global Giving', 2018, 1500000), (4, 'Acme Corp', 2019, 2500000), (5, 'XYZ Foundation', 2018, 1000000);", "reference_sql": "SELECT organization_name, SUM(value) as total_value FROM social_impact_bonds GROUP BY organization_name;", "generated_sql": "SELECT organization_name, SUM(value) AS total_value \nFROM social_impact_bonds \nGROUP BY organization_name;", "raw_model_output": "To find the total value of social impact bonds issued by each organization, you can use the following SQL query:\n\n```sql\nSELECT organization_name, SUM(value) AS total_value \nFROM social_impact_bonds \nGROUP BY organization_name;\n```", "latency_sec": 1.777069091796875, "total_duration_sec": 1.742158105, "load_duration_sec": 0.014986496, "tokens_prompt": 1144, "prompt_eval_sec": 0.553571601, "tokens_completion": 50, "completion_eval_sec": 1.16906743, "tokens_total": 1194, "tokens_per_sec": 671.8928405831945, "retrieval_latency_sec": 0.11649489402770996, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. They both select organization_name and sum the value column, grouping by organization_name. The only differences are formatting (line breaks and spacing) which do not affect semantic meaning."}
{"example_id": 1315, "sql_complexity": "single join", "prompt": "List all the transactions made by clients living in New York with a transaction amount greater than $1000.", "context": "CREATE TABLE transactions (id INT, client_id INT, transaction_amount DECIMAL(10,2), transaction_date DATE); INSERT INTO transactions (id, client_id, transaction_amount, transaction_date) VALUES (1, 3, 1500.00, '2022-01-01'), (2, 4, 800.00, '2022-01-02'), (3, 3, 1200.00, '2022-01-03'); CREATE TABLE clients (id INT, name VARCHAR(255), state VARCHAR(255)); INSERT INTO clients (id, name, state) VALUES (3, 'Mike Johnson', 'New York'), (4, 'Sara Lee', 'California');", "reference_sql": "SELECT transactions.id, transactions.client_id, transactions.transaction_amount, transactions.transaction_date FROM transactions INNER JOIN clients ON transactions.client_id = clients.id WHERE clients.state = 'New York' AND transactions.transaction_amount > 1000.00;", "generated_sql": "SELECT t.id, t.client_id, t.transaction_amount, t.transaction_date \nFROM transactions t\nINNER JOIN clients c ON t.client_id = c.id\nWHERE c.state = 'New York' AND t.transaction_amount > 1000;", "raw_model_output": "To list all the transactions made by clients living in New York with a transaction amount greater than $1000, you can use an INNER JOIN between the `transactions` and `clients` tables on the `client_id` column and filter based on the state and transaction amount criteria. Here is the SQL query:\n\n```sql\nSELECT t.id, t.client_id, t.transaction_amount, t.transaction_date \nFROM transactions t\nINNER JOIN clients c ON t.client_id = c.id\nWHERE c.state = 'New York' AND t.transaction_amount > 1000;\n```", "latency_sec": 3.407888174057007, "total_duration_sec": 3.226573786, "load_duration_sec": 0.014441962, "tokens_prompt": 963, "prompt_eval_sec": 0.378459424, "tokens_completion": 120, "completion_eval_sec": 2.829840477, "tokens_total": 1083, "tokens_per_sec": 317.79211778264283, "retrieval_latency_sec": 0.11788797378540039, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an INNER JOIN between transactions and clients tables on client_id, filter for clients in 'New York' and transactions over 1000. The generated query uses table aliases (t/c) instead of full table names, but this doesn't affect the result. The numeric comparison 1000.00 vs 1000 is equivalent in SQL."}
{"example_id": 520, "sql_complexity": "multiple_joins", "prompt": "What is the total number of electric vehicles sold in 'California' in the 'sales' schema?", "context": "CREATE TABLE sales_regions (id INT, name VARCHAR(50));   CREATE TABLE sales (id INT, region_id INT, vehicle_count INT);   CREATE TABLE vehicles (id INT, type VARCHAR(50));   INSERT INTO sales_regions VALUES (1, 'California');   INSERT INTO sales VALUES (1, 1, 5000);   INSERT INTO vehicles VALUES (1, 'electric');", "reference_sql": "SELECT SUM(sales.vehicle_count) FROM sales INNER JOIN sales_regions ON sales.region_id = sales_regions.id INNER JOIN vehicles ON sales.id = vehicles.id WHERE vehicles.type = 'electric' AND sales_regions.name = 'California';", "generated_sql": "SELECT SUM(sales.vehicle_count) \nFROM sales \nINNER JOIN sales_regions ON sales.region_id = sales_regions.id \nINNER JOIN vehicles ON sales.id = vehicles.id \nWHERE vehicles.type = 'electric' AND sales_regions.name = 'California';", "raw_model_output": "To find the total number of electric vehicles sold in \"California\", we need to join the `sales`, `sales_regions`, and `vehicles` tables, filter by the vehicle type being \"electric\" and the sales region name being \"California\", and then sum up the `vehicle_count`.\n\nHere is the SQL query:\n\n```sql\nSELECT SUM(sales.vehicle_count) \nFROM sales \nINNER JOIN sales_regions ON sales.region_id = sales_regions.id \nINNER JOIN vehicles ON sales.id = vehicles.id \nWHERE vehicles.type = 'electric' AND sales_regions.name = 'California';\n```", "latency_sec": 3.3184173107147217, "total_duration_sec": 3.08404734, "load_duration_sec": 0.015772146, "tokens_prompt": 760, "prompt_eval_sec": 0.31358979, "tokens_completion": 118, "completion_eval_sec": 2.750492801, "tokens_total": 878, "tokens_per_sec": 264.5839621090019, "retrieval_latency_sec": 0.11265301704406738, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure, join conditions, and WHERE clauses. They perform the same three-table join (sales, sales_regions, vehicles) with the same filtering conditions (vehicles.type = 'electric' and sales_regions.name = 'California') and calculate the same aggregate sum (SUM(sales.vehicle_count)). The formatting differences (e.g., line breaks, spacing) do not affect semantic equivalence."}
{"example_id": 3999, "sql_complexity": "single join", "prompt": "What is the total number of tickets sold for performances with a rating of 5?", "context": "CREATE TABLE performance (id INT PRIMARY KEY, name VARCHAR(255), date DATE, artist_id INT, rating INT); INSERT INTO performance (id, name, date, artist_id, rating) VALUES (1, 'Dance Recital', '2022-03-01', 1, 5);", "reference_sql": "SELECT SUM(t.quantity) as total_tickets_sold FROM performance p INNER JOIN ticket t ON p.id = t.performance_id WHERE p.rating = 5;", "generated_sql": "CREATE TABLE sales (id INT PRIMARY KEY, performance_id INT, tickets_sold INT);", "raw_model_output": "To find the total number of tickets sold for performances with a rating of 5, we need to assume that there is a column in the `performance` table or another related table that tracks ticket sales. Since no such column is mentioned in the provided schema, I will assume there is an additional table called `sales` which has a foreign key referencing the `performance.id`.\n\nLet's assume the following schema for the `sales` table:\n```sql\nCREATE TABLE sales (id INT PRIMARY KEY, performance_id INT, tickets_sold INT);\n```\n\nGiven this assumption, the SQL query to find the total number of tickets sold for performances with a rating of 5 would be:\n\n```sql\nSELECT SUM(s.tickets_sold) AS total_tickets_sold\nFROM performance p\nJOIN sales s ON p.id = s.performance_id\nWHERE p.rating = 5;\n```\n\nThis query joins the `performance` and `sales` tables on their respective IDs, filters for performances with a rating of 5, and sums up the tickets sold.", "latency_sec": 5.291956901550293, "total_duration_sec": 5.182121404, "load_duration_sec": 0.021183908, "tokens_prompt": 737, "prompt_eval_sec": 0.313444665, "tokens_completion": 210, "completion_eval_sec": 4.840729175, "tokens_total": 947, "tokens_per_sec": 178.95081490980658, "retrieval_latency_sec": 0.12440705299377441, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL is a SELECT query that calculates total tickets sold by joining 'performance' and 'ticket' tables with a rating filter, while the Generated SQL is a CREATE TABLE statement defining a 'sales' table structure. They serve entirely different purposes (querying data vs. defining schema) and cannot be semantically equivalent."}
{"example_id": 2261, "sql_complexity": "multiple_joins", "prompt": "What is the total number of animals that have been released into 'protected' habitats, and the average weight of those animals?", "context": "CREATE TABLE habitats (habitat_id INT, habitat_name VARCHAR(50), habitat_status VARCHAR(50)); INSERT INTO habitats (habitat_id, habitat_name, habitat_status) VALUES (1, 'Habitat A', 'protected'), (2, 'Habitat B', 'unprotected'); CREATE TABLE animal_habitats (animal_id INT, habitat_id INT, animal_weight FLOAT); INSERT INTO animal_habitats (animal_id, habitat_id, animal_weight) VALUES (101, 1, 25.5), (102, 2, 15.2); CREATE TABLE animals (animal_id INT, animal_name VARCHAR(50)); INSERT INTO animals (animal_id, animal_name) VALUES (101, 'Dog'), (102, 'Cat');", "reference_sql": "SELECT COUNT(*), AVG(animal_habitats.animal_weight) FROM animal_habitats INNER JOIN animals ON animal_habitats.animal_id = animals.animal_id INNER JOIN habitats ON animal_habitats.habitat_id = habitats.habitat_id WHERE habitats.habitat_status = 'protected';", "generated_sql": "SELECT COUNT(a.animal_id) AS total_animals, AVG(animal_weight) AS average_weight \nFROM animals a \nJOIN animal_habitats ah ON a.animal_id = ah.animal_id \nJOIN habitats h ON ah.habitat_id = h.habitat_id \nWHERE h.habitat_status = 'protected';", "raw_model_output": "```sql\nSELECT COUNT(a.animal_id) AS total_animals, AVG(animal_weight) AS average_weight \nFROM animals a \nJOIN animal_habitats ah ON a.animal_id = ah.animal_id \nJOIN habitats h ON ah.habitat_id = h.habitat_id \nWHERE h.habitat_status = 'protected';\n```", "latency_sec": 2.2652788162231445, "total_duration_sec": 2.188775937, "load_duration_sec": 0.017251636, "tokens_prompt": 1028, "prompt_eval_sec": 0.400423164, "tokens_completion": 73, "completion_eval_sec": 1.76676803, "tokens_total": 1101, "tokens_per_sec": 486.0328857158855, "retrieval_latency_sec": 0.11251592636108398, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform the same inner joins between animals, animal_habitats, and habitats tables, apply the same WHERE condition (habitats.habitat_status = 'protected'), and calculate the same aggregate functions (COUNT and AVG). The generated query uses table aliases and explicit column references, but the semantic meaning remains identical to the reference query."}
{"example_id": 3439, "sql_complexity": "multiple_joins", "prompt": "How many menu items contain ingredients sourced from local suppliers for each restaurant?", "context": "CREATE TABLE restaurants (id INT, name VARCHAR(50), location VARCHAR(50)); INSERT INTO restaurants VALUES (1, 'Restaurant A', 'City A'); INSERT INTO restaurants VALUES (2, 'Restaurant B', 'City B'); CREATE TABLE menu_items (id INT, name VARCHAR(50), restaurant_id INT, price DECIMAL(5,2)); INSERT INTO menu_items VALUES (1, 'Item A', 1, 10.99); INSERT INTO menu_items VALUES (2, 'Item B', 1, 12.99); INSERT INTO menu_items VALUES (3, 'Item C', 2, 11.99); CREATE TABLE ingredients (id INT, name VARCHAR(50), local_source BOOLEAN, menu_item_id INT); INSERT INTO ingredients VALUES (1, 'Ingredient A', TRUE, 1); INSERT INTO ingredients VALUES (2, 'Ingredient B', FALSE, 1); INSERT INTO ingredients VALUES (3, 'Ingredient C', TRUE, 2); INSERT INTO ingredients VALUES (4, 'Ingredient D', FALSE, 2); INSERT INTO ingredients VALUES (5, 'Ingredient E', TRUE, 3);", "reference_sql": "SELECT r.name, COUNT(DISTINCT mi.id) as num_local_items FROM restaurants r JOIN menu_items mi ON r.id = mi.restaurant_id JOIN ingredients i ON mi.id = i.menu_item_id WHERE i.local_source = TRUE GROUP BY r.name;", "generated_sql": "SELECT r.id AS restaurant_id, r.name AS restaurant_name, COUNT(DISTINCT m.id) AS local_menu_items_count\nFROM restaurants r\nJOIN menu_items m ON r.id = m.restaurant_id\nJOIN ingredients i ON m.id = i.menu_item_id AND i.local_source = TRUE\nGROUP BY r.id, r.name;", "raw_model_output": "To determine how many menu items contain ingredients sourced from local suppliers for each restaurant, we need to join three tables: `restaurants`, `menu_items`, and `ingredients`. We will filter the ingredients table to include only those that are locally sourced (`local_source = TRUE`) and then count the number of unique menu items per restaurant.\n\nHere is the SQL query:\n\n```sql\nSELECT r.id AS restaurant_id, r.name AS restaurant_name, COUNT(DISTINCT m.id) AS local_menu_items_count\nFROM restaurants r\nJOIN menu_items m ON r.id = m.restaurant_id\nJOIN ingredients i ON m.id = i.menu_item_id AND i.local_source = TRUE\nGROUP BY r.id, r.name;\n```", "latency_sec": 3.962045907974243, "total_duration_sec": 3.83282977, "load_duration_sec": 0.015688704, "tokens_prompt": 924, "prompt_eval_sec": 0.365208148, "tokens_completion": 145, "completion_eval_sec": 3.447559245, "tokens_total": 1069, "tokens_per_sec": 269.81009933490895, "retrieval_latency_sec": 0.10921597480773926, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in selected columns (Reference includes only 'name' and count, Generated includes 'id', 'name', and count) and grouping logic (Reference groups by 'r.name', Generated groups by 'r.id' and 'r.name'). The Generated query also moves the 'local_source = TRUE' condition to the JOIN, which doesn't affect the result but changes the execution plan. These differences in structure and grouping make them non-equivalent."}
{"example_id": 2265, "sql_complexity": "aggregation", "prompt": "Hourly revenue for a specific movie?", "context": "CREATE TABLE Movie_Revenue (id INT, movie_title VARCHAR(100), revenue_time TIME, revenue DECIMAL(10,2));", "reference_sql": "SELECT revenue_time, SUM(revenue) FROM Movie_Revenue WHERE movie_title = 'Spider-Man: No Way Home' GROUP BY revenue_time;", "generated_sql": "SELECT revenue_time AS Hour_of_Day, SUM(revenue) AS Total_Revenue \nFROM Movie_Revenue \nWHERE movie_title = 'Specific Movie Title' \nGROUP BY revenue_time;", "raw_model_output": "To retrieve the hourly revenue for a specific movie from the `Movie_Revenue` table, you can use the following SQL query:\n\n```sql\nSELECT revenue_time AS Hour_of_Day, SUM(revenue) AS Total_Revenue \nFROM Movie_Revenue \nWHERE movie_title = 'Specific Movie Title' \nGROUP BY revenue_time;\n```\n\nReplace `'Specific Movie Title'` with the actual title of the movie you are interested in. This query groups the data by `revenue_time` and calculates the total revenue for each hour of the day for that specific movie.", "latency_sec": 3.111830949783325, "total_duration_sec": 2.998058019, "load_duration_sec": 0.031711332, "tokens_prompt": 659, "prompt_eval_sec": 0.290218345, "tokens_completion": 116, "completion_eval_sec": 2.672289481, "tokens_total": 775, "tokens_per_sec": 249.04951859739128, "retrieval_latency_sec": 0.0994560718536377, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the WHERE clause condition (movie_title values 'Spider-Man: No Way Home' vs 'Specific Movie Title') and column aliases. While the structure and grouping are identical, the filter condition targets different movies, leading to potentially different results. Column aliases do not affect semantic equivalence."}
{"example_id": 1763, "sql_complexity": "multiple_joins", "prompt": "What is the total food and beverage revenue last month for hotels in 'Bangkok'?", "context": "CREATE TABLE revenue (hotel_id INT, revenue_source VARCHAR(50), revenue INT, revenue_date DATE); INSERT INTO revenue (hotel_id, revenue_source, revenue, revenue_date) VALUES (5, 'Room revenue', 12000, '2022-03-01'), (5, 'Food and beverage', 4000, '2022-03-02'), (5, 'Other revenue', 1000, '2022-03-03'); CREATE TABLE hotels (hotel_id INT, city VARCHAR(50)); INSERT INTO hotels (hotel_id, city) VALUES (5, 'Bangkok'); CREATE TABLE dates (date DATE); INSERT INTO dates (date) VALUES ('2022-03-01'), ('2022-03-02'), ('2022-03-03');", "reference_sql": "SELECT SUM(revenue) FROM revenue JOIN hotels ON revenue.hotel_id = hotels.hotel_id JOIN dates ON revenue.revenue_date = dates.date WHERE hotels.city = 'Bangkok' AND revenue_source = 'Food and beverage' AND dates.date >= DATEADD(month, -1, GETDATE());", "generated_sql": "SELECT SUM(revenue) AS total_food_and_beverage_revenue\nFROM revenue r\nJOIN hotels h ON r.hotel_id = h.hotel_id\nWHERE r.revenue_source = 'Food and beverage'\nAND h.city = 'Bangkok'\nAND r.revenue_date >= CURRENT_DATE - INTERVAL '1 MONTH';", "raw_model_output": "To find the total food and beverage revenue for hotels in 'Bangkok' last month, we need to follow these steps:\n\n1. Identify the relevant rows from the `revenue` table where `revenue_source` is 'Food and beverage'.\n2. Filter by hotel_id that corresponds to a hotel in 'Bangkok'.\n3. Ensure the date falls within the past month.\n4. Sum up the revenue for those filtered records.\n\nHere's the SQL query:\n\n```sql\nSELECT SUM(revenue) AS total_food_and_beverage_revenue\nFROM revenue r\nJOIN hotels h ON r.hotel_id = h.hotel_id\nWHERE r.revenue_source = 'Food and beverage'\nAND h.city = 'Bangkok'\nAND r.revenue_date >= CURRENT_DATE - INTERVAL '1 MONTH';\n```", "latency_sec": 4.658198118209839, "total_duration_sec": 4.363293059, "load_duration_sec": 0.020252157, "tokens_prompt": 1125, "prompt_eval_sec": 0.549135976, "tokens_completion": 165, "completion_eval_sec": 3.786110067, "tokens_total": 1290, "tokens_per_sec": 276.93111526474775, "retrieval_latency_sec": 0.11353087425231934, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of 'Food and beverage' revenue for hotels in Bangkok where the revenue date is within the last month. The reference query joins with the 'dates' table but uses a condition on dates.date that is equivalent to checking revenue.revenue_date directly. The generated query omits the redundant 'dates' join and uses the same date calculation logic (CURRENT_DATE - INTERVAL '1 MONTH' vs DATEADD(month, -1, GETDATE())). Since the 'dates' table is not required for filtering revenue dates in this case, the queries are semantically equivalent."}
{"example_id": 5499, "sql_complexity": "set operations", "prompt": "How many legal aid clinics and community mediation centers are there in total, and what is the sum of cases handled by each type of center, for centers located in the state of California?", "context": "CREATE TABLE LegalAidClinics (ClinicName text, State text, NumCases int); INSERT INTO LegalAidClinics VALUES ('Clinic1', 'CA', 30, '2022-01-01'), ('Clinic2', 'CA', 25, '2022-01-01'); CREATE TABLE CommunityMediationCenters (CenterName text, State text, NumCases int); INSERT INTO CommunityMediationCenters VALUES ('CM1', 'CA', 22, '2022-01-01'), ('CM2', 'CA', 28, '2022-01-01');", "reference_sql": "SELECT State, 'Legal Aid Clinics' AS CenterType, COUNT(*) AS NumCenters, SUM(NumCases) AS TotalCases FROM LegalAidClinics WHERE State = 'CA' UNION ALL SELECT State, 'Community Mediation Centers', COUNT(*), SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA';", "generated_sql": "SELECT 'Legal Aid Clinics' AS CenterType, COUNT(*) AS NumCenters, SUM(NumCases) AS TotalCases FROM LegalAidClinics WHERE State = 'CA'\nUNION ALL\nSELECT 'Community Mediation Centers', COUNT(*), SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA';", "raw_model_output": "To answer the question, we need to calculate the total number of legal aid clinics and community mediation centers in California along with the sum of cases handled by each type of center. We can achieve this using two separate queries for each table and then combine them.\n\nHere is the SQL statement:\n\n```sql\nSELECT 'Legal Aid Clinics' AS CenterType, COUNT(*) AS NumCenters, SUM(NumCases) AS TotalCases FROM LegalAidClinics WHERE State = 'CA'\nUNION ALL\nSELECT 'Community Mediation Centers', COUNT(*), SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA';\n```\n\nThis SQL statement will return the number of centers and total cases for each type in California.", "latency_sec": 4.162862777709961, "total_duration_sec": 4.113312907, "load_duration_sec": 0.019901602, "tokens_prompt": 1181, "prompt_eval_sec": 0.56475207, "tokens_completion": 150, "completion_eval_sec": 3.524184985, "tokens_total": 1331, "tokens_per_sec": 319.7318939088832, "retrieval_latency_sec": 0.09749197959899902, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes the 'State' column in both SELECT statements, while the Generated SQL omits it. This results in different output column structures (4 columns vs 3 columns), making them semantically inequivalent despite similar data aggregation."}
{"example_id": 2408, "sql_complexity": "aggregation", "prompt": "What is the average number of victories for players from Japan and South Korea, partitioned by game mode?", "context": "CREATE TABLE PlayerVictories (PlayerID INT, GameMode VARCHAR(255), Victories INT, Country VARCHAR(255)); INSERT INTO PlayerVictories (PlayerID, GameMode, Victories, Country) VALUES (1, 'Battle Royale', 25, 'Japan'), (2, 'Team Deathmatch', 18, 'South Korea');", "reference_sql": "SELECT GameMode, AVG(Victories) as AvgVictories FROM PlayerVictories WHERE Country IN ('Japan', 'South Korea') GROUP BY GameMode, Country WITH ROLLUP;", "generated_sql": "SELECT Country, GameMode, AVG(Victories) AS AverageVictories\nFROM PlayerVictories\nWHERE Country IN ('Japan', 'South Korea')\nGROUP BY Country, GameMode;", "raw_model_output": "```sql\nSELECT Country, GameMode, AVG(Victories) AS AverageVictories\nFROM PlayerVictories\nWHERE Country IN ('Japan', 'South Korea')\nGROUP BY Country, GameMode;\n```", "latency_sec": 1.5537691116333008, "total_duration_sec": 1.429308734, "load_duration_sec": 0.017835061, "tokens_prompt": 874, "prompt_eval_sec": 0.351045306, "tokens_completion": 43, "completion_eval_sec": 1.055889796, "tokens_total": 917, "tokens_per_sec": 590.177776823007, "retrieval_latency_sec": 0.10020208358764648, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses WITH ROLLUP which adds summary rows for aggregations (e.g., total averages per GameMode and a grand total), while the Generated SQL only returns detailed groupings without summary rows. The output structure and content differ due to the ROLLUP clause."}
{"example_id": 2729, "sql_complexity": "subqueries", "prompt": "Find the total number of trips made by shared autonomous vehicles in Seattle", "context": "CREATE TABLE shared_vehicles (id INT, vehicle_type VARCHAR(20), is_autonomous BOOLEAN, trip_count INT); INSERT INTO shared_vehicles (id, vehicle_type, is_autonomous, trip_count) VALUES (1, 'ebike', false, 1200), (2, 'escooter', false, 800), (3, 'car', true, 1500); CREATE TABLE city_data (city VARCHAR(20), has_autonomous_vehicles BOOLEAN); INSERT INTO city_data (city, has_autonomous_vehicles) VALUES ('Seattle', true), ('Denver', false), ('Portland', true);", "reference_sql": "SELECT SUM(trip_count) FROM shared_vehicles WHERE is_autonomous = true AND vehicle_type != 'ebike' AND vehicle_type != 'escooter' AND city IN (SELECT city FROM city_data WHERE has_autonomous_vehicles = true AND city = 'Seattle');", "generated_sql": "SELECT SUM(sv.trip_count) AS TotalTrips\nFROM shared_vehicles sv\nJOIN city_data cd ON cd.has_autonomous_vehicles = sv.is_autonomous\nWHERE cd.city = 'Seattle' AND sv.is_autonomous = true;", "raw_model_output": "To find the total number of trips made by shared autonomous vehicles in Seattle, we need to join the `shared_vehicles` and `city_data` tables based on the condition that the vehicle is autonomous and located in a city with autonomous vehicles. Here's the corresponding SQL query:\n\n```sql\nSELECT SUM(sv.trip_count) AS TotalTrips\nFROM shared_vehicles sv\nJOIN city_data cd ON cd.has_autonomous_vehicles = sv.is_autonomous\nWHERE cd.city = 'Seattle' AND sv.is_autonomous = true;\n```\n\nThis query sums up the `trip_count` of autonomous vehicles in Seattle.", "latency_sec": 3.3092916011810303, "total_duration_sec": 3.302237997, "load_duration_sec": 0.01574173, "tokens_prompt": 785, "prompt_eval_sec": 0.32377225, "tokens_completion": 126, "completion_eval_sec": 2.958668931, "tokens_total": 911, "tokens_per_sec": 275.2855020920125, "retrieval_latency_sec": 0.11841392517089844, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references a 'city' column in the shared_vehicles table, which does not exist in the schema. The Generated SQL correctly joins shared_vehicles with city_data on the autonomous status and filters for Seattle. The Reference SQL would fail due to invalid column reference, making them non-equivalent."}
{"example_id": 2952, "sql_complexity": "aggregation", "prompt": "Show the total budget allocated for each program category in 2023.", "context": "CREATE TABLE Budget (id INT, category TEXT, year INT, allocated_amount INT); INSERT INTO Budget (id, category, year, allocated_amount) VALUES (1, 'Education', 2023, 30000); INSERT INTO Budget (id, category, year, allocated_amount) VALUES (2, 'Healthcare', 2023, 50000);", "reference_sql": "SELECT category, SUM(allocated_amount) FROM Budget WHERE year = 2023 GROUP BY category;", "generated_sql": "SELECT category, SUM(allocated_amount) AS total_budget \nFROM Budget \nWHERE year = 2023 \nGROUP BY category;", "raw_model_output": "```sql\nSELECT category, SUM(allocated_amount) AS total_budget \nFROM Budget \nWHERE year = 2023 \nGROUP BY category;\n```", "latency_sec": 1.1996469497680664, "total_duration_sec": 1.14921244, "load_duration_sec": 0.020461809, "tokens_prompt": 819, "prompt_eval_sec": 0.330993785, "tokens_completion": 33, "completion_eval_sec": 0.791677448, "tokens_total": 852, "tokens_per_sec": 710.208949528627, "retrieval_latency_sec": 0.09116101264953613, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (category and summed allocated_amount) from the same table with the same filtering (year = 2023) and grouping (category). The only difference is the alias 'total_budget' in the generated query, which doesn't affect the semantic meaning of the result set."}
{"example_id": 4328, "sql_complexity": "aggregation", "prompt": "What is the average cargo handling time in hours for each port?", "context": "CREATE TABLE cargo_handling (id INT, port_id INT, time_in_hours DECIMAL(5,2)); INSERT INTO cargo_handling (id, port_id, time_in_hours) VALUES (1, 1, 20.5), (2, 1, 22.3), (3, 2, 18.7);", "reference_sql": "SELECT port_id, AVG(time_in_hours) FROM cargo_handling GROUP BY port_id;", "generated_sql": "SELECT port_id, AVG(time_in_hours) AS avg_handling_time \nFROM cargo_handling \nGROUP BY port_id;", "raw_model_output": "To find the average cargo handling time in hours for each port, we need to group the records by `port_id` and calculate the average of `time_in_hours`. Since there is no additional table like \"ports\" provided that contains names or other details about the ports, we can simply return the `port_id` along with the calculated average.\n\nHere's the SQL query:\n\n```sql\nSELECT port_id, AVG(time_in_hours) AS avg_handling_time \nFROM cargo_handling \nGROUP BY port_id;\n```", "latency_sec": 2.942497730255127, "total_duration_sec": 2.752101528, "load_duration_sec": 0.01577769, "tokens_prompt": 762, "prompt_eval_sec": 0.311475536, "tokens_completion": 104, "completion_eval_sec": 2.421313737, "tokens_total": 866, "tokens_per_sec": 294.30778861634474, "retrieval_latency_sec": 0.11392378807067871, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average time_in_hours per port_id. The generated query adds an alias (avg_handling_time) to the calculated column, but this does not affect the semantic result - the port_id and average values remain identical."}
{"example_id": 4915, "sql_complexity": "window functions", "prompt": "Calculate the percentage of total Europium production for each country.", "context": "CREATE TABLE europium_production (country VARCHAR(50), quantity INT);", "reference_sql": "SELECT country, quantity * 100.0 / SUM(quantity) OVER (PARTITION BY NULL) AS percentage FROM europium_production;", "generated_sql": "SELECT \n    country,\n    (quantity * 100.0 / SUM(quantity) OVER ()) AS production_percentage\nFROM \n    europium_production;", "raw_model_output": "To calculate the percentage of total Europium production for each country based on the provided schema:\n\n```sql\nSELECT \n    country,\n    (quantity * 100.0 / SUM(quantity) OVER ()) AS production_percentage\nFROM \n    europium_production;\n```\n\nThis query calculates the percentage contribution of each country's `quantity` to the total `quantity` of Europium produced across all countries in the table.", "latency_sec": 2.6237051486968994, "total_duration_sec": 2.353510857, "load_duration_sec": 0.015714147, "tokens_prompt": 791, "prompt_eval_sec": 0.324509976, "tokens_completion": 86, "completion_eval_sec": 2.009257545, "tokens_total": 877, "tokens_per_sec": 334.2601208201976, "retrieval_latency_sec": 0.11856889724731445, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the same percentage by dividing each row's quantity by the total sum of quantities. The SUM(quantity) OVER () in the generated query is equivalent to SUM(quantity) OVER (PARTITION BY NULL) in the reference query, as both define a window spanning the entire result set. The only difference is the column alias name, which does not affect the semantic result."}
{"example_id": 5030, "sql_complexity": "subqueries", "prompt": "What is the success rate of diverse-led startups (at least 1 female or underrepresented racial or ethnic group executive) in the past 3 years?", "context": "CREATE TABLE DiverseStartups(id INT, name TEXT, country TEXT, year INT, success BOOLEAN);   INSERT INTO DiverseStartups VALUES (1, 'FemTech', 'USA', 2020, true), (2, 'GreenCity', 'Canada', 2019, false), (3, 'AI-Health', 'UK', 2021, true), (4, 'SolarEnergy', 'USA', 2020, false), (5, 'DataAnalytics', 'Germany', 2019, true), (6, 'SmartGrid', 'USA', 2021, true), (7, 'CloudServices', 'India', 2020, false), (8, 'RenewableEnergy', 'USA', 2019, true);", "reference_sql": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3) AS success_rate FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3 AND success = true;", "generated_sql": "SELECT \n    COUNT(*) * 100.0 / (SELECT COUNT(*) FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3) AS success_rate\nFROM \n    DiverseStartups \nWHERE \n    year >= YEAR(CURRENT_DATE) - 3 AND \n    success = true;", "raw_model_output": "Given that the provided schema does not include information about racial or ethnic diversity of founders, it's impossible to directly calculate the success rate based on those criteria. However, if we assume all startups in the `DiverseStartups` table meet the diverse-led criterion, we can still compute the success rate for startups founded in the past 3 years.\n\nHere is the SQL query:\n\n```sql\nSELECT \n    COUNT(*) * 100.0 / (SELECT COUNT(*) FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3) AS success_rate\nFROM \n    DiverseStartups \nWHERE \n    year >= YEAR(CURRENT_DATE) - 3 AND \n    success = true;\n```\n\nThis query calculates the percentage of successful startups founded in the past three years.", "latency_sec": 4.801311016082764, "total_duration_sec": 4.576294224, "load_duration_sec": 0.016161364, "tokens_prompt": 1398, "prompt_eval_sec": 0.631383558, "tokens_completion": 163, "completion_eval_sec": 3.923186065, "tokens_total": 1561, "tokens_per_sec": 325.1195339712798, "retrieval_latency_sec": 0.11364889144897461, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the success rate of startups by dividing the count of successful startups (success = true) in the last 3 years by the total count of startups in the same period. The structure and logic are identical, with only minor formatting differences (line breaks) that do not affect semantic equivalence."}
{"example_id": 4626, "sql_complexity": "aggregation", "prompt": "What was the maximum number of training hours for farmers in each country in 2020?", "context": "CREATE TABLE training (id INT, country_id INT, farmer_id INT, hours INT, date DATE);", "reference_sql": "SELECT country_id, MAX(hours) FROM training WHERE YEAR(date) = 2020 GROUP BY country_id;", "generated_sql": "SELECT country_id, MAX(hours) AS max_hours\nFROM training\nWHERE YEAR(date) = 2020\nGROUP BY country_id;", "raw_model_output": "To find the maximum number of training hours for farmers in each country in 2020, you can use the following SQL query:\n\n```sql\nSELECT country_id, MAX(hours) AS max_hours\nFROM training\nWHERE YEAR(date) = 2020\nGROUP BY country_id;\n```\n\nThis query filters the `training` table to include only records from the year 2020 and then groups the results by `country_id`. For each group (each country), it calculates the maximum number of training hours (`MAX(hours)`).", "latency_sec": 3.0825541019439697, "total_duration_sec": 2.924445828, "load_duration_sec": 0.01533811, "tokens_prompt": 661, "prompt_eval_sec": 0.288201799, "tokens_completion": 114, "completion_eval_sec": 2.617129257, "tokens_total": 775, "tokens_per_sec": 251.4148898510028, "retrieval_latency_sec": 0.11956286430358887, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (country_id and MAX(hours)), apply the same filter (YEAR(date) = 2020), and group by country_id. The generated query only adds an explicit alias (max_hours) for the MAX(hours) column, which does not affect the semantic result set. The data returned remains identical."}
{"example_id": 2703, "sql_complexity": "set operations", "prompt": "Identify the species unique to 'MarineResearchAreaA' and 'MarineResearchAreaB'", "context": "CREATE TABLE ResearchAreaSpecies (area VARCHAR(255), species VARCHAR(255)); INSERT INTO ResearchAreaSpecies (area, species) VALUES ('MarineResearchAreaA', 'Coral'), ('MarineResearchAreaA', 'Starfish'), ('MarineResearchAreaB', 'Jellyfish');", "reference_sql": "(SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB') UNION (SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA');", "generated_sql": "(SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA' \n EXCEPT \n SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB') \n UNION \n (SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB' \n  EXCEPT \n  SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA');", "raw_model_output": "To identify the species unique to 'MarineResearchAreaA' and 'MarineResearchAreaB', we can use the `EXCEPT` operator twice, once for each area. The results are then combined using `UNION`.\n\nHere is the SQL query:\n\n```sql\n(SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA' \n EXCEPT \n SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB') \n UNION \n (SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB' \n  EXCEPT \n  SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA');\n```", "latency_sec": 3.695470094680786, "total_duration_sec": 3.433564196, "load_duration_sec": 0.017238678, "tokens_prompt": 696, "prompt_eval_sec": 0.296488999, "tokens_completion": 136, "completion_eval_sec": 3.115257528, "tokens_total": 832, "tokens_per_sec": 225.1405040992134, "retrieval_latency_sec": 0.11127805709838867, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries have identical structure and logic. Both perform a UNION of two EXCEPT operations comparing the same tables and conditions. The formatting differences (line breaks, spacing) do not affect semantic equivalence. The result will be the same set of species present in either area but not both."}
{"example_id": 200, "sql_complexity": "window functions", "prompt": "List the top three categories of workforce development programs with the highest budget increases.", "context": "CREATE TABLE programs (program_id INT, program_name VARCHAR(50), budget DECIMAL(10, 2), category VARCHAR(50), budget_date DATE);", "reference_sql": "SELECT category, SUM(budget - LAG(budget) OVER (PARTITION BY category ORDER BY budget_date)) as total_budget_increase FROM programs GROUP BY category ORDER BY total_budget_increase DESC LIMIT 3;", "generated_sql": "WITH budget_changes AS (\n    SELECT \n        category,\n        LAG(budget) OVER (PARTITION BY category ORDER BY budget_date) AS prev_budget,\n        budget - COALESCE(LAG(budget) OVER (PARTITION BY category ORDER BY budget_date), 0) AS budget_increase\n    FROM programs\n),\ncategory_increases AS (\n    SELECT \n        category,\n        SUM(budget_increase) AS total_increase\n    FROM budget_changes\n    GROUP BY category\n)\nSELECT \n    category, \n    total_increase\nFROM (\n    SELECT \n        category, \n        total_increase, \n        ROW_NUMBER() OVER (ORDER BY total_increase DESC) as rn\n    FROM category_increases\n) t\nWHERE rn <= 3;", "raw_model_output": "To list the top three categories of workforce development programs with the highest budget increases, we need to calculate the budget increase for each category. Assuming that \"budget_date\" indicates different periods and we want to compare budgets across these dates, here is a possible approach:\n\n1. Calculate the difference in budget between two consecutive periods.\n2. Group by category and sum up the differences to get total budget increase per category.\n3. Rank categories based on their total budget increases.\n\nHere's an example SQL statement that achieves this:\n\n```sql\nWITH budget_changes AS (\n    SELECT \n        category,\n        LAG(budget) OVER (PARTITION BY category ORDER BY budget_date) AS prev_budget,\n        budget - COALESCE(LAG(budget) OVER (PARTITION BY category ORDER BY budget_date), 0) AS budget_increase\n    FROM programs\n),\ncategory_increases AS (\n    SELECT \n        category,\n        SUM(budget_increase) AS total_increase\n    FROM budget_changes\n    GROUP BY category\n)\nSELECT \n    category, \n    total_increase\nFROM (\n    SELECT \n        category, \n        total_increase, \n        ROW_NUMBER() OVER (ORDER BY total_increase DESC) as rn\n    FROM category_increases\n) t\nWHERE rn <= 3;\n```\n\nThis query first calculates the budget increase for each program within a category over time. Then it sums up these increases per category and ranks them to get the top three categories with the highest total budget increases.", "latency_sec": 7.425471067428589, "total_duration_sec": 7.184286591, "load_duration_sec": 0.016388799, "tokens_prompt": 535, "prompt_eval_sec": 0.135935774, "tokens_completion": 303, "completion_eval_sec": 7.029310409, "tokens_total": 838, "tokens_per_sec": 112.8547929673903, "retrieval_latency_sec": 0.10711193084716797, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in how they handle the first row of each category. The Reference SQL calculates budget - LAG(budget) which results in NULL for the first row (ignored in SUM), while the Generated SQL uses COALESCE(LAG(...), 0) making the first row's budget_increase equal to the budget itself. This leads to different total sums: the Reference SQL computes last_budget - first_budget (telescoping sum), while the Generated SQL computes last_budget + first_budget (due to adding the first budget as an increase). Additionally, the Generated SQL uses ROW_NUMBER() for ranking, which may behave differently than ORDER BY in the Reference SQL."}
{"example_id": 5131, "sql_complexity": "basic SQL", "prompt": "How many wells were drilled in the Eagle Ford Shale and Bakken Formation?", "context": "CREATE TABLE wells (id INT, region VARCHAR(255), well_type VARCHAR(255), num_drilled INT); INSERT INTO wells (id, region, well_type, num_drilled) VALUES (1, 'Eagle Ford Shale', 'Oil', 2000), (2, 'Eagle Ford Shale', 'Gas', 1500), (3, 'Bakken Formation', 'Oil', 1000), (4, 'Bakken Formation', 'Gas', 1200);", "reference_sql": "SELECT SUM(num_drilled) as total_wells FROM wells WHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "generated_sql": "SELECT SUM(num_drilled) AS total_wells FROM wells WHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "raw_model_output": "To find the total number of wells drilled in both the Eagle Ford Shale and Bakken Formation, you can use a `SUM` aggregation function combined with a condition to filter by these regions. Here is the corresponding SQL query:\n\n```sql\nSELECT SUM(num_drilled) AS total_wells FROM wells WHERE region IN ('Eagle Ford Shale', 'Bakken Formation');\n```", "latency_sec": 2.5138700008392334, "total_duration_sec": 2.204227923, "load_duration_sec": 0.02046401, "tokens_prompt": 822, "prompt_eval_sec": 0.327603822, "tokens_completion": 79, "completion_eval_sec": 1.851812717, "tokens_total": 901, "tokens_per_sec": 358.41153269628467, "retrieval_latency_sec": 0.10865306854248047, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of num_drilled for wells in the 'Eagle Ford Shale' and 'Bakken Formation' regions. The only differences are whitespace and case variations in SQL keywords (e.g., SUM vs sum, FROM vs from), which do not affect semantic meaning in SQL."}
{"example_id": 1160, "sql_complexity": "subqueries", "prompt": "What is the total revenue generated from ads on Instagram in March 2021, for users in the 'brand' category who have posted more than 10 times?", "context": "CREATE TABLE ads (ad_id INT, user_id INT, platform VARCHAR(255), ad_revenue DECIMAL(10,2), post_count INT); INSERT INTO ads (ad_id, user_id, platform, ad_revenue, post_count) VALUES (1, 1, 'Instagram', 150.50, 12), (2, 2, 'Twitter', 80.00, 15), (3, 3, 'Instagram', 120.75, 8);", "reference_sql": "SELECT SUM(ad_revenue) FROM ads WHERE platform = 'Instagram' AND MONTH(ad_date) = 3 AND YEAR(ad_date) = 2021 AND user_id IN (SELECT user_id FROM users WHERE category = 'brand' AND post_count > 10);", "generated_sql": "SELECT SUM(ad_revenue) AS total_revenue\nFROM ads\nWHERE platform = 'Instagram'\nAND post_count > 10\nAND user_id IN (SELECT user_id FROM users WHERE category = 'brand');", "raw_model_output": "To address the question and given that there is no `ad_date` column in the provided schema, we can only filter based on the platform and post count. Additionally, since there's no information about user categories directly within the ads table, we'll assume a separate users table exists with necessary details.\n\nHere\u2019s how to write the SQL query:\n\n```sql\nSELECT SUM(ad_revenue) AS total_revenue\nFROM ads\nWHERE platform = 'Instagram'\nAND post_count > 10\nAND user_id IN (SELECT user_id FROM users WHERE category = 'brand');\n```\n\nThis query calculates the total revenue from ads on Instagram for users in the 'brand' category who have posted more than 10 times.", "latency_sec": 4.047132968902588, "total_duration_sec": 3.976466825, "load_duration_sec": 0.015978449, "tokens_prompt": 1082, "prompt_eval_sec": 0.406606587, "tokens_completion": 147, "completion_eval_sec": 3.550382901, "tokens_total": 1229, "tokens_per_sec": 303.671762070435, "retrieval_latency_sec": 0.11237573623657227, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Reference SQL includes ad_date filters (MONTH(ad_date) = 3 AND YEAR(ad_date) = 2021) which the Generated SQL lacks. Second, the Reference SQL filters users via a subquery with post_count > 10, while the Generated SQL filters ads directly via post_count > 10. These differences in filtering logic and conditions make the queries non-equivalent."}
{"example_id": 4708, "sql_complexity": "subqueries", "prompt": "What is the maximum number of high-level threats reported by a single agency in a month?", "context": "CREATE TABLE Threat_Intelligence (Threat_ID INT, Threat_Type VARCHAR(50), Threat_Level VARCHAR(50), Reported_Date DATE, Reporting_Agency VARCHAR(50)); CREATE VIEW High_Level_Threats AS SELECT Threat_Type, Threat_Level, Reported_Date FROM Threat_Intelligence WHERE Threat_Level = 'High';", "reference_sql": "SELECT Reporting_Agency, MAX(Number_of_High_Level_Threats) as Max_High_Level_Threats_in_a_Month FROM (SELECT Reporting_Agency, TO_CHAR(Reported_Date, 'YYYY-MM') as Month, COUNT(*) as Number_of_High_Level_Threats FROM High_Level_Threats GROUP BY Reporting_Agency, Month) GROUP BY Reporting_Agency;", "generated_sql": "SELECT MAX(threat_count) AS max_threats_per_month\nFROM (\n    SELECT Reporting_Agency, COUNT(*) AS threat_count\n    FROM Threat_Intelligence\n    WHERE Threat_Level = 'High'\n      AND Reported_Date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH)\n    GROUP BY Reporting_Agency, YEAR(Reported_Date), MONTH(Reported_Date)\n) AS subquery;", "raw_model_output": "To find the maximum number of high-level threats reported by a single agency in a month, we need to follow these steps:\n\n1. Filter for high-level threats.\n2. Group by Reporting_Agency and Reported_Date's month and year.\n3. Count the number of high-level threats per group.\n4. Find the maximum count.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT MAX(threat_count) AS max_threats_per_month\nFROM (\n    SELECT Reporting_Agency, COUNT(*) AS threat_count\n    FROM Threat_Intelligence\n    WHERE Threat_Level = 'High'\n      AND Reported_Date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH)\n    GROUP BY Reporting_Agency, YEAR(Reported_Date), MONTH(Reported_Date)\n) AS subquery;\n```", "latency_sec": 4.256842136383057, "total_duration_sec": 4.078161977, "load_duration_sec": 0.022303293, "tokens_prompt": 671, "prompt_eval_sec": 0.30048869, "tokens_completion": 164, "completion_eval_sec": 3.747932485, "tokens_total": 835, "tokens_per_sec": 196.15479579646353, "retrieval_latency_sec": 0.09295296669006348, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Reference SQL considers all high-level threats across all time, while the Generated SQL restricts to threats from the last month. Second, the Reference SQL calculates the maximum monthly count per Reporting_Agency, whereas the Generated SQL returns a single maximum value across all agencies and months. Additionally, the Generated SQL uses explicit YEAR/MONTH grouping instead of a formatted 'YYYY-MM' string, but the primary discrepancy lies in the date filter and aggregation scope."}
{"example_id": 5608, "sql_complexity": "set operations", "prompt": "List the suppliers that provide materials for both product A and product C.", "context": "CREATE TABLE products (product_id INT, product_name TEXT); CREATE TABLE materials (material_id INT, material_name TEXT, product_id INT, supplier_id INT); INSERT INTO products (product_id, product_name) VALUES (1, 'Product A'), (2, 'Product B'), (3, 'Product C'); INSERT INTO materials (material_id, material_name, product_id, supplier_id) VALUES (1, 'Material 1', 1, 101), (2, 'Material 2', 1, 102), (3, 'Material 3', 2, 103), (4, 'Material 4', 3, 101), (5, 'Material 5', 3, 102);", "reference_sql": "SELECT supplier_id FROM materials WHERE product_id = 1 INTERSECT SELECT supplier_id FROM materials WHERE product_id = 3;", "generated_sql": "SELECT supplier_id \nFROM materials \nWHERE product_id IN (1, 3) -- Product A has ID 1 and Product C has ID 3\nGROUP BY supplier_id \nHAVING COUNT(DISTINCT product_id) = 2;", "raw_model_output": "To find the suppliers that provide materials for both Product A and Product C, we need to filter the `materials` table based on these two specific products and then group by `supplier_id`. We can use a `HAVING` clause to ensure that only those suppliers who supply materials for both products are included.\n\nHere is the SQL query:\n\n```sql\nSELECT supplier_id \nFROM materials \nWHERE product_id IN (1, 3) -- Product A has ID 1 and Product C has ID 3\nGROUP BY supplier_id \nHAVING COUNT(DISTINCT product_id) = 2;\n```\n\nThis query filters the `materials` table to include only those rows where `product_id` is either 1 or 3 (Product A and Product C). It then groups by `supplier_id`, ensuring that each group contains materials for both products. The `HAVING COUNT(DISTINCT product_id) = 2` condition ensures that the supplier provides materials for exactly two distinct products, which are Product A and Product C in this case.", "latency_sec": 5.761987686157227, "total_duration_sec": 5.648479766, "load_duration_sec": 0.014954614, "tokens_prompt": 1315, "prompt_eval_sec": 0.605758818, "tokens_completion": 213, "completion_eval_sec": 5.022628362, "tokens_total": 1528, "tokens_per_sec": 265.1862661336319, "retrieval_latency_sec": 0.09798073768615723, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve supplier_ids that have materials for both product_id 1 and 3. The Reference SQL uses INTERSECT to find common supplier_ids between the two product_id conditions, while the Generated SQL uses GROUP BY and HAVING COUNT(DISTINCT product_id) = 2 to ensure suppliers appear in both product groups. Both approaches yield the same result."}
{"example_id": 1506, "sql_complexity": "basic SQL", "prompt": "How many habitats are in the 'animal_habitats' table?", "context": "CREATE TABLE animal_habitats (id INT PRIMARY KEY, habitat_name VARCHAR, num_animals INT);", "reference_sql": "SELECT COUNT(*) FROM animal_habitats;", "generated_sql": "SELECT COUNT(*) FROM animal_habitats;", "raw_model_output": "```sql\nSELECT COUNT(*) FROM animal_habitats;\n```", "latency_sec": 0.8821282386779785, "total_duration_sec": 0.645706534, "load_duration_sec": 0.023948848, "tokens_prompt": 634, "prompt_eval_sec": 0.2938517, "tokens_completion": 14, "completion_eval_sec": 0.319593632, "tokens_total": 648, "tokens_per_sec": 734.5870720238362, "retrieval_latency_sec": 0.10695004463195801, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical: they select the count of all rows from the 'animal_habitats' table. Since the SQL syntax and structure are exactly the same, they will produce the same result."}
{"example_id": 3117, "sql_complexity": "aggregation", "prompt": "What is the percentage of the population that has access to clean water in each continent?", "context": "CREATE TABLE water_data (id INT, country VARCHAR(50), continent CHAR(2), access_to_clean_water BOOLEAN); INSERT INTO water_data VALUES (1, 'Canada', 'NA', true), (2, 'Mexico', 'NA', false), (3, 'Brazil', 'SA', true), (4, 'Russia', 'EU', true);", "reference_sql": "SELECT continent, COUNT(*) FILTER (WHERE access_to_clean_water) * 100.0 / COUNT(*) AS percentage FROM water_data GROUP BY continent;", "generated_sql": "SELECT \n    continent,\n    (SUM(CASE WHEN access_to_clean_water THEN 1 ELSE 0 END) / COUNT(*)) * 100 AS clean_water_percentage\nFROM \n    water_data\nGROUP BY \n    continent;", "raw_model_output": "To calculate the percentage of the population with access to clean water for each continent, we need to group by `continent` and compute the ratio of countries that have `access_to_clean_water = true`. However, since the schema does not provide population data directly, we will assume that each country represents an equal part of its continent's population.\n\nHere is the SQL query:\n\n```sql\nSELECT \n    continent,\n    (SUM(CASE WHEN access_to_clean_water THEN 1 ELSE 0 END) / COUNT(*)) * 100 AS clean_water_percentage\nFROM \n    water_data\nGROUP BY \n    continent;\n```\n\nThis query groups the data by `continent` and calculates the percentage of countries within each continent that have access to clean water.", "latency_sec": 4.1434361934661865, "total_duration_sec": 3.924804552, "load_duration_sec": 0.015834369, "tokens_prompt": 798, "prompt_eval_sec": 0.32550224, "tokens_completion": 154, "completion_eval_sec": 3.578246248, "tokens_total": 952, "tokens_per_sec": 229.76098956253156, "retrieval_latency_sec": 0.10992622375488281, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the percentage of countries with access to clean water per continent. The Reference SQL uses COUNT(*) FILTER (WHERE access_to_clean_water) to count true values, while the Generated SQL uses SUM(CASE WHEN access_to_clean_water THEN 1 ELSE 0 END) for the same purpose. Both methods effectively compute the same numerator (count of true values) and denominator (total count per group), resulting in identical percentages."}
{"example_id": 3542, "sql_complexity": "window functions", "prompt": "What is the average yield of crops for each country, ranked by average yield?", "context": "CREATE TABLE farming (id INT, name TEXT, country TEXT, crop TEXT, yield INT); INSERT INTO farming VALUES (1, 'Smith Farm', 'USA', 'Corn', 120), (2, 'Brown Farm', 'Canada', 'Soybeans', 45), (3, 'Jones Farm', 'Mexico', 'Wheat', 80);", "reference_sql": "SELECT country, AVG(yield) as avg_yield, ROW_NUMBER() OVER (ORDER BY AVG(yield) DESC) as rank FROM farming GROUP BY country;", "generated_sql": "SELECT country, AVG(yield) AS avg_yield \nFROM farming \nGROUP BY country \nORDER BY avg_yield;", "raw_model_output": "```sql\nSELECT country, AVG(yield) AS avg_yield \nFROM farming \nGROUP BY country \nORDER BY avg_yield;\n```", "latency_sec": 1.1703908443450928, "total_duration_sec": 0.952142657, "load_duration_sec": 0.015314642, "tokens_prompt": 673, "prompt_eval_sec": 0.293546336, "tokens_completion": 28, "completion_eval_sec": 0.638977319, "tokens_total": 701, "tokens_per_sec": 598.9452185028442, "retrieval_latency_sec": 0.11379098892211914, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a ROW_NUMBER() window function to assign ranks based on descending average yield, while the Generated SQL only groups and orders by average yield without ranking. The presence of the rank column and different ordering logic (descending vs. default ascending) make them non-equivalent."}
{"example_id": 2274, "sql_complexity": "subqueries", "prompt": "Add a new crop 'amaranth' to farm 'Nourishing Harvest' with yield 50 in 2023", "context": "CREATE TABLE farms (id INT, name TEXT, location TEXT, size FLOAT); INSERT INTO farms (id, name, location, size) VALUES (1, 'Nourishing Harvest', 'Mexico', 120.0); CREATE TABLE crops (id INT, farm_id INT, crop TEXT, yield INT, year INT);", "reference_sql": "INSERT INTO crops (id, farm_id, crop, yield, year) VALUES (5, (SELECT id FROM farms WHERE name = 'Nourishing Harvest'), 'amaranth', 50, 2023);", "generated_sql": "INSERT INTO crops (farm_id, crop, yield, year)\nVALUES (\n    (SELECT id FROM farms WHERE name = 'Nourishing Harvest'),\n    'amaranth',\n    50,\n    2023\n);", "raw_model_output": "To add a new crop 'amaranth' to farm 'Nourishing Harvest' with yield 50 in 2023, you need to:\n\n1. Find the `farm_id` for the farm named 'Nourishing Harvest'.\n2. Insert a new row into the `crops` table with the appropriate values.\n\nHere is the SQL statement that accomplishes this:\n\n```sql\nINSERT INTO crops (farm_id, crop, yield, year)\nVALUES (\n    (SELECT id FROM farms WHERE name = 'Nourishing Harvest'),\n    'amaranth',\n    50,\n    2023\n);\n```", "latency_sec": 3.6086268424987793, "total_duration_sec": 3.570469554, "load_duration_sec": 0.016117839, "tokens_prompt": 1084, "prompt_eval_sec": 0.404340487, "tokens_completion": 132, "completion_eval_sec": 3.146114281, "tokens_total": 1216, "tokens_per_sec": 336.9702806838253, "retrieval_latency_sec": 0.11533880233764648, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference SQL explicitly specifies the 'id' column and assigns it a value of 5, while the generated SQL omits the 'id' column entirely. This makes them non-equivalent because the generated query would rely on the database to handle the 'id' (e.g., auto-increment) whereas the reference query explicitly sets it. The presence of the 'id' column in the INSERT statement affects the semantic equivalence."}
{"example_id": 3705, "sql_complexity": "subqueries", "prompt": "What is the percentage of unions with collective bargaining agreements in the Midwest region?", "context": "CREATE TABLE collective_bargaining (bargaining_id INT, union_name VARCHAR(50), contract_start_date DATE, contract_end_date DATE, region VARCHAR(50));CREATE VIEW union_region AS SELECT DISTINCT union_name, region FROM collective_bargaining;", "reference_sql": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM union_region) as percentage FROM union_region ur WHERE ur.region = 'Midwest' AND EXISTS (SELECT 1 FROM collective_bargaining cb WHERE cb.union_name = ur.union_name);", "generated_sql": "SELECT \n    (COUNT(DISTINCT cb.union_name) * 100.0 / \n     (SELECT COUNT(DISTINCT union_name) FROM union_region WHERE region = 'Midwest')) AS percentage\nFROM \n    collective_bargaining cb\nWHERE \n    cb.region = 'Midwest';", "raw_model_output": "To find the percentage of unions with collective bargaining agreements in the Midwest region, we need to count the number of unique unions that have a collective bargaining agreement in the Midwest and divide it by the total number of unique unions in the Midwest. Here is the corresponding SQL query:\n\n```sql\nSELECT \n    (COUNT(DISTINCT cb.union_name) * 100.0 / \n     (SELECT COUNT(DISTINCT union_name) FROM union_region WHERE region = 'Midwest')) AS percentage\nFROM \n    collective_bargaining cb\nWHERE \n    cb.region = 'Midwest';\n```\n\nThis query calculates the percentage of unions with collective bargaining agreements in the Midwest by dividing the count of distinct `union_name` entries from the `collective_bargaining` table that are in the Midwest region by the total number of unique union names in the `union_region` view for the Midwest.", "latency_sec": 5.144284009933472, "total_duration_sec": 4.895519913, "load_duration_sec": 0.021268773, "tokens_prompt": 1156, "prompt_eval_sec": 0.556529253, "tokens_completion": 183, "completion_eval_sec": 4.309025457, "tokens_total": 1339, "tokens_per_sec": 260.2888949005202, "retrieval_latency_sec": 0.10227012634277344, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query calculates the percentage of 'Midwest' entries in the entire union_region view, while the generated query computes 100% because its numerator and denominator both count distinct Midwest union_names in the same context. The reference query's denominator is the total number of (union_name, region) pairs in union_region, whereas the generated query's denominator is the count of distinct union_names in the Midwest, leading to different results."}
{"example_id": 240, "sql_complexity": "aggregation", "prompt": "What is the average capacity of renewable energy projects for each country?", "context": "CREATE TABLE projects (name TEXT, type TEXT, capacity INTEGER, country TEXT); INSERT INTO projects (name, type, capacity, country) VALUES ('Project 1', 'Wind', 100, 'USA'), ('Project 2', 'Solar', 200, 'Germany'), ('Project 3', 'Wind', 300, 'France');", "reference_sql": "SELECT country, AVG(capacity) FROM projects GROUP BY country", "generated_sql": "SELECT country, AVG(capacity) AS avg_capacity \nFROM projects \nWHERE type IN ('Wind', 'Solar')\nGROUP BY country;", "raw_model_output": "To find the average capacity of renewable energy projects for each country, we need to group the data by `country` and calculate the average `capacity` within each group. Here is the corresponding SQL query:\n\n```sql\nSELECT country, AVG(capacity) AS avg_capacity \nFROM projects \nWHERE type IN ('Wind', 'Solar')\nGROUP BY country;\n```", "latency_sec": 2.365518093109131, "total_duration_sec": 2.048535264, "load_duration_sec": 0.016427044, "tokens_prompt": 724, "prompt_eval_sec": 0.323800189, "tokens_completion": 73, "completion_eval_sec": 1.703918495, "tokens_total": 797, "tokens_per_sec": 336.92407693760606, "retrieval_latency_sec": 0.09231209754943848, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The WHERE clause in the Generated SQL does not exclude any rows because all projects in the dataset are of type 'Wind' or 'Solar', making both queries produce the same results."}
{"example_id": 2132, "sql_complexity": "set operations", "prompt": "What is the average caseload per attorney in community legal clinics in California, and how does it compare to the state average?", "context": "CREATE TABLE cali_community_legal_clinics(id INT, attorney_count INT, cases_handled INT, state VARCHAR(255));", "reference_sql": "SELECT state, AVG(cases_handled/attorney_count) AS avg_caseload FROM cali_community_legal_clinics WHERE state = 'California' GROUP BY state UNION ALL SELECT 'California', AVG(cases_handled/attorney_count) FROM cali_community_legal_clinics WHERE state = 'California';", "generated_sql": "SELECT \n    (SUM(cases_handled) / SUM(attorney_count)) AS avg_caseload_per_attorney,\n    AVG((cases_handled * 1.0) / attorney_count) AS avg_caseload_per_clinic\nFROM cali_community_legal_clinics;", "raw_model_output": "To find the average caseload per attorney in community legal clinics in California and compare it to the state average, we need to calculate two values:\n\n1. The average number of cases handled per attorney in California.\n2. The overall average number of cases handled per attorney (assuming this is also for California).\n\nHere's how you can write the SQL query to achieve that:\n\n```sql\nSELECT \n    (SUM(cases_handled) / SUM(attorney_count)) AS avg_caseload_per_attorney,\n    AVG((cases_handled * 1.0) / attorney_count) AS avg_caseload_per_clinic\nFROM cali_community_legal_clinics;\n```\n\nExplanation:\n- `SUM(cases_handled) / SUM(attorney_count)` calculates the total number of cases handled divided by the total number of attorneys, giving us the average caseload per attorney.\n- `AVG((cases_handled * 1.0) / attorney_count)` calculates the average caseload per clinic by dividing each clinic's cases handled by its attorney count and then averaging those values.\n\nThis query provides both the overall average caseload per attorney as well as the average caseload per clinic in California.", "latency_sec": 6.290204763412476, "total_duration_sec": 5.979036562, "load_duration_sec": 0.016814147, "tokens_prompt": 760, "prompt_eval_sec": 0.313699016, "tokens_completion": 244, "completion_eval_sec": 5.644657858, "tokens_total": 1004, "tokens_per_sec": 159.6132459534312, "retrieval_latency_sec": 0.09080290794372559, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates the average caseload per attorney for California clinics, with a redundant UNION ALL to ensure a row is returned. The Generated SQL computes two different metrics: total cases divided by total attorneys (sum-based) and the average of per-clinic caseload ratios. Additionally, the Generated SQL lacks a WHERE clause filtering for California, and the column names/definitions differ entirely."}
{"example_id": 3276, "sql_complexity": "basic SQL", "prompt": "What is the total energy consumption of the Chemical Plant B in the last quarter?", "context": "CREATE TABLE EnergyConsumption (EnergyID INT, Plant VARCHAR(255), EnergyQuantity DECIMAL(5,2), Timestamp DATETIME);", "reference_sql": "SELECT SUM(EnergyQuantity) FROM EnergyConsumption WHERE Plant = 'Chemical Plant B' AND Timestamp BETWEEN DATE_SUB(CURRENT_DATE(), INTERVAL 3 MONTH) AND CURRENT_DATE();", "generated_sql": "SELECT SUM(EnergyQuantity) AS TotalEnergyConsumption \nFROM EnergyConsumption \nWHERE Plant = 'Chemical Plant B' \n  AND Timestamp >= DATEADD(quarter, -1, CURRENT_DATE());", "raw_model_output": "```sql\nSELECT SUM(EnergyQuantity) AS TotalEnergyConsumption \nFROM EnergyConsumption \nWHERE Plant = 'Chemical Plant B' \n  AND Timestamp >= DATEADD(quarter, -1, CURRENT_DATE());\n```", "latency_sec": 1.7779240608215332, "total_duration_sec": 1.452010007, "load_duration_sec": 0.016016153, "tokens_prompt": 795, "prompt_eval_sec": 0.317212861, "tokens_completion": 47, "completion_eval_sec": 1.115142939, "tokens_total": 842, "tokens_per_sec": 473.5860313465432, "retrieval_latency_sec": 0.10255265235900879, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query uses BETWEEN with both start and end dates (CURRENT_DATE()), while the generated query only uses a >= condition. The generated query lacks the upper bound restriction, potentially including records with Timestamps after the current date, which the reference query explicitly excludes."}
{"example_id": 3074, "sql_complexity": "multiple_joins", "prompt": "Find the top 5 players with the highest scores in the 'historical_tournaments' view, including their scores and the names of the tournaments they participated in.", "context": "CREATE VIEW historical_tournaments AS SELECT tournaments.tournament_name, players.player_name, players.score FROM tournaments JOIN players_scores ON tournaments.tournament_id = players_scores.tournament_id JOIN players ON players_scores.player_id = players.player_id;  CREATE TABLE tournaments (tournament_id INT, tournament_name TEXT);  CREATE TABLE players_scores (player_id INT, tournament_id INT, score INT);  CREATE TABLE players (player_id INT, player_name TEXT);", "reference_sql": "SELECT players.player_name, MAX(players_scores.score) as high_score, tournaments.tournament_name FROM historical_tournaments JOIN players ON historical_tournaments.player_id = players.player_id JOIN players_scores ON historical_tournaments.player_id = players_scores.player_id JOIN tournaments ON players_scores.tournament_id = tournaments.tournament_id GROUP BY players.player_id, tournaments.tournament_name ORDER BY high_score DESC LIMIT 5;", "generated_sql": "SELECT player_name, tournament_name, score \nFROM (\n    SELECT player_name, tournament_name, score,\n           RANK() OVER (ORDER BY score DESC) as rnk\n    FROM historical_tournaments\n) AS ranked_players\nWHERE rnk <= 5;", "raw_model_output": "To find the top 5 players with the highest scores from the `historical_tournaments` view and include their tournament names and scores, you can use a window function to rank the players by score. Here is the corresponding SQL query:\n\n```sql\nSELECT player_name, tournament_name, score \nFROM (\n    SELECT player_name, tournament_name, score,\n           RANK() OVER (ORDER BY score DESC) as rnk\n    FROM historical_tournaments\n) AS ranked_players\nWHERE rnk <= 5;\n```\n\nThis query ranks all players by their scores in descending order and then selects the top 5 players along with the names of the tournaments they participated in.", "latency_sec": 3.8892579078674316, "total_duration_sec": 3.706396968, "load_duration_sec": 0.020758789, "tokens_prompt": 995, "prompt_eval_sec": 0.383023624, "tokens_completion": 138, "completion_eval_sec": 3.294767261, "tokens_total": 1133, "tokens_per_sec": 291.31521406901237, "retrieval_latency_sec": 0.1134178638458252, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL groups by player and tournament to find each player's maximum score per tournament, then ranks these max scores. The Generated SQL ranks all entries in the historical_tournaments view directly by score, without grouping, leading to different results. Additionally, the Reference SQL contains invalid JOIN conditions (missing player_id in the view), making it syntactically incorrect."}
{"example_id": 2219, "sql_complexity": "window functions", "prompt": "What is the average population of cities with a UNESCO World Heritage designation, ordered by designation date?", "context": "CREATE TABLE cities (name VARCHAR(255), population INT, designation_date DATE); INSERT INTO cities (name, population, designation_date) VALUES ('Paris', 2141000, '1991-09-16'); INSERT INTO cities (name, population, designation_date) VALUES ('Rio de Janeiro', 6727000, '2012-07-01');", "reference_sql": "SELECT AVG(population) FROM (SELECT population, ROW_NUMBER() OVER (ORDER BY designation_date) rn FROM cities WHERE name IN (SELECT name FROM heritagesites)) t WHERE rn % 2 = 1;", "generated_sql": "SELECT AVG(population) AS avg_population, designation_date \nFROM cities \nWHERE name IN ('Paris', 'Rio de Janeiro')  -- Assuming these are the cities with UNESCO designations\nGROUP BY designation_date \nORDER BY designation_date;", "raw_model_output": "To find the average population of cities with a UNESCO World Heritage designation ordered by their designation date, you can use the following SQL query:\n\n```sql\nSELECT AVG(population) AS avg_population, designation_date \nFROM cities \nWHERE name IN ('Paris', 'Rio de Janeiro')  -- Assuming these are the cities with UNESCO designations\nGROUP BY designation_date \nORDER BY designation_date;\n```\n\nThis query calculates the average population of cities that have a UNESCO World Heritage designation and orders the results by their designation date. Note that I assumed 'Paris' and 'Rio de Janeiro' as examples for cities with UNESCO designations based on the provided data. If there are other cities in your actual dataset, you should adjust the `IN` clause accordingly.", "latency_sec": 4.279421806335449, "total_duration_sec": 3.977790053, "load_duration_sec": 0.016022002, "tokens_prompt": 981, "prompt_eval_sec": 0.377352688, "tokens_completion": 152, "completion_eval_sec": 3.579047451, "tokens_total": 1133, "tokens_per_sec": 264.75539249780326, "retrieval_latency_sec": 0.09245109558105469, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates the average population of cities in heritagesites ordered by designation_date, selecting only odd-numbered rows. The Generated SQL groups cities by designation_date and calculates averages per group. They differ in filtering logic (heritagesites vs hardcoded names), result structure (single average vs grouped averages), and handling of dates. The Reference SQL's subquery depends on an unspecified heritagesites table, while the Generated SQL hardcodes city names."}
{"example_id": 3786, "sql_complexity": "aggregation", "prompt": "Display the names and average co-owner percentages for all properties in the 'property_coownership' table where the co-owner percentage is greater than 60.", "context": "CREATE TABLE property_coownership (property_id INT, owner VARCHAR(255), percentage INT); INSERT INTO property_coownership (property_id, owner, percentage) VALUES (1, 'Mohammed', 70), (1, 'Fatima', 30), (2, 'Jamal', 65), (2, 'Aisha', 35), (3, 'Ali', 75), (3, 'Khadija', 25);", "reference_sql": "SELECT owner, AVG(percentage) FROM property_coownership WHERE percentage > 60 GROUP BY owner;", "generated_sql": "SELECT owner, AVG(percentage) AS avg_percentage \nFROM property_coownership \nWHERE percentage > 60 \nGROUP BY owner;", "raw_model_output": "The question requires displaying the names of owners and their average co-owner percentages for all properties in the 'property_coownership' table where the co-owner percentage is greater than 60. This can be achieved by using a `GROUP BY` clause on the `owner` column, applying an `AVG` function to calculate the average percentage, and filtering with a `HAVING` clause.\n\nHere's the SQL query:\n\n```sql\nSELECT owner, AVG(percentage) AS avg_percentage \nFROM property_coownership \nWHERE percentage > 60 \nGROUP BY owner;\n```", "latency_sec": 3.3331429958343506, "total_duration_sec": 3.130514869, "load_duration_sec": 0.019802663, "tokens_prompt": 905, "prompt_eval_sec": 0.355168277, "tokens_completion": 117, "completion_eval_sec": 2.751516191, "tokens_total": 1022, "tokens_per_sec": 306.61750824289896, "retrieval_latency_sec": 0.09991192817687988, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. The only difference is that the Generated SQL adds an explicit alias (avg_percentage) for the AVG(percentage) column, but the selection, filtering, and grouping logic remain identical. Both queries calculate the average percentage for owners with entries >60% and group by owner."}
{"example_id": 2357, "sql_complexity": "basic SQL", "prompt": "What is the total amount of climate finance invested in renewable energy projects by public and private sectors in Africa?", "context": "CREATE TABLE renewable_energy_projects (project_id INT, sector TEXT, investor_type TEXT, region TEXT, amount FLOAT); INSERT INTO renewable_energy_projects (project_id, sector, investor_type, region, amount) VALUES (1, 'Renewable Energy', 'Public', 'Africa', 5000000); INSERT INTO renewable_energy_projects (project_id, sector, investor_type, region, amount) VALUES (2, 'Renewable Energy', 'Private', 'Africa', 7000000);", "reference_sql": "SELECT SUM(amount) FROM renewable_energy_projects WHERE sector = 'Renewable Energy' AND region = 'Africa';", "generated_sql": "SELECT SUM(amount) AS total_invested_amount \nFROM renewable_energy_projects \nWHERE sector = 'Renewable Energy' AND region = 'Africa';", "raw_model_output": "```sql\nSELECT SUM(amount) AS total_invested_amount \nFROM renewable_energy_projects \nWHERE sector = 'Renewable Energy' AND region = 'Africa';\n```", "latency_sec": 1.327847957611084, "total_duration_sec": 1.203637893, "load_duration_sec": 0.016150924, "tokens_prompt": 813, "prompt_eval_sec": 0.326104488, "tokens_completion": 36, "completion_eval_sec": 0.857472331, "tokens_total": 849, "tokens_per_sec": 639.3804314218521, "retrieval_latency_sec": 0.11377692222595215, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of 'amount' for projects in the 'Renewable Energy' sector located in 'Africa'. The generated query adds an alias ('total_invested_amount') to the SUM result, but this does not affect the semantic equivalence of the output value."}
{"example_id": 1009, "sql_complexity": "multiple_joins", "prompt": "Find the number of IoT sensors installed in each farm that use Sprinkler irrigation.", "context": "CREATE TABLE IoT_Sensors (id INT, sensor_type VARCHAR(50), Farm_id INT); INSERT INTO IoT_Sensors (id, sensor_type, Farm_id) VALUES (1, 'Soil Moisture', 1), (2, 'Temperature', 1), (3, 'Humidity', 2); CREATE TABLE Irrigation (id INT, Farm_id INT, irrigation_type VARCHAR(50), duration INT); INSERT INTO Irrigation (id, Farm_id, irrigation_type, duration) VALUES (1, 1, 'Sprinkler', 30), (2, 2, 'Drip', 45);", "reference_sql": "SELECT f.id, COUNT(s.id) FROM Farmers f JOIN Irrigation i ON f.id = i.Farm_id JOIN IoT_Sensors s ON f.id = s.Farm_id WHERE i.irrigation_type = 'Sprinkler' GROUP BY f.id;", "generated_sql": "SELECT i.Farm_id, COUNT(i.id) AS sensor_count\nFROM IoT_Sensors i\nJOIN Irrigation ir ON i.Farm_id = ir.Farm_id AND ir.irrigation_type = 'Sprinkler'\nGROUP BY i.Farm_id;", "raw_model_output": "To find the number of IoT sensors installed in each farm that use Sprinkler irrigation, we need to join the `IoT_Sensors` and `Irrigation` tables on the `Farm_id` column. We then filter for farms using \"Sprinkler\" irrigation and count the number of sensors per farm.\n\nHere is the SQL query:\n\n```sql\nSELECT i.Farm_id, COUNT(i.id) AS sensor_count\nFROM IoT_Sensors i\nJOIN Irrigation ir ON i.Farm_id = ir.Farm_id AND ir.irrigation_type = 'Sprinkler'\nGROUP BY i.Farm_id;\n```\n\nThis query joins the `IoT_Sensors` and `Irrigation` tables on `Farm_id`, filters for farms using \"Sprinkler\" irrigation, groups by `Farm_id`, and counts the number of sensors in each farm.", "latency_sec": 4.817383766174316, "total_duration_sec": 4.608370913, "load_duration_sec": 0.019775811, "tokens_prompt": 864, "prompt_eval_sec": 0.351852359, "tokens_completion": 179, "completion_eval_sec": 4.230408262, "tokens_total": 1043, "tokens_per_sec": 216.50755900402126, "retrieval_latency_sec": 0.11060714721679688, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of IoT_Sensors per Farm_id where the associated Irrigation is of type 'Sprinkler'. The Reference SQL joins Farmers, Irrigation, and IoT_Sensors, while the Generated SQL directly joins IoT_Sensors and Irrigation. However, the final grouping and counting logic are equivalent: both count sensor-irrigation pairs for farms with 'Sprinkler' irrigation. The result sets will match as the same Farm_id values are grouped and the same filtering condition is applied."}
{"example_id": 4217, "sql_complexity": "subqueries", "prompt": "Show consumer preference data for foundations, excluding products from the USA.", "context": "CREATE TABLE cosmetics (product_id INT, product_name VARCHAR(100), product_type VARCHAR(50), is_cruelty_free BOOLEAN, consumer_preference_score INT); INSERT INTO cosmetics (product_id, product_name, product_type, is_cruelty_free, consumer_preference_score) VALUES (1, 'Lipstick A', 'Lipstick', TRUE, 80), (2, 'Foundation B', 'Foundation', FALSE, 90), (3, 'Mascara C', 'Mascara', TRUE, 85), (4, 'Eyeshadow D', 'Eyeshadow', TRUE, 70), (5, 'Blush E', 'Blush', FALSE, 95); CREATE TABLE ingredient_sourcing (ingredient_id INT, ingredient_name VARCHAR(100), sourcing_country VARCHAR(50), is_organic BOOLEAN); INSERT INTO ingredient_sourcing (ingredient_id, ingredient_name, sourcing_country, is_organic) VALUES (1, 'Rosehip Oil', 'Chile', TRUE), (2, 'Shea Butter', 'Ghana', TRUE), (3, 'Jojoba Oil', 'India', TRUE), (4, 'Coconut Oil', 'Philippines', FALSE), (5, 'Aloe Vera', 'USA', TRUE);", "reference_sql": "SELECT * FROM cosmetics WHERE product_type = 'Foundation' AND product_id NOT IN (SELECT cosmetics.product_id FROM cosmetics INNER JOIN ingredient_sourcing ON cosmetics.product_id = ingredient_sourcing.ingredient_id WHERE ingredient_sourcing.sourcing_country = 'USA');", "generated_sql": "SELECT c.consumer_preference_score \nFROM cosmetics c\nJOIN ingredient_sourcing i ON c.product_id = i.ingredient_id\nWHERE c.product_type = 'Foundation' AND i.sourcing_country != 'USA';", "raw_model_output": "To show the consumer preference data for foundations excluding products from the USA, we need to filter the `cosmetics` table based on the product type and sourcing country. Here is the corresponding SQL query:\n\n```sql\nSELECT c.consumer_preference_score \nFROM cosmetics c\nJOIN ingredient_sourcing i ON c.product_id = i.ingredient_id\nWHERE c.product_type = 'Foundation' AND i.sourcing_country != 'USA';\n```\n\nThis query joins the `cosmetics` and `ingredient_sourcing` tables on a common key (assuming `product_id` in `cosmetics` corresponds to `ingredient_id` in `ingredient_sourcing`). It then filters for foundations (`c.product_type = 'Foundation'`) that are not sourced from the USA (`i.sourcing_country != 'USA'`).", "latency_sec": 4.344777345657349, "total_duration_sec": 4.216600807, "load_duration_sec": 0.016545673, "tokens_prompt": 972, "prompt_eval_sec": 0.381756354, "tokens_completion": 161, "completion_eval_sec": 3.814684563, "tokens_total": 1133, "tokens_per_sec": 260.77285666489803, "retrieval_latency_sec": 0.10757994651794434, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL selects all columns from 'cosmetics' where product_type is 'Foundation' and product_id is not in a subquery that excludes entries with USA-sourced ingredients. The Generated SQL selects only 'consumer_preference_score' from a join where product_type is 'Foundation' and sourcing_country is not 'USA'. The Generated SQL incorrectly joins on product_id = ingredient_id (which is not semantically meaningful) and returns rows where *any* ingredient is non-USA, while the Reference SQL excludes products with *any* USA-sourced ingredients. Additionally, the column sets differ."}
{"example_id": 5620, "sql_complexity": "basic SQL", "prompt": "What is the recycling rate of plastic in the residential sector in the state of New York?", "context": "CREATE TABLE recycling_rates_city (sector VARCHAR(20), city VARCHAR(20), material VARCHAR(20), recycling_rate DECIMAL(5,2)); INSERT INTO recycling_rates_city (sector, city, material, recycling_rate) VALUES ('residential', 'New York City', 'plastic', 0.25), ('commercial', 'New York City', 'plastic', 0.30), ('residential', 'New York City', 'paper', 0.45), ('commercial', 'New York City', 'paper', 0.50), ('residential', 'Los Angeles', 'plastic', 0.20), ('commercial', 'Los Angeles', 'plastic', 0.35), ('residential', 'Los Angeles', 'paper', 0.40), ('commercial', 'Los Angeles', 'paper', 0.50);", "reference_sql": "SELECT recycling_rate FROM recycling_rates_city WHERE sector = 'residential' AND material = 'plastic' AND city = 'New York City';", "generated_sql": "SELECT recycling_rate \nFROM recycling_rates_city \nWHERE city = 'New York City' AND material = 'plastic' AND sector = 'residential';", "raw_model_output": "Given the provided schema and question, we need to find the recycling rate of plastic in the residential sector for New York City. The table `recycling_rates_city` contains the necessary data.\n\nHere is the corresponding SQL query:\n\n```sql\nSELECT recycling_rate \nFROM recycling_rates_city \nWHERE city = 'New York City' AND material = 'plastic' AND sector = 'residential';\n```", "latency_sec": 2.6069717407226562, "total_duration_sec": 2.403568751, "load_duration_sec": 0.015439179, "tokens_prompt": 1045, "prompt_eval_sec": 0.403394935, "tokens_completion": 81, "completion_eval_sec": 1.980053242, "tokens_total": 1126, "tokens_per_sec": 431.91875938320345, "retrieval_latency_sec": 0.09385490417480469, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select the same column and apply identical WHERE conditions, though the order of conditions differs. Since SQL WHERE clauses evaluate logical AND operations regardless of order, the result sets are identical."}
{"example_id": 3151, "sql_complexity": "basic SQL", "prompt": "List all biotech startups that received funding in 2022 and their respective funding amounts.", "context": "CREATE TABLE biotech_startups (name TEXT, funding FLOAT, date DATE); INSERT INTO biotech_startups (name, funding, date) VALUES ('StartupA', 3500000, '2022-02-28'); INSERT INTO biotech_startups (name, funding, date) VALUES ('StartupB', 4500000, '2022-07-12');", "reference_sql": "SELECT name, funding FROM biotech_startups WHERE date BETWEEN '2022-01-01' AND '2022-12-31';", "generated_sql": "SELECT name, funding FROM biotech_startups WHERE date >= '2022-01-01' AND date <= '2022-12-31';", "raw_model_output": "```sql\nSELECT name, funding FROM biotech_startups WHERE date >= '2022-01-01' AND date <= '2022-12-31';\n```", "latency_sec": 1.5396089553833008, "total_duration_sec": 1.456626264, "load_duration_sec": 0.01616144, "tokens_prompt": 907, "prompt_eval_sec": 0.355194873, "tokens_completion": 44, "completion_eval_sec": 1.080957532, "tokens_total": 951, "tokens_per_sec": 617.6893143384186, "retrieval_latency_sec": 0.11186003684997559, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The BETWEEN operator in SQL is inclusive and equivalent to using >= and <= conditions. Both queries filter rows where the date falls between '2022-01-01' and '2022-12-31', inclusive. The sample data contains entries within this range, so both queries would return the same results."}
{"example_id": 2136, "sql_complexity": "window functions", "prompt": "What is the total military equipment sales revenue for each sales representative by fiscal year?", "context": "CREATE TABLE SalesReps (SalesRepID INT, SalesRepName VARCHAR(50), FiscalYear INT, Revenue DECIMAL(10,2)); INSERT INTO SalesReps (SalesRepID, SalesRepName, FiscalYear, Revenue) VALUES (1, 'John Doe', 2020, 150000.00), (2, 'Jane Smith', 2020, 200000.00), (1, 'John Doe', 2021, 180000.00), (2, 'Jane Smith', 2021, 250000.00);", "reference_sql": "SELECT SalesRepName, FiscalYear, SUM(Revenue) OVER (PARTITION BY SalesRepName ORDER BY FiscalYear) AS TotalRevenue FROM SalesReps;", "generated_sql": "SELECT SalesRepName, FiscalYear, SUM(Revenue) AS TotalRevenue\nFROM SalesReps\nGROUP BY SalesRepName, FiscalYear\nORDER BY SalesRepName, FiscalYear;", "raw_model_output": "The provided schema does not include a table for military equipment sales. However, based on the given `SalesReps` table and the question asked, we need to calculate the total revenue by each sales representative for each fiscal year.\n\nHere is the SQL statement that answers the question:\n\n```sql\nSELECT SalesRepName, FiscalYear, SUM(Revenue) AS TotalRevenue\nFROM SalesReps\nGROUP BY SalesRepName, FiscalYear\nORDER BY SalesRepName, FiscalYear;\n```\n\nThis query groups the data by `SalesRepName` and `FiscalYear`, calculates the total revenue for each group, and orders the results by `SalesRepName` and `FiscalYear`.", "latency_sec": 3.9555232524871826, "total_duration_sec": 3.660335912, "load_duration_sec": 0.019301614, "tokens_prompt": 810, "prompt_eval_sec": 0.331240076, "tokens_completion": 142, "completion_eval_sec": 3.303512733, "tokens_total": 952, "tokens_per_sec": 240.67612278638344, "retrieval_latency_sec": 0.11815810203552246, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates a running total (cumulative sum) of Revenue for each SalesRepName ordered by FiscalYear using a window function. The Generated SQL aggregates Revenue by SalesRepName and FiscalYear, returning only the individual year's Revenue instead of a cumulative sum. The results would differ: the Reference SQL shows cumulative totals (e.g., 150000 for 2020, 330000 for 2021 for John Doe), while the Generated SQL shows standalone values (150000 for 2020, 180000 for 2021)."}
{"example_id": 5452, "sql_complexity": "basic SQL", "prompt": "What is the name of the farms with a size greater than 150 acres located in 'Texas'?", "context": "CREATE TABLE farms (id INT PRIMARY KEY, name VARCHAR(50), size INT, location VARCHAR(50)); INSERT INTO farms (id, name, size, location) VALUES (1, 'Smith Farms', 200, 'Texas'), (2, 'Johnson Farms', 100, 'California');", "reference_sql": "SELECT name FROM farms WHERE size > 150 AND location = 'Texas'", "generated_sql": "SELECT name FROM farms WHERE size > 150 AND location = 'Texas';", "raw_model_output": "```sql\nSELECT name FROM farms WHERE size > 150 AND location = 'Texas';\n```", "latency_sec": 1.316922903060913, "total_duration_sec": 1.020115428, "load_duration_sec": 0.016144859, "tokens_prompt": 1029, "prompt_eval_sec": 0.395184226, "tokens_completion": 22, "completion_eval_sec": 0.605636604, "tokens_total": 1051, "tokens_per_sec": 798.0725352692776, "retrieval_latency_sec": 0.10984301567077637, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and conditions. Both select the 'name' column from the 'farms' table where 'size' is greater than 150 and 'location' is 'Texas'. The result will be the same for both queries."}
{"example_id": 5152, "sql_complexity": "aggregation", "prompt": "How many international tourists visited Portugal in 2020, broken down by continent?", "context": "CREATE TABLE international_tourists(tourist_id INT, country TEXT, arrival_year INT, continent TEXT);INSERT INTO international_tourists (tourist_id, country, arrival_year, continent) VALUES (1, 'Spain', 2020, 'Europe'), (2, 'France', 2020, 'Europe'), (3, 'Brazil', 2020, 'South America'), (4, 'United States', 2020, 'North America'), (5, 'China', 2020, 'Asia');", "reference_sql": "SELECT continent, COUNT(*) FROM international_tourists WHERE arrival_year = 2020 GROUP BY continent;", "generated_sql": "SELECT continent, COUNT(*) AS tourist_count \nFROM international_tourists \nWHERE arrival_year = 2020 AND country != 'Portugal'\nGROUP BY continent;", "raw_model_output": "The question asks for a breakdown of international tourists visiting Portugal in 2020 by continent. However, the provided schema does not include a table with visitor counts or specific data about visits to Portugal; it only contains information about tourists from different countries and continents.\n\nGiven this context, we can infer that the number of visitors to Portugal is implied by the presence of tourists from other countries in 2020. We need to count how many tourists are listed for each continent in the year 2020, assuming these represent visits to Portugal.\n\nHere's the SQL query:\n\n```sql\nSELECT continent, COUNT(*) AS tourist_count \nFROM international_tourists \nWHERE arrival_year = 2020 AND country != 'Portugal'\nGROUP BY continent;\n```\n\nThis query counts the number of tourists from each continent in 2020 (excluding Portugal itself) and groups them by continent.", "latency_sec": 5.085799217224121, "total_duration_sec": 4.7834895, "load_duration_sec": 0.015842307, "tokens_prompt": 926, "prompt_eval_sec": 0.361472194, "tokens_completion": 186, "completion_eval_sec": 4.403156713, "tokens_total": 1112, "tokens_per_sec": 218.64803396759743, "retrieval_latency_sec": 0.11943697929382324, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The generated query adds a condition 'country != 'Portugal'' which has no effect because the dataset contains no tourists from Portugal. Both queries group by continent and count tourists for 2020, producing identical results."}
{"example_id": 2477, "sql_complexity": "set operations", "prompt": "What is the carbon price in Europe and Australia for the last quarter of 2020?", "context": "CREATE TABLE CarbonPrices (Country TEXT, Year INT, Quarter INT, CarbonPrice NUMBER); INSERT INTO CarbonPrices (Country, Year, Quarter, CarbonPrice) VALUES ('Europe', 2020, 4, 25), ('Australia', 2020, 4, 15); CREATE TABLE CarbonTaxes (Country TEXT, Year INT, Quarter INT, CarbonPrice NUMBER); INSERT INTO CarbonTaxes (Country, Year, Quarter, CarbonPrice) VALUES ('Europe', 2019, 4, 20), ('Australia', 2019, 4, 10);", "reference_sql": "SELECT Context.Country, Context.CarbonPrice FROM ( SELECT * FROM CarbonPrices WHERE CarbonPrices.Country IN ('Europe', 'Australia') AND CarbonPrices.Year = 2020 AND CarbonPrices.Quarter = 4 UNION SELECT * FROM CarbonTaxes WHERE CarbonTaxes.Country IN ('Europe', 'Australia') AND CarbonTaxes.Year = 2020 AND CarbonTaxes.Quarter = 4 ) AS Context;", "generated_sql": "SELECT Country, CarbonPrice \nFROM CarbonPrices \nWHERE Year = 2020 AND Quarter = 4;", "raw_model_output": "To retrieve the carbon prices for Europe and Australia in the last quarter of 2020, we need to query both `CarbonPrices` and `CarbonTaxes` tables. However, since the question specifically asks about the last quarter of 2020, we only need to look at the `CarbonPrices` table.\n\nHere is the SQL statement:\n\n```sql\nSELECT Country, CarbonPrice \nFROM CarbonPrices \nWHERE Year = 2020 AND Quarter = 4;\n```\n\nThis query selects the carbon prices for Europe and Australia in the fourth quarter of 2020.", "latency_sec": 3.459756851196289, "total_duration_sec": 3.255970324, "load_duration_sec": 0.015510479, "tokens_prompt": 823, "prompt_eval_sec": 0.329934226, "tokens_completion": 125, "completion_eval_sec": 2.907025714, "tokens_total": 948, "tokens_per_sec": 274.0076949835962, "retrieval_latency_sec": 0.11264181137084961, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL combines data from both CarbonPrices and CarbonTaxes tables using a UNION, while the Generated SQL only queries the CarbonPrices table. Although in the provided sample data the CarbonTaxes table has no matching entries (2019 data vs 2020 filter), the queries would produce different results if CarbonTaxes had entries for 2020. The Reference SQL is broader in scope and could return additional rows from CarbonTaxes, making them non-equivalent."}
{"example_id": 4573, "sql_complexity": "subqueries", "prompt": "Find the names of all the indigenous communities in the 'Arctic_Communities' table that have a population size greater than the average population size in the 'Antarctic_Communities' table.", "context": "CREATE TABLE Arctic_Communities (name TEXT, population INTEGER); CREATE TABLE Antarctic_Communities (name TEXT, population INTEGER);", "reference_sql": "SELECT name FROM Arctic_Communities WHERE Arctic_Communities.population > (SELECT AVG(population) FROM Antarctic_Communities)", "generated_sql": "SELECT name FROM Arctic_Communities WHERE population > (SELECT AVG(population) FROM Antarctic_Communities)", "raw_model_output": "```sql\nSELECT name FROM Arctic_Communities WHERE population > (SELECT AVG(population) FROM Antarctic_Communities)\n```", "latency_sec": 0.9208550453186035, "total_duration_sec": 0.876607638, "load_duration_sec": 0.019669315, "tokens_prompt": 644, "prompt_eval_sec": 0.285926947, "tokens_completion": 25, "completion_eval_sec": 0.567240976, "tokens_total": 669, "tokens_per_sec": 726.4987072623737, "retrieval_latency_sec": 0.1166841983795166, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select names from Arctic_Communities where population exceeds the average population of Antarctic_Communities. The generated query omits the table alias in the WHERE clause, but since the column 'population' is unambiguous (only exists in Arctic_Communities), the semantic meaning remains identical."}
{"example_id": 3596, "sql_complexity": "window functions", "prompt": "What is the total revenue for each game in the \"Gaming\" category?", "context": "CREATE TABLE Games (GameID int, GameName varchar(50), Category varchar(50), Revenue decimal(10,2));", "reference_sql": "SELECT Category, SUM(Revenue) OVER(PARTITION BY Category) as TotalRevenue FROM Games;", "generated_sql": "SELECT GameName, SUM(Revenue) AS TotalRevenue \nFROM Games \nWHERE Category = 'Gaming' \nGROUP BY GameName;", "raw_model_output": "```sql\nSELECT GameName, SUM(Revenue) AS TotalRevenue \nFROM Games \nWHERE Category = 'Gaming' \nGROUP BY GameName;\n```", "latency_sec": 1.3789191246032715, "total_duration_sec": 1.144070816, "load_duration_sec": 0.017531502, "tokens_prompt": 815, "prompt_eval_sec": 0.330739655, "tokens_completion": 33, "completion_eval_sec": 0.792072119, "tokens_total": 848, "tokens_per_sec": 614.974428064429, "retrieval_latency_sec": 0.11249184608459473, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates the total revenue per category for all games, returning Category and TotalRevenue columns. The generated query filters to only 'Gaming' category, groups by GameName, and returns individual game revenues instead of category-level totals. The output structure, filtering, and aggregation logic differ significantly."}
{"example_id": 5039, "sql_complexity": "subqueries", "prompt": "What is the total number of community policing events in 'City Park' in 2021?", "context": "CREATE TABLE locations (id INT, name VARCHAR(255)); CREATE TABLE community_policing (id INT, location_id INT, year INT, events INT); INSERT INTO locations (id, name) VALUES (1, 'City Park'); INSERT INTO community_policing (id, location_id, year, events) VALUES (1, 1, 2021, 5);", "reference_sql": "SELECT SUM(events) FROM community_policing WHERE location_id = (SELECT id FROM locations WHERE name = 'City Park') AND year = 2021;", "generated_sql": "SELECT l.name, SUM(c.events) AS total_events\nFROM locations l\nJOIN community_policing c ON l.id = c.location_id\nWHERE l.name = 'City Park' AND c.year = 2021\nGROUP BY l.name;", "raw_model_output": "```sql\nSELECT l.name, SUM(c.events) AS total_events\nFROM locations l\nJOIN community_policing c ON l.id = c.location_id\nWHERE l.name = 'City Park' AND c.year = 2021\nGROUP BY l.name;\n```", "latency_sec": 1.9178318977355957, "total_duration_sec": 1.716747157, "load_duration_sec": 0.016366331, "tokens_prompt": 797, "prompt_eval_sec": 0.319257961, "tokens_completion": 58, "completion_eval_sec": 1.377885503, "tokens_total": 855, "tokens_per_sec": 445.81592422647026, "retrieval_latency_sec": 0.1114499568939209, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns a single scalar value (SUM(events)), while the Generated SQL returns a result set with two columns (name and total_events). Although both calculate the same sum, their output structures differ, making them semantically non-equivalent."}
{"example_id": 2724, "sql_complexity": "basic SQL", "prompt": "What is the earliest installation date for solar panels in Italy?", "context": "CREATE TABLE solar_panels_italy (id INT, installation_date DATE); INSERT INTO solar_panels_italy (id, installation_date) VALUES (1, '2018-01-01'), (2, '2019-01-01'), (3, '2020-01-01');", "reference_sql": "SELECT MIN(installation_date) as earliest_date FROM solar_panels_italy;", "generated_sql": "SELECT MIN(installation_date) AS earliest_installation_date \nFROM solar_panels_italy;", "raw_model_output": "To find the earliest installation date for solar panels in Italy from the `solar_panels_italy` table, you can use the following SQL query:\n\n```sql\nSELECT MIN(installation_date) AS earliest_installation_date \nFROM solar_panels_italy;\n```", "latency_sec": 1.8586390018463135, "total_duration_sec": 1.704362027, "load_duration_sec": 0.019586489, "tokens_prompt": 754, "prompt_eval_sec": 0.314039718, "tokens_completion": 58, "completion_eval_sec": 1.366322189, "tokens_total": 812, "tokens_per_sec": 436.8788125038723, "retrieval_latency_sec": 0.10548591613769531, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the minimum installation_date from the same table. The only difference is the column alias name ('earliest_date' vs 'earliest_installation_date'), which does not affect the semantic result. The MIN() function and table structure are identical in both queries."}
{"example_id": 2200, "sql_complexity": "single join", "prompt": "Which diversity programs are currently being participated in by employees in the HR department?", "context": "CREATE TABLE Employees (Employee_ID INT, First_Name VARCHAR(20), Last_Name VARCHAR(20), Department VARCHAR(20), Salary DECIMAL(10,2), Date_Hired DATE); CREATE TABLE Diversity_Programs (Program_ID INT, Program_Name VARCHAR(50), Participant_ID INT, Date_Started DATE, Date_Ended DATE);", "reference_sql": "SELECT dp.Program_Name FROM Diversity_Programs dp JOIN Employees e ON dp.Participant_ID = e.Employee_ID WHERE e.Department = 'HR' AND dp.Date_Ended IS NULL;", "generated_sql": "SELECT dp.Program_Name \nFROM Employees e\nJOIN Diversity_Programs dp ON e.Employee_ID = dp.Participant_ID\nWHERE e.Department = 'HR' AND (dp.Date_Started <= CURRENT_DATE AND (dp.Date_Ended IS NULL OR dp.Date_Ended > CURRENT_DATE));", "raw_model_output": "To find out which diversity programs are currently being participated in by employees in the HR department, we need to join the `Employees` and `Diversity_Programs` tables based on the employee IDs. We then filter for employees who work in the HR department and check if their participation dates overlap with the current date.\n\nHere is the SQL query:\n\n```sql\nSELECT dp.Program_Name \nFROM Employees e\nJOIN Diversity_Programs dp ON e.Employee_ID = dp.Participant_ID\nWHERE e.Department = 'HR' AND (dp.Date_Started <= CURRENT_DATE AND (dp.Date_Ended IS NULL OR dp.Date_Ended > CURRENT_DATE));\n```\n\nThis query selects the names of diversity programs where employees in the HR department are currently participating.", "latency_sec": 4.157423257827759, "total_duration_sec": 3.889362382, "load_duration_sec": 0.01573347, "tokens_prompt": 906, "prompt_eval_sec": 0.357035953, "tokens_completion": 150, "completion_eval_sec": 3.513488016, "tokens_total": 1056, "tokens_per_sec": 254.0034859360836, "retrieval_latency_sec": 0.11235809326171875, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL only filters for records where dp.Date_Ended IS NULL, while the Generated SQL adds an additional condition that dp.Date_Started must be <= CURRENT_DATE and (dp.Date_Ended IS NULL OR dp.Date_Ended > CURRENT_DATE). This makes the Generated SQL more restrictive by ensuring the program started before or on the current date, which the Reference SQL does not enforce."}
{"example_id": 4359, "sql_complexity": "window functions", "prompt": "Which destinations have the least hotel awards?", "context": "CREATE TABLE Destinations (destination_id INT, destination_name TEXT, country TEXT, awards INT); INSERT INTO Destinations (destination_id, destination_name, country, awards) VALUES (1, 'City A', 'Germany', 3), (2, 'City B', 'Switzerland', 5), (3, 'City C', 'Norway', 2);", "reference_sql": "SELECT destination_name, country, awards, RANK() OVER (PARTITION BY country ORDER BY awards ASC) AS rank FROM Destinations;", "generated_sql": "SELECT destination_name, country, awards \nFROM Destinations \nWHERE awards = (SELECT MIN(awards) FROM Destinations);", "raw_model_output": "To find which destinations have the least hotel awards across all countries, we need to determine the minimum number of awards and then select the destinations that match this minimum value. Here is the corresponding SQL query:\n\n```sql\nSELECT destination_name, country, awards \nFROM Destinations \nWHERE awards = (SELECT MIN(awards) FROM Destinations);\n```", "latency_sec": 2.170098066329956, "total_duration_sec": 2.039484799, "load_duration_sec": 0.015647777, "tokens_prompt": 816, "prompt_eval_sec": 0.329185676, "tokens_completion": 71, "completion_eval_sec": 1.690603833, "tokens_total": 887, "tokens_per_sec": 408.73728877150876, "retrieval_latency_sec": 0.10970187187194824, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates ranks within each country partition based on awards, while the Generated SQL filters to only include destinations with the minimum awards in the entire table. The first returns all rows with rank values, the second returns only the row(s) with the lowest awards (City C in this case)."}
{"example_id": 1373, "sql_complexity": "subqueries", "prompt": "What is the total value of military equipment sales to Africa in the last 12 months?", "context": "CREATE TABLE Military_Equipment_Sales(sale_id INT, sale_date DATE, equipment_type VARCHAR(50), country VARCHAR(50), sale_value DECIMAL(10,2));", "reference_sql": "SELECT SUM(sale_value) FROM Military_Equipment_Sales WHERE country IN (SELECT country FROM World_Countries WHERE continent = 'Africa') AND sale_date >= DATE_SUB(CURRENT_DATE, INTERVAL 12 MONTH);", "generated_sql": "SELECT SUM(sale_value) AS total_sale_value \nFROM Military_Equipment_Sales \nWHERE country IN ('Nigeria', 'Egypt', 'South Africa', /* Add other African countries here */) \nAND sale_date >= DATEADD(year, -1, CURRENT_DATE);", "raw_model_output": "To find the total value of military equipment sales to Africa in the last 12 months, we need to filter the `Military_Equipment_Sales` table for rows where the `country` is one of the African countries and the `sale_date` falls within the last year. Assuming that the list of African countries is known or can be derived from a separate table (which isn't provided in this schema), let's assume we know which countries are in Africa.\n\nHere\u2019s the SQL query:\n\n```sql\nSELECT SUM(sale_value) AS total_sale_value \nFROM Military_Equipment_Sales \nWHERE country IN ('Nigeria', 'Egypt', 'South Africa', /* Add other African countries here */) \nAND sale_date >= DATEADD(year, -1, CURRENT_DATE);\n```\n\nThis assumes that the list of African countries is known and provided in the `IN` clause. If there's a separate table for African countries, you would need to join with it.\n\nIf we assume an exact list of African countries isn't available but we know all sales are categorized by continent:\n\n```sql\nSELECT SUM(sale_value) AS total_sale_value \nFROM Military_Equipment_Sales \nWHERE country IN ('Nigeria', 'Egypt', 'South Africa', /* Add other African countries here */) \nAND sale_date >= DATEADD(year, -1, CURRENT_DATE);\n```\n\nIf you have a separate table for African countries:\n\n```sql\nSELECT SUM(s.M.sale_value) AS total_sale_value \nFROM Military_Equipment_Sales s \nJOIN African_Countries c ON s.country = c.country_name \nWHERE s.sale_date >= DATEADD(year, -1, CURRENT_DATE);\n```\n\nSince the exact schema and list of African countries isn't provided, I'll assume a direct approach with known African countries:\n\n```sql\nSELECT SUM(sale_value) AS total_sale_value \nFROM Military_Equipment_Sales \nWHERE country IN ('Nigeria', 'Egypt', 'South Africa') -- Add other African countries here\nAND sale_date >= DATEADD(year, -1, CURRENT_DATE);\n```\n\nThis query sums up the `sale_value` for sales to specified African countries within the last year.", "latency_sec": 10.564594030380249, "total_duration_sec": 10.40567296, "load_duration_sec": 0.019461253, "tokens_prompt": 613, "prompt_eval_sec": 0.2814451, "tokens_completion": 443, "completion_eval_sec": 10.099935254, "tokens_total": 1056, "tokens_per_sec": 99.95651484224535, "retrieval_latency_sec": 0.11162495613098145, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL uses a subquery to dynamically fetch all African countries from the World_Countries table, while the Generated SQL hardcodes a partial list of countries (e.g., Nigeria, Egypt, South Africa) and relies on a comment to add more. This makes the Generated SQL's country filter incomplete and static, potentially excluding valid African countries not explicitly listed. Additionally, DATE_SUB(CURRENT_DATE, INTERVAL 12 MONTH) and DATEADD(year, -1, CURRENT_DATE) are functionally equivalent for date calculations, but the core discrepancy lies in the country filtering logic."}
{"example_id": 904, "sql_complexity": "basic SQL", "prompt": "What is the minimum Shariah-compliant loan amount issued in the last quarter of 2021?", "context": "CREATE TABLE loans (id INT, amount DECIMAL, date DATE, loan_type VARCHAR); INSERT INTO loans (id, amount, date, loan_type) VALUES (1, 5000, '2021-09-05', 'Shariah-compliant'), (2, 7000, '2021-10-07', 'socially responsible'), (3, 9000, '2021-11-03', 'Shariah-compliant'), (4, 11000, '2021-12-31', 'Shariah-compliant');", "reference_sql": "SELECT MIN(amount) FROM loans WHERE EXTRACT(YEAR FROM date) = 2021 AND EXTRACT(QUARTER FROM date) = 4 AND loan_type = 'Shariah-compliant';", "generated_sql": "SELECT MIN(amount) AS min_loan_amount \nFROM loans \nWHERE loan_type = 'Shariah-compliant' AND date BETWEEN '2021-10-01' AND '2021-12-31';", "raw_model_output": "To find the minimum Shariah-compliant loan amount issued in the last quarter of 2021, we need to filter the `loans` table for entries with `loan_type` 'Shariah-compliant' and dates between October 1, 2021 and December 31, 2021. Then, we can use the MIN function to find the minimum loan amount.\n\nHere is the SQL query:\n\n```sql\nSELECT MIN(amount) AS min_loan_amount \nFROM loans \nWHERE loan_type = 'Shariah-compliant' AND date BETWEEN '2021-10-01' AND '2021-12-31';\n```", "latency_sec": 3.8842508792877197, "total_duration_sec": 3.85112052, "load_duration_sec": 0.015335258, "tokens_prompt": 897, "prompt_eval_sec": 0.351976951, "tokens_completion": 147, "completion_eval_sec": 3.479594981, "tokens_total": 1044, "tokens_per_sec": 268.77769547971246, "retrieval_latency_sec": 0.09930610656738281, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter loans with 'Shariah-compliant' type and dates in Q4 2021. The reference uses EXTRACT(QUARTER) = 4 and EXTRACT(YEAR) = 2021, while the generated query uses a date range from '2021-10-01' to '2021-12-31', which covers the same quarter. Both will select the same rows (loans 3 and 4) and return the same MIN(amount) of 9000."}
{"example_id": 3299, "sql_complexity": "set operations", "prompt": "How many schools and hospitals are there in Colombia and which ones need repairs?", "context": "CREATE TABLE schools (id INT, country VARCHAR(20), name VARCHAR(50), needs_repair BOOLEAN); CREATE TABLE hospitals (id INT, country VARCHAR(20), name VARCHAR(50), needs_repair BOOLEAN);", "reference_sql": "SELECT 'Schools' as facility_type, COUNT(*) as total, SUM(needs_repair) as repairs_needed FROM schools WHERE country = 'Colombia' UNION ALL SELECT 'Hospitals' as facility_type, COUNT(*) as total, SUM(needs_repair) as repairs_needed FROM hospitals WHERE country = 'Colombia';", "generated_sql": "SELECT name AS facility_name, needs_repair FROM schools WHERE country = 'Colombia' AND needs_repair = TRUE\nUNION ALL\nSELECT name AS facility_name, needs_repair FROM hospitals WHERE country = 'Colombia' AND needs_repair = TRUE;", "raw_model_output": "To answer the question about how many schools and hospitals are there in Colombia and which ones need repairs, we can write a query that selects from both `schools` and `hospitals` tables where the country is 'Colombia' and filters for those needing repair. We will use UNION to combine results from both tables.\n\nHere's the SQL statement:\n\n```sql\nSELECT name AS facility_name, needs_repair FROM schools WHERE country = 'Colombia' AND needs_repair = TRUE\nUNION ALL\nSELECT name AS facility_name, needs_repair FROM hospitals WHERE country = 'Colombia' AND needs_repair = TRUE;\n```\n\nThis query will return the names of all schools and hospitals in Colombia that need repairs.", "latency_sec": 4.134603023529053, "total_duration_sec": 4.103750379, "load_duration_sec": 0.015737846, "tokens_prompt": 1126, "prompt_eval_sec": 0.546017364, "tokens_completion": 151, "completion_eval_sec": 3.537577015, "tokens_total": 1277, "tokens_per_sec": 308.85673732953165, "retrieval_latency_sec": 0.09324979782104492, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL aggregates data to show total counts and repair needs per facility type (Schools/Hospitals), while the Generated SQL returns individual records of facilities needing repair. The output structure, column definitions, and data granularity differ significantly between the two queries."}
{"example_id": 907, "sql_complexity": "set operations", "prompt": "What is the total quantity of items with type 'E' or type 'F' in warehouse O and warehouse P?", "context": "CREATE TABLE warehouse_o(item_id INT, item_type VARCHAR(10), quantity INT);CREATE TABLE warehouse_p(item_id INT, item_type VARCHAR(10), quantity INT);INSERT INTO warehouse_o(item_id, item_type, quantity) VALUES (1, 'E', 200), (2, 'F', 300), (3, 'E', 50), (4, 'F', 400);INSERT INTO warehouse_p(item_id, item_type, quantity) VALUES (1, 'E', 150), (2, 'F', 250), (3, 'E', 40), (4, 'F', 350);", "reference_sql": "SELECT quantity FROM warehouse_o WHERE item_type IN ('E', 'F') UNION ALL SELECT quantity FROM warehouse_p WHERE item_type IN ('E', 'F');", "generated_sql": "SELECT quantity FROM warehouse_o WHERE item_type IN ('E', 'F') \nUNION ALL \nSELECT quantity FROM warehouse_p WHERE item_type IN ('E', 'F');", "raw_model_output": "```sql\nSELECT quantity FROM warehouse_o WHERE item_type IN ('E', 'F') \nUNION ALL \nSELECT quantity FROM warehouse_p WHERE item_type IN ('E', 'F');\n```", "latency_sec": 1.5983638763427734, "total_duration_sec": 1.452770931, "load_duration_sec": 0.016525448, "tokens_prompt": 1071, "prompt_eval_sec": 0.406935966, "tokens_completion": 40, "completion_eval_sec": 1.025546322, "tokens_total": 1111, "tokens_per_sec": 695.0857789291924, "retrieval_latency_sec": 0.10924196243286133, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select quantities from warehouse_o and warehouse_p where item_type is 'E' or 'F', using UNION ALL. The only difference is formatting (line breaks and spacing), which does not affect semantic equivalence."}
{"example_id": 1400, "sql_complexity": "single join", "prompt": "What is the maximum co-ownership duration for properties in the neighborhood of 'Chinatown' in San Francisco?'", "context": "CREATE TABLE sf_neighborhoods (neighborhood_id INT, name VARCHAR(255), city VARCHAR(255)); INSERT INTO sf_neighborhoods (neighborhood_id, name, city) VALUES (1, 'Chinatown', 'San Francisco'); CREATE TABLE co_ownership (co_ownership_id INT, property_id INT, co_owner_id INT, start_date DATE, end_date DATE); INSERT INTO co_ownership (co_ownership_id, property_id, co_owner_id, start_date, end_date) VALUES (1, 1, 2, '2010-01-01', '2020-01-01'), (2, 2, 3, '2015-01-01', '2022-01-01'); CREATE TABLE properties (property_id INT, city VARCHAR(255)); INSERT INTO properties (property_id, city) VALUES (1, 'San Francisco'), (2, 'San Francisco');", "reference_sql": "SELECT MAX(DATEDIFF(end_date, start_date)) as max_duration FROM co_ownership JOIN properties ON co_ownership.property_id = properties.property_id WHERE properties.city = 'San Francisco' AND name = 'Chinatown';", "generated_sql": "SELECT MAX(DATEDIFF(co.end_date, co.start_date)) AS max_duration\nFROM co_ownership co\nJOIN properties p ON co.property_id = p.property_id\nWHERE p.city = 'San Francisco'\nAND EXISTS (\n    SELECT 1 \n    FROM sf_neighborhoods n\n    WHERE n.neighborhood_id = (SELECT neighborhood_id FROM sf_neighborhoods WHERE name = 'Chinatown')\n      AND n.name = 'Chinatown'\n);", "raw_model_output": "To determine the maximum co-ownership duration for properties in the neighborhood of 'Chinatown' in San Francisco, we need to follow these steps:\n\n1. Identify properties located in 'San Francisco'.\n2. Filter those properties that are specifically in the 'Chinatown' neighborhood.\n3. Calculate the duration of each co-ownership period and find the maximum duration.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT MAX(DATEDIFF(co.end_date, co.start_date)) AS max_duration\nFROM co_ownership co\nJOIN properties p ON co.property_id = p.property_id\nWHERE p.city = 'San Francisco'\nAND EXISTS (\n    SELECT 1 \n    FROM sf_neighborhoods n\n    WHERE n.neighborhood_id = (SELECT neighborhood_id FROM sf_neighborhoods WHERE name = 'Chinatown')\n      AND n.name = 'Chinatown'\n);\n```\n\nThis query calculates the maximum duration of co-ownership periods for properties located in the 'Chinatown' neighborhood within San Francisco.", "latency_sec": 5.515609264373779, "total_duration_sec": 5.356323021, "load_duration_sec": 0.023235523, "tokens_prompt": 1005, "prompt_eval_sec": 0.385516057, "tokens_completion": 209, "completion_eval_sec": 4.932810797, "tokens_total": 1214, "tokens_per_sec": 220.1026109375485, "retrieval_latency_sec": 0.11363816261291504, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL is invalid because it references 'name' in the WHERE clause without joining with sf_neighborhoods. The Generated SQL attempts to fix this by using an EXISTS clause, but it incorrectly checks for the existence of a neighborhood named 'Chinatown' in the entire table (a static condition) rather than linking properties to specific neighborhoods. The Generated SQL does not properly filter properties based on their neighborhood, making the queries semantically different."}
{"example_id": 5248, "sql_complexity": "window functions", "prompt": "Find the top 5 games by rating", "context": "CREATE TABLE games (game_id INT PRIMARY KEY, name VARCHAR(50), genre VARCHAR(50), rating DECIMAL(3,2));", "reference_sql": "SELECT * FROM (SELECT name, rating, ROW_NUMBER() OVER (ORDER BY rating DESC) as rn FROM games) t WHERE rn <= 5;", "generated_sql": "SELECT name, rating FROM games ORDER BY rating DESC LIMIT 5;", "raw_model_output": "```sql\nSELECT name, rating FROM games ORDER BY rating DESC LIMIT 5;\n```", "latency_sec": 1.0858349800109863, "total_duration_sec": 0.867135788, "load_duration_sec": 0.017301442, "tokens_prompt": 862, "prompt_eval_sec": 0.352195918, "tokens_completion": 19, "completion_eval_sec": 0.4932938, "tokens_total": 881, "tokens_per_sec": 811.3571732521328, "retrieval_latency_sec": 0.09442305564880371, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the top 5 games by rating in descending order. The reference query uses ROW_NUMBER() to assign ranks and filters where rn <= 5, while the generated query uses ORDER BY with LIMIT 5. Since the ordering and limit are identical, the result sets will be the same. The ROW_NUMBER() is redundant here but does not alter the final output."}
{"example_id": 778, "sql_complexity": "single join", "prompt": "What is the maximum property price in wheelchair-accessible neighborhoods in Singapore?", "context": "CREATE TABLE Singapore_Neighborhoods (Neighborhood_Name TEXT, Wheelchair_Accessibility BOOLEAN); INSERT INTO Singapore_Neighborhoods (Neighborhood_Name, Wheelchair_Accessibility) VALUES ('Orchard', true), ('Marina Bay', true), ('Chinatown', false), ('Little India', false), ('Bugis', true); CREATE TABLE Singapore_Properties (Neighborhood_Name TEXT, Property_Price INTEGER); INSERT INTO Singapore_Properties (Neighborhood_Name, Property_Price) VALUES ('Orchard', 2000000), ('Marina Bay', 3000000), ('Chinatown', 1500000), ('Little India', 1200000), ('Bugis', 1800000);", "reference_sql": "SELECT MAX(Singapore_Properties.Property_Price) FROM Singapore_Properties INNER JOIN Singapore_Neighborhoods ON Singapore_Properties.Neighborhood_Name = Singapore_Neighborhoods.Neighborhood_Name WHERE Singapore_Neighborhoods.Wheelchair_Accessibility = true;", "generated_sql": "SELECT MAX(Property_Price) \nFROM Singapore_Properties \nWHERE Neighborhood_Name IN (SELECT Neighborhood_Name FROM Singapore_Neighborhoods WHERE Wheelchair_Accessibility = true);", "raw_model_output": "```sql\nSELECT MAX(Property_Price) \nFROM Singapore_Properties \nWHERE Neighborhood_Name IN (SELECT Neighborhood_Name FROM Singapore_Neighborhoods WHERE Wheelchair_Accessibility = true);\n```", "latency_sec": 1.3650689125061035, "total_duration_sec": 1.343465544, "load_duration_sec": 0.015866637, "tokens_prompt": 909, "prompt_eval_sec": 0.355842266, "tokens_completion": 39, "completion_eval_sec": 0.967954405, "tokens_total": 948, "tokens_per_sec": 694.4704339208672, "retrieval_latency_sec": 0.11586475372314453, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the maximum property price from neighborhoods with wheelchair accessibility. The Reference SQL uses an INNER JOIN to combine tables and filter accessible neighborhoods, while the Generated SQL uses a subquery with IN to achieve the same filtering. Since both approaches ultimately select the same subset of properties (Orchard, Marina Bay, Bugis) and compute the MAX(Property_Price), they produce identical results."}
{"example_id": 3859, "sql_complexity": "aggregation", "prompt": "What is the total number of mental health parity violations by month and year?", "context": "CREATE TABLE mental_health_parity_reports (report_id INT, violation_date DATE); INSERT INTO mental_health_parity_reports (report_id, violation_date) VALUES (1, '2022-01-01'), (2, '2022-02-15'), (3, '2022-03-05'), (4, '2022-04-20'), (5, '2021-06-12'), (6, '2021-07-28');", "reference_sql": "SELECT EXTRACT(MONTH FROM violation_date) AS month, EXTRACT(YEAR FROM violation_date) AS year, COUNT(*) FROM mental_health_parity_reports GROUP BY month, year;", "generated_sql": "SELECT \n    EXTRACT(YEAR FROM violation_date) AS violation_year,\n    EXTRACT(MONTH FROM violation_date) AS violation_month,\n    COUNT(*) AS total_violations\nFROM \n    mental_health_parity_reports\nGROUP BY \n    EXTRACT(YEAR FROM violation_date), \n    EXTRACT(MONTH FROM violation_date)\nORDER BY \n    violation_year, \n    violation_month;", "raw_model_output": "To calculate the total number of mental health parity violations by month and year, we need to extract the year and month from the `violation_date` column and then group the results accordingly. Here is the SQL query:\n\n```sql\nSELECT \n    EXTRACT(YEAR FROM violation_date) AS violation_year,\n    EXTRACT(MONTH FROM violation_date) AS violation_month,\n    COUNT(*) AS total_violations\nFROM \n    mental_health_parity_reports\nGROUP BY \n    EXTRACT(YEAR FROM violation_date), \n    EXTRACT(MONTH FROM violation_date)\nORDER BY \n    violation_year, \n    violation_month;\n```", "latency_sec": 3.607647180557251, "total_duration_sec": 3.329762219, "load_duration_sec": 0.016191883, "tokens_prompt": 698, "prompt_eval_sec": 0.29848097, "tokens_completion": 131, "completion_eval_sec": 3.011290227, "tokens_total": 829, "tokens_per_sec": 229.7896547278078, "retrieval_latency_sec": 0.11113500595092773, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries group by the same underlying expressions (year and month extracted from violation_date) and count violations. The differences are purely syntactic: column aliases differ (month/year vs violation_month/violation_year), and the generated query adds an ORDER BY clause. Since semantic equivalence ignores column aliases and ordering, the results will be identical."}
{"example_id": 3551, "sql_complexity": "multiple_joins", "prompt": "List all artists who have performed in New York and Chicago, along with their highest-earning performance.", "context": "CREATE TABLE artist_events (artist_id INT, event_id INT, earnings DECIMAL(5,2)); CREATE TABLE artists (id INT, name VARCHAR(50)); CREATE TABLE events (id INT, city VARCHAR(20));", "reference_sql": "SELECT artists.name, MAX(artist_events.earnings) FROM artists INNER JOIN artist_events ON artists.id = artist_events.artist_id INNER JOIN events ON artist_events.event_id = events.id WHERE city IN ('New York', 'Chicago') GROUP BY artists.name;", "generated_sql": "SELECT \n    a.name,\n    e.city,\n    ae.event_id,\n    MAX(ae.earnings) AS max_earnings\nFROM \n    artist_events ae\nJOIN \n    artists a ON ae.artist_id = a.id\nJOIN \n    events e ON ae.event_id = e.id\nWHERE \n    e.city IN ('New York', 'Chicago')\nGROUP BY \n    a.name, e.city\nHAVING \n    COUNT(DISTINCT CASE WHEN e.city = 'New York' THEN ae.event_id END) > 0\n    AND COUNT(DISTINCT CASE WHEN e.city = 'Chicago' THEN ae.event_id END) > 0;", "raw_model_output": "To find the artists who have performed in both New York and Chicago, along with their highest-earning performance details, we need to follow these steps:\n\n1. Join the `artist_events` table with the `artists` and `events` tables.\n2. Filter for events that took place in either New York or Chicago.\n3. Group by artist_id to find artists who have performed in both cities.\n4. Use a subquery to determine if an artist has performed in both cities.\n5. Find the highest-earning performance for each qualifying artist.\n\nHere is the SQL statement:\n\n```sql\nSELECT \n    a.name,\n    e.city,\n    ae.event_id,\n    MAX(ae.earnings) AS max_earnings\nFROM \n    artist_events ae\nJOIN \n    artists a ON ae.artist_id = a.id\nJOIN \n    events e ON ae.event_id = e.id\nWHERE \n    e.city IN ('New York', 'Chicago')\nGROUP BY \n    a.name, e.city\nHAVING \n    COUNT(DISTINCT CASE WHEN e.city = 'New York' THEN ae.event_id END) > 0\n    AND COUNT(DISTINCT CASE WHEN e.city = 'Chicago' THEN ae.event_id END) > 0;\n```\n\nThis query ensures that only artists who have performed in both New York and Chicago are listed, along with their highest-earning performance details.", "latency_sec": 6.996306896209717, "total_duration_sec": 6.946415298, "load_duration_sec": 0.020842241, "tokens_prompt": 776, "prompt_eval_sec": 0.320208526, "tokens_completion": 286, "completion_eval_sec": 6.597381224, "tokens_total": 1062, "tokens_per_sec": 151.79437033777688, "retrieval_latency_sec": 0.11345696449279785, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query groups by artist name only, returning each artist's maximum earnings across all events in New York/Chicago. The generated query groups by artist and city, adds extra columns (city, event_id), and applies a HAVING clause requiring artists to have events in *both* cities. This filters out artists with events in only one city and changes the grouping structure, leading to different results."}
{"example_id": 5168, "sql_complexity": "aggregation", "prompt": "Get the number of renewable energy projects in Australia for each project type.", "context": "CREATE TABLE renewable_projects (id INT PRIMARY KEY, project_name VARCHAR(255), project_location VARCHAR(255), project_type VARCHAR(255), capacity_mw FLOAT);", "reference_sql": "SELECT project_type, COUNT(*) FROM renewable_projects WHERE project_location = 'Australia' GROUP BY project_type;", "generated_sql": "SELECT project_type, COUNT(*) \nFROM renewable_projects \nWHERE project_location = 'Australia'\nGROUP BY project_type;", "raw_model_output": "```sql\nSELECT project_type, COUNT(*) \nFROM renewable_projects \nWHERE project_location = 'Australia'\nGROUP BY project_type;\n```", "latency_sec": 1.2248680591583252, "total_duration_sec": 0.929820877, "load_duration_sec": 0.015477705, "tokens_prompt": 581, "prompt_eval_sec": 0.279109722, "tokens_completion": 28, "completion_eval_sec": 0.631498633, "tokens_total": 609, "tokens_per_sec": 497.19640858173545, "retrieval_latency_sec": 0.10381197929382324, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. The only differences are formatting (line breaks and whitespace) which do not affect semantic meaning. Both select project_type and count rows from renewable_projects where project_location is 'Australia', grouped by project_type."}
{"example_id": 4916, "sql_complexity": "aggregation", "prompt": "What is the maximum revenue generated from selling Yttrium in India in the past 3 years?", "context": "CREATE TABLE Yttrium_Sales (id INT PRIMARY KEY, year INT, country VARCHAR(20), quantity INT, price PER_KG); INSERT INTO Yttrium_Sales (id, year, country, quantity, price) VALUES (1, 2019, 'India', 120, 40), (2, 2020, 'India', 130, 45), (3, 2021, 'India', 140, 50), (4, 2019, 'China', 150, 35), (5, 2020, 'China', 160, 40), (6, 2021, 'China', 170, 45);", "reference_sql": "SELECT MAX(quantity * price) FROM Yttrium_Sales WHERE country = 'India' GROUP BY year ORDER BY year DESC LIMIT 3;", "generated_sql": "SELECT MAX(quantity * price) AS max_revenue\nFROM Yttrium_Sales\nWHERE country = 'India' AND year >= 2019;", "raw_model_output": "To find the maximum revenue generated from selling Yttrium in India over the past three years, we need to calculate the total revenue for each year and then determine the maximum value. The revenue can be calculated as `quantity * price`.\n\nHere is the corresponding SQL query:\n\n```sql\nSELECT MAX(quantity * price) AS max_revenue\nFROM Yttrium_Sales\nWHERE country = 'India' AND year >= 2019;\n```\n\nThis query calculates the total revenue for each sale in India from 2019 onwards and then finds the maximum value of this calculated revenue.", "latency_sec": 3.3576362133026123, "total_duration_sec": 3.285990301, "load_duration_sec": 0.015926443, "tokens_prompt": 886, "prompt_eval_sec": 0.352543202, "tokens_completion": 124, "completion_eval_sec": 2.914663721, "tokens_total": 1010, "tokens_per_sec": 300.80685811002485, "retrieval_latency_sec": 0.10704207420349121, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL groups by year and returns the maximum quantity*price per year (3 rows), while the Generated SQL calculates a single maximum value across all years >= 2019. The Reference query also orders and limits results, producing different output structure and values."}
{"example_id": 812, "sql_complexity": "multiple_joins", "prompt": "What is the average salary of 'engineer' workers in each factory?", "context": "CREATE TABLE factories (factory_id INT, factory_name VARCHAR(20)); INSERT INTO factories VALUES (1, 'Factory X'), (2, 'Factory Y'), (3, 'Factory Z'); CREATE TABLE roles (role_id INT, role_name VARCHAR(20)); INSERT INTO roles VALUES (1, 'engineer'), (2, 'manager'), (3, 'assistant'); CREATE TABLE workers (worker_id INT, factory_id INT, role_id INT, salary DECIMAL(5,2)); INSERT INTO workers VALUES (1, 1, 1, 50000.00), (2, 1, 2, 70000.00), (3, 2, 1, 55000.00), (4, 2, 3, 40000.00), (5, 3, 1, 60000.00);", "reference_sql": "SELECT f.factory_name, AVG(salary) FROM workers w INNER JOIN factories f ON w.factory_id = f.factory_id INNER JOIN roles r ON w.role_id = r.role_id WHERE r.role_name = 'engineer' GROUP BY f.factory_name;", "generated_sql": "SELECT f.factory_name, AVG(w.salary) AS avg_salary\nFROM workers w\nJOIN factories f ON w.factory_id = f.factory_id\nJOIN roles r ON w.role_id = r.role_id\nWHERE r.role_name = 'engineer'\nGROUP BY f.factory_name;", "raw_model_output": "To find the average salary of 'engineer' workers in each factory, we need to join three tables: `workers`, `factories`, and `roles`. We will filter for the role 'engineer', group by the factory name, and calculate the average salary.\n\nHere is the SQL query:\n\n```sql\nSELECT f.factory_name, AVG(w.salary) AS avg_salary\nFROM workers w\nJOIN factories f ON w.factory_id = f.factory_id\nJOIN roles r ON w.role_id = r.role_id\nWHERE r.role_name = 'engineer'\nGROUP BY f.factory_name;\n```", "latency_sec": 3.409000873565674, "total_duration_sec": 3.215403338, "load_duration_sec": 0.015033854, "tokens_prompt": 853, "prompt_eval_sec": 0.34256761, "tokens_completion": 122, "completion_eval_sec": 2.853870118, "tokens_total": 975, "tokens_per_sec": 286.00755357982365, "retrieval_latency_sec": 0.10872101783752441, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average salary per factory for workers with the 'engineer' role. The differences (column alias name and explicit 'AS' keyword) do not affect the semantic result. The JOIN conditions, WHERE filter, and GROUP BY clause are identical."}
{"example_id": 5784, "sql_complexity": "set operations", "prompt": "List the number of users who have completed a workout of a specific type (e.g. Running) and have a membership status of 'Active'.", "context": "CREATE TABLE workouts (id INT, user_id INT, workout_type VARCHAR(20)); CREATE TABLE members (id INT, name VARCHAR(50), membership_status VARCHAR(20), state VARCHAR(20)); INSERT INTO workouts (id, user_id, workout_type) VALUES (1, 1, 'Running'), (2, 1, 'Cycling'), (3, 2, 'Running'), (4, 3, 'Cycling'), (5, 3, 'Swimming'), (6, 4, 'Running'), (7, 4, 'Swimming'); INSERT INTO members (id, name, membership_status, state) VALUES (1, 'John Doe', 'Active', 'Texas'), (2, 'Jane Doe', 'Inactive', 'California'), (3, 'Bob Smith', 'Active', 'Texas'), (4, 'Alice Johnson', 'Active', 'California');", "reference_sql": "SELECT COUNT(*) FROM (SELECT user_id FROM workouts WHERE workout_type = 'Running' INTERSECT SELECT id FROM members WHERE membership_status = 'Active') AS user_set;", "generated_sql": "SELECT COUNT(DISTINCT w.user_id)\nFROM workouts w\nJOIN members m ON w.user_id = m.id\nWHERE w.workout_type = 'Running' AND m.membership_status = 'Active';", "raw_model_output": "To list the number of users who have completed a workout of a specific type (e.g., Running) and have a membership status of 'Active', you can use the following SQL query:\n\n```sql\nSELECT COUNT(DISTINCT w.user_id)\nFROM workouts w\nJOIN members m ON w.user_id = m.id\nWHERE w.workout_type = 'Running' AND m.membership_status = 'Active';\n```\n\nThis query joins the `workouts` and `members` tables on the user ID, filters for users who have completed a running workout and have an active membership status, and counts the distinct number of such users.", "latency_sec": 3.7314682006835938, "total_duration_sec": 3.620945529, "load_duration_sec": 0.019721448, "tokens_prompt": 1220, "prompt_eval_sec": 0.580780667, "tokens_completion": 129, "completion_eval_sec": 3.013776474, "tokens_total": 1349, "tokens_per_sec": 361.51989711526073, "retrieval_latency_sec": 0.11583590507507324, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of unique user_ids that appear in both 'Running' workouts and active members. The Reference SQL uses INTERSECT to find the intersection of user_ids from workouts and members, while the Generated SQL uses a JOIN with conditions to achieve the same result. Both approaches ensure only users present in both datasets are counted, and COUNT(DISTINCT) in the Generated SQL mirrors the set-based nature of INTERSECT."}
{"example_id": 3038, "sql_complexity": "subqueries", "prompt": "What is the total assets of clients who have invested in mutual funds but not in stocks?", "context": "CREATE TABLE clients (client_id INT, name TEXT, age INT, gender TEXT, total_assets DECIMAL(10,2)); INSERT INTO clients VALUES (1, 'John Doe', 35, 'Male', 250000.00), (2, 'Jane Smith', 45, 'Female', 500000.00); CREATE TABLE investments (client_id INT, investment_type TEXT); INSERT INTO investments VALUES (1, 'Stocks'), (1, 'Bonds'), (2, 'Stocks'), (3, 'Mutual Funds');", "reference_sql": "SELECT c.total_assets FROM clients c INNER JOIN investments i ON c.client_id = i.client_id WHERE i.investment_type = 'Mutual Funds' AND c.client_id NOT IN (SELECT client_id FROM investments WHERE investment_type = 'Stocks');", "generated_sql": "SELECT SUM(c.total_assets) AS total_assets\nFROM clients c\nWHERE c.client_id IN (\n    SELECT i.client_id \n    FROM investments i\n    WHERE i.investment_type = 'Mutual Funds'\n)\nAND c.client_id NOT IN (\n    SELECT i.client_id \n    FROM investments i\n    WHERE i.investment_type = 'Stocks'\n);", "raw_model_output": "To find the total assets of clients who have invested in mutual funds but not in stocks, we need to:\n\n1. Identify clients who have invested in mutual funds.\n2. Ensure these clients have not invested in stocks.\n\nHere is the corresponding SQL query:\n\n```sql\nSELECT SUM(c.total_assets) AS total_assets\nFROM clients c\nWHERE c.client_id IN (\n    SELECT i.client_id \n    FROM investments i\n    WHERE i.investment_type = 'Mutual Funds'\n)\nAND c.client_id NOT IN (\n    SELECT i.client_id \n    FROM investments i\n    WHERE i.investment_type = 'Stocks'\n);\n```", "latency_sec": 4.06493616104126, "total_duration_sec": 3.564974027, "load_duration_sec": 0.01353313, "tokens_prompt": 1117, "prompt_eval_sec": 0.548763658, "tokens_completion": 130, "completion_eval_sec": 2.998035095, "tokens_total": 1247, "tokens_per_sec": 306.7698853308862, "retrieval_latency_sec": 0.10374307632446289, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL selects individual client.total_assets values from a JOIN with investments, returning multiple rows if a client has multiple 'Mutual Funds' investments. The Generated SQL aggregates total_assets using SUM and uses IN clauses to filter clients, returning a single summed value. The output structure and aggregation differ, making them non-equivalent."}
{"example_id": 1078, "sql_complexity": "basic SQL", "prompt": "What is the maximum and minimum temperature difference between any two Arctic research stations?", "context": "CREATE TABLE arctic_stations (id INT, name TEXT, location TEXT, temperature DECIMAL(5,2)); INSERT INTO arctic_stations (id, name, location, temperature) VALUES (1, 'Station A', 'Greenland', 2.3), (2, 'Station B', 'Canada', -5.2);", "reference_sql": "SELECT a.name as station1, b.name as station2, MAX(ABS(a.temperature - b.temperature)) as temp_diff FROM arctic_stations a, arctic_stations b ORDER BY temp_diff DESC LIMIT 1", "generated_sql": "SELECT MAX(T1.temperature) - MIN(T2.temperature) AS max_min_temp_difference\nFROM arctic_stations T1, arctic_stations T2;", "raw_model_output": "To find the maximum and minimum temperature difference between any two Arctic research stations, we need to calculate the difference between the highest and lowest temperatures recorded at different stations. Here is the corresponding SQL query:\n\n```sql\nSELECT MAX(T1.temperature) - MIN(T2.temperature) AS max_min_temp_difference\nFROM arctic_stations T1, arctic_stations T2;\n```\n\nThis query calculates the maximum temperature from one station (`T1`) and subtracts the minimum temperature from another station (`T2`), giving us the required difference.", "latency_sec": 3.123789072036743, "total_duration_sec": 2.981025613, "load_duration_sec": 0.032467365, "tokens_prompt": 810, "prompt_eval_sec": 0.328391111, "tokens_completion": 111, "completion_eval_sec": 2.616911215, "tokens_total": 921, "tokens_per_sec": 294.83424737109357, "retrieval_latency_sec": 0.10528087615966797, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The reference query calculates the maximum absolute temperature difference between any two stations and returns station names along with the difference. The generated query computes the difference between the maximum and minimum temperatures in the table, but does not consider pairs of stations or return station names. While both might yield the same numerical value in some cases, their result structures and logic differ fundamentally."}
{"example_id": 5015, "sql_complexity": "basic SQL", "prompt": "Calculate the average recycling rate", "context": "CREATE TABLE recycling_rates (id INT PRIMARY KEY, location VARCHAR(50), rate FLOAT);", "reference_sql": "SELECT AVG(rate) FROM recycling_rates;", "generated_sql": "SELECT AVG(rate) AS average_recycling_rate \nFROM recycling_rates;", "raw_model_output": "To calculate the average recycling rate from the `recycling_rates` table:\n\n```sql\nSELECT AVG(rate) AS average_recycling_rate \nFROM recycling_rates;\n```", "latency_sec": 1.204686164855957, "total_duration_sec": 1.128528496, "load_duration_sec": 0.016442062, "tokens_prompt": 732, "prompt_eval_sec": 0.309099604, "tokens_completion": 34, "completion_eval_sec": 0.799080455, "tokens_total": 766, "tokens_per_sec": 635.8502507510657, "retrieval_latency_sec": 0.09153008460998535, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average of the 'rate' column from the recycling_rates table. The generated query adds an alias ('average_recycling_rate') to the computed value, but this does not affect the semantic result - the numerical average remains the same. SQL aliases only change column names in the output, not the computed values."}
{"example_id": 1533, "sql_complexity": "subqueries", "prompt": "Which programs had the highest volunteer participation rate in the last quarter?", "context": "CREATE TABLE Programs (ProgramID INT, ProgramName TEXT, Budget DECIMAL(10,2), NumVolunteers INT); CREATE TABLE VolunteerEvents (EventID INT, ProgramID INT, EventDate DATE, NumVolunteers INT);", "reference_sql": "SELECT p.ProgramName, COUNT(v.EventID) / (SELECT COUNT(*) FROM VolunteerEvents WHERE EventDate >= DATEADD(quarter, -1, GETDATE())) * 100.0 AS VolunteerParticipationRate FROM Programs p INNER JOIN VolunteerEvents v ON p.ProgramID = v.ProgramID WHERE v.EventDate >= DATEADD(quarter, -1, GETDATE()) GROUP BY p.ProgramName ORDER BY VolunteerParticipationRate DESC;", "generated_sql": "SELECT p.ProgramID, p.ProgramName, SUM(v.NumVolunteers) AS TotalEventVolunteers, p.NumVolunteers AS ProgramTotalVolunteers,\n       (SUM(v.NumVolunteers) / p.NumVolunteers * 100.0) AS ParticipationRate\nFROM Programs p\nJOIN VolunteerEvents v ON p.ProgramID = v.ProgramID\nWHERE v.EventDate >= DATE_TRUNC('quarter', CURRENT_DATE - INTERVAL '3 months') \n      AND v.EventDate < DATE_TRUNC('quarter', CURRENT_DATE)\nGROUP BY p.ProgramID, p.ProgramName, p.NumVolunteers\nORDER BY ParticipationRate DESC;", "raw_model_output": "To determine which programs had the highest volunteer participation rate in the last quarter, we need to calculate the number of volunteers involved in events during that period and compare it with the total number of volunteers associated with each program. Here's how you can write the SQL query:\n\n```sql\nSELECT p.ProgramID, p.ProgramName, SUM(v.NumVolunteers) AS TotalEventVolunteers, p.NumVolunteers AS ProgramTotalVolunteers,\n       (SUM(v.NumVolunteers) / p.NumVolunteers * 100.0) AS ParticipationRate\nFROM Programs p\nJOIN VolunteerEvents v ON p.ProgramID = v.ProgramID\nWHERE v.EventDate >= DATE_TRUNC('quarter', CURRENT_DATE - INTERVAL '3 months') \n      AND v.EventDate < DATE_TRUNC('quarter', CURRENT_DATE)\nGROUP BY p.ProgramID, p.ProgramName, p.NumVolunteers\nORDER BY ParticipationRate DESC;\n```\n\nThis query does the following:\n1. Joins `Programs` and `VolunteerEvents` tables on `ProgramID`.\n2. Filters events to include only those in the last quarter.\n3. Groups by program ID, name, and total volunteers for each program.\n4. Calculates the participation rate as a percentage of event volunteers over total program volunteers.\n5. Orders results by participation rate in descending order.\n\nThis will give you the programs with the highest volunteer participation rates during the specified period.", "latency_sec": 7.042963027954102, "total_duration_sec": 7.011484003, "load_duration_sec": 0.019456267, "tokens_prompt": 794, "prompt_eval_sec": 0.32511224, "tokens_completion": 286, "completion_eval_sec": 6.659168114, "tokens_total": 1080, "tokens_per_sec": 153.34455054121267, "retrieval_latency_sec": 0.10862278938293457, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries calculate different metrics. The reference query computes the percentage of events (count) for each program relative to total events in the last quarter, while the generated query calculates the percentage of volunteers (sum of NumVolunteers) relative to the program's total volunteers. Additionally, the date filtering logic differs (DATEADD vs DATE_TRUNC) and the output columns/ grouping fields are not identical."}
{"example_id": 4021, "sql_complexity": "subqueries", "prompt": "What is the percentage of energy efficiency improvement, per sector, compared to 2015 levels?", "context": "CREATE TABLE energy_efficiency (id INT, sector VARCHAR(50), year INT, efficiency FLOAT); INSERT INTO energy_efficiency (id, sector, year, efficiency) VALUES (1, 'Industry', 2015, 100.0), (2, 'Industry', 2020, 105.0), (3, 'Residential', 2015, 100.0), (4, 'Residential', 2020, 103.0);", "reference_sql": "SELECT sector, (SUM(efficiency) / (SELECT SUM(efficiency) FROM energy_efficiency WHERE year = 2015 AND sector = e.sector) * 100.0) - 100.0 AS improvement FROM energy_efficiency e WHERE year = 2020 GROUP BY sector;", "generated_sql": "SELECT \n    e1.sector,\n    ((e2.efficiency - e1.efficiency) / e1.efficiency * 100) AS improvement_percentage\nFROM \n    energy_efficiency e1\nJOIN \n    energy_efficiency e2 ON e1.sector = e2.sector\nWHERE \n    e1.year = 2015 AND e2.year = 2020;", "raw_model_output": "To calculate the percentage of energy efficiency improvement per sector compared to 2015 levels, we need to:\n\n1. Join the table with itself on `sector` and find the difference in efficiency between 2020 and 2015.\n2. Calculate the percentage improvement based on the 2015 values.\n\nHere is the SQL statement that accomplishes this:\n\n```sql\nSELECT \n    e1.sector,\n    ((e2.efficiency - e1.efficiency) / e1.efficiency * 100) AS improvement_percentage\nFROM \n    energy_efficiency e1\nJOIN \n    energy_efficiency e2 ON e1.sector = e2.sector\nWHERE \n    e1.year = 2015 AND e2.year = 2020;\n```\n\nThis query calculates the percentage increase in efficiency from 2015 to 2020 for each sector.", "latency_sec": 5.02350115776062, "total_duration_sec": 4.956461855, "load_duration_sec": 0.016145287, "tokens_prompt": 864, "prompt_eval_sec": 0.346552445, "tokens_completion": 198, "completion_eval_sec": 4.589983464, "tokens_total": 1062, "tokens_per_sec": 211.4063412445632, "retrieval_latency_sec": 0.10442185401916504, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the percentage improvement in efficiency from 2015 to 2020 per sector. The Reference SQL uses SUM to aggregate 2020 efficiency values and compares them to 2015 sums, while the Generated SQL joins 2015 and 2020 records directly. In the given data, each sector has exactly one entry per year, making the SUM in the Reference SQL equivalent to the single value, and the join in the Generated SQL pairs corresponding 2015/2020 records. Thus, both produce identical results for the sample data."}
{"example_id": 1551, "sql_complexity": "single join", "prompt": "How many unique donors made donations in the healthcare industry in Q3 2022?", "context": "CREATE TABLE donations (id INT, donor_id INT, amount FLOAT, donation_date DATE); INSERT INTO donations (id, donor_id, amount, donation_date) VALUES (1, 7, 100, '2022-07-01'); INSERT INTO donations (id, donor_id, amount, donation_date) VALUES (2, 8, 200, '2022-09-15'); INSERT INTO donors (id, name, industry, first_donation_date DATE) VALUES (7, 'Charlie Davis', 'Healthcare', '2022-07-01'); INSERT INTO donors (id, name, industry, first_donation_date DATE) VALUES (8, 'Dana Wilson', 'Healthcare', '2022-09-15');", "reference_sql": "SELECT COUNT(DISTINCT donor_id) FROM donations d JOIN donors don ON d.donor_id = don.id WHERE industry = 'Healthcare' AND donation_date BETWEEN '2022-07-01' AND '2022-09-30';", "generated_sql": "SELECT COUNT(DISTINCT d.donor_id) AS unique_donors\nFROM donations d\nJOIN donors do ON d.donor_id = do.id\nWHERE d.donation_date BETWEEN '2022-07-01' AND '2022-09-30'\n  AND do.industry = 'Healthcare';", "raw_model_output": "To find the number of unique donors who made donations in the healthcare industry during Q3 2022, we need to join the `donations` and `donors` tables on `donor_id`, filter by the donation date range for Q3 2022, and ensure that the donor's industry is 'Healthcare'. Here\u2019s the SQL query:\n\n```sql\nSELECT COUNT(DISTINCT d.donor_id) AS unique_donors\nFROM donations d\nJOIN donors do ON d.donor_id = do.id\nWHERE d.donation_date BETWEEN '2022-07-01' AND '2022-09-30'\n  AND do.industry = 'Healthcare';\n```", "latency_sec": 4.209496021270752, "total_duration_sec": 4.072323769, "load_duration_sec": 0.021518266, "tokens_prompt": 1031, "prompt_eval_sec": 0.402916969, "tokens_completion": 154, "completion_eval_sec": 3.644055437, "tokens_total": 1185, "tokens_per_sec": 281.5063831898516, "retrieval_latency_sec": 0.09149479866027832, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count distinct donor_ids from donations joined with donors where industry is 'Healthcare' and donation_date falls between '2022-07-01' and '2022-09-30'. The only difference is table alias names (don vs do), which does not affect semantic meaning."}
{"example_id": 2592, "sql_complexity": "window functions", "prompt": "What is the third highest account balance for Shariah-compliant finance customers?", "context": "CREATE TABLE shariah_compliant_finance(customer_id INT, account_balance DECIMAL(10, 2)); INSERT INTO shariah_compliant_finance VALUES (1, 5000), (2, 7000), (3, 6000), (4, 8000), (5, 9000);", "reference_sql": "SELECT account_balance FROM (SELECT account_balance, RANK() OVER (ORDER BY account_balance DESC) as rn FROM shariah_compliant_finance) t WHERE rn = 3;", "generated_sql": "SELECT account_balance \nFROM (\n    SELECT account_balance, ROW_NUMBER() OVER (ORDER BY account_balance DESC) AS rn \n    FROM shariah_compliant_finance\n) t \nWHERE rn = 3;", "raw_model_output": "To find the third highest account balance for Shariah-compliant finance customers, you can use the `ROW_NUMBER()` window function to rank the balances in descending order and then select the row with a rank of 3.\n\nHere is the corresponding SQL query:\n\n```sql\nSELECT account_balance \nFROM (\n    SELECT account_balance, ROW_NUMBER() OVER (ORDER BY account_balance DESC) AS rn \n    FROM shariah_compliant_finance\n) t \nWHERE rn = 3;\n```", "latency_sec": 2.77333402633667, "total_duration_sec": 2.742632179, "load_duration_sec": 0.02189814, "tokens_prompt": 892, "prompt_eval_sec": 0.355894859, "tokens_completion": 100, "completion_eval_sec": 2.357938264, "tokens_total": 992, "tokens_per_sec": 357.69221831181466, "retrieval_latency_sec": 0.10951495170593262, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in how they handle tied values. RANK() assigns the same rank to ties and skips subsequent ranks, while ROW_NUMBER() assigns unique ranks without skipping. Although the provided data has unique account balances (so both return 7000), they are not semantically equivalent in general cases with duplicate values."}
{"example_id": 3795, "sql_complexity": "single join", "prompt": "What is the total quantity of unsold garments for each manufacturer based in 'Italy' or 'Spain'?", "context": "CREATE TABLE manufacturers (id INT PRIMARY KEY, name VARCHAR(255), country VARCHAR(255)); CREATE TABLE garments (id INT PRIMARY KEY, manufacturer_id INT, quantity_manufactured INT, quantity_sold INT);", "reference_sql": "SELECT m.name, SUM(g.quantity_manufactured - g.quantity_sold) as total_unsold_quantity FROM manufacturers m JOIN garments g ON m.id = g.manufacturer_id WHERE m.country IN ('Italy', 'Spain') GROUP BY m.name;", "generated_sql": "SELECT m.name AS manufacturer_name, SUM(g.quantity_manufactured - g.quantity_sold) AS unsold_quantity\nFROM garments g\nJOIN manufacturers m ON g.manufacturer_id = m.id\nWHERE m.country IN ('Italy', 'Spain')\nGROUP BY m.name;", "raw_model_output": "```sql\nSELECT m.name AS manufacturer_name, SUM(g.quantity_manufactured - g.quantity_sold) AS unsold_quantity\nFROM garments g\nJOIN manufacturers m ON g.manufacturer_id = m.id\nWHERE m.country IN ('Italy', 'Spain')\nGROUP BY m.name;\n```", "latency_sec": 1.9816851615905762, "total_duration_sec": 1.813138393, "load_duration_sec": 0.015380738, "tokens_prompt": 937, "prompt_eval_sec": 0.366998237, "tokens_completion": 59, "completion_eval_sec": 1.426264778, "tokens_total": 996, "tokens_per_sec": 502.6025421720231, "retrieval_latency_sec": 0.11132287979125977, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same data by joining manufacturers and garments tables on manufacturer_id, filtering by country ('Italy' or 'Spain'), and grouping by manufacturer name. The differences are purely syntactic: the generated query reverses the JOIN order and uses different column aliases, which do not affect the result set's content or structure."}
{"example_id": 4138, "sql_complexity": "window functions", "prompt": "How many lifelong learning courses has a student with ID '2' completed, in chronological order?", "context": "CREATE TABLE lifelong_learning (student_id INT, course_id INT, completion_date DATE); INSERT INTO lifelong_learning VALUES (2, 1001, '2015-01-01'), (2, 1002, '2016-01-01');", "reference_sql": "SELECT student_id, course_id, COUNT(course_id) OVER (PARTITION BY student_id ORDER BY completion_date) as completed_courses FROM lifelong_learning WHERE student_id = 2;", "generated_sql": "SELECT student_id, course_id, COUNT(course_id) OVER (PARTITION BY student_id ORDER BY completion_date) AS completed_courses\nFROM lifelong_learning\nWHERE student_id = 2;", "raw_model_output": "To answer the question \"How many lifelong learning courses has a student with ID '2' completed, in chronological order?\", we need to retrieve and count the number of courses for that specific student. We can use `COUNT` along with an appropriate ordering clause.\n\nHere is the corresponding SQL query:\n\n```sql\nSELECT student_id, course_id, COUNT(course_id) OVER (PARTITION BY student_id ORDER BY completion_date) AS completed_courses\nFROM lifelong_learning\nWHERE student_id = 2;\n```\n\nThis query will return each course that the student with ID '2' has completed along with a cumulative count of courses in chronological order.", "latency_sec": 3.4953601360321045, "total_duration_sec": 3.459471325, "load_duration_sec": 0.016029727, "tokens_prompt": 978, "prompt_eval_sec": 0.381928439, "tokens_completion": 130, "completion_eval_sec": 3.057159671, "tokens_total": 1108, "tokens_per_sec": 316.99165661876253, "retrieval_latency_sec": 0.11548805236816406, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select student_id, course_id, and a window function COUNT(course_id) over the same partitioning and ordering. The WHERE clause is the same, and the only differences are formatting (line breaks and optional AS keyword), which do not affect semantic equivalence."}
{"example_id": 312, "sql_complexity": "aggregation", "prompt": "List the top 3 most represented ethnicities in movies produced in the USA.", "context": "CREATE TABLE movies (title VARCHAR(255), production_country VARCHAR(64), lead_actor_ethnicity VARCHAR(64));", "reference_sql": "SELECT lead_actor_ethnicity, COUNT(*) AS count FROM movies WHERE production_country = 'USA' GROUP BY lead_actor_ethnicity ORDER BY count DESC LIMIT 3;", "generated_sql": "SELECT lead_actor_ethnicity, COUNT(*) AS movie_count \nFROM movies \nWHERE production_country = 'USA' \nGROUP BY lead_actor_ethnicity \nORDER BY movie_count DESC \nLIMIT 3;", "raw_model_output": "To list the top 3 most represented ethnicities in movies produced in the USA, we need to filter the `movies` table for entries where the production country is \"USA\" and then group by the lead actor's ethnicity. We will count the number of movies per ethnicity and order them in descending order to get the top 3.\n\nHere is the SQL query:\n\n```sql\nSELECT lead_actor_ethnicity, COUNT(*) AS movie_count \nFROM movies \nWHERE production_country = 'USA' \nGROUP BY lead_actor_ethnicity \nORDER BY movie_count DESC \nLIMIT 3;\n```", "latency_sec": 3.2808659076690674, "total_duration_sec": 3.189036562, "load_duration_sec": 0.018404343, "tokens_prompt": 833, "prompt_eval_sec": 0.34055808, "tokens_completion": 121, "completion_eval_sec": 2.826398321, "tokens_total": 954, "tokens_per_sec": 290.77689452958515, "retrieval_latency_sec": 0.1085050106048584, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. The only difference is the column alias name ('count' vs 'movie_count'), which does not affect the query's logic, result set structure, or data returned. Both queries filter USA production movies, group by lead actor ethnicity, count entries, order by count descending, and limit to 3 results."}
{"example_id": 4298, "sql_complexity": "single join", "prompt": "How many users joined the gym in Q1 2023?", "context": "CREATE TABLE memberships (id INT, user_id INT, join_date DATE); INSERT INTO memberships (id, user_id, join_date) VALUES (1, 5, '2023-01-15'), (2, 6, '2023-02-03'), (3, 7, '2023-03-20'), (4, 8, '2022-12-31');", "reference_sql": "SELECT COUNT(*) FROM memberships WHERE join_date BETWEEN '2023-01-01' AND '2023-03-31';", "generated_sql": "SELECT COUNT(*) \nFROM memberships \nWHERE join_date >= '2023-01-01' AND join_date <= '2023-03-31';", "raw_model_output": "To find the number of users who joined in Q1 2023, we need to filter the `join_date` column for dates between '2023-01-01' and '2023-03-31'. Here is the corresponding SQL query:\n\n```sql\nSELECT COUNT(*) \nFROM memberships \nWHERE join_date >= '2023-01-01' AND join_date <= '2023-03-31';\n```", "latency_sec": 3.186800956726074, "total_duration_sec": 3.095972818, "load_duration_sec": 0.015788102, "tokens_prompt": 1263, "prompt_eval_sec": 0.593690642, "tokens_completion": 106, "completion_eval_sec": 2.481798402, "tokens_total": 1369, "tokens_per_sec": 429.5844072440682, "retrieval_latency_sec": 0.11668872833251953, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter memberships where join_date is between '2023-01-01' and '2023-03-31' inclusive. The BETWEEN operator in the reference query includes both endpoints, and the generated query explicitly uses >= and <= to achieve the same inclusive range. The dataset shows 3 entries within this range (1, 2, 3), so both would return COUNT(*) = 3."}
{"example_id": 5211, "sql_complexity": "multiple_joins", "prompt": "What is the average transaction value in the last week, split by product category and customer demographics?", "context": "CREATE TABLE transactions (transaction_id INT, customer_id INT, product_id INT, category_id INT, transaction_date DATE, amount DECIMAL(10,2)); CREATE TABLE customers (customer_id INT, age INT, gender VARCHAR(10), location VARCHAR(255)); CREATE TABLE products (product_id INT, name VARCHAR(255), category_id INT);", "reference_sql": "SELECT c.age, c.gender, p.category_id, AVG(t.amount) as avg_transaction_value FROM transactions t INNER JOIN customers c ON t.customer_id = c.customer_id INNER JOIN products p ON t.product_id = p.product_id WHERE t.transaction_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 WEEK) GROUP BY c.age, c.gender, p.category_id;", "generated_sql": "SELECT p.category_id, c.age, c.gender, AVG(t.amount) AS avg_transaction_value \nFROM transactions t \nINNER JOIN customers c ON t.customer_id = c.customer_id \nWHERE t.transaction_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 WEEK)\nGROUP BY p.category_id, c.age, c.gender;", "raw_model_output": "To find the average transaction value in the last week split by product category and customer demographics (age and gender), you can use the following SQL query:\n\n```sql\nSELECT p.category_id, c.age, c.gender, AVG(t.amount) AS avg_transaction_value \nFROM transactions t \nINNER JOIN customers c ON t.customer_id = c.customer_id \nWHERE t.transaction_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 WEEK)\nGROUP BY p.category_id, c.age, c.gender;\n```", "latency_sec": 2.9412291049957275, "total_duration_sec": 2.729434321, "load_duration_sec": 0.015498273, "tokens_prompt": 875, "prompt_eval_sec": 0.35425296, "tokens_completion": 100, "completion_eval_sec": 2.355216218, "tokens_total": 975, "tokens_per_sec": 331.4940676820945, "retrieval_latency_sec": 0.11261630058288574, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The generated SQL is missing the join with the products table. While the reference query joins transactions, customers, and products tables, the generated query only joins transactions and customers. The SELECT clause in the generated query references p.category_id, which is undefined because the products table is not joined. This makes the generated query invalid and semantically different from the reference."}
{"example_id": 382, "sql_complexity": "window functions", "prompt": "What is the average annual precipitation in the past 10 years for each weather station?", "context": "CREATE TABLE WeatherStation (ID INT, Name VARCHAR(100), Location VARCHAR(100), Elevation FLOAT, AnnualPrecipitation FLOAT); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (1, 'Station A', 'Arctic Circle', 100, 450); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (2, 'Station B', 'North Pole', 200, 300);", "reference_sql": "SELECT Name, AVG(AnnualPrecipitation) OVER (PARTITION BY Name ORDER BY Name ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS AvgAnnualPrecipitation FROM WeatherStation WHERE YEAR(CurrentDate) - YEAR(DateInstalled) BETWEEN 1 AND 10;", "generated_sql": "SELECT ws.Name AS StationName, AVG(wd.AnnualPrecipitation) AS AvgAnnualPrecipitation\nFROM WeatherStation ws\nJOIN (\n    SELECT StationID, AnnualPrecipitation, Year\n    FROM WeatherData\n    WHERE Year >= (CURRENT_DATE - INTERVAL '10 years')\n) wd ON ws.ID = wd.StationID\nGROUP BY ws.Name;", "raw_model_output": "The provided schema does not include historical weather data or a way to filter by date ranges. Therefore, it's impossible to calculate the average annual precipitation for each station over the past 10 years based on the given information.\n\nHowever, if we assume that there is another table `WeatherData` with columns like `StationID`, `Year`, and `AnnualPrecipitation`, the SQL query would look something like this:\n\n```sql\nSELECT ws.Name AS StationName, AVG(wd.AnnualPrecipitation) AS AvgAnnualPrecipitation\nFROM WeatherStation ws\nJOIN (\n    SELECT StationID, AnnualPrecipitation, Year\n    FROM WeatherData\n    WHERE Year >= (CURRENT_DATE - INTERVAL '10 years')\n) wd ON ws.ID = wd.StationID\nGROUP BY ws.Name;\n```\n\nIf such a table does not exist and only the `WeatherStation` table is available with no historical data, then it's impossible to answer this question accurately. Please provide additional tables or columns if you want to calculate the average annual precipitation over multiple years.", "latency_sec": 5.917162895202637, "total_duration_sec": 5.705070084, "load_duration_sec": 0.017043435, "tokens_prompt": 1118, "prompt_eval_sec": 0.542473496, "tokens_completion": 220, "completion_eval_sec": 5.142012012, "tokens_total": 1338, "tokens_per_sec": 226.12188031612055, "retrieval_latency_sec": 0.11361312866210938, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL references non-existent columns (DateInstalled, CurrentDate) and uses a window function, while the Generated SQL references a non-existent WeatherData table and uses an aggregate GROUP BY. Both queries operate on different schema structures and contain invalid references according to the provided database schema."}
{"example_id": 2190, "sql_complexity": "single join", "prompt": "What is the total number of humanitarian assistance events by each country in the last 3 years?", "context": "CREATE TABLE Humanitarian_Assistance (id INT, country VARCHAR(50), year INT, events INT); CREATE TABLE Countries (id INT, name VARCHAR(50), region VARCHAR(50));", "reference_sql": "SELECT co.name, SUM(ha.events) FROM Humanitarian_Assistance ha INNER JOIN Countries co ON ha.country = co.name WHERE ha.year BETWEEN (YEAR(CURRENT_DATE) - 3) AND YEAR(CURRENT_DATE) GROUP BY co.name;", "generated_sql": "SELECT h.country, SUM(h.events) AS total_events \nFROM Humanitarian_Assistance h \nWHERE h.year >= (YEAR(CURRENT_DATE) - 3)\nGROUP BY h.country;", "raw_model_output": "To find the total number of humanitarian assistance events by each country in the last 3 years, we need to filter the `Humanitarian_Assistance` table for records where the year is within the last three years and then group the results by country.\n\nHere's the corresponding SQL query:\n\n```sql\nSELECT h.country, SUM(h.events) AS total_events \nFROM Humanitarian_Assistance h \nWHERE h.year >= (YEAR(CURRENT_DATE) - 3)\nGROUP BY h.country;\n```\n\nThis query uses `SUM` to calculate the total number of events for each country and filters records based on the year being within the last three years. The `CURRENT_DATE` function is used to get the current date, from which we subtract 3 years to filter the data accordingly.", "latency_sec": 4.4083662033081055, "total_duration_sec": 4.212187904, "load_duration_sec": 0.015889328, "tokens_prompt": 1042, "prompt_eval_sec": 0.403018466, "tokens_completion": 158, "completion_eval_sec": 3.787799987, "tokens_total": 1200, "tokens_per_sec": 272.20969054238316, "retrieval_latency_sec": 0.0971992015838623, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference query joins with the Countries table and groups by co.name, while the Generated query does not join and groups by h.country. The JOIN in the Reference could filter out countries not present in the Countries table, leading to different results. Additionally, the WHERE clause in the Reference uses BETWEEN (inclusive) while the Generated uses >=, but this difference is minor and does not affect equivalence. The absence of the JOIN in the Generated query makes the queries non-equivalent."}
{"example_id": 1852, "sql_complexity": "set operations", "prompt": "Compare coal production and employment rates in China and India between 2018 and 2020.", "context": "CREATE TABLE china_coal_production (year INT, production FLOAT); INSERT INTO china_coal_production (year, production) VALUES (2018, 3500.0), (2019, 3600.0), (2020, 3700.0); CREATE TABLE china_employment (year INT, employment FLOAT); INSERT INTO china_employment (year, employment) VALUES (2018, 8000000.0), (2019, 8100000.0), (2020, 8200000.0); CREATE TABLE india_coal_production (year INT, production FLOAT); INSERT INTO india_coal_production (year, production) VALUES (2018, 700.0), (2019, 750.0), (2020, 800.0); CREATE TABLE india_employment (year INT, employment FLOAT); INSERT INTO india_employment (year, employment) VALUES (2018, 1000000.0), (2019, 1050000.0), (2020, 1100000.0);", "reference_sql": "SELECT 'China' AS country, china_coal_production.production, china_employment.employment FROM china_coal_production INNER JOIN china_employment ON china_coal_production.year = china_employment.year WHERE china_coal_production.year BETWEEN 2018 AND 2020 UNION ALL SELECT 'India', india_coal_production.production, india_employment.employment FROM india_coal_production INNER JOIN india_employment ON india_coal_production.year = india_employment.year WHERE india_coal_production.year BETWEEN 2018 AND 2020;", "generated_sql": "SELECT \n    ccp.year AS year,\n    ccp.production AS china_production,\n    ce.employment AS china_employment,\n    icp.production AS india_production,\n    ie.employment AS india_employment\nFROM \n    china_coal_production ccp\nJOIN \n    china_employment ce ON ccp.year = ce.year\nJOIN \n    india_coal_production icp ON ccp.year = icp.year\nJOIN \n    india_employment ie ON ccp.year = ie.year\nWHERE \n    ccp.year BETWEEN 2018 AND 2020;", "raw_model_output": "To compare coal production and employment rates in China and India between 2018 and 2020, we need to join the relevant tables for each country and extract the required data. Here is the SQL statement:\n\n```sql\nSELECT \n    ccp.year AS year,\n    ccp.production AS china_production,\n    ce.employment AS china_employment,\n    icp.production AS india_production,\n    ie.employment AS india_employment\nFROM \n    china_coal_production ccp\nJOIN \n    china_employment ce ON ccp.year = ce.year\nJOIN \n    india_coal_production icp ON ccp.year = icp.year\nJOIN \n    india_employment ie ON ccp.year = ie.year\nWHERE \n    ccp.year BETWEEN 2018 AND 2020;\n```\n\nThis query joins the `china_coal_production`, `china_employment`, `india_coal_production`, and `india_employment` tables on the year column, ensuring that we get the production and employment data for both China and India for each year from 2018 to 2020.", "latency_sec": 6.10796332359314, "total_duration_sec": 6.01718658, "load_duration_sec": 0.015746914, "tokens_prompt": 1282, "prompt_eval_sec": 0.600926275, "tokens_completion": 230, "completion_eval_sec": 5.396223407, "tokens_total": 1512, "tokens_per_sec": 247.54569074762122, "retrieval_latency_sec": 0.09431600570678711, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two rows per year (China and India) with separate production/employment values, while the Generated SQL returns one row per year with all four columns (China and India production/employment combined). The structure and number of rows differ, making them non-equivalent."}
{"example_id": 2535, "sql_complexity": "subqueries", "prompt": "What is the maximum safety rating for vehicles in the vehiclesafety schema?", "context": "CREATE TABLE VehicleSafety (id INT, vehicle_id INT, safetyrating INT, PRIMARY KEY (id)); CREATE TABLE Vehicles (id INT, make VARCHAR(50), model VARCHAR(50), PRIMARY KEY (id)); CREATE TABLE LuxuryVehicles (id INT, vehicle_id INT, PRIMARY KEY (id), FOREIGN KEY (vehicle_id) REFERENCES Vehicles(id));", "reference_sql": "SELECT MAX(safetyrating) FROM vehicleSafety JOIN Vehicles ON vehicleSafety.vehicle_id = Vehicles.id WHERE EXISTS (SELECT * FROM LuxuryVehicles WHERE Vehicles.id = LuxuryVehicles.vehicle_id);", "generated_sql": "SELECT MAX(safetyrating) AS max_safety_rating FROM VehicleSafety;", "raw_model_output": "To find the maximum safety rating for vehicles in the `VehicleSafety` schema, we can directly use the `MAX()` aggregation function on the `safetyrating` column:\n\n```sql\nSELECT MAX(safetyrating) AS max_safety_rating FROM VehicleSafety;\n```", "latency_sec": 1.844538927078247, "total_duration_sec": 1.62353837, "load_duration_sec": 0.015548194, "tokens_prompt": 754, "prompt_eval_sec": 0.313327005, "tokens_completion": 55, "completion_eval_sec": 1.290540496, "tokens_total": 809, "tokens_per_sec": 438.59199072662426, "retrieval_latency_sec": 0.09769916534423828, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters vehicles that exist in LuxuryVehicles via the EXISTS clause, while the Generated SQL retrieves the maximum safetyrating from all entries in VehicleSafety without any filtering. The Generated SQL lacks the join and exists condition, so it may include safety ratings from non-luxury vehicles, leading to potentially different results."}
{"example_id": 2140, "sql_complexity": "aggregation", "prompt": "What was the total amount of minerals extracted in the 'north' region for each month in 2020?", "context": "CREATE TABLE extraction(id INT, location TEXT, month INT, year INT, minerals_extracted FLOAT);INSERT INTO extraction(id, location, month, year, minerals_extracted) VALUES (1, 'north', 1, 2020, 1500), (2, 'north', 2, 2020, 1800), (3, 'south', 1, 2020, 1200);", "reference_sql": "SELECT month, SUM(minerals_extracted) FROM extraction WHERE location = 'north' AND year = 2020 GROUP BY month;", "generated_sql": "SELECT month, SUM(minerals_extracted) AS total_minerals\nFROM extraction\nWHERE location = 'north' AND year = 2020\nGROUP BY month;", "raw_model_output": "To find the total amount of minerals extracted in the 'north' region for each month in 2020, we need to group by `month` and sum the `minerals_extracted`. Here is the corresponding SQL query:\n\n```sql\nSELECT month, SUM(minerals_extracted) AS total_minerals\nFROM extraction\nWHERE location = 'north' AND year = 2020\nGROUP BY month;\n```", "latency_sec": 2.7997403144836426, "total_duration_sec": 2.557275313, "load_duration_sec": 0.019432843, "tokens_prompt": 958, "prompt_eval_sec": 0.378073488, "tokens_completion": 89, "completion_eval_sec": 2.153352937, "tokens_total": 1047, "tokens_per_sec": 373.96325458602354, "retrieval_latency_sec": 0.12185192108154297, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same data by selecting 'month' and summing 'minerals_extracted' for 'north' locations in 2020, grouped by 'month'. The generated query adds an alias ('total_minerals') to the sum, but this does not affect the semantic result set's content or structure."}
{"example_id": 4779, "sql_complexity": "window functions", "prompt": "What is the average CO2 emission for the top 3 highest emitting countries since 2015?", "context": "CREATE TABLE emissions (country VARCHAR(50), year INT, co2_emission INT); INSERT INTO emissions (country, year, co2_emission) VALUES ('USA', 2015, 5373978000); INSERT INTO emissions (country, year, co2_emission) VALUES ('China', 2015, 10498600000); INSERT INTO emissions (country, year, co2_emission) VALUES ('India', 2015, 2633830000); INSERT INTO emissions (country, year, co2_emission) VALUES ('USA', 2016, 5518004000); INSERT INTO emissions (country, year, co2_emission) VALUES ('China', 2016, 10813000000); INSERT INTO emissions (country, year, co2_emission) VALUES ('India', 2016, 2799280000);", "reference_sql": "SELECT AVG(co2_emission) as avg_emission FROM (SELECT country, year, co2_emission, ROW_NUMBER() OVER (ORDER BY co2_emission DESC) as rn FROM emissions WHERE year >= 2015) t WHERE rn <= 3 GROUP BY country;", "generated_sql": "SELECT AVG(co2_emission) AS avg_co2_emission\nFROM (\n    SELECT country, SUM(co2_emission) AS total_emission\n    FROM emissions\n    WHERE year >= 2015\n    GROUP BY country\n    ORDER BY total_emission DESC\n    LIMIT 3\n) AS top_countries;", "raw_model_output": "To find the average CO2 emission for the top 3 highest emitting countries since 2015, we need to follow these steps:\n\n1. Filter records from the year 2015 onwards.\n2. Group by country and calculate the total CO2 emissions per country.\n3. Rank countries based on their total CO2 emissions in descending order.\n4. Select the top 3 countries.\n5. Calculate the average CO2 emission for these top 3 countries.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT AVG(co2_emission) AS avg_co2_emission\nFROM (\n    SELECT country, SUM(co2_emission) AS total_emission\n    FROM emissions\n    WHERE year >= 2015\n    GROUP BY country\n    ORDER BY total_emission DESC\n    LIMIT 3\n) AS top_countries;\n```\n\nThis query first calculates the total CO2 emission for each country since 2015, ranks them in descending order of their total emissions, selects the top 3 countries, and then computes the average CO2 emission for these countries.", "latency_sec": 6.176692962646484, "total_duration_sec": 5.867655102, "load_duration_sec": 0.01609709, "tokens_prompt": 1080, "prompt_eval_sec": 0.406853474, "tokens_completion": 228, "completion_eval_sec": 5.44047252, "tokens_total": 1308, "tokens_per_sec": 211.76380433836076, "retrieval_latency_sec": 0.11549806594848633, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL calculates the average of the top 3 co2_emission values (per country-year) grouped by country, while the Generated SQL sums emissions per country, selects the top 3 countries by total emissions, and averages those totals. The Reference SQL's subquery uses ROW_NUMBER() on individual rows, whereas the Generated SQL aggregates by country first and then ranks."}
{"example_id": 1015, "sql_complexity": "subqueries", "prompt": "List the top 3 most expensive eco-friendly products in Europe and their suppliers.", "context": "CREATE TABLE Suppliers (supplierID INT, supplierName VARCHAR(50), country VARCHAR(50)); CREATE TABLE Products (productID INT, productName VARCHAR(50), price DECIMAL(10,2), ecoFriendly BOOLEAN, supplierID INT);", "reference_sql": "SELECT P.productName, P.price, S.supplierName FROM (SELECT * FROM Products WHERE ecoFriendly = TRUE ORDER BY price DESC LIMIT 3) P JOIN Suppliers S ON P.supplierID = S.supplierID;", "generated_sql": "SELECT p.productName, s.supplierName, p.price \nFROM Products p\nJOIN Suppliers s ON p.supplierID = s.supplierID\nWHERE p.ecoFriendly = TRUE AND s.country IN ('Europe', 'European Union')\nORDER BY p.price DESC\nLIMIT 3;", "raw_model_output": "To list the top 3 most expensive eco-friendly products in Europe and their suppliers, we need to join the `Products` and `Suppliers` tables, filter for eco-friendly products with European suppliers, order by price in descending order, and limit the results to the top 3.\n\nHere is the SQL query:\n\n```sql\nSELECT p.productName, s.supplierName, p.price \nFROM Products p\nJOIN Suppliers s ON p.supplierID = s.supplierID\nWHERE p.ecoFriendly = TRUE AND s.country IN ('Europe', 'European Union')\nORDER BY p.price DESC\nLIMIT 3;\n```\n\nNote: The `country` column in the `Suppliers` table should contain values like 'Europe' or 'European Union'. If there are specific country codes for European countries, you would need to list them accordingly.", "latency_sec": 4.47749924659729, "total_duration_sec": 4.426285621, "load_duration_sec": 0.016438738, "tokens_prompt": 868, "prompt_eval_sec": 0.352915491, "tokens_completion": 173, "completion_eval_sec": 4.052784195, "tokens_total": 1041, "tokens_per_sec": 232.4958515160256, "retrieval_latency_sec": 0.10413217544555664, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Generated SQL includes an additional WHERE condition (s.country IN ('Europe', 'European Union')) that is not present in the Reference SQL. This restricts results to suppliers in Europe, while the Reference SQL has no such restriction. Additionally, the column order in the SELECT clause differs but does not affect semantic equivalence."}
{"example_id": 3715, "sql_complexity": "aggregation", "prompt": "What is the average age of engines still in service for each engine type?", "context": "CREATE TABLE Engine (id INT, aircraft_id INT, engine_type VARCHAR(255), hours_since_last_service INT, manufacture_year INT); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (1, 1, 'GE90-115B', 500, 2000); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (2, 2, 'CFM56-5B', 1000, 1995); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (3, 1, 'GE90-115B', 700, 2002);", "reference_sql": "SELECT engine_type, AVG(YEAR(CURRENT_DATE) - manufacture_year) as avg_age FROM Engine GROUP BY engine_type;", "generated_sql": "SELECT engine_type, AVG(2023 - manufacture_year) AS avg_age \nFROM Engine \nGROUP BY engine_type;", "raw_model_output": "To find the average age of engines still in service for each engine type, we need to calculate the current year (assuming the current year is 2023), subtract the manufacture_year from it to get the age, and then compute the average age per engine_type.\n\nHere's the corresponding SQL query:\n\n```sql\nSELECT engine_type, AVG(2023 - manufacture_year) AS avg_age \nFROM Engine \nGROUP BY engine_type;\n```\n\nThis query calculates the current year (2023) minus the `manufacture_year` to get the age of each engine and then computes the average age for engines grouped by their type.", "latency_sec": 3.6621179580688477, "total_duration_sec": 3.397149226, "load_duration_sec": 0.015330628, "tokens_prompt": 698, "prompt_eval_sec": 0.298148898, "tokens_completion": 133, "completion_eval_sec": 3.080164649, "tokens_total": 831, "tokens_per_sec": 226.9178681612465, "retrieval_latency_sec": 0.11297774314880371, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average age of engines by subtracting the manufacture_year from the current year. The Reference SQL uses YEAR(CURRENT_DATE) to dynamically get the current year, while the Generated SQL hardcodes 2023. Assuming the current year is 2023 (as implied by the hardcoded value), both expressions yield the same result. Since the problem context does not specify a different year, they are semantically equivalent in this scenario."}
{"example_id": 1957, "sql_complexity": "set operations", "prompt": "What is the average temperature recorded for the 'polar_bear' species in the 'Arctic_Animals' table compared to the 'penguin' species in the 'Antarctic_Animals' table?", "context": "CREATE TABLE Arctic_Animals (species TEXT, avg_temp FLOAT); CREATE TABLE Antarctic_Animals (species TEXT, avg_temp FLOAT);", "reference_sql": "SELECT AVG(Arctic_Animals.avg_temp) FROM Arctic_Animals WHERE Arctic_Animals.species = 'polar_bear' INTERSECT SELECT AVG(Antarctic_Animals.avg_temp) FROM Antarctic_Animals WHERE Antarctic_Animals.species = 'penguin'", "generated_sql": "SELECT \n    (SELECT AVG(avg_temp) FROM Arctic_Animals WHERE species = 'polar_bear') AS polar_bear_avg_temp,\n    (SELECT AVG(avg_temp) FROM Antarctic_Animals WHERE species = 'penguin') AS penguin_avg_temp;", "raw_model_output": "To compare the average temperatures recorded for 'polar_bear' in the 'Arctic_Animals' table and 'penguin' in the 'Antarctic_Animals' table, we need to calculate the average temperature for each species separately and then select these values.\n\nHere is the corresponding SQL query:\n\n```sql\nSELECT \n    (SELECT AVG(avg_temp) FROM Arctic_Animals WHERE species = 'polar_bear') AS polar_bear_avg_temp,\n    (SELECT AVG(avg_temp) FROM Antarctic_Animals WHERE species = 'penguin') AS penguin_avg_temp;\n```\n\nThis query calculates the average temperature for each specified species and returns them in a single row.", "latency_sec": 3.7778520584106445, "total_duration_sec": 3.491836781, "load_duration_sec": 0.015597357, "tokens_prompt": 670, "prompt_eval_sec": 0.294101226, "tokens_completion": 139, "completion_eval_sec": 3.178448574, "tokens_total": 809, "tokens_per_sec": 214.14284823539361, "retrieval_latency_sec": 0.09475088119506836, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses INTERSECT to return only rows where the two averages are equal, while the Generated SQL returns both averages as separate columns. The first query's result depends on equality between the two averages, whereas the second query always returns both values independently. Their output structures and logical conditions differ fundamentally."}
{"example_id": 1311, "sql_complexity": "basic SQL", "prompt": "What is the total number of veteran job applications in Texas in the last year?", "context": "CREATE TABLE veteran_jobs (id INT, state VARCHAR(50), application_date DATE); INSERT INTO veteran_jobs (id, state, application_date) VALUES (1, 'Texas', '2021-02-15'), (2, 'California', '2021-04-10'), (3, 'Texas', '2022-01-05');", "reference_sql": "SELECT COUNT(*) FROM veteran_jobs WHERE state = 'Texas' AND application_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR);", "generated_sql": "SELECT COUNT(*) \nFROM veteran_jobs \nWHERE state = 'Texas' AND application_date >= DATEADD(year, -1, CURRENT_DATE);", "raw_model_output": "To find the total number of veteran job applications in Texas in the last year, you can use the following SQL query:\n\n```sql\nSELECT COUNT(*) \nFROM veteran_jobs \nWHERE state = 'Texas' AND application_date >= DATEADD(year, -1, CURRENT_DATE);\n```\n\nThis query counts the number of records where `state` is 'Texas' and `application_date` falls within the last year from the current date.", "latency_sec": 2.447343111038208, "total_duration_sec": 2.414296423, "load_duration_sec": 0.020881712, "tokens_prompt": 809, "prompt_eval_sec": 0.334631488, "tokens_completion": 88, "completion_eval_sec": 2.053027561, "tokens_total": 897, "tokens_per_sec": 366.51991948095747, "retrieval_latency_sec": 0.10341811180114746, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the same date range for application_date. DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR) and DATEADD(year, -1, CURRENT_DATE) both return the date exactly one year before the current date. The WHERE clause conditions (state = 'Texas' and application_date >= calculated date) are logically identical, so the COUNT(*) results will match."}
{"example_id": 2997, "sql_complexity": "window functions", "prompt": "What is the earliest capture time for each satellite image in the 'satellite_images' table?", "context": "CREATE TABLE satellite_images (image_id INT, image_url TEXT, capture_time TIMESTAMP); INSERT INTO satellite_images (image_id, image_url, capture_time) VALUES (1, 'image1.jpg', '2022-01-01 10:00:00'), (2, 'image2.jpg', '2021-05-01 10:00:00');", "reference_sql": "SELECT image_id, MIN(capture_time) OVER (PARTITION BY image_id) FROM satellite_images;", "generated_sql": "SELECT MIN(capture_time) AS earliest_capture_time \nFROM satellite_images;", "raw_model_output": "The question asks for the earliest capture time for each satellite image, but since there are only two distinct images and we need to find the minimum capture time overall rather than grouping by any column, the query simplifies to finding the minimum value of `capture_time` in the table.\n\nHere is the SQL statement:\n\n```sql\nSELECT MIN(capture_time) AS earliest_capture_time \nFROM satellite_images;\n```", "latency_sec": 2.5405848026275635, "total_duration_sec": 2.247159878, "load_duration_sec": 0.017277373, "tokens_prompt": 732, "prompt_eval_sec": 0.308364243, "tokens_completion": 82, "completion_eval_sec": 1.917276192, "tokens_total": 814, "tokens_per_sec": 320.3986732338681, "retrieval_latency_sec": 0.10973405838012695, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses a window function to return the minimum capture_time per image_id (which equals the original capture_time since each image_id is unique), resulting in two rows with image_id and capture_time. The Generated SQL aggregates all rows to return a single row with the overall earliest capture_time. The result structures and outputs differ."}
{"example_id": 3743, "sql_complexity": "aggregation", "prompt": "What is the maximum budget spent on peacekeeping operations by each department?", "context": "CREATE TABLE DepartmentPeacekeeping (id INT, department VARCHAR(50), budget INT);", "reference_sql": "SELECT department, MAX(budget) FROM DepartmentPeacekeeping GROUP BY department;", "generated_sql": "SELECT department, MAX(budget) AS max_budget \nFROM DepartmentPeacekeeping \nGROUP BY department;", "raw_model_output": "To find the maximum budget spent on peacekeeping operations by each department, you can use the following SQL query:\n\n```sql\nSELECT department, MAX(budget) AS max_budget \nFROM DepartmentPeacekeeping \nGROUP BY department;\n```", "latency_sec": 1.3585197925567627, "total_duration_sec": 1.323943424, "load_duration_sec": 0.016256335, "tokens_prompt": 567, "prompt_eval_sec": 0.142570276, "tokens_completion": 47, "completion_eval_sec": 1.161188267, "tokens_total": 614, "tokens_per_sec": 451.9624987166651, "retrieval_latency_sec": 0.11042499542236328, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries group by 'department' and calculate the maximum 'budget' for each group. The generated query adds an alias 'max_budget' to the MAX(budget) column, but this does not affect the data returned. The result sets will contain the same values, only with a different column name in the generated query."}
{"example_id": 4664, "sql_complexity": "multiple_joins", "prompt": "Calculate the total number of volunteer hours contributed by volunteers from 'California' in 'Health' projects in 2021.", "context": "CREATE TABLE volunteers (volunteer_id INT, name VARCHAR(255), state VARCHAR(255));", "reference_sql": "SELECT SUM(vh.hours) as total_hours FROM volunteer_projects vp JOIN volunteer_hours vh ON vp.project_id = vh.project_id JOIN volunteers vol ON vh.volunteer_id = vol.volunteer_id WHERE vp.cause = 'Health' AND vol.state = 'California' AND vh.volunteer_date BETWEEN '2021-01-01' AND '2021-12-31';", "generated_sql": "SELECT SUM(hours) AS total_volunteer_hours\nFROM volunteer_hours vh\nJOIN volunteers v ON vh.volunteer_id = v.volunteer_id\nWHERE v.state = 'California' AND vh.program = 'Health' AND YEAR(vh.hours_date) = 2021;", "raw_model_output": "To calculate the total number of volunteer hours contributed by volunteers from 'California' in 'Health' projects in 2021, we need to join the `volunteers` table with a hypothetical `volunteer_hours` table (since it's not provided in the schema but implied by the question). Assuming there is such a table named `volunteer_hours`, the SQL query would look like this:\n\n```sql\nSELECT SUM(hours) AS total_volunteer_hours\nFROM volunteer_hours vh\nJOIN volunteers v ON vh.volunteer_id = v.volunteer_id\nWHERE v.state = 'California' AND vh.program = 'Health' AND YEAR(vh.hours_date) = 2021;\n```\n\nThis query sums up the hours contributed by volunteers from California in Health projects during the year 2021.", "latency_sec": 4.639748811721802, "total_duration_sec": 4.333251573, "load_duration_sec": 0.017220312, "tokens_prompt": 946, "prompt_eval_sec": 0.36643251, "tokens_completion": 167, "completion_eval_sec": 3.945419854, "tokens_total": 1113, "tokens_per_sec": 239.88367585506592, "retrieval_latency_sec": 0.11412930488586426, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in several key aspects.  The Reference SQL joins three tables (volunteer_projects, volunteer_hours, volunteers) and filters on vp.cause = 'Health' and vh.volunteer_date between specific dates. The Generated SQL only joins two tables (volunteer_hours and volunteers) and filters on vh.program = 'Health' and YEAR(vh.hours_date) = 2021.  The column names for the date (volunteer_date vs. hours_date) and the filtering criteria (cause vs. program) are different.  These differences mean the queries are not semantically equivalent."}
{"example_id": 251, "sql_complexity": "set operations", "prompt": "Compare the number of economic diversification projects in two regions, one in Europe and one in Oceania, by showing the project type and the number of projects in each region.", "context": "CREATE TABLE economic_diversification (region VARCHAR(50), project_type VARCHAR(50), project_start_date DATE);", "reference_sql": "SELECT 'Europe' as region, project_type, COUNT(*) as project_count FROM economic_diversification WHERE region = 'Europe' UNION ALL SELECT 'Oceania' as region, project_type, COUNT(*) as project_count FROM economic_diversification WHERE region = 'Oceania';", "generated_sql": "SELECT 'Europe' AS region, project_type, COUNT(*) AS project_count \nFROM economic_diversification \nWHERE region = 'Europe'\nGROUP BY project_type\n\nUNION ALL\n\nSELECT 'Oceania' AS region, project_type, COUNT(*) AS project_count \nFROM economic_diversification \nWHERE region = 'Oceania'\nGROUP BY project_type;", "raw_model_output": "To compare the number of economic diversification projects in one region from Europe and another from Oceania by showing the project type and the number of projects in each region, we can use the `UNION ALL` operator to combine two separate queries. Each query will count the number of projects for a specific region based on the given criteria.\n\nHere is the SQL statement:\n\n```sql\nSELECT 'Europe' AS region, project_type, COUNT(*) AS project_count \nFROM economic_diversification \nWHERE region = 'Europe'\nGROUP BY project_type\n\nUNION ALL\n\nSELECT 'Oceania' AS region, project_type, COUNT(*) AS project_count \nFROM economic_diversification \nWHERE region = 'Oceania'\nGROUP BY project_type;\n```\n\nThis SQL statement will provide a comparison of the number and type of projects in both regions.", "latency_sec": 4.506789207458496, "total_duration_sec": 4.305540384, "load_duration_sec": 0.019157757, "tokens_prompt": 745, "prompt_eval_sec": 0.314283778, "tokens_completion": 172, "completion_eval_sec": 3.964184523, "tokens_total": 917, "tokens_per_sec": 203.4707987856219, "retrieval_latency_sec": 0.11261582374572754, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL lacks GROUP BY clauses, which would cause it to return incorrect counts (aggregating all rows in the filtered region without grouping by project_type). The Generated SQL correctly groups by project_type for each region, ensuring accurate per-type counts. Without GROUP BY, the Reference SQL is semantically invalid and would produce different results."}
{"example_id": 610, "sql_complexity": "subqueries", "prompt": "What is the percentage of community development projects completed in 'Caribbean' in 2020?", "context": "CREATE TABLE community_projects (project_id INT, project_name TEXT, location TEXT, completion_year INT); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (1, 'Community Center', 'Southern Region, Caribbean', 2020); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (2, 'Park Renovation', 'Northern Region, Caribbean', 2019); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (3, 'Library Construction', 'Caribbean', 2020);", "reference_sql": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM community_projects WHERE location = 'Caribbean')) FROM community_projects WHERE completion_year = 2020 AND location = 'Caribbean';", "generated_sql": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM community_projects WHERE location = 'Caribbean')) \nFROM community_projects \nWHERE completion_year = 2020 AND location = 'Caribbean';", "raw_model_output": "To calculate the percentage of community development projects completed in 'Caribbean' in 2020, we need to count the number of projects completed in 2020 and divide it by the total number of projects in 'Caribbean'. Here is the corresponding SQL query:\n\n```sql\nSELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM community_projects WHERE location = 'Caribbean')) \nFROM community_projects \nWHERE completion_year = 2020 AND location = 'Caribbean';\n```", "latency_sec": 3.233692169189453, "total_duration_sec": 2.973505585, "load_duration_sec": 0.015541778, "tokens_prompt": 1006, "prompt_eval_sec": 0.388551053, "tokens_completion": 109, "completion_eval_sec": 2.563972942, "tokens_total": 1115, "tokens_per_sec": 344.80709407769086, "retrieval_latency_sec": 0.10187530517578125, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both calculate the percentage of projects completed in 2020 within the 'Caribbean' location by dividing the count of such projects by the total count of Caribbean projects. The only difference is formatting (line breaks and indentation), which does not affect semantic equivalence."}
{"example_id": 421, "sql_complexity": "set operations", "prompt": "What is the combined landfill capacity for 'City A' and 'City B'?", "context": "CREATE TABLE landfill_capacity (city VARCHAR(255), capacity INT); INSERT INTO landfill_capacity (city, capacity) VALUES ('City A', 500000), ('City B', 600000);", "reference_sql": "SELECT SUM(capacity) FROM (SELECT capacity FROM landfill_capacity WHERE city = 'City A' UNION ALL SELECT capacity FROM landfill_capacity WHERE city = 'City B') AS combined_capacity;", "generated_sql": "SELECT SUM(capacity) AS total_capacity \nFROM landfill_capacity \nWHERE city IN ('City A', 'City B');", "raw_model_output": "To find the combined landfill capacity for 'City A' and 'City B', you can use a `SUM` aggregation function along with a `WHERE` clause to filter the cities. Here is the corresponding SQL query:\n\n```sql\nSELECT SUM(capacity) AS total_capacity \nFROM landfill_capacity \nWHERE city IN ('City A', 'City B');\n```", "latency_sec": 2.336594820022583, "total_duration_sec": 2.077272859, "load_duration_sec": 0.014057562, "tokens_prompt": 817, "prompt_eval_sec": 0.328265384, "tokens_completion": 73, "completion_eval_sec": 1.731881267, "tokens_total": 890, "tokens_per_sec": 380.8961623870236, "retrieval_latency_sec": 0.11069607734680176, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of capacities for 'City A' and 'City B'. The reference query uses a subquery with UNION ALL to combine the two cities' capacities before summing, while the generated query directly filters using WHERE city IN. Since both approaches aggregate the same values, the result will be identical."}
{"example_id": 880, "sql_complexity": "aggregation", "prompt": "Show veteran employment statistics for each state in the 'veteran_employment' table", "context": "CREATE TABLE veteran_employment (employee_id INT, state VARCHAR(2), job_title VARCHAR(50), employment_date DATE);", "reference_sql": "SELECT state, COUNT(*) as veteran_employees FROM veteran_employment WHERE state IN ('CA', 'NY', 'TX', 'FL', 'PA') GROUP BY state;", "generated_sql": "SELECT state, COUNT(*) AS veteran_employees \nFROM veteran_employment \nGROUP BY state;", "raw_model_output": "To show veteran employment statistics for each state in the 'veteran_employment' table, we need to count the number of employees per state. Here is the SQL query:\n\n```sql\nSELECT state, COUNT(*) AS veteran_employees \nFROM veteran_employment \nGROUP BY state;\n```", "latency_sec": 1.9513189792633057, "total_duration_sec": 1.657608152, "load_duration_sec": 0.015961146, "tokens_prompt": 624, "prompt_eval_sec": 0.280142289, "tokens_completion": 60, "completion_eval_sec": 1.358479587, "tokens_total": 684, "tokens_per_sec": 350.53213096827204, "retrieval_latency_sec": 0.11691498756408691, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters results to only include records where state is in ('CA', 'NY', 'TX', 'FL', 'PA'), while the Generated SQL includes all states. This means the Generated SQL could return more states than the Reference SQL, making them non-equivalent."}
{"example_id": 454, "sql_complexity": "single join", "prompt": "Which excavation sites have more than 10 artifacts?", "context": "CREATE TABLE ExcavationSite (SiteID INT, SiteName VARCHAR(50)); INSERT INTO ExcavationSite (SiteID, SiteName) VALUES (1, 'Site A'), (2, 'Site B'), (3, 'Site C'); CREATE TABLE Artifact (ArtifactID INT, SiteID INT, ObjectType VARCHAR(50)); INSERT INTO Artifact (ArtifactID, SiteID, ObjectType) VALUES (1, 1, 'Pottery'), (2, 1, 'Tool'), (3, 2, 'Statue'), (4, 2, 'Bead'), (5, 3, 'Bead'), (6, 3, 'Bead'), (7, 3, 'Bead'), (8, 3, 'Bead'), (9, 3, 'Bead'), (10, 3, 'Bead'), (11, 3, 'Bead');", "reference_sql": "SELECT e.SiteName FROM ExcavationSite e JOIN Artifact a ON e.SiteID = a.SiteID GROUP BY e.SiteName HAVING COUNT(a.ArtifactID) > 10;", "generated_sql": "SELECT es.SiteName\nFROM ExcavationSite es\nJOIN Artifact a ON es.SiteID = a.SiteID\nGROUP BY es.SiteName\nHAVING COUNT(a.ArtifactID) > 10;", "raw_model_output": "```sql\nSELECT es.SiteName\nFROM ExcavationSite es\nJOIN Artifact a ON es.SiteID = a.SiteID\nGROUP BY es.SiteName\nHAVING COUNT(a.ArtifactID) > 10;\n```", "latency_sec": 1.7600171566009521, "total_duration_sec": 1.687157737, "load_duration_sec": 0.020740917, "tokens_prompt": 1131, "prompt_eval_sec": 0.558154259, "tokens_completion": 48, "completion_eval_sec": 1.10025034, "tokens_total": 1179, "tokens_per_sec": 669.8798336017096, "retrieval_latency_sec": 0.11357402801513672, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform the same operations: joining ExcavationSite with Artifact on SiteID, grouping by SiteName, and filtering groups with more than 10 artifacts. The only differences are alias names (e/es and a/a), which do not affect semantic equivalence."}
{"example_id": 1086, "sql_complexity": "aggregation", "prompt": "What is the total CO2 emission for each equipment type, excluding equipment that is older than 8 years?", "context": "CREATE TABLE EmissionData (EquipmentID INT, EquipmentType VARCHAR(50), CO2Emission INT, Age INT); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (1, 'Excavator', 50, 8); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (2, 'Haul Truck', 70, 7); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (3, 'Shovel', 30, 6); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (4, 'Drilling Rig', 40, 3);", "reference_sql": "SELECT EquipmentType, SUM(CO2Emission) as TotalCO2Emission FROM EmissionData WHERE Age <= 8 GROUP BY EquipmentType;", "generated_sql": "SELECT EquipmentType, SUM(CO2Emission) AS TotalCO2Emission \nFROM EmissionData \nWHERE Age <= 8 \nGROUP BY EquipmentType;", "raw_model_output": "To find the total CO2 emission for each equipment type, excluding equipment that is older than 8 years, you can use the following SQL query:\n\n```sql\nSELECT EquipmentType, SUM(CO2Emission) AS TotalCO2Emission \nFROM EmissionData \nWHERE Age <= 8 \nGROUP BY EquipmentType;\n```", "latency_sec": 2.3306000232696533, "total_duration_sec": 2.027429535, "load_duration_sec": 0.015632283, "tokens_prompt": 868, "prompt_eval_sec": 0.349339465, "tokens_completion": 69, "completion_eval_sec": 1.657789924, "tokens_total": 937, "tokens_per_sec": 402.04238850279455, "retrieval_latency_sec": 0.11495089530944824, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure, logic, and syntax. They both select EquipmentType and sum CO2Emission where Age <= 8, grouping by EquipmentType. The only difference is whitespace formatting, which does not affect semantic equivalence."}
{"example_id": 3455, "sql_complexity": "basic SQL", "prompt": "What are the names of all innovation projects in the 'rural_infrastructure' table, excluding those with a budget over 50000?", "context": "CREATE TABLE rural_infrastructure (name VARCHAR(255), budget INT); INSERT INTO rural_infrastructure (name, budget) VALUES ('Dam Construction', 40000), ('Well Digging', 30000), ('Irrigation System', 70000);", "reference_sql": "SELECT name FROM rural_infrastructure WHERE budget <= 50000;", "generated_sql": "SELECT name FROM rural_infrastructure WHERE budget <= 50000;", "raw_model_output": "The provided schema does not include a `type` column to distinguish between different types of projects. Therefore, we can only filter based on the budget constraint.\n\nHere is the SQL query:\n\n```sql\nSELECT name FROM rural_infrastructure WHERE budget <= 50000;\n```", "latency_sec": 1.8545069694519043, "total_duration_sec": 1.785998914, "load_duration_sec": 0.016069015, "tokens_prompt": 957, "prompt_eval_sec": 0.363940991, "tokens_completion": 58, "completion_eval_sec": 1.40167543, "tokens_total": 1015, "tokens_per_sec": 547.3152793273034, "retrieval_latency_sec": 0.10976409912109375, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure and logic. Both select the 'name' column from the 'rural_infrastructure' table where the 'budget' is less than or equal to 50000. The queries will produce the same result set."}
{"example_id": 3936, "sql_complexity": "window functions", "prompt": "What is the total investment per client for each investment type?", "context": "CREATE TABLE clients (client_id INT, name TEXT, investment_type TEXT, investment FLOAT); INSERT INTO clients (client_id, name, investment_type, investment) VALUES (1, 'John Doe', 'Stocks', 3000.00), (1, 'John Doe', 'Bonds', 2000.00), (2, 'Jane Smith', 'Stocks', 5000.00);", "reference_sql": "SELECT client_id, name, investment_type, SUM(investment) OVER (PARTITION BY client_id, investment_type ORDER BY client_id) as total_investment FROM clients;", "generated_sql": "SELECT client_id, investment_type, SUM(investment) AS total_investment\nFROM clients\nGROUP BY client_id, investment_type;", "raw_model_output": "To find the total investment per client for each investment type, we need to group the data by `client_id` and `investment_type`, then calculate the sum of investments within these groups. Here is the corresponding SQL query:\n\n```sql\nSELECT client_id, investment_type, SUM(investment) AS total_investment\nFROM clients\nGROUP BY client_id, investment_type;\n```", "latency_sec": 2.2018330097198486, "total_duration_sec": 2.167162095, "load_duration_sec": 0.015598393, "tokens_prompt": 806, "prompt_eval_sec": 0.325559828, "tokens_completion": 77, "completion_eval_sec": 1.822814956, "tokens_total": 883, "tokens_per_sec": 401.0295041004717, "retrieval_latency_sec": 0.11763405799865723, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL includes the 'name' column and uses a window function to calculate a cumulative sum, while the Generated SQL groups by client_id and investment_type, omitting the 'name' column and using an aggregate SUM. The output structures differ, and the window function preserves individual rows while the aggregate query collapses them."}
{"example_id": 1838, "sql_complexity": "window functions", "prompt": "What are the top 3 species with the most sightings across all arctic research stations?", "context": "CREATE TABLE research_station (id INT, name TEXT); INSERT INTO research_station (id, name) VALUES (1, 'Station A'); INSERT INTO research_station (id, name) VALUES (2, 'Station B'); CREATE TABLE species_observations (station_id INT, species_name TEXT, sightings INT); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (1, 'Species 1', 10); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (1, 'Species 2', 5); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (2, 'Species 1', 8); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (2, 'Species 3', 15);", "reference_sql": "SELECT species_name, SUM(sightings) as total_sightings, RANK() OVER (ORDER BY SUM(sightings) DESC) as rank FROM species_observations GROUP BY species_name HAVING rank <= 3;", "generated_sql": "SELECT so.species_name, SUM(so.sightings) AS total_sightings \nFROM species_observations so \nGROUP BY so.species_name \nORDER BY total_sightings DESC \nLIMIT 3;", "raw_model_output": "To find the top 3 species with the most sightings across all arctic research stations, we need to aggregate the `sightings` column in the `species_observations` table and then order by this aggregated value. Here is the corresponding SQL query:\n\n```sql\nSELECT so.species_name, SUM(so.sightings) AS total_sightings \nFROM species_observations so \nGROUP BY so.species_name \nORDER BY total_sightings DESC \nLIMIT 3;\n```", "latency_sec": 3.0540099143981934, "total_duration_sec": 2.853703392, "load_duration_sec": 0.032255553, "tokens_prompt": 1116, "prompt_eval_sec": 0.55013713, "tokens_completion": 98, "completion_eval_sec": 2.267429251, "tokens_total": 1214, "tokens_per_sec": 397.5101699167942, "retrieval_latency_sec": 0.10531473159790039, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses RANK() in a HAVING clause, which is invalid syntax because window functions like RANK() cannot be used in HAVING. The Generated SQL correctly uses ORDER BY and LIMIT to get top 3 results. Even if the Reference SQL were valid, it would behave differently in cases with tied rankings (e.g., multiple species with same total sightings), potentially returning more than 3 rows. The two queries are not semantically equivalent."}
{"example_id": 3091, "sql_complexity": "single join", "prompt": "Find the number of hybrid vehicles sold in the US, Germany, and Japan.", "context": "CREATE TABLE vehicle_sales (sale_id INT, vehicle_id INT, country VARCHAR(20), quantity INT); CREATE TABLE vehicles (vehicle_id INT, model VARCHAR(20), manufacture VARCHAR(20), vehicle_type VARCHAR(20));", "reference_sql": "SELECT SUM(vs.quantity) FROM vehicle_sales vs JOIN vehicles v ON vs.vehicle_id = v.vehicle_id WHERE v.vehicle_type = 'hybrid' AND vs.country IN ('US', 'Germany', 'Japan');", "generated_sql": "SELECT vs.country, SUM(vs.quantity) AS total_quantity\nFROM vehicle_sales vs\nJOIN vehicles v ON vs.vehicle_id = v.vehicle_id\nWHERE v.vehicle_type = 'hybrid' AND vs.country IN ('US', 'Germany', 'Japan')\nGROUP BY vs.country;", "raw_model_output": "To find the number of hybrid vehicles sold in the US, Germany, and Japan, we need to join the `vehicle_sales` table with the `vehicles` table on the `vehicle_id` column. We then filter for rows where the `vehicle_type` is 'hybrid' and the `country` is one of 'US', 'Germany', or 'Japan'. Finally, we group by country and sum up the quantities.\n\nHere's the SQL query:\n\n```sql\nSELECT vs.country, SUM(vs.quantity) AS total_quantity\nFROM vehicle_sales vs\nJOIN vehicles v ON vs.vehicle_id = v.vehicle_id\nWHERE v.vehicle_type = 'hybrid' AND vs.country IN ('US', 'Germany', 'Japan')\nGROUP BY vs.country;\n```", "latency_sec": 4.1476500034332275, "total_duration_sec": 3.924116741, "load_duration_sec": 0.014829962, "tokens_prompt": 824, "prompt_eval_sec": 0.326284356, "tokens_completion": 154, "completion_eval_sec": 3.57998829, "tokens_total": 978, "tokens_per_sec": 235.7961735417545, "retrieval_latency_sec": 0.10849976539611816, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns a single total sum of quantities for all qualifying records, while the Generated SQL groups the results by country, producing separate sums for each country. The output structure and results differ fundamentally."}
{"example_id": 2399, "sql_complexity": "set operations", "prompt": "What is the average duration of criminal trials for Indigenous defendants compared to non-Indigenous defendants in Canada and New Zealand?", "context": "CREATE TABLE canada_criminal_trials (id INT, defendant_type VARCHAR(255), days_to_completion INT); INSERT INTO canada_criminal_trials (id, defendant_type, days_to_completion) VALUES (1, 'Indigenous', 60), (2, 'Non-Indigenous', 45);CREATE TABLE nz_criminal_trials (id INT, defendant_type VARCHAR(255), days_to_completion INT); INSERT INTO nz_criminal_trials (id, defendant_type, days_to_completion) VALUES (1, 'Indigenous', 70), (2, 'Non-Indigenous', 50);", "reference_sql": "SELECT AVG(days_to_completion) AS avg_duration FROM canada_criminal_trials WHERE defendant_type = 'Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM canada_criminal_trials WHERE defendant_type = 'Non-Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM nz_criminal_trials WHERE defendant_type = 'Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM nz_criminal_trials WHERE defendant_type = 'Non-Indigenous';", "generated_sql": "SELECT \n    defendant_type,\n    AVG(days_to_completion) AS avg_days_to_completion\nFROM (\n    SELECT id, defendant_type, days_to_completion FROM canada_criminal_trials\n    UNION ALL\n    SELECT id, defendant_type, days_to_completion FROM nz_criminal_trials\n) combined_data\nGROUP BY defendant_type;", "raw_model_output": "To find the average duration of criminal trials for Indigenous defendants compared to non-Indigenous defendants in Canada and New Zealand, we need to calculate the average `days_to_completion` for each type of defendant from both tables (`canada_criminal_trials` and `nz_criminal_trials`). We can achieve this by using a UNION ALL to combine data from both tables and then calculating the averages.\n\nHere is the SQL statement:\n\n```sql\nSELECT \n    defendant_type,\n    AVG(days_to_completion) AS avg_days_to_completion\nFROM (\n    SELECT id, defendant_type, days_to_completion FROM canada_criminal_trials\n    UNION ALL\n    SELECT id, defendant_type, days_to_completion FROM nz_criminal_trials\n) combined_data\nGROUP BY defendant_type;\n```", "latency_sec": 4.219350099563599, "total_duration_sec": 4.000052502, "load_duration_sec": 0.016516065, "tokens_prompt": 940, "prompt_eval_sec": 0.365016595, "tokens_completion": 154, "completion_eval_sec": 3.614182227, "tokens_total": 1094, "tokens_per_sec": 259.28163678883885, "retrieval_latency_sec": 0.10334610939025879, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates separate averages for each defendant_type within each country (4 rows total), while the Generated SQL combines data from both countries first and then averages by defendant_type (2 rows total). The Generated SQL's aggregation spans both countries, whereas the Reference SQL maintains country-specific distinctions."}
{"example_id": 2972, "sql_complexity": "set operations", "prompt": "How many indigenous communities are in the Arctic Research Station 13 and 14?", "context": "CREATE TABLE Arctic_Research_Station_13 (id INT, community TEXT); CREATE TABLE Arctic_Research_Station_14 (id INT, community TEXT);", "reference_sql": "SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_13; SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_14; SELECT COUNT(DISTINCT community) FROM (SELECT * FROM Arctic_Research_Station_13 UNION ALL SELECT * FROM Arctic_Research_Station_14) AS Arctic_Communities;", "generated_sql": "SELECT COUNT(DISTINCT community) \nFROM (\n    SELECT community FROM Arctic_Research_Station_13 \n    UNION ALL \n    SELECT community FROM Arctic_Research_Station_14\n) AS Combined_Communities;", "raw_model_output": "To find out how many distinct indigenous communities are in both Arctic Research Station 13 and 14, we can use a similar approach to the examples provided. We will combine the data from both tables using `UNION ALL` and then count the distinct communities.\n\nHere is the SQL statement:\n\n```sql\nSELECT COUNT(DISTINCT community) \nFROM (\n    SELECT community FROM Arctic_Research_Station_13 \n    UNION ALL \n    SELECT community FROM Arctic_Research_Station_14\n) AS Combined_Communities;\n```\n\nThis query combines all unique communities from both stations and counts the distinct ones.", "latency_sec": 3.5361359119415283, "total_duration_sec": 3.224593792, "load_duration_sec": 0.015810104, "tokens_prompt": 693, "prompt_eval_sec": 0.295944972, "tokens_completion": 127, "completion_eval_sec": 2.908869607, "tokens_total": 820, "tokens_per_sec": 231.89153935821884, "retrieval_latency_sec": 0.10317206382751465, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count distinct 'community' values from combined data of Arctic_Research_Station_13 and 14. The Reference's third query uses UNION ALL on all columns, while the Generated query explicitly selects only 'community' columns. Since COUNT(DISTINCT community) ignores extra columns and duplicates, both approaches yield the same result."}
{"example_id": 5576, "sql_complexity": "window functions", "prompt": "Who are the top 5 users with the most followers, and what is their location?", "context": "CREATE TABLE user_data (user_id INT, name VARCHAR(50), followers INT, location VARCHAR(50)); INSERT INTO user_data (user_id, name, followers, location) VALUES (1, 'Alice', 10000, 'New York'), (2, 'Bob', 15000, 'California'), (3, 'Charlie', 12000, 'Texas'), (4, 'David', 8000, 'Florida'), (5, 'Eve', 9000, 'Illinois');", "reference_sql": "SELECT name, location FROM (SELECT name, location, ROW_NUMBER() OVER (ORDER BY followers DESC) AS rank FROM user_data) AS user_ranks WHERE rank <= 5;", "generated_sql": "SELECT name, followers, location \nFROM user_data \nORDER BY followers DESC \nLIMIT 5;", "raw_model_output": "To retrieve the top 5 users with the most followers along with their location, you can use the following SQL query:\n\n```sql\nSELECT name, followers, location \nFROM user_data \nORDER BY followers DESC \nLIMIT 5;\n```", "latency_sec": 1.842621088027954, "total_duration_sec": 1.596714756, "load_duration_sec": 0.022041988, "tokens_prompt": 936, "prompt_eval_sec": 0.36403806, "tokens_completion": 49, "completion_eval_sec": 1.205236616, "tokens_total": 985, "tokens_per_sec": 534.5645973552739, "retrieval_latency_sec": 0.10238933563232422, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL returns only 'name' and 'location' columns, while the Generated SQL includes 'followers' as well. Additionally, the Reference SQL uses a subquery with ROW_NUMBER() for ranking, which could handle ties differently compared to the Generated SQL's simple ORDER BY + LIMIT approach. The column differences make the result sets structurally distinct."}
{"example_id": 1560, "sql_complexity": "basic SQL", "prompt": "What is the average media literacy score for users in the 'Young Adult' age group who have completed at least one disinformation detection course?", "context": "CREATE TABLE users (id INT, age VARCHAR(20), media_literacy_score INT, courses_completed INT);", "reference_sql": "SELECT AVG(media_literacy_score) FROM users WHERE age = 'Young Adult' AND courses_completed > 0;", "generated_sql": "SELECT AVG(media_literacy_score) \nFROM users \nWHERE age = 'Young Adult' AND courses_completed > 0;", "raw_model_output": "To find the average media literacy score for users in the 'Young Adult' age group who have completed at least one disinformation detection course, you can use the following SQL query:\n\n```sql\nSELECT AVG(media_literacy_score) \nFROM users \nWHERE age = 'Young Adult' AND courses_completed > 0;\n```", "latency_sec": 2.0496928691864014, "total_duration_sec": 1.769477329, "load_duration_sec": 0.014713478, "tokens_prompt": 564, "prompt_eval_sec": 0.138695394, "tokens_completion": 67, "completion_eval_sec": 1.613521481, "tokens_total": 631, "tokens_per_sec": 307.85100025764694, "retrieval_latency_sec": 0.10264992713928223, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. The only difference is formatting (line breaks), which does not affect semantic equivalence. Both calculate the average media_literacy_score for users aged 'Young Adult' with courses_completed > 0."}
{"example_id": 1201, "sql_complexity": "basic SQL", "prompt": "What is the maximum energy efficiency rating of hydroelectric dams in Canada?", "context": "CREATE TABLE hydro_dams (id INT, name TEXT, country TEXT, energy_efficiency_rating FLOAT); INSERT INTO hydro_dams (id, name, country, energy_efficiency_rating) VALUES (1, 'Robert-Bourassa', 'Canada', 0.94), (2, 'Churchill Falls', 'Canada', 0.92);", "reference_sql": "SELECT MAX(energy_efficiency_rating) FROM hydro_dams WHERE country = 'Canada';", "generated_sql": "SELECT MAX(energy_efficiency_rating) FROM hydro_dams WHERE country = 'Canada';", "raw_model_output": "```sql\nSELECT MAX(energy_efficiency_rating) FROM hydro_dams WHERE country = 'Canada';\n```", "latency_sec": 0.9721658229827881, "total_duration_sec": 0.834491618, "load_duration_sec": 0.015742664, "tokens_prompt": 647, "prompt_eval_sec": 0.285287297, "tokens_completion": 23, "completion_eval_sec": 0.53011976, "tokens_total": 670, "tokens_per_sec": 689.1828370846381, "retrieval_latency_sec": 0.10187101364135742, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They both select the maximum energy_efficiency_rating from the hydro_dams table where the country is 'Canada'. The SQL syntax, table name, column names, and WHERE condition are exactly the same in both queries."}
{"example_id": 4243, "sql_complexity": "single join", "prompt": "How many orders were placed by new and returning customers in each month of the year 2021?'", "context": "CREATE TABLE customer (id INT, first_order_date DATE, last_order_date DATE);", "reference_sql": "INSERT INTO customer (id, first_order_date, last_order_date) SELECT customer_id, MIN(order_date) AS first_order_date, MAX(order_date) AS last_order_date FROM orders GROUP BY customer_id; SELECT YEAR(order_date) AS year, MONTH(order_date) AS month, CASE WHEN DATEDIFF(last_order_date, first_order_date) > 30 THEN 'returning' ELSE 'new' END AS customer_type, COUNT(DISTINCT id) AS num_orders FROM orders JOIN customer ON orders.customer_id = customer.id WHERE YEAR(order_date) = 2021 GROUP BY year, month, customer_type;", "generated_sql": "SELECT \n    DATE_FORMAT(first_order_date, '%Y-%m') AS order_month,\n    SUM(CASE WHEN first_order_date <= last_order_date AND YEAR(first_order_date) = 2021 THEN 1 ELSE 0 END) AS total_orders,\n    SUM(CASE WHEN YEAR(first_order_date) = 2021 THEN 1 ELSE 0 END) AS new_customers,\n    SUM(CASE WHEN YEAR(first_order_date) < 2021 THEN 1 ELSE 0 END) AS returning_customers\nFROM \n    customer\nWHERE \n    first_order_date <= '2021-12-31'\nGROUP BY \n    order_month;", "raw_model_output": "To determine the number of orders placed by new and returning customers in each month of 2021, we need to categorize customers based on whether their `first_order_date` falls within a given month. Here's how you can achieve this using an SQL query:\n\n```sql\nSELECT \n    DATE_FORMAT(first_order_date, '%Y-%m') AS order_month,\n    SUM(CASE WHEN first_order_date <= last_order_date AND YEAR(first_order_date) = 2021 THEN 1 ELSE 0 END) AS total_orders,\n    SUM(CASE WHEN YEAR(first_order_date) = 2021 THEN 1 ELSE 0 END) AS new_customers,\n    SUM(CASE WHEN YEAR(first_order_date) < 2021 THEN 1 ELSE 0 END) AS returning_customers\nFROM \n    customer\nWHERE \n    first_order_date <= '2021-12-31'\nGROUP BY \n    order_month;\n```\n\nExplanation:\n- `DATE_FORMAT(first_order_date, '%Y-%m')` extracts the year and month from `first_order_date`.\n- The query uses conditional aggregation to count orders placed by new customers (those with a `first_order_date` in 2021) and returning customers (those with a `first_order_date` before 2021).\n- The `WHERE` clause ensures that only records where the first order was made on or before December 31, 2021 are considered.\n- Finally, the results are grouped by month to get counts for each month of 2021.", "latency_sec": 8.238526821136475, "total_duration_sec": 8.036963823, "load_duration_sec": 0.016515324, "tokens_prompt": 786, "prompt_eval_sec": 0.321304536, "tokens_completion": 333, "completion_eval_sec": 7.695782394, "tokens_total": 1119, "tokens_per_sec": 135.82525423466888, "retrieval_latency_sec": 0.10452985763549805, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The reference query calculates customer types ('new'/'returning') based on the difference between first and last order dates, and counts orders per month in 2021. The generated query focuses on first_order_date metrics, categorizing customers by whether their first order was in 2021 or earlier, and aggregates totals by month. Key differences include: 1) Different data sources (orders vs. customer table), 2) Distinct customer type definitions, 3) Different aggregation logic (order counts vs. customer counts), and 4) Missing customer_type grouping in the generated query."}
{"example_id": 2321, "sql_complexity": "subqueries", "prompt": "What are the names and types of vessels used in research expeditions in the regions with the lowest ocean acidification levels?", "context": "CREATE TABLE ocean_acidification (id INT PRIMARY KEY, region VARCHAR(255), year INT, acidification_level INT); INSERT INTO ocean_acidification (id, region, year, acidification_level) VALUES (1, 'Arctic Ocean', 2018, 20), (2, 'Southern Ocean', 2019, 22); CREATE TABLE expedition_vessels (id INT PRIMARY KEY, name VARCHAR(255), type VARCHAR(255), region VARCHAR(255)); INSERT INTO expedition_vessels (id, name, type, region) VALUES (1, 'Sea Researcher', 'Research Vessel', 'Arctic Ocean');", "reference_sql": "SELECT v.name, v.type FROM expedition_vessels v INNER JOIN ocean_acidification oa ON v.region = oa.region WHERE oa.acidification_level = (SELECT MIN(acidification_level) FROM ocean_acidification);", "generated_sql": "SELECT e.name, e.type \nFROM expedition_vessels e\nJOIN (\n    SELECT region, MIN(acidification_level) AS min_acidification\n    FROM ocean_acidification\n    GROUP BY region\n    HAVING COUNT(*) = 1 -- Ensure there is only one minimum acidification level per region\n) o ON e.region = o.region;", "raw_model_output": "To find the names and types of vessels used in research expeditions in the regions with the lowest ocean acidification levels, we need to follow these steps:\n\n1. Identify the regions with the lowest acidification level.\n2. Find the vessels operating in those regions.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT e.name, e.type \nFROM expedition_vessels e\nJOIN (\n    SELECT region, MIN(acidification_level) AS min_acidification\n    FROM ocean_acidification\n    GROUP BY region\n    HAVING COUNT(*) = 1 -- Ensure there is only one minimum acidification level per region\n) o ON e.region = o.region;\n```\n\nThis query first finds the regions with the lowest acidification levels and then selects the names and types of vessels operating in those regions.", "latency_sec": 4.6132166385650635, "total_duration_sec": 4.34393328, "load_duration_sec": 0.021031356, "tokens_prompt": 902, "prompt_eval_sec": 0.357227384, "tokens_completion": 169, "completion_eval_sec": 3.958670313, "tokens_total": 1071, "tokens_per_sec": 232.1590516792061, "retrieval_latency_sec": 0.10749197006225586, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL finds vessels in regions where the acidification_level equals the absolute minimum value across all records. The Generated SQL instead groups by region, calculates per-region minima, and filters regions with exactly one record (due to HAVING COUNT(*) = 1). This changes the criteria: the Generated SQL ignores global minima, focuses on regions with single entries, and returns different results. For example, in the sample data, the Reference SQL would return Arctic Ocean vessels (acidification_level=20), while the Generated SQL would return both Arctic and Southern Ocean vessels (due to their single entries) but with different minima."}
{"example_id": 4349, "sql_complexity": "multiple_joins", "prompt": "Show the research grants awarded to professors in the Computer Science department.", "context": "CREATE TABLE departments (id INT, name VARCHAR(50)); INSERT INTO departments (id, name) VALUES (1, 'Computer Science'), (2, 'Mathematics'); CREATE TABLE professors (id INT, name VARCHAR(50), department_id INT); INSERT INTO professors (id, name, department_id) VALUES (1, 'John Smith', 1), (2, 'Jane Doe', 2); CREATE TABLE grants (id INT, professor_id INT, year INT, amount FLOAT); INSERT INTO grants (id, professor_id, year, amount) VALUES (1, 1, 2021, 5000.0), (2, 2, 2020, 7000.0);", "reference_sql": "SELECT professors.name, grants.amount FROM professors INNER JOIN grants ON professors.id = grants.professor_id INNER JOIN departments ON professors.department_id = departments.id WHERE departments.name = 'Computer Science';", "generated_sql": "SELECT g.id AS grant_id, g.year, g.amount \nFROM grants g \nJOIN professors p ON g.professor_id = p.id \nJOIN departments d ON p.department_id = d.id \nWHERE d.name = 'Computer Science';", "raw_model_output": "```sql\nSELECT g.id AS grant_id, g.year, g.amount \nFROM grants g \nJOIN professors p ON g.professor_id = p.id \nJOIN departments d ON p.department_id = d.id \nWHERE d.name = 'Computer Science';\n```", "latency_sec": 1.8969299793243408, "total_duration_sec": 1.649875512, "load_duration_sec": 0.01685424, "tokens_prompt": 879, "prompt_eval_sec": 0.354516777, "tokens_completion": 53, "completion_eval_sec": 1.274075266, "tokens_total": 932, "tokens_per_sec": 491.3201911290184, "retrieval_latency_sec": 0.1013193130493164, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects professor names and grant amounts, while the Generated SQL selects grant IDs, years, and amounts. The selected columns differ, resulting in different output structures even though both filter for 'Computer Science' department professors."}
{"example_id": 476, "sql_complexity": "basic SQL", "prompt": "Insert new food safety records for locations \"A123\", \"B456\", and \"C789\"", "context": "CREATE TABLE food_safety_records (id INT, location VARCHAR(255), inspection_date DATE, violation_count INT);", "reference_sql": "INSERT INTO food_safety_records (location, inspection_date, violation_count) VALUES ('A123', '2022-03-01', 0), ('B456', '2022-03-05', 2), ('C789', '2022-03-10', 1);", "generated_sql": "INSERT INTO food_safety_records (location, inspection_date, violation_count) \nVALUES ('A123', CURRENT_DATE, 0), \n       ('B456', CURRENT_DATE, 0), \n       ('C789', CURRENT_DATE, 0);", "raw_model_output": "```sql\nINSERT INTO food_safety_records (location, inspection_date, violation_count) \nVALUES ('A123', CURRENT_DATE, 0), \n       ('B456', CURRENT_DATE, 0), \n       ('C789', CURRENT_DATE, 0);\n```", "latency_sec": 2.036881923675537, "total_duration_sec": 1.711373139, "load_duration_sec": 0.015839992, "tokens_prompt": 641, "prompt_eval_sec": 0.288049022, "tokens_completion": 62, "completion_eval_sec": 1.403849451, "tokens_total": 703, "tokens_per_sec": 345.1353717801384, "retrieval_latency_sec": 0.09170722961425781, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL uses specific historical dates (2022-03-01, 2022-03-05, 2022-03-10) and varying violation counts (0, 2, 1), while the Generated SQL uses the current date (CURRENT_DATE) for all entries and sets violation_count to 0 for all rows. This results in different data being inserted."}
{"example_id": 2908, "sql_complexity": "single join", "prompt": "List all co-owners and the properties they own in New York, NY.", "context": "CREATE TABLE properties (id INT, city VARCHAR(50), price INT); CREATE TABLE co_owners (property_id INT, owner_name VARCHAR(50)); INSERT INTO properties (id, city, price) VALUES (1, 'New York', 800000), (2, 'Los Angeles', 600000); INSERT INTO co_owners (property_id, owner_name) VALUES (1, 'David'), (1, 'Ella'), (2, 'Frank');", "reference_sql": "SELECT properties.city, co_owners.owner_name FROM properties INNER JOIN co_owners ON properties.id = co_owners.property_id WHERE properties.city = 'New York';", "generated_sql": "SELECT c.owner_name, p.id AS property_id, p.city, p.price \nFROM co_owners c\nJOIN properties p ON c.property_id = p.id\nWHERE p.city = 'New York';", "raw_model_output": "To list all co-owners and the properties they own in New York, we need to join the `properties` table with the `co_owners` table on the property ID. We then filter for properties located in \"New York\".\n\nHere is the corresponding SQL query:\n\n```sql\nSELECT c.owner_name, p.id AS property_id, p.city, p.price \nFROM co_owners c\nJOIN properties p ON c.property_id = p.id\nWHERE p.city = 'New York';\n```", "latency_sec": 2.9965109825134277, "total_duration_sec": 2.695256881, "load_duration_sec": 0.01418147, "tokens_prompt": 758, "prompt_eval_sec": 0.314811348, "tokens_completion": 102, "completion_eval_sec": 2.362412953, "tokens_total": 860, "tokens_per_sec": 287.00044986274173, "retrieval_latency_sec": 0.10721015930175781, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects only 'city' and 'owner_name', while the Generated SQL includes additional columns ('property_id', 'price'). Although both queries join the same tables and filter by 'New York', the Generated SQL returns a superset of columns, making the result sets different."}
{"example_id": 636, "sql_complexity": "set operations", "prompt": "Insert new data into the 'cosmetic_ingredients' table for a vegan eyeshadow product by brand 'Ara' with ingredients 'Mica', 'Iron Oxide', 'Titanium Dioxide' and 'Zinc Oxide'.", "context": "CREATE TABLE cosmetic_ingredients (ingredient_id INT, product_name TEXT, brand_name TEXT, ingredient_type TEXT);", "reference_sql": "INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type) VALUES (NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient'); INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type, ingredient_name) SELECT ingredient_id, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Mica' FROM cosmetic_ingredients WHERE ingredient_name = 'Mica' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Iron Oxide' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Titanium Dioxide' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Zinc Oxide';", "generated_sql": "INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type)\nVALUES \n((SELECT COALESCE(MAX(ingredient_id), 0) + 1 FROM cosmetic_ingredients), 'Vegan Eyeshadow', 'Ara', 'Mica'),\n((SELECT COALESCE(MAX(ingredient_id), 0) + 2 FROM cosmetic_ingredients), 'Vegan Eyeshadow', 'Ara', 'Iron Oxide'),\n((SELECT COALESCE(MAX(ingredient_id), 0) + 3 FROM cosmetic_ingredients), 'Vegan Eyeshadow', 'Ara', 'Titanium Dioxide'),\n((SELECT COALESCE(MAX(ingredient_id), 0) + 4 FROM cosmetic_ingredients), 'Vegan Eyeshadow', 'Ara', 'Zinc Oxide');", "raw_model_output": "To insert new data into the `cosmetic_ingredients` table for a vegan eyeshadow product by brand 'Ara' with ingredients 'Mica', 'Iron Oxide', 'Titanium Dioxide', and 'Zinc Oxide', you can use the following SQL statement:\n\n```sql\nINSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type)\nVALUES \n((SELECT COALESCE(MAX(ingredient_id), 0) + 1 FROM cosmetic_ingredients), 'Vegan Eyeshadow', 'Ara', 'Mica'),\n((SELECT COALESCE(MAX(ingredient_id), 0) + 2 FROM cosmetic_ingredients), 'Vegan Eyeshadow', 'Ara', 'Iron Oxide'),\n((SELECT COALESCE(MAX(ingredient_id), 0) + 3 FROM cosmetic_ingredients), 'Vegan Eyeshadow', 'Ara', 'Titanium Dioxide'),\n((SELECT COALESCE(MAX(ingredient_id), 0) + 4 FROM cosmetic_ingredients), 'Vegan Eyeshadow', 'Ara', 'Zinc Oxide');\n```\n\nThis SQL statement inserts four rows into the `cosmetic_ingredients` table, each with a unique `ingredient_id`, the same `product_name` and `brand_name`, and different `ingredient_type`.", "latency_sec": 6.709813833236694, "total_duration_sec": 6.655782374, "load_duration_sec": 0.016399837, "tokens_prompt": 756, "prompt_eval_sec": 0.314211348, "tokens_completion": 274, "completion_eval_sec": 6.321650255, "tokens_total": 1030, "tokens_per_sec": 153.5064944571117, "retrieval_latency_sec": 0.1096651554107666, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL inserts rows with 'Ingredient' as the ingredient_type, while the Generated SQL uses specific ingredient names (e.g., 'Mica') as the ingredient_type. Additionally, the Reference SQL includes a NULL ingredient_id and potentially duplicates existing data, whereas the Generated SQL generates sequential ingredient_ids and inserts distinct entries without relying on existing data."}
{"example_id": 3404, "sql_complexity": "multiple_joins", "prompt": "What are the names of startups that have received funding from investors with over 3 million funds, and are involved in Genetic Research or Bioprocess Engineering?", "context": "CREATE TABLE public.investors ( id SERIAL PRIMARY KEY, name VARCHAR(100), type VARCHAR(50), funds INTEGER ); CREATE TABLE public.investments ( id SERIAL PRIMARY KEY, investor_id INTEGER, startup_id INTEGER ); CREATE TABLE public.startups ( id SERIAL PRIMARY KEY, name VARCHAR(100), industry VARCHAR(50), funding INTEGER );", "reference_sql": "SELECT startups.name FROM public.startups JOIN public.investments ON startups.id = investments.startup_id JOIN public.investors ON investments.investor_id = investors.id WHERE (startups.industry = 'Genetic Research' OR startups.industry = 'Bioprocess Engineering') AND investors.funds > 3000000;", "generated_sql": "SELECT DISTINCT s.name \nFROM startups s\nJOIN investments i ON s.id = i.startup_id\nJOIN investors iv ON i.investor_id = iv.id\nWHERE iv.funds > 3000000 AND s.industry IN ('Genetic Research', 'Bioprocess Engineering');", "raw_model_output": "To find the names of startups that have received funding from investors with over 3 million funds and are involved in Genetic Research or Bioprocess Engineering, you can use the following SQL query:\n\n```sql\nSELECT DISTINCT s.name \nFROM startups s\nJOIN investments i ON s.id = i.startup_id\nJOIN investors iv ON i.investor_id = iv.id\nWHERE iv.funds > 3000000 AND s.industry IN ('Genetic Research', 'Bioprocess Engineering');\n```", "latency_sec": 3.1692068576812744, "total_duration_sec": 2.888409244, "load_duration_sec": 0.016283357, "tokens_prompt": 931, "prompt_eval_sec": 0.366405895, "tokens_completion": 106, "completion_eval_sec": 2.50125017, "tokens_total": 1037, "tokens_per_sec": 327.2112066420029, "retrieval_latency_sec": 0.1022789478302002, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The generated query includes DISTINCT which ensures unique startup names, while the reference query may return duplicates. The WHERE clause logic is equivalent (IN vs OR), but the DISTINCT clause in the generated query changes the result set's uniqueness characteristics."}
{"example_id": 134, "sql_complexity": "subqueries", "prompt": "Who are the top 3 authors with the most citations in the Mathematics department in the past 5 years?", "context": "CREATE TABLE authors (id INT, name VARCHAR(50), department VARCHAR(50)); INSERT INTO authors (id, name, department) VALUES (1, 'Author Name', 'Mathematics'); CREATE TABLE publications (id INT, title VARCHAR(100), author VARCHAR(50), journal VARCHAR(50), year INT, cites INT); INSERT INTO publications (id, title, author, journal, year, cites) VALUES (1, 'Publication Title', 'Author Name', 'Journal Name', 2021, 10);", "reference_sql": "SELECT author, SUM(cites) as total_cites FROM publications WHERE author IN (SELECT name FROM authors WHERE department = 'Mathematics') AND year BETWEEN YEAR(CURRENT_DATE) - 5 AND YEAR(CURRENT_DATE) GROUP BY author ORDER BY total_cites DESC LIMIT 3;", "generated_sql": "SELECT a.name, SUM(p.cites) AS total_citations\nFROM authors a\nJOIN publications p ON a.name = p.author\nWHERE a.department = 'Mathematics' AND p.year >= (YEAR(CURRENT_DATE) - 5)\nGROUP BY a.name\nORDER BY total_citations DESC\nLIMIT 3;", "raw_model_output": "To find the top 3 authors with the most citations in the Mathematics department in the past 5 years, we need to join the `authors` and `publications` tables on the author's name. We then filter for publications that are from the Mathematics department and were published within the last 5 years (i.e., year >= current_year - 5). Finally, we group by the author's name, sum their citations, order by the total number of citations in descending order, and limit the results to the top 3.\n\nHere is the SQL query:\n\n```sql\nSELECT a.name, SUM(p.cites) AS total_citations\nFROM authors a\nJOIN publications p ON a.name = p.author\nWHERE a.department = 'Mathematics' AND p.year >= (YEAR(CURRENT_DATE) - 5)\nGROUP BY a.name\nORDER BY total_citations DESC\nLIMIT 3;\n```", "latency_sec": 5.104832172393799, "total_duration_sec": 4.82127192, "load_duration_sec": 0.01558338, "tokens_prompt": 1059, "prompt_eval_sec": 0.401015543, "tokens_completion": 186, "completion_eval_sec": 4.399637291, "tokens_total": 1245, "tokens_per_sec": 243.88656824660794, "retrieval_latency_sec": 0.10538029670715332, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses BETWEEN YEAR(CURRENT_DATE) - 5 AND YEAR(CURRENT_DATE) which includes both lower and upper bounds, while the Generated SQL only uses p.year >= (YEAR(CURRENT_DATE) - 5) missing the upper bound. This means the Generated SQL could include publications from years beyond the current year, making them semantically different."}
{"example_id": 592, "sql_complexity": "set operations", "prompt": "How many public healthcare facilities and public parks are there in total, in the 'StateData' schema's 'StateHealthcare' and 'StateParks' tables?", "context": "CREATE SCHEMA StateData; CREATE TABLE StateHealthcare (Name varchar(255), Type varchar(255)); INSERT INTO StateHealthcare (Name, Type) VALUES ('FacilityA', 'Public'), ('FacilityB', 'Public'), ('FacilityC', 'Private'); CREATE TABLE StateParks (Name varchar(255), Type varchar(255)); INSERT INTO StateParks (Name, Type) VALUES ('ParkA', 'Public'), ('ParkB', 'Public'), ('ParkC', 'Private');", "reference_sql": "SELECT COUNT(*) FROM StateData.StateHealthcare WHERE Type = 'Public' UNION ALL SELECT COUNT(*) FROM StateData.StateParks WHERE Type = 'Public';", "generated_sql": "SELECT SUM(public_count) AS total_public_facilities\nFROM (\n    SELECT COUNT(*) AS public_count FROM StateHealthcare WHERE Type = 'Public'\n    UNION ALL\n    SELECT COUNT(*) AS public_count FROM StateParks WHERE Type = 'Public'\n) subquery;", "raw_model_output": "To find the total number of public healthcare facilities and public parks, we need to count the rows in both `StateHealthcare` and `StateParks` tables where the type is 'Public'. We can achieve this by using a UNION ALL to combine counts from both tables and then summing them up.\n\nHere's the SQL query:\n\n```sql\nSELECT SUM(public_count) AS total_public_facilities\nFROM (\n    SELECT COUNT(*) AS public_count FROM StateHealthcare WHERE Type = 'Public'\n    UNION ALL\n    SELECT COUNT(*) AS public_count FROM StateParks WHERE Type = 'Public'\n) subquery;\n```\n\nThis query first counts the number of public healthcare facilities and parks separately, then combines these counts using `UNION ALL`, and finally sums them up to get the total count.", "latency_sec": 4.2368080615997314, "total_duration_sec": 4.133745852, "load_duration_sec": 0.016607088, "tokens_prompt": 759, "prompt_eval_sec": 0.313059847, "tokens_completion": 164, "completion_eval_sec": 3.800508909, "tokens_total": 923, "tokens_per_sec": 217.8526821560791, "retrieval_latency_sec": 0.10495996475219727, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate counts (one from StateHealthcare and one from StateParks) as two rows, while the Generated SQL sums these counts into a single total value. The result structures differ (two rows vs. one row) and the values would also differ (2 and 2 vs. 4 for the given data)."}
{"example_id": 1989, "sql_complexity": "single join", "prompt": "What are the names and production dates of garments made from fabrics with a sustainability score over 70, produced after 2021-01-01?", "context": "CREATE TABLE fabrics (id INT, name VARCHAR(50), type VARCHAR(50), sustainability_score INT); INSERT INTO fabrics (id, name, type, sustainability_score) VALUES (1, 'Organic Linen', 'Natural', 80); INSERT INTO fabrics (id, name, type, sustainability_score) VALUES (2, 'Recycled Nylon', 'Synthetic', 72);", "reference_sql": "SELECT garments.name, garments.production_date FROM garments JOIN fabrics ON garments.fabric_id = fabrics.id WHERE fabrics.sustainability_score > 70 AND garments.production_date > '2021-01-01';", "generated_sql": "SELECT garments.name, garments.production_date \nFROM garments \nJOIN fabrics ON garments.fabric_id = fabrics.id \nWHERE fabrics.sustainability_score > 70 AND garments.production_date > '2021-01-01';", "raw_model_output": "To retrieve the names and production dates of garments made from fabrics with a sustainability score over 70, produced after 2021-01-01, we need to join the `garments` table with the `fabrics` table on the fabric ID. We then filter based on the sustainability score and production date.\n\nHere is the SQL statement:\n\n```sql\nSELECT garments.name, garments.production_date \nFROM garments \nJOIN fabrics ON garments.fabric_id = fabrics.id \nWHERE fabrics.sustainability_score > 70 AND garments.production_date > '2021-01-01';\n```", "latency_sec": 3.5358810424804688, "total_duration_sec": 3.297875882, "load_duration_sec": 0.019505401, "tokens_prompt": 710, "prompt_eval_sec": 0.312108692, "tokens_completion": 128, "completion_eval_sec": 2.958639053, "tokens_total": 838, "tokens_per_sec": 236.99892330431217, "retrieval_latency_sec": 0.10222697257995605, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure, column selection, join conditions, and WHERE clause filters. The only difference is formatting (line breaks), which does not affect semantic equivalence."}
{"example_id": 1388, "sql_complexity": "aggregation", "prompt": "What was the total donation amount by each organization in the last 30 days?", "context": "CREATE TABLE organization_donations (id INT, organization TEXT, donation_date DATE, donation_amount DECIMAL(10,2)); INSERT INTO organization_donations (id, organization, donation_date, donation_amount) VALUES (1, 'Organization A', '2021-03-15', 100.00), (2, 'Organization B', '2021-03-25', 200.00);", "reference_sql": "SELECT organization, SUM(donation_amount) FROM organization_donations WHERE donation_date >= DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY) GROUP BY organization;", "generated_sql": "SELECT organization, SUM(donation_amount) AS total_donation \nFROM organization_donations \nWHERE donation_date >= CURRENT_DATE - INTERVAL '30' DAY \nGROUP BY organization;", "raw_model_output": "To find the total donation amount by each organization in the last 30 days from today, you can use the following SQL query:\n\n```sql\nSELECT organization, SUM(donation_amount) AS total_donation \nFROM organization_donations \nWHERE donation_date >= CURRENT_DATE - INTERVAL '30' DAY \nGROUP BY organization;\n```\n\nThis query filters records to include only those donations made in the last 30 days and then groups them by `organization` while summing up the `donation_amount` for each group.", "latency_sec": 3.262822151184082, "total_duration_sec": 3.001631436, "load_duration_sec": 0.016448853, "tokens_prompt": 981, "prompt_eval_sec": 0.383740948, "tokens_completion": 108, "completion_eval_sec": 2.597325266, "tokens_total": 1089, "tokens_per_sec": 333.7601467505057, "retrieval_latency_sec": 0.10735726356506348, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of donation_amount for each organization where donation_date is within the last 30 days. The date calculation syntax differs (DATE_SUB vs. CURRENT_DATE - INTERVAL), but both expressions evaluate to the same date value. The column alias (total_donation) in the generated query does not affect semantic equivalence as it only changes the result column name, not the data returned."}
{"example_id": 1628, "sql_complexity": "window functions", "prompt": "What is the ranking of national security measures for Russia based on the publication date?", "context": "CREATE TABLE national_security (id INT, title VARCHAR(255), description TEXT, agency VARCHAR(255), date DATE); INSERT INTO national_security (id, title, description, agency, date) VALUES (1, 'National Cyber Strategy', 'Outlines the approach to protecting the American people and the American way of life in the digital age', 'White House', '2018-09-20'); INSERT INTO national_security (id, title, description, agency, date) VALUES (2, 'Cybersecurity and Infrastructure Security Agency Act of 2018', 'Establishes the Cybersecurity and Infrastructure Security Agency within the Department of Homeland Security', 'Congress', '2018-11-16'); INSERT INTO national_security (id, title, description, agency, date) VALUES (3, 'Russian Military Doctrine', 'Outlines the country\u2019s stance on military security', 'Russian Government', '2014-12-26');", "reference_sql": "SELECT title, description, agency, date, ROW_NUMBER() OVER (PARTITION BY agency ORDER BY date DESC) as ranking FROM national_security WHERE agency = 'Russian Government';", "generated_sql": "SELECT title, description, agency, date,\n       RANK() OVER(ORDER BY date ASC) AS ranking\nFROM national_security\nWHERE agency = 'Russian Government';", "raw_model_output": "To determine the ranking of national security measures for Russia based on their publication dates, we need to filter the `national_security` table by the country (Russia in this case) and then assign a rank based on the publication date. Here is the corresponding SQL query:\n\n```sql\nSELECT title, description, agency, date,\n       RANK() OVER(ORDER BY date ASC) AS ranking\nFROM national_security\nWHERE agency = 'Russian Government';\n```\n\nThis query selects the relevant columns from the `national_security` table where the `agency` column indicates Russian measures and assigns a rank based on the publication dates in ascending order.", "latency_sec": 3.685364007949829, "total_duration_sec": 3.625992701, "load_duration_sec": 0.015285947, "tokens_prompt": 1304, "prompt_eval_sec": 0.603041763, "tokens_completion": 128, "completion_eval_sec": 3.001050645, "tokens_total": 1432, "tokens_per_sec": 388.56405959112374, "retrieval_latency_sec": 0.1054079532623291, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects: 1) The Reference uses ROW_NUMBER() with PARTITION BY agency and ORDER BY date DESC, while the Generated uses RANK() with no partition and ORDER BY date ASC. 2) The Reference's PARTITION BY agency is redundant due to the WHERE clause, but the ordering direction and ranking function differ. These differences would produce opposite rankings for multiple rows (e.g., earliest vs. latest dates) and different behavior with ties."}
{"example_id": 2300, "sql_complexity": "aggregation", "prompt": "What is the minimum capacity for schools in each location ('community_development')?", "context": "CREATE TABLE community_development.schools (id INT, name VARCHAR(50), capacity INT, location VARCHAR(50));", "reference_sql": "SELECT location, MIN(capacity) FROM community_development.schools GROUP BY location;", "generated_sql": "SELECT location, MIN(capacity) AS min_capacity \nFROM community_development.schools \nGROUP BY location;", "raw_model_output": "To find the minimum capacity for schools in each location, we need to group the data by `location` and then use the `MIN()` function on the `capacity` column. Here is the corresponding SQL query:\n\n```sql\nSELECT location, MIN(capacity) AS min_capacity \nFROM community_development.schools \nGROUP BY location;\n```", "latency_sec": 1.9335098266601562, "total_duration_sec": 1.788921677, "load_duration_sec": 0.015007715, "tokens_prompt": 484, "prompt_eval_sec": 0.115779189, "tokens_completion": 70, "completion_eval_sec": 1.654244763, "tokens_total": 554, "tokens_per_sec": 286.5255673186573, "retrieval_latency_sec": 0.10798215866088867, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries group schools by location and calculate the minimum capacity per group. The generated query adds an alias 'min_capacity' for the MIN(capacity) column, but this does not affect the semantic result set. The core logic and output data remain identical."}
{"example_id": 4976, "sql_complexity": "set operations", "prompt": "What is the most common hashtag used in posts made by users from Brazil?", "context": "CREATE TABLE posts (id INT, user_id INT, content TEXT, hashtags TEXT, post_date DATE); INSERT INTO posts (id, user_id, content, hashtags, post_date) VALUES (1, 1, 'Hello World', '#datascience', '2022-06-01'), (2, 1, 'I love data', '#ai', '2022-06-02'), (3, 2, 'Ol\u00e1 Mundo', '#brasil', '2022-06-03'); CREATE TABLE users (id INT, name VARCHAR(100), country VARCHAR(50)); INSERT INTO users (id, name, country) VALUES (1, 'Jo\u00e3o Silva', 'Brazil'), (2, 'Maria Souza', 'Brazil');", "reference_sql": "SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(hashtags, ' ', n.n), ' ', -1) hashtag, COUNT(*) count FROM posts JOIN users ON posts.user_id = users.id CROSS JOIN (SELECT 1 n UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5) n WHERE users.country = 'Brazil' GROUP BY hashtag ORDER BY count DESC LIMIT 1;", "generated_sql": "SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(p.hashtags, ' ', n.n), ' ', -1) AS hashtag,\n       COUNT(*) AS count\nFROM posts p\nJOIN users u ON p.user_id = u.id\nCROSS JOIN (SELECT 1 n UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5) n\nWHERE u.country = 'Brazil'\nGROUP BY SUBSTRING_INDEX(SUBSTRING_INDEX(p.hashtags, ' ', n.n), ' ', -1)\nORDER BY count DESC\nLIMIT 1;", "raw_model_output": "To find the most common hashtag used in posts made by users from Brazil, we need to:\n\n1. Join the `posts` and `users` tables on `user_id` and `id`.\n2. Filter for users whose country is 'Brazil'.\n3. Split the hashtags into individual tags.\n4. Count the occurrences of each tag.\n5. Order the results by count in descending order and limit to 1.\n\nHere's the SQL query:\n\n```sql\nSELECT SUBSTRING_INDEX(SUBSTRING_INDEX(p.hashtags, ' ', n.n), ' ', -1) AS hashtag,\n       COUNT(*) AS count\nFROM posts p\nJOIN users u ON p.user_id = u.id\nCROSS JOIN (SELECT 1 n UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5) n\nWHERE u.country = 'Brazil'\nGROUP BY SUBSTRING_INDEX(SUBSTRING_INDEX(p.hashtags, ' ', n.n), ' ', -1)\nORDER BY count DESC\nLIMIT 1;\n```", "latency_sec": 5.723557949066162, "total_duration_sec": 5.648439248, "load_duration_sec": 0.01421861, "tokens_prompt": 1398, "prompt_eval_sec": 0.625224442, "tokens_completion": 208, "completion_eval_sec": 5.003634789, "tokens_total": 1606, "tokens_per_sec": 280.59469551837594, "retrieval_latency_sec": 0.10006189346313477, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries extract hashtags from the 'hashtags' column using the same SUBSTRING_INDEX logic, join with users table filtering for Brazil, and group by the extracted hashtag. The only difference is that the Reference SQL uses an alias in GROUP BY while Generated SQL repeats the expression. Since MySQL allows alias usage in GROUP BY, the semantic result remains identical."}
{"example_id": 4637, "sql_complexity": "single join", "prompt": "What is the total value of transactions for each customer in the last 30 days?", "context": "CREATE TABLE transactions (id INT, customer_id INT, value DECIMAL(10, 2), transaction_date DATE); INSERT INTO transactions (id, customer_id, value, transaction_date) VALUES (1, 1, 100, '2022-01-01'), (2, 1, 200, '2022-01-15'), (3, 2, 50, '2022-01-05'), (4, 2, 150, '2022-01-30'), (5, 3, 300, '2022-01-20');", "reference_sql": "SELECT c.id, SUM(t.value) FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE t.transaction_date >= CURDATE() - INTERVAL 30 DAY GROUP BY c.id;", "generated_sql": "SELECT customer_id, SUM(value) AS total_value \nFROM transactions \nWHERE transaction_date >= CURRENT_DATE - INTERVAL '30 days' \nGROUP BY customer_id;", "raw_model_output": "To calculate the total value of transactions for each customer in the last 30 days using the provided schema:\n\n```sql\nSELECT customer_id, SUM(value) AS total_value \nFROM transactions \nWHERE transaction_date >= CURRENT_DATE - INTERVAL '30 days' \nGROUP BY customer_id;\n```\n\nThis SQL statement selects the `customer_id` and sums up the `value` for each customer's transactions that occurred in the last 30 days. The `CURRENT_DATE - INTERVAL '30 days'` expression is used to filter out transactions older than 30 days.", "latency_sec": 3.539686918258667, "total_duration_sec": 3.270099424, "load_duration_sec": 0.037886923, "tokens_prompt": 1066, "prompt_eval_sec": 0.405264786, "tokens_completion": 118, "completion_eval_sec": 2.819113319, "tokens_total": 1184, "tokens_per_sec": 334.4928597759893, "retrieval_latency_sec": 0.10261869430541992, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the total transaction value per customer for the last 30 days. The Reference SQL uses an INNER JOIN with customers and groups by c.id, while the Generated SQL directly groups transactions by customer_id. Since the WHERE clause filters transactions to the last 30 days in both cases, and the grouping/columns are functionally equivalent (customer_id vs c.id), the result sets will be identical. The date calculation syntax differences (CURDATE vs CURRENT_DATE) are functionally equivalent in this context."}
{"example_id": 4947, "sql_complexity": "aggregation", "prompt": "What is the total revenue for drugs approved between 2017 and 2019?", "context": "CREATE TABLE drug_sales_3 (drug_name TEXT, revenue FLOAT, year INT); INSERT INTO drug_sales_3 (drug_name, revenue, year) VALUES ('DrugG', 20000000, 2019), ('DrugG', 19000000, 2018), ('DrugH', 15000000, 2017), ('DrugH', 16000000, 2018);", "reference_sql": "SELECT drug_name, SUM(revenue) FROM drug_sales_3 WHERE year BETWEEN 2017 AND 2019 GROUP BY drug_name;", "generated_sql": "SELECT SUM(revenue) AS total_revenue \nFROM drug_sales_3 \nWHERE year BETWEEN 2017 AND 2019;", "raw_model_output": "To calculate the total revenue for drugs approved between 2017 and 2019, we need to filter the `drug_sales_3` table based on the year range provided. Since there is no separate approval table in this schema, we assume that all entries within the specified years are relevant.\n\nHere's the SQL query:\n\n```sql\nSELECT SUM(revenue) AS total_revenue \nFROM drug_sales_3 \nWHERE year BETWEEN 2017 AND 2019;\n```\n\nThis query sums up the revenue for all records in `drug_sales_3` where the year is between 2017 and 2019.", "latency_sec": 3.9914920330047607, "total_duration_sec": 3.687610699, "load_duration_sec": 0.016821401, "tokens_prompt": 989, "prompt_eval_sec": 0.382907506, "tokens_completion": 139, "completion_eval_sec": 3.283267097, "tokens_total": 1128, "tokens_per_sec": 282.60109018703247, "retrieval_latency_sec": 0.10022687911987305, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query groups results by drug_name, returning individual drug totals, while the generated query returns a single total revenue without grouping. The presence/absence of GROUP BY changes the result structure and content."}
{"example_id": 4767, "sql_complexity": "window functions", "prompt": "List the top 2 AI algorithms with the highest explainability scores, by algorithm subtype, ordered by scores in descending order for the European region.", "context": "CREATE TABLE ai_algorithms (algorithm_id INT, algorithm_name VARCHAR(50), algorithm_subtype VARCHAR(50), region VARCHAR(50), explainability_score FLOAT); INSERT INTO ai_algorithms (algorithm_id, algorithm_name, algorithm_subtype, region, explainability_score) VALUES (1, 'AlgoA', 'Tree-based', 'Europe', 0.85), (2, 'AlgoB', 'Computer Vision', 'Europe', 0.92), (3, 'AlgoC', 'Tree-based', 'Europe', 0.78), (4, 'AlgoD', 'Transformer', 'Europe', 0.90), (5, 'AlgoE', 'Tree-based', 'Europe', 0.80);", "reference_sql": "SELECT algorithm_subtype, region, * FROM (SELECT algorithm_subtype, region, algorithm_id, algorithm_name, explainability_score, RANK() OVER (PARTITION BY algorithm_subtype ORDER BY explainability_score DESC) AS rank FROM ai_algorithms WHERE region = 'Europe') ranked WHERE rank <= 2 ORDER BY algorithm_subtype, region, explainability_score DESC;", "generated_sql": "SELECT algorithm_name, explainability_score, algorithm_subtype \nFROM ai_algorithms \nWHERE region = 'Europe' \nORDER BY explainability_score DESC \nLIMIT 2;", "raw_model_output": "To list the top 2 AI algorithms with the highest explainability scores by algorithm subtype for the European region, ordered by scores in descending order, you can use the following SQL query:\n\n```sql\nSELECT algorithm_name, explainability_score, algorithm_subtype \nFROM ai_algorithms \nWHERE region = 'Europe' \nORDER BY explainability_score DESC \nLIMIT 2;\n```\n\nHowever, this will give only the top two algorithms overall. To get the top 2 by subtype, we need to use a window function:\n\n```sql\nSELECT algorithm_name, explainability_score, algorithm_subtype \nFROM (\n    SELECT *, ROW_NUMBER() OVER (PARTITION BY algorithm_subtype ORDER BY explainability_score DESC) as rank\n    FROM ai_algorithms\n    WHERE region = 'Europe'\n) subquery\nWHERE rank <= 2;\n```\n\nThis query uses a window function to assign a ranking within each subtype and then filters for the top two in each subtype.", "latency_sec": 5.086006164550781, "total_duration_sec": 4.999727298, "load_duration_sec": 0.015698721, "tokens_prompt": 992, "prompt_eval_sec": 0.384465046, "tokens_completion": 194, "completion_eval_sec": 4.594999945, "tokens_total": 1186, "tokens_per_sec": 233.1888640376339, "retrieval_latency_sec": 0.10340118408203125, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL selects top 2 algorithms per subtype (e.g., Tree-based, Computer Vision, Transformer) in Europe, while the Generated SQL returns only the top 2 algorithms overall in Europe. For the sample data, Reference SQL returns 4 rows (2 per subtype) and Generated SQL returns 2 rows (top 2 overall)."}
{"example_id": 4495, "sql_complexity": "basic SQL", "prompt": "Which countries are the top 3 sources of sustainable textiles?", "context": "CREATE TABLE Textile_Sources (Source_ID INT, Source_Country TEXT, Sustainable BOOLEAN, Quantity INT); INSERT INTO Textile_Sources (Source_ID, Source_Country, Sustainable, Quantity) VALUES (1, 'India', true, 1000), (2, 'Bangladesh', false, 800), (3, 'China', true, 1200), (4, 'Vietnam', false, 900), (5, 'Italy', true, 1100), (6, 'USA', false, 700);", "reference_sql": "SELECT Source_Country FROM Textile_Sources WHERE Sustainable = true ORDER BY Quantity DESC LIMIT 3;", "generated_sql": "SELECT Source_Country, SUM(Quantity) AS Total_Quantity \nFROM Textile_Sources \nWHERE Sustainable = TRUE \nGROUP BY Source_Country \nORDER BY Total_Quantity DESC \nLIMIT 3;", "raw_model_output": "To find the top 3 countries that are the largest sources of sustainable textiles, we need to filter for sustainable textile sources and then group by country. We will calculate the total quantity from each country and order it in descending order before limiting the results to the top 3.\n\nHere is the corresponding SQL query:\n\n```sql\nSELECT Source_Country, SUM(Quantity) AS Total_Quantity \nFROM Textile_Sources \nWHERE Sustainable = TRUE \nGROUP BY Source_Country \nORDER BY Total_Quantity DESC \nLIMIT 3;\n```", "latency_sec": 3.192354202270508, "total_duration_sec": 2.918239208, "load_duration_sec": 0.01586642, "tokens_prompt": 810, "prompt_eval_sec": 0.327527534, "tokens_completion": 109, "completion_eval_sec": 2.57153662, "tokens_total": 919, "tokens_per_sec": 287.8753239055919, "retrieval_latency_sec": 0.10231590270996094, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL returns only 'Source_Country' values from sustainable sources, ordered by Quantity and limited to 3. The Generated SQL groups by 'Source_Country', sums Quantity (which coincidentally equals the original Quantity due to unique per-country entries), and adds a 'Total_Quantity' column. The result set structure differs (1 column vs. 2 columns), making them semantically distinct."}
{"example_id": 2513, "sql_complexity": "single join", "prompt": "What is the total number of concert ticket sales for artists who released their first album between 2015 and 2017?", "context": "CREATE TABLE ConcertTicketSales (id INT, year INT, artist_id INT); CREATE TABLE ArtistAlbums (id INT, artist_id INT, year INT);", "reference_sql": "SELECT COUNT(DISTINCT cts.artist_id) FROM ConcertTicketSales cts JOIN ArtistAlbums a ON cts.artist_id = a.artist_id WHERE a.year BETWEEN 2015 AND 2017;", "generated_sql": "SELECT SUM(T1.id) AS total_concert_ticket_sales\nFROM ConcertTicketSales T1\nJOIN (\n    SELECT artist_id, MIN(year) AS first_album_year\n    FROM ArtistAlbums\n    WHERE year BETWEEN 2015 AND 2017\n    GROUP BY artist_id\n) T2 ON T1.artist_id = T2.artist_id;", "raw_model_output": "To find the total number of concert ticket sales for artists who released their first album between 2015 and 2017, we need to follow these steps:\n\n1. Identify artists who released their first album in the specified years.\n2. Calculate the total number of concert ticket sales for those artists.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT SUM(T1.id) AS total_concert_ticket_sales\nFROM ConcertTicketSales T1\nJOIN (\n    SELECT artist_id, MIN(year) AS first_album_year\n    FROM ArtistAlbums\n    WHERE year BETWEEN 2015 AND 2017\n    GROUP BY artist_id\n) T2 ON T1.artist_id = T2.artist_id;\n```\n\nThis query joins the `ConcertTicketSales` table with a subquery that identifies artists who released their first album between 2015 and 2017. The main query then sums up the concert ticket sales for those artists.", "latency_sec": 5.313515901565552, "total_duration_sec": 5.140391298, "load_duration_sec": 0.022723796, "tokens_prompt": 797, "prompt_eval_sec": 0.321509121, "tokens_completion": 207, "completion_eval_sec": 4.791455971, "tokens_total": 1004, "tokens_per_sec": 188.9521022613644, "retrieval_latency_sec": 0.10514116287231445, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query counts distinct artist_ids from ConcertTicketSales joined with ArtistAlbums where the album year is between 2015-2017. The generated query sums the id values from ConcertTicketSales after joining with a subquery that filters ArtistAlbums for albums in 2015-2017. The two queries aggregate different data (count of distinct artists vs. sum of ticket IDs) and have different logical purposes, making them semantically non-equivalent."}
{"example_id": 873, "sql_complexity": "subqueries", "prompt": "Identify attorneys who have never handled cases in the 'West' region but have in the 'North' or 'South'.", "context": "CREATE TABLE attorney_regions(attorney_id INT, region VARCHAR(20)); INSERT INTO attorney_regions(attorney_id, region) VALUES (1, 'North'), (2, 'South'), (3, 'East'), (4, 'West'), (5, 'West'), (6, 'North'); CREATE TABLE handled_cases(attorney_id INT, case_id INT); INSERT INTO handled_cases(attorney_id, case_id) VALUES (1, 101), (2, 102), (3, 103), (4, 104), (5, 105), (6, 106), (1, 107), (1, 108);", "reference_sql": "SELECT h.attorney_id FROM attorney_regions h LEFT JOIN handled_cases i ON h.attorney_id = i.attorney_id WHERE h.region IN ('North', 'South') AND h.region != 'West' AND i.attorney_id IS NOT NULL AND h.attorney_id NOT IN (SELECT attorney_id FROM attorney_regions WHERE region = 'West');", "generated_sql": "SELECT ar.attorney_id \nFROM attorney_regions ar\nJOIN (\n    SELECT attorney_id \n    FROM handled_cases \n    WHERE attorney_id IN (\n        SELECT attorney_id \n        FROM attorney_regions \n        WHERE region = 'North' OR region = 'South'\n    )\n) hc ON ar.attorney_id = hc.attorney_id\nLEFT JOIN handled_cases wc ON ar.attorney_id = wc.attorney_id AND wc.case_id IN (\n    SELECT case_id \n    FROM handled_cases \n    WHERE attorney_id IN (\n        SELECT attorney_id \n        FROM attorney_regions \n        WHERE region = 'West'\n    )\n)\nWHERE ar.region != 'West' AND wc.case_id IS NULL;", "raw_model_output": "To identify attorneys who have never handled cases in the 'West' region but have handled cases in either the 'North' or 'South' regions, we can use a combination of `LEFT JOIN`, `WHERE` clauses, and subqueries. Here is the SQL statement:\n\n```sql\nSELECT ar.attorney_id \nFROM attorney_regions ar\nJOIN (\n    SELECT attorney_id \n    FROM handled_cases \n    WHERE attorney_id IN (\n        SELECT attorney_id \n        FROM attorney_regions \n        WHERE region = 'North' OR region = 'South'\n    )\n) hc ON ar.attorney_id = hc.attorney_id\nLEFT JOIN handled_cases wc ON ar.attorney_id = wc.attorney_id AND wc.case_id IN (\n    SELECT case_id \n    FROM handled_cases \n    WHERE attorney_id IN (\n        SELECT attorney_id \n        FROM attorney_regions \n        WHERE region = 'West'\n    )\n)\nWHERE ar.region != 'West' AND wc.case_id IS NULL;\n```\n\nThis query first identifies attorneys who have handled cases in the 'North' or 'South' regions. Then, it ensures these attorneys have not handled any case in the 'West' region by checking for null values from a `LEFT JOIN` with the `handled_cases` table where the attorney has been associated with the 'West' region.", "latency_sec": 7.031797170639038, "total_duration_sec": 6.749686912, "load_duration_sec": 0.019348071, "tokens_prompt": 1103, "prompt_eval_sec": 0.547281133, "tokens_completion": 267, "completion_eval_sec": 6.179095053, "tokens_total": 1370, "tokens_per_sec": 194.82928286389932, "retrieval_latency_sec": 0.10434818267822266, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL selects North/South region attorneys with cases (excluding West region attorneys), while the Generated SQL adds an additional filter to exclude attorneys who have any case in the West region's cases. This makes the Generated SQL more restrictive, leading to different results in scenarios where attorneys have cross-region cases."}
{"example_id": 471, "sql_complexity": "set operations", "prompt": "Find the number of donations made by first-time donors in the last quarter.", "context": "CREATE TABLE Donations (DonationID INT, DonorID INT, DonationDate DATE, DonationType TEXT, DonationAmount FLOAT); INSERT INTO Donations (DonationID, DonorID, DonationDate, DonationType, DonationAmount) VALUES (1, 1, '2021-01-01', 'Individual', 100), (2, 2, '2021-02-01', 'Corporate', 5000);", "reference_sql": "SELECT COUNT(*) FROM (SELECT DonationID FROM Donations WHERE DonationType = 'Individual' AND DonationDate >= DATEADD(quarter, -1, CURRENT_DATE) EXCEPT SELECT DonationID FROM PreviousDonations) AS FirstTimeDonors;", "generated_sql": "SELECT COUNT(DonationID) AS FirstTimeDonationsCount \nFROM Donations d1\nWHERE DonationDate >= DATE_TRUNC('quarter', CURRENT_DATE - INTERVAL '3 months')\nAND DonorID NOT IN (\n    SELECT DonorID \n    FROM Donations \n    WHERE DonationDate < DATE_TRUNC('quarter', CURRENT_DATE - INTERVAL '3 months')\n);", "raw_model_output": "To find the number of donations made by first-time donors in the last quarter, we need to identify donors who have not made any previous donations before the start of the current quarter and then count their donations within that period.\n\nHere is the SQL statement:\n\n```sql\nSELECT COUNT(DonationID) AS FirstTimeDonationsCount \nFROM Donations d1\nWHERE DonationDate >= DATE_TRUNC('quarter', CURRENT_DATE - INTERVAL '3 months')\nAND DonorID NOT IN (\n    SELECT DonorID \n    FROM Donations \n    WHERE DonationDate < DATE_TRUNC('quarter', CURRENT_DATE - INTERVAL '3 months')\n);\n```\n\nExplanation:\n- `DATE_TRUNC('quarter', CURRENT_DATE - INTERVAL '3 months')` calculates the start of the last quarter.\n- The subquery identifies donors who have made donations before the start of the current quarter (last quarter).\n- The main query counts the number of donations from those donors who are not in the list identified by the subquery, i.e., first-time donors in the last quarter.", "latency_sec": 5.41626501083374, "total_duration_sec": 5.366554478, "load_duration_sec": 0.016293177, "tokens_prompt": 1026, "prompt_eval_sec": 0.398207119, "tokens_completion": 211, "completion_eval_sec": 4.947458567, "tokens_total": 1237, "tokens_per_sec": 228.38616602506036, "retrieval_latency_sec": 0.10142970085144043, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in several key aspects. The Reference SQL filters for 'Individual' donations and uses EXCEPT to exclude DonationIDs from a non-existent 'PreviousDonations' table (assuming it's a typo). The Generated SQL lacks a DonationType filter and uses a NOT IN clause on DonorID to identify first-time donors. Additionally, the date logic (DATEADD vs DATE_TRUNC) may not be equivalent, and the EXCEPT operation vs. NOT IN clause serves different purposes in set comparison. These differences in logic and conditions make the queries non-equivalent."}
{"example_id": 1301, "sql_complexity": "multiple_joins", "prompt": "What is the total quantity of corn sold by farmers in 'Summerfield'?", "context": "CREATE TABLE farmers (id INT, name VARCHAR(50), location VARCHAR(50), crops VARCHAR(50)); CREATE TABLE crops (id INT, name VARCHAR(50), yield INT); CREATE TABLE sales (id INT, farmer_id INT, crop_name VARCHAR(50), quantity INT, price DECIMAL(5,2)); INSERT INTO farmers VALUES (1, 'Jane Doe', 'Summerfield', 'Corn'); INSERT INTO crops VALUES (1, 'Corn', 100); INSERT INTO sales VALUES (1, 1, 'Corn', 50, 2.50);", "reference_sql": "SELECT SUM(quantity) FROM sales INNER JOIN farmers ON sales.farmer_id = farmers.id INNER JOIN crops ON sales.crop_name = crops.name WHERE farmers.location = 'Summerfield' AND crops.name = 'Corn';", "generated_sql": "SELECT SUM(s.quantity) AS total_quantity_sold\nFROM farmers f\nJOIN sales s ON f.id = s.farmer_id\nWHERE f.location = 'Summerfield' AND s.crop_name = 'Corn';", "raw_model_output": "To find the total quantity of corn sold by farmers in 'Summerfield', we need to join the `farmers` table with the `sales` table on the farmer ID and filter for the location 'Summerfield'. We then sum up the quantities where the crop name is 'Corn'.\n\nHere's the SQL query:\n\n```sql\nSELECT SUM(s.quantity) AS total_quantity_sold\nFROM farmers f\nJOIN sales s ON f.id = s.farmer_id\nWHERE f.location = 'Summerfield' AND s.crop_name = 'Corn';\n```", "latency_sec": 3.383044719696045, "total_duration_sec": 3.067586221, "load_duration_sec": 0.018386428, "tokens_prompt": 918, "prompt_eval_sec": 0.362589171, "tokens_completion": 112, "completion_eval_sec": 2.682582028, "tokens_total": 1030, "tokens_per_sec": 304.45946930685034, "retrieval_latency_sec": 0.10644793510437012, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes an explicit join with the 'crops' table and filters on 'crops.name = 'Corn'', while the Generated SQL omits this join and only filters on 'sales.crop_name = 'Corn''. Although both queries filter for 'Corn', the Reference SQL ensures that the crop exists in the 'crops' table (via the join), whereas the Generated SQL does not. This makes them semantically different in cases where 'sales.crop_name' values might not correspond to existing entries in 'crops'."}
{"example_id": 4667, "sql_complexity": "aggregation", "prompt": "Find the number of unique organizations in each country in the Philanthropy Trends table?", "context": "CREATE TABLE PhilanthropyTrends (OrgID INT, Name TEXT, Country TEXT);", "reference_sql": "SELECT Country, COUNT(DISTINCT OrgID) as UniqueOrganizations FROM PhilanthropyTrends GROUP BY Country;", "generated_sql": "SELECT Country, COUNT(DISTINCT OrgID) AS UniqueOrganizationsCount \nFROM PhilanthropyTrends \nGROUP BY Country;", "raw_model_output": "```sql\nSELECT Country, COUNT(DISTINCT OrgID) AS UniqueOrganizationsCount \nFROM PhilanthropyTrends \nGROUP BY Country;\n```", "latency_sec": 1.2607059478759766, "total_duration_sec": 1.120097103, "load_duration_sec": 0.020375596, "tokens_prompt": 806, "prompt_eval_sec": 0.328087647, "tokens_completion": 32, "completion_eval_sec": 0.767904147, "tokens_total": 838, "tokens_per_sec": 664.7069456694903, "retrieval_latency_sec": 0.1068108081817627, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries perform the same aggregation (COUNT(DISTINCT OrgID)) grouped by Country. The only difference is the column alias name ('UniqueOrganizations' vs 'UniqueOrganizationsCount'), which does not affect the semantic result."}
{"example_id": 1006, "sql_complexity": "subqueries", "prompt": "What is the average word count of news articles written by investigative journalists?", "context": "CREATE TABLE reporters (id INT, name VARCHAR(50), gender VARCHAR(10), age INT, position VARCHAR(20), country VARCHAR(50)); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (1, 'Anna Smith', 'Female', 35, 'News Reporter', 'USA'); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (2, 'Mike Johnson', 'Male', 40, 'Investigative Journalist', 'Canada'); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (3, 'Sofia Rodriguez', 'Female', 32, 'Investigative Journalist', 'Mexico'); CREATE TABLE news_articles (id INT, title VARCHAR(100), content TEXT, publication_date DATE, reporter_id INT); INSERT INTO news_articles (id, title, content, publication_date, reporter_id) VALUES (1, 'News Article 1', 'Content of News Article 1', '2021-01-01', 2); INSERT INTO news_articles (id, title, content, publication_date, reporter_id) VALUES (2, 'News Article 2', 'Content of News Article 2', '2021-02-01', 3);", "reference_sql": "SELECT AVG(LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1) AS avg_word_count FROM news_articles WHERE reporter_id IN (SELECT id FROM reporters WHERE position = 'Investigative Journalist');", "generated_sql": "SELECT AVG(LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1) AS avg_word_count\nFROM news_articles na\nJOIN reporters r ON na.reporter_id = r.id\nWHERE r.position = 'Investigative Journalist';", "raw_model_output": "To find the average word count of news articles written by investigative journalists, we need to follow these steps:\n\n1. Identify reporters who are investigative journalists.\n2. Find the news articles written by those investigative journalists.\n3. Calculate the average word count for those articles.\n\nHere is the SQL statement that accomplishes this:\n\n```sql\nSELECT AVG(LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1) AS avg_word_count\nFROM news_articles na\nJOIN reporters r ON na.reporter_id = r.id\nWHERE r.position = 'Investigative Journalist';\n```\n\nThis query joins the `news_articles` and `reporters` tables on the reporter ID, filters for investigative journalists, and calculates the average word count of their articles.", "latency_sec": 4.312297105789185, "total_duration_sec": 4.133127116, "load_duration_sec": 0.0155351, "tokens_prompt": 1030, "prompt_eval_sec": 0.401506499, "tokens_completion": 156, "completion_eval_sec": 3.710839112, "tokens_total": 1186, "tokens_per_sec": 275.02743222581194, "retrieval_latency_sec": 0.10451507568359375, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average word count of news articles written by investigative journalists. The reference query uses a subquery to filter reporter_ids, while the generated query uses a JOIN. Both achieve the same result by restricting to reporters with 'Investigative Journalist' position and applying the same word count calculation."}
{"example_id": 3635, "sql_complexity": "set operations", "prompt": "Which brands have certifications related to cruelty-free, vegan, or organic products?", "context": "CREATE TABLE brands (brand_name VARCHAR(50), is_cruelty_free BOOLEAN, is_vegan BOOLEAN, is_organic BOOLEAN); INSERT INTO brands (brand_name, is_cruelty_free, is_vegan, is_organic) VALUES ('Lush', TRUE, TRUE, FALSE), ('The Body Shop', TRUE, FALSE, FALSE), ('Est\u00e9e Lauder', FALSE, FALSE, FALSE), ('Urban Decay', TRUE, TRUE, FALSE), ('Maybelline', FALSE, FALSE, FALSE), ('Kat Von D', TRUE, TRUE, FALSE), ('Tarte', TRUE, TRUE, TRUE);", "reference_sql": "SELECT brand_name, 'Cruelty-free' as certification FROM brands WHERE is_cruelty_free = TRUE UNION SELECT brand_name, 'Vegan' as certification FROM brands WHERE is_vegan = TRUE UNION SELECT brand_name, 'Organic' as certification FROM brands WHERE is_organic = TRUE;", "generated_sql": "SELECT brand_name \nFROM brands \nWHERE is_cruelty_free = TRUE OR is_vegan = TRUE OR is_organic = TRUE;", "raw_model_output": "To find brands with certifications related to cruelty-free, vegan, or organic products based on the provided schema and data:\n\n```sql\nSELECT brand_name \nFROM brands \nWHERE is_cruelty_free = TRUE OR is_vegan = TRUE OR is_organic = TRUE;\n```", "latency_sec": 1.8391962051391602, "total_duration_sec": 1.789617013, "load_duration_sec": 0.01466545, "tokens_prompt": 985, "prompt_eval_sec": 0.379697899, "tokens_completion": 57, "completion_eval_sec": 1.390380137, "tokens_total": 1042, "tokens_per_sec": 566.5518431847561, "retrieval_latency_sec": 0.10395073890686035, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query returns multiple rows per brand with different certification types (e.g., a brand with both cruelty-free and vegan status would appear twice), while the generated query returns each brand only once, regardless of how many certifications they have. The output structure and row counts differ."}
{"example_id": 4932, "sql_complexity": "basic SQL", "prompt": "Delete the workout row with the id of 2.", "context": "CREATE TABLE Workouts (id INT, user_id INT, workout_name TEXT, calories INT); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (1, 1, 'Running', 300); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (2, 1, 'Cycling', 400); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (3, 2, 'Yoga', 200);", "reference_sql": "DELETE FROM Workouts WHERE id = 2;", "generated_sql": "DELETE FROM Workouts WHERE id = 2;", "raw_model_output": "```sql\nDELETE FROM Workouts WHERE id = 2;\n```", "latency_sec": 0.8560051918029785, "total_duration_sec": 0.726627363, "load_duration_sec": 0.015683892, "tokens_prompt": 801, "prompt_eval_sec": 0.327855948, "tokens_completion": 15, "completion_eval_sec": 0.379650365, "tokens_total": 816, "tokens_per_sec": 953.2652463021669, "retrieval_latency_sec": 0.10750579833984375, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and intent. They both delete the record with id = 2 from the Workouts table, resulting in the same database state change."}
{"example_id": 365, "sql_complexity": "aggregation", "prompt": "Identify the total number of military personnel and their corresponding rank for each branch and country in the 'military_personnel' table, sorted by the total number of personnel in descending order.", "context": "CREATE TABLE military_personnel (id INT, branch VARCHAR(255), rank VARCHAR(255), country VARCHAR(255), personnel INT);", "reference_sql": "SELECT branch, country, SUM(personnel) as total_personnel FROM military_personnel GROUP BY branch, country ORDER BY total_personnel DESC;", "generated_sql": "SELECT branch, country, rank, SUM(personnel) AS total_personnel \nFROM military_personnel \nGROUP BY branch, country, rank \nORDER BY total_personnel DESC;", "raw_model_output": "```sql\nSELECT branch, country, rank, SUM(personnel) AS total_personnel \nFROM military_personnel \nGROUP BY branch, country, rank \nORDER BY total_personnel DESC;\n```", "latency_sec": 1.4121270179748535, "total_duration_sec": 1.31462876, "load_duration_sec": 0.021138617, "tokens_prompt": 747, "prompt_eval_sec": 0.316201151, "tokens_completion": 41, "completion_eval_sec": 0.971880688, "tokens_total": 788, "tokens_per_sec": 558.0234567922079, "retrieval_latency_sec": 0.10613083839416504, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query groups by (branch, country) and sums personnel across all ranks within each group. The generated query groups by (branch, country, rank), summing personnel within each specific rank subgroup. This results in different aggregation levels: the first collapses ranks within branch/country pairs, while the second retains rank distinctions. Additionally, the generated query includes an extra 'rank' column in the output."}
{"example_id": 521, "sql_complexity": "subqueries", "prompt": "How many vessels have not had an inspection in the past year?", "context": "CREATE TABLE safety_records(id INT, vessel_name VARCHAR(50), inspection_date DATE); CREATE TABLE vessels(id INT, name VARCHAR(50), country VARCHAR(50)); INSERT INTO vessels(id, name, country) VALUES (1, 'Vessel A', 'Philippines'), (2, 'Vessel B', 'Philippines'); INSERT INTO safety_records(id, vessel_name, inspection_date) VALUES (1, 'Vessel A', '2022-01-01');", "reference_sql": "SELECT COUNT(*) FROM vessels WHERE name NOT IN (SELECT vessel_name FROM safety_records WHERE inspection_date BETWEEN DATE_SUB(NOW(), INTERVAL 1 YEAR) AND NOW());", "generated_sql": "SELECT COUNT(v.id) \nFROM vessels v\nLEFT JOIN safety_records sr ON v.name = sr.vessel_name\nWHERE sr.inspection_date < DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR)\n   OR sr.inspection_date IS NULL;", "raw_model_output": "To determine how many vessels have not had an inspection in the past year, we need to join the `vessels` and `safety_records` tables on the vessel name and filter for those that haven't been inspected within the last year. Here is the corresponding SQL query:\n\n```sql\nSELECT COUNT(v.id) \nFROM vessels v\nLEFT JOIN safety_records sr ON v.name = sr.vessel_name\nWHERE sr.inspection_date < DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR)\n   OR sr.inspection_date IS NULL;\n```\n\nThis query counts the number of vessels that either have no inspection record or their last inspection was more than a year ago.", "latency_sec": 3.8556602001190186, "total_duration_sec": 3.577900415, "load_duration_sec": 0.015910955, "tokens_prompt": 809, "prompt_eval_sec": 0.330049912, "tokens_completion": 137, "completion_eval_sec": 3.228482717, "tokens_total": 946, "tokens_per_sec": 245.35357134708042, "retrieval_latency_sec": 0.10155391693115234, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Reference SQL uses `NOT IN` with a subquery that includes all inspections in the past year, while the Generated SQL uses a LEFT JOIN and checks for inspections older than a year or NULL. This can lead to overcounting if a vessel has multiple safety records. Second, the date comparison in the Generated SQL uses `CURRENT_DATE` (date-only) and strict inequality (`<`), whereas the Reference SQL uses `NOW()` (datetime) and `BETWEEN` (inclusive). These differences in logic and date handling make the queries non-equivalent."}
{"example_id": 5687, "sql_complexity": "multiple_joins", "prompt": "List organizations with more than 200 volunteers, and their average donation amounts, excluding donations less than $10.", "context": "CREATE TABLE organizations (org_id INT, org_name TEXT, social_impact_score INT);CREATE TABLE volunteers (vol_id INT, org_id INT, vol_country TEXT);CREATE TABLE donations (donation_id INT, donor_id INT, donation_amount INT, donation_date DATE);", "reference_sql": "SELECT o.org_name, AVG(donation_amount) AS avg_donation_amount FROM organizations o JOIN volunteers v ON o.org_id = v.org_id JOIN donations don ON o.org_id = don.org_id WHERE donation_amount >= 10 GROUP BY o.org_name HAVING COUNT(v.vol_id) > 200;", "generated_sql": "SELECT o.org_id, o.org_name, AVG(d.donation_amount) AS avg_donation_amount\nFROM organizations o\nJOIN volunteers v ON o.org_id = v.org_id\nJOIN donations d ON o.org_id = d.org_id\nWHERE COUNT(v.vol_id) OVER (PARTITION BY o.org_id) > 200 AND d.donation_amount >= 10\nGROUP BY o.org_id, o.org_name;", "raw_model_output": "To list organizations with more than 200 volunteers and their average donation amounts (excluding donations less than $10), we need to follow these steps:\n\n1. Join the `organizations` table with the `volunteers` table to get the number of volunteers for each organization.\n2. Filter out organizations that have fewer than 200 volunteers.\n3. Join this result with the `donations` table to include donation amounts.\n4. Exclude donations less than $10.\n5. Calculate the average donation amount for each organization.\n\nHere is the SQL query:\n\n```sql\nSELECT o.org_id, o.org_name, AVG(d.donation_amount) AS avg_donation_amount\nFROM organizations o\nJOIN volunteers v ON o.org_id = v.org_id\nJOIN donations d ON o.org_id = d.org_id\nWHERE COUNT(v.vol_id) OVER (PARTITION BY o.org_id) > 200 AND d.donation_amount >= 10\nGROUP BY o.org_id, o.org_name;\n```\n\nHowever, the `COUNT` function cannot be used directly in a `WHERE` clause like this. We need to use a subquery to filter organizations with more than 200 volunteers first:\n\n```sql\nSELECT o.org_id, o.org_name, AVG(d.donation_amount) AS avg_donation_amount\nFROM (\n    SELECT org_id\n    FROM volunteers\n    GROUP BY org_id\n    HAVING COUNT(vol_id) > 200\n) v_filtered\nJOIN organizations o ON v_filtered.org_id = o.org_id\nJOIN donations d ON o.org_id = d.donor_id AND d.donation_amount >= 10\nGROUP BY o.org_id, o.org_name;\n```\n\nThis query correctly filters the organizations with more than 200 volunteers and calculates the average donation amount for those organizations, excluding donations less than $10.", "latency_sec": 9.69835090637207, "total_duration_sec": 9.51251876, "load_duration_sec": 0.015943295, "tokens_prompt": 991, "prompt_eval_sec": 0.384043295, "tokens_completion": 388, "completion_eval_sec": 9.108436067, "tokens_total": 1379, "tokens_per_sec": 142.18912197680544, "retrieval_latency_sec": 0.1100308895111084, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The reference query selects only 'org_name' and groups by it, while the generated query selects 'org_id' and 'org_name' and groups by both. Additionally, the generated query uses a window function in the WHERE clause, which filters rows before grouping, whereas the reference uses a HAVING clause after grouping. These differences in column selection, grouping, and filtering logic lead to different result sets."}
{"example_id": 1281, "sql_complexity": "subqueries", "prompt": "Find the top 3 contributors with the lowest recycling rate in the 'waste_contributors' table.", "context": "CREATE TABLE waste_contributors (contributor VARCHAR(20), recycling_rate FLOAT); INSERT INTO waste_contributors (contributor, recycling_rate) VALUES ('Manufacturing', 0.4), ('Commercial', 0.38), ('Residential', 0.35), ('Institutional', 0.32), ('Agricultural', 0.2), ('Industrial', 0.15);", "reference_sql": "SELECT contributor FROM waste_contributors WHERE recycling_rate IN (SELECT MIN(recycling_rate) FROM waste_contributors) LIMIT 3;", "generated_sql": "SELECT contributor \nFROM waste_contributors \nORDER BY recycling_rate ASC \nLIMIT 3;", "raw_model_output": "To find the top 3 contributors with the lowest recycling rate in the `waste_contributors` table, you can use an ORDER BY clause to sort by `recycling_rate` in ascending order and then apply a LIMIT clause to restrict the results to the top 3. Here is the SQL query:\n\n```sql\nSELECT contributor \nFROM waste_contributors \nORDER BY recycling_rate ASC \nLIMIT 3;\n```", "latency_sec": 2.5804200172424316, "total_duration_sec": 2.391320592, "load_duration_sec": 0.016831808, "tokens_prompt": 848, "prompt_eval_sec": 0.34276836, "tokens_completion": 85, "completion_eval_sec": 2.028507171, "tokens_total": 933, "tokens_per_sec": 361.56904448332847, "retrieval_latency_sec": 0.10847997665405273, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query selects contributors with the minimum recycling rate (0.15) and limits to 3 results, which in this case returns only 'Industrial'. The generated query orders all contributors by ascending recycling rate and returns the top 3, which includes 'Industrial', 'Agricultural', and 'Institutional'. The generated query retrieves the three lowest rates, while the reference query specifically targets the minimum rate (which may be a single value). Thus, they produce different results."}
{"example_id": 5669, "sql_complexity": "window functions", "prompt": "What is the total number of new and returning volunteers in each program in each month?", "context": "CREATE TABLE Volunteers (VolunteerID INT, VolunteerName TEXT, ProgramID INT, VolunteerDate DATE, IsReturning BOOLEAN); INSERT INTO Volunteers (VolunteerID, VolunteerName, ProgramID, VolunteerDate, IsReturning) VALUES (6, 'David Kim', 1, '2022-03-01', FALSE), (7, 'Emily Chen', 2, '2022-03-15', TRUE), (8, 'James Lee', 2, '2022-04-01', FALSE), (9, 'Grace Park', 3, '2022-04-15', TRUE), (10, 'Daniel Kim', 1, '2022-04-01', FALSE);", "reference_sql": "SELECT ProgramID, EXTRACT(MONTH FROM VolunteerDate) AS Month, SUM(CASE WHEN IsReturning THEN 1 ELSE 0 END) OVER (PARTITION BY ProgramID, EXTRACT(MONTH FROM VolunteerDate) ORDER BY ProgramID, EXTRACT(MONTH FROM VolunteerDate)) + COUNT(DISTINCT VolunteerID) OVER (PARTITION BY ProgramID, EXTRACT(MONTH FROM VolunteerDate) ORDER BY ProgramID, EXTRACT(MONTH FROM VolunteerDate)) AS TotalVolunteers FROM Volunteers;", "generated_sql": "SELECT \n    ProgramID,\n    EXTRACT(MONTH FROM VolunteerDate) AS Month,\n    SUM(CASE WHEN IsReturning THEN 0 ELSE 1 END) AS NewVolunteers,\n    SUM(CASE WHEN IsReturning THEN 1 ELSE 0 END) AS ReturningVolunteers\nFROM \n    Volunteers\nGROUP BY \n    ProgramID, \n    EXTRACT(MONTH FROM VolunteerDate)\nORDER BY \n    ProgramID, \n    Month;", "raw_model_output": "To calculate the total number of new and returning volunteers in each program for each month, we need to partition the data based on `ProgramID` and the month extracted from `VolunteerDate`. Additionally, we will use conditional aggregation to count new and returning volunteers separately.\n\nHere is the SQL query:\n\n```sql\nSELECT \n    ProgramID,\n    EXTRACT(MONTH FROM VolunteerDate) AS Month,\n    SUM(CASE WHEN IsReturning THEN 0 ELSE 1 END) AS NewVolunteers,\n    SUM(CASE WHEN IsReturning THEN 1 ELSE 0 END) AS ReturningVolunteers\nFROM \n    Volunteers\nGROUP BY \n    ProgramID, \n    EXTRACT(MONTH FROM VolunteerDate)\nORDER BY \n    ProgramID, \n    Month;\n```\n\nThis query groups the data by `ProgramID` and month (extracted from `VolunteerDate`). It then uses conditional aggregation to count new volunteers (`IsReturning = FALSE`) and returning volunteers (`IsReturning = TRUE`) separately.", "latency_sec": 5.494415044784546, "total_duration_sec": 5.399929053, "load_duration_sec": 0.020606259, "tokens_prompt": 1164, "prompt_eval_sec": 0.558929796, "tokens_completion": 206, "completion_eval_sec": 4.814761411, "tokens_total": 1370, "tokens_per_sec": 249.34410466505307, "retrieval_latency_sec": 0.10313701629638672, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL uses window functions to calculate a cumulative sum and count, which would produce multiple rows per (ProgramID, Month) group if there are multiple entries. The Generated SQL aggregates data into one row per (ProgramID, Month) group. Additionally, the Reference SQL's 'TotalVolunteers' combines returning counts with distinct volunteer counts, while the Generated SQL separates new and returning volunteers. The calculation logic and result structure differ significantly."}
{"example_id": 3576, "sql_complexity": "window functions", "prompt": "What is the difference in the number of eco-friendly hotels between the top 2 countries?", "context": "CREATE TABLE eco_hotel_count (country TEXT, num_hotels INT); INSERT INTO eco_hotel_count (country, num_hotels) VALUES ('France', 100), ('Italy', 120), ('Germany', 150), ('Spain', 110), ('UK', 160);", "reference_sql": "SELECT (MAX(num_hotels) OVER (PARTITION BY num_hotels <= 2) - MIN(num_hotels) OVER (PARTITION BY num_hotels <= 2)) AS hotel_difference FROM eco_hotel_count WHERE country IN ('France', 'Italy');", "generated_sql": "SELECT \n    (t1.num_hotels - t2.num_hotels) AS hotel_difference\nFROM \n    eco_hotel_count t1,\n    eco_hotel_count t2\nWHERE \n    t1.num_hotels > t2.num_hotels\nORDER BY \n    t1.num_hotels DESC, \n    t2.num_hotels DESC\nLIMIT 1;", "raw_model_output": "To find the difference in the number of eco-friendly hotels between the top 2 countries based on the `eco_hotel_count` table:\n\n1. First, we need to order the data by `num_hotels` in descending order.\n2. Then, we select the top two rows.\n3. Finally, we calculate the difference between the number of hotels in these two countries.\n\nHere is the SQL statement that accomplishes this:\n\n```sql\nSELECT \n    (t1.num_hotels - t2.num_hotels) AS hotel_difference\nFROM \n    eco_hotel_count t1,\n    eco_hotel_count t2\nWHERE \n    t1.num_hotels > t2.num_hotels\nORDER BY \n    t1.num_hotels DESC, \n    t2.num_hotels DESC\nLIMIT 1;\n```", "latency_sec": 4.317749977111816, "total_duration_sec": 4.210965144, "load_duration_sec": 0.020483464, "tokens_prompt": 699, "prompt_eval_sec": 0.301769614, "tokens_completion": 169, "completion_eval_sec": 3.882104531, "tokens_total": 868, "tokens_per_sec": 201.030630444381, "retrieval_latency_sec": 0.09735512733459473, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the difference between the maximum and minimum num_hotels in the filtered rows (France and Italy) using window functions. The Generated SQL finds the maximum difference between any two rows where t1.num_hotels > t2.num_hotels. While both return 20 for the given data, they are not equivalent in general. The Generated SQL would return 30 (150-120) if additional data like Germany (150) were present, whereas the Reference SQL would return 50 (150-100). Thus, they produce different results for other datasets."}
{"example_id": 1970, "sql_complexity": "multiple_joins", "prompt": "List all players who have played a specific VR game, 'CyberSphere', and their ages.", "context": "CREATE TABLE Players (PlayerID INT, Age INT, Gender VARCHAR(10), Country VARCHAR(50)); CREATE TABLE VRPlayers (PlayerID INT, VRGameID INT); CREATE TABLE VRGames (VRGameID INT, Title VARCHAR(50)); INSERT INTO Players (PlayerID, Age, Gender, Country) VALUES (1, 25, 'Male', 'USA'); INSERT INTO Players (PlayerID, Age, Gender, Country) VALUES (2, 28, 'Female', 'Canada'); INSERT INTO VRPlayers (PlayerID, VRGameID) VALUES (1, 1); INSERT INTO VRPlayers (PlayerID, VRGameID) VALUES (2, 1); INSERT INTO VRGames (VRGameID, Title) VALUES (1, 'CyberSphere');", "reference_sql": "SELECT Players.Age, Players.PlayerID FROM Players INNER JOIN VRPlayers ON Players.PlayerID = VRPlayers.PlayerID INNER JOIN VRGames ON VRPlayers.VRGameID = VRGames.VRGameID WHERE VRGames.Title = 'CyberSphere';", "generated_sql": "SELECT P.PlayerID, P.Age \nFROM Players P \nINNER JOIN VRPlayers VP ON P.PlayerID = VP.PlayerID \nINNER JOIN VRGames VG ON VP.VRGameID = VG.VRGameID \nWHERE VG.Title = 'CyberSphere';", "raw_model_output": "```sql\nSELECT P.PlayerID, P.Age \nFROM Players P \nINNER JOIN VRPlayers VP ON P.PlayerID = VP.PlayerID \nINNER JOIN VRGames VG ON VP.VRGameID = VG.VRGameID \nWHERE VG.Title = 'CyberSphere';\n```", "latency_sec": 2.0616257190704346, "total_duration_sec": 1.819796268, "load_duration_sec": 0.015892234, "tokens_prompt": 996, "prompt_eval_sec": 0.393486999, "tokens_completion": 58, "completion_eval_sec": 1.40625404, "tokens_total": 1054, "tokens_per_sec": 511.2470174631104, "retrieval_latency_sec": 0.09859800338745117, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (PlayerID and Age) from the Players table, join with VRPlayers and VRGames on identical conditions, and filter using the same VRGames.Title = 'CyberSphere' condition. The differences are purely syntactic (table aliases and column order in SELECT) and do not affect the semantic result."}
{"example_id": 2414, "sql_complexity": "window functions", "prompt": "List the policy areas with the lowest citizen satisfaction scores.", "context": "CREATE TABLE Policy (Area VARCHAR(20), Score INT); INSERT INTO Policy (Area, Score) VALUES ('Transportation', 70), ('Education', 85), ('Healthcare', 75), ('PublicSafety', 80);", "reference_sql": "SELECT Area, Score FROM (SELECT Area, Score, ROW_NUMBER() OVER (ORDER BY Score) AS RN FROM Policy) X WHERE RN IN (1, 2);", "generated_sql": "SELECT Area \nFROM Policy \nWHERE Score = (SELECT MIN(Score) FROM Policy);", "raw_model_output": "To list the policy areas with the lowest citizen satisfaction scores from the given `Policy` table:\n\n```sql\nSELECT Area \nFROM Policy \nWHERE Score = (SELECT MIN(Score) FROM Policy);\n```", "latency_sec": 1.4590930938720703, "total_duration_sec": 1.349774396, "load_duration_sec": 0.01412109, "tokens_prompt": 814, "prompt_eval_sec": 0.329593194, "tokens_completion": 42, "completion_eval_sec": 1.001356507, "tokens_total": 856, "tokens_per_sec": 586.6657882180697, "retrieval_latency_sec": 0.10379815101623535, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns the top 2 rows ordered by Score (lowest two scores: 70 and 75), while the Generated SQL only returns the row with the minimum Score (70). The first query retrieves two rows, the second only one, making them non-equivalent."}
{"example_id": 1898, "sql_complexity": "single join", "prompt": "What are the total sales for each drug in Q2 2020?", "context": "CREATE TABLE drugs (drug_id INT, drug_name TEXT); INSERT INTO drugs (drug_id, drug_name) VALUES (1001, 'Ibuprofen'), (1002, 'Paracetamol'), (1003, 'Aspirin'); CREATE TABLE sales (sale_id INT, drug_id INT, sale_date DATE, revenue FLOAT); INSERT INTO sales (sale_id, drug_id, sale_date, revenue) VALUES (1, 1001, '2020-04-05', 1800.0), (2, 1002, '2020-04-10', 2300.0), (3, 1003, '2020-04-15', 1400.0), (4, 1001, '2020-05-20', 1900.0), (5, 1002, '2020-06-25', 2400.0);", "reference_sql": "SELECT drug_name, SUM(revenue) as total_sales FROM sales JOIN drugs ON sales.drug_id = drugs.drug_id WHERE sale_date BETWEEN '2020-04-01' AND '2020-06-30' GROUP BY drug_name;", "generated_sql": "SELECT d.drug_name, SUM(s.revenue) AS total_sales \nFROM sales s \nJOIN drugs d ON s.drug_id = d.drug_id \nWHERE s.sale_date BETWEEN '2020-04-01' AND '2020-06-30'\nGROUP BY d.drug_name;", "raw_model_output": "To find the total sales for each drug in Q2 2020, you can use the following SQL query:\n\n```sql\nSELECT d.drug_name, SUM(s.revenue) AS total_sales \nFROM sales s \nJOIN drugs d ON s.drug_id = d.drug_id \nWHERE s.sale_date BETWEEN '2020-04-01' AND '2020-06-30'\nGROUP BY d.drug_name;\n```", "latency_sec": 3.1090757846832275, "total_duration_sec": 3.0099136, "load_duration_sec": 0.015597472, "tokens_prompt": 1291, "prompt_eval_sec": 0.596295746, "tokens_completion": 100, "completion_eval_sec": 2.394490438, "tokens_total": 1391, "tokens_per_sec": 447.3998372290317, "retrieval_latency_sec": 0.10354471206665039, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between 'sales' and 'drugs' on drug_id, filter sales between '2020-04-01' and '2020-06-30', and group by drug_name to calculate total sales. The generated query uses table aliases (s and d) but references the same columns (d.drug_name vs drug_name) and applies identical filtering and aggregation. The semantic logic remains unchanged."}
{"example_id": 2403, "sql_complexity": "multiple_joins", "prompt": "Who is the most frequent customer ordering vegetarian items?", "context": "CREATE TABLE customers (customer_id INT, customer_name VARCHAR(50)); INSERT INTO customers VALUES (1, 'John Doe'), (2, 'Jane Smith'), (3, 'Alice Johnson'); CREATE TABLE orders (order_id INT, customer_id INT, menu_id INT, order_date DATE); INSERT INTO orders VALUES (1, 1, 1, '2022-01-01'), (2, 2, 3, '2022-01-02'), (3, 3, 2, '2022-01-03'); CREATE TABLE menu (menu_id INT, item_name VARCHAR(50), is_vegetarian BOOLEAN, price DECIMAL(5,2)); INSERT INTO menu VALUES (1, 'Veggie Burger', true, 8.99), (2, 'Cheeseburger', false, 7.99), (3, 'Tofu Stir Fry', true, 11.99);", "reference_sql": "SELECT customers.customer_name, COUNT(orders.order_id) as order_count FROM customers INNER JOIN orders ON customers.customer_id = orders.customer_id INNER JOIN menu ON orders.menu_id = menu.menu_id WHERE menu.is_vegetarian = true GROUP BY customers.customer_name ORDER BY order_count DESC LIMIT 1;", "generated_sql": "SELECT c.customer_id, c.customer_name, COUNT(o.order_id) AS order_count\nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nJOIN menu m ON o.menu_id = m.menu_id\nWHERE m.is_vegetarian = true\nGROUP BY c.customer_id, c.customer_name\nORDER BY order_count DESC\nLIMIT 1;", "raw_model_output": "To find the most frequent customer ordering vegetarian items, we need to join the `customers`, `orders`, and `menu` tables. We will filter for vegetarian items and group by the customer ID to count how many times each customer has ordered a vegetarian item.\n\nHere is the SQL query:\n\n```sql\nSELECT c.customer_id, c.customer_name, COUNT(o.order_id) AS order_count\nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nJOIN menu m ON o.menu_id = m.menu_id\nWHERE m.is_vegetarian = true\nGROUP BY c.customer_id, c.customer_name\nORDER BY order_count DESC\nLIMIT 1;\n```", "latency_sec": 3.836095094680786, "total_duration_sec": 3.744114929, "load_duration_sec": 0.016062431, "tokens_prompt": 1088, "prompt_eval_sec": 0.545386751, "tokens_completion": 138, "completion_eval_sec": 3.177479238, "tokens_total": 1226, "tokens_per_sec": 319.595831109609, "retrieval_latency_sec": 0.10470724105834961, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL returns only 'customer_name' and 'order_count', while the Generated SQL includes 'customer_id' as an additional column. Additionally, the Generated SQL groups by both 'customer_id' and 'customer_name' (though grouping by 'customer_name' alone could be problematic if names are not unique). The output structure differs, making them non-equivalent."}
{"example_id": 124, "sql_complexity": "set operations", "prompt": "Find the intersection of AI and accessibility research projects in the EU and those in Africa.", "context": "CREATE SCHEMA if not exists accessibility; CREATE TABLE if not exists accessibility.research (id INT PRIMARY KEY, project_name VARCHAR(255), region VARCHAR(255)); INSERT INTO accessibility.research (id, project_name, region) VALUES (1, 'AI for Accessibility EU', 'EU'), (2, 'Accessibility Africa', 'Africa'), (3, 'AI for Accessibility Africa', 'Africa'), (4, 'Accessibility EU', 'EU');", "reference_sql": "SELECT project_name FROM accessibility.research WHERE region = 'EU' INTERSECT SELECT project_name FROM accessibility.research WHERE region = 'Africa';", "generated_sql": "SELECT id, project_name \nFROM accessibility.research \nWHERE region = 'EU' AND project_name LIKE '%AI%' AND project_name LIKE '%accessibility%';", "raw_model_output": "To find the intersection of AI and accessibility research projects in the EU and those in Africa, we need to identify projects that contain both \"AI\" and \"accessibility\" keywords in their project names for each region. However, since there is no direct overlap between regions, we can list out the projects separately for each region.\n\nHere's how you could write SQL queries to find such projects:\n\n1. For EU:\n```sql\nSELECT id, project_name \nFROM accessibility.research \nWHERE region = 'EU' AND project_name LIKE '%AI%' AND project_name LIKE '%accessibility%';\n```\n\n2. For Africa:\n```sql\nSELECT id, project_name \nFROM accessibility.research \nWHERE region = 'Africa' AND project_name LIKE '%AI%' AND project_name LIKE '%accessibility%';\n```\n\nSince the question asks for an intersection and there is no overlap between regions in this context, we can combine these queries into a single query that returns both sets of results:\n\n```sql\n(SELECT id, project_name \n FROM accessibility.research \n WHERE region = 'EU' AND project_name LIKE '%AI%' AND project_name LIKE '%accessibility%')\nUNION ALL\n(SELECT id, project_name \n FROM accessibility.research \n WHERE region = 'Africa' AND project_name LIKE '%AI%' AND project_name LIKE '%accessibility%');\n```\n\nThis query will return all research projects in both regions that contain the keywords \"AI\" and \"accessibility\".", "latency_sec": 7.376170873641968, "total_duration_sec": 7.213527528, "load_duration_sec": 0.015198177, "tokens_prompt": 848, "prompt_eval_sec": 0.345598716, "tokens_completion": 296, "completion_eval_sec": 6.848222035, "tokens_total": 1144, "tokens_per_sec": 155.0940209489958, "retrieval_latency_sec": 0.10344600677490234, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses INTERSECT to find project_names present in both 'EU' and 'Africa' regions, which returns no rows in the given data. The Generated SQL selects project_names from 'EU' region with specific LIKE conditions, returning 'AI for Accessibility EU'. Additionally, the columns selected differ (project_name vs. id and project_name), making them non-equivalent."}
{"example_id": 1231, "sql_complexity": "basic SQL", "prompt": "What is the average ticket price for performances at the 'Downtown Theater'?", "context": "CREATE TABLE DowntownTheater (show_name TEXT, date DATE, ticket_price FLOAT); INSERT INTO DowntownTheater (show_name, date, ticket_price) VALUES ('Play 1', '2022-01-01', 30.0), ('Play 2', '2022-01-02', 40.0), ('Concert 1', '2022-01-03', 50.0);", "reference_sql": "SELECT AVG(ticket_price) FROM DowntownTheater WHERE show_name = 'Downtown Theater'", "generated_sql": "SELECT AVG(ticket_price) FROM DowntownTheater;", "raw_model_output": "```sql\nSELECT AVG(ticket_price) FROM DowntownTheater;\n```", "latency_sec": 0.8398730754852295, "total_duration_sec": 0.749332989, "load_duration_sec": 0.022786287, "tokens_prompt": 827, "prompt_eval_sec": 0.332412906, "tokens_completion": 15, "completion_eval_sec": 0.385549633, "tokens_total": 842, "tokens_per_sec": 1002.5324356463525, "retrieval_latency_sec": 0.10486507415771484, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters for show_name = 'Downtown Theater' which doesn't exist in the data (the actual shows are 'Play 1', 'Play 2', 'Concert 1'), resulting in NULL. The Generated SQL averages all tickets. The WHERE clause in Reference SQL changes the dataset being aggregated, making results different."}
{"example_id": 1485, "sql_complexity": "set operations", "prompt": "How many public schools and public libraries exist in total, in the 'CityData' schema's 'CityEducation' and 'CityLibrary' tables?", "context": "CREATE SCHEMA CityData; CREATE TABLE CityEducation (Name varchar(255), Type varchar(255)); INSERT INTO CityEducation (Name, Type) VALUES ('SchoolA', 'Public'), ('SchoolB', 'Public'), ('SchoolC', 'Private'); CREATE TABLE CityLibrary (Name varchar(255), Type varchar(255)); INSERT INTO CityLibrary (Name, Type) VALUES ('LibraryA', 'Public'), ('LibraryB', 'Public'), ('LibraryC', 'Private');", "reference_sql": "SELECT COUNT(*) FROM CityData.CityEducation WHERE Type = 'Public' UNION ALL SELECT COUNT(*) FROM CityData.CityLibrary WHERE Type = 'Public';", "generated_sql": "SELECT SUM(public_count) AS TotalPublicFacilities \nFROM (\n    SELECT COUNT(*) AS public_count FROM CityData.CityEducation WHERE Type = 'Public'\n    UNION ALL\n    SELECT COUNT(*) FROM CityData.CityLibrary WHERE Type = 'Public'\n) subquery;", "raw_model_output": "To find the total number of public schools and public libraries, you need to count the rows in both `CityEducation` and `CityLibrary` tables where the type is 'Public', and then sum these counts.\n\nHere's the corresponding SQL query:\n\n```sql\nSELECT SUM(public_count) AS TotalPublicFacilities \nFROM (\n    SELECT COUNT(*) AS public_count FROM CityData.CityEducation WHERE Type = 'Public'\n    UNION ALL\n    SELECT COUNT(*) FROM CityData.CityLibrary WHERE Type = 'Public'\n) subquery;\n```\n\nThis query first counts the number of public schools and public libraries separately, then sums these counts to get the total.", "latency_sec": 3.6539907455444336, "total_duration_sec": 3.439752705, "load_duration_sec": 0.016544949, "tokens_prompt": 769, "prompt_eval_sec": 0.318034137, "tokens_completion": 133, "completion_eval_sec": 3.100839271, "tokens_total": 902, "tokens_per_sec": 246.85338929768, "retrieval_latency_sec": 0.10995697975158691, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate counts (one for CityEducation and one for CityLibrary) as two rows, while the Generated SQL combines these counts into a single summed value. The first query's output structure differs from the second, making them non-equivalent."}
{"example_id": 5806, "sql_complexity": "single join", "prompt": "List the top 3 countries with the most veteran employment in the IT industry", "context": "CREATE TABLE veteran_employment (employee_id INT, industry VARCHAR(255), salary DECIMAL(10,2), state VARCHAR(2), country VARCHAR(255)); CREATE TABLE countries (country_id INT, country VARCHAR(255));", "reference_sql": "SELECT country, COUNT(*) as num_veterans FROM veteran_employment JOIN countries ON veteran_employment.country = countries.country WHERE industry = 'IT' GROUP BY country ORDER BY num_veterans DESC LIMIT 3;", "generated_sql": "SELECT c.country, COUNT(ve.employee_id) AS num_veterans\nFROM veteran_employment ve\nJOIN countries c ON ve.country = c.country\nWHERE ve.industry = 'IT'\nGROUP BY c.country\nORDER BY num_veterans DESC\nLIMIT 3;", "raw_model_output": "To list the top 3 countries with the most veteran employment in the IT industry based on the provided schema, we need to follow these steps:\n\n1. Filter the `veteran_employment` table for entries where the `industry` is 'IT'.\n2. Join this filtered data with the `countries` table to get country names.\n3. Group by country and count the number of veteran employments in each country.\n4. Rank countries based on the count of veteran employment in descending order.\n5. Select the top 3 ranked countries.\n\nHere's the SQL statement:\n\n```sql\nSELECT c.country, COUNT(ve.employee_id) AS num_veterans\nFROM veteran_employment ve\nJOIN countries c ON ve.country = c.country\nWHERE ve.industry = 'IT'\nGROUP BY c.country\nORDER BY num_veterans DESC\nLIMIT 3;\n```\n\nThis query will return the top 3 countries with the highest number of veteran employment in the IT industry.", "latency_sec": 5.4158852100372314, "total_duration_sec": 5.177353394, "load_duration_sec": 0.015851333, "tokens_prompt": 1011, "prompt_eval_sec": 0.384913546, "tokens_completion": 201, "completion_eval_sec": 4.773117702, "tokens_total": 1212, "tokens_per_sec": 223.78613153650429, "retrieval_latency_sec": 0.1075739860534668, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same data by joining the same tables on the country column, filtering for 'IT' industry, grouping by country, and ordering by the count of veterans. The differences are purely syntactic (table aliases and COUNT expression variation), which do not affect the semantic result."}
{"example_id": 4126, "sql_complexity": "window functions", "prompt": "What is the average crime rate per capita in each neighborhood?", "context": "CREATE TABLE neighborhoods (name VARCHAR(255), population INT, crime_count INT); INSERT INTO neighborhoods (name, population, crime_count) VALUES ('Central Park', 1000, 25), ('Harlem', 2500, 75), ('Brooklyn', 5000, 120);", "reference_sql": "SELECT name, AVG(crime_count/population) OVER (PARTITION BY name) FROM neighborhoods;", "generated_sql": "SELECT name, (crime_count / population) AS avg_crime_rate_per_capita \nFROM neighborhoods;", "raw_model_output": "To find the average crime rate per capita in each neighborhood, we need to compute the ratio of `crime_count` to `population` and then calculate the average for each neighborhood.\n\nHere is the SQL query:\n\n```sql\nSELECT name, (crime_count / population) AS avg_crime_rate_per_capita \nFROM neighborhoods;\n```\n\nHowever, if you want to get an average crime rate per capita across all neighborhoods, we can use a subquery or window function. Here's how it would look using a subquery:\n\n```sql\nSELECT AVG(avg_crime_rate_per_neighborhood) AS avg_crime_rate_per_capita_across_all \nFROM (\n    SELECT name, (crime_count / population) AS avg_crime_rate_per_neighborhood \n    FROM neighborhoods\n) AS subquery;\n```\n\nIf you want the average crime rate per capita for each neighborhood individually:\n\n```sql\nSELECT name, (crime_count / population) AS avg_crime_rate_per_capita \nFROM neighborhoods;\n```\n\nSince the question asks specifically about \"average crime rate per capita in each neighborhood,\" I'll provide the first query as it directly answers the requirement.\n\nFinal SQL statement:\n```sql\nSELECT name, (crime_count / population) AS avg_crime_rate_per_capita \nFROM neighborhoods;\n```", "latency_sec": 6.597062110900879, "total_duration_sec": 6.387418412, "load_duration_sec": 0.016362938, "tokens_prompt": 783, "prompt_eval_sec": 0.321253308, "tokens_completion": 262, "completion_eval_sec": 6.045555912, "tokens_total": 1045, "tokens_per_sec": 158.40384438298054, "retrieval_latency_sec": 0.09976387023925781, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the ratio of crime_count to population for each neighborhood. The Reference SQL uses an AVG() window function with PARTITION BY name, but since each name is unique in the data, the average of a single value equals the value itself. The Generated SQL directly computes the ratio. Thus, they produce identical results in this context."}
{"example_id": 4559, "sql_complexity": "basic SQL", "prompt": "List the top 3 energy efficient appliances in the US by energy star rating?", "context": "CREATE TABLE appliances (id INT, name VARCHAR(255), country VARCHAR(255), energy_star_rating INT); INSERT INTO appliances (id, name, country, energy_star_rating) VALUES (1, 'Fridge A', 'USA', 5), (2, 'TV B', 'USA', 4), (3, 'Laptop C', 'USA', 5), (4, 'Microwave D', 'USA', 3);", "reference_sql": "SELECT name, energy_star_rating FROM appliances WHERE country = 'USA' ORDER BY energy_star_rating DESC LIMIT 3;", "generated_sql": "SELECT name, energy_star_rating \nFROM appliances \nWHERE country = 'USA' \nORDER BY energy_star_rating DESC \nLIMIT 3;", "raw_model_output": "To list the top 3 energy efficient appliances in the US by energy star rating, you can use the following SQL query:\n\n```sql\nSELECT name, energy_star_rating \nFROM appliances \nWHERE country = 'USA' \nORDER BY energy_star_rating DESC \nLIMIT 3;\n```\n\nThis query selects the names and energy star ratings of appliances from the `appliances` table where the country is 'USA', orders them by their energy star rating in descending order (most efficient first), and limits the results to the top 3 entries.", "latency_sec": 3.1398699283599854, "total_duration_sec": 2.921852322, "load_duration_sec": 0.019115901, "tokens_prompt": 767, "prompt_eval_sec": 0.319474898, "tokens_completion": 110, "completion_eval_sec": 2.5788824, "tokens_total": 877, "tokens_per_sec": 279.31093325833217, "retrieval_latency_sec": 0.10562920570373535, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select the same columns (name, energy_star_rating) from the appliances table where country is 'USA', order by energy_star_rating descending, and limit to 3 results. The formatting differences (e.g., line breaks) do not affect semantic equivalence."}
{"example_id": 456, "sql_complexity": "window functions", "prompt": "List the intelligence operations and their corresponding threat levels, and rank them based on their threat level and budget.", "context": "CREATE TABLE intel_ops_threat (id INT, operation VARCHAR, threat VARCHAR, budget INT); INSERT INTO intel_ops_threat (id, operation, threat, budget) VALUES (1, 'Operation Red Folder', 'High', 5000000), (2, 'Operation Black Vault', 'Medium', 7000000), (3, 'Operation Blue Sail', 'Low', 6000000);", "reference_sql": "SELECT operation, threat, budget, ROW_NUMBER() OVER (PARTITION BY threat ORDER BY budget DESC) as rank FROM intel_ops_threat;", "generated_sql": "SELECT operation, threat, budget,\n       ROW_NUMBER() OVER (ORDER BY CASE WHEN threat = 'High' THEN 1 \n                                        WHEN threat = 'Medium' THEN 2 \n                                        WHEN threat = 'Low' THEN 3 END, budget DESC) AS rank\nFROM intel_ops_threat;", "raw_model_output": "To list the intelligence operations along with their corresponding threat levels and rank them based on both threat level and budget, you can use the following SQL query:\n\n```sql\nSELECT operation, threat, budget,\n       ROW_NUMBER() OVER (ORDER BY CASE WHEN threat = 'High' THEN 1 \n                                        WHEN threat = 'Medium' THEN 2 \n                                        WHEN threat = 'Low' THEN 3 END, budget DESC) AS rank\nFROM intel_ops_threat;\n```\n\nThis query uses the `ROW_NUMBER()` window function to assign a unique rank based on the threat level (with 'High', 'Medium', and 'Low' ordered accordingly) and then by descending order of budget.", "latency_sec": 3.7115139961242676, "total_duration_sec": 3.625353079, "load_duration_sec": 0.016409712, "tokens_prompt": 797, "prompt_eval_sec": 0.319869083, "tokens_completion": 140, "completion_eval_sec": 3.285371614, "tokens_total": 937, "tokens_per_sec": 252.45762267863148, "retrieval_latency_sec": 0.09774160385131836, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query ranks rows within each 'threat' partition by budget descending, while the generated query ranks all rows based on a custom threat order (High=1, Medium=2, Low=3) combined with budget descending. This changes the ranking logic: the first query ranks within threat categories, while the second ranks globally according to the specified threat priority and budget."}
{"example_id": 459, "sql_complexity": "set operations", "prompt": "What is the total installed capacity of hydroelectric power plants in Brazil and Canada?", "context": "CREATE TABLE hydroelectric_power (country TEXT, capacity INTEGER); INSERT INTO hydroelectric_power (country, capacity) VALUES ('Brazil', 104000), ('Canada', 78000), ('China', 350000), ('United States', 100000), ('Russia', 45000);", "reference_sql": "(SELECT capacity FROM hydroelectric_power WHERE country = 'Brazil') UNION (SELECT capacity FROM hydroelectric_power WHERE country = 'Canada');", "generated_sql": "SELECT SUM(capacity) AS total_capacity \nFROM hydroelectric_power \nWHERE country IN ('Brazil', 'Canada');", "raw_model_output": "To find the total installed capacity of hydroelectric power plants in Brazil and Canada, you can use the following SQL query:\n\n```sql\nSELECT SUM(capacity) AS total_capacity \nFROM hydroelectric_power \nWHERE country IN ('Brazil', 'Canada');\n```", "latency_sec": 1.6583929061889648, "total_duration_sec": 1.623219843, "load_duration_sec": 0.015846402, "tokens_prompt": 885, "prompt_eval_sec": 0.353066045, "tokens_completion": 52, "completion_eval_sec": 1.250013591, "tokens_total": 937, "tokens_per_sec": 565.0048287732087, "retrieval_latency_sec": 0.09867072105407715, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate rows with individual capacities of Brazil and Canada, while the Generated SQL returns a single row with the summed capacity of both countries. The output structures differ (two rows vs. one row with aggregate value), so they are not semantically equivalent."}
{"example_id": 2356, "sql_complexity": "window functions", "prompt": "Find the total billing amount for attorneys in the 'Criminal Law' practice area, for the year 2020, partitioned by attorney's last name and ordered by the total billing amount in descending order.", "context": "CREATE TABLE Attorneys (AttorneyID INT, FirstName VARCHAR(50), LastName VARCHAR(50), PracticeArea VARCHAR(50), TotalBilling FLOAT, BillingYear INT); INSERT INTO Attorneys (AttorneyID, FirstName, LastName, PracticeArea, TotalBilling, BillingYear) VALUES (1, 'Clara', 'Rivera', 'Personal Injury', 8000.00, 2020), (2, 'Jamal', 'Lee', 'Personal Injury', 6000.00, 2019), (3, 'Sophia', 'Gomez', 'Criminal Law', 9000.00, 2020);", "reference_sql": "SELECT LastName, SUM(TotalBilling) OVER (PARTITION BY PracticeArea, LastName, BillingYear) AS TotalBilling FROM Attorneys WHERE PracticeArea = 'Criminal Law' AND BillingYear = 2020 ORDER BY TotalBilling DESC;", "generated_sql": "SELECT LastName, SUM(TotalBilling) AS TotalBilling \nFROM Attorneys \nWHERE PracticeArea = 'Criminal Law' AND BillingYear = 2020 \nGROUP BY LastName \nORDER BY TotalBilling DESC;", "raw_model_output": "The provided examples and context suggest that we need to calculate the sum of `TotalBilling` for each attorney's last name within the 'Criminal Law' practice area for the year 2020. However, since there is no direct partitioning needed (as we are only interested in a single practice area and year), we can simply group by `LastName`. The requirement to order by total billing amount in descending order should be applied after grouping.\n\nHere's the SQL query:\n\n```sql\nSELECT LastName, SUM(TotalBilling) AS TotalBilling \nFROM Attorneys \nWHERE PracticeArea = 'Criminal Law' AND BillingYear = 2020 \nGROUP BY LastName \nORDER BY TotalBilling DESC;\n```\n\nThis query groups by `LastName` and calculates the sum of `TotalBilling` for each group. It filters the records to include only those in the 'Criminal Law' practice area for the year 2020, then orders the results by total billing amount in descending order.", "latency_sec": 6.13527774810791, "total_duration_sec": 5.284266367, "load_duration_sec": 0.015476642, "tokens_prompt": 979, "prompt_eval_sec": 0.387776787, "tokens_completion": 206, "completion_eval_sec": 4.877520087, "tokens_total": 1185, "tokens_per_sec": 193.14529001811667, "retrieval_latency_sec": 0.10741305351257324, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL uses a window function that retains all rows and calculates the sum per partition (PracticeArea, LastName, BillingYear), potentially returning multiple rows per LastName if there are duplicates. The Generated SQL groups by LastName, collapsing multiple rows into a single row per LastName. This difference in output structure (multiple vs. single rows) makes them non-equivalent, even if they produce the same sum value for the given sample data."}
