{"example_id": 2656, "sql_complexity": "multiple_joins", "prompt": "Find the drugs and their respective total sales for rare diseases indication with sales greater than the average sales for infectious diseases.", "context": "CREATE TABLE sales (id INT, drug_id INT, quarter INT, year INT, revenue FLOAT); INSERT INTO sales (id, drug_id, quarter, year, revenue) VALUES (1, 1, 1, 2022, 1500000); CREATE TABLE drugs (id INT, name VARCHAR(50), company VARCHAR(50), indication VARCHAR(50)); INSERT INTO drugs (id, name, company, indication) VALUES (1, 'DrugA', 'ABC Corp', 'Rare_Diseases');", "reference_sql": "SELECT s.drug_id, d.name, SUM(s.revenue) as total_sales FROM sales s JOIN drugs d ON s.drug_id = d.id WHERE d.indication = 'Rare_Diseases' GROUP BY s.drug_id HAVING total_sales > (SELECT AVG(s2.revenue) FROM sales s2 JOIN drugs d2 ON s2.drug_id = d2.id WHERE d2.indication = 'Infectious_Diseases')", "generated_sql": "SELECT\n  d.name,\n  SUM(s.revenue) AS total_sales\nFROM drugs d\nJOIN sales s\n  ON d.id = s.drug_id\nWHERE d.indication = 'Rare_Diseases'\nGROUP BY d.name\nHAVING SUM(s.revenue) > (\n  SELECT AVG(t.total_sales)\n  FROM (\n    SELECT\n      SUM(s2.revenue) AS total_sales\n    FROM drugs d2\n    JOIN sales s2\n      ON d2.id = s2.drug_id\n    WHERE d2.indication = 'Infectious_Diseases'\n    GROUP BY d2.id\n  ) AS t\n);", "raw_model_output": "SELECT\n  d.name,\n  SUM(s.revenue) AS total_sales\nFROM drugs d\nJOIN sales s\n  ON d.id = s.drug_id\nWHERE d.indication = 'Rare_Diseases'\nGROUP BY d.name\nHAVING SUM(s.revenue) > (\n  SELECT AVG(t.total_sales)\n  FROM (\n    SELECT\n      SUM(s2.revenue) AS total_sales\n    FROM drugs d2\n    JOIN sales s2\n      ON d2.id = s2.drug_id\n    WHERE d2.indication = 'Infectious_Diseases'\n    GROUP BY d2.id\n  ) AS t\n);", "latency_sec": 8.4130539894104, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 195, "prompt_eval_sec": null, "tokens_completion": 1050, "completion_eval_sec": null, "tokens_total": 1245, "tokens_per_sec": 147.9843112343145, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in how they calculate the average revenue for 'Infectious_Diseases' drugs. The Reference SQL averages individual sales revenues, while the Generated SQL first aggregates each drug's sales and then averages those totals. This leads to different threshold values in the HAVING clause, making the results non-equivalent."}
{"example_id": 3008, "sql_complexity": "multiple_joins", "prompt": "Who are the users who used electric vehicles and their trip details?", "context": "CREATE TABLE users (id INT, name VARCHAR(50), age INT, gender VARCHAR(10), city VARCHAR(50));CREATE TABLE vehicles (id INT, vehicle_type VARCHAR(20), is_electric BOOLEAN);CREATE TABLE trips (id INT, user_id INT, vehicle_id INT, trip_distance FLOAT, trip_duration INT, departure_time TIMESTAMP, arrival_time TIMESTAMP);INSERT INTO users (id, name, age, gender, city) VALUES (3, 'Alex', 30, 'Female', 'New York');INSERT INTO vehicles (id, vehicle_type, is_electric) VALUES (1, 'Tesla', true), (2, 'Bike', false);INSERT INTO trips (id, user_id, vehicle_id, trip_distance, trip_duration, departure_time, arrival_time) VALUES (3, 3, 1, 15.3, 25, '2022-01-03 12:00:00', '2022-01-03 12:25:00');", "reference_sql": "SELECT u.name, v.vehicle_type, t.trip_distance, t.trip_duration FROM users u JOIN trips t ON u.id = t.user_id JOIN vehicles v ON t.vehicle_id = v.id WHERE v.is_electric = true;", "generated_sql": "SELECT \n  u.id AS user_id,\n  u.name,\n  u.age,\n  u.gender,\n  u.city,\n  t.id AS trip_id,\n  t.trip_distance,\n  t.trip_duration,\n  t.departure_time,\n  t.arrival_time\nFROM users u\nJOIN trips t ON u.id = t.user_id\nJOIN vehicles v ON t.vehicle_id = v.id\nWHERE v.is_electric = TRUE;", "raw_model_output": "SELECT \n  u.id AS user_id,\n  u.name,\n  u.age,\n  u.gender,\n  u.city,\n  t.id AS trip_id,\n  t.trip_distance,\n  t.trip_duration,\n  t.departure_time,\n  t.arrival_time\nFROM users u\nJOIN trips t ON u.id = t.user_id\nJOIN vehicles v ON t.vehicle_id = v.id\nWHERE v.is_electric = TRUE;", "latency_sec": 6.1977479457855225, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 286, "prompt_eval_sec": null, "tokens_completion": 491, "completion_eval_sec": null, "tokens_total": 777, "tokens_per_sec": 125.36811867742396, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects only 4 columns (name, vehicle_type, trip_distance, trip_duration), while the Generated SQL selects 10 columns (including user details, trip metadata, and additional vehicle information). Although both filter electric vehicles and join the same tables, the differing column sets produce structurally different result sets."}
{"example_id": 2531, "sql_complexity": "basic SQL", "prompt": "Who is the top customer by sales in 2022?", "context": "CREATE TABLE customers (customer_id INT, total_sales_2022 FLOAT); INSERT INTO customers (customer_id, total_sales_2022) VALUES (1, 25000.0), (2, 30000.0), (3, 22000.0), (4, 35000.0);", "reference_sql": "SELECT customer_id, total_sales_2022 FROM customers ORDER BY total_sales_2022 DESC LIMIT 1;", "generated_sql": "SELECT customer_id\nFROM customers\nWHERE total_sales_2022 = (\n  SELECT MAX(total_sales_2022)\n  FROM customers\n);", "raw_model_output": "SELECT customer_id\nFROM customers\nWHERE total_sales_2022 = (\n  SELECT MAX(total_sales_2022)\n  FROM customers\n);", "latency_sec": 2.982491970062256, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 143, "prompt_eval_sec": null, "tokens_completion": 304, "completion_eval_sec": null, "tokens_total": 447, "tokens_per_sec": 149.874670070166, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The reference query returns both customer_id and total_sales_2022 columns, ordered by sales descending with a LIMIT 1, while the generated query only returns customer_id and relies on a subquery to find the maximum sales. Additionally, the generated query would return all customers with the maximum sales (if duplicates exist), whereas the reference query would only return one row due to LIMIT 1. In the given data, they might return the same customer_id, but the result sets differ in structure and behavior."}
{"example_id": 3792, "sql_complexity": "single join", "prompt": "What is the maximum distance traveled by an electric vehicle in a single trip, grouped by vehicle model?", "context": "CREATE TABLE Trips (trip_id INT, vehicle_id INT, distance FLOAT); CREATE TABLE ElectricVehicleModels (vehicle_id INT, vehicle_model TEXT);", "reference_sql": "SELECT evm.vehicle_model, MAX(trips.distance) AS max_distance_traveled FROM Trips trips INNER JOIN ElectricVehicleModels evm ON trips.vehicle_id = evm.vehicle_id GROUP BY 1;", "generated_sql": "SELECT evm.vehicle_model,\n       MAX(t.distance) AS max_distance\nFROM Trips AS t\nJOIN ElectricVehicleModels AS evm\n  ON t.vehicle_id = evm.vehicle_id\nGROUP BY evm.vehicle_model;", "raw_model_output": "SELECT evm.vehicle_model,\n       MAX(t.distance) AS max_distance\nFROM Trips AS t\nJOIN ElectricVehicleModels AS evm\n  ON t.vehicle_id = evm.vehicle_id\nGROUP BY evm.vehicle_model;", "latency_sec": 5.973016023635864, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 115, "prompt_eval_sec": null, "tokens_completion": 257, "completion_eval_sec": null, "tokens_total": 372, "tokens_per_sec": 62.28009409784875, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the maximum distance traveled per vehicle model by joining the Trips and ElectricVehicleModels tables. The differences are purely syntactic (alias names and column alias formatting), but the logical structure, join condition, aggregation, and grouping are identical. The GROUP BY clause in both cases effectively groups by the vehicle_model column."}
{"example_id": 2311, "sql_complexity": "subqueries", "prompt": "Determine the percentage of sales from each ingredient category", "context": "CREATE TABLE Sales_Details (sale_id INT, ingredient_id INT, quantity INT); INSERT INTO Sales_Details (sale_id, ingredient_id, quantity) VALUES (1, 1, 2), (1, 2, 8), (2, 1, 3), (2, 2, 7); CREATE TABLE Ingredient_Categories (ingredient_id INT, ingredient_category VARCHAR(255)); INSERT INTO Ingredient_Categories (ingredient_id, ingredient_category) VALUES (1, 'Legumes'), (2, 'Poultry');", "reference_sql": "SELECT ingredient_category, SUM(quantity) AS total_quantity, SUM(quantity) * 100.0 / (SELECT SUM(quantity) FROM Sales_Details) AS percentage_of_sales FROM Sales_Details, Ingredient_Categories WHERE Sales_Details.ingredient_id = Ingredient_Categories.ingredient_id GROUP BY ingredient_category;", "generated_sql": "SELECT\n  ic.ingredient_category,\n  SUM(sd.quantity) AS total_quantity,\n  100.0 * SUM(sd.quantity) / (\n    SELECT SUM(quantity)\n    FROM Sales_Details\n  ) AS percentage_of_total\nFROM Sales_Details sd\nJOIN Ingredient_Categories ic\n  ON sd.ingredient_id = ic.ingredient_id\nGROUP BY\n  ic.ingredient_category;", "raw_model_output": "SELECT\n  ic.ingredient_category,\n  SUM(sd.quantity) AS total_quantity,\n  100.0 * SUM(sd.quantity) / (\n    SELECT SUM(quantity)\n    FROM Sales_Details\n  ) AS percentage_of_total\nFROM Sales_Details sd\nJOIN Ingredient_Categories ic\n  ON sd.ingredient_id = ic.ingredient_id\nGROUP BY\n  ic.ingredient_category;", "latency_sec": 2.7473480701446533, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 188, "prompt_eval_sec": null, "tokens_completion": 291, "completion_eval_sec": null, "tokens_total": 479, "tokens_per_sec": 174.3499504868998, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the total quantity sold per ingredient category and the percentage of total sales. They use equivalent JOIN logic (implicit vs explicit), same aggregation calculations (SUM(quantity) * 100.0 / total vs 100.0 * SUM(quantity) / total), and identical grouping. The subquery for total sales is also the same. The only differences are syntax conventions (JOIN vs comma join, aliasing) which don't affect semantic output."}
{"example_id": 3329, "sql_complexity": "set operations", "prompt": "Which causes received funding from donors in both the United States and Canada?", "context": "CREATE TABLE donor_location (donor_id INT, country VARCHAR(50), cause VARCHAR(50), donation DECIMAL(10,2)); INSERT INTO donor_location (donor_id, country, cause, donation) VALUES (1, 'United States', 'Global Health', 1000.00), (2, 'Canada', 'Education', 2000.00), (3, 'United States', 'Environment', 1500.00), (4, 'Canada', 'Animal Welfare', 2500.00);", "reference_sql": "SELECT cause FROM donor_location WHERE country = 'United States' INTERSECT SELECT cause FROM donor_location WHERE country = 'Canada';", "generated_sql": "SELECT cause\nFROM donor_location\nWHERE country IN ('United States', 'Canada')\nGROUP BY cause\nHAVING COUNT(DISTINCT country) = 2;", "raw_model_output": "SELECT cause\nFROM donor_location\nWHERE country IN ('United States', 'Canada')\nGROUP BY cause\nHAVING COUNT(DISTINCT country) = 2;", "latency_sec": 2.1373131275177, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 188, "prompt_eval_sec": null, "tokens_completion": 244, "completion_eval_sec": null, "tokens_total": 432, "tokens_per_sec": 202.12293390146803, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve causes that appear in both 'United States' and 'Canada'. The reference uses INTERSECT to find common causes between the two countries, while the generated query groups by cause and ensures each cause exists in both countries via COUNT(DISTINCT country) = 2. Both approaches yield the same result set."}
{"example_id": 2912, "sql_complexity": "single join", "prompt": "Which company has manufactured the most satellites?", "context": "CREATE TABLE manufacturers (id INT, name TEXT); CREATE TABLE satellites (id INT, manufacturer_id INT, name TEXT, launch_date DATE); INSERT INTO manufacturers (id, name) VALUES (1, 'SpaceX'), (2, 'Blue Origin'), (3, 'ISRO'), (4, 'CAST'); INSERT INTO satellites (id, manufacturer_id, name, launch_date) VALUES (1, 1, 'StarDragon', '2012-05-25'), (2, 1, 'Falcon', '2015-12-21'), (3, 2, 'New Glenn', '2022-01-11'), (4, 3, 'ChinaSat 1E', '2000-12-05'), (5, 3, 'ChinaSat 2A', '2003-08-13'), (6, 4, 'Shijian 9', '2017-11-19'), (7, 1, 'StarLink', '2020-05-24'), (8, 1, 'StarLink', '2020-06-13');", "reference_sql": "SELECT m.name, COUNT(s.id) FROM manufacturers m JOIN satellites s ON m.id = s.manufacturer_id GROUP BY m.name ORDER BY COUNT(s.id) DESC;", "generated_sql": "SELECT\n  m.name\nFROM\n  manufacturers AS m\n  JOIN satellites AS s ON m.id = s.manufacturer_id\nGROUP BY\n  m.name\nORDER BY\n  COUNT(*) DESC\nFETCH FIRST 1 ROW ONLY;", "raw_model_output": "SELECT\n  m.name\nFROM\n  manufacturers AS m\n  JOIN satellites AS s ON m.id = s.manufacturer_id\nGROUP BY\n  m.name\nORDER BY\n  COUNT(*) DESC\nFETCH FIRST 1 ROW ONLY;", "latency_sec": 2.180921792984009, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 306, "prompt_eval_sec": null, "tokens_completion": 260, "completion_eval_sec": null, "tokens_total": 566, "tokens_per_sec": 259.52329048240665, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns all manufacturers sorted by their satellite count in descending order, while the Generated SQL adds a FETCH FIRST 1 ROW ONLY clause, limiting the result to only the top manufacturer with the highest satellite count. This makes them semantically different."}
{"example_id": 3170, "sql_complexity": "aggregation", "prompt": "Determine the total production quantity of silver for mining sites in Mexico, between the dates '2017-05-01' and '2017-09-30', having less than 40 employees.", "context": "CREATE TABLE silver_mine_2 (site_id INT, country VARCHAR(50), num_employees INT, extraction_date DATE, quantity INT); INSERT INTO silver_mine_2 (site_id, country, num_employees, extraction_date, quantity) VALUES (1, 'Mexico', 35, '2017-05-02', 1200), (2, 'Mexico', 30, '2017-08-31', 1800), (3, 'Mexico', 37, '2017-07-04', 2200);", "reference_sql": "SELECT country, SUM(quantity) as total_silver_prod FROM silver_mine_2 WHERE num_employees < 40 AND country = 'Mexico' AND extraction_date >= '2017-05-01' AND extraction_date <= '2017-09-30' GROUP BY country;", "generated_sql": "SELECT SUM(quantity) AS total_quantity\nFROM silver_mine_2\nWHERE country = 'Mexico'\n  AND extraction_date BETWEEN '2017-05-01' AND '2017-09-30'\n  AND num_employees < 40;", "raw_model_output": "SELECT SUM(quantity) AS total_quantity\nFROM silver_mine_2\nWHERE country = 'Mexico'\n  AND extraction_date BETWEEN '2017-05-01' AND '2017-09-30'\n  AND num_employees < 40;", "latency_sec": 3.10262393951416, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 221, "prompt_eval_sec": null, "tokens_completion": 327, "completion_eval_sec": null, "tokens_total": 548, "tokens_per_sec": 176.6246927385635, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two columns (country and total_silver_prod), while the Generated SQL returns only one column (total_quantity). Although both calculate the same aggregate sum, their result structures differ, making them non-equivalent in terms of output format."}
{"example_id": 3518, "sql_complexity": "basic SQL", "prompt": "Insert new records of ticket sales for a new event, including event and salesperson information.", "context": "CREATE TABLE salesperson (salesperson_id INT, name VARCHAR(50), position VARCHAR(50)); CREATE TABLE tickets (ticket_id INT, salesperson_id INT, event_id INT, price DECIMAL(5,2), quantity INT); CREATE TABLE events (event_id INT, name VARCHAR(50), date DATE); INSERT INTO salesperson VALUES (1, 'John Doe', 'Senior Salesperson'); INSERT INTO events VALUES (2, 'New Event', '2023-04-15');", "reference_sql": "INSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity) VALUES (2, 1, 2, 75, 50), (3, 2, 2, 65, 75); INSERT INTO events (event_id, name, date) VALUES (2, 'New Event', '2023-04-15');", "generated_sql": "Insert the new event  \nINSERT INTO events (event_id, name, date)  \nVALUES (3, 'Charity Concert', DATE '2024-06-30');", "raw_model_output": "BEGIN;\n  \n-- Insert the new event  \nINSERT INTO events (event_id, name, date)  \nVALUES (3, 'Charity Concert', DATE '2024-06-30');\n\n-- (Optionally) Insert a new salesperson  \nINSERT INTO salesperson (salesperson_id, name, position)  \nVALUES (2, 'Jane Smith', 'Associate Salesperson');\n\n-- Insert one or more ticket\u2010sale records for that event/salesperson  \nINSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity)  \nVALUES \n  (101, 2, 3, 75.00, 50), \n  (102, 2, 3, 120.00, 20);\n\nCOMMIT;", "latency_sec": 9.203855276107788, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 180, "prompt_eval_sec": null, "tokens_completion": 1514, "completion_eval_sec": null, "tokens_total": 1694, "tokens_per_sec": 184.0533069220939, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL inserts two ticket records and an event record (event_id=2), while the Generated SQL only inserts a single new event (event_id=3). They operate on different tables (tickets vs events) and insert distinct data. The Generated SQL does not include any ticket inserts or reference the salesperson table, making them semantically different."}
{"example_id": 3925, "sql_complexity": "set operations", "prompt": "What is the total number of students and staff with accommodations in the \"disability_services\" schema, excluding the \"accessibility_parking\" type?", "context": "CREATE SCHEMA disability_services; CREATE TABLE staff (id INT, name VARCHAR(50), accommodation VARCHAR(50)); CREATE TABLE students (id INT, name VARCHAR(50), accommodation VARCHAR(50));", "reference_sql": "SELECT COUNT(*) FROM disability_services.staff WHERE accommodation != 'accessibility_parking' UNION SELECT COUNT(*) FROM disability_services.students WHERE accommodation != 'accessibility_parking';", "generated_sql": "SELECT COUNT(*) AS total_count\nFROM (\n  SELECT id\n  FROM disability_services.staff\n  WHERE accommodation IS NOT NULL\n    AND accommodation <> 'accessibility_parking'\n  UNION ALL\n  SELECT id\n  FROM disability_services.students\n  WHERE accommodation IS NOT NULL\n    AND accommodation <> 'accessibility_parking'\n) AS combined;", "raw_model_output": "SELECT COUNT(*) AS total_count\nFROM (\n  SELECT id\n  FROM disability_services.staff\n  WHERE accommodation IS NOT NULL\n    AND accommodation <> 'accessibility_parking'\n  UNION ALL\n  SELECT id\n  FROM disability_services.students\n  WHERE accommodation IS NOT NULL\n    AND accommodation <> 'accessibility_parking'\n) AS combined;", "latency_sec": 3.3197197914123535, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 136, "prompt_eval_sec": null, "tokens_completion": 474, "completion_eval_sec": null, "tokens_total": 610, "tokens_per_sec": 183.75044832939935, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate counts (staff and students) as two rows, while the Generated SQL combines both into a single total count. The Generated SQL also uses UNION ALL (which preserves duplicates) but the outer COUNT(*) aggregates all combined rows into one value. The Reference SQL's structure inherently produces two results, making them semantically different."}
{"example_id": 3340, "sql_complexity": "subqueries", "prompt": "Calculate the total revenue for garments manufactured in the US and sold in California.", "context": "CREATE TABLE garment_manufacturing(id INT PRIMARY KEY, garment_id INT, country VARCHAR(50), material VARCHAR(50), manufacturing_date DATE, quantity INT); CREATE TABLE garment_sales(id INT PRIMARY KEY, garment_id INT, store_id INT, sale_date DATE, units INT, revenue DECIMAL(10,2));", "reference_sql": "SELECT SUM(gs.revenue) FROM garment_manufacturing gm JOIN garment_sales gs ON gm.garment_id = gs.garment_id WHERE gm.country = 'United States' AND gs.store_id IN (SELECT id FROM stores WHERE region = 'California');", "generated_sql": "SELECT\n  SUM(gs.revenue) AS total_revenue\nFROM\n  garment_sales gs\n  JOIN garment_manufacturing gm\n    ON gs.garment_id = gm.garment_id\nWHERE\n  gm.country = 'US'\n  AND gs.store_id IN (\n    SELECT id\n    FROM stores\n    WHERE state = 'California'\n  );", "raw_model_output": "SELECT\n  SUM(gs.revenue) AS total_revenue\nFROM\n  garment_sales gs\n  JOIN garment_manufacturing gm\n    ON gs.garment_id = gm.garment_id\nWHERE\n  gm.country = 'US'\n  AND gs.store_id IN (\n    SELECT id\n    FROM stores\n    WHERE state = 'California'\n  );", "latency_sec": 12.680299043655396, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 145, "prompt_eval_sec": null, "tokens_completion": 2014, "completion_eval_sec": null, "tokens_total": 2159, "tokens_per_sec": 170.264123311844, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects: 1) The country condition uses 'United States' vs 'US' (assuming 'US' is not equivalent to 'United States' in the data). 2) The subquery references 'region' vs 'state' in the stores table (assuming these are different columns with potentially different values). These differences would produce different results unless the data explicitly maps 'US' to 'United States' and 'region'/'state' to identical store IDs, which cannot be assumed."}
{"example_id": 596, "sql_complexity": "basic SQL", "prompt": "What is the minimum energy production cost of wind farms in Spain?", "context": "CREATE TABLE wind_farm_costs (id INT, name TEXT, country TEXT, energy_production_cost FLOAT); INSERT INTO wind_farm_costs (id, name, country, energy_production_cost) VALUES (1, 'Las Tiesas', 'Spain', 0.045), (2, 'Eolo', 'Spain', 0.050);", "reference_sql": "SELECT MIN(energy_production_cost) FROM wind_farm_costs WHERE country = 'Spain';", "generated_sql": "SELECT MIN(energy_production_cost) AS min_cost\nFROM wind_farm_costs\nWHERE country = 'Spain';", "raw_model_output": "SELECT MIN(energy_production_cost) AS min_cost\nFROM wind_farm_costs\nWHERE country = 'Spain';", "latency_sec": 2.450820207595825, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 154, "prompt_eval_sec": null, "tokens_completion": 108, "completion_eval_sec": null, "tokens_total": 262, "tokens_per_sec": 106.90298667686173, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the minimum energy_production_cost for Spain. The generated query adds an alias 'min_cost' to the result column, but this does not affect the semantic value of the result. The core logic (filtering by country and calculating MIN) remains identical."}
{"example_id": 2604, "sql_complexity": "subqueries", "prompt": "What is the maximum number of virtual tours taken by a single user in the UK?", "context": "CREATE TABLE virtual_tour_data (user_id INT, hotel_id INT, tour_date DATE); INSERT INTO virtual_tour_data (user_id, hotel_id, tour_date) VALUES (1, 10, '2022-01-01'), (2, 11, '2022-01-03'), (3, 12, '2022-01-05'), (4, 10, '2022-01-07'), (5, 10, '2022-01-09'); CREATE TABLE hotels (hotel_id INT, hotel_name TEXT, country TEXT); INSERT INTO hotels (hotel_id, hotel_name, country) VALUES (10, 'Royal Park Hotel', 'UK'), (11, 'The Ritz London', 'UK'), (12, 'Hotel de Crillon', 'France');", "reference_sql": "SELECT MAX(vt.user_tours) FROM (SELECT user_id, COUNT(DISTINCT hotel_id) as user_tours FROM virtual_tour_data WHERE country = 'UK' GROUP BY user_id) as vt;", "generated_sql": "SELECT MAX(tour_count) AS max_tours\nFROM (\n  SELECT v.user_id, COUNT(*) AS tour_count\n  FROM virtual_tour_data v\n  JOIN hotels h ON v.hotel_id = h.hotel_id\n  WHERE h.country = 'UK'\n  GROUP BY v.user_id\n) AS user_tours;", "raw_model_output": "SELECT MAX(tour_count) AS max_tours\nFROM (\n  SELECT v.user_id, COUNT(*) AS tour_count\n  FROM virtual_tour_data v\n  JOIN hotels h ON v.hotel_id = h.hotel_id\n  WHERE h.country = 'UK'\n  GROUP BY v.user_id\n) AS user_tours;", "latency_sec": 3.6258177757263184, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 251, "prompt_eval_sec": null, "tokens_completion": 470, "completion_eval_sec": null, "tokens_total": 721, "tokens_per_sec": 198.85169211394535, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references a non-existent 'country' column in the virtual_tour_data table, making it invalid. The Generated SQL correctly joins with the hotels table to filter by country. Additionally, the Reference SQL uses COUNT(DISTINCT hotel_id) while the Generated SQL uses COUNT(*), which would produce different results if users visited the same hotel multiple times."}
{"example_id": 5812, "sql_complexity": "single join", "prompt": "Calculate the percentage of Shariah-compliant investments held by each investor in the top 5 countries with the highest percentage?", "context": "CREATE TABLE investors (investor_id INT, investor_name TEXT, country TEXT); INSERT INTO investors (investor_id, investor_name, country) VALUES (1, 'Al Thani', 'Qatar'), (2, 'Saudi Investment Group', 'Saudi Arabia'), (3, 'Temasek Holdings', 'Singapore'); CREATE TABLE investments (investment_id INT, investor_id INT, investment_type TEXT, investment_value DECIMAL, is_shariah_compliant BOOLEAN); INSERT INTO investments (investment_id, investor_id, investment_type, investment_value, is_shariah_compliant) VALUES (1, 1, 'Real Estate', 15000000, true), (2, 2, 'Stocks', 20000000, false);", "reference_sql": "SELECT investor_name, ROUND((SUM(CASE WHEN is_shariah_compliant THEN investment_value ELSE 0 END) / SUM(investment_value)) * 100, 2) AS percentage FROM investments JOIN investors ON investments.investor_id = investors.investor_id GROUP BY investor_name ORDER BY percentage DESC LIMIT 5;", "generated_sql": "SELECT\n    inv.country,\n    SUM(CASE WHEN ins.is_shariah_compliant THEN ins.investment_value ELSE 0 END)                AS shariah_val,\n    SUM(ins.investment_value)                                                                  AS total_val,\n    100.0 * SUM(CASE WHEN ins.is_shariah_compliant THEN ins.investment_value ELSE 0 END)\n           / NULLIF(SUM(ins.investment_value), 0)                                              AS country_compliance_pct\n  FROM investors AS inv\n  JOIN investments AS ins\n    ON inv.investor_id = ins.investor_id\n  GROUP BY inv.country\n),\ntop_countries AS (\n  SELECT country\n  FROM country_stats\n  ORDER BY country_compliance_pct DESC\n  FETCH FIRST 5 ROWS ONLY\n)\nSELECT\n  inv.investor_name,\n  inv.country,\n  ROUND(\n    100.0 * SUM(CASE WHEN ins.is_shariah_compliant THEN ins.investment_value ELSE 0 END)\n          / NULLIF(SUM(ins.investment_value), 0),\n    2\n  ) AS compliance_percentage\nFROM investors AS inv\nJOIN investments AS ins\n  ON inv.investor_id = ins.investor_id\nJOIN top_countries AS tc\n  ON inv.country = tc.country\nGROUP BY inv.investor_name, inv.country\nORDER BY inv.country, compliance_percentage DESC;", "raw_model_output": "WITH country_stats AS (\n  SELECT\n    inv.country,\n    SUM(CASE WHEN ins.is_shariah_compliant THEN ins.investment_value ELSE 0 END)                AS shariah_val,\n    SUM(ins.investment_value)                                                                  AS total_val,\n    100.0 * SUM(CASE WHEN ins.is_shariah_compliant THEN ins.investment_value ELSE 0 END)\n           / NULLIF(SUM(ins.investment_value), 0)                                              AS country_compliance_pct\n  FROM investors AS inv\n  JOIN investments AS ins\n    ON inv.investor_id = ins.investor_id\n  GROUP BY inv.country\n),\ntop_countries AS (\n  SELECT country\n  FROM country_stats\n  ORDER BY country_compliance_pct DESC\n  FETCH FIRST 5 ROWS ONLY\n)\nSELECT\n  inv.investor_name,\n  inv.country,\n  ROUND(\n    100.0 * SUM(CASE WHEN ins.is_shariah_compliant THEN ins.investment_value ELSE 0 END)\n          / NULLIF(SUM(ins.investment_value), 0),\n    2\n  ) AS compliance_percentage\nFROM investors AS inv\nJOIN investments AS ins\n  ON inv.investor_id = ins.investor_id\nJOIN top_countries AS tc\n  ON inv.country = tc.country\nGROUP BY inv.investor_name, inv.country\nORDER BY inv.country, compliance_percentage DESC;", "latency_sec": 7.452256679534912, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 243, "prompt_eval_sec": null, "tokens_completion": 958, "completion_eval_sec": null, "tokens_total": 1201, "tokens_per_sec": 161.1592369460566, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates compliance percentages per investor and orders by investor-level compliance. The Generated SQL first calculates country-level compliance, selects top countries, then shows investor-level compliance only for those countries. The output columns differ (country included in Generated), and the filtering/ grouping logic is fundamentally different. The Generated SQL also uses a CTE and FETCH FIRST which are not present in the Reference."}
{"example_id": 4706, "sql_complexity": "multiple_joins", "prompt": "Who are the top 3 customers by total spend on makeup products from Italy and Spain?", "context": "CREATE TABLE customers (customer_id INT, customer_name TEXT, country TEXT); INSERT INTO customers (customer_id, customer_name, country) VALUES (1, 'Alessandro Martini', 'IT'), (2, 'Laura Rossi', 'ES'), (3, 'Daniela Gonzalez', 'MX'), (4, 'Jose Hernandez', 'ES'), (5, 'Sophia Rodriguez', 'IT'); CREATE TABLE sales (sale_id INT, customer_id INT, product_id INT, sale_quantity INT, sale_country TEXT); INSERT INTO sales (sale_id, customer_id, product_id, sale_quantity, sale_country) VALUES (1, 1, 1, 100, 'IT'), (2, 2, 2, 150, 'ES'), (3, 3, 3, 200, 'MX'), (4, 4, 4, 250, 'ES'), (5, 5, 5, 300, 'IT'); CREATE TABLE products (product_id INT, product_name TEXT, category TEXT); INSERT INTO products (product_id, product_name, category) VALUES (1, 'Eyeshadow Palette', 'makeup'), (2, 'Liquid Lipstick', 'makeup'), (3, 'BB Cream', 'makeup'), (4, 'Volumizing Mascara', 'makeup'), (5, 'Nourishing Lip Balm', 'makeup');", "reference_sql": "SELECT c.customer_name, SUM(s.sale_quantity) as total_spent_on_makeup FROM sales s JOIN customers c ON s.customer_id = c.customer_id JOIN products p ON s.product_id = p.product_id WHERE c.country IN ('IT', 'ES') AND p.category = 'makeup' GROUP BY c.customer_name ORDER BY total_spent_on_makeup DESC LIMIT 3;", "generated_sql": "SELECT \n  c.customer_name, \n  SUM(s.sale_quantity) AS total_spend \nFROM customers c \nJOIN sales s \n  ON c.customer_id = s.customer_id \nJOIN products p \n  ON s.product_id = p.product_id \nWHERE p.category = 'makeup' \n  AND c.country IN ('IT','ES') \nGROUP BY c.customer_name \nORDER BY total_spend DESC \nFETCH FIRST 3 ROWS ONLY;", "raw_model_output": "SELECT \n  c.customer_name, \n  SUM(s.sale_quantity) AS total_spend \nFROM customers c \nJOIN sales s \n  ON c.customer_id = s.customer_id \nJOIN products p \n  ON s.product_id = p.product_id \nWHERE p.category = 'makeup' \n  AND c.country IN ('IT','ES') \nGROUP BY c.customer_name \nORDER BY total_spend DESC \nFETCH FIRST 3 ROWS ONLY;", "latency_sec": 6.366430759429932, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 376, "prompt_eval_sec": null, "tokens_completion": 1007, "completion_eval_sec": null, "tokens_total": 1383, "tokens_per_sec": 217.23318013810265, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the top 3 customers from IT and ES countries based on their total makeup purchases. The differences are purely syntactic: the generated query uses FETCH FIRST 3 ROWS ONLY instead of LIMIT 3, and the alias name differs (total_spend vs total_spent_on_makeup). The logical structure, join conditions, filtering, grouping, and ordering are identical."}
{"example_id": 1515, "sql_complexity": "multiple_joins", "prompt": "What is the average age of clients who lost cases in the 'personal injury' category?", "context": "CREATE TABLE Cases (CaseID int, ClientID int, Category varchar(50)); INSERT INTO Cases (CaseID, ClientID, Category) VALUES (701, 7, 'Personal Injury'); CREATE TABLE Clients (ClientID int, Age int, Gender varchar(10)); INSERT INTO Clients (ClientID, Age, Gender) VALUES (7, 45, 'Male'); CREATE TABLE CaseOutcomes (CaseID int, Outcome varchar(50)); INSERT INTO CaseOutcomes (CaseID, Outcome) VALUES (701, 'Lost');", "reference_sql": "SELECT AVG(C.Age) as AvgAge FROM Clients C INNER JOIN Cases CA ON C.ClientID = CA.ClientID INNER JOIN CaseOutcomes CO ON CA.CaseID = CO.CaseID WHERE CA.Category = 'Personal Injury' AND CO.Outcome = 'Lost';", "generated_sql": "SELECT AVG(cl.Age) AS average_age\nFROM Cases ca\nJOIN CaseOutcomes co ON ca.CaseID = co.CaseID\nJOIN Clients cl ON ca.ClientID = cl.ClientID\nWHERE ca.Category = 'Personal Injury'\n  AND co.Outcome = 'Lost';", "raw_model_output": "SELECT AVG(cl.Age) AS average_age\nFROM Cases ca\nJOIN CaseOutcomes co ON ca.CaseID = co.CaseID\nJOIN Clients cl ON ca.ClientID = cl.ClientID\nWHERE ca.Category = 'Personal Injury'\n  AND co.Outcome = 'Lost';", "latency_sec": 2.64251971244812, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 194, "prompt_eval_sec": null, "tokens_completion": 334, "completion_eval_sec": null, "tokens_total": 528, "tokens_per_sec": 199.80929470942067, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries compute the average age of clients with 'Personal Injury' cases that resulted in a 'Lost' outcome. They use identical join conditions (Clients.ClientID = Cases.ClientID and Cases.CaseID = CaseOutcomes.CaseID), same WHERE filters (Category = 'Personal Injury' and Outcome = 'Lost'), and aggregate the same column (Clients.Age). The differences are purely syntactic (alias names and join order) which do not affect the semantic result."}
{"example_id": 4388, "sql_complexity": "subqueries", "prompt": "Insert a new drug with a price 10% higher than the average price", "context": "CREATE TABLE drugs (drug_id INT, drug_name VARCHAR(50), price DECIMAL(10, 2)); INSERT INTO drugs (drug_id, drug_name, price) VALUES (1, 'DrugA', 50), (2, 'DrugB', 75), (3, 'DrugC', 100)", "reference_sql": "INSERT INTO drugs (drug_id, drug_name, price) VALUES ((SELECT MAX(drug_id) FROM drugs) + 1, 'DrugD', (SELECT AVG(price) * 1.1 FROM drugs))", "generated_sql": "INSERT INTO drugs (drug_id, drug_name, price)\nSELECT COALESCE(MAX(drug_id), 0) + 1,\n       'NewDrug',\n       AVG(price) * 1.10\nFROM drugs;", "raw_model_output": "INSERT INTO drugs (drug_id, drug_name, price)\nSELECT COALESCE(MAX(drug_id), 0) + 1,\n       'NewDrug',\n       AVG(price) * 1.10\nFROM drugs;", "latency_sec": 2.587609052658081, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 148, "prompt_eval_sec": null, "tokens_completion": 321, "completion_eval_sec": null, "tokens_total": 469, "tokens_per_sec": 181.2483997604766, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the drug_name values are different ('DrugD' vs 'NewDrug'). Second, the drug_id calculation handles empty tables differently: the Reference SQL would produce NULL for drug_id if the table is empty (causing an error), while the Generated SQL uses COALESCE to default to 1. Additionally, the Generated SQL's structure using a SELECT with AVG() may behave differently in edge cases compared to the subquery approach in the Reference SQL."}
{"example_id": 5431, "sql_complexity": "basic SQL", "prompt": "What is the average CO2 emission of ride-hailing vehicles in San Francisco?", "context": "CREATE TABLE SFRideHailing (id INT, company VARCHAR(20), co2_emission DECIMAL(5,2));", "reference_sql": "SELECT AVG(co2_emission) FROM SFRideHailing WHERE company = 'Uber';", "generated_sql": "SELECT AVG(co2_emission) AS average_co2_emission\nFROM SFRideHailing;", "raw_model_output": "SELECT AVG(co2_emission) AS average_co2_emission\nFROM SFRideHailing;", "latency_sec": 1.7622740268707275, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 109, "prompt_eval_sec": null, "tokens_completion": 168, "completion_eval_sec": null, "tokens_total": 277, "tokens_per_sec": 157.18327330277305, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters results to only include rows where company = 'Uber' before calculating the average, while the Generated SQL calculates the average for all companies without any filtering. The presence of the WHERE clause in the Reference query makes it semantically different from the Generated query."}
{"example_id": 3531, "sql_complexity": "single join", "prompt": "What is the total number of workouts and total workout time per user for users with a membership type of 'Basic'?", "context": "CREATE TABLE Members (id INT, user_name VARCHAR, membership_type VARCHAR, signup_date DATE); CREATE TABLE Workouts (id INT, user_id INT, workout_date DATE, workout_duration INT); INSERT INTO Members (id, user_name, membership_type, signup_date) VALUES (1, 'John Doe', 'Premium', '2020-01-01'), (2, 'Jane Smith', 'Basic', '2019-06-15'), (3, 'Alice Johnson', 'Premium', '2020-03-20'); INSERT INTO Workouts (id, user_id, workout_date, workout_duration) VALUES (1, 1, '2020-01-01', 60), (2, 1, '2020-01-02', 70), (3, 2, '2019-06-15', 90), (4, 3, '2020-03-20', 65), (5, 3, '2020-03-21', 70);", "reference_sql": "SELECT Members.user_name, SUM(Workouts.workout_duration) AS total_workout_time, COUNT(Workouts.id) AS total_workouts FROM Members JOIN Workouts ON Members.id = Workouts.user_id WHERE Members.membership_type = 'Basic' GROUP BY Members.user_name;", "generated_sql": "SELECT \n  m.id AS user_id,\n  m.user_name,\n  COUNT(w.id)        AS total_workouts,\n  SUM(w.workout_duration) AS total_workout_time\nFROM Members m\nJOIN Workouts w\n  ON m.id = w.user_id\nWHERE m.membership_type = 'Basic'\nGROUP BY m.id, m.user_name;", "raw_model_output": "SELECT \n  m.id AS user_id,\n  m.user_name,\n  COUNT(w.id)        AS total_workouts,\n  SUM(w.workout_duration) AS total_workout_time\nFROM Members m\nJOIN Workouts w\n  ON m.id = w.user_id\nWHERE m.membership_type = 'Basic'\nGROUP BY m.id, m.user_name;", "latency_sec": 3.6444709300994873, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 301, "prompt_eval_sec": null, "tokens_completion": 477, "completion_eval_sec": null, "tokens_total": 778, "tokens_per_sec": 213.4740583535844, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects only 'user_name' and aggregates data, while the Generated SQL includes 'user_id' as an additional column. Although both group by user-related fields and calculate the same aggregates, the presence of the extra 'user_id' column in the Generated SQL changes the result set structure, making them non-equivalent."}
{"example_id": 5678, "sql_complexity": "set operations", "prompt": "How many public works projects are there in 'Sydney' and 'Melbourne' combined?", "context": "CREATE TABLE PublicWorksC(id INT, city VARCHAR(20), project VARCHAR(30)); INSERT INTO PublicWorksC(id, city, project) VALUES (1, 'Sydney', 'Park Renovation'), (2, 'Melbourne', 'Sidewalk Repair');", "reference_sql": "SELECT COUNT(*) FROM (SELECT city FROM PublicWorksC WHERE city = 'Sydney' UNION ALL SELECT city FROM PublicWorksC WHERE city = 'Melbourne') AS Total;", "generated_sql": "SELECT COUNT(*) AS total_projects\nFROM PublicWorksC\nWHERE city IN ('Sydney', 'Melbourne');", "raw_model_output": "SELECT COUNT(*) AS total_projects\nFROM PublicWorksC\nWHERE city IN ('Sydney', 'Melbourne');", "latency_sec": 2.4778852462768555, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 137, "prompt_eval_sec": null, "tokens_completion": 169, "completion_eval_sec": null, "tokens_total": 306, "tokens_per_sec": 123.49240161939704, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of rows where the city is either 'Sydney' or 'Melbourne'. The Reference SQL uses a UNION ALL to combine results from two subqueries, while the Generated SQL uses IN to filter directly. Since UNION ALL preserves duplicates and IN includes all matching rows, the final COUNT(*) will be identical in both cases."}
{"example_id": 5792, "sql_complexity": "multiple_joins", "prompt": "How many cases were handled by attorneys in the 'Los Angeles' office?", "context": "CREATE TABLE offices (office_id INT, office_name VARCHAR(20), city VARCHAR(20), state VARCHAR(20)); INSERT INTO offices (office_id, office_name, city, state) VALUES (1, 'Boston', 'Boston', 'MA'), (2, 'New York', 'New York', 'NY'), (3, 'Los Angeles', 'Los Angeles', 'CA'); CREATE TABLE attorneys (attorney_id INT, office_id INT); INSERT INTO attorneys (attorney_id, office_id) VALUES (1, 1), (2, 2), (3, 3); CREATE TABLE cases (case_id INT, attorney_id INT); INSERT INTO cases (case_id, attorney_id) VALUES (1, 1), (2, 2), (3, 3);", "reference_sql": "SELECT COUNT(*) FROM cases JOIN attorneys ON cases.attorney_id = attorneys.attorney_id JOIN offices ON attorneys.office_id = offices.office_id WHERE offices.city = 'Los Angeles';", "generated_sql": "SELECT COUNT(*) AS case_count\nFROM cases c\nJOIN attorneys a ON c.attorney_id = a.attorney_id\nJOIN offices o ON a.office_id = o.office_id\nWHERE o.office_name = 'Los Angeles';", "raw_model_output": "SELECT COUNT(*) AS case_count\nFROM cases c\nJOIN attorneys a ON c.attorney_id = a.attorney_id\nJOIN offices o ON a.office_id = o.office_id\nWHERE o.office_name = 'Los Angeles';", "latency_sec": 2.1886470317840576, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 244, "prompt_eval_sec": null, "tokens_completion": 257, "completion_eval_sec": null, "tokens_total": 501, "tokens_per_sec": 228.90854154386602, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters by 'offices.city = 'Los Angeles'', while the Generated SQL filters by 'o.office_name = 'Los Angeles''. Although in the provided data the office_name and city columns coincide for the Los Angeles office, the queries are not semantically equivalent because they check different columns. Semantically, 'city' and 'office_name' represent distinct attributes, and their values could differ in other data scenarios."}
{"example_id": 5148, "sql_complexity": "window functions", "prompt": "List the unique types of smart city technologies that have been implemented in the top 3 most populous countries in the world.", "context": "CREATE TABLE smart_city_tech (tech_type VARCHAR(255), country VARCHAR(255)); CREATE TABLE country_populations (country VARCHAR(255), population INT);", "reference_sql": "SELECT DISTINCT tech_type FROM smart_city_tech SCT WHERE country IN (SELECT country FROM (SELECT country, ROW_NUMBER() OVER (ORDER BY population DESC) as rank FROM country_populations) CP WHERE rank <= 3);", "generated_sql": "SELECT country\n  FROM country_populations\n  ORDER BY population DESC\n  FETCH FIRST 3 ROWS ONLY\n)\nSELECT DISTINCT sct.tech_type\nFROM smart_city_tech AS sct\nJOIN top_countries AS tc\n  ON sct.country = tc.country;", "raw_model_output": "WITH top_countries AS (\n  SELECT country\n  FROM country_populations\n  ORDER BY population DESC\n  FETCH FIRST 3 ROWS ONLY\n)\nSELECT DISTINCT sct.tech_type\nFROM smart_city_tech AS sct\nJOIN top_countries AS tc\n  ON sct.country = tc.country;", "latency_sec": 13.813891172409058, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 122, "prompt_eval_sec": null, "tokens_completion": 1043, "completion_eval_sec": null, "tokens_total": 1165, "tokens_per_sec": 84.33539727943514, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query uses a subquery with ROW_NUMBER() to select top 3 countries by population, while the generated query uses FETCH FIRST 3 ROWS ONLY (which is non-standard SQL). Additionally, the generated query appears to have incorrect syntax with two separate SELECT statements. Even if the generated query were corrected to use a CTE, differences in handling ties (ROW_NUMBER() vs. FETCH) could lead to different results."}
{"example_id": 5547, "sql_complexity": "multiple_joins", "prompt": "Which species have a population growth rate higher than the average for protected areas?", "context": "CREATE TABLE species (id INT, name VARCHAR(50), population DECIMAL(5,2), protected_area_id INT, growth_rate DECIMAL(5,2)); INSERT INTO species (id, name, population, protected_area_id, growth_rate) VALUES (1, 'Species 1', 500.00, 1, 0.05), (2, 'Species 2', 800.00, 1, 0.03), (3, 'Species 3', 1200.00, 2, 0.07), (4, 'Species 4', 700.00, 2, 0.02); CREATE TABLE protected_areas (id INT, name VARCHAR(50)); INSERT INTO protected_areas (id, name) VALUES (1, 'Area 1'), (2, 'Area 2');", "reference_sql": "SELECT s.name, s.growth_rate FROM species s INNER JOIN protected_areas pa ON s.protected_area_id = pa.id GROUP BY s.name, s.growth_rate HAVING s.growth_rate > (SELECT AVG(s.growth_rate) FROM species s INNER JOIN protected_areas pa ON s.protected_area_id = pa.id);", "generated_sql": "SELECT s.name\nFROM species s\nWHERE s.growth_rate > (\n  SELECT AVG(s2.growth_rate)\n  FROM species s2\n  WHERE s2.protected_area_id = s.protected_area_id\n);", "raw_model_output": "SELECT s.name\nFROM species s\nWHERE s.growth_rate > (\n  SELECT AVG(s2.growth_rate)\n  FROM species s2\n  WHERE s2.protected_area_id = s.protected_area_id\n);", "latency_sec": 5.112478017807007, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 259, "prompt_eval_sec": null, "tokens_completion": 769, "completion_eval_sec": null, "tokens_total": 1028, "tokens_per_sec": 201.0766591894237, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL compares growth rates to the overall average of all species, while the Generated SQL compares each species' growth rate to the average within its specific protected area. The subquery in the Generated SQL is correlated to the outer query's protected_area_id, leading to different filtering criteria."}
{"example_id": 5498, "sql_complexity": "aggregation", "prompt": "Identify the destinations with the highest number of repeat visitors from the US.", "context": "CREATE TABLE RepeatTravelers (Visitor VARCHAR(20), Destination VARCHAR(20), VisitCount INT); INSERT INTO RepeatTravelers (Visitor, Destination, VisitCount) VALUES ('David', 'Paris', 3), ('Ella', 'London', 4), ('Fiona', 'Paris', 2);", "reference_sql": "SELECT Destination, AVG(VisitCount) AS AvgVisitCount FROM RepeatTravelers WHERE Visitor LIKE '%USA%' GROUP BY Destination ORDER BY AvgVisitCount DESC;", "generated_sql": "SELECT Destination\nFROM RepeatTravelers\nWHERE VisitCount > 1\nGROUP BY Destination\nHAVING COUNT(*) = (\n  SELECT MAX(dest_count)\n  FROM (\n    SELECT COUNT(*) AS dest_count\n    FROM RepeatTravelers\n    WHERE VisitCount > 1\n    GROUP BY Destination\n  ) AS sub\n);", "raw_model_output": "SELECT Destination\nFROM RepeatTravelers\nWHERE VisitCount > 1\nGROUP BY Destination\nHAVING COUNT(*) = (\n  SELECT MAX(dest_count)\n  FROM (\n    SELECT COUNT(*) AS dest_count\n    FROM RepeatTravelers\n    WHERE VisitCount > 1\n    GROUP BY Destination\n  ) AS sub\n);", "latency_sec": 5.930451154708862, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 142, "prompt_eval_sec": null, "tokens_completion": 854, "completion_eval_sec": null, "tokens_total": 996, "tokens_per_sec": 167.94675042710062, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters for visitors from USA (no matching rows) and calculates average visit counts per destination, while the Generated SQL finds destinations with VisitCount > 1 that have the maximum group size (Paris). The Reference query returns no rows, while the Generated query returns 'Paris'."}
{"example_id": 3546, "sql_complexity": "window functions", "prompt": "What are the cryptocurrency exchanges with their corresponding blockchain companies, ranked by exchange ID in ascending order, for the Bitcoin platform?", "context": "CREATE TABLE cryptocurrency_exchanges (exchange_id INT, exchange_name VARCHAR(50), company_id INT); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (1, 'Binance', 1); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (2, 'Coinbase', 2); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (3, 'Kraken', 3); CREATE TABLE blockchain_companies (company_id INT, company_name VARCHAR(50), platform VARCHAR(50)); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (1, 'Binance', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (2, 'Blockstream', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (3, 'Blockchair', 'Bitcoin');", "reference_sql": "SELECT ce.exchange_name, bc.company_name, ce.exchange_id, ROW_NUMBER() OVER (PARTITION BY bc.platform ORDER BY ce.exchange_id ASC) as rank FROM cryptocurrency_exchanges ce JOIN blockchain_companies bc ON ce.company_id = bc.company_id WHERE bc.platform = 'Bitcoin';", "generated_sql": "SELECT\n  ce.exchange_name,\n  bc.company_name\nFROM\n  cryptocurrency_exchanges AS ce\n  JOIN blockchain_companies AS bc\n    ON ce.company_id = bc.company_id\nWHERE\n  bc.platform = 'Bitcoin'\nORDER BY\n  ce.exchange_id ASC;", "raw_model_output": "SELECT\n  ce.exchange_name,\n  bc.company_name\nFROM\n  cryptocurrency_exchanges AS ce\n  JOIN blockchain_companies AS bc\n    ON ce.company_id = bc.company_id\nWHERE\n  bc.platform = 'Bitcoin'\nORDER BY\n  ce.exchange_id ASC;", "latency_sec": 3.4879658222198486, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 284, "prompt_eval_sec": null, "tokens_completion": 460, "completion_eval_sec": null, "tokens_total": 744, "tokens_per_sec": 213.30484239851168, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL includes an additional 'exchange_id' column and a 'rank' column generated by ROW_NUMBER(), while the Generated SQL omits these. Additionally, the Generated SQL includes an ORDER BY clause which is not present in the Reference SQL. These differences in selected columns and ordering logic result in different output structures."}
{"example_id": 486, "sql_complexity": "single join", "prompt": "What is the average price of paintings from African artists in our collection?", "context": "CREATE TABLE Artworks (id INT, title VARCHAR(50), price DECIMAL(10,2), medium VARCHAR(50), artist_nationality VARCHAR(50)); CREATE TABLE Collections (id INT, name VARCHAR(50), continent VARCHAR(50));", "reference_sql": "SELECT AVG(Artworks.price) FROM Artworks INNER JOIN Collections ON Artworks.artist_nationality = Collections.continent WHERE Artworks.medium = 'Painting' AND Collections.continent = 'Africa';", "generated_sql": "SELECT AVG(price) AS average_price\nFROM Artworks\nWHERE medium = 'painting'\n  AND artist_nationality = 'African';", "raw_model_output": "SELECT AVG(price) AS average_price\nFROM Artworks\nWHERE medium = 'painting'\n  AND artist_nationality = 'African';", "latency_sec": 13.861897945404053, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 131, "prompt_eval_sec": null, "tokens_completion": 367, "completion_eval_sec": null, "tokens_total": 498, "tokens_per_sec": 35.925816360891126, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key ways. First, the Reference SQL uses a JOIN with Collections on Artworks.artist_nationality = Collections.continent and filters Collections.continent = 'Africa', which effectively requires Artworks.artist_nationality = 'Africa'. The Generated SQL directly filters Artworks.artist_nationality = 'African' (a different value). Second, the Generated SQL omits the JOIN entirely, which could lead to different results if Collections contains non-matching data. Additionally, the medium filter uses 'Painting' vs 'painting' (case sensitivity may vary)."}
{"example_id": 794, "sql_complexity": "multiple_joins", "prompt": "Which suppliers have provided raw materials for the production of chemicals with high environmental impact?", "context": "CREATE TABLE suppliers (id INT, name TEXT); INSERT INTO suppliers (id, name) VALUES (1, 'Supplier1'), (2, 'Supplier2'), (3, 'Supplier3'); CREATE TABLE chemicals (id INT, name TEXT, environmental_impact INT); INSERT INTO chemicals (id, name, environmental_impact) VALUES (1, 'ChemA', 10), (2, 'ChemB', 20), (3, 'ChemC', 15); CREATE TABLE raw_materials (chemical_id INT, supplier_id INT); INSERT INTO raw_materials (chemical_id, supplier_id) VALUES (1, 1), (1, 2), (2, 3), (3, 1);", "reference_sql": "SELECT s.name FROM suppliers s INNER JOIN raw_materials rm ON s.id = rm.supplier_id INNER JOIN chemicals c ON rm.chemical_id = c.id WHERE c.environmental_impact > 10;", "generated_sql": "SELECT DISTINCT s.name\nFROM suppliers AS s\nJOIN raw_materials AS rm\n  ON rm.supplier_id = s.id\nJOIN chemicals AS c\n  ON rm.chemical_id = c.id\nWHERE c.environmental_impact > 15;", "raw_model_output": "SELECT DISTINCT s.name\nFROM suppliers AS s\nJOIN raw_materials AS rm\n  ON rm.supplier_id = s.id\nJOIN chemicals AS c\n  ON rm.chemical_id = c.id\nWHERE c.environmental_impact > 15;", "latency_sec": 5.49505090713501, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 231, "prompt_eval_sec": null, "tokens_completion": 711, "completion_eval_sec": null, "tokens_total": 942, "tokens_per_sec": 171.4269832836065, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Reference SQL uses WHERE c.environmental_impact > 10 while the Generated SQL uses > 15, filtering different sets of chemicals. Second, the Generated SQL includes DISTINCT which the Reference does not. For example, the Reference would return suppliers linked to chemicals with impact 15 (ChemC) and 20 (ChemB), while the Generated SQL only considers impact >15 (only ChemB). This results in different output sets."}
{"example_id": 3164, "sql_complexity": "set operations", "prompt": "What is the average age of patients who received therapy in 'clinic_a' and 'clinic_b'?", "context": "CREATE TABLE clinic_a (patient_id INT, age INT, therapy_received BOOLEAN); INSERT INTO clinic_a (patient_id, age, therapy_received) VALUES (1, 35, true), (2, 42, true), (3, 28, false); CREATE TABLE clinic_b (patient_id INT, age INT, therapy_received BOOLEAN); INSERT INTO clinic_b (patient_id, age, therapy_received) VALUES (4, 50, true), (5, 32, false), (6, 45, true);", "reference_sql": "SELECT AVG(age) FROM (SELECT age FROM clinic_a WHERE therapy_received = true UNION ALL SELECT age FROM clinic_b WHERE therapy_received = true) AS combined_clinics;", "generated_sql": "SELECT AVG(age) AS average_age\nFROM (\n  SELECT age\n  FROM clinic_a\n  WHERE therapy_received = TRUE\n  UNION ALL\n  SELECT age\n  FROM clinic_b\n  WHERE therapy_received = TRUE\n) AS combined;", "raw_model_output": "SELECT AVG(age) AS average_age\nFROM (\n  SELECT age\n  FROM clinic_a\n  WHERE therapy_received = TRUE\n  UNION ALL\n  SELECT age\n  FROM clinic_b\n  WHERE therapy_received = TRUE\n) AS combined;", "latency_sec": 3.9695498943328857, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 195, "prompt_eval_sec": null, "tokens_completion": 581, "completion_eval_sec": null, "tokens_total": 776, "tokens_per_sec": 195.48815877282553, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average age of patients who received therapy (therapy_received = true) from both clinics. The only differences are the subquery alias names ('combined_clinics' vs 'combined') and the column alias ('average_age' in Generated SQL). These syntactic variations do not affect the result, as the underlying data selection and aggregation logic are identical."}
{"example_id": 3704, "sql_complexity": "aggregation", "prompt": "What is the total sales revenue for each category of garments in the South America region in Q1 2022?", "context": "CREATE TABLE sales_category (sale_id INT, garment_category VARCHAR(50), sale_date DATE, total_sales DECIMAL(10, 2), region VARCHAR(50));", "reference_sql": "SELECT garment_category, SUM(total_sales) FROM sales_category WHERE sale_date BETWEEN '2022-01-01' AND '2022-03-31' AND region = 'South America' GROUP BY garment_category;", "generated_sql": "SELECT\n  garment_category,\n  SUM(total_sales) AS total_sales_revenue\nFROM\n  sales_category\nWHERE\n  region = 'South America'\n  AND sale_date BETWEEN '2022-01-01' AND '2022-03-31'\nGROUP BY\n  garment_category;", "raw_model_output": "SELECT\n  garment_category,\n  SUM(total_sales) AS total_sales_revenue\nFROM\n  sales_category\nWHERE\n  region = 'South America'\n  AND sale_date BETWEEN '2022-01-01' AND '2022-03-31'\nGROUP BY\n  garment_category;", "latency_sec": 2.4937210083007812, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 123, "prompt_eval_sec": null, "tokens_completion": 272, "completion_eval_sec": null, "tokens_total": 395, "tokens_per_sec": 158.39783146758367, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (garment_category and SUM(total_sales)), apply identical WHERE conditions (region = 'South America' and sale_date between '2022-01-01' and '2022-03-31'), and group by the same column (garment_category). The generated query adds an alias for the aggregated column, but this does not affect the semantic result. The order of conditions in the WHERE clause is irrelevant since AND is commutative."}
{"example_id": 2851, "sql_complexity": "single join", "prompt": "How many cases were handled by attorneys who joined the firm in 2015 or later?", "context": "CREATE TABLE attorneys (attorney_id INT, join_year INT); CREATE TABLE cases (case_id INT, attorney_id INT, billing_amount INT);", "reference_sql": "SELECT COUNT(DISTINCT cases.case_id) FROM cases INNER JOIN attorneys ON cases.attorney_id = attorneys.attorney_id WHERE attorneys.join_year >= 2015;", "generated_sql": "SELECT COUNT(*) AS num_cases\nFROM cases c\nJOIN attorneys a ON c.attorney_id = a.attorney_id\nWHERE a.join_year >= 2015;", "raw_model_output": "SELECT COUNT(*) AS num_cases\nFROM cases c\nJOIN attorneys a ON c.attorney_id = a.attorney_id\nWHERE a.join_year >= 2015;", "latency_sec": 2.381869077682495, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 113, "prompt_eval_sec": null, "tokens_completion": 245, "completion_eval_sec": null, "tokens_total": 358, "tokens_per_sec": 150.30213178145203, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of cases linked to attorneys who joined in 2015 or later. The Reference SQL uses COUNT(DISTINCT cases.case_id) while the Generated SQL uses COUNT(*). Since each case is associated with exactly one attorney (due to the foreign key relationship in the schema), there are no duplicate case_ids in the joined result. Thus, COUNT(DISTINCT case_id) and COUNT(*) yield the same result."}
{"example_id": 3246, "sql_complexity": "single join", "prompt": "What is the average eco-friendliness score of accommodations in Oceania by year?", "context": "CREATE TABLE Accommodations (Accommodation_ID INT, Accommodation_Name VARCHAR(50), City VARCHAR(30), Country VARCHAR(50), Eco_Friendliness_Score INT, Visit_Year INT); INSERT INTO Accommodations (Accommodation_ID, Accommodation_Name, City, Country, Eco_Friendliness_Score, Visit_Year) VALUES (1, 'EcoLodge', 'Sydney', 'Australia', 85, 2019), (2, 'GreenHotel', 'Melbourne', 'Australia', 90, 2019), (3, 'SustainableResort', 'Auckland', 'New Zealand', 80, 2019), (4, 'EcoVilla', 'Wellington', 'New Zealand', 88, 2019); CREATE TABLE Countries (Country VARCHAR(50), Continent VARCHAR(30)); INSERT INTO Countries (Country, Continent) VALUES ('Australia', 'Oceania'), ('New Zealand', 'Oceania');", "reference_sql": "SELECT C.Continent, V.Visit_Year, AVG(A.Eco_Friendliness_Score) AS Avg_Eco_Score  FROM Accommodations A  JOIN Countries C  ON A.Country = C.Country  WHERE C.Continent = 'Oceania'  GROUP BY C.Continent, V.Visit_Year  ORDER BY V.Visit_Year;", "generated_sql": "SELECT \n  a.Visit_Year, \n  AVG(a.Eco_Friendliness_Score) AS average_score\nFROM Accommodations AS a\nJOIN Countries AS c\n  ON a.Country = c.Country\nWHERE c.Continent = 'Oceania'\nGROUP BY a.Visit_Year;", "raw_model_output": "SELECT \n  a.Visit_Year, \n  AVG(a.Eco_Friendliness_Score) AS average_score\nFROM Accommodations AS a\nJOIN Countries AS c\n  ON a.Country = c.Country\nWHERE c.Continent = 'Oceania'\nGROUP BY a.Visit_Year;", "latency_sec": 2.317950963973999, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 280, "prompt_eval_sec": null, "tokens_completion": 209, "completion_eval_sec": null, "tokens_total": 489, "tokens_per_sec": 210.962184964274, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes 'Continent' in both the SELECT and GROUP BY clauses, while the Generated SQL omits it. Although the WHERE clause filters to 'Oceania' (making Continent constant), the output structure differs: Reference includes Continent, Visit_Year, and Avg_Eco_Score, while Generated only includes Visit_Year and average_score. This difference in result columns makes them non-equivalent."}
{"example_id": 3056, "sql_complexity": "multiple_joins", "prompt": "Identify all suppliers who provide non-GMO ingredients to restaurants with Michelin stars.", "context": "CREATE TABLE Suppliers (id INT, name VARCHAR(50), isNonGMO BOOLEAN); CREATE TABLE Restaurants (id INT, name VARCHAR(50), numStars INT); CREATE TABLE Ingredients (supplierId INT, restaurantId INT, isNonGMO BOOLEAN);", "reference_sql": "SELECT Suppliers.name FROM Suppliers INNER JOIN Ingredients ON Suppliers.id = Ingredients.supplierId INNER JOIN Restaurants ON Ingredients.restaurantId = Restaurants.id WHERE Restaurants.numStars > 2 AND Ingredients.isNonGMO = TRUE;", "generated_sql": "SELECT DISTINCT s.id, s.name\nFROM Suppliers AS s\nJOIN Ingredients AS i\n  ON s.id = i.supplierId\nJOIN Restaurants AS r\n  ON i.restaurantId = r.id\nWHERE i.isNonGMO = TRUE\n  AND r.numStars > 0;", "raw_model_output": "SELECT DISTINCT s.id, s.name\nFROM Suppliers AS s\nJOIN Ingredients AS i\n  ON s.id = i.supplierId\nJOIN Restaurants AS r\n  ON i.restaurantId = r.id\nWHERE i.isNonGMO = TRUE\n  AND r.numStars > 0;", "latency_sec": 2.31520414352417, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 133, "prompt_eval_sec": null, "tokens_completion": 271, "completion_eval_sec": null, "tokens_total": 404, "tokens_per_sec": 174.49865107145027, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in three key aspects: 1) The Reference SQL selects only 'Suppliers.name' while the Generated SQL selects 's.id' and 's.name' (different column sets). 2) The WHERE clause in the Reference uses 'Restaurants.numStars > 2' whereas the Generated uses 'r.numStars > 0' (different filtering thresholds). 3) The Generated SQL includes 'DISTINCT' which could eliminate duplicates not present in the Reference SQL. These differences ensure they do not produce identical results."}
{"example_id": 264, "sql_complexity": "set operations", "prompt": "List the number of community health centers and infectious disease tracking facilities in 'southwest' regions.", "context": "CREATE TABLE centers (id INT, name TEXT, region TEXT); INSERT INTO centers (id, name, region) VALUES (1, 'Center A', 'southwest'); INSERT INTO centers (id, name, region) VALUES (2, 'Center B', 'northeast'); INSERT INTO centers (id, name, region) VALUES (3, 'Center C', 'northwest'); CREATE TABLE diseases (id INT, name TEXT, region TEXT); INSERT INTO diseases (id, name, region) VALUES (1, 'Disease A', 'southwest'); INSERT INTO diseases (id, name, region) VALUES (2, 'Disease B', 'southeast');", "reference_sql": "SELECT COUNT(*) FROM ( (SELECT * FROM centers WHERE region = 'southwest') UNION (SELECT * FROM diseases WHERE region = 'southwest') );", "generated_sql": "SELECT\n  (SELECT COUNT(*) FROM centers WHERE region = 'southwest') AS num_centers,\n  (SELECT COUNT(*) FROM diseases WHERE region = 'southwest') AS num_diseases;", "raw_model_output": "SELECT\n  (SELECT COUNT(*) FROM centers WHERE region = 'southwest') AS num_centers,\n  (SELECT COUNT(*) FROM diseases WHERE region = 'southwest') AS num_diseases;", "latency_sec": 3.4353480339050293, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 223, "prompt_eval_sec": null, "tokens_completion": 508, "completion_eval_sec": null, "tokens_total": 731, "tokens_per_sec": 212.78775622889586, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL counts the total number of rows from both tables combined after removing duplicates (due to UNION), while the Generated SQL returns separate counts for each table. For the given data, Reference SQL would return 2 (Center A and Disease A), and Generated SQL would return 1 and 1. The result structures and values differ."}
{"example_id": 2838, "sql_complexity": "basic SQL", "prompt": "What is the minimum safety rating of electric vehicles in the 'green_cars' table?", "context": "CREATE TABLE green_cars (id INT, make VARCHAR(50), model VARCHAR(50), type VARCHAR(50), safety_rating INT);", "reference_sql": "SELECT MIN(safety_rating) FROM green_cars WHERE type = 'Electric';", "generated_sql": "SELECT MIN(safety_rating) AS min_safety_rating\nFROM green_cars\nWHERE type = 'electric';", "raw_model_output": "SELECT MIN(safety_rating) AS min_safety_rating\nFROM green_cars\nWHERE type = 'electric';", "latency_sec": 2.9316279888153076, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 112, "prompt_eval_sec": null, "tokens_completion": 170, "completion_eval_sec": null, "tokens_total": 282, "tokens_per_sec": 96.19228670072776, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the minimum safety_rating from green_cars where type matches a specific value. The difference in string case ('Electric' vs 'electric') is typically case-insensitive in SQL comparisons, and the column alias in the generated query does not affect the result's content."}
{"example_id": 1187, "sql_complexity": "multiple_joins", "prompt": "Who are the top 3 authors with the highest number of articles published in The Guardian?", "context": "CREATE TABLE authors (id INT, name VARCHAR(100), publisher VARCHAR(50)); CREATE TABLE articles_authors (article_id INT, author_id INT); INSERT INTO authors (id, name, publisher) VALUES (1, 'Author1', 'The Guardian'), (2, 'Author2', 'The Guardian'), (3, 'Author3', 'The Guardian'); INSERT INTO articles_authors (article_id, author_id) VALUES (1, 1), (2, 2), (3, 1), (3, 2), (3, 3); INSERT INTO articles (id, title, publication_date, publisher) VALUES (1, 'Article1', '2021-01-01', 'The Guardian'), (2, 'Article2', '2021-01-02', 'The Guardian'), (3, 'Article3', '2021-01-03', 'The Guardian');", "reference_sql": "SELECT a.name, COUNT(aa.article_id) AS articles_count FROM authors a JOIN articles_authors aa ON a.id = aa.author_id JOIN articles ar ON aa.article_id = ar.id WHERE ar.publisher = 'The Guardian' GROUP BY a.name ORDER BY articles_count DESC LIMIT 3;", "generated_sql": "SELECT a.name AS author_name,\n       COUNT(ar.id) AS article_count\nFROM authors a\nJOIN articles_authors aa\n  ON a.id = aa.author_id\nJOIN articles ar\n  ON aa.article_id = ar.id\nWHERE ar.publisher = 'The Guardian'\nGROUP BY a.name\nORDER BY article_count DESC\nFETCH FIRST 3 ROWS ONLY;", "raw_model_output": "SELECT a.name AS author_name,\n       COUNT(ar.id) AS article_count\nFROM authors a\nJOIN articles_authors aa\n  ON a.id = aa.author_id\nJOIN articles ar\n  ON aa.article_id = ar.id\nWHERE ar.publisher = 'The Guardian'\nGROUP BY a.name\nORDER BY article_count DESC\nFETCH FIRST 3 ROWS ONLY;", "latency_sec": 3.5021300315856934, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 273, "prompt_eval_sec": null, "tokens_completion": 414, "completion_eval_sec": null, "tokens_total": 687, "tokens_per_sec": 196.16633129094305, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same data by joining authors with articles through articles_authors, filtering by 'The Guardian' publisher. They count articles per author, group by author name, order by article count descending, and limit to 3 results. The differences are syntactic (COUNT column alias names, LIMIT vs FETCH FIRST) but do not affect the result."}
{"example_id": 360, "sql_complexity": "window functions", "prompt": "What is the change in crime rate for each category, between this year and last year, for the same time period?", "context": "CREATE TABLE CrimeStatistics (ID INT, CrimeType VARCHAR(50), Date TIMESTAMP, Count INT); INSERT INTO CrimeStatistics (ID, CrimeType, Date, Count) VALUES (1, 'Theft', '2022-01-01 00:00:00', 100), (2, 'Vandalism', '2022-01-01 00:00:00', 50), (3, 'Theft', '2022-01-02 00:00:00', 120), (4, 'Vandalism', '2022-01-02 00:00:00', 60), (5, 'Theft', '2021-01-01 00:00:00', 80), (6, 'Vandalism', '2021-01-01 00:00:00', 40), (7, 'Theft', '2021-01-02 00:00:00', 90), (8, 'Vandalism', '2021-01-02 00:00:00', 45);", "reference_sql": "SELECT CrimeType, (SUM(Count) OVER (PARTITION BY CrimeType ORDER BY EXTRACT(YEAR FROM Date) ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)) - SUM(Count) OVER (PARTITION BY CrimeType ORDER BY EXTRACT(YEAR FROM Date)) AS CrimeRateChange FROM CrimeStatistics WHERE Date BETWEEN DATE_TRUNC('year', CURRENT_DATE - INTERVAL '1 year') AND CURRENT_DATE;", "generated_sql": "SELECT MAX(EXTRACT(YEAR FROM Date)) AS yr\n  FROM CrimeStatistics\n)\nSELECT\n  curr.CrimeType,\n  SUM(curr.Count) - SUM(prev.Count) AS change\nFROM CrimeStatistics AS curr\nJOIN CrimeStatistics AS prev\n  ON curr.CrimeType = prev.CrimeType\n  AND curr.Date = prev.Date + INTERVAL '1' YEAR\nWHERE EXTRACT(YEAR FROM curr.Date) = (SELECT yr FROM LatestYear)\nGROUP BY curr.CrimeType;", "raw_model_output": "WITH LatestYear AS (\n  SELECT MAX(EXTRACT(YEAR FROM Date)) AS yr\n  FROM CrimeStatistics\n)\nSELECT\n  curr.CrimeType,\n  SUM(curr.Count) - SUM(prev.Count) AS change\nFROM CrimeStatistics AS curr\nJOIN CrimeStatistics AS prev\n  ON curr.CrimeType = prev.CrimeType\n  AND curr.Date = prev.Date + INTERVAL '1' YEAR\nWHERE EXTRACT(YEAR FROM curr.Date) = (SELECT yr FROM LatestYear)\nGROUP BY curr.CrimeType;", "latency_sec": 16.39559006690979, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 322, "prompt_eval_sec": null, "tokens_completion": 2435, "completion_eval_sec": null, "tokens_total": 2757, "tokens_per_sec": 168.1549726938028, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL uses window functions to calculate a cumulative sum difference across years, while the Generated SQL performs a direct self-join to compare exact year-over-year counts. The Reference SQL's window frame (ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING) only references the immediate previous year, but the WHERE clause filters dates between the previous year and current date, potentially including multiple years. The Generated SQL explicitly joins on exact date offsets and filters for the latest year, leading to different result sets."}
{"example_id": 335, "sql_complexity": "single join", "prompt": "List the policy numbers, claim amounts, and claim dates for policies that have more than two claims and the total claim amount exceeds $5000", "context": "CREATE TABLE policies (policy_number INT);CREATE TABLE claims (claim_id INT, policy_number INT, claim_amount DECIMAL(10,2), claim_date DATE);", "reference_sql": "SELECT p.policy_number, c.claim_amount, c.claim_date FROM policies p INNER JOIN claims c ON p.policy_number = c.policy_number GROUP BY p.policy_number, c.claim_amount, c.claim_date HAVING COUNT(c.claim_id) > 2 AND SUM(c.claim_amount) > 5000;", "generated_sql": "SELECT c.policy_number,\n       c.claim_amount,\n       c.claim_date\nFROM claims c\nJOIN (\n  SELECT policy_number\n  FROM claims\n  GROUP BY policy_number\n  HAVING COUNT(*) > 2\n     AND SUM(claim_amount) > 5000\n) qualified_policies\n  ON c.policy_number = qualified_policies.policy_number;", "raw_model_output": "SELECT c.policy_number,\n       c.claim_amount,\n       c.claim_date\nFROM claims c\nJOIN (\n  SELECT policy_number\n  FROM claims\n  GROUP BY policy_number\n  HAVING COUNT(*) > 2\n     AND SUM(claim_amount) > 5000\n) qualified_policies\n  ON c.policy_number = qualified_policies.policy_number;", "latency_sec": 4.545693874359131, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 128, "prompt_eval_sec": null, "tokens_completion": 349, "completion_eval_sec": null, "tokens_total": 477, "tokens_per_sec": 104.9344749523524, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their grouping and filtering logic. The reference query groups by policy_number, claim_amount, and claim_date, requiring each specific (policy, amount, date) combination to have >2 claims and sum >5000. The generated query first filters policies with >2 total claims and sum >5000 (grouped by policy_number only), then retrieves all claims for those policies. This means the generated query returns all claims for qualifying policies, while the reference query only returns claims that belong to groups meeting the criteria for their specific (policy, amount, date) combination."}
{"example_id": 2866, "sql_complexity": "basic SQL", "prompt": "What is the number of hospitals in 'rural_healthcare' table?", "context": "CREATE TABLE rural_healthcare (name VARCHAR(255), type VARCHAR(255), location VARCHAR(255)); INSERT INTO rural_healthcare (name, type, location) VALUES ('Rural General Hospital', 'Hospital', 'Bushland'), ('Rural Community Hospital', 'Hospital', 'Forest Region');", "reference_sql": "SELECT COUNT(*) FROM rural_healthcare WHERE type = 'Hospital';", "generated_sql": "SELECT COUNT(*) AS number_of_hospitals\nFROM rural_healthcare\nWHERE type = 'Hospital';", "raw_model_output": "SELECT COUNT(*) AS number_of_hospitals\nFROM rural_healthcare\nWHERE type = 'Hospital';", "latency_sec": 2.2540578842163086, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 141, "prompt_eval_sec": null, "tokens_completion": 168, "completion_eval_sec": null, "tokens_total": 309, "tokens_per_sec": 137.08609799407756, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries count the number of rows where type = 'Hospital'. The generated query adds an alias (number_of_hospitals) to the COUNT(*) result, but this does not affect the semantic result. The core logic and output value remain identical."}
{"example_id": 4440, "sql_complexity": "multiple_joins", "prompt": "What is the average session length for each game genre in the last month, sorted by average session length.", "context": "CREATE TABLE game_sessions(id INT, user_id INT, game_name VARCHAR(50), start_time DATETIME, end_time DATETIME); CREATE TABLE games(id INT, name VARCHAR(50), genre VARCHAR(50));", "reference_sql": "SELECT genres.genre, AVG(TIMESTAMPDIFF(SECOND, start_time, end_time)) as avg_session_length FROM game_sessions JOIN games ON game_sessions.game_name = games.name JOIN (SELECT DISTINCT game_name, genre FROM game_sessions JOIN games ON game_sessions.game_name = games.name) genres ON games.name = genres.game_name WHERE start_time >= DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH) GROUP BY genres.genre ORDER BY avg_session_length DESC;", "generated_sql": "SELECT\n    g.genre,\n    AVG(EXTRACT(EPOCH FROM gs.end_time) - EXTRACT(EPOCH FROM gs.start_time)) AS avg_session_length_seconds\nFROM game_sessions gs\nJOIN games g\n  ON gs.game_name = g.name\nWHERE gs.start_time >= CURRENT_DATE - INTERVAL '1' MONTH\nGROUP BY g.genre\nORDER BY avg_session_length_seconds;", "raw_model_output": "SELECT\n    g.genre,\n    AVG(EXTRACT(EPOCH FROM gs.end_time) - EXTRACT(EPOCH FROM gs.start_time)) AS avg_session_length_seconds\nFROM game_sessions gs\nJOIN games g\n  ON gs.game_name = g.name\nWHERE gs.start_time >= CURRENT_DATE - INTERVAL '1' MONTH\nGROUP BY g.genre\nORDER BY avg_session_length_seconds;", "latency_sec": 10.80175518989563, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 130, "prompt_eval_sec": null, "tokens_completion": 1441, "completion_eval_sec": null, "tokens_total": 1571, "tokens_per_sec": 145.43932651515493, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes an unnecessary subquery and additional join that could alter results. The subquery (SELECT DISTINCT game_name, genre ...) and subsequent join on games.name = genres.game_name introduces redundancy and potential data duplication, which may affect aggregation. The Generated SQL directly joins tables and calculates averages without this complexity. While both calculate average session length by genre, the Reference SQL's structure could produce different results due to redundant joins and distinct handling."}
{"example_id": 451, "sql_complexity": "single join", "prompt": "Which customers have made a transaction over 500 in the \"risk_management\" category?", "context": "CREATE TABLE customers (id INT, name VARCHAR(50), category VARCHAR(50)); INSERT INTO customers (id, name, category) VALUES (1, 'John Doe', 'risk_management'); INSERT INTO customers (id, name, category) VALUES (2, 'Jane Smith', 'compliance'); INSERT INTO customers (id, name, category) VALUES (3, 'Jim Brown', 'risk_management'); CREATE TABLE transactions (id INT, customer_id INT, amount DECIMAL(10, 2)); INSERT INTO transactions (id, customer_id, amount) VALUES (1, 1, 500.00); INSERT INTO transactions (id, customer_id, amount) VALUES (2, 1, 200.00); INSERT INTO transactions (id, customer_id, amount) VALUES (3, 2, 100.00); INSERT INTO transactions (id, customer_id, amount) VALUES (4, 3, 750.00);", "reference_sql": "SELECT c.name FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE c.category = 'risk_management' AND t.amount > 500;", "generated_sql": "SELECT DISTINCT c.id, c.name\nFROM customers c\nJOIN transactions t\n  ON c.id = t.customer_id\nWHERE c.category = 'risk_management'\n  AND t.amount > 500;", "raw_model_output": "SELECT DISTINCT c.id, c.name\nFROM customers c\nJOIN transactions t\n  ON c.id = t.customer_id\nWHERE c.category = 'risk_management'\n  AND t.amount > 500;", "latency_sec": 2.7837977409362793, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 278, "prompt_eval_sec": null, "tokens_completion": 316, "completion_eval_sec": null, "tokens_total": 594, "tokens_per_sec": 213.37757095823312, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects only 'name' from customers, while the Generated SQL selects 'id' and 'name' with a DISTINCT clause. Although both filter customers in the 'risk_management' category with transactions over 500, the Generated SQL returns additional columns and enforces uniqueness, which could alter the result set structure and content in different scenarios. In this specific data, both return 'Jim Brown', but the differences in output columns and DISTINCT make them non-equivalent in general."}
{"example_id": 2879, "sql_complexity": "basic SQL", "prompt": "Update the FoodSafetyRecords.OrganicFarms table to include a new record for a certified organic farm in Kenya.", "context": "CREATE TABLE FoodSafetyRecords.OrganicFarms (farmName TEXT, country TEXT, certified BOOLEAN);", "reference_sql": "INSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('Ngong Organic Farm', 'Kenya', TRUE);", "generated_sql": "INSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified)\nVALUES ('Kenya Organic Farm', 'Kenya', TRUE);", "raw_model_output": "```sql\nINSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified)\nVALUES ('Kenya Organic Farm', 'Kenya', TRUE);\n```", "latency_sec": 2.6622190475463867, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 109, "prompt_eval_sec": null, "tokens_completion": 245, "completion_eval_sec": null, "tokens_total": 354, "tokens_per_sec": 132.97177793324758, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The two queries differ in the farmName value inserted. The reference inserts 'Ngong Organic Farm' while the generated query inserts 'Kenya Organic Farm'. Although the structure and other values (country and certified) are identical, the distinct farmName results in different data being inserted, making them semantically non-equivalent."}
{"example_id": 5688, "sql_complexity": "single join", "prompt": "What is the total amount donated to a specific cause?", "context": "CREATE TABLE causes (id INT, name TEXT); CREATE TABLE donations (id INT, donor_id INT, cause_id INT, donation_amount DECIMAL(10,2)); INSERT INTO causes (id, name) VALUES (1, 'Cause A'), (2, 'Cause B'); INSERT INTO donations (id, donor_id, cause_id, donation_amount) VALUES (1, 1, 1, 50.00), (2, 2, 1, 100.00);", "reference_sql": "SELECT SUM(donation_amount) FROM donations JOIN causes ON donations.cause_id = causes.id WHERE causes.name = 'Cause A';", "generated_sql": "SELECT \n  COALESCE(SUM(donation_amount), 0) AS total_amount\nFROM \n  donations\nWHERE \n  cause_id = :cause_id;", "raw_model_output": "```sql\nSELECT \n  COALESCE(SUM(donation_amount), 0) AS total_amount\nFROM \n  donations\nWHERE \n  cause_id = :cause_id;\n```", "latency_sec": 3.147599220275879, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 178, "prompt_eval_sec": null, "tokens_completion": 313, "completion_eval_sec": null, "tokens_total": 491, "tokens_per_sec": 155.99190546151078, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Reference SQL uses a JOIN with a WHERE condition on causes.name='Cause A', while the Generated SQL directly filters on cause_id=:cause_id. Second, the Generated SQL uses COALESCE to return 0 instead of NULL when no donations exist. Although they might produce the same result for specific parameter values (e.g., :cause_id=1), they are not universally equivalent due to different handling of missing data and different filtering approaches."}
{"example_id": 3273, "sql_complexity": "multiple_joins", "prompt": "List all departments, the number of chemicals they handle, and the number of machines used in their manufacturing processes.", "context": "CREATE TABLE Departments (DepartmentID INT, DepartmentName VARCHAR(20)); INSERT INTO Departments (DepartmentID, DepartmentName) VALUES (1, 'Manufacturing'), (2, 'Engineering'), (3, 'Chemical Safety'), (4, 'Product Development'); CREATE TABLE Chemicals (ChemicalID INT, ChemicalName VARCHAR(20), DepartmentID INT); INSERT INTO Chemicals (ChemicalID, ChemicalName, DepartmentID) VALUES (1, 'Hydrochloric Acid', 1), (2, 'Nitric Acid', 2), (3, 'Sodium Hydroxide', 3), (4, 'New Chemical', 4); CREATE TABLE Machinery (MachineID INT, MachineName VARCHAR(20), DepartmentID INT); INSERT INTO Machinery (MachineID, MachineName, DepartmentID) VALUES (1, 'Mixer 1', 1), (2, 'Cutter 2', 2), (3, 'Dispenser 3', 3), (4, 'Innovator 4', 4);", "reference_sql": "SELECT D.DepartmentName, COUNT(C.ChemicalID) AS ChemicalCount, COUNT(M.MachineID) AS MachineCount FROM Departments D LEFT JOIN Chemicals C ON D.DepartmentID = C.DepartmentID LEFT JOIN Machinery M ON D.DepartmentID = M.DepartmentID GROUP BY D.DepartmentName;", "generated_sql": "SELECT \n  d.DepartmentName,\n  (SELECT COUNT(*) \n   FROM Chemicals c \n   WHERE c.DepartmentID = d.DepartmentID\n  ) AS ChemicalCount,\n  (SELECT COUNT(*) \n   FROM Machinery m \n   WHERE m.DepartmentID = d.DepartmentID\n  ) AS MachineCount\nFROM Departments d;", "raw_model_output": "SELECT \n  d.DepartmentName,\n  (SELECT COUNT(*) \n   FROM Chemicals c \n   WHERE c.DepartmentID = d.DepartmentID\n  ) AS ChemicalCount,\n  (SELECT COUNT(*) \n   FROM Machinery m \n   WHERE m.DepartmentID = d.DepartmentID\n  ) AS MachineCount\nFROM Departments d;", "latency_sec": 5.540067911148071, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 298, "prompt_eval_sec": null, "tokens_completion": 788, "completion_eval_sec": null, "tokens_total": 1086, "tokens_per_sec": 196.0264779091756, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries produce the same result by calculating the number of chemicals and machinery per department. The Reference SQL uses LEFT JOINs with aggregation, while the Generated SQL uses correlated subqueries. Both approaches correctly count related records for each department, including departments with zero entries in either table."}
{"example_id": 1895, "sql_complexity": "window functions", "prompt": "What is the average safety score of chemical production sites in the United States, partitioned by state and ranked in descending order?", "context": "CREATE TABLE production_sites (site_id INT, site_name TEXT, country TEXT, state TEXT, safety_score FLOAT); INSERT INTO production_sites (site_id, site_name, country, state, safety_score) VALUES (1, 'Site A', 'USA', 'NY', 92.5), (2, 'Site B', 'USA', 'CA', 87.4), (3, 'Site C', 'USA', 'TX', 95.3), (4, 'Site D', 'USA', 'FL', 89.2);", "reference_sql": "SELECT state, AVG(safety_score) as avg_safety_score, ROW_NUMBER() OVER (ORDER BY AVG(safety_score) DESC) as rank FROM production_sites WHERE country = 'USA' GROUP BY state ORDER BY rank;", "generated_sql": "SELECT \n  state, \n  AVG(safety_score) AS avg_safety_score,\n  RANK() OVER (ORDER BY AVG(safety_score) DESC) AS state_rank\nFROM production_sites\nWHERE country = 'USA'\nGROUP BY state\nORDER BY avg_safety_score DESC;", "raw_model_output": "SELECT \n  state, \n  AVG(safety_score) AS avg_safety_score,\n  RANK() OVER (ORDER BY AVG(safety_score) DESC) AS state_rank\nFROM production_sites\nWHERE country = 'USA'\nGROUP BY state\nORDER BY avg_safety_score DESC;", "latency_sec": 4.5872039794921875, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 205, "prompt_eval_sec": null, "tokens_completion": 654, "completion_eval_sec": null, "tokens_total": 859, "tokens_per_sec": 187.26003985004672, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their ranking functions: ROW_NUMBER() (Reference) vs RANK() (Generated). ROW_NUMBER() assigns unique, sequential ranks without gaps, while RANK() allows gaps when there are ties. Although the sample data has unique safety scores (no ties), the queries would produce different results if ties existed. Additionally, the Reference query orders by 'rank' (which is the row number) while the Generated query orders by avg_safety_score DESC. While the final order might appear similar in this specific case, the ranking logic and ordering mechanisms are fundamentally different, making them non-equivalent in general."}
{"example_id": 4669, "sql_complexity": "set operations", "prompt": "Identify the number of IoT devices in each country and the total number of devices.", "context": "CREATE TABLE device_country (device_id INT, country TEXT); INSERT INTO device_country (device_id, country) VALUES (1, 'USA'), (2, 'Canada'), (3, 'Mexico'), (4, 'Brazil'); CREATE TABLE device_info (device_id INT, device_type TEXT); INSERT INTO device_info (device_id, device_type) VALUES (1, 'Soil Sensor'), (2, 'Temperature Sensor'), (3, 'Humidity Sensor'), (4, 'Precision Sprayer');", "reference_sql": "SELECT country, COUNT(*) AS device_count FROM device_country GROUP BY country UNION SELECT 'Total' AS country, COUNT(*) FROM device_country;", "generated_sql": "SELECT dc.country,\n       COUNT(*) AS device_count\nFROM device_country dc\nJOIN device_info di\n  ON dc.device_id = di.device_id\nGROUP BY dc.country\n\nUNION ALL\n\nSELECT 'Total' AS country,\n       COUNT(*) AS device_count\nFROM device_country dc\nJOIN device_info di\n  ON dc.device_id = di.device_id;", "raw_model_output": "SELECT dc.country,\n       COUNT(*) AS device_count\nFROM device_country dc\nJOIN device_info di\n  ON dc.device_id = di.device_id\nGROUP BY dc.country\n\nUNION ALL\n\nSELECT 'Total' AS country,\n       COUNT(*) AS device_count\nFROM device_country dc\nJOIN device_info di\n  ON dc.device_id = di.device_id;", "latency_sec": 5.740640878677368, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 185, "prompt_eval_sec": null, "tokens_completion": 734, "completion_eval_sec": null, "tokens_total": 919, "tokens_per_sec": 160.08665572749356, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL counts devices directly from the device_country table, while the Generated SQL joins device_country with device_info. Although the data currently has 1:1 relationships, the JOIN introduces a dependency on device_info. This would produce different results if device_country had entries without corresponding device_info records. Additionally, the Generated SQL uses UNION ALL instead of UNION, which could affect output uniqueness but the core discrepancy lies in the JOIN affecting the count."}
{"example_id": 5302, "sql_complexity": "multiple_joins", "prompt": "Find the supplier with the lowest average delivery time for orders in the last month.", "context": "CREATE TABLE Suppliers (SupplierID int, SupplierName varchar(50)); CREATE TABLE Products (ProductID int, ProductName varchar(50), SupplierID int); CREATE TABLE Orders (OrderID int, ProductID int, OrderDate date, DeliveryTime int); INSERT INTO Suppliers VALUES (1, 'SupplierA'), (2, 'SupplierB'); INSERT INTO Products VALUES (1, 'Organic Apples', 1), (2, 'Bananas', 2); INSERT INTO Orders VALUES (1, 1, '2022-01-01', 2), (2, 2, '2022-01-03', 3);", "reference_sql": "SELECT SupplierName, AVG(DeliveryTime) as AvgDeliveryTime FROM Orders o JOIN Products p ON o.ProductID = p.ProductID JOIN Suppliers sp ON p.SupplierID = sp.SupplierID WHERE OrderDate >= DATEADD(month, -1, GETDATE()) GROUP BY SupplierName ORDER BY AvgDeliveryTime ASC;", "generated_sql": "SELECT s.SupplierName, \n       AVG(o.DeliveryTime) AS AvgDeliveryTime\nFROM Suppliers s\nJOIN Products p\n  ON s.SupplierID = p.SupplierID\nJOIN Orders o\n  ON p.ProductID = o.ProductID\nWHERE o.OrderDate >= CURRENT_DATE - INTERVAL '1' MONTH\nGROUP BY s.SupplierName\nORDER BY AVG(o.DeliveryTime)\nFETCH FIRST 1 ROW ONLY;", "raw_model_output": "SELECT s.SupplierName, \n       AVG(o.DeliveryTime) AS AvgDeliveryTime\nFROM Suppliers s\nJOIN Products p\n  ON s.SupplierID = p.SupplierID\nJOIN Orders o\n  ON p.ProductID = o.ProductID\nWHERE o.OrderDate >= CURRENT_DATE - INTERVAL '1' MONTH\nGROUP BY s.SupplierName\nORDER BY AVG(o.DeliveryTime)\nFETCH FIRST 1 ROW ONLY;", "latency_sec": 4.92103910446167, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 214, "prompt_eval_sec": null, "tokens_completion": 617, "completion_eval_sec": null, "tokens_total": 831, "tokens_per_sec": 168.86677434580272, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. 1) The Generated SQL includes a 'FETCH FIRST 1 ROW ONLY' clause, which limits the result to a single row, while the Reference SQL does not have this restriction. 2) The date calculation syntax differs (DATEADD vs CURRENT_DATE - INTERVAL), but this is likely functionally equivalent. The presence of the FETCH clause makes the queries non-equivalent as they would return different numbers of rows."}
{"example_id": 267, "sql_complexity": "subqueries", "prompt": "What is the total number of disability support programs offered in urban and rural areas, and the percentage of total programs for each area type?", "context": "CREATE TABLE programs (program_id INT, program_name VARCHAR(255), area_type VARCHAR(255));", "reference_sql": "SELECT area_type, COUNT(*) as total_programs, ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM programs) , 2) as percentage_of_total FROM programs WHERE area_type IN ('urban', 'rural') GROUP BY area_type;", "generated_sql": "SELECT\n  area_type,\n  COUNT(*) AS total_programs,\n  ROUND(\n    COUNT(*) * 100.0\n    / SUM(COUNT(*)) OVER (),\n    2\n  ) AS percentage_of_total\nFROM programs\nWHERE area_type IN ('urban', 'rural')\n  AND program_name LIKE '%Disability Support%'\nGROUP BY area_type;", "raw_model_output": "SELECT\n  area_type,\n  COUNT(*) AS total_programs,\n  ROUND(\n    COUNT(*) * 100.0\n    / SUM(COUNT(*)) OVER (),\n    2\n  ) AS percentage_of_total\nFROM programs\nWHERE area_type IN ('urban', 'rural')\n  AND program_name LIKE '%Disability Support%'\nGROUP BY area_type;", "latency_sec": 15.439198017120361, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 113, "prompt_eval_sec": null, "tokens_completion": 862, "completion_eval_sec": null, "tokens_total": 975, "tokens_per_sec": 63.15094857380759, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The generated query adds an extra filter 'program_name LIKE '%Disability Support%'' which is not present in the reference query. This would significantly change the result set by only counting programs with 'Disability Support' in their name, whereas the reference query counts all programs in 'urban' and 'rural' area types regardless of program name."}
{"example_id": 3028, "sql_complexity": "basic SQL", "prompt": "What is the number of startups founded by non-binary individuals in the technology industry?", "context": "CREATE TABLE company (id INT, name TEXT, founder_gender TEXT, industry TEXT); INSERT INTO company (id, name, founder_gender, industry) VALUES (1, 'CodeForAll', 'Non-binary', 'Technology'); INSERT INTO company (id, name, founder_gender, industry) VALUES (2, 'TechVillage', 'Male', 'Technology');", "reference_sql": "SELECT COUNT(*) FROM company WHERE founder_gender = 'Non-binary' AND industry = 'Technology';", "generated_sql": "SELECT COUNT(*) AS non_binary_tech_startups\nFROM company\nWHERE founder_gender = 'Non-binary'\n  AND industry = 'Technology';", "raw_model_output": "SELECT COUNT(*) AS non_binary_tech_startups\nFROM company\nWHERE founder_gender = 'Non-binary'\n  AND industry = 'Technology';", "latency_sec": 2.2280287742614746, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 157, "prompt_eval_sec": null, "tokens_completion": 177, "completion_eval_sec": null, "tokens_total": 334, "tokens_per_sec": 149.90829735164039, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries count the number of companies where founder_gender is 'Non-binary' and industry is 'Technology'. The generated query adds an alias 'non_binary_tech_startups' to the result, but this does not affect the semantic result set. The WHERE conditions and aggregate function remain identical."}
{"example_id": 3282, "sql_complexity": "aggregation", "prompt": "Which marine species have been observed in both the Arctic and Antarctic oceans?", "context": "CREATE TABLE marine_species (id INT, species_name VARCHAR(50), common_name VARCHAR(50), region VARCHAR(20));INSERT INTO marine_species (id, species_name, common_name, region) VALUES (1, 'Orcinus_orca', 'Killer Whale', 'Arctic');INSERT INTO marine_species (id, species_name, common_name, region) VALUES (2, 'Balaenoptera_bonaerensis', 'Antarctic Minke Whale', 'Antarctic');", "reference_sql": "SELECT species_name FROM marine_species WHERE region IN ('Arctic', 'Antarctic') GROUP BY species_name HAVING COUNT(DISTINCT region) = 2;", "generated_sql": "SELECT species_name,\n       common_name\nFROM marine_species\nWHERE region IN ('Arctic','Antarctic')\nGROUP BY species_name,\n         common_name\nHAVING COUNT(DISTINCT region) = 2;", "raw_model_output": "SELECT species_name,\n       common_name\nFROM marine_species\nWHERE region IN ('Arctic','Antarctic')\nGROUP BY species_name,\n         common_name\nHAVING COUNT(DISTINCT region) = 2;", "latency_sec": 3.5877366065979004, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 183, "prompt_eval_sec": null, "tokens_completion": 319, "completion_eval_sec": null, "tokens_total": 502, "tokens_per_sec": 139.92108536530097, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their GROUP BY clauses. The reference query groups only by 'species_name', while the generated query groups by both 'species_name' and 'common_name'. This affects the HAVING condition: the generated query requires that each (species_name, common_name) pair appears in both regions, whereas the reference query only requires that a species_name appears in both regions (regardless of common_name). If a species has the same species_name but different common_names in different regions, the generated query would not return it, while the reference query would."}
{"example_id": 3474, "sql_complexity": "subqueries", "prompt": "What is the total transaction volume for the top 3 digital assets by market capitalization in the 'developed_markets' schema?", "context": "CREATE SCHEMA developed_markets; CREATE TABLE developed_markets.digital_assets (asset_name VARCHAR(10), market_cap BIGINT, daily_transaction_volume BIGINT); INSERT INTO developed_markets.digital_assets (asset_name, market_cap, daily_transaction_volume) VALUES ('AssetG', 30000000, 15000000), ('AssetH', 25000000, 12000000), ('AssetI', 20000000, 10000000), ('AssetJ', 15000000, 8000000), ('AssetK', 10000000, 6000000);", "reference_sql": "SELECT SUM(daily_transaction_volume) FROM (SELECT daily_transaction_volume FROM developed_markets.digital_assets ORDER BY market_cap DESC FETCH NEXT 3 ROWS ONLY) t;", "generated_sql": "SELECT SUM(daily_transaction_volume) AS total_transaction_volume\nFROM (\n  SELECT daily_transaction_volume\n  FROM developed_markets.digital_assets\n  ORDER BY market_cap DESC\n  FETCH FIRST 3 ROWS ONLY\n) AS top3;", "raw_model_output": "SELECT SUM(daily_transaction_volume) AS total_transaction_volume\nFROM (\n  SELECT daily_transaction_volume\n  FROM developed_markets.digital_assets\n  ORDER BY market_cap DESC\n  FETCH FIRST 3 ROWS ONLY\n) AS top3;", "latency_sec": 4.989690065383911, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 213, "prompt_eval_sec": null, "tokens_completion": 324, "completion_eval_sec": null, "tokens_total": 537, "tokens_per_sec": 107.62191498134318, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of daily_transaction_volume for the top 3 assets by market_cap. The only differences are the use of 'NEXT' vs 'FIRST' in FETCH (which are functionally equivalent in this context) and a subquery alias name. The ordering, column selection, and aggregation logic are identical."}
{"example_id": 1626, "sql_complexity": "aggregation", "prompt": "Find the total value of social impact bonds issued by each organization.", "context": "CREATE TABLE social_impact_bonds (id INT, organization_name VARCHAR(255), issue_year INT, value FLOAT); INSERT INTO social_impact_bonds (id, organization_name, issue_year, value) VALUES (1, 'Acme Corp', 2018, 2000000), (2, 'XYZ Foundation', 2019, 3000000), (3, 'Global Giving', 2018, 1500000), (4, 'Acme Corp', 2019, 2500000), (5, 'XYZ Foundation', 2018, 1000000);", "reference_sql": "SELECT organization_name, SUM(value) as total_value FROM social_impact_bonds GROUP BY organization_name;", "generated_sql": "SELECT \n  organization_name, \n  SUM(value) AS total_value \nFROM \n  social_impact_bonds \nGROUP BY \n  organization_name;", "raw_model_output": "SELECT \n  organization_name, \n  SUM(value) AS total_value \nFROM \n  social_impact_bonds \nGROUP BY \n  organization_name;", "latency_sec": 1.855431079864502, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 204, "prompt_eval_sec": null, "tokens_completion": 114, "completion_eval_sec": null, "tokens_total": 318, "tokens_per_sec": 171.38874272992282, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select organization_name and sum the value column, grouping by organization_name. The only differences are whitespace and formatting (e.g., line breaks, capitalization of keywords), which do not affect semantic meaning in SQL."}
{"example_id": 1315, "sql_complexity": "single join", "prompt": "List all the transactions made by clients living in New York with a transaction amount greater than $1000.", "context": "CREATE TABLE transactions (id INT, client_id INT, transaction_amount DECIMAL(10,2), transaction_date DATE); INSERT INTO transactions (id, client_id, transaction_amount, transaction_date) VALUES (1, 3, 1500.00, '2022-01-01'), (2, 4, 800.00, '2022-01-02'), (3, 3, 1200.00, '2022-01-03'); CREATE TABLE clients (id INT, name VARCHAR(255), state VARCHAR(255)); INSERT INTO clients (id, name, state) VALUES (3, 'Mike Johnson', 'New York'), (4, 'Sara Lee', 'California');", "reference_sql": "SELECT transactions.id, transactions.client_id, transactions.transaction_amount, transactions.transaction_date FROM transactions INNER JOIN clients ON transactions.client_id = clients.id WHERE clients.state = 'New York' AND transactions.transaction_amount > 1000.00;", "generated_sql": "SELECT\n  t.id,\n  t.client_id,\n  t.transaction_amount,\n  t.transaction_date\nFROM transactions t\nJOIN clients c\n  ON t.client_id = c.id\nWHERE c.state = 'New York'\n  AND t.transaction_amount > 1000.00;", "raw_model_output": "SELECT\n  t.id,\n  t.client_id,\n  t.transaction_amount,\n  t.transaction_date\nFROM transactions t\nJOIN clients c\n  ON t.client_id = c.id\nWHERE c.state = 'New York'\n  AND t.transaction_amount > 1000.00;", "latency_sec": 3.12981915473938, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 235, "prompt_eval_sec": null, "tokens_completion": 269, "completion_eval_sec": null, "tokens_total": 504, "tokens_per_sec": 161.03166831118972, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an INNER JOIN between transactions and clients on client_id, filter for clients in 'New York' and transactions over 1000.00, and select the same columns. The generated query uses table aliases (t/c) instead of full table names but maintains identical logic and output structure."}
{"example_id": 520, "sql_complexity": "multiple_joins", "prompt": "What is the total number of electric vehicles sold in 'California' in the 'sales' schema?", "context": "CREATE TABLE sales_regions (id INT, name VARCHAR(50));   CREATE TABLE sales (id INT, region_id INT, vehicle_count INT);   CREATE TABLE vehicles (id INT, type VARCHAR(50));   INSERT INTO sales_regions VALUES (1, 'California');   INSERT INTO sales VALUES (1, 1, 5000);   INSERT INTO vehicles VALUES (1, 'electric');", "reference_sql": "SELECT SUM(sales.vehicle_count) FROM sales INNER JOIN sales_regions ON sales.region_id = sales_regions.id INNER JOIN vehicles ON sales.id = vehicles.id WHERE vehicles.type = 'electric' AND sales_regions.name = 'California';", "generated_sql": "SELECT \n  SUM(s.vehicle_count) AS total_electric_vehicles_sold\nFROM sales AS s\nJOIN sales_regions AS sr\n  ON s.region_id = sr.id\nJOIN vehicles AS v\n  ON s.id = v.id\nWHERE sr.name = 'California'\n  AND v.type = 'electric';", "raw_model_output": "SELECT \n  SUM(s.vehicle_count) AS total_electric_vehicles_sold\nFROM sales AS s\nJOIN sales_regions AS sr\n  ON s.region_id = sr.id\nJOIN vehicles AS v\n  ON s.id = v.id\nWHERE sr.name = 'California'\n  AND v.type = 'electric';", "latency_sec": 4.705365896224976, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 166, "prompt_eval_sec": null, "tokens_completion": 468, "completion_eval_sec": null, "tokens_total": 634, "tokens_per_sec": 134.73978729446864, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform the same operations: joining the sales, sales_regions, and vehicles tables with identical conditions, filtering for 'electric' vehicles in the 'California' region, and summing the vehicle_count. The generated query uses table aliases (s, sr, v) but maintains the same logical structure and conditions as the reference query."}
{"example_id": 3999, "sql_complexity": "single join", "prompt": "What is the total number of tickets sold for performances with a rating of 5?", "context": "CREATE TABLE performance (id INT PRIMARY KEY, name VARCHAR(255), date DATE, artist_id INT, rating INT); INSERT INTO performance (id, name, date, artist_id, rating) VALUES (1, 'Dance Recital', '2022-03-01', 1, 5);", "reference_sql": "SELECT SUM(t.quantity) as total_tickets_sold FROM performance p INNER JOIN ticket t ON p.id = t.performance_id WHERE p.rating = 5;", "generated_sql": "SELECT SUM(tickets_sold) AS total_tickets_sold\nFROM performance\nWHERE rating = 5;", "raw_model_output": "SELECT SUM(tickets_sold) AS total_tickets_sold\nFROM performance\nWHERE rating = 5;", "latency_sec": 10.687201976776123, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 145, "prompt_eval_sec": null, "tokens_completion": 298, "completion_eval_sec": null, "tokens_total": 443, "tokens_per_sec": 41.45144828016382, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The generated query references a 'tickets_sold' column in the performance table, which does not exist in the provided schema. The reference query correctly joins with the ticket table and sums the 'quantity' column. The schema only contains 'quantity' in the ticket table, not 'tickets_sold' in performance."}
{"example_id": 2261, "sql_complexity": "multiple_joins", "prompt": "What is the total number of animals that have been released into 'protected' habitats, and the average weight of those animals?", "context": "CREATE TABLE habitats (habitat_id INT, habitat_name VARCHAR(50), habitat_status VARCHAR(50)); INSERT INTO habitats (habitat_id, habitat_name, habitat_status) VALUES (1, 'Habitat A', 'protected'), (2, 'Habitat B', 'unprotected'); CREATE TABLE animal_habitats (animal_id INT, habitat_id INT, animal_weight FLOAT); INSERT INTO animal_habitats (animal_id, habitat_id, animal_weight) VALUES (101, 1, 25.5), (102, 2, 15.2); CREATE TABLE animals (animal_id INT, animal_name VARCHAR(50)); INSERT INTO animals (animal_id, animal_name) VALUES (101, 'Dog'), (102, 'Cat');", "reference_sql": "SELECT COUNT(*), AVG(animal_habitats.animal_weight) FROM animal_habitats INNER JOIN animals ON animal_habitats.animal_id = animals.animal_id INNER JOIN habitats ON animal_habitats.habitat_id = habitats.habitat_id WHERE habitats.habitat_status = 'protected';", "generated_sql": "SELECT \n  COUNT(DISTINCT ah.animal_id) AS total_released_animals,\n  AVG(ah.animal_weight)      AS average_weight\nFROM animal_habitats ah\nJOIN habitats h\n  ON ah.habitat_id = h.habitat_id\nWHERE h.habitat_status = 'protected';", "raw_model_output": "SELECT \n  COUNT(DISTINCT ah.animal_id) AS total_released_animals,\n  AVG(ah.animal_weight)      AS average_weight\nFROM animal_habitats ah\nJOIN habitats h\n  ON ah.habitat_id = h.habitat_id\nWHERE h.habitat_status = 'protected';", "latency_sec": 4.126060724258423, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 245, "prompt_eval_sec": null, "tokens_completion": 406, "completion_eval_sec": null, "tokens_total": 651, "tokens_per_sec": 157.77761005129275, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses COUNT(*) which counts all rows in the joined result, while the Generated SQL uses COUNT(DISTINCT ah.animal_id) which counts unique animal IDs. Additionally, the Reference SQL includes an unnecessary JOIN with the animals table that doesn't affect the result but could impact row counts if there were orphaned entries in animal_habitats. The average calculation is equivalent, but the count methods differ."}
{"example_id": 3439, "sql_complexity": "multiple_joins", "prompt": "How many menu items contain ingredients sourced from local suppliers for each restaurant?", "context": "CREATE TABLE restaurants (id INT, name VARCHAR(50), location VARCHAR(50)); INSERT INTO restaurants VALUES (1, 'Restaurant A', 'City A'); INSERT INTO restaurants VALUES (2, 'Restaurant B', 'City B'); CREATE TABLE menu_items (id INT, name VARCHAR(50), restaurant_id INT, price DECIMAL(5,2)); INSERT INTO menu_items VALUES (1, 'Item A', 1, 10.99); INSERT INTO menu_items VALUES (2, 'Item B', 1, 12.99); INSERT INTO menu_items VALUES (3, 'Item C', 2, 11.99); CREATE TABLE ingredients (id INT, name VARCHAR(50), local_source BOOLEAN, menu_item_id INT); INSERT INTO ingredients VALUES (1, 'Ingredient A', TRUE, 1); INSERT INTO ingredients VALUES (2, 'Ingredient B', FALSE, 1); INSERT INTO ingredients VALUES (3, 'Ingredient C', TRUE, 2); INSERT INTO ingredients VALUES (4, 'Ingredient D', FALSE, 2); INSERT INTO ingredients VALUES (5, 'Ingredient E', TRUE, 3);", "reference_sql": "SELECT r.name, COUNT(DISTINCT mi.id) as num_local_items FROM restaurants r JOIN menu_items mi ON r.id = mi.restaurant_id JOIN ingredients i ON mi.id = i.menu_item_id WHERE i.local_source = TRUE GROUP BY r.name;", "generated_sql": "SELECT\n  r.id AS restaurant_id,\n  r.name AS restaurant_name,\n  COUNT(DISTINCT mi.id) AS local_menu_item_count\nFROM restaurants r\nLEFT JOIN menu_items mi\n  ON mi.restaurant_id = r.id\nLEFT JOIN ingredients i\n  ON i.menu_item_id = mi.id\n  AND i.local_source = TRUE\nGROUP BY\n  r.id,\n  r.name;", "raw_model_output": "SELECT\n  r.id AS restaurant_id,\n  r.name AS restaurant_name,\n  COUNT(DISTINCT mi.id) AS local_menu_item_count\nFROM restaurants r\nLEFT JOIN menu_items mi\n  ON mi.restaurant_id = r.id\nLEFT JOIN ingredients i\n  ON i.menu_item_id = mi.id\n  AND i.local_source = TRUE\nGROUP BY\n  r.id,\n  r.name;", "latency_sec": 4.441889047622681, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 313, "prompt_eval_sec": null, "tokens_completion": 486, "completion_eval_sec": null, "tokens_total": 799, "tokens_per_sec": 179.87842366923334, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in how they handle menu items without local ingredients. The Reference SQL uses an INNER JOIN with a WHERE clause filtering for local_source = TRUE, ensuring only menu items with at least one local ingredient are counted. The Generated SQL uses LEFT JOINs with the local_source condition in the ON clause, which includes all menu items (even those without local ingredients) but counts them as 0 for local items. This leads to different results when a menu item has no local ingredients. Additionally, the Generated SQL groups by restaurant.id and name, while the Reference groups by name alone, which could affect results if restaurants have duplicate names."}
{"example_id": 2265, "sql_complexity": "aggregation", "prompt": "Hourly revenue for a specific movie?", "context": "CREATE TABLE Movie_Revenue (id INT, movie_title VARCHAR(100), revenue_time TIME, revenue DECIMAL(10,2));", "reference_sql": "SELECT revenue_time, SUM(revenue) FROM Movie_Revenue WHERE movie_title = 'Spider-Man: No Way Home' GROUP BY revenue_time;", "generated_sql": "SELECT\n  EXTRACT(HOUR FROM revenue_time) AS revenue_hour,\n  SUM(revenue)            AS hourly_revenue\nFROM Movie_Revenue\nWHERE movie_title = 'Your Movie Title'\nGROUP BY EXTRACT(HOUR FROM revenue_time)\nORDER BY revenue_hour;", "raw_model_output": "SELECT\n  EXTRACT(HOUR FROM revenue_time) AS revenue_hour,\n  SUM(revenue)            AS hourly_revenue\nFROM Movie_Revenue\nWHERE movie_title = 'Your Movie Title'\nGROUP BY EXTRACT(HOUR FROM revenue_time)\nORDER BY revenue_hour;", "latency_sec": 6.3996710777282715, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 100, "prompt_eval_sec": null, "tokens_completion": 586, "completion_eval_sec": null, "tokens_total": 686, "tokens_per_sec": 107.19300908875982, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in three key aspects: 1) The movie title filter is different ('Spider-Man: No Way Home' vs 'Your Movie Title'). 2) The reference groups by full revenue_time (TIME type) while the generated query groups by extracted hour (INT). 3) The generated query adds an ORDER BY clause. These differences in grouping logic, filter conditions, and sorting would produce different results."}
{"example_id": 1763, "sql_complexity": "multiple_joins", "prompt": "What is the total food and beverage revenue last month for hotels in 'Bangkok'?", "context": "CREATE TABLE revenue (hotel_id INT, revenue_source VARCHAR(50), revenue INT, revenue_date DATE); INSERT INTO revenue (hotel_id, revenue_source, revenue, revenue_date) VALUES (5, 'Room revenue', 12000, '2022-03-01'), (5, 'Food and beverage', 4000, '2022-03-02'), (5, 'Other revenue', 1000, '2022-03-03'); CREATE TABLE hotels (hotel_id INT, city VARCHAR(50)); INSERT INTO hotels (hotel_id, city) VALUES (5, 'Bangkok'); CREATE TABLE dates (date DATE); INSERT INTO dates (date) VALUES ('2022-03-01'), ('2022-03-02'), ('2022-03-03');", "reference_sql": "SELECT SUM(revenue) FROM revenue JOIN hotels ON revenue.hotel_id = hotels.hotel_id JOIN dates ON revenue.revenue_date = dates.date WHERE hotels.city = 'Bangkok' AND revenue_source = 'Food and beverage' AND dates.date >= DATEADD(month, -1, GETDATE());", "generated_sql": "SELECT \n  SUM(r.revenue) AS total_food_and_beverage_revenue\nFROM revenue r\nJOIN hotels h \n  ON r.hotel_id = h.hotel_id\nWHERE h.city = 'Bangkok'\n  AND r.revenue_source = 'Food and beverage'\n  AND EXTRACT(YEAR FROM r.revenue_date)   = EXTRACT(YEAR   FROM (CURRENT_DATE - INTERVAL '1' MONTH))\n  AND EXTRACT(MONTH FROM r.revenue_date)  = EXTRACT(MONTH  FROM (CURRENT_DATE - INTERVAL '1' MONTH));", "raw_model_output": "SELECT \n  SUM(r.revenue) AS total_food_and_beverage_revenue\nFROM revenue r\nJOIN hotels h \n  ON r.hotel_id = h.hotel_id\nWHERE h.city = 'Bangkok'\n  AND r.revenue_source = 'Food and beverage'\n  AND EXTRACT(YEAR FROM r.revenue_date)   = EXTRACT(YEAR   FROM (CURRENT_DATE - INTERVAL '1' MONTH))\n  AND EXTRACT(MONTH FROM r.revenue_date)  = EXTRACT(MONTH  FROM (CURRENT_DATE - INTERVAL '1' MONTH));", "latency_sec": 19.537559986114502, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 247, "prompt_eval_sec": null, "tokens_completion": 2058, "completion_eval_sec": null, "tokens_total": 2305, "tokens_per_sec": 117.97788473269854, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in date filtering logic. The Reference SQL uses 'dates.date >= DATEADD(month, -1, GETDATE())' which depends on the dates table containing dates in the last month, while the Generated SQL uses EXTRACT() to match the entire previous month's year and month. This means the Reference SQL may exclude valid revenue entries if the dates table lacks specific dates in the last month, whereas the Generated SQL includes all revenue entries from the full previous month. Additionally, the Reference SQL joins with the dates table unnecessarily, which could further affect results if the dates table is incomplete."}
{"example_id": 5499, "sql_complexity": "set operations", "prompt": "How many legal aid clinics and community mediation centers are there in total, and what is the sum of cases handled by each type of center, for centers located in the state of California?", "context": "CREATE TABLE LegalAidClinics (ClinicName text, State text, NumCases int); INSERT INTO LegalAidClinics VALUES ('Clinic1', 'CA', 30, '2022-01-01'), ('Clinic2', 'CA', 25, '2022-01-01'); CREATE TABLE CommunityMediationCenters (CenterName text, State text, NumCases int); INSERT INTO CommunityMediationCenters VALUES ('CM1', 'CA', 22, '2022-01-01'), ('CM2', 'CA', 28, '2022-01-01');", "reference_sql": "SELECT State, 'Legal Aid Clinics' AS CenterType, COUNT(*) AS NumCenters, SUM(NumCases) AS TotalCases FROM LegalAidClinics WHERE State = 'CA' UNION ALL SELECT State, 'Community Mediation Centers', COUNT(*), SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA';", "generated_sql": "SELECT\n  (SELECT COUNT(*) FROM LegalAidClinics WHERE State = 'CA') AS num_legal_aid_clinics,\n  (SELECT SUM(NumCases) FROM LegalAidClinics WHERE State = 'CA') AS total_cases_legal_aid,\n  (SELECT COUNT(*) FROM CommunityMediationCenters WHERE State = 'CA') AS num_mediation_centers,\n  (SELECT SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA') AS total_cases_mediation;", "raw_model_output": "SELECT\n  (SELECT COUNT(*) FROM LegalAidClinics WHERE State = 'CA') AS num_legal_aid_clinics,\n  (SELECT SUM(NumCases) FROM LegalAidClinics WHERE State = 'CA') AS total_cases_legal_aid,\n  (SELECT COUNT(*) FROM CommunityMediationCenters WHERE State = 'CA') AS num_mediation_centers,\n  (SELECT SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA') AS total_cases_mediation;", "latency_sec": 10.586227178573608, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 225, "prompt_eval_sec": null, "tokens_completion": 1018, "completion_eval_sec": null, "tokens_total": 1243, "tokens_per_sec": 117.41671315308785, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two rows (one for each center type) with columns State, CenterType, NumCenters, TotalCases, while the Generated SQL returns a single row with four separate columns for each metric. The structure and formatting of the results differ, making them non-equivalent."}
{"example_id": 2408, "sql_complexity": "aggregation", "prompt": "What is the average number of victories for players from Japan and South Korea, partitioned by game mode?", "context": "CREATE TABLE PlayerVictories (PlayerID INT, GameMode VARCHAR(255), Victories INT, Country VARCHAR(255)); INSERT INTO PlayerVictories (PlayerID, GameMode, Victories, Country) VALUES (1, 'Battle Royale', 25, 'Japan'), (2, 'Team Deathmatch', 18, 'South Korea');", "reference_sql": "SELECT GameMode, AVG(Victories) as AvgVictories FROM PlayerVictories WHERE Country IN ('Japan', 'South Korea') GROUP BY GameMode, Country WITH ROLLUP;", "generated_sql": "SELECT \n  GameMode,\n  Country,\n  AVG(Victories) AS AvgVictories\nFROM PlayerVictories\nWHERE Country IN ('Japan', 'South Korea')\nGROUP BY GameMode, Country;", "raw_model_output": "SELECT \n  GameMode,\n  Country,\n  AVG(Victories) AS AvgVictories\nFROM PlayerVictories\nWHERE Country IN ('Japan', 'South Korea')\nGROUP BY GameMode, Country;", "latency_sec": 4.140255928039551, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 158, "prompt_eval_sec": null, "tokens_completion": 573, "completion_eval_sec": null, "tokens_total": 731, "tokens_per_sec": 176.55913371184647, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses WITH ROLLUP which adds subtotal and grand total rows to the result set, while the Generated SQL does not. Additionally, the Reference SQL omits the 'Country' column in the SELECT clause, whereas the Generated SQL includes it. These differences in grouping, aggregation, and selected columns make the queries non-equivalent."}
{"example_id": 2729, "sql_complexity": "subqueries", "prompt": "Find the total number of trips made by shared autonomous vehicles in Seattle", "context": "CREATE TABLE shared_vehicles (id INT, vehicle_type VARCHAR(20), is_autonomous BOOLEAN, trip_count INT); INSERT INTO shared_vehicles (id, vehicle_type, is_autonomous, trip_count) VALUES (1, 'ebike', false, 1200), (2, 'escooter', false, 800), (3, 'car', true, 1500); CREATE TABLE city_data (city VARCHAR(20), has_autonomous_vehicles BOOLEAN); INSERT INTO city_data (city, has_autonomous_vehicles) VALUES ('Seattle', true), ('Denver', false), ('Portland', true);", "reference_sql": "SELECT SUM(trip_count) FROM shared_vehicles WHERE is_autonomous = true AND vehicle_type != 'ebike' AND vehicle_type != 'escooter' AND city IN (SELECT city FROM city_data WHERE has_autonomous_vehicles = true AND city = 'Seattle');", "generated_sql": "SELECT SUM(sv.trip_count) AS total_trips\nFROM shared_vehicles sv\nJOIN city_data cd\n  ON cd.city = 'Seattle' \n AND cd.has_autonomous_vehicles = TRUE\nWHERE sv.is_autonomous = TRUE;", "raw_model_output": "SELECT SUM(sv.trip_count) AS total_trips\nFROM shared_vehicles sv\nJOIN city_data cd\n  ON cd.city = 'Seattle' \n AND cd.has_autonomous_vehicles = TRUE\nWHERE sv.is_autonomous = TRUE;", "latency_sec": 6.770548343658447, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 207, "prompt_eval_sec": null, "tokens_completion": 1093, "completion_eval_sec": null, "tokens_total": 1300, "tokens_per_sec": 192.0080817704565, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes conditions to exclude 'ebike' and 'escooter' vehicle types, while the Generated SQL does not. Additionally, the Reference SQL references a 'city' column not present in the shared_vehicles table, making it invalid. Even if the city condition were valid, the Generated SQL lacks the vehicle_type filters, leading to different results."}
{"example_id": 2952, "sql_complexity": "aggregation", "prompt": "Show the total budget allocated for each program category in 2023.", "context": "CREATE TABLE Budget (id INT, category TEXT, year INT, allocated_amount INT); INSERT INTO Budget (id, category, year, allocated_amount) VALUES (1, 'Education', 2023, 30000); INSERT INTO Budget (id, category, year, allocated_amount) VALUES (2, 'Healthcare', 2023, 50000);", "reference_sql": "SELECT category, SUM(allocated_amount) FROM Budget WHERE year = 2023 GROUP BY category;", "generated_sql": "SELECT \n  category, \n  SUM(allocated_amount) AS total_allocated \nFROM Budget \nWHERE year = 2023 \nGROUP BY category;", "raw_model_output": "SELECT \n  category, \n  SUM(allocated_amount) AS total_allocated \nFROM Budget \nWHERE year = 2023 \nGROUP BY category;", "latency_sec": 1.7370140552520752, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 153, "prompt_eval_sec": null, "tokens_completion": 114, "completion_eval_sec": null, "tokens_total": 267, "tokens_per_sec": 153.71205500191132, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries group by 'category' and sum 'allocated_amount' for year 2023. The only difference is the column alias ('total_allocated' in Generated SQL) which doesn't affect the semantic result set. The GROUP BY and WHERE clauses are identical."}
{"example_id": 4328, "sql_complexity": "aggregation", "prompt": "What is the average cargo handling time in hours for each port?", "context": "CREATE TABLE cargo_handling (id INT, port_id INT, time_in_hours DECIMAL(5,2)); INSERT INTO cargo_handling (id, port_id, time_in_hours) VALUES (1, 1, 20.5), (2, 1, 22.3), (3, 2, 18.7);", "reference_sql": "SELECT port_id, AVG(time_in_hours) FROM cargo_handling GROUP BY port_id;", "generated_sql": "SELECT \n  port_id, \n  AVG(time_in_hours) AS average_time_in_hours \nFROM cargo_handling \nGROUP BY port_id;", "raw_model_output": "SELECT \n  port_id, \n  AVG(time_in_hours) AS average_time_in_hours \nFROM cargo_handling \nGROUP BY port_id;", "latency_sec": 1.6081418991088867, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 151, "prompt_eval_sec": null, "tokens_completion": 176, "completion_eval_sec": null, "tokens_total": 327, "tokens_per_sec": 203.34026504825178, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries produce the same result set. The only difference is that the generated query explicitly names the calculated column 'average_time_in_hours' while the reference query uses the default column name. The GROUP BY clause and aggregation logic remain identical."}
{"example_id": 4915, "sql_complexity": "window functions", "prompt": "Calculate the percentage of total Europium production for each country.", "context": "CREATE TABLE europium_production (country VARCHAR(50), quantity INT);", "reference_sql": "SELECT country, quantity * 100.0 / SUM(quantity) OVER (PARTITION BY NULL) AS percentage FROM europium_production;", "generated_sql": "SELECT \n  country,\n  quantity * 100.0 / (SELECT SUM(quantity) FROM europium_production) AS percentage_of_total\nFROM europium_production;", "raw_model_output": "SELECT \n  country,\n  quantity * 100.0 / (SELECT SUM(quantity) FROM europium_production) AS percentage_of_total\nFROM europium_production;", "latency_sec": 4.025402307510376, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 93, "prompt_eval_sec": null, "tokens_completion": 502, "completion_eval_sec": null, "tokens_total": 595, "tokens_per_sec": 147.811312894088, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the percentage of each country's production relative to the total production. The reference query uses a window function SUM(quantity) OVER (PARTITION BY NULL) to get the total, while the generated query uses a scalar subquery (SELECT SUM(quantity) FROM europium_production). Both approaches compute the same total sum and perform identical division, resulting in equivalent output."}
{"example_id": 5030, "sql_complexity": "subqueries", "prompt": "What is the success rate of diverse-led startups (at least 1 female or underrepresented racial or ethnic group executive) in the past 3 years?", "context": "CREATE TABLE DiverseStartups(id INT, name TEXT, country TEXT, year INT, success BOOLEAN);   INSERT INTO DiverseStartups VALUES (1, 'FemTech', 'USA', 2020, true), (2, 'GreenCity', 'Canada', 2019, false), (3, 'AI-Health', 'UK', 2021, true), (4, 'SolarEnergy', 'USA', 2020, false), (5, 'DataAnalytics', 'Germany', 2019, true), (6, 'SmartGrid', 'USA', 2021, true), (7, 'CloudServices', 'India', 2020, false), (8, 'RenewableEnergy', 'USA', 2019, true);", "reference_sql": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3) AS success_rate FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3 AND success = true;", "generated_sql": "SELECT\n  CAST(SUM(CASE WHEN success = TRUE THEN 1 ELSE 0 END) AS DECIMAL) \n    / COUNT(*) * 100 AS success_rate\nFROM DiverseStartups\nWHERE year >= EXTRACT(YEAR FROM CURRENT_DATE) - 3;", "raw_model_output": "SELECT\n  CAST(SUM(CASE WHEN success = TRUE THEN 1 ELSE 0 END) AS DECIMAL) \n    / COUNT(*) * 100 AS success_rate\nFROM DiverseStartups\nWHERE year >= EXTRACT(YEAR FROM CURRENT_DATE) - 3;", "latency_sec": 5.6515021324157715, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 254, "prompt_eval_sec": null, "tokens_completion": 907, "completion_eval_sec": null, "tokens_total": 1161, "tokens_per_sec": 205.43210863192633, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the success rate of startups in the last 3 years. The Reference SQL uses a subquery to get the total count and multiplies by 100.0, while the Generated SQL uses SUM(CASE) to count successes and divides by COUNT(*) directly. Mathematically, they produce the same result. The year filtering conditions (YEAR(CURRENT_DATE) - 3 vs EXTRACT(YEAR FROM CURRENT_DATE) - 3) are equivalent. Both handle the same dataset and perform identical calculations."}
{"example_id": 4626, "sql_complexity": "aggregation", "prompt": "What was the maximum number of training hours for farmers in each country in 2020?", "context": "CREATE TABLE training (id INT, country_id INT, farmer_id INT, hours INT, date DATE);", "reference_sql": "SELECT country_id, MAX(hours) FROM training WHERE YEAR(date) = 2020 GROUP BY country_id;", "generated_sql": "SELECT\n  country_id,\n  MAX(hours) AS max_hours\nFROM training\nWHERE EXTRACT(YEAR FROM date) = 2020\nGROUP BY country_id;", "raw_model_output": "SELECT\n  country_id,\n  MAX(hours) AS max_hours\nFROM training\nWHERE EXTRACT(YEAR FROM date) = 2020\nGROUP BY country_id;", "latency_sec": 3.2226381301879883, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 105, "prompt_eval_sec": null, "tokens_completion": 310, "completion_eval_sec": null, "tokens_total": 415, "tokens_per_sec": 128.77648163859823, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select country_id and the maximum hours from the training table where the date is in 2020, grouped by country_id. The WHERE clause conditions (YEAR(date) = 2020 vs EXTRACT(YEAR FROM date) = 2020) are functionally equivalent for filtering dates. The generated query adds an alias (max_hours) which doesn't affect semantic equivalence."}
{"example_id": 2703, "sql_complexity": "set operations", "prompt": "Identify the species unique to 'MarineResearchAreaA' and 'MarineResearchAreaB'", "context": "CREATE TABLE ResearchAreaSpecies (area VARCHAR(255), species VARCHAR(255)); INSERT INTO ResearchAreaSpecies (area, species) VALUES ('MarineResearchAreaA', 'Coral'), ('MarineResearchAreaA', 'Starfish'), ('MarineResearchAreaB', 'Jellyfish');", "reference_sql": "(SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB') UNION (SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA');", "generated_sql": "SELECT ras.area,\n       ras.species\nFROM ResearchAreaSpecies ras\nWHERE ras.area IN ('MarineResearchAreaA','MarineResearchAreaB')\n  AND NOT EXISTS (\n    SELECT 1\n    FROM ResearchAreaSpecies ras2\n    WHERE ras2.species = ras.species\n      AND ras2.area   <> ras.area\n  );", "raw_model_output": "Here\u2019s one way to return each species that appears in A or B \u2013 but not in both \u2013 along with the area it belongs to:\n\n```sql\nSELECT ras.area,\n       ras.species\nFROM ResearchAreaSpecies ras\nWHERE ras.area IN ('MarineResearchAreaA','MarineResearchAreaB')\n  AND NOT EXISTS (\n    SELECT 1\n    FROM ResearchAreaSpecies ras2\n    WHERE ras2.species = ras.species\n      AND ras2.area   <> ras.area\n  );\n```\n\nExplanation:\n- We first filter down to rows in A or B.\n- We then exclude any species for which there exists another row in the table with the same species but a different area.\n- What remains are the species unique to each of the two areas.", "latency_sec": 10.468055963516235, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 142, "prompt_eval_sec": null, "tokens_completion": 1649, "completion_eval_sec": null, "tokens_total": 1791, "tokens_per_sec": 171.09193972998216, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns only species names (1 column) that are unique to each area, while the Generated SQL returns both area and species (2 columns). The Reference SQL's result would be ['Coral', 'Starfish', 'Jellyfish'], whereas the Generated SQL's result includes area information like ['MarineResearchAreaA', 'Coral'], etc. The column structure and output values differ, making them non-equivalent."}
{"example_id": 200, "sql_complexity": "window functions", "prompt": "List the top three categories of workforce development programs with the highest budget increases.", "context": "CREATE TABLE programs (program_id INT, program_name VARCHAR(50), budget DECIMAL(10, 2), category VARCHAR(50), budget_date DATE);", "reference_sql": "SELECT category, SUM(budget - LAG(budget) OVER (PARTITION BY category ORDER BY budget_date)) as total_budget_increase FROM programs GROUP BY category ORDER BY total_budget_increase DESC LIMIT 3;", "generated_sql": "SELECT\n    category,\n    MAX(budget) - MIN(budget) AS budget_increase\n  FROM programs\n  GROUP BY category\n)\nSELECT\n  category,\n  budget_increase\nFROM category_budget_change\nORDER BY budget_increase DESC\nFETCH FIRST 3 ROWS ONLY;", "raw_model_output": "WITH category_budget_change AS (\n  SELECT\n    category,\n    MAX(budget) - MIN(budget) AS budget_increase\n  FROM programs\n  GROUP BY category\n)\nSELECT\n  category,\n  budget_increase\nFROM category_budget_change\nORDER BY budget_increase DESC\nFETCH FIRST 3 ROWS ONLY;", "latency_sec": 10.559408903121948, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 113, "prompt_eval_sec": null, "tokens_completion": 1686, "completion_eval_sec": null, "tokens_total": 1799, "tokens_per_sec": 170.3693849253357, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the sum of consecutive budget differences within each category (effectively last budget - first budget when ordered by date), while the Generated SQL computes the difference between maximum and minimum budgets in each category. These two approaches yield different results because they measure distinct metrics (sequential changes vs. overall range)."}
{"example_id": 5131, "sql_complexity": "basic SQL", "prompt": "How many wells were drilled in the Eagle Ford Shale and Bakken Formation?", "context": "CREATE TABLE wells (id INT, region VARCHAR(255), well_type VARCHAR(255), num_drilled INT); INSERT INTO wells (id, region, well_type, num_drilled) VALUES (1, 'Eagle Ford Shale', 'Oil', 2000), (2, 'Eagle Ford Shale', 'Gas', 1500), (3, 'Bakken Formation', 'Oil', 1000), (4, 'Bakken Formation', 'Gas', 1200);", "reference_sql": "SELECT SUM(num_drilled) as total_wells FROM wells WHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "generated_sql": "SELECT\n  region,\n  SUM(num_drilled) AS wells_drilled\nFROM wells\nWHERE region IN ('Eagle Ford Shale', 'Bakken Formation')\nGROUP BY region;", "raw_model_output": "SELECT\n  region,\n  SUM(num_drilled) AS wells_drilled\nFROM wells\nWHERE region IN ('Eagle Ford Shale', 'Bakken Formation')\nGROUP BY region;", "latency_sec": 3.5486059188842773, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 185, "prompt_eval_sec": null, "tokens_completion": 441, "completion_eval_sec": null, "tokens_total": 626, "tokens_per_sec": 176.40730312393256, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query returns a single total sum of num_drilled for all specified regions, while the generated query groups the sum by individual regions. The reference produces one row with a single total, whereas the generated query produces two rows with regional breakdowns. The output structures and results differ."}
{"example_id": 1160, "sql_complexity": "subqueries", "prompt": "What is the total revenue generated from ads on Instagram in March 2021, for users in the 'brand' category who have posted more than 10 times?", "context": "CREATE TABLE ads (ad_id INT, user_id INT, platform VARCHAR(255), ad_revenue DECIMAL(10,2), post_count INT); INSERT INTO ads (ad_id, user_id, platform, ad_revenue, post_count) VALUES (1, 1, 'Instagram', 150.50, 12), (2, 2, 'Twitter', 80.00, 15), (3, 3, 'Instagram', 120.75, 8);", "reference_sql": "SELECT SUM(ad_revenue) FROM ads WHERE platform = 'Instagram' AND MONTH(ad_date) = 3 AND YEAR(ad_date) = 2021 AND user_id IN (SELECT user_id FROM users WHERE category = 'brand' AND post_count > 10);", "generated_sql": "I\u2019m going to need a couple more details to write this:\n\n\u2022 Which table (and column) holds the users\u2019 category (e.g. \u201cbrand\u201d)?  \n\u2022 Which table (and column) holds the ad date so we can filter to March 2021?  \n\nOnce you can point me at those, I can produce the SQL you need.", "raw_model_output": "I\u2019m going to need a couple more details to write this:\n\n\u2022 Which table (and column) holds the users\u2019 category (e.g. \u201cbrand\u201d)?  \n\u2022 Which table (and column) holds the ad date so we can filter to March 2021?  \n\nOnce you can point me at those, I can produce the SQL you need.", "latency_sec": 2.080575942993164, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 201, "prompt_eval_sec": null, "tokens_completion": 219, "completion_eval_sec": null, "tokens_total": 420, "tokens_per_sec": 201.86718077484758, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Generated SQL is incomplete and not provided, making comparison impossible. Additionally, the Reference SQL references a 'users' table and 'ad_date' column not present in the given schema, which only includes the 'ads' table. The schema mismatch invalidates semantic equivalence."}
{"example_id": 4708, "sql_complexity": "subqueries", "prompt": "What is the maximum number of high-level threats reported by a single agency in a month?", "context": "CREATE TABLE Threat_Intelligence (Threat_ID INT, Threat_Type VARCHAR(50), Threat_Level VARCHAR(50), Reported_Date DATE, Reporting_Agency VARCHAR(50)); CREATE VIEW High_Level_Threats AS SELECT Threat_Type, Threat_Level, Reported_Date FROM Threat_Intelligence WHERE Threat_Level = 'High';", "reference_sql": "SELECT Reporting_Agency, MAX(Number_of_High_Level_Threats) as Max_High_Level_Threats_in_a_Month FROM (SELECT Reporting_Agency, TO_CHAR(Reported_Date, 'YYYY-MM') as Month, COUNT(*) as Number_of_High_Level_Threats FROM High_Level_Threats GROUP BY Reporting_Agency, Month) GROUP BY Reporting_Agency;", "generated_sql": "SELECT MAX(monthly_count) AS max_high_threats\nFROM (\n  SELECT COUNT(*) AS monthly_count\n  FROM Threat_Intelligence\n  WHERE Threat_Level = 'High'\n  GROUP BY \n    Reporting_Agency,\n    EXTRACT(YEAR FROM Reported_Date),\n    EXTRACT(MONTH FROM Reported_Date)\n) AS sub;", "raw_model_output": "SELECT MAX(monthly_count) AS max_high_threats\nFROM (\n  SELECT COUNT(*) AS monthly_count\n  FROM Threat_Intelligence\n  WHERE Threat_Level = 'High'\n  GROUP BY \n    Reporting_Agency,\n    EXTRACT(YEAR FROM Reported_Date),\n    EXTRACT(MONTH FROM Reported_Date)\n) AS sub;", "latency_sec": 3.750006914138794, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 147, "prompt_eval_sec": null, "tokens_completion": 602, "completion_eval_sec": null, "tokens_total": 749, "tokens_per_sec": 199.7329650716154, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their output structure and logic. The Reference SQL calculates the maximum number of high-level threats per agency per month, grouping by Reporting_Agency and returning one row per agency. The Generated SQL calculates the overall maximum number of high-level threats across all agencies and months, returning a single value. Additionally, the Generated SQL uses EXTRACT() for date parts while the Reference uses TO_CHAR(), but this is a syntactic difference, not a semantic one. The core difference lies in the grouping and aggregation scope."}
{"example_id": 5608, "sql_complexity": "set operations", "prompt": "List the suppliers that provide materials for both product A and product C.", "context": "CREATE TABLE products (product_id INT, product_name TEXT); CREATE TABLE materials (material_id INT, material_name TEXT, product_id INT, supplier_id INT); INSERT INTO products (product_id, product_name) VALUES (1, 'Product A'), (2, 'Product B'), (3, 'Product C'); INSERT INTO materials (material_id, material_name, product_id, supplier_id) VALUES (1, 'Material 1', 1, 101), (2, 'Material 2', 1, 102), (3, 'Material 3', 2, 103), (4, 'Material 4', 3, 101), (5, 'Material 5', 3, 102);", "reference_sql": "SELECT supplier_id FROM materials WHERE product_id = 1 INTERSECT SELECT supplier_id FROM materials WHERE product_id = 3;", "generated_sql": "SELECT m.supplier_id\nFROM materials m\nJOIN products p ON m.product_id = p.product_id\nWHERE p.product_name IN ('Product A', 'Product C')\nGROUP BY m.supplier_id\nHAVING COUNT(DISTINCT p.product_name) = 2;", "raw_model_output": "SELECT m.supplier_id\nFROM materials m\nJOIN products p ON m.product_id = p.product_id\nWHERE p.product_name IN ('Product A', 'Product C')\nGROUP BY m.supplier_id\nHAVING COUNT(DISTINCT p.product_name) = 2;", "latency_sec": 5.321175813674927, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 231, "prompt_eval_sec": null, "tokens_completion": 523, "completion_eval_sec": null, "tokens_total": 754, "tokens_per_sec": 141.698005554015, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve supplier_ids that are associated with both product_id 1 (Product A) and product_id 3 (Product C). The Reference SQL uses INTERSECT to find common suppliers between the two product_id conditions, while the Generated SQL uses a JOIN and GROUP BY with a HAVING clause to ensure suppliers are linked to both products. The result sets are identical."}
{"example_id": 1506, "sql_complexity": "basic SQL", "prompt": "How many habitats are in the 'animal_habitats' table?", "context": "CREATE TABLE animal_habitats (id INT PRIMARY KEY, habitat_name VARCHAR, num_animals INT);", "reference_sql": "SELECT COUNT(*) FROM animal_habitats;", "generated_sql": "SELECT COUNT(*) AS habitat_count\nFROM animal_habitats;", "raw_model_output": "SELECT COUNT(*) AS habitat_count\nFROM animal_habitats;", "latency_sec": 1.6112608909606934, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 101, "prompt_eval_sec": null, "tokens_completion": 96, "completion_eval_sec": null, "tokens_total": 197, "tokens_per_sec": 122.26449552967262, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries return the same numerical count of rows from the animal_habitats table. The generated query adds an alias (habitat_count) to the COUNT(*) result, but this does not affect the actual value returned. The semantic meaning (counting all rows) remains identical."}
{"example_id": 3117, "sql_complexity": "aggregation", "prompt": "What is the percentage of the population that has access to clean water in each continent?", "context": "CREATE TABLE water_data (id INT, country VARCHAR(50), continent CHAR(2), access_to_clean_water BOOLEAN); INSERT INTO water_data VALUES (1, 'Canada', 'NA', true), (2, 'Mexico', 'NA', false), (3, 'Brazil', 'SA', true), (4, 'Russia', 'EU', true);", "reference_sql": "SELECT continent, COUNT(*) FILTER (WHERE access_to_clean_water) * 100.0 / COUNT(*) AS percentage FROM water_data GROUP BY continent;", "generated_sql": "SELECT\n  continent,\n  100.0 * SUM(CASE WHEN access_to_clean_water THEN 1 ELSE 0 END) / COUNT(*) AS pct_with_clean_water\nFROM water_data\nGROUP BY continent;", "raw_model_output": "SELECT\n  continent,\n  100.0 * SUM(CASE WHEN access_to_clean_water THEN 1 ELSE 0 END) / COUNT(*) AS pct_with_clean_water\nFROM water_data\nGROUP BY continent;", "latency_sec": 4.217409610748291, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 156, "prompt_eval_sec": null, "tokens_completion": 383, "completion_eval_sec": null, "tokens_total": 539, "tokens_per_sec": 127.80356895529664, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the percentage of countries with access to clean water per continent. The Reference SQL uses COUNT(*) FILTER (WHERE access_to_clean_water) to count true values, while the Generated SQL uses SUM(CASE WHEN access_to_clean_water THEN 1 ELSE 0 END) to achieve the same count. Both methods effectively compute the same numerator (count of true values) and denominator (total count per continent), resulting in identical percentages."}
{"example_id": 3542, "sql_complexity": "window functions", "prompt": "What is the average yield of crops for each country, ranked by average yield?", "context": "CREATE TABLE farming (id INT, name TEXT, country TEXT, crop TEXT, yield INT); INSERT INTO farming VALUES (1, 'Smith Farm', 'USA', 'Corn', 120), (2, 'Brown Farm', 'Canada', 'Soybeans', 45), (3, 'Jones Farm', 'Mexico', 'Wheat', 80);", "reference_sql": "SELECT country, AVG(yield) as avg_yield, ROW_NUMBER() OVER (ORDER BY AVG(yield) DESC) as rank FROM farming GROUP BY country;", "generated_sql": "SELECT \n  country, \n  AVG(yield) AS average_yield \nFROM farming \nGROUP BY country \nORDER BY average_yield DESC;", "raw_model_output": "SELECT \n  country, \n  AVG(yield) AS average_yield \nFROM farming \nGROUP BY country \nORDER BY average_yield DESC;", "latency_sec": 2.1065621376037598, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 155, "prompt_eval_sec": null, "tokens_completion": 177, "completion_eval_sec": null, "tokens_total": 332, "tokens_per_sec": 157.60275667806982, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a ROW_NUMBER() column for ranking, while the Generated SQL only returns country and average_yield. The Generated SQL lacks the rank column and does not include the window function, making them non-equivalent."}
{"example_id": 2274, "sql_complexity": "subqueries", "prompt": "Add a new crop 'amaranth' to farm 'Nourishing Harvest' with yield 50 in 2023", "context": "CREATE TABLE farms (id INT, name TEXT, location TEXT, size FLOAT); INSERT INTO farms (id, name, location, size) VALUES (1, 'Nourishing Harvest', 'Mexico', 120.0); CREATE TABLE crops (id INT, farm_id INT, crop TEXT, yield INT, year INT);", "reference_sql": "INSERT INTO crops (id, farm_id, crop, yield, year) VALUES (5, (SELECT id FROM farms WHERE name = 'Nourishing Harvest'), 'amaranth', 50, 2023);", "generated_sql": "INSERT INTO crops (farm_id, crop, yield, year)\nSELECT id, 'amaranth', 50, 2023\nFROM farms\nWHERE name = 'Nourishing Harvest';", "raw_model_output": "INSERT INTO crops (farm_id, crop, yield, year)\nSELECT id, 'amaranth', 50, 2023\nFROM farms\nWHERE name = 'Nourishing Harvest';", "latency_sec": 4.918688058853149, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 158, "prompt_eval_sec": null, "tokens_completion": 763, "completion_eval_sec": null, "tokens_total": 921, "tokens_per_sec": 187.24505172518343, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL explicitly specifies an id (5) for the inserted row, while the Generated SQL omits the id column and relies on the database's default handling (e.g., auto-increment). This difference in id assignment makes the queries non-equivalent. Additionally, the Generated SQL uses a SELECT statement that could insert multiple rows if multiple farms had the same name, whereas the Reference SQL inserts a single row."}
{"example_id": 3705, "sql_complexity": "subqueries", "prompt": "What is the percentage of unions with collective bargaining agreements in the Midwest region?", "context": "CREATE TABLE collective_bargaining (bargaining_id INT, union_name VARCHAR(50), contract_start_date DATE, contract_end_date DATE, region VARCHAR(50));CREATE VIEW union_region AS SELECT DISTINCT union_name, region FROM collective_bargaining;", "reference_sql": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM union_region) as percentage FROM union_region ur WHERE ur.region = 'Midwest' AND EXISTS (SELECT 1 FROM collective_bargaining cb WHERE cb.union_name = ur.union_name);", "generated_sql": "SELECT \n  (SUM(CASE WHEN region = 'Midwest' THEN 1 ELSE 0 END) * 100.0) \n  / COUNT(*) AS percentage_midwest\nFROM union_region;", "raw_model_output": "SELECT \n  (SUM(CASE WHEN region = 'Midwest' THEN 1 ELSE 0 END) * 100.0) \n  / COUNT(*) AS percentage_midwest\nFROM union_region;", "latency_sec": 5.02220892906189, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 132, "prompt_eval_sec": null, "tokens_completion": 317, "completion_eval_sec": null, "tokens_total": 449, "tokens_per_sec": 89.40289150492785, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the percentage of 'Midwest' regions in the union_region view. The Reference SQL's EXISTS clause is redundant because union_region is derived from collective_bargaining, ensuring all union_names in union_region exist in collective_bargaining. The Generated SQL directly counts 'Midwest' entries and divides by total rows, matching the Reference SQL's logic after removing the redundant condition."}
{"example_id": 240, "sql_complexity": "aggregation", "prompt": "What is the average capacity of renewable energy projects for each country?", "context": "CREATE TABLE projects (name TEXT, type TEXT, capacity INTEGER, country TEXT); INSERT INTO projects (name, type, capacity, country) VALUES ('Project 1', 'Wind', 100, 'USA'), ('Project 2', 'Solar', 200, 'Germany'), ('Project 3', 'Wind', 300, 'France');", "reference_sql": "SELECT country, AVG(capacity) FROM projects GROUP BY country", "generated_sql": "SELECT\n  country,\n  AVG(capacity) AS average_capacity\nFROM\n  projects\nWHERE\n  type IN ('Wind', 'Solar')\nGROUP BY\n  country;", "raw_model_output": "SELECT\n  country,\n  AVG(capacity) AS average_capacity\nFROM\n  projects\nWHERE\n  type IN ('Wind', 'Solar')\nGROUP BY\n  country;", "latency_sec": 3.197500228881836, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 150, "prompt_eval_sec": null, "tokens_completion": 375, "completion_eval_sec": null, "tokens_total": 525, "tokens_per_sec": 164.19076228919997, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average capacity per country. The generated query's WHERE clause filters for 'Wind' and 'Solar' types, but the provided data contains only these types. Thus, the filtering has no effect on the result, making the queries equivalent in this context."}
{"example_id": 2132, "sql_complexity": "set operations", "prompt": "What is the average caseload per attorney in community legal clinics in California, and how does it compare to the state average?", "context": "CREATE TABLE cali_community_legal_clinics(id INT, attorney_count INT, cases_handled INT, state VARCHAR(255));", "reference_sql": "SELECT state, AVG(cases_handled/attorney_count) AS avg_caseload FROM cali_community_legal_clinics WHERE state = 'California' GROUP BY state UNION ALL SELECT 'California', AVG(cases_handled/attorney_count) FROM cali_community_legal_clinics WHERE state = 'California';", "generated_sql": "SELECT \n      SUM(cases_handled) * 1.0 / NULLIF(SUM(attorney_count), 0) AS avg_caseload_ca\n    FROM cali_community_legal_clinics\n    WHERE state = 'California'\n  ),\n  overall AS (\n    SELECT \n      SUM(cases_handled) * 1.0 / NULLIF(SUM(attorney_count), 0) AS avg_caseload_state\n    FROM cali_community_legal_clinics\n  )\nSELECT\n  ca.avg_caseload_ca,\n  overall.avg_caseload_state,\n  ca.avg_caseload_ca - overall.avg_caseload_state AS difference\nFROM ca\nCROSS JOIN overall;", "raw_model_output": "WITH \n  ca AS (\n    SELECT \n      SUM(cases_handled) * 1.0 / NULLIF(SUM(attorney_count), 0) AS avg_caseload_ca\n    FROM cali_community_legal_clinics\n    WHERE state = 'California'\n  ),\n  overall AS (\n    SELECT \n      SUM(cases_handled) * 1.0 / NULLIF(SUM(attorney_count), 0) AS avg_caseload_state\n    FROM cali_community_legal_clinics\n  )\nSELECT\n  ca.avg_caseload_ca,\n  overall.avg_caseload_state,\n  ca.avg_caseload_ca - overall.avg_caseload_state AS difference\nFROM ca\nCROSS JOIN overall;", "latency_sec": 6.496370077133179, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 119, "prompt_eval_sec": null, "tokens_completion": 943, "completion_eval_sec": null, "tokens_total": 1062, "tokens_per_sec": 163.47590845204067, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates the average caseload per attorney for California clinics and returns two rows (including a hardcoded 'California' row), while the Generated SQL computes total caseload divided by total attorneys for California and all states, returning a single row with comparative metrics. The aggregation methods differ (average of ratios vs. ratio of sums) and the output structures are fundamentally different."}
{"example_id": 3276, "sql_complexity": "basic SQL", "prompt": "What is the total energy consumption of the Chemical Plant B in the last quarter?", "context": "CREATE TABLE EnergyConsumption (EnergyID INT, Plant VARCHAR(255), EnergyQuantity DECIMAL(5,2), Timestamp DATETIME);", "reference_sql": "SELECT SUM(EnergyQuantity) FROM EnergyConsumption WHERE Plant = 'Chemical Plant B' AND Timestamp BETWEEN DATE_SUB(CURRENT_DATE(), INTERVAL 3 MONTH) AND CURRENT_DATE();", "generated_sql": "SELECT \n  SUM(EnergyQuantity) AS TotalEnergy \nFROM \n  EnergyConsumption \nWHERE \n  Plant = 'Chemical Plant B' \n  AND Timestamp >= CURRENT_DATE - INTERVAL '3' MONTH \n  AND Timestamp <  CURRENT_DATE;", "raw_model_output": "SELECT \n  SUM(EnergyQuantity) AS TotalEnergy \nFROM \n  EnergyConsumption \nWHERE \n  Plant = 'Chemical Plant B' \n  AND Timestamp >= CURRENT_DATE - INTERVAL '3' MONTH \n  AND Timestamp <  CURRENT_DATE;", "latency_sec": 10.378297090530396, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 109, "prompt_eval_sec": null, "tokens_completion": 1478, "completion_eval_sec": null, "tokens_total": 1587, "tokens_per_sec": 152.91526019697847, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses BETWEEN with CURRENT_DATE (inclusive) while the Generated SQL uses < CURRENT_DATE (exclusive). This means the Generated query excludes records with Timestamp exactly equal to CURRENT_DATE, whereas the Reference includes them. The date range is slightly different."}
{"example_id": 3074, "sql_complexity": "multiple_joins", "prompt": "Find the top 5 players with the highest scores in the 'historical_tournaments' view, including their scores and the names of the tournaments they participated in.", "context": "CREATE VIEW historical_tournaments AS SELECT tournaments.tournament_name, players.player_name, players.score FROM tournaments JOIN players_scores ON tournaments.tournament_id = players_scores.tournament_id JOIN players ON players_scores.player_id = players.player_id;  CREATE TABLE tournaments (tournament_id INT, tournament_name TEXT);  CREATE TABLE players_scores (player_id INT, tournament_id INT, score INT);  CREATE TABLE players (player_id INT, player_name TEXT);", "reference_sql": "SELECT players.player_name, MAX(players_scores.score) as high_score, tournaments.tournament_name FROM historical_tournaments JOIN players ON historical_tournaments.player_id = players.player_id JOIN players_scores ON historical_tournaments.player_id = players_scores.player_id JOIN tournaments ON players_scores.tournament_id = tournaments.tournament_id GROUP BY players.player_id, tournaments.tournament_name ORDER BY high_score DESC LIMIT 5;", "generated_sql": "SELECT\n  tournament_name,\n  player_name,\n  score\nFROM\n  historical_tournaments\nORDER BY\n  score DESC\nFETCH FIRST 5 ROWS ONLY;", "raw_model_output": "SELECT\n  tournament_name,\n  player_name,\n  score\nFROM\n  historical_tournaments\nORDER BY\n  score DESC\nFETCH FIRST 5 ROWS ONLY;", "latency_sec": 4.455165147781372, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 189, "prompt_eval_sec": null, "tokens_completion": 310, "completion_eval_sec": null, "tokens_total": 499, "tokens_per_sec": 112.00482663330607, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL groups by player and tournament to find maximum scores per player-tournament pair, while the Generated SQL simply selects top 5 scores from the view without aggregation. The Reference SQL's GROUP BY and MAX() create distinct player-tournament score records, whereas the Generated SQL returns raw entries from the view. The output structures and data selection criteria differ fundamentally."}
{"example_id": 2219, "sql_complexity": "window functions", "prompt": "What is the average population of cities with a UNESCO World Heritage designation, ordered by designation date?", "context": "CREATE TABLE cities (name VARCHAR(255), population INT, designation_date DATE); INSERT INTO cities (name, population, designation_date) VALUES ('Paris', 2141000, '1991-09-16'); INSERT INTO cities (name, population, designation_date) VALUES ('Rio de Janeiro', 6727000, '2012-07-01');", "reference_sql": "SELECT AVG(population) FROM (SELECT population, ROW_NUMBER() OVER (ORDER BY designation_date) rn FROM cities WHERE name IN (SELECT name FROM heritagesites)) t WHERE rn % 2 = 1;", "generated_sql": "SELECT\n  designation_date,\n  AVG(population) AS average_population\nFROM cities\nWHERE designation_date IS NOT NULL\nGROUP BY designation_date\nORDER BY designation_date;", "raw_model_output": "```sql\nSELECT\n  designation_date,\n  AVG(population) AS average_population\nFROM cities\nWHERE designation_date IS NOT NULL\nGROUP BY designation_date\nORDER BY designation_date;\n```", "latency_sec": 6.246256113052368, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 159, "prompt_eval_sec": null, "tokens_completion": 442, "completion_eval_sec": null, "tokens_total": 601, "tokens_per_sec": 96.21763647253144, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates the average population of cities in heritagesites, ordered by designation_date, considering only odd-numbered rows. The Generated SQL groups cities by designation_date (excluding nulls) and calculates average population per date. They differ in: 1) Filtering criteria (heritagesites vs. non-null dates), 2) Aggregation structure (single average vs. grouped averages), 3) Output columns (single average vs. date+average), and 4) Row selection logic (row numbering vs. grouping)."}
{"example_id": 3786, "sql_complexity": "aggregation", "prompt": "Display the names and average co-owner percentages for all properties in the 'property_coownership' table where the co-owner percentage is greater than 60.", "context": "CREATE TABLE property_coownership (property_id INT, owner VARCHAR(255), percentage INT); INSERT INTO property_coownership (property_id, owner, percentage) VALUES (1, 'Mohammed', 70), (1, 'Fatima', 30), (2, 'Jamal', 65), (2, 'Aisha', 35), (3, 'Ali', 75), (3, 'Khadija', 25);", "reference_sql": "SELECT owner, AVG(percentage) FROM property_coownership WHERE percentage > 60 GROUP BY owner;", "generated_sql": "SELECT owner,\n       AVG(percentage) AS average_percentage\nFROM property_coownership\nWHERE percentage > 60\nGROUP BY owner;", "raw_model_output": "SELECT owner,\n       AVG(percentage) AS average_percentage\nFROM property_coownership\nWHERE percentage > 60\nGROUP BY owner;", "latency_sec": 16.045124053955078, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 188, "prompt_eval_sec": null, "tokens_completion": 1774, "completion_eval_sec": null, "tokens_total": 1962, "tokens_per_sec": 122.28013902556101, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. The generated query adds an explicit column alias 'average_percentage' for the AVG(percentage) expression, but this does not affect the actual data returned. Both queries filter rows where percentage > 60, group by owner, and calculate the average percentage per owner. The semicolon at the end of the generated query is syntactic and does not impact the query's meaning."}
{"example_id": 2357, "sql_complexity": "basic SQL", "prompt": "What is the total amount of climate finance invested in renewable energy projects by public and private sectors in Africa?", "context": "CREATE TABLE renewable_energy_projects (project_id INT, sector TEXT, investor_type TEXT, region TEXT, amount FLOAT); INSERT INTO renewable_energy_projects (project_id, sector, investor_type, region, amount) VALUES (1, 'Renewable Energy', 'Public', 'Africa', 5000000); INSERT INTO renewable_energy_projects (project_id, sector, investor_type, region, amount) VALUES (2, 'Renewable Energy', 'Private', 'Africa', 7000000);", "reference_sql": "SELECT SUM(amount) FROM renewable_energy_projects WHERE sector = 'Renewable Energy' AND region = 'Africa';", "generated_sql": "SELECT\n  SUM(amount) AS total_amount\nFROM\n  renewable_energy_projects\nWHERE\n  sector = 'Renewable Energy'\n  AND region = 'Africa'\n  AND investor_type IN ('Public', 'Private');", "raw_model_output": "SELECT\n  SUM(amount) AS total_amount\nFROM\n  renewable_energy_projects\nWHERE\n  sector = 'Renewable Energy'\n  AND region = 'Africa'\n  AND investor_type IN ('Public', 'Private');", "latency_sec": 3.9695680141448975, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 186, "prompt_eval_sec": null, "tokens_completion": 256, "completion_eval_sec": null, "tokens_total": 442, "tokens_per_sec": 111.34712856033863, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The generated query adds an extra condition (investor_type IN ('Public', 'Private')) that wasn't in the reference query. While the current data satisfies this condition, semantically the reference query could include other investor types. This makes them non-equivalent in general cases."}
{"example_id": 1009, "sql_complexity": "multiple_joins", "prompt": "Find the number of IoT sensors installed in each farm that use Sprinkler irrigation.", "context": "CREATE TABLE IoT_Sensors (id INT, sensor_type VARCHAR(50), Farm_id INT); INSERT INTO IoT_Sensors (id, sensor_type, Farm_id) VALUES (1, 'Soil Moisture', 1), (2, 'Temperature', 1), (3, 'Humidity', 2); CREATE TABLE Irrigation (id INT, Farm_id INT, irrigation_type VARCHAR(50), duration INT); INSERT INTO Irrigation (id, Farm_id, irrigation_type, duration) VALUES (1, 1, 'Sprinkler', 30), (2, 2, 'Drip', 45);", "reference_sql": "SELECT f.id, COUNT(s.id) FROM Farmers f JOIN Irrigation i ON f.id = i.Farm_id JOIN IoT_Sensors s ON f.id = s.Farm_id WHERE i.irrigation_type = 'Sprinkler' GROUP BY f.id;", "generated_sql": "SELECT \n  s.Farm_id, \n  COUNT(*) AS sensor_count\nFROM \n  IoT_Sensors s\nJOIN \n  Irrigation i \n    ON s.Farm_id = i.Farm_id\n   AND i.irrigation_type = 'Sprinkler'\nGROUP BY \n  s.Farm_id;", "raw_model_output": "SELECT \n  s.Farm_id, \n  COUNT(*) AS sensor_count\nFROM \n  IoT_Sensors s\nJOIN \n  Irrigation i \n    ON s.Farm_id = i.Farm_id\n   AND i.irrigation_type = 'Sprinkler'\nGROUP BY \n  s.Farm_id;", "latency_sec": 6.711690902709961, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 214, "prompt_eval_sec": null, "tokens_completion": 469, "completion_eval_sec": null, "tokens_total": 683, "tokens_per_sec": 101.76273161271878, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL includes an explicit join with the Farmers table, which ensures that only Farm_ids present in Farmers are considered. The Generated SQL directly joins IoT_Sensors and Irrigation, potentially including Farm_ids that exist in those tables but not in Farmers. While they produce the same result in the provided sample data, they differ in handling cases where Farm_ids exist in IoT_Sensors/Irrigation but not in Farmers."}
{"example_id": 4217, "sql_complexity": "subqueries", "prompt": "Show consumer preference data for foundations, excluding products from the USA.", "context": "CREATE TABLE cosmetics (product_id INT, product_name VARCHAR(100), product_type VARCHAR(50), is_cruelty_free BOOLEAN, consumer_preference_score INT); INSERT INTO cosmetics (product_id, product_name, product_type, is_cruelty_free, consumer_preference_score) VALUES (1, 'Lipstick A', 'Lipstick', TRUE, 80), (2, 'Foundation B', 'Foundation', FALSE, 90), (3, 'Mascara C', 'Mascara', TRUE, 85), (4, 'Eyeshadow D', 'Eyeshadow', TRUE, 70), (5, 'Blush E', 'Blush', FALSE, 95); CREATE TABLE ingredient_sourcing (ingredient_id INT, ingredient_name VARCHAR(100), sourcing_country VARCHAR(50), is_organic BOOLEAN); INSERT INTO ingredient_sourcing (ingredient_id, ingredient_name, sourcing_country, is_organic) VALUES (1, 'Rosehip Oil', 'Chile', TRUE), (2, 'Shea Butter', 'Ghana', TRUE), (3, 'Jojoba Oil', 'India', TRUE), (4, 'Coconut Oil', 'Philippines', FALSE), (5, 'Aloe Vera', 'USA', TRUE);", "reference_sql": "SELECT * FROM cosmetics WHERE product_type = 'Foundation' AND product_id NOT IN (SELECT cosmetics.product_id FROM cosmetics INNER JOIN ingredient_sourcing ON cosmetics.product_id = ingredient_sourcing.ingredient_id WHERE ingredient_sourcing.sourcing_country = 'USA');", "generated_sql": "SELECT product_name,\n       consumer_preference_score\nFROM cosmetics\nWHERE product_type = 'Foundation';", "raw_model_output": "SELECT product_name,\n       consumer_preference_score\nFROM cosmetics\nWHERE product_type = 'Foundation';", "latency_sec": 6.571995735168457, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 335, "prompt_eval_sec": null, "tokens_completion": 871, "completion_eval_sec": null, "tokens_total": 1206, "tokens_per_sec": 183.50590119016368, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL filters Foundation products excluding those linked to ingredients sourced from 'USA' via a NOT IN clause, while the Generated SQL returns all Foundation products without this exclusion. Additionally, the Reference SQL selects all columns, whereas the Generated SQL only selects specific columns."}
{"example_id": 5620, "sql_complexity": "basic SQL", "prompt": "What is the recycling rate of plastic in the residential sector in the state of New York?", "context": "CREATE TABLE recycling_rates_city (sector VARCHAR(20), city VARCHAR(20), material VARCHAR(20), recycling_rate DECIMAL(5,2)); INSERT INTO recycling_rates_city (sector, city, material, recycling_rate) VALUES ('residential', 'New York City', 'plastic', 0.25), ('commercial', 'New York City', 'plastic', 0.30), ('residential', 'New York City', 'paper', 0.45), ('commercial', 'New York City', 'paper', 0.50), ('residential', 'Los Angeles', 'plastic', 0.20), ('commercial', 'Los Angeles', 'plastic', 0.35), ('residential', 'Los Angeles', 'paper', 0.40), ('commercial', 'Los Angeles', 'paper', 0.50);", "reference_sql": "SELECT recycling_rate FROM recycling_rates_city WHERE sector = 'residential' AND material = 'plastic' AND city = 'New York City';", "generated_sql": "SELECT recycling_rate\nFROM recycling_rates_city\nWHERE sector = 'residential'\n  AND material = 'plastic'\n  AND city = 'New York City';", "raw_model_output": "SELECT recycling_rate\nFROM recycling_rates_city\nWHERE sector = 'residential'\n  AND material = 'plastic'\n  AND city = 'New York City';", "latency_sec": 2.7035748958587646, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 258, "prompt_eval_sec": null, "tokens_completion": 371, "completion_eval_sec": null, "tokens_total": 629, "tokens_per_sec": 232.6549195894217, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the same column from the same table with identical WHERE conditions (sector = 'residential', material = 'plastic', city = 'New York City'). The only difference is formatting (line breaks/spaces), which does not affect semantic meaning in SQL."}
{"example_id": 3151, "sql_complexity": "basic SQL", "prompt": "List all biotech startups that received funding in 2022 and their respective funding amounts.", "context": "CREATE TABLE biotech_startups (name TEXT, funding FLOAT, date DATE); INSERT INTO biotech_startups (name, funding, date) VALUES ('StartupA', 3500000, '2022-02-28'); INSERT INTO biotech_startups (name, funding, date) VALUES ('StartupB', 4500000, '2022-07-12');", "reference_sql": "SELECT name, funding FROM biotech_startups WHERE date BETWEEN '2022-01-01' AND '2022-12-31';", "generated_sql": "SELECT name, funding\nFROM biotech_startups\nWHERE EXTRACT(YEAR FROM date) = 2022;", "raw_model_output": "SELECT name, funding\nFROM biotech_startups\nWHERE EXTRACT(YEAR FROM date) = 2022;", "latency_sec": 3.4937472343444824, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 158, "prompt_eval_sec": null, "tokens_completion": 234, "completion_eval_sec": null, "tokens_total": 392, "tokens_per_sec": 112.20044659972356, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter records where the date falls within 2022. The BETWEEN clause explicitly checks for dates between '2022-01-01' and '2022-12-31' (inclusive), while EXTRACT(YEAR FROM date) = 2022 achieves the same by checking the year part of the date. Since the date column is of DATE type, both approaches yield identical results."}
{"example_id": 2136, "sql_complexity": "window functions", "prompt": "What is the total military equipment sales revenue for each sales representative by fiscal year?", "context": "CREATE TABLE SalesReps (SalesRepID INT, SalesRepName VARCHAR(50), FiscalYear INT, Revenue DECIMAL(10,2)); INSERT INTO SalesReps (SalesRepID, SalesRepName, FiscalYear, Revenue) VALUES (1, 'John Doe', 2020, 150000.00), (2, 'Jane Smith', 2020, 200000.00), (1, 'John Doe', 2021, 180000.00), (2, 'Jane Smith', 2021, 250000.00);", "reference_sql": "SELECT SalesRepName, FiscalYear, SUM(Revenue) OVER (PARTITION BY SalesRepName ORDER BY FiscalYear) AS TotalRevenue FROM SalesReps;", "generated_sql": "SELECT\n  SalesRepID,\n  SalesRepName,\n  FiscalYear,\n  SUM(Revenue) AS TotalRevenue\nFROM SalesReps\nGROUP BY\n  SalesRepID,\n  SalesRepName,\n  FiscalYear\nORDER BY\n  SalesRepID,\n  FiscalYear;", "raw_model_output": "SELECT\n  SalesRepID,\n  SalesRepName,\n  FiscalYear,\n  SUM(Revenue) AS TotalRevenue\nFROM SalesReps\nGROUP BY\n  SalesRepID,\n  SalesRepName,\n  FiscalYear\nORDER BY\n  SalesRepID,\n  FiscalYear;", "latency_sec": 3.947049856185913, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 200, "prompt_eval_sec": null, "tokens_completion": 398, "completion_eval_sec": null, "tokens_total": 598, "tokens_per_sec": 151.50556030165157, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL uses a window function to calculate a running total of Revenue per SalesRepName across FiscalYears, while the Generated SQL aggregates Revenue by individual SalesRepID/FiscalYear combinations. The Reference includes only SalesRepName and FiscalYear, whereas the Generated includes SalesRepID. The semantic output differs between cumulative sums vs. per-group sums."}
{"example_id": 5452, "sql_complexity": "basic SQL", "prompt": "What is the name of the farms with a size greater than 150 acres located in 'Texas'?", "context": "CREATE TABLE farms (id INT PRIMARY KEY, name VARCHAR(50), size INT, location VARCHAR(50)); INSERT INTO farms (id, name, size, location) VALUES (1, 'Smith Farms', 200, 'Texas'), (2, 'Johnson Farms', 100, 'California');", "reference_sql": "SELECT name FROM farms WHERE size > 150 AND location = 'Texas'", "generated_sql": "SELECT name\nFROM farms\nWHERE size > 150\n  AND location = 'Texas';", "raw_model_output": "SELECT name\nFROM farms\nWHERE size > 150\n  AND location = 'Texas';", "latency_sec": 2.043825149536133, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 148, "prompt_eval_sec": null, "tokens_completion": 166, "completion_eval_sec": null, "tokens_total": 314, "tokens_per_sec": 153.63349456349803, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in logic and structure. Both select the 'name' column from the 'farms' table where 'size' is greater than 150 and 'location' is 'Texas'. The only difference is formatting (line breaks and spacing), which does not affect semantic equivalence."}
{"example_id": 5152, "sql_complexity": "aggregation", "prompt": "How many international tourists visited Portugal in 2020, broken down by continent?", "context": "CREATE TABLE international_tourists(tourist_id INT, country TEXT, arrival_year INT, continent TEXT);INSERT INTO international_tourists (tourist_id, country, arrival_year, continent) VALUES (1, 'Spain', 2020, 'Europe'), (2, 'France', 2020, 'Europe'), (3, 'Brazil', 2020, 'South America'), (4, 'United States', 2020, 'North America'), (5, 'China', 2020, 'Asia');", "reference_sql": "SELECT continent, COUNT(*) FROM international_tourists WHERE arrival_year = 2020 GROUP BY continent;", "generated_sql": "SELECT\n  continent,\n  COUNT(*) AS tourist_count\nFROM\n  international_tourists\nWHERE\n  country = 'Portugal'\n  AND arrival_year = 2020\nGROUP BY\n  continent;", "raw_model_output": "SELECT\n  continent,\n  COUNT(*) AS tourist_count\nFROM\n  international_tourists\nWHERE\n  country = 'Portugal'\n  AND arrival_year = 2020\nGROUP BY\n  continent;", "latency_sec": 5.153097152709961, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 191, "prompt_eval_sec": null, "tokens_completion": 318, "completion_eval_sec": null, "tokens_total": 509, "tokens_per_sec": 98.77554893998499, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL counts all tourists from 2020 grouped by continent, while the Generated SQL filters for 'Portugal' (which doesn't exist in the data) and would return no results. The WHERE clause in the Generated SQL excludes all rows, making the results fundamentally different."}
{"example_id": 2477, "sql_complexity": "set operations", "prompt": "What is the carbon price in Europe and Australia for the last quarter of 2020?", "context": "CREATE TABLE CarbonPrices (Country TEXT, Year INT, Quarter INT, CarbonPrice NUMBER); INSERT INTO CarbonPrices (Country, Year, Quarter, CarbonPrice) VALUES ('Europe', 2020, 4, 25), ('Australia', 2020, 4, 15); CREATE TABLE CarbonTaxes (Country TEXT, Year INT, Quarter INT, CarbonPrice NUMBER); INSERT INTO CarbonTaxes (Country, Year, Quarter, CarbonPrice) VALUES ('Europe', 2019, 4, 20), ('Australia', 2019, 4, 10);", "reference_sql": "SELECT Context.Country, Context.CarbonPrice FROM ( SELECT * FROM CarbonPrices WHERE CarbonPrices.Country IN ('Europe', 'Australia') AND CarbonPrices.Year = 2020 AND CarbonPrices.Quarter = 4 UNION SELECT * FROM CarbonTaxes WHERE CarbonTaxes.Country IN ('Europe', 'Australia') AND CarbonTaxes.Year = 2020 AND CarbonTaxes.Quarter = 4 ) AS Context;", "generated_sql": "SELECT Country, CarbonPrice\nFROM CarbonPrices\nWHERE Year = 2020\n  AND Quarter = 4\n  AND Country IN ('Europe', 'Australia');", "raw_model_output": "SELECT Country, CarbonPrice\nFROM CarbonPrices\nWHERE Year = 2020\n  AND Quarter = 4\n  AND Country IN ('Europe', 'Australia');", "latency_sec": 2.8674209117889404, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 202, "prompt_eval_sec": null, "tokens_completion": 309, "completion_eval_sec": null, "tokens_total": 511, "tokens_per_sec": 178.208925623408, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL combines data from both CarbonPrices and CarbonTaxes tables using UNION, while the Generated SQL only queries the CarbonPrices table. The Generated SQL omits the CarbonTaxes table entirely, so it would not include any matching records from CarbonTaxes (even though none exist in the sample data). This makes them semantically different."}
{"example_id": 4573, "sql_complexity": "subqueries", "prompt": "Find the names of all the indigenous communities in the 'Arctic_Communities' table that have a population size greater than the average population size in the 'Antarctic_Communities' table.", "context": "CREATE TABLE Arctic_Communities (name TEXT, population INTEGER); CREATE TABLE Antarctic_Communities (name TEXT, population INTEGER);", "reference_sql": "SELECT name FROM Arctic_Communities WHERE Arctic_Communities.population > (SELECT AVG(population) FROM Antarctic_Communities)", "generated_sql": "SELECT name\nFROM Arctic_Communities\nWHERE population > (\n  SELECT AVG(population)\n  FROM Antarctic_Communities\n);", "raw_model_output": "SELECT name\nFROM Arctic_Communities\nWHERE population > (\n  SELECT AVG(population)\n  FROM Antarctic_Communities\n);", "latency_sec": 1.8339259624481201, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 133, "prompt_eval_sec": null, "tokens_completion": 174, "completion_eval_sec": null, "tokens_total": 307, "tokens_per_sec": 167.4004328888957, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select names from Arctic_Communities where population exceeds the average population of Antarctic_Communities. The generated SQL omits table qualifiers in the WHERE clause, but since the query only references Arctic_Communities, the population column is unambiguous. The subquery correctly references Antarctic_Communities in both cases."}
{"example_id": 3596, "sql_complexity": "window functions", "prompt": "What is the total revenue for each game in the \"Gaming\" category?", "context": "CREATE TABLE Games (GameID int, GameName varchar(50), Category varchar(50), Revenue decimal(10,2));", "reference_sql": "SELECT Category, SUM(Revenue) OVER(PARTITION BY Category) as TotalRevenue FROM Games;", "generated_sql": "SELECT GameName, \n       SUM(Revenue) AS TotalRevenue\nFROM Games\nWHERE Category = 'Gaming'\nGROUP BY GameName;", "raw_model_output": "SELECT GameName, \n       SUM(Revenue) AS TotalRevenue\nFROM Games\nWHERE Category = 'Gaming'\nGROUP BY GameName;", "latency_sec": 2.8090450763702393, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 107, "prompt_eval_sec": null, "tokens_completion": 175, "completion_eval_sec": null, "tokens_total": 282, "tokens_per_sec": 100.38998746306757, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates the total revenue per category for each row using a window function, while the generated query filters to only 'Gaming' category, groups by GameName, and sums revenue per GameName. The output columns, aggregation logic, and filtering differ significantly."}
{"example_id": 5039, "sql_complexity": "subqueries", "prompt": "What is the total number of community policing events in 'City Park' in 2021?", "context": "CREATE TABLE locations (id INT, name VARCHAR(255)); CREATE TABLE community_policing (id INT, location_id INT, year INT, events INT); INSERT INTO locations (id, name) VALUES (1, 'City Park'); INSERT INTO community_policing (id, location_id, year, events) VALUES (1, 1, 2021, 5);", "reference_sql": "SELECT SUM(events) FROM community_policing WHERE location_id = (SELECT id FROM locations WHERE name = 'City Park') AND year = 2021;", "generated_sql": "SELECT SUM(cp.events) AS total_events\nFROM community_policing AS cp\nJOIN locations AS l\n  ON cp.location_id = l.id\nWHERE l.name = 'City Park'\n  AND cp.year = 2021;", "raw_model_output": "SELECT SUM(cp.events) AS total_events\nFROM community_policing AS cp\nJOIN locations AS l\n  ON cp.location_id = l.id\nWHERE l.name = 'City Park'\n  AND cp.year = 2021;", "latency_sec": 2.0286941528320312, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 161, "prompt_eval_sec": null, "tokens_completion": 258, "completion_eval_sec": null, "tokens_total": 419, "tokens_per_sec": 206.53680073710535, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of 'events' from the community_policing table where the location corresponds to 'City Park' (via location_id matching the locations table's id) and the year is 2021. The reference query uses a subquery to get the location_id, while the generated query uses a JOIN. Since the data contains only one location named 'City Park', both approaches yield the same result. The JOIN version is more robust for multiple locations with the same name, but in this specific case, they are semantically equivalent."}
{"example_id": 2724, "sql_complexity": "basic SQL", "prompt": "What is the earliest installation date for solar panels in Italy?", "context": "CREATE TABLE solar_panels_italy (id INT, installation_date DATE); INSERT INTO solar_panels_italy (id, installation_date) VALUES (1, '2018-01-01'), (2, '2019-01-01'), (3, '2020-01-01');", "reference_sql": "SELECT MIN(installation_date) as earliest_date FROM solar_panels_italy;", "generated_sql": "SELECT MIN(installation_date) AS earliest_installation_date\nFROM solar_panels_italy;", "raw_model_output": "SELECT MIN(installation_date) AS earliest_installation_date\nFROM solar_panels_italy;", "latency_sec": 1.8610961437225342, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 142, "prompt_eval_sec": null, "tokens_completion": 231, "completion_eval_sec": null, "tokens_total": 373, "tokens_per_sec": 200.41952225742162, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the minimum installation_date from the same table. The only difference is the column alias name ('earliest_date' vs 'earliest_installation_date'), which does not affect the semantic result. The output value (the earliest date) remains the same."}
{"example_id": 2200, "sql_complexity": "single join", "prompt": "Which diversity programs are currently being participated in by employees in the HR department?", "context": "CREATE TABLE Employees (Employee_ID INT, First_Name VARCHAR(20), Last_Name VARCHAR(20), Department VARCHAR(20), Salary DECIMAL(10,2), Date_Hired DATE); CREATE TABLE Diversity_Programs (Program_ID INT, Program_Name VARCHAR(50), Participant_ID INT, Date_Started DATE, Date_Ended DATE);", "reference_sql": "SELECT dp.Program_Name FROM Diversity_Programs dp JOIN Employees e ON dp.Participant_ID = e.Employee_ID WHERE e.Department = 'HR' AND dp.Date_Ended IS NULL;", "generated_sql": "SELECT DISTINCT dp.Program_ID,\n                dp.Program_Name\nFROM Diversity_Programs AS dp\nJOIN Employees AS e\n  ON dp.Participant_ID = e.Employee_ID\nWHERE e.Department = 'HR'\n  AND (dp.Date_Ended IS NULL OR dp.Date_Ended > CURRENT_DATE);", "raw_model_output": "SELECT DISTINCT dp.Program_ID,\n                dp.Program_Name\nFROM Diversity_Programs AS dp\nJOIN Employees AS e\n  ON dp.Participant_ID = e.Employee_ID\nWHERE e.Department = 'HR'\n  AND (dp.Date_Ended IS NULL OR dp.Date_Ended > CURRENT_DATE);", "latency_sec": 3.2298622131347656, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 149, "prompt_eval_sec": null, "tokens_completion": 462, "completion_eval_sec": null, "tokens_total": 611, "tokens_per_sec": 189.17215648248649, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their Date_Ended condition: the Reference SQL checks for NULL, while the Generated SQL includes NULL OR Date_Ended > CURRENT_DATE. This makes the Generated SQL broader, potentially including programs with future end dates. Additionally, the Generated SQL selects Program_ID (missing in Reference) and uses DISTINCT, which could alter results if duplicates exist."}
{"example_id": 4359, "sql_complexity": "window functions", "prompt": "Which destinations have the least hotel awards?", "context": "CREATE TABLE Destinations (destination_id INT, destination_name TEXT, country TEXT, awards INT); INSERT INTO Destinations (destination_id, destination_name, country, awards) VALUES (1, 'City A', 'Germany', 3), (2, 'City B', 'Switzerland', 5), (3, 'City C', 'Norway', 2);", "reference_sql": "SELECT destination_name, country, awards, RANK() OVER (PARTITION BY country ORDER BY awards ASC) AS rank FROM Destinations;", "generated_sql": "SELECT destination_name, country, awards\nFROM Destinations\nWHERE awards = (\n  SELECT MIN(awards)\n  FROM Destinations\n);", "raw_model_output": "SELECT destination_name, country, awards\nFROM Destinations\nWHERE awards = (\n  SELECT MIN(awards)\n  FROM Destinations\n);", "latency_sec": 4.25789999961853, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 150, "prompt_eval_sec": null, "tokens_completion": 240, "completion_eval_sec": null, "tokens_total": 390, "tokens_per_sec": 91.59444797551387, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates ranks within each country partition, returning all rows with their respective ranks. The Generated SQL filters to only include destinations with the minimum awards in the entire table. While the sample data shows City C (awards=2) as the minimum, the Reference SQL would return all three destinations with rank=1 (since each country has one entry), whereas the Generated SQL returns only City C. The queries differ in both result set content and purpose."}
{"example_id": 1373, "sql_complexity": "subqueries", "prompt": "What is the total value of military equipment sales to Africa in the last 12 months?", "context": "CREATE TABLE Military_Equipment_Sales(sale_id INT, sale_date DATE, equipment_type VARCHAR(50), country VARCHAR(50), sale_value DECIMAL(10,2));", "reference_sql": "SELECT SUM(sale_value) FROM Military_Equipment_Sales WHERE country IN (SELECT country FROM World_Countries WHERE continent = 'Africa') AND sale_date >= DATE_SUB(CURRENT_DATE, INTERVAL 12 MONTH);", "generated_sql": "SELECT \n  COALESCE(SUM(sale_value), 0) AS total_value_last_12_months\nFROM \n  Military_Equipment_Sales\nWHERE \n  country = 'Africa'\n  AND sale_date >= CURRENT_DATE - INTERVAL '1' YEAR;", "raw_model_output": "SELECT \n  COALESCE(SUM(sale_value), 0) AS total_value_last_12_months\nFROM \n  Military_Equipment_Sales\nWHERE \n  country = 'Africa'\n  AND sale_date >= CURRENT_DATE - INTERVAL '1' YEAR;", "latency_sec": 7.356243848800659, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 120, "prompt_eval_sec": null, "tokens_completion": 523, "completion_eval_sec": null, "tokens_total": 643, "tokens_per_sec": 87.4087391902911, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their country filtering logic. The Reference SQL uses a subquery to select countries in Africa from World_Countries, while the Generated SQL incorrectly filters for a country named 'Africa' (a continent, not a country). The date conditions are equivalent, but the country condition makes the queries non-equivalent."}
{"example_id": 904, "sql_complexity": "basic SQL", "prompt": "What is the minimum Shariah-compliant loan amount issued in the last quarter of 2021?", "context": "CREATE TABLE loans (id INT, amount DECIMAL, date DATE, loan_type VARCHAR); INSERT INTO loans (id, amount, date, loan_type) VALUES (1, 5000, '2021-09-05', 'Shariah-compliant'), (2, 7000, '2021-10-07', 'socially responsible'), (3, 9000, '2021-11-03', 'Shariah-compliant'), (4, 11000, '2021-12-31', 'Shariah-compliant');", "reference_sql": "SELECT MIN(amount) FROM loans WHERE EXTRACT(YEAR FROM date) = 2021 AND EXTRACT(QUARTER FROM date) = 4 AND loan_type = 'Shariah-compliant';", "generated_sql": "SELECT MIN(amount) AS min_amount\nFROM loans\nWHERE loan_type = 'Shariah-compliant'\n  AND date BETWEEN '2021-10-01' AND '2021-12-31';", "raw_model_output": "SELECT MIN(amount) AS min_amount\nFROM loans\nWHERE loan_type = 'Shariah-compliant'\n  AND date BETWEEN '2021-10-01' AND '2021-12-31';", "latency_sec": 2.476691961288452, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 205, "prompt_eval_sec": null, "tokens_completion": 254, "completion_eval_sec": null, "tokens_total": 459, "tokens_per_sec": 185.3278514947874, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter 'Shariah-compliant' loans with dates in the fourth quarter of 2021. The reference uses EXTRACT(YEAR) = 2021 and EXTRACT(QUARTER) = 4, which corresponds to October-December 2021. The generated query uses date BETWEEN '2021-10-01' AND '2021-12-31', which covers the same date range. The loan_type condition is identical. Both will return the same MIN(amount) of 9000."}
{"example_id": 3299, "sql_complexity": "set operations", "prompt": "How many schools and hospitals are there in Colombia and which ones need repairs?", "context": "CREATE TABLE schools (id INT, country VARCHAR(20), name VARCHAR(50), needs_repair BOOLEAN); CREATE TABLE hospitals (id INT, country VARCHAR(20), name VARCHAR(50), needs_repair BOOLEAN);", "reference_sql": "SELECT 'Schools' as facility_type, COUNT(*) as total, SUM(needs_repair) as repairs_needed FROM schools WHERE country = 'Colombia' UNION ALL SELECT 'Hospitals' as facility_type, COUNT(*) as total, SUM(needs_repair) as repairs_needed FROM hospitals WHERE country = 'Colombia';", "generated_sql": "SELECT COUNT(*) AS total_schools\n  FROM schools\n  WHERE country = 'Colombia'\n),\ncol_hospitals AS (\n  SELECT COUNT(*) AS total_hospitals\n  FROM hospitals\n  WHERE country = 'Colombia'\n),\nrepairs AS (\n  SELECT 'school'    AS entity_type,\n         name\n  FROM schools\n  WHERE country = 'Colombia'\n    AND needs_repair = TRUE\n  UNION ALL\n  SELECT 'hospital'  AS entity_type,\n         name\n  FROM hospitals\n  WHERE country = 'Colombia'\n    AND needs_repair = TRUE\n)\nSELECT\n  cs.total_schools,\n  ch.total_hospitals,\n  r.entity_type,\n  r.name AS needs_repair_name\nFROM col_schools cs\nCROSS JOIN col_hospitals ch\nLEFT JOIN repairs r\n  ON TRUE;", "raw_model_output": "WITH col_schools AS (\n  SELECT COUNT(*) AS total_schools\n  FROM schools\n  WHERE country = 'Colombia'\n),\ncol_hospitals AS (\n  SELECT COUNT(*) AS total_hospitals\n  FROM hospitals\n  WHERE country = 'Colombia'\n),\nrepairs AS (\n  SELECT 'school'    AS entity_type,\n         name\n  FROM schools\n  WHERE country = 'Colombia'\n    AND needs_repair = TRUE\n  UNION ALL\n  SELECT 'hospital'  AS entity_type,\n         name\n  FROM hospitals\n  WHERE country = 'Colombia'\n    AND needs_repair = TRUE\n)\nSELECT\n  cs.total_schools,\n  ch.total_hospitals,\n  r.entity_type,\n  r.name AS needs_repair_name\nFROM col_schools cs\nCROSS JOIN col_hospitals ch\nLEFT JOIN repairs r\n  ON TRUE;", "latency_sec": 11.517385005950928, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 125, "prompt_eval_sec": null, "tokens_completion": 1808, "completion_eval_sec": null, "tokens_total": 1933, "tokens_per_sec": 167.83323636409102, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries have different structures and outputs. The reference query returns two rows (Schools/Hospitals) with aggregated counts and repairs, while the generated query produces a Cartesian product of totals with individual repair records, resulting in multiple rows with different column structures."}
{"example_id": 907, "sql_complexity": "set operations", "prompt": "What is the total quantity of items with type 'E' or type 'F' in warehouse O and warehouse P?", "context": "CREATE TABLE warehouse_o(item_id INT, item_type VARCHAR(10), quantity INT);CREATE TABLE warehouse_p(item_id INT, item_type VARCHAR(10), quantity INT);INSERT INTO warehouse_o(item_id, item_type, quantity) VALUES (1, 'E', 200), (2, 'F', 300), (3, 'E', 50), (4, 'F', 400);INSERT INTO warehouse_p(item_id, item_type, quantity) VALUES (1, 'E', 150), (2, 'F', 250), (3, 'E', 40), (4, 'F', 350);", "reference_sql": "SELECT quantity FROM warehouse_o WHERE item_type IN ('E', 'F') UNION ALL SELECT quantity FROM warehouse_p WHERE item_type IN ('E', 'F');", "generated_sql": "SELECT SUM(quantity) AS total_quantity\nFROM (\n  SELECT quantity\n  FROM warehouse_o\n  WHERE item_type IN ('E','F')\n  UNION ALL\n  SELECT quantity\n  FROM warehouse_p\n  WHERE item_type IN ('E','F')\n) AS combined;", "raw_model_output": "SELECT SUM(quantity) AS total_quantity\nFROM (\n  SELECT quantity\n  FROM warehouse_o\n  WHERE item_type IN ('E','F')\n  UNION ALL\n  SELECT quantity\n  FROM warehouse_p\n  WHERE item_type IN ('E','F')\n) AS combined;", "latency_sec": 3.312490940093994, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 222, "prompt_eval_sec": null, "tokens_completion": 267, "completion_eval_sec": null, "tokens_total": 489, "tokens_per_sec": 147.62304526820057, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns individual quantity values from both tables using UNION ALL, while the Generated SQL aggregates all quantities into a single summed value. The first produces multiple rows of raw data, while the second produces a single summary value."}
{"example_id": 1400, "sql_complexity": "single join", "prompt": "What is the maximum co-ownership duration for properties in the neighborhood of 'Chinatown' in San Francisco?'", "context": "CREATE TABLE sf_neighborhoods (neighborhood_id INT, name VARCHAR(255), city VARCHAR(255)); INSERT INTO sf_neighborhoods (neighborhood_id, name, city) VALUES (1, 'Chinatown', 'San Francisco'); CREATE TABLE co_ownership (co_ownership_id INT, property_id INT, co_owner_id INT, start_date DATE, end_date DATE); INSERT INTO co_ownership (co_ownership_id, property_id, co_owner_id, start_date, end_date) VALUES (1, 1, 2, '2010-01-01', '2020-01-01'), (2, 2, 3, '2015-01-01', '2022-01-01'); CREATE TABLE properties (property_id INT, city VARCHAR(255)); INSERT INTO properties (property_id, city) VALUES (1, 'San Francisco'), (2, 'San Francisco');", "reference_sql": "SELECT MAX(DATEDIFF(end_date, start_date)) as max_duration FROM co_ownership JOIN properties ON co_ownership.property_id = properties.property_id WHERE properties.city = 'San Francisco' AND name = 'Chinatown';", "generated_sql": "SELECT MAX(DATEDIFF(co.end_date, co.start_date)) AS max_co_ownership_duration_days\nFROM co_ownership AS co\nJOIN properties AS p\n  ON co.property_id = p.property_id\nJOIN sf_neighborhoods AS n\n  ON p.city = n.city\nWHERE n.name = 'Chinatown'\n  AND n.city = 'San Francisco';", "raw_model_output": "SELECT MAX(DATEDIFF(co.end_date, co.start_date)) AS max_co_ownership_duration_days\nFROM co_ownership AS co\nJOIN properties AS p\n  ON co.property_id = p.property_id\nJOIN sf_neighborhoods AS n\n  ON p.city = n.city\nWHERE n.name = 'Chinatown'\n  AND n.city = 'San Francisco';", "latency_sec": 7.601786136627197, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 279, "prompt_eval_sec": null, "tokens_completion": 1247, "completion_eval_sec": null, "tokens_total": 1526, "tokens_per_sec": 200.7422956359391, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references 'name' in the WHERE clause, but the 'name' column exists in sf_neighborhoods, which is not joined in the Reference SQL. The Generated SQL correctly joins sf_neighborhoods and filters on n.name = 'Chinatown'. The Reference SQL would result in an error due to missing join, making them non-equivalent."}
{"example_id": 5248, "sql_complexity": "window functions", "prompt": "Find the top 5 games by rating", "context": "CREATE TABLE games (game_id INT PRIMARY KEY, name VARCHAR(50), genre VARCHAR(50), rating DECIMAL(3,2));", "reference_sql": "SELECT * FROM (SELECT name, rating, ROW_NUMBER() OVER (ORDER BY rating DESC) as rn FROM games) t WHERE rn <= 5;", "generated_sql": "SELECT\n  game_id,\n  name,\n  genre,\n  rating\nFROM\n  games\nORDER BY\n  rating DESC\nFETCH FIRST 5 ROWS ONLY;", "raw_model_output": "SELECT\n  game_id,\n  name,\n  genre,\n  rating\nFROM\n  games\nORDER BY\n  rating DESC\nFETCH FIRST 5 ROWS ONLY;", "latency_sec": 3.7371389865875244, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 103, "prompt_eval_sec": null, "tokens_completion": 310, "completion_eval_sec": null, "tokens_total": 413, "tokens_per_sec": 110.51234687343558, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL returns only 'name', 'rating', and 'rn' columns, while the Generated SQL returns all columns (game_id, name, genre, rating). Additionally, the Reference SQL uses ROW_NUMBER() which assigns unique ranks, whereas the Generated SQL uses FETCH FIRST 5 which may return different results if there are tie values in the rating column."}
{"example_id": 778, "sql_complexity": "single join", "prompt": "What is the maximum property price in wheelchair-accessible neighborhoods in Singapore?", "context": "CREATE TABLE Singapore_Neighborhoods (Neighborhood_Name TEXT, Wheelchair_Accessibility BOOLEAN); INSERT INTO Singapore_Neighborhoods (Neighborhood_Name, Wheelchair_Accessibility) VALUES ('Orchard', true), ('Marina Bay', true), ('Chinatown', false), ('Little India', false), ('Bugis', true); CREATE TABLE Singapore_Properties (Neighborhood_Name TEXT, Property_Price INTEGER); INSERT INTO Singapore_Properties (Neighborhood_Name, Property_Price) VALUES ('Orchard', 2000000), ('Marina Bay', 3000000), ('Chinatown', 1500000), ('Little India', 1200000), ('Bugis', 1800000);", "reference_sql": "SELECT MAX(Singapore_Properties.Property_Price) FROM Singapore_Properties INNER JOIN Singapore_Neighborhoods ON Singapore_Properties.Neighborhood_Name = Singapore_Neighborhoods.Neighborhood_Name WHERE Singapore_Neighborhoods.Wheelchair_Accessibility = true;", "generated_sql": "SELECT MAX(sp.Property_Price) AS Max_Property_Price\nFROM Singapore_Properties sp\nJOIN Singapore_Neighborhoods sn\n  ON sp.Neighborhood_Name = sn.Neighborhood_Name\nWHERE sn.Wheelchair_Accessibility = TRUE;", "raw_model_output": "SELECT MAX(sp.Property_Price) AS Max_Property_Price\nFROM Singapore_Properties sp\nJOIN Singapore_Neighborhoods sn\n  ON sp.Neighborhood_Name = sn.Neighborhood_Name\nWHERE sn.Wheelchair_Accessibility = TRUE;", "latency_sec": 2.4250760078430176, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 225, "prompt_eval_sec": null, "tokens_completion": 261, "completion_eval_sec": null, "tokens_total": 486, "tokens_per_sec": 200.40608971768782, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between Singapore_Properties and Singapore_Neighborhoods on Neighborhood_Name, filter for wheelchair-accessible neighborhoods, and select the maximum property price. The generated query uses table aliases and slightly different formatting, but the semantic logic remains identical."}
{"example_id": 3859, "sql_complexity": "aggregation", "prompt": "What is the total number of mental health parity violations by month and year?", "context": "CREATE TABLE mental_health_parity_reports (report_id INT, violation_date DATE); INSERT INTO mental_health_parity_reports (report_id, violation_date) VALUES (1, '2022-01-01'), (2, '2022-02-15'), (3, '2022-03-05'), (4, '2022-04-20'), (5, '2021-06-12'), (6, '2021-07-28');", "reference_sql": "SELECT EXTRACT(MONTH FROM violation_date) AS month, EXTRACT(YEAR FROM violation_date) AS year, COUNT(*) FROM mental_health_parity_reports GROUP BY month, year;", "generated_sql": "SELECT\n  EXTRACT(YEAR FROM violation_date)   AS violation_year,\n  EXTRACT(MONTH FROM violation_date)  AS violation_month,\n  COUNT(*)                            AS total_violations\nFROM mental_health_parity_reports\nGROUP BY\n  EXTRACT(YEAR FROM violation_date),\n  EXTRACT(MONTH FROM violation_date)\nORDER BY\n  violation_year,\n  violation_month;", "raw_model_output": "SELECT\n  EXTRACT(YEAR FROM violation_date)   AS violation_year,\n  EXTRACT(MONTH FROM violation_date)  AS violation_month,\n  COUNT(*)                            AS total_violations\nFROM mental_health_parity_reports\nGROUP BY\n  EXTRACT(YEAR FROM violation_date),\n  EXTRACT(MONTH FROM violation_date)\nORDER BY\n  violation_year,\n  violation_month;", "latency_sec": 2.4680702686309814, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 178, "prompt_eval_sec": null, "tokens_completion": 292, "completion_eval_sec": null, "tokens_total": 470, "tokens_per_sec": 190.43217933203547, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries group by extracted year and month from violation_date, count violations, and produce the same numerical results. The differences are purely in column aliases (month/year vs violation_month/violation_year) and the addition of an ORDER BY clause in the generated query, which does not affect the semantic equivalence of the result set."}
{"example_id": 3551, "sql_complexity": "multiple_joins", "prompt": "List all artists who have performed in New York and Chicago, along with their highest-earning performance.", "context": "CREATE TABLE artist_events (artist_id INT, event_id INT, earnings DECIMAL(5,2)); CREATE TABLE artists (id INT, name VARCHAR(50)); CREATE TABLE events (id INT, city VARCHAR(20));", "reference_sql": "SELECT artists.name, MAX(artist_events.earnings) FROM artists INNER JOIN artist_events ON artists.id = artist_events.artist_id INNER JOIN events ON artist_events.event_id = events.id WHERE city IN ('New York', 'Chicago') GROUP BY artists.name;", "generated_sql": "SELECT ae.artist_id\n  FROM artist_events ae\n  JOIN events e ON ae.event_id = e.id\n  WHERE e.city IN ('New York', 'Chicago')\n  GROUP BY ae.artist_id\n  HAVING COUNT(DISTINCT e.city) = 2\n),\nmax_earnings AS (\n  SELECT artist_id, MAX(earnings) AS max_earnings\n  FROM artist_events\n  GROUP BY artist_id\n)\nSELECT \n  a.name,\n  ae.event_id,\n  e.city,\n  ae.earnings\nFROM artists a\nJOIN qualified_artists qa \n  ON a.id = qa.artist_id\nJOIN max_earnings me \n  ON a.id = me.artist_id\nJOIN artist_events ae \n  ON ae.artist_id = a.id \n AND ae.earnings = me.max_earnings\nJOIN events e \n  ON ae.event_id = e.id;", "raw_model_output": "WITH qualified_artists AS (\n  SELECT ae.artist_id\n  FROM artist_events ae\n  JOIN events e ON ae.event_id = e.id\n  WHERE e.city IN ('New York', 'Chicago')\n  GROUP BY ae.artist_id\n  HAVING COUNT(DISTINCT e.city) = 2\n),\nmax_earnings AS (\n  SELECT artist_id, MAX(earnings) AS max_earnings\n  FROM artist_events\n  GROUP BY artist_id\n)\nSELECT \n  a.name,\n  ae.event_id,\n  e.city,\n  ae.earnings\nFROM artists a\nJOIN qualified_artists qa \n  ON a.id = qa.artist_id\nJOIN max_earnings me \n  ON a.id = me.artist_id\nJOIN artist_events ae \n  ON ae.artist_id = a.id \n AND ae.earnings = me.max_earnings\nJOIN events e \n  ON ae.event_id = e.id;", "latency_sec": 13.959151983261108, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 131, "prompt_eval_sec": null, "tokens_completion": 2388, "completion_eval_sec": null, "tokens_total": 2519, "tokens_per_sec": 180.45508803261245, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query returns artist names and their maximum earnings from events in New York or Chicago, grouped by name. The generated query includes additional complexity: it first filters artists with events in both cities (via HAVING COUNT(DISTINCT e.city) = 2), then joins with max_earnings to find specific event records matching each artist's maximum earnings. The output columns also differ (e.g., event_id, city, earnings in generated query). The semantic goals and results differ significantly."}
{"example_id": 5168, "sql_complexity": "aggregation", "prompt": "Get the number of renewable energy projects in Australia for each project type.", "context": "CREATE TABLE renewable_projects (id INT PRIMARY KEY, project_name VARCHAR(255), project_location VARCHAR(255), project_type VARCHAR(255), capacity_mw FLOAT);", "reference_sql": "SELECT project_type, COUNT(*) FROM renewable_projects WHERE project_location = 'Australia' GROUP BY project_type;", "generated_sql": "SELECT\n  project_type,\n  COUNT(*) AS project_count\nFROM\n  renewable_projects\nWHERE\n  project_location = 'Australia'\nGROUP BY\n  project_type;", "raw_model_output": "SELECT\n  project_type,\n  COUNT(*) AS project_count\nFROM\n  renewable_projects\nWHERE\n  project_location = 'Australia'\nGROUP BY\n  project_type;", "latency_sec": 2.632906913757324, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 113, "prompt_eval_sec": null, "tokens_completion": 182, "completion_eval_sec": null, "tokens_total": 295, "tokens_per_sec": 112.04345981948006, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select project_type and count the number of projects in Australia. The generated query adds an alias 'project_count' for the count, but this does not affect the semantic result. The WHERE clause, GROUP BY, and aggregate function are identical in both queries."}
{"example_id": 4916, "sql_complexity": "aggregation", "prompt": "What is the maximum revenue generated from selling Yttrium in India in the past 3 years?", "context": "CREATE TABLE Yttrium_Sales (id INT PRIMARY KEY, year INT, country VARCHAR(20), quantity INT, price PER_KG); INSERT INTO Yttrium_Sales (id, year, country, quantity, price) VALUES (1, 2019, 'India', 120, 40), (2, 2020, 'India', 130, 45), (3, 2021, 'India', 140, 50), (4, 2019, 'China', 150, 35), (5, 2020, 'China', 160, 40), (6, 2021, 'China', 170, 45);", "reference_sql": "SELECT MAX(quantity * price) FROM Yttrium_Sales WHERE country = 'India' GROUP BY year ORDER BY year DESC LIMIT 3;", "generated_sql": "SELECT \n  MAX(quantity * price) AS max_revenue\nFROM \n  Yttrium_Sales\nWHERE \n  country = 'India'\n  AND year BETWEEN EXTRACT(YEAR FROM CURRENT_DATE) - 2 \n              AND EXTRACT(YEAR FROM CURRENT_DATE);", "raw_model_output": "SELECT \n  MAX(quantity * price) AS max_revenue\nFROM \n  Yttrium_Sales\nWHERE \n  country = 'India'\n  AND year BETWEEN EXTRACT(YEAR FROM CURRENT_DATE) - 2 \n              AND EXTRACT(YEAR FROM CURRENT_DATE);", "latency_sec": 6.355992078781128, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 233, "prompt_eval_sec": null, "tokens_completion": 588, "completion_eval_sec": null, "tokens_total": 821, "tokens_per_sec": 129.1694498394405, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL groups by year and returns the maximum quantity*price per year (3 rows), while the Generated SQL calculates a single maximum value across all specified years without grouping. The Reference SQL also explicitly limits to 3 years, whereas the Generated SQL uses a dynamic year range. The output structures and semantics differ."}
{"example_id": 812, "sql_complexity": "multiple_joins", "prompt": "What is the average salary of 'engineer' workers in each factory?", "context": "CREATE TABLE factories (factory_id INT, factory_name VARCHAR(20)); INSERT INTO factories VALUES (1, 'Factory X'), (2, 'Factory Y'), (3, 'Factory Z'); CREATE TABLE roles (role_id INT, role_name VARCHAR(20)); INSERT INTO roles VALUES (1, 'engineer'), (2, 'manager'), (3, 'assistant'); CREATE TABLE workers (worker_id INT, factory_id INT, role_id INT, salary DECIMAL(5,2)); INSERT INTO workers VALUES (1, 1, 1, 50000.00), (2, 1, 2, 70000.00), (3, 2, 1, 55000.00), (4, 2, 3, 40000.00), (5, 3, 1, 60000.00);", "reference_sql": "SELECT f.factory_name, AVG(salary) FROM workers w INNER JOIN factories f ON w.factory_id = f.factory_id INNER JOIN roles r ON w.role_id = r.role_id WHERE r.role_name = 'engineer' GROUP BY f.factory_name;", "generated_sql": "SELECT \n  f.factory_id, \n  f.factory_name, \n  AVG(w.salary) AS avg_salary\nFROM workers w\nJOIN roles r \n  ON w.role_id = r.role_id\nJOIN factories f \n  ON w.factory_id = f.factory_id\nWHERE r.role_name = 'engineer'\nGROUP BY \n  f.factory_id, \n  f.factory_name;", "raw_model_output": "SELECT \n  f.factory_id, \n  f.factory_name, \n  AVG(w.salary) AS avg_salary\nFROM workers w\nJOIN roles r \n  ON w.role_id = r.role_id\nJOIN factories f \n  ON w.factory_id = f.factory_id\nWHERE r.role_name = 'engineer'\nGROUP BY \n  f.factory_id, \n  f.factory_name;", "latency_sec": 3.452495813369751, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 260, "prompt_eval_sec": null, "tokens_completion": 289, "completion_eval_sec": null, "tokens_total": 549, "tokens_per_sec": 159.01539920019707, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in selected columns and grouping. The Reference SQL returns only factory_name and average salary, while the Generated SQL includes factory_id, factory_name, and average salary. Additionally, the GROUP BY clause in the Generated SQL includes factory_id (which is functionally dependent on factory_name but not explicitly required in the Reference SQL). The extra column in the Generated SQL makes the result sets non-equivalent."}
{"example_id": 5784, "sql_complexity": "set operations", "prompt": "List the number of users who have completed a workout of a specific type (e.g. Running) and have a membership status of 'Active'.", "context": "CREATE TABLE workouts (id INT, user_id INT, workout_type VARCHAR(20)); CREATE TABLE members (id INT, name VARCHAR(50), membership_status VARCHAR(20), state VARCHAR(20)); INSERT INTO workouts (id, user_id, workout_type) VALUES (1, 1, 'Running'), (2, 1, 'Cycling'), (3, 2, 'Running'), (4, 3, 'Cycling'), (5, 3, 'Swimming'), (6, 4, 'Running'), (7, 4, 'Swimming'); INSERT INTO members (id, name, membership_status, state) VALUES (1, 'John Doe', 'Active', 'Texas'), (2, 'Jane Doe', 'Inactive', 'California'), (3, 'Bob Smith', 'Active', 'Texas'), (4, 'Alice Johnson', 'Active', 'California');", "reference_sql": "SELECT COUNT(*) FROM (SELECT user_id FROM workouts WHERE workout_type = 'Running' INTERSECT SELECT id FROM members WHERE membership_status = 'Active') AS user_set;", "generated_sql": "SELECT COUNT(DISTINCT w.user_id) AS active_user_count\nFROM workouts w\nJOIN members m\n  ON w.user_id = m.id\nWHERE w.workout_type = 'Running'\n  AND m.membership_status = 'Active';", "raw_model_output": "SELECT COUNT(DISTINCT w.user_id) AS active_user_count\nFROM workouts w\nJOIN members m\n  ON w.user_id = m.id\nWHERE w.workout_type = 'Running'\n  AND m.membership_status = 'Active';", "latency_sec": 4.645040988922119, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 279, "prompt_eval_sec": null, "tokens_completion": 325, "completion_eval_sec": null, "tokens_total": 604, "tokens_per_sec": 130.03114535274705, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of distinct users who have at least one 'Running' workout and are active members. The Reference SQL uses INTERSECT to find the intersection of user_ids from workouts and active members, while the Generated SQL joins the tables with explicit filters and counts distinct user_ids. Both approaches yield the same result."}
{"example_id": 3038, "sql_complexity": "subqueries", "prompt": "What is the total assets of clients who have invested in mutual funds but not in stocks?", "context": "CREATE TABLE clients (client_id INT, name TEXT, age INT, gender TEXT, total_assets DECIMAL(10,2)); INSERT INTO clients VALUES (1, 'John Doe', 35, 'Male', 250000.00), (2, 'Jane Smith', 45, 'Female', 500000.00); CREATE TABLE investments (client_id INT, investment_type TEXT); INSERT INTO investments VALUES (1, 'Stocks'), (1, 'Bonds'), (2, 'Stocks'), (3, 'Mutual Funds');", "reference_sql": "SELECT c.total_assets FROM clients c INNER JOIN investments i ON c.client_id = i.client_id WHERE i.investment_type = 'Mutual Funds' AND c.client_id NOT IN (SELECT client_id FROM investments WHERE investment_type = 'Stocks');", "generated_sql": "SELECT SUM(c.total_assets) AS total_assets\nFROM clients c\nJOIN investments i_mut ON c.client_id = i_mut.client_id\n  AND i_mut.investment_type = 'Mutual Funds'\nWHERE NOT EXISTS (\n  SELECT 1\n  FROM investments i_stk\n  WHERE i_stk.client_id = c.client_id\n    AND i_stk.investment_type = 'Stocks'\n);", "raw_model_output": "SELECT SUM(c.total_assets) AS total_assets\nFROM clients c\nJOIN investments i_mut ON c.client_id = i_mut.client_id\n  AND i_mut.investment_type = 'Mutual Funds'\nWHERE NOT EXISTS (\n  SELECT 1\n  FROM investments i_stk\n  WHERE i_stk.client_id = c.client_id\n    AND i_stk.investment_type = 'Stocks'\n);", "latency_sec": 5.424849987030029, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 195, "prompt_eval_sec": null, "tokens_completion": 423, "completion_eval_sec": null, "tokens_total": 618, "tokens_per_sec": 113.92020083090623, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns individual client total_assets values, while the Generated SQL aggregates them with SUM. The logic of filtering clients with 'Mutual Funds' and no 'Stocks' investments is equivalent, but the output structure differs (row-level vs. aggregated total)."}
{"example_id": 1078, "sql_complexity": "basic SQL", "prompt": "What is the maximum and minimum temperature difference between any two Arctic research stations?", "context": "CREATE TABLE arctic_stations (id INT, name TEXT, location TEXT, temperature DECIMAL(5,2)); INSERT INTO arctic_stations (id, name, location, temperature) VALUES (1, 'Station A', 'Greenland', 2.3), (2, 'Station B', 'Canada', -5.2);", "reference_sql": "SELECT a.name as station1, b.name as station2, MAX(ABS(a.temperature - b.temperature)) as temp_diff FROM arctic_stations a, arctic_stations b ORDER BY temp_diff DESC LIMIT 1", "generated_sql": "SELECT \n  MAX(ABS(a.temperature - b.temperature)) AS max_temp_diff,\n  MIN(ABS(a.temperature - b.temperature)) AS min_temp_diff\nFROM arctic_stations a\nJOIN arctic_stations b\n  ON a.id < b.id;", "raw_model_output": "SELECT \n  MAX(ABS(a.temperature - b.temperature)) AS max_temp_diff,\n  MIN(ABS(a.temperature - b.temperature)) AS min_temp_diff\nFROM arctic_stations a\nJOIN arctic_stations b\n  ON a.id < b.id;", "latency_sec": 5.302300930023193, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 152, "prompt_eval_sec": null, "tokens_completion": 393, "completion_eval_sec": null, "tokens_total": 545, "tokens_per_sec": 102.78556558607399, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query returns the single pair of stations with the maximum temperature difference, including station names and the max difference. The generated query calculates both maximum and minimum temperature differences across all unique station pairs, returning different columns and values. The result structures and objectives differ significantly."}
{"example_id": 5015, "sql_complexity": "basic SQL", "prompt": "Calculate the average recycling rate", "context": "CREATE TABLE recycling_rates (id INT PRIMARY KEY, location VARCHAR(50), rate FLOAT);", "reference_sql": "SELECT AVG(rate) FROM recycling_rates;", "generated_sql": "SELECT AVG(rate) AS average_recycling_rate\nFROM recycling_rates;", "raw_model_output": "SELECT AVG(rate) AS average_recycling_rate\nFROM recycling_rates;", "latency_sec": 1.9048669338226318, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 90, "prompt_eval_sec": null, "tokens_completion": 97, "completion_eval_sec": null, "tokens_total": 187, "tokens_per_sec": 98.16958690376015, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average of the 'rate' column from the 'recycling_rates' table. The generated query adds an alias ('average_recycling_rate') to the computed average, but this does not affect the actual value returned. The semantic result (the average value) remains the same."}
{"example_id": 1533, "sql_complexity": "subqueries", "prompt": "Which programs had the highest volunteer participation rate in the last quarter?", "context": "CREATE TABLE Programs (ProgramID INT, ProgramName TEXT, Budget DECIMAL(10,2), NumVolunteers INT); CREATE TABLE VolunteerEvents (EventID INT, ProgramID INT, EventDate DATE, NumVolunteers INT);", "reference_sql": "SELECT p.ProgramName, COUNT(v.EventID) / (SELECT COUNT(*) FROM VolunteerEvents WHERE EventDate >= DATEADD(quarter, -1, GETDATE())) * 100.0 AS VolunteerParticipationRate FROM Programs p INNER JOIN VolunteerEvents v ON p.ProgramID = v.ProgramID WHERE v.EventDate >= DATEADD(quarter, -1, GETDATE()) GROUP BY p.ProgramName ORDER BY VolunteerParticipationRate DESC;", "generated_sql": "SELECT\n    p.ProgramID,\n    p.ProgramName,\n    SUM(e.NumVolunteers) * 1.0 / NULLIF(p.NumVolunteers, 0) AS participation_rate\n  FROM Programs p\n  JOIN VolunteerEvents e\n    ON p.ProgramID = e.ProgramID\n  WHERE e.EventDate >= DATE_TRUNC('quarter', CURRENT_DATE) - INTERVAL '3 months'\n    AND e.EventDate <  DATE_TRUNC('quarter', CURRENT_DATE)\n  GROUP BY p.ProgramID, p.ProgramName\n),\nmax_participation AS (\n  SELECT MAX(participation_rate) AS max_rate\n  FROM participation\n)\nSELECT\n  p.ProgramID,\n  p.ProgramName,\n  p.participation_rate\nFROM participation p\nJOIN max_participation m\n  ON p.participation_rate = m.max_rate;", "raw_model_output": "WITH participation AS (\n  SELECT\n    p.ProgramID,\n    p.ProgramName,\n    SUM(e.NumVolunteers) * 1.0 / NULLIF(p.NumVolunteers, 0) AS participation_rate\n  FROM Programs p\n  JOIN VolunteerEvents e\n    ON p.ProgramID = e.ProgramID\n  WHERE e.EventDate >= DATE_TRUNC('quarter', CURRENT_DATE) - INTERVAL '3 months'\n    AND e.EventDate <  DATE_TRUNC('quarter', CURRENT_DATE)\n  GROUP BY p.ProgramID, p.ProgramName\n),\nmax_participation AS (\n  SELECT MAX(participation_rate) AS max_rate\n  FROM participation\n)\nSELECT\n  p.ProgramID,\n  p.ProgramName,\n  p.participation_rate\nFROM participation p\nJOIN max_participation m\n  ON p.participation_rate = m.max_rate;", "latency_sec": 15.512993097305298, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 126, "prompt_eval_sec": null, "tokens_completion": 1351, "completion_eval_sec": null, "tokens_total": 1477, "tokens_per_sec": 95.2105110042603, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in multiple ways.  The reference query calculates a participation rate as a percentage of events in the last quarter relative to total events in that period, while the generated query calculates a ratio of volunteer hours to program volunteer count.  The reference query returns all programs ordered by participation rate, while the generated query only returns the program(s) with the highest participation rate.  Additionally, the date filtering logic differs, potentially leading to different sets of events being considered."}
{"example_id": 4021, "sql_complexity": "subqueries", "prompt": "What is the percentage of energy efficiency improvement, per sector, compared to 2015 levels?", "context": "CREATE TABLE energy_efficiency (id INT, sector VARCHAR(50), year INT, efficiency FLOAT); INSERT INTO energy_efficiency (id, sector, year, efficiency) VALUES (1, 'Industry', 2015, 100.0), (2, 'Industry', 2020, 105.0), (3, 'Residential', 2015, 100.0), (4, 'Residential', 2020, 103.0);", "reference_sql": "SELECT sector, (SUM(efficiency) / (SELECT SUM(efficiency) FROM energy_efficiency WHERE year = 2015 AND sector = e.sector) * 100.0) - 100.0 AS improvement FROM energy_efficiency e WHERE year = 2020 GROUP BY sector;", "generated_sql": "SELECT e2020.sector,\n       (e2020.efficiency - e2015.efficiency) / e2015.efficiency * 100 AS improvement_pct\nFROM energy_efficiency e2015\nJOIN energy_efficiency e2020\n  ON e2015.sector = e2020.sector\nWHERE e2015.year = 2015\n  AND e2020.year = 2020;", "raw_model_output": "SELECT e2020.sector,\n       (e2020.efficiency - e2015.efficiency) / e2015.efficiency * 100 AS improvement_pct\nFROM energy_efficiency e2015\nJOIN energy_efficiency e2020\n  ON e2015.sector = e2020.sector\nWHERE e2015.year = 2015\n  AND e2020.year = 2020;", "latency_sec": 5.408413410186768, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 180, "prompt_eval_sec": null, "tokens_completion": 747, "completion_eval_sec": null, "tokens_total": 927, "tokens_per_sec": 171.39961938819098, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the percentage improvement for each sector by comparing the sum of efficiencies in 2020 to the sum in 2015. The Generated SQL computes the percentage change for individual rows by joining 2015 and 2020 data. While they produce the same results for the sample data (where each sector has one entry per year), they differ in general cases. If a sector has multiple entries, the Reference SQL aggregates values (summing efficiencies), while the Generated SQL calculates per-row differences, leading to different result sets (e.g., multiple rows vs. grouped results). Thus, they are not semantically equivalent in all scenarios."}
{"example_id": 1551, "sql_complexity": "single join", "prompt": "How many unique donors made donations in the healthcare industry in Q3 2022?", "context": "CREATE TABLE donations (id INT, donor_id INT, amount FLOAT, donation_date DATE); INSERT INTO donations (id, donor_id, amount, donation_date) VALUES (1, 7, 100, '2022-07-01'); INSERT INTO donations (id, donor_id, amount, donation_date) VALUES (2, 8, 200, '2022-09-15'); INSERT INTO donors (id, name, industry, first_donation_date DATE) VALUES (7, 'Charlie Davis', 'Healthcare', '2022-07-01'); INSERT INTO donors (id, name, industry, first_donation_date DATE) VALUES (8, 'Dana Wilson', 'Healthcare', '2022-09-15');", "reference_sql": "SELECT COUNT(DISTINCT donor_id) FROM donations d JOIN donors don ON d.donor_id = don.id WHERE industry = 'Healthcare' AND donation_date BETWEEN '2022-07-01' AND '2022-09-30';", "generated_sql": "SELECT COUNT(DISTINCT d.donor_id) AS unique_healthcare_donors_q3_2022\nFROM donations d\nJOIN donors dr ON d.donor_id = dr.id\nWHERE dr.industry = 'Healthcare'\n  AND d.donation_date BETWEEN '2022-07-01' AND '2022-09-30';", "raw_model_output": "SELECT COUNT(DISTINCT d.donor_id) AS unique_healthcare_donors_q3_2022\nFROM donations d\nJOIN donors dr ON d.donor_id = dr.id\nWHERE dr.industry = 'Healthcare'\n  AND d.donation_date BETWEEN '2022-07-01' AND '2022-09-30';", "latency_sec": 3.6497867107391357, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 235, "prompt_eval_sec": null, "tokens_completion": 410, "completion_eval_sec": null, "tokens_total": 645, "tokens_per_sec": 176.72265562865672, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count distinct donor_ids from donations joined with donors where industry is 'Healthcare' and donation_date falls between '2022-07-01' and '2022-09-30'. The only differences are table alias names (don vs dr) and a column alias in the generated query, which don't affect semantic meaning."}
{"example_id": 2592, "sql_complexity": "window functions", "prompt": "What is the third highest account balance for Shariah-compliant finance customers?", "context": "CREATE TABLE shariah_compliant_finance(customer_id INT, account_balance DECIMAL(10, 2)); INSERT INTO shariah_compliant_finance VALUES (1, 5000), (2, 7000), (3, 6000), (4, 8000), (5, 9000);", "reference_sql": "SELECT account_balance FROM (SELECT account_balance, RANK() OVER (ORDER BY account_balance DESC) as rn FROM shariah_compliant_finance) t WHERE rn = 3;", "generated_sql": "SELECT account_balance\nFROM (\n  SELECT \n    account_balance,\n    DENSE_RANK() OVER (ORDER BY account_balance DESC) AS rnk\n  FROM shariah_compliant_finance\n) AS ranked_balances\nWHERE rnk = 3;", "raw_model_output": "SELECT account_balance\nFROM (\n  SELECT \n    account_balance,\n    DENSE_RANK() OVER (ORDER BY account_balance DESC) AS rnk\n  FROM shariah_compliant_finance\n) AS ranked_balances\nWHERE rnk = 3;", "latency_sec": 7.7737226486206055, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 150, "prompt_eval_sec": null, "tokens_completion": 585, "completion_eval_sec": null, "tokens_total": 735, "tokens_per_sec": 94.54929552065005, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the account balance with the third highest value. Since all account balances are unique, RANK() and DENSE_RANK() produce identical rankings in this specific case. The reference query uses RANK() and the generated query uses DENSE_RANK(), but they yield the same result (7000) because there are no duplicate values to create ranking gaps."}
{"example_id": 3795, "sql_complexity": "single join", "prompt": "What is the total quantity of unsold garments for each manufacturer based in 'Italy' or 'Spain'?", "context": "CREATE TABLE manufacturers (id INT PRIMARY KEY, name VARCHAR(255), country VARCHAR(255)); CREATE TABLE garments (id INT PRIMARY KEY, manufacturer_id INT, quantity_manufactured INT, quantity_sold INT);", "reference_sql": "SELECT m.name, SUM(g.quantity_manufactured - g.quantity_sold) as total_unsold_quantity FROM manufacturers m JOIN garments g ON m.id = g.manufacturer_id WHERE m.country IN ('Italy', 'Spain') GROUP BY m.name;", "generated_sql": "SELECT \n  m.name AS manufacturer_name,\n  SUM(g.quantity_manufactured - g.quantity_sold) AS total_unsold\nFROM manufacturers m\nJOIN garments g \n  ON m.id = g.manufacturer_id\nWHERE m.country IN ('Italy', 'Spain')\nGROUP BY m.name;", "raw_model_output": "SELECT \n  m.name AS manufacturer_name,\n  SUM(g.quantity_manufactured - g.quantity_sold) AS total_unsold\nFROM manufacturers m\nJOIN garments g \n  ON m.id = g.manufacturer_id\nWHERE m.country IN ('Italy', 'Spain')\nGROUP BY m.name;", "latency_sec": 3.3971850872039795, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 131, "prompt_eval_sec": null, "tokens_completion": 399, "completion_eval_sec": null, "tokens_total": 530, "tokens_per_sec": 156.01151729893274, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. Both perform the same operations: joining manufacturers with garments, filtering by country ('Italy'/'Spain'), grouping by manufacturer name, and calculating the total unsold quantity as the sum of (quantity_manufactured - quantity_sold). The only differences are column aliases ('name' vs 'manufacturer_name', 'total_unsold_quantity' vs 'total_unsold'), which do not affect the result's correctness."}
{"example_id": 4138, "sql_complexity": "window functions", "prompt": "How many lifelong learning courses has a student with ID '2' completed, in chronological order?", "context": "CREATE TABLE lifelong_learning (student_id INT, course_id INT, completion_date DATE); INSERT INTO lifelong_learning VALUES (2, 1001, '2015-01-01'), (2, 1002, '2016-01-01');", "reference_sql": "SELECT student_id, course_id, COUNT(course_id) OVER (PARTITION BY student_id ORDER BY completion_date) as completed_courses FROM lifelong_learning WHERE student_id = 2;", "generated_sql": "SELECT COUNT(*) AS completed_courses\nFROM lifelong_learning\nWHERE student_id = 2;", "raw_model_output": "SELECT COUNT(*) AS completed_courses\nFROM lifelong_learning\nWHERE student_id = 2;", "latency_sec": 5.184475898742676, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 137, "prompt_eval_sec": null, "tokens_completion": 805, "completion_eval_sec": null, "tokens_total": 942, "tokens_per_sec": 181.69628297981887, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns multiple rows with a cumulative count per course completion date for student_id=2, while the Generated SQL returns a single row with the total count of courses for student_id=2. The first query uses a window function to show incremental counts, whereas the second simply aggregates all rows."}
{"example_id": 312, "sql_complexity": "aggregation", "prompt": "List the top 3 most represented ethnicities in movies produced in the USA.", "context": "CREATE TABLE movies (title VARCHAR(255), production_country VARCHAR(64), lead_actor_ethnicity VARCHAR(64));", "reference_sql": "SELECT lead_actor_ethnicity, COUNT(*) AS count FROM movies WHERE production_country = 'USA' GROUP BY lead_actor_ethnicity ORDER BY count DESC LIMIT 3;", "generated_sql": "SELECT\n  lead_actor_ethnicity,\n  COUNT(*) AS movie_count\nFROM movies\nWHERE production_country = 'USA'\nGROUP BY lead_actor_ethnicity\nORDER BY movie_count DESC\nFETCH FIRST 3 ROWS ONLY;", "raw_model_output": "SELECT\n  lead_actor_ethnicity,\n  COUNT(*) AS movie_count\nFROM movies\nWHERE production_country = 'USA'\nGROUP BY lead_actor_ethnicity\nORDER BY movie_count DESC\nFETCH FIRST 3 ROWS ONLY;", "latency_sec": 3.844763994216919, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 105, "prompt_eval_sec": null, "tokens_completion": 257, "completion_eval_sec": null, "tokens_total": 362, "tokens_per_sec": 94.15402363955248, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count movies by lead_actor_ethnicity for USA productions, group by ethnicity, order by count descending, and limit to top 3 results. The only difference is the syntax for limiting results (LIMIT 3 vs FETCH FIRST 3 ROWS ONLY), which are functionally equivalent in their effect."}
{"example_id": 4298, "sql_complexity": "single join", "prompt": "How many users joined the gym in Q1 2023?", "context": "CREATE TABLE memberships (id INT, user_id INT, join_date DATE); INSERT INTO memberships (id, user_id, join_date) VALUES (1, 5, '2023-01-15'), (2, 6, '2023-02-03'), (3, 7, '2023-03-20'), (4, 8, '2022-12-31');", "reference_sql": "SELECT COUNT(*) FROM memberships WHERE join_date BETWEEN '2023-01-01' AND '2023-03-31';", "generated_sql": "SELECT COUNT(DISTINCT user_id) AS users_joined_q1_2023\nFROM memberships\nWHERE join_date BETWEEN '2023-01-01' AND '2023-03-31';", "raw_model_output": "SELECT COUNT(DISTINCT user_id) AS users_joined_q1_2023\nFROM memberships\nWHERE join_date BETWEEN '2023-01-01' AND '2023-03-31';", "latency_sec": 4.2496349811553955, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 163, "prompt_eval_sec": null, "tokens_completion": 317, "completion_eval_sec": null, "tokens_total": 480, "tokens_per_sec": 112.95087745853812, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query counts all rows matching the date range (COUNT(*)), while the generated query counts distinct user_ids (COUNT(DISTINCT user_id)). If there are multiple memberships for the same user in the date range, they would produce different results."}
{"example_id": 5211, "sql_complexity": "multiple_joins", "prompt": "What is the average transaction value in the last week, split by product category and customer demographics?", "context": "CREATE TABLE transactions (transaction_id INT, customer_id INT, product_id INT, category_id INT, transaction_date DATE, amount DECIMAL(10,2)); CREATE TABLE customers (customer_id INT, age INT, gender VARCHAR(10), location VARCHAR(255)); CREATE TABLE products (product_id INT, name VARCHAR(255), category_id INT);", "reference_sql": "SELECT c.age, c.gender, p.category_id, AVG(t.amount) as avg_transaction_value FROM transactions t INNER JOIN customers c ON t.customer_id = c.customer_id INNER JOIN products p ON t.product_id = p.product_id WHERE t.transaction_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 WEEK) GROUP BY c.age, c.gender, p.category_id;", "generated_sql": "SELECT\n  t.category_id,\n  c.gender,\n  c.age,\n  AVG(t.amount) AS avg_transaction_value\nFROM\n  transactions AS t\n  JOIN customers AS c\n    ON t.customer_id = c.customer_id\nWHERE\n  t.transaction_date >= CURRENT_DATE - INTERVAL '7' DAY\nGROUP BY\n  t.category_id,\n  c.gender,\n  c.age;", "raw_model_output": "SELECT\n  t.category_id,\n  c.gender,\n  c.age,\n  AVG(t.amount) AS avg_transaction_value\nFROM\n  transactions AS t\n  JOIN customers AS c\n    ON t.customer_id = c.customer_id\nWHERE\n  t.transaction_date >= CURRENT_DATE - INTERVAL '7' DAY\nGROUP BY\n  t.category_id,\n  c.gender,\n  c.age;", "latency_sec": 5.619847059249878, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 155, "prompt_eval_sec": null, "tokens_completion": 676, "completion_eval_sec": null, "tokens_total": 831, "tokens_per_sec": 147.86879273382212, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their joins and column sources. The reference query joins with the 'products' table and uses p.category_id, while the generated query omits the products table and uses t.category_id from transactions. This could lead to different results if transaction.category_id and product.category_id differ. Additionally, the generated query's GROUP BY order differs but doesn't affect equivalence. The core issue is the missing products join, making them non-equivalent."}
{"example_id": 382, "sql_complexity": "window functions", "prompt": "What is the average annual precipitation in the past 10 years for each weather station?", "context": "CREATE TABLE WeatherStation (ID INT, Name VARCHAR(100), Location VARCHAR(100), Elevation FLOAT, AnnualPrecipitation FLOAT); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (1, 'Station A', 'Arctic Circle', 100, 450); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (2, 'Station B', 'North Pole', 200, 300);", "reference_sql": "SELECT Name, AVG(AnnualPrecipitation) OVER (PARTITION BY Name ORDER BY Name ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS AvgAnnualPrecipitation FROM WeatherStation WHERE YEAR(CurrentDate) - YEAR(DateInstalled) BETWEEN 1 AND 10;", "generated_sql": "SELECT\n  ID,\n  Name,\n  AVG(AnnualPrecipitation) AS AvgAnnualPrecipitationPast10Years\nFROM\n  WeatherStation\nGROUP BY\n  ID,\n  Name;", "raw_model_output": "SELECT\n  ID,\n  Name,\n  AVG(AnnualPrecipitation) AS AvgAnnualPrecipitationPast10Years\nFROM\n  WeatherStation\nGROUP BY\n  ID,\n  Name;", "latency_sec": 7.310338973999023, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 186, "prompt_eval_sec": null, "tokens_completion": 508, "completion_eval_sec": null, "tokens_total": 694, "tokens_per_sec": 94.93403828035576, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL references a non-existent 'DateInstalled' column in the WHERE clause, making it invalid. The Generated SQL groups by ID/Name and calculates a simple average (which would equal the individual AnnualPrecipitation values due to grouping on unique IDs), while the Reference SQL attempts a window function partitioning by Name. Additionally, the selected columns differ between the two queries."}
{"example_id": 2190, "sql_complexity": "single join", "prompt": "What is the total number of humanitarian assistance events by each country in the last 3 years?", "context": "CREATE TABLE Humanitarian_Assistance (id INT, country VARCHAR(50), year INT, events INT); CREATE TABLE Countries (id INT, name VARCHAR(50), region VARCHAR(50));", "reference_sql": "SELECT co.name, SUM(ha.events) FROM Humanitarian_Assistance ha INNER JOIN Countries co ON ha.country = co.name WHERE ha.year BETWEEN (YEAR(CURRENT_DATE) - 3) AND YEAR(CURRENT_DATE) GROUP BY co.name;", "generated_sql": "SELECT c.name AS country,\n       SUM(ha.events) AS total_events\nFROM Countries c\nJOIN Humanitarian_Assistance ha\n  ON ha.country = c.name\nWHERE ha.year >= EXTRACT(YEAR FROM CURRENT_DATE) - 2\nGROUP BY c.name;", "raw_model_output": "SELECT c.name AS country,\n       SUM(ha.events) AS total_events\nFROM Countries c\nJOIN Humanitarian_Assistance ha\n  ON ha.country = c.name\nWHERE ha.year >= EXTRACT(YEAR FROM CURRENT_DATE) - 2\nGROUP BY c.name;", "latency_sec": 5.600849151611328, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 123, "prompt_eval_sec": null, "tokens_completion": 651, "completion_eval_sec": null, "tokens_total": 774, "tokens_per_sec": 138.19333087685914, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their year range filtering. The Reference SQL uses BETWEEN (YEAR(CURRENT_DATE) - 3) AND YEAR(CURRENT_DATE) which includes 4 years (current year -3, -2, -1, and current). The Generated SQL uses WHERE ha.year >= EXTRACT(YEAR FROM CURRENT_DATE) - 2 which includes 3 years (current year -2, -1, and current). This makes the generated query exclude the earliest year in the reference query's range."}
{"example_id": 1852, "sql_complexity": "set operations", "prompt": "Compare coal production and employment rates in China and India between 2018 and 2020.", "context": "CREATE TABLE china_coal_production (year INT, production FLOAT); INSERT INTO china_coal_production (year, production) VALUES (2018, 3500.0), (2019, 3600.0), (2020, 3700.0); CREATE TABLE china_employment (year INT, employment FLOAT); INSERT INTO china_employment (year, employment) VALUES (2018, 8000000.0), (2019, 8100000.0), (2020, 8200000.0); CREATE TABLE india_coal_production (year INT, production FLOAT); INSERT INTO india_coal_production (year, production) VALUES (2018, 700.0), (2019, 750.0), (2020, 800.0); CREATE TABLE india_employment (year INT, employment FLOAT); INSERT INTO india_employment (year, employment) VALUES (2018, 1000000.0), (2019, 1050000.0), (2020, 1100000.0);", "reference_sql": "SELECT 'China' AS country, china_coal_production.production, china_employment.employment FROM china_coal_production INNER JOIN china_employment ON china_coal_production.year = china_employment.year WHERE china_coal_production.year BETWEEN 2018 AND 2020 UNION ALL SELECT 'India', india_coal_production.production, india_employment.employment FROM india_coal_production INNER JOIN india_employment ON india_coal_production.year = india_employment.year WHERE india_coal_production.year BETWEEN 2018 AND 2020;", "generated_sql": "SELECT\n  ccp.year AS year,\n  ccp.production AS china_coal_production,\n  icp.production AS india_coal_production,\n  ce.employment AS china_employment,\n  ie.employment AS india_employment\nFROM china_coal_production AS ccp\nJOIN china_employment AS ce\n  ON ccp.year = ce.year\nJOIN india_coal_production AS icp\n  ON ccp.year = icp.year\nJOIN india_employment AS ie\n  ON ccp.year = ie.year\nWHERE ccp.year BETWEEN 2018 AND 2020\nORDER BY ccp.year;", "raw_model_output": "SELECT\n  ccp.year AS year,\n  ccp.production AS china_coal_production,\n  icp.production AS india_coal_production,\n  ce.employment AS china_employment,\n  ie.employment AS india_employment\nFROM china_coal_production AS ccp\nJOIN china_employment AS ce\n  ON ccp.year = ce.year\nJOIN india_coal_production AS icp\n  ON ccp.year = icp.year\nJOIN india_employment AS ie\n  ON ccp.year = ie.year\nWHERE ccp.year BETWEEN 2018 AND 2020\nORDER BY ccp.year;", "latency_sec": 5.212045669555664, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 308, "prompt_eval_sec": null, "tokens_completion": 469, "completion_eval_sec": null, "tokens_total": 777, "tokens_per_sec": 149.07774207324638, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two rows per year (China and India) with separate production/employment values, while the Generated SQL returns one row per year with all four values combined. The structure and number of rows differ, making them non-equivalent."}
{"example_id": 2535, "sql_complexity": "subqueries", "prompt": "What is the maximum safety rating for vehicles in the vehiclesafety schema?", "context": "CREATE TABLE VehicleSafety (id INT, vehicle_id INT, safetyrating INT, PRIMARY KEY (id)); CREATE TABLE Vehicles (id INT, make VARCHAR(50), model VARCHAR(50), PRIMARY KEY (id)); CREATE TABLE LuxuryVehicles (id INT, vehicle_id INT, PRIMARY KEY (id), FOREIGN KEY (vehicle_id) REFERENCES Vehicles(id));", "reference_sql": "SELECT MAX(safetyrating) FROM vehicleSafety JOIN Vehicles ON vehicleSafety.vehicle_id = Vehicles.id WHERE EXISTS (SELECT * FROM LuxuryVehicles WHERE Vehicles.id = LuxuryVehicles.vehicle_id);", "generated_sql": "SELECT MAX(safetyrating) AS max_safety_rating\nFROM VehicleSafety;", "raw_model_output": "SELECT MAX(safetyrating) AS max_safety_rating\nFROM VehicleSafety;", "latency_sec": 2.3875808715820312, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 152, "prompt_eval_sec": null, "tokens_completion": 164, "completion_eval_sec": null, "tokens_total": 316, "tokens_per_sec": 132.35153781015833, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters VehicleSafety records to only those vehicles that exist in LuxuryVehicles (via the EXISTS clause), while the Generated SQL selects from VehicleSafety without any filtering. This means the Generated SQL could include safety ratings from non-luxury vehicles, leading to potentially different maximum values."}
{"example_id": 2140, "sql_complexity": "aggregation", "prompt": "What was the total amount of minerals extracted in the 'north' region for each month in 2020?", "context": "CREATE TABLE extraction(id INT, location TEXT, month INT, year INT, minerals_extracted FLOAT);INSERT INTO extraction(id, location, month, year, minerals_extracted) VALUES (1, 'north', 1, 2020, 1500), (2, 'north', 2, 2020, 1800), (3, 'south', 1, 2020, 1200);", "reference_sql": "SELECT month, SUM(minerals_extracted) FROM extraction WHERE location = 'north' AND year = 2020 GROUP BY month;", "generated_sql": "SELECT\n  month,\n  SUM(minerals_extracted) AS total_extracted\nFROM extraction\nWHERE location = 'north'\n  AND year = 2020\nGROUP BY month\nORDER BY month;", "raw_model_output": "SELECT\n  month,\n  SUM(minerals_extracted) AS total_extracted\nFROM extraction\nWHERE location = 'north'\n  AND year = 2020\nGROUP BY month\nORDER BY month;", "latency_sec": 2.699810028076172, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 175, "prompt_eval_sec": null, "tokens_completion": 126, "completion_eval_sec": null, "tokens_total": 301, "tokens_per_sec": 111.48932586730419, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns, apply identical filtering conditions (location = 'north' and year = 2020), and group by the same column (month). The generated query includes an ORDER BY clause, but since the reference query does not specify an order, the result sets are considered semantically equivalent as they contain the same data. The ORDER BY clause in the generated query only affects the output order, not the actual data returned."}
{"example_id": 4779, "sql_complexity": "window functions", "prompt": "What is the average CO2 emission for the top 3 highest emitting countries since 2015?", "context": "CREATE TABLE emissions (country VARCHAR(50), year INT, co2_emission INT); INSERT INTO emissions (country, year, co2_emission) VALUES ('USA', 2015, 5373978000); INSERT INTO emissions (country, year, co2_emission) VALUES ('China', 2015, 10498600000); INSERT INTO emissions (country, year, co2_emission) VALUES ('India', 2015, 2633830000); INSERT INTO emissions (country, year, co2_emission) VALUES ('USA', 2016, 5518004000); INSERT INTO emissions (country, year, co2_emission) VALUES ('China', 2016, 10813000000); INSERT INTO emissions (country, year, co2_emission) VALUES ('India', 2016, 2799280000);", "reference_sql": "SELECT AVG(co2_emission) as avg_emission FROM (SELECT country, year, co2_emission, ROW_NUMBER() OVER (ORDER BY co2_emission DESC) as rn FROM emissions WHERE year >= 2015) t WHERE rn <= 3 GROUP BY country;", "generated_sql": "SELECT\n    country,\n    SUM(co2_emission) AS total_emission\n  FROM emissions\n  WHERE year >= 2015\n  GROUP BY country\n),\ntop3 AS (\n  SELECT country\n  FROM (\n    SELECT\n      country,\n      ROW_NUMBER() OVER (ORDER BY total_emission DESC) AS rn\n    FROM country_totals\n  ) t\n  WHERE rn <= 3\n)\nSELECT\n  AVG(co2_emission) AS avg_co2_emission\nFROM emissions\nWHERE year >= 2015\n  AND country IN (SELECT country FROM top3);", "raw_model_output": "WITH country_totals AS (\n  SELECT\n    country,\n    SUM(co2_emission) AS total_emission\n  FROM emissions\n  WHERE year >= 2015\n  GROUP BY country\n),\ntop3 AS (\n  SELECT country\n  FROM (\n    SELECT\n      country,\n      ROW_NUMBER() OVER (ORDER BY total_emission DESC) AS rn\n    FROM country_totals\n  ) t\n  WHERE rn <= 3\n)\nSELECT\n  AVG(co2_emission) AS avg_co2_emission\nFROM emissions\nWHERE year >= 2015\n  AND country IN (SELECT country FROM top3);", "latency_sec": 16.833763122558594, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 266, "prompt_eval_sec": null, "tokens_completion": 1493, "completion_eval_sec": null, "tokens_total": 1759, "tokens_per_sec": 104.49238160199597, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the average CO2 emissions for the top 3 individual rows (by co2_emission value) grouped by country, while the Generated SQL calculates the average CO2 emissions for all entries of the top 3 countries (based on total emissions). The Reference SQL's grouping is based on ranked individual rows, whereas the Generated SQL's grouping is based on aggregated country totals. This leads to different results."}
{"example_id": 1015, "sql_complexity": "subqueries", "prompt": "List the top 3 most expensive eco-friendly products in Europe and their suppliers.", "context": "CREATE TABLE Suppliers (supplierID INT, supplierName VARCHAR(50), country VARCHAR(50)); CREATE TABLE Products (productID INT, productName VARCHAR(50), price DECIMAL(10,2), ecoFriendly BOOLEAN, supplierID INT);", "reference_sql": "SELECT P.productName, P.price, S.supplierName FROM (SELECT * FROM Products WHERE ecoFriendly = TRUE ORDER BY price DESC LIMIT 3) P JOIN Suppliers S ON P.supplierID = S.supplierID;", "generated_sql": "SELECT \n  p.productName, \n  p.price, \n  s.supplierName\nFROM Products AS p\nJOIN Suppliers AS s\n  ON p.supplierID = s.supplierID\nWHERE \n  p.ecoFriendly = TRUE\n  AND s.country = 'Europe'\nORDER BY \n  p.price DESC\nFETCH FIRST 3 ROWS ONLY;", "raw_model_output": "SELECT \n  p.productName, \n  p.price, \n  s.supplierName\nFROM Products AS p\nJOIN Suppliers AS s\n  ON p.supplierID = s.supplierID\nWHERE \n  p.ecoFriendly = TRUE\n  AND s.country = 'Europe'\nORDER BY \n  p.price DESC\nFETCH FIRST 3 ROWS ONLY;", "latency_sec": 3.507352113723755, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 131, "prompt_eval_sec": null, "tokens_completion": 414, "completion_eval_sec": null, "tokens_total": 545, "tokens_per_sec": 155.3878773298794, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Generated SQL includes an additional filter WHERE s.country = 'Europe' which is absent in the Reference SQL. Second, the Reference SQL applies the LIMIT 3 after filtering and ordering the Products table, while the Generated SQL applies the ORDER BY and FETCH FIRST 3 ROWS ONLY after joining with Suppliers. These differences in filtering conditions and operation order result in non-equivalent outputs."}
{"example_id": 3715, "sql_complexity": "aggregation", "prompt": "What is the average age of engines still in service for each engine type?", "context": "CREATE TABLE Engine (id INT, aircraft_id INT, engine_type VARCHAR(255), hours_since_last_service INT, manufacture_year INT); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (1, 1, 'GE90-115B', 500, 2000); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (2, 2, 'CFM56-5B', 1000, 1995); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (3, 1, 'GE90-115B', 700, 2002);", "reference_sql": "SELECT engine_type, AVG(YEAR(CURRENT_DATE) - manufacture_year) as avg_age FROM Engine GROUP BY engine_type;", "generated_sql": "SELECT\n  engine_type,\n  AVG(EXTRACT(YEAR FROM CURRENT_DATE) - manufacture_year) AS average_age\nFROM Engine\nGROUP BY engine_type;", "raw_model_output": "SELECT\n  engine_type,\n  AVG(EXTRACT(YEAR FROM CURRENT_DATE) - manufacture_year) AS average_age\nFROM Engine\nGROUP BY engine_type;", "latency_sec": 2.8493740558624268, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 233, "prompt_eval_sec": null, "tokens_completion": 307, "completion_eval_sec": null, "tokens_total": 540, "tokens_per_sec": 189.51530736688656, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average age of engines per type by subtracting the manufacture_year from the current year. The Reference SQL uses YEAR(CURRENT_DATE) while the Generated SQL uses EXTRACT(YEAR FROM CURRENT_DATE). These expressions are functionally equivalent in most SQL dialects for retrieving the year component of the current date, leading to identical results."}
{"example_id": 1957, "sql_complexity": "set operations", "prompt": "What is the average temperature recorded for the 'polar_bear' species in the 'Arctic_Animals' table compared to the 'penguin' species in the 'Antarctic_Animals' table?", "context": "CREATE TABLE Arctic_Animals (species TEXT, avg_temp FLOAT); CREATE TABLE Antarctic_Animals (species TEXT, avg_temp FLOAT);", "reference_sql": "SELECT AVG(Arctic_Animals.avg_temp) FROM Arctic_Animals WHERE Arctic_Animals.species = 'polar_bear' INTERSECT SELECT AVG(Antarctic_Animals.avg_temp) FROM Antarctic_Animals WHERE Antarctic_Animals.species = 'penguin'", "generated_sql": "SELECT\n  (SELECT avg_temp FROM Arctic_Animals WHERE species = 'polar_bear') AS polar_bear_avg_temp,\n  (SELECT avg_temp FROM Antarctic_Animals WHERE species = 'penguin') AS penguin_avg_temp;", "raw_model_output": "SELECT\n  (SELECT avg_temp FROM Arctic_Animals WHERE species = 'polar_bear') AS polar_bear_avg_temp,\n  (SELECT avg_temp FROM Antarctic_Animals WHERE species = 'penguin') AS penguin_avg_temp;", "latency_sec": 3.752782106399536, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 134, "prompt_eval_sec": null, "tokens_completion": 515, "completion_eval_sec": null, "tokens_total": 649, "tokens_per_sec": 172.93836455180136, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the average temperature for polar bears and penguins separately and returns their intersection (i.e., matches where both averages are equal). The Generated SQL retrieves the two average temperatures as separate columns in a single row. The first query enforces a equality check between the two averages, while the second simply returns both values independently. Their result structures and purposes differ."}
{"example_id": 1311, "sql_complexity": "basic SQL", "prompt": "What is the total number of veteran job applications in Texas in the last year?", "context": "CREATE TABLE veteran_jobs (id INT, state VARCHAR(50), application_date DATE); INSERT INTO veteran_jobs (id, state, application_date) VALUES (1, 'Texas', '2021-02-15'), (2, 'California', '2021-04-10'), (3, 'Texas', '2022-01-05');", "reference_sql": "SELECT COUNT(*) FROM veteran_jobs WHERE state = 'Texas' AND application_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR);", "generated_sql": "SELECT COUNT(*) AS total_applications\nFROM veteran_jobs\nWHERE state = 'Texas'\n  AND application_date BETWEEN CURRENT_DATE - INTERVAL '1' YEAR AND CURRENT_DATE;", "raw_model_output": "SELECT COUNT(*) AS total_applications\nFROM veteran_jobs\nWHERE state = 'Texas'\n  AND application_date BETWEEN CURRENT_DATE - INTERVAL '1' YEAR AND CURRENT_DATE;", "latency_sec": 2.490478992462158, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 154, "prompt_eval_sec": null, "tokens_completion": 247, "completion_eval_sec": null, "tokens_total": 401, "tokens_per_sec": 161.01320316842344, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count records where state is 'Texas' and application_date falls within the last year. The reference query uses DATE_SUB to calculate the start date and checks application_date >= that date. The generated query uses BETWEEN with the same start date (CURRENT_DATE - INTERVAL '1' YEAR) and CURRENT_DATE. Since BETWEEN is inclusive of both endpoints and the original condition implicitly includes all dates up to the current date, the result sets are identical."}
{"example_id": 2997, "sql_complexity": "window functions", "prompt": "What is the earliest capture time for each satellite image in the 'satellite_images' table?", "context": "CREATE TABLE satellite_images (image_id INT, image_url TEXT, capture_time TIMESTAMP); INSERT INTO satellite_images (image_id, image_url, capture_time) VALUES (1, 'image1.jpg', '2022-01-01 10:00:00'), (2, 'image2.jpg', '2021-05-01 10:00:00');", "reference_sql": "SELECT image_id, MIN(capture_time) OVER (PARTITION BY image_id) FROM satellite_images;", "generated_sql": "SELECT \n  image_id, \n  MIN(capture_time) AS earliest_capture_time \nFROM satellite_images \nGROUP BY image_id;", "raw_model_output": "SELECT \n  image_id, \n  MIN(capture_time) AS earliest_capture_time \nFROM satellite_images \nGROUP BY image_id;", "latency_sec": 3.06315016746521, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 162, "prompt_eval_sec": null, "tokens_completion": 366, "completion_eval_sec": null, "tokens_total": 528, "tokens_per_sec": 172.3715688535524, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries return the same result because the 'image_id' column is unique in the table. The Reference SQL uses a window function that returns the same value as the capture_time for each row (since each group has only one row), while the Generated SQL aggregates by image_id (also returning the same capture_time value for each unique image_id). The output structure and values match exactly in this specific case."}
{"example_id": 3743, "sql_complexity": "aggregation", "prompt": "What is the maximum budget spent on peacekeeping operations by each department?", "context": "CREATE TABLE DepartmentPeacekeeping (id INT, department VARCHAR(50), budget INT);", "reference_sql": "SELECT department, MAX(budget) FROM DepartmentPeacekeeping GROUP BY department;", "generated_sql": "SELECT\n  department,\n  MAX(budget) AS max_budget\nFROM\n  DepartmentPeacekeeping\nGROUP BY\n  department;", "raw_model_output": "SELECT\n  department,\n  MAX(budget) AS max_budget\nFROM\n  DepartmentPeacekeeping\nGROUP BY\n  department;", "latency_sec": 1.4416630268096924, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 97, "prompt_eval_sec": null, "tokens_completion": 110, "completion_eval_sec": null, "tokens_total": 207, "tokens_per_sec": 143.5841775439561, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (department and MAX(budget)) and apply the same GROUP BY clause. The generated query adds an explicit alias (max_budget) for the MAX(budget) column, but this does not affect the semantic result set. The grouping and aggregation logic remain identical."}
{"example_id": 4664, "sql_complexity": "multiple_joins", "prompt": "Calculate the total number of volunteer hours contributed by volunteers from 'California' in 'Health' projects in 2021.", "context": "CREATE TABLE volunteers (volunteer_id INT, name VARCHAR(255), state VARCHAR(255));", "reference_sql": "SELECT SUM(vh.hours) as total_hours FROM volunteer_projects vp JOIN volunteer_hours vh ON vp.project_id = vh.project_id JOIN volunteers vol ON vh.volunteer_id = vol.volunteer_id WHERE vp.cause = 'Health' AND vol.state = 'California' AND vh.volunteer_date BETWEEN '2021-01-01' AND '2021-12-31';", "generated_sql": "I\u2019m afraid I can\u2019t write that query because the schema you provided only includes the `volunteers` table. To calculate volunteer hours by project category and year you\u2019d also need tables (for example) recording hours and project details\u2014neither of which are in the schema. Could you please provide the definitions for the tables that track hours and project categories?", "raw_model_output": "I\u2019m afraid I can\u2019t write that query because the schema you provided only includes the `volunteers` table. To calculate volunteer hours by project category and year you\u2019d also need tables (for example) recording hours and project details\u2014neither of which are in the schema. Could you please provide the definitions for the tables that track hours and project categories?", "latency_sec": 3.9889228343963623, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 109, "prompt_eval_sec": null, "tokens_completion": 539, "completion_eval_sec": null, "tokens_total": 648, "tokens_per_sec": 162.44987103092478, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Generated SQL is not a valid SQL query but rather a message explaining that the required tables (volunteer_projects, volunteer_hours) are missing from the schema. The Reference SQL involves joins between volunteers, volunteer_hours, and volunteer_projects tables, which are not available in the provided schema. Therefore, the queries cannot be semantically equivalent."}
{"example_id": 251, "sql_complexity": "set operations", "prompt": "Compare the number of economic diversification projects in two regions, one in Europe and one in Oceania, by showing the project type and the number of projects in each region.", "context": "CREATE TABLE economic_diversification (region VARCHAR(50), project_type VARCHAR(50), project_start_date DATE);", "reference_sql": "SELECT 'Europe' as region, project_type, COUNT(*) as project_count FROM economic_diversification WHERE region = 'Europe' UNION ALL SELECT 'Oceania' as region, project_type, COUNT(*) as project_count FROM economic_diversification WHERE region = 'Oceania';", "generated_sql": "SELECT\n  project_type,\n  SUM(CASE WHEN region = 'Europe'  THEN 1 ELSE 0 END) AS europe_project_count,\n  SUM(CASE WHEN region = 'Oceania' THEN 1 ELSE 0 END) AS oceania_project_count\nFROM economic_diversification\nWHERE region IN ('Europe', 'Oceania')\nGROUP BY project_type;", "raw_model_output": "SELECT\n  project_type,\n  SUM(CASE WHEN region = 'Europe'  THEN 1 ELSE 0 END) AS europe_project_count,\n  SUM(CASE WHEN region = 'Oceania' THEN 1 ELSE 0 END) AS oceania_project_count\nFROM economic_diversification\nWHERE region IN ('Europe', 'Oceania')\nGROUP BY project_type;", "latency_sec": 7.513751029968262, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 123, "prompt_eval_sec": null, "tokens_completion": 545, "completion_eval_sec": null, "tokens_total": 668, "tokens_per_sec": 88.90366440619495, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries have different output structures. The Reference query returns two separate rows per project_type (one for Europe and one for Oceania), while the Generated query returns a single row per project_type with two columns (europe_project_count and oceania_project_count). The semantic output is not equivalent due to structural differences in results."}
{"example_id": 610, "sql_complexity": "subqueries", "prompt": "What is the percentage of community development projects completed in 'Caribbean' in 2020?", "context": "CREATE TABLE community_projects (project_id INT, project_name TEXT, location TEXT, completion_year INT); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (1, 'Community Center', 'Southern Region, Caribbean', 2020); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (2, 'Park Renovation', 'Northern Region, Caribbean', 2019); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (3, 'Library Construction', 'Caribbean', 2020);", "reference_sql": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM community_projects WHERE location = 'Caribbean')) FROM community_projects WHERE completion_year = 2020 AND location = 'Caribbean';", "generated_sql": "SELECT\n  (SUM(CASE WHEN location LIKE '%Caribbean%' THEN 1 ELSE 0 END) * 100.0\n   / COUNT(*)) AS percentage\nFROM community_projects\nWHERE completion_year = 2020;", "raw_model_output": "SELECT\n  (SUM(CASE WHEN location LIKE '%Caribbean%' THEN 1 ELSE 0 END) * 100.0\n   / COUNT(*)) AS percentage\nFROM community_projects\nWHERE completion_year = 2020;", "latency_sec": 6.851454973220825, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 206, "prompt_eval_sec": null, "tokens_completion": 1091, "completion_eval_sec": null, "tokens_total": 1297, "tokens_per_sec": 189.30285684856344, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their calculation logic. The Reference SQL calculates (2020 Caribbean projects / total Caribbean projects) * 100, while the Generated SQL calculates (2020 projects in Caribbean / total 2020 projects) * 100. The denominators and numerator conditions differ: the Reference uses a fixed 'Caribbean' location match, while the Generated uses a LIKE '%Caribbean%' pattern and a different denominator. In the provided data, they coincidentally return the same result, but they are not semantically equivalent in general."}
{"example_id": 421, "sql_complexity": "set operations", "prompt": "What is the combined landfill capacity for 'City A' and 'City B'?", "context": "CREATE TABLE landfill_capacity (city VARCHAR(255), capacity INT); INSERT INTO landfill_capacity (city, capacity) VALUES ('City A', 500000), ('City B', 600000);", "reference_sql": "SELECT SUM(capacity) FROM (SELECT capacity FROM landfill_capacity WHERE city = 'City A' UNION ALL SELECT capacity FROM landfill_capacity WHERE city = 'City B') AS combined_capacity;", "generated_sql": "SELECT SUM(capacity) AS combined_capacity\nFROM landfill_capacity\nWHERE city IN ('City A', 'City B');", "raw_model_output": "SELECT SUM(capacity) AS combined_capacity\nFROM landfill_capacity\nWHERE city IN ('City A', 'City B');", "latency_sec": 3.2531089782714844, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 122, "prompt_eval_sec": null, "tokens_completion": 171, "completion_eval_sec": null, "tokens_total": 293, "tokens_per_sec": 90.06768662133274, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of capacities for 'City A' and 'City B'. The reference query uses a subquery with UNION ALL to combine the two cities' capacities before summing, while the generated query uses a WHERE IN clause to directly filter and sum the capacities. Both approaches yield the same result."}
{"example_id": 880, "sql_complexity": "aggregation", "prompt": "Show veteran employment statistics for each state in the 'veteran_employment' table", "context": "CREATE TABLE veteran_employment (employee_id INT, state VARCHAR(2), job_title VARCHAR(50), employment_date DATE);", "reference_sql": "SELECT state, COUNT(*) as veteran_employees FROM veteran_employment WHERE state IN ('CA', 'NY', 'TX', 'FL', 'PA') GROUP BY state;", "generated_sql": "SELECT \n  state, \n  COUNT(*) AS veteran_count \nFROM \n  veteran_employment \nGROUP BY \n  state \nORDER BY \n  state;", "raw_model_output": "SELECT \n  state, \n  COUNT(*) AS veteran_count \nFROM \n  veteran_employment \nGROUP BY \n  state \nORDER BY \n  state;", "latency_sec": 4.286645174026489, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 109, "prompt_eval_sec": null, "tokens_completion": 563, "completion_eval_sec": null, "tokens_total": 672, "tokens_per_sec": 156.76594929567813, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters results to only include records where state is in ('CA', 'NY', 'TX', 'FL', 'PA'), while the Generated SQL includes all states. The Generated SQL also adds an ORDER BY clause, which doesn't affect semantic equivalence but the WHERE clause difference means they could produce different results when other states exist in the table."}
{"example_id": 454, "sql_complexity": "single join", "prompt": "Which excavation sites have more than 10 artifacts?", "context": "CREATE TABLE ExcavationSite (SiteID INT, SiteName VARCHAR(50)); INSERT INTO ExcavationSite (SiteID, SiteName) VALUES (1, 'Site A'), (2, 'Site B'), (3, 'Site C'); CREATE TABLE Artifact (ArtifactID INT, SiteID INT, ObjectType VARCHAR(50)); INSERT INTO Artifact (ArtifactID, SiteID, ObjectType) VALUES (1, 1, 'Pottery'), (2, 1, 'Tool'), (3, 2, 'Statue'), (4, 2, 'Bead'), (5, 3, 'Bead'), (6, 3, 'Bead'), (7, 3, 'Bead'), (8, 3, 'Bead'), (9, 3, 'Bead'), (10, 3, 'Bead'), (11, 3, 'Bead');", "reference_sql": "SELECT e.SiteName FROM ExcavationSite e JOIN Artifact a ON e.SiteID = a.SiteID GROUP BY e.SiteName HAVING COUNT(a.ArtifactID) > 10;", "generated_sql": "SELECT e.SiteName\nFROM ExcavationSite e\nJOIN Artifact a ON e.SiteID = a.SiteID\nGROUP BY e.SiteID, e.SiteName\nHAVING COUNT(*) > 10;", "raw_model_output": "SELECT e.SiteName\nFROM ExcavationSite e\nJOIN Artifact a ON e.SiteID = a.SiteID\nGROUP BY e.SiteID, e.SiteName\nHAVING COUNT(*) > 10;", "latency_sec": 4.287614822387695, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 267, "prompt_eval_sec": null, "tokens_completion": 252, "completion_eval_sec": null, "tokens_total": 519, "tokens_per_sec": 121.04632097315549, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their GROUP BY clauses. The Reference SQL groups by SiteName alone, which could combine multiple sites with the same name (if they existed). The Generated SQL groups by both SiteID and SiteName, ensuring each site is treated individually. While the sample data has unique SiteNames, the semantic equivalence depends on the database schema's constraints. Since SiteName is not guaranteed to be unique, the queries may produce different results in general cases."}
{"example_id": 1086, "sql_complexity": "aggregation", "prompt": "What is the total CO2 emission for each equipment type, excluding equipment that is older than 8 years?", "context": "CREATE TABLE EmissionData (EquipmentID INT, EquipmentType VARCHAR(50), CO2Emission INT, Age INT); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (1, 'Excavator', 50, 8); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (2, 'Haul Truck', 70, 7); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (3, 'Shovel', 30, 6); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (4, 'Drilling Rig', 40, 3);", "reference_sql": "SELECT EquipmentType, SUM(CO2Emission) as TotalCO2Emission FROM EmissionData WHERE Age <= 8 GROUP BY EquipmentType;", "generated_sql": "SELECT\n  EquipmentType,\n  SUM(CO2Emission) AS TotalCO2Emission\nFROM\n  EmissionData\nWHERE\n  Age <= 8\nGROUP BY\n  EquipmentType;", "raw_model_output": "SELECT\n  EquipmentType,\n  SUM(CO2Emission) AS TotalCO2Emission\nFROM\n  EmissionData\nWHERE\n  Age <= 8\nGROUP BY\n  EquipmentType;", "latency_sec": 6.68142294883728, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 243, "prompt_eval_sec": null, "tokens_completion": 380, "completion_eval_sec": null, "tokens_total": 623, "tokens_per_sec": 93.243610645606, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (EquipmentType and SUM(CO2Emission)), apply the same WHERE condition (Age <= 8), and group by EquipmentType. The generated SQL is identical in logic to the reference query, with only formatting differences (line breaks, indentation)."}
{"example_id": 3455, "sql_complexity": "basic SQL", "prompt": "What are the names of all innovation projects in the 'rural_infrastructure' table, excluding those with a budget over 50000?", "context": "CREATE TABLE rural_infrastructure (name VARCHAR(255), budget INT); INSERT INTO rural_infrastructure (name, budget) VALUES ('Dam Construction', 40000), ('Well Digging', 30000), ('Irrigation System', 70000);", "reference_sql": "SELECT name FROM rural_infrastructure WHERE budget <= 50000;", "generated_sql": "SELECT name\nFROM rural_infrastructure\nWHERE budget <= 50000;", "raw_model_output": "SELECT name\nFROM rural_infrastructure\nWHERE budget <= 50000;", "latency_sec": 3.709023952484131, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 146, "prompt_eval_sec": null, "tokens_completion": 226, "completion_eval_sec": null, "tokens_total": 372, "tokens_per_sec": 100.29592819179607, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the 'name' column from the 'rural_infrastructure' table where the 'budget' is less than or equal to 50000. The structure and conditions are identical, with only formatting differences (line breaks/spaces) that do not affect semantic meaning."}
{"example_id": 3936, "sql_complexity": "window functions", "prompt": "What is the total investment per client for each investment type?", "context": "CREATE TABLE clients (client_id INT, name TEXT, investment_type TEXT, investment FLOAT); INSERT INTO clients (client_id, name, investment_type, investment) VALUES (1, 'John Doe', 'Stocks', 3000.00), (1, 'John Doe', 'Bonds', 2000.00), (2, 'Jane Smith', 'Stocks', 5000.00);", "reference_sql": "SELECT client_id, name, investment_type, SUM(investment) OVER (PARTITION BY client_id, investment_type ORDER BY client_id) as total_investment FROM clients;", "generated_sql": "SELECT \n  client_id, \n  name, \n  investment_type, \n  SUM(investment) AS total_investment \nFROM clients \nGROUP BY client_id, name, investment_type;", "raw_model_output": "SELECT \n  client_id, \n  name, \n  investment_type, \n  SUM(investment) AS total_investment \nFROM clients \nGROUP BY client_id, name, investment_type;", "latency_sec": 3.351015329360962, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 160, "prompt_eval_sec": null, "tokens_completion": 188, "completion_eval_sec": null, "tokens_total": 348, "tokens_per_sec": 103.84912207082131, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The reference query uses a window function to calculate a cumulative sum within partitions, retaining all original rows. The generated query aggregates rows using GROUP BY, collapsing multiple rows into a single summary per group. For example, if there were multiple entries per client_id/investment_type, the reference query would show cumulative sums per row while the generated query would show total sums per group."}
{"example_id": 1838, "sql_complexity": "window functions", "prompt": "What are the top 3 species with the most sightings across all arctic research stations?", "context": "CREATE TABLE research_station (id INT, name TEXT); INSERT INTO research_station (id, name) VALUES (1, 'Station A'); INSERT INTO research_station (id, name) VALUES (2, 'Station B'); CREATE TABLE species_observations (station_id INT, species_name TEXT, sightings INT); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (1, 'Species 1', 10); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (1, 'Species 2', 5); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (2, 'Species 1', 8); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (2, 'Species 3', 15);", "reference_sql": "SELECT species_name, SUM(sightings) as total_sightings, RANK() OVER (ORDER BY SUM(sightings) DESC) as rank FROM species_observations GROUP BY species_name HAVING rank <= 3;", "generated_sql": "SELECT\n  species_name,\n  SUM(sightings) AS total_sightings\nFROM\n  species_observations\nGROUP BY\n  species_name\nORDER BY\n  total_sightings DESC\nFETCH FIRST 3 ROWS ONLY;", "raw_model_output": "SELECT\n  species_name,\n  SUM(sightings) AS total_sightings\nFROM\n  species_observations\nGROUP BY\n  species_name\nORDER BY\n  total_sightings DESC\nFETCH FIRST 3 ROWS ONLY;", "latency_sec": 2.57796573638916, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 255, "prompt_eval_sec": null, "tokens_completion": 198, "completion_eval_sec": null, "tokens_total": 453, "tokens_per_sec": 175.7199460045953, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL includes a RANK() window function and filters with HAVING rank <= 3, but this is invalid SQL because window functions cannot be used in HAVING clauses. The Generated SQL correctly orders and limits results, but it omits the rank column present in the Reference SQL. Additionally, the Reference SQL's structure would likely produce an error in standard SQL implementations."}
{"example_id": 3091, "sql_complexity": "single join", "prompt": "Find the number of hybrid vehicles sold in the US, Germany, and Japan.", "context": "CREATE TABLE vehicle_sales (sale_id INT, vehicle_id INT, country VARCHAR(20), quantity INT); CREATE TABLE vehicles (vehicle_id INT, model VARCHAR(20), manufacture VARCHAR(20), vehicle_type VARCHAR(20));", "reference_sql": "SELECT SUM(vs.quantity) FROM vehicle_sales vs JOIN vehicles v ON vs.vehicle_id = v.vehicle_id WHERE v.vehicle_type = 'hybrid' AND vs.country IN ('US', 'Germany', 'Japan');", "generated_sql": "SELECT\n  vs.country,\n  SUM(vs.quantity) AS hybrid_vehicles_sold\nFROM vehicle_sales AS vs\nJOIN vehicles AS v\n  ON vs.vehicle_id = v.vehicle_id\nWHERE v.vehicle_type = 'hybrid'\n  AND vs.country IN ('US', 'Germany', 'Japan')\nGROUP BY vs.country;", "raw_model_output": "SELECT\n  vs.country,\n  SUM(vs.quantity) AS hybrid_vehicles_sold\nFROM vehicle_sales AS vs\nJOIN vehicles AS v\n  ON vs.vehicle_id = v.vehicle_id\nWHERE v.vehicle_type = 'hybrid'\n  AND vs.country IN ('US', 'Germany', 'Japan')\nGROUP BY vs.country;", "latency_sec": 3.53790283203125, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 127, "prompt_eval_sec": null, "tokens_completion": 471, "completion_eval_sec": null, "tokens_total": 598, "tokens_per_sec": 169.02668851893384, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns a single total sum of quantities, while the Generated SQL groups results by country, producing separate sums per country. The output structure and results differ due to the GROUP BY clause in the Generated SQL."}
{"example_id": 2399, "sql_complexity": "set operations", "prompt": "What is the average duration of criminal trials for Indigenous defendants compared to non-Indigenous defendants in Canada and New Zealand?", "context": "CREATE TABLE canada_criminal_trials (id INT, defendant_type VARCHAR(255), days_to_completion INT); INSERT INTO canada_criminal_trials (id, defendant_type, days_to_completion) VALUES (1, 'Indigenous', 60), (2, 'Non-Indigenous', 45);CREATE TABLE nz_criminal_trials (id INT, defendant_type VARCHAR(255), days_to_completion INT); INSERT INTO nz_criminal_trials (id, defendant_type, days_to_completion) VALUES (1, 'Indigenous', 70), (2, 'Non-Indigenous', 50);", "reference_sql": "SELECT AVG(days_to_completion) AS avg_duration FROM canada_criminal_trials WHERE defendant_type = 'Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM canada_criminal_trials WHERE defendant_type = 'Non-Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM nz_criminal_trials WHERE defendant_type = 'Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM nz_criminal_trials WHERE defendant_type = 'Non-Indigenous';", "generated_sql": "SELECT country,\n       AVG(CASE WHEN defendant_type = 'Indigenous' THEN days_to_completion END)        AS avg_indigenous,\n       AVG(CASE WHEN defendant_type = 'Non-Indigenous' THEN days_to_completion END)    AS avg_non_indigenous\nFROM (\n  SELECT 'Canada'       AS country, defendant_type, days_to_completion\n  FROM canada_criminal_trials\n  UNION ALL\n  SELECT 'New Zealand' AS country, defendant_type, days_to_completion\n  FROM nz_criminal_trials\n) AS combined\nGROUP BY country;", "raw_model_output": "SELECT country,\n       AVG(CASE WHEN defendant_type = 'Indigenous' THEN days_to_completion END)        AS avg_indigenous,\n       AVG(CASE WHEN defendant_type = 'Non-Indigenous' THEN days_to_completion END)    AS avg_non_indigenous\nFROM (\n  SELECT 'Canada'       AS country, defendant_type, days_to_completion\n  FROM canada_criminal_trials\n  UNION ALL\n  SELECT 'New Zealand' AS country, defendant_type, days_to_completion\n  FROM nz_criminal_trials\n) AS combined\nGROUP BY country;", "latency_sec": 9.263885021209717, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 207, "prompt_eval_sec": null, "tokens_completion": 580, "completion_eval_sec": null, "tokens_total": 787, "tokens_per_sec": 84.95355870654257, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns four separate rows with single average values for each combination of country and defendant_type, while the Generated SQL returns two rows with aggregated averages for each country in separate columns. The structure and column counts differ, making them non-equivalent."}
{"example_id": 2972, "sql_complexity": "set operations", "prompt": "How many indigenous communities are in the Arctic Research Station 13 and 14?", "context": "CREATE TABLE Arctic_Research_Station_13 (id INT, community TEXT); CREATE TABLE Arctic_Research_Station_14 (id INT, community TEXT);", "reference_sql": "SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_13; SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_14; SELECT COUNT(DISTINCT community) FROM (SELECT * FROM Arctic_Research_Station_13 UNION ALL SELECT * FROM Arctic_Research_Station_14) AS Arctic_Communities;", "generated_sql": "SELECT COUNT(*) AS indigenous_community_count\nFROM (\n  SELECT community FROM Arctic_Research_Station_13\n  UNION\n  SELECT community FROM Arctic_Research_Station_14\n) AS combined_stations;", "raw_model_output": "SELECT COUNT(*) AS indigenous_community_count\nFROM (\n  SELECT community FROM Arctic_Research_Station_13\n  UNION\n  SELECT community FROM Arctic_Research_Station_14\n) AS combined_stations;", "latency_sec": 5.269761085510254, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 114, "prompt_eval_sec": null, "tokens_completion": 767, "completion_eval_sec": null, "tokens_total": 881, "tokens_per_sec": 167.18025460820215, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of distinct 'community' values across both tables. The Generated SQL uses UNION to eliminate duplicates before counting, while the third Reference SQL uses UNION ALL (which includes duplicates) but then applies COUNT(DISTINCT). Both approaches yield the same result because COUNT(DISTINCT) inherently removes duplicates, making them semantically equivalent."}
{"example_id": 5576, "sql_complexity": "window functions", "prompt": "Who are the top 5 users with the most followers, and what is their location?", "context": "CREATE TABLE user_data (user_id INT, name VARCHAR(50), followers INT, location VARCHAR(50)); INSERT INTO user_data (user_id, name, followers, location) VALUES (1, 'Alice', 10000, 'New York'), (2, 'Bob', 15000, 'California'), (3, 'Charlie', 12000, 'Texas'), (4, 'David', 8000, 'Florida'), (5, 'Eve', 9000, 'Illinois');", "reference_sql": "SELECT name, location FROM (SELECT name, location, ROW_NUMBER() OVER (ORDER BY followers DESC) AS rank FROM user_data) AS user_ranks WHERE rank <= 5;", "generated_sql": "SELECT name, location\nFROM user_data\nORDER BY followers DESC\nLIMIT 5;", "raw_model_output": "SELECT name, location\nFROM user_data\nORDER BY followers DESC\nLIMIT 5;", "latency_sec": 2.7285900115966797, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 188, "prompt_eval_sec": null, "tokens_completion": 101, "completion_eval_sec": null, "tokens_total": 289, "tokens_per_sec": 105.91550902544236, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the top 5 users by followers in descending order. The Reference SQL uses ROW_NUMBER() to assign ranks and filters where rank <= 5, while the Generated SQL directly orders by followers DESC and limits to 5 results. Since the data has unique follower counts, both approaches yield identical results."}
{"example_id": 1560, "sql_complexity": "basic SQL", "prompt": "What is the average media literacy score for users in the 'Young Adult' age group who have completed at least one disinformation detection course?", "context": "CREATE TABLE users (id INT, age VARCHAR(20), media_literacy_score INT, courses_completed INT);", "reference_sql": "SELECT AVG(media_literacy_score) FROM users WHERE age = 'Young Adult' AND courses_completed > 0;", "generated_sql": "SELECT AVG(media_literacy_score) AS avg_media_literacy_score\nFROM users\nWHERE age = 'Young Adult'\n  AND courses_completed >= 1;", "raw_model_output": "SELECT AVG(media_literacy_score) AS avg_media_literacy_score\nFROM users\nWHERE age = 'Young Adult'\n  AND courses_completed >= 1;", "latency_sec": 2.6459619998931885, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 117, "prompt_eval_sec": null, "tokens_completion": 245, "completion_eval_sec": null, "tokens_total": 362, "tokens_per_sec": 136.81224447464217, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The conditions 'courses_completed > 0' and 'courses_completed >= 1' are equivalent when 'courses_completed' is an integer field. Both filter rows where the value is 1 or higher. The generated query adds an alias ('AS avg_media_literacy_score'), which does not affect the semantic result."}
{"example_id": 1201, "sql_complexity": "basic SQL", "prompt": "What is the maximum energy efficiency rating of hydroelectric dams in Canada?", "context": "CREATE TABLE hydro_dams (id INT, name TEXT, country TEXT, energy_efficiency_rating FLOAT); INSERT INTO hydro_dams (id, name, country, energy_efficiency_rating) VALUES (1, 'Robert-Bourassa', 'Canada', 0.94), (2, 'Churchill Falls', 'Canada', 0.92);", "reference_sql": "SELECT MAX(energy_efficiency_rating) FROM hydro_dams WHERE country = 'Canada';", "generated_sql": "SELECT MAX(energy_efficiency_rating) AS max_energy_efficiency_rating\nFROM hydro_dams\nWHERE country = 'Canada';", "raw_model_output": "SELECT MAX(energy_efficiency_rating) AS max_energy_efficiency_rating\nFROM hydro_dams\nWHERE country = 'Canada';", "latency_sec": 1.8387548923492432, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 152, "prompt_eval_sec": null, "tokens_completion": 173, "completion_eval_sec": null, "tokens_total": 325, "tokens_per_sec": 176.75003957964793, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the maximum energy_efficiency_rating for dams in Canada. The generated query adds an alias (max_energy_efficiency_rating) to the output column, but this does not affect the semantic result - the value returned remains the same."}
{"example_id": 4243, "sql_complexity": "single join", "prompt": "How many orders were placed by new and returning customers in each month of the year 2021?'", "context": "CREATE TABLE customer (id INT, first_order_date DATE, last_order_date DATE);", "reference_sql": "INSERT INTO customer (id, first_order_date, last_order_date) SELECT customer_id, MIN(order_date) AS first_order_date, MAX(order_date) AS last_order_date FROM orders GROUP BY customer_id; SELECT YEAR(order_date) AS year, MONTH(order_date) AS month, CASE WHEN DATEDIFF(last_order_date, first_order_date) > 30 THEN 'returning' ELSE 'new' END AS customer_type, COUNT(DISTINCT id) AS num_orders FROM orders JOIN customer ON orders.customer_id = customer.id WHERE YEAR(order_date) = 2021 GROUP BY year, month, customer_type;", "generated_sql": "SELECT DATE '2021-01-01' UNION ALL\n    SELECT DATE '2021-02-01' UNION ALL\n    SELECT DATE '2021-03-01' UNION ALL\n    SELECT DATE '2021-04-01' UNION ALL\n    SELECT DATE '2021-05-01' UNION ALL\n    SELECT DATE '2021-06-01' UNION ALL\n    SELECT DATE '2021-07-01' UNION ALL\n    SELECT DATE '2021-08-01' UNION ALL\n    SELECT DATE '2021-09-01' UNION ALL\n    SELECT DATE '2021-10-01' UNION ALL\n    SELECT DATE '2021-11-01' UNION ALL\n    SELECT DATE '2021-12-01'\n)\nSELECT \n    TO_CHAR(m.month_start, 'YYYY-MM') AS month,\n    SUM(CASE \n            WHEN c.first_order_date >= m.month_start \n             AND c.first_order_date < m.month_start + INTERVAL '1' MONTH \n            THEN 1 \n            ELSE 0 \n        END) AS new_orders,\n    SUM(CASE \n            WHEN c.first_order_date < m.month_start\n             AND c.last_order_date  >= m.month_start\n             AND c.last_order_date  < m.month_start + INTERVAL '1' MONTH \n            THEN 1 \n            ELSE 0 \n        END) AS returning_orders\nFROM months m\nLEFT JOIN customer c\n  ON (c.first_order_date >= m.month_start \n       AND c.first_order_date < m.month_start + INTERVAL '1' MONTH)\n   OR (c.first_order_date < m.month_start\n       AND c.last_order_date  >= m.month_start\n       AND c.last_order_date  < m.month_start + INTERVAL '1' MONTH)\nGROUP BY m.month_start\nORDER BY m.month_start;", "raw_model_output": "WITH months(month_start) AS (\n    SELECT DATE '2021-01-01' UNION ALL\n    SELECT DATE '2021-02-01' UNION ALL\n    SELECT DATE '2021-03-01' UNION ALL\n    SELECT DATE '2021-04-01' UNION ALL\n    SELECT DATE '2021-05-01' UNION ALL\n    SELECT DATE '2021-06-01' UNION ALL\n    SELECT DATE '2021-07-01' UNION ALL\n    SELECT DATE '2021-08-01' UNION ALL\n    SELECT DATE '2021-09-01' UNION ALL\n    SELECT DATE '2021-10-01' UNION ALL\n    SELECT DATE '2021-11-01' UNION ALL\n    SELECT DATE '2021-12-01'\n)\nSELECT \n    TO_CHAR(m.month_start, 'YYYY-MM') AS month,\n    SUM(CASE \n            WHEN c.first_order_date >= m.month_start \n             AND c.first_order_date < m.month_start + INTERVAL '1' MONTH \n            THEN 1 \n            ELSE 0 \n        END) AS new_orders,\n    SUM(CASE \n            WHEN c.first_order_date < m.month_start\n             AND c.last_order_date  >= m.month_start\n             AND c.last_order_date  < m.month_start + INTERVAL '1' MONTH \n            THEN 1 \n            ELSE 0 \n        END) AS returning_orders\nFROM months m\nLEFT JOIN customer c\n  ON (c.first_order_date >= m.month_start \n       AND c.first_order_date < m.month_start + INTERVAL '1' MONTH)\n   OR (c.first_order_date < m.month_start\n       AND c.last_order_date  >= m.month_start\n       AND c.last_order_date  < m.month_start + INTERVAL '1' MONTH)\nGROUP BY m.month_start\nORDER BY m.month_start;", "latency_sec": 15.092620849609375, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 104, "prompt_eval_sec": null, "tokens_completion": 2593, "completion_eval_sec": null, "tokens_total": 2697, "tokens_per_sec": 178.69659795169395, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The reference query calculates customer types ('new' or 'returning') based on the DATEDIFF between first and last order dates, then counts distinct customers per month. The generated query uses a different approach, categorizing customers as 'new' or 'returning' based on whether their first/last orders fall within specific months, and counts them differently. The logic for determining customer type and the final aggregation metrics differ significantly."}
{"example_id": 2321, "sql_complexity": "subqueries", "prompt": "What are the names and types of vessels used in research expeditions in the regions with the lowest ocean acidification levels?", "context": "CREATE TABLE ocean_acidification (id INT PRIMARY KEY, region VARCHAR(255), year INT, acidification_level INT); INSERT INTO ocean_acidification (id, region, year, acidification_level) VALUES (1, 'Arctic Ocean', 2018, 20), (2, 'Southern Ocean', 2019, 22); CREATE TABLE expedition_vessels (id INT PRIMARY KEY, name VARCHAR(255), type VARCHAR(255), region VARCHAR(255)); INSERT INTO expedition_vessels (id, name, type, region) VALUES (1, 'Sea Researcher', 'Research Vessel', 'Arctic Ocean');", "reference_sql": "SELECT v.name, v.type FROM expedition_vessels v INNER JOIN ocean_acidification oa ON v.region = oa.region WHERE oa.acidification_level = (SELECT MIN(acidification_level) FROM ocean_acidification);", "generated_sql": "SELECT ev.name, ev.type\nFROM expedition_vessels ev\nWHERE ev.region IN (\n  SELECT oa.region\n  FROM ocean_acidification oa\n  WHERE oa.acidification_level = (\n    SELECT MIN(acidification_level)\n    FROM ocean_acidification\n  )\n);", "raw_model_output": "SELECT ev.name, ev.type\nFROM expedition_vessels ev\nWHERE ev.region IN (\n  SELECT oa.region\n  FROM ocean_acidification oa\n  WHERE oa.acidification_level = (\n    SELECT MIN(acidification_level)\n    FROM ocean_acidification\n  )\n);", "latency_sec": 5.4146599769592285, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 222, "prompt_eval_sec": null, "tokens_completion": 270, "completion_eval_sec": null, "tokens_total": 492, "tokens_per_sec": 90.8644313943233, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses an INNER JOIN which may return duplicate rows if multiple entries in ocean_acidification exist for the same region with the minimum acidification_level. The Generated SQL uses IN with a subquery that could include duplicate regions, but the outer query would still return each vessel once per region. However, the Reference SQL's JOIN condition requires matching regions in both tables, while the Generated SQL's subquery might include regions with the minimum level even if they don't have corresponding entries in expedition_vessels. Additionally, the Reference SQL could produce duplicates if multiple ocean_acidification entries exist for the same region and min level, making the results non-equivalent in general cases."}
{"example_id": 4349, "sql_complexity": "multiple_joins", "prompt": "Show the research grants awarded to professors in the Computer Science department.", "context": "CREATE TABLE departments (id INT, name VARCHAR(50)); INSERT INTO departments (id, name) VALUES (1, 'Computer Science'), (2, 'Mathematics'); CREATE TABLE professors (id INT, name VARCHAR(50), department_id INT); INSERT INTO professors (id, name, department_id) VALUES (1, 'John Smith', 1), (2, 'Jane Doe', 2); CREATE TABLE grants (id INT, professor_id INT, year INT, amount FLOAT); INSERT INTO grants (id, professor_id, year, amount) VALUES (1, 1, 2021, 5000.0), (2, 2, 2020, 7000.0);", "reference_sql": "SELECT professors.name, grants.amount FROM professors INNER JOIN grants ON professors.id = grants.professor_id INNER JOIN departments ON professors.department_id = departments.id WHERE departments.name = 'Computer Science';", "generated_sql": "SELECT g.id,\n       p.name AS professor_name,\n       g.year,\n       g.amount\nFROM grants AS g\nJOIN professors AS p\n  ON g.professor_id = p.id\nJOIN departments AS d\n  ON p.department_id = d.id\nWHERE d.name = 'Computer Science';", "raw_model_output": "SELECT g.id,\n       p.name AS professor_name,\n       g.year,\n       g.amount\nFROM grants AS g\nJOIN professors AS p\n  ON g.professor_id = p.id\nJOIN departments AS d\n  ON p.department_id = d.id\nWHERE d.name = 'Computer Science';", "latency_sec": 2.829340934753418, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 226, "prompt_eval_sec": null, "tokens_completion": 336, "completion_eval_sec": null, "tokens_total": 562, "tokens_per_sec": 198.63283109392376, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects only 'professors.name' and 'grants.amount', while the Generated SQL selects additional columns ('g.id', 'g.year') and uses different column aliases. Although both filter for 'Computer Science' department, the result sets differ in structure and content."}
{"example_id": 476, "sql_complexity": "basic SQL", "prompt": "Insert new food safety records for locations \"A123\", \"B456\", and \"C789\"", "context": "CREATE TABLE food_safety_records (id INT, location VARCHAR(255), inspection_date DATE, violation_count INT);", "reference_sql": "INSERT INTO food_safety_records (location, inspection_date, violation_count) VALUES ('A123', '2022-03-01', 0), ('B456', '2022-03-05', 2), ('C789', '2022-03-10', 1);", "generated_sql": "INSERT INTO food_safety_records (location, inspection_date, violation_count)\nVALUES\n  ('A123', CURRENT_DATE, 0),\n  ('B456', CURRENT_DATE, 0),\n  ('C789', CURRENT_DATE, 0);", "raw_model_output": "INSERT INTO food_safety_records (location, inspection_date, violation_count)\nVALUES\n  ('A123', CURRENT_DATE, 0),\n  ('B456', CURRENT_DATE, 0),\n  ('C789', CURRENT_DATE, 0);", "latency_sec": 4.45940089225769, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 109, "prompt_eval_sec": null, "tokens_completion": 581, "completion_eval_sec": null, "tokens_total": 690, "tokens_per_sec": 154.72930482611739, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL uses specific inspection dates (2022-03-01, 2022-03-05, 2022-03-10) and varying violation counts (0, 2, 1), while the Generated SQL uses CURRENT_DATE (which inserts the current date at execution time) and sets all violation_counts to 0. This results in different data being inserted."}
{"example_id": 2908, "sql_complexity": "single join", "prompt": "List all co-owners and the properties they own in New York, NY.", "context": "CREATE TABLE properties (id INT, city VARCHAR(50), price INT); CREATE TABLE co_owners (property_id INT, owner_name VARCHAR(50)); INSERT INTO properties (id, city, price) VALUES (1, 'New York', 800000), (2, 'Los Angeles', 600000); INSERT INTO co_owners (property_id, owner_name) VALUES (1, 'David'), (1, 'Ella'), (2, 'Frank');", "reference_sql": "SELECT properties.city, co_owners.owner_name FROM properties INNER JOIN co_owners ON properties.id = co_owners.property_id WHERE properties.city = 'New York';", "generated_sql": "SELECT c.owner_name,\n       p.id        AS property_id,\n       p.city,\n       p.price\nFROM co_owners AS c\nJOIN properties AS p\n  ON c.property_id = p.id\nWHERE p.city = 'New York';", "raw_model_output": "SELECT c.owner_name,\n       p.id        AS property_id,\n       p.city,\n       p.price\nFROM co_owners AS c\nJOIN properties AS p\n  ON c.property_id = p.id\nWHERE p.city = 'New York';", "latency_sec": 6.654616832733154, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 177, "prompt_eval_sec": null, "tokens_completion": 389, "completion_eval_sec": null, "tokens_total": 566, "tokens_per_sec": 85.05373250281264, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects only 'city' and 'owner_name', while the Generated SQL selects 'owner_name', 'property_id', 'city', and 'price'. The additional columns in the Generated SQL (property_id, price) and the different column order change the result structure, making them non-equivalent."}
{"example_id": 636, "sql_complexity": "set operations", "prompt": "Insert new data into the 'cosmetic_ingredients' table for a vegan eyeshadow product by brand 'Ara' with ingredients 'Mica', 'Iron Oxide', 'Titanium Dioxide' and 'Zinc Oxide'.", "context": "CREATE TABLE cosmetic_ingredients (ingredient_id INT, product_name TEXT, brand_name TEXT, ingredient_type TEXT);", "reference_sql": "INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type) VALUES (NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient'); INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type, ingredient_name) SELECT ingredient_id, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Mica' FROM cosmetic_ingredients WHERE ingredient_name = 'Mica' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Iron Oxide' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Titanium Dioxide' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Zinc Oxide';", "generated_sql": "INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type)\nVALUES\n  (1, 'Vegan Eyeshadow', 'Ara', 'Mica'),\n  (2, 'Vegan Eyeshadow', 'Ara', 'Iron Oxide'),\n  (3, 'Vegan Eyeshadow', 'Ara', 'Titanium Dioxide'),\n  (4, 'Vegan Eyeshadow', 'Ara', 'Zinc Oxide');", "raw_model_output": "INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type)\nVALUES\n  (1, 'Vegan Eyeshadow', 'Ara', 'Mica'),\n  (2, 'Vegan Eyeshadow', 'Ara', 'Iron Oxide'),\n  (3, 'Vegan Eyeshadow', 'Ara', 'Titanium Dioxide'),\n  (4, 'Vegan Eyeshadow', 'Ara', 'Zinc Oxide');", "latency_sec": 5.813227891921997, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 135, "prompt_eval_sec": null, "tokens_completion": 624, "completion_eval_sec": null, "tokens_total": 759, "tokens_per_sec": 130.56429476207165, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL attempts to insert into a non-existent 'ingredient_name' column (schema mismatch) and uses a SELECT with a WHERE clause on 'ingredient_name' which isn't in the table. The Generated SQL directly inserts values into the existing columns without referencing 'ingredient_name'. Additionally, the Reference SQL's first INSERT adds a row with NULL ingredient_id, while the Generated SQL uses explicit IDs. The data structure and column usage differ significantly."}
{"example_id": 3404, "sql_complexity": "multiple_joins", "prompt": "What are the names of startups that have received funding from investors with over 3 million funds, and are involved in Genetic Research or Bioprocess Engineering?", "context": "CREATE TABLE public.investors ( id SERIAL PRIMARY KEY, name VARCHAR(100), type VARCHAR(50), funds INTEGER ); CREATE TABLE public.investments ( id SERIAL PRIMARY KEY, investor_id INTEGER, startup_id INTEGER ); CREATE TABLE public.startups ( id SERIAL PRIMARY KEY, name VARCHAR(100), industry VARCHAR(50), funding INTEGER );", "reference_sql": "SELECT startups.name FROM public.startups JOIN public.investments ON startups.id = investments.startup_id JOIN public.investors ON investments.investor_id = investors.id WHERE (startups.industry = 'Genetic Research' OR startups.industry = 'Bioprocess Engineering') AND investors.funds > 3000000;", "generated_sql": "SELECT DISTINCT s.name\nFROM public.startups AS s\nJOIN public.investments AS i\n  ON s.id = i.startup_id\nJOIN public.investors AS v\n  ON i.investor_id = v.id\nWHERE v.funds > 3000000\n  AND s.industry IN ('Genetic Research', 'Bioprocess Engineering');", "raw_model_output": "SELECT DISTINCT s.name\nFROM public.startups AS s\nJOIN public.investments AS i\n  ON s.id = i.startup_id\nJOIN public.investors AS v\n  ON i.investor_id = v.id\nWHERE v.funds > 3000000\n  AND s.industry IN ('Genetic Research', 'Bioprocess Engineering');", "latency_sec": 7.060643911361694, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 166, "prompt_eval_sec": null, "tokens_completion": 415, "completion_eval_sec": null, "tokens_total": 581, "tokens_per_sec": 82.28711252030129, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their use of DISTINCT. The generated query uses SELECT DISTINCT s.name, which ensures unique startup names, while the reference query returns all matching rows (potentially including duplicates). The WHERE clause logic is equivalent (IN vs OR), but the DISTINCT clause in the generated query may produce fewer results when multiple investments exist for the same startup."}
{"example_id": 134, "sql_complexity": "subqueries", "prompt": "Who are the top 3 authors with the most citations in the Mathematics department in the past 5 years?", "context": "CREATE TABLE authors (id INT, name VARCHAR(50), department VARCHAR(50)); INSERT INTO authors (id, name, department) VALUES (1, 'Author Name', 'Mathematics'); CREATE TABLE publications (id INT, title VARCHAR(100), author VARCHAR(50), journal VARCHAR(50), year INT, cites INT); INSERT INTO publications (id, title, author, journal, year, cites) VALUES (1, 'Publication Title', 'Author Name', 'Journal Name', 2021, 10);", "reference_sql": "SELECT author, SUM(cites) as total_cites FROM publications WHERE author IN (SELECT name FROM authors WHERE department = 'Mathematics') AND year BETWEEN YEAR(CURRENT_DATE) - 5 AND YEAR(CURRENT_DATE) GROUP BY author ORDER BY total_cites DESC LIMIT 3;", "generated_sql": "SELECT a.name,\n       SUM(p.cites) AS total_cites\nFROM authors AS a\nJOIN publications AS p\n  ON a.name = p.author\nWHERE a.department = 'Mathematics'\n  AND p.year >= EXTRACT(YEAR FROM CURRENT_DATE) - 5\nGROUP BY a.name\nORDER BY total_cites DESC\nFETCH FIRST 3 ROWS ONLY;", "raw_model_output": "SELECT a.name,\n       SUM(p.cites) AS total_cites\nFROM authors AS a\nJOIN publications AS p\n  ON a.name = p.author\nWHERE a.department = 'Mathematics'\n  AND p.year >= EXTRACT(YEAR FROM CURRENT_DATE) - 5\nGROUP BY a.name\nORDER BY total_cites DESC\nFETCH FIRST 3 ROWS ONLY;", "latency_sec": 3.753357172012329, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 195, "prompt_eval_sec": null, "tokens_completion": 482, "completion_eval_sec": null, "tokens_total": 677, "tokens_per_sec": 180.3718561740375, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the top 3 authors from the 'Mathematics' department with the highest total citations from publications in the last 5 years. The Reference SQL uses a subquery with IN and BETWEEN, while the Generated SQL uses a JOIN and EXTRACT. The year conditions are equivalent (BETWEEN Y-5 to Y vs >= Y-5), LIMIT 3 vs FETCH FIRST 3 ROWS ONLY are functionally identical, and the JOIN ensures the same author-filtering as the subquery. Both group by author name and order by total_cites descending."}
{"example_id": 592, "sql_complexity": "set operations", "prompt": "How many public healthcare facilities and public parks are there in total, in the 'StateData' schema's 'StateHealthcare' and 'StateParks' tables?", "context": "CREATE SCHEMA StateData; CREATE TABLE StateHealthcare (Name varchar(255), Type varchar(255)); INSERT INTO StateHealthcare (Name, Type) VALUES ('FacilityA', 'Public'), ('FacilityB', 'Public'), ('FacilityC', 'Private'); CREATE TABLE StateParks (Name varchar(255), Type varchar(255)); INSERT INTO StateParks (Name, Type) VALUES ('ParkA', 'Public'), ('ParkB', 'Public'), ('ParkC', 'Private');", "reference_sql": "SELECT COUNT(*) FROM StateData.StateHealthcare WHERE Type = 'Public' UNION ALL SELECT COUNT(*) FROM StateData.StateParks WHERE Type = 'Public';", "generated_sql": "SELECT\n  (SELECT COUNT(*) FROM StateData.StateHealthcare WHERE Type = 'Public')\n  +\n  (SELECT COUNT(*) FROM StateData.StateParks WHERE Type = 'Public')\n  AS TotalPublicCount;", "raw_model_output": "SELECT\n  (SELECT COUNT(*) FROM StateData.StateHealthcare WHERE Type = 'Public')\n  +\n  (SELECT COUNT(*) FROM StateData.StateParks WHERE Type = 'Public')\n  AS TotalPublicCount;", "latency_sec": 2.4089488983154297, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 199, "prompt_eval_sec": null, "tokens_completion": 254, "completion_eval_sec": null, "tokens_total": 453, "tokens_per_sec": 188.04882092633076, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query returns two separate counts as individual rows (using UNION ALL), while the generated query returns a single row with the summed total. The result structures differ (two rows vs. one row), so they are not semantically equivalent."}
{"example_id": 1989, "sql_complexity": "single join", "prompt": "What are the names and production dates of garments made from fabrics with a sustainability score over 70, produced after 2021-01-01?", "context": "CREATE TABLE fabrics (id INT, name VARCHAR(50), type VARCHAR(50), sustainability_score INT); INSERT INTO fabrics (id, name, type, sustainability_score) VALUES (1, 'Organic Linen', 'Natural', 80); INSERT INTO fabrics (id, name, type, sustainability_score) VALUES (2, 'Recycled Nylon', 'Synthetic', 72);", "reference_sql": "SELECT garments.name, garments.production_date FROM garments JOIN fabrics ON garments.fabric_id = fabrics.id WHERE fabrics.sustainability_score > 70 AND garments.production_date > '2021-01-01';", "generated_sql": "Error: The provided schema does not include a \u201cgarments\u201d table required to answer this question.", "raw_model_output": "Error: The provided schema does not include a \u201cgarments\u201d table required to answer this question.", "latency_sec": 7.889695882797241, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 172, "prompt_eval_sec": null, "tokens_completion": 1255, "completion_eval_sec": null, "tokens_total": 1427, "tokens_per_sec": 180.86882196707262, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Generated SQL references a 'garments' table which is not present in the provided schema, making it invalid. The Reference SQL also requires the 'garments' table, but since it's missing, both queries cannot execute. However, since the Generated SQL is invalid, they are not semantically equivalent."}
{"example_id": 1388, "sql_complexity": "aggregation", "prompt": "What was the total donation amount by each organization in the last 30 days?", "context": "CREATE TABLE organization_donations (id INT, organization TEXT, donation_date DATE, donation_amount DECIMAL(10,2)); INSERT INTO organization_donations (id, organization, donation_date, donation_amount) VALUES (1, 'Organization A', '2021-03-15', 100.00), (2, 'Organization B', '2021-03-25', 200.00);", "reference_sql": "SELECT organization, SUM(donation_amount) FROM organization_donations WHERE donation_date >= DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY) GROUP BY organization;", "generated_sql": "SELECT\n  organization,\n  SUM(donation_amount) AS total_donation_amount\nFROM\n  organization_donations\nWHERE\n  donation_date >= CURRENT_DATE - INTERVAL '30' DAY\nGROUP BY\n  organization;", "raw_model_output": "SELECT\n  organization,\n  SUM(donation_amount) AS total_donation_amount\nFROM\n  organization_donations\nWHERE\n  donation_date >= CURRENT_DATE - INTERVAL '30' DAY\nGROUP BY\n  organization;", "latency_sec": 2.6436948776245117, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 166, "prompt_eval_sec": null, "tokens_completion": 258, "completion_eval_sec": null, "tokens_total": 424, "tokens_per_sec": 160.3815945586673, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of donation amounts for each organization where the donation_date is within the last 30 days. The date calculation syntax differs (DATE_SUB vs. CURRENT_DATE - INTERVAL), but both expressions evaluate to the same date value. The column alias in the generated query does not affect semantic equivalence."}
{"example_id": 1628, "sql_complexity": "window functions", "prompt": "What is the ranking of national security measures for Russia based on the publication date?", "context": "CREATE TABLE national_security (id INT, title VARCHAR(255), description TEXT, agency VARCHAR(255), date DATE); INSERT INTO national_security (id, title, description, agency, date) VALUES (1, 'National Cyber Strategy', 'Outlines the approach to protecting the American people and the American way of life in the digital age', 'White House', '2018-09-20'); INSERT INTO national_security (id, title, description, agency, date) VALUES (2, 'Cybersecurity and Infrastructure Security Agency Act of 2018', 'Establishes the Cybersecurity and Infrastructure Security Agency within the Department of Homeland Security', 'Congress', '2018-11-16'); INSERT INTO national_security (id, title, description, agency, date) VALUES (3, 'Russian Military Doctrine', 'Outlines the country\u2019s stance on military security', 'Russian Government', '2014-12-26');", "reference_sql": "SELECT title, description, agency, date, ROW_NUMBER() OVER (PARTITION BY agency ORDER BY date DESC) as ranking FROM national_security WHERE agency = 'Russian Government';", "generated_sql": "SELECT \n  title, \n  date, \n  ROW_NUMBER() OVER (ORDER BY date) AS ranking \nFROM national_security \nWHERE agency = 'Russian Government' \nORDER BY date;", "raw_model_output": "SELECT \n  title, \n  date, \n  ROW_NUMBER() OVER (ORDER BY date) AS ranking \nFROM national_security \nWHERE agency = 'Russian Government' \nORDER BY date;", "latency_sec": 3.623598098754883, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 271, "prompt_eval_sec": null, "tokens_completion": 442, "completion_eval_sec": null, "tokens_total": 713, "tokens_per_sec": 196.76575066230342, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL includes 'description' and 'agency' columns and uses a partitioned row number (by agency) with descending date ordering, while the Generated SQL omits 'description' and 'agency', uses a non-partitioned row number with ascending date ordering, and lacks the explicit 'ORDER BY date' in the window function. Additionally, the Generated SQL's final ORDER BY date would affect the output order but not the ranking calculation."}
{"example_id": 2300, "sql_complexity": "aggregation", "prompt": "What is the minimum capacity for schools in each location ('community_development')?", "context": "CREATE TABLE community_development.schools (id INT, name VARCHAR(50), capacity INT, location VARCHAR(50));", "reference_sql": "SELECT location, MIN(capacity) FROM community_development.schools GROUP BY location;", "generated_sql": "SELECT\n  location,\n  MIN(capacity) AS min_capacity\nFROM\n  community_development.schools\nGROUP BY\n  location;", "raw_model_output": "SELECT\n  location,\n  MIN(capacity) AS min_capacity\nFROM\n  community_development.schools\nGROUP BY\n  location;", "latency_sec": 2.3680388927459717, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 106, "prompt_eval_sec": null, "tokens_completion": 240, "completion_eval_sec": null, "tokens_total": 346, "tokens_per_sec": 146.11246506968445, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. The generated SQL adds an explicit column alias ('min_capacity') for the MIN(capacity) expression, but this does not affect the data returned. Both queries group by 'location' and retrieve the minimum capacity per location, producing identical result sets in terms of data content."}
{"example_id": 4976, "sql_complexity": "set operations", "prompt": "What is the most common hashtag used in posts made by users from Brazil?", "context": "CREATE TABLE posts (id INT, user_id INT, content TEXT, hashtags TEXT, post_date DATE); INSERT INTO posts (id, user_id, content, hashtags, post_date) VALUES (1, 1, 'Hello World', '#datascience', '2022-06-01'), (2, 1, 'I love data', '#ai', '2022-06-02'), (3, 2, 'Ol\u00e1 Mundo', '#brasil', '2022-06-03'); CREATE TABLE users (id INT, name VARCHAR(100), country VARCHAR(50)); INSERT INTO users (id, name, country) VALUES (1, 'Jo\u00e3o Silva', 'Brazil'), (2, 'Maria Souza', 'Brazil');", "reference_sql": "SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(hashtags, ' ', n.n), ' ', -1) hashtag, COUNT(*) count FROM posts JOIN users ON posts.user_id = users.id CROSS JOIN (SELECT 1 n UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5) n WHERE users.country = 'Brazil' GROUP BY hashtag ORDER BY count DESC LIMIT 1;", "generated_sql": "SELECT p.hashtags AS most_common_hashtag\nFROM posts p\nJOIN users u ON p.user_id = u.id\nWHERE u.country = 'Brazil'\nGROUP BY p.hashtags\nORDER BY COUNT(*) DESC\nFETCH FIRST 1 ROW ONLY;", "raw_model_output": "SELECT p.hashtags AS most_common_hashtag\nFROM posts p\nJOIN users u ON p.user_id = u.id\nWHERE u.country = 'Brazil'\nGROUP BY p.hashtags\nORDER BY COUNT(*) DESC\nFETCH FIRST 1 ROW ONLY;", "latency_sec": 3.534172296524048, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 234, "prompt_eval_sec": null, "tokens_completion": 326, "completion_eval_sec": null, "tokens_total": 560, "tokens_per_sec": 158.45294258878516, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL splits multi-value hashtags into individual tags using SUBSTRING_INDEX and a numbers table, while the Generated SQL treats the entire hashtags field as a single string. This difference means they would produce different results when posts contain multiple hashtags."}
{"example_id": 4637, "sql_complexity": "single join", "prompt": "What is the total value of transactions for each customer in the last 30 days?", "context": "CREATE TABLE transactions (id INT, customer_id INT, value DECIMAL(10, 2), transaction_date DATE); INSERT INTO transactions (id, customer_id, value, transaction_date) VALUES (1, 1, 100, '2022-01-01'), (2, 1, 200, '2022-01-15'), (3, 2, 50, '2022-01-05'), (4, 2, 150, '2022-01-30'), (5, 3, 300, '2022-01-20');", "reference_sql": "SELECT c.id, SUM(t.value) FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE t.transaction_date >= CURDATE() - INTERVAL 30 DAY GROUP BY c.id;", "generated_sql": "SELECT\n  customer_id,\n  SUM(value) AS total_value\nFROM\n  transactions\nWHERE\n  transaction_date >= CURRENT_DATE - INTERVAL '30' DAY\nGROUP BY\n  customer_id;", "raw_model_output": "SELECT\n  customer_id,\n  SUM(value) AS total_value\nFROM\n  transactions\nWHERE\n  transaction_date >= CURRENT_DATE - INTERVAL '30' DAY\nGROUP BY\n  customer_id;", "latency_sec": 1.820906162261963, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 207, "prompt_eval_sec": null, "tokens_completion": 189, "completion_eval_sec": null, "tokens_total": 396, "tokens_per_sec": 217.47413908912338, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the total transaction value per customer for the last 30 days. The Reference SQL uses an INNER JOIN between customers and transactions, while the Generated SQL directly filters transactions. However, since the JOIN condition is c.id = t.customer_id and the WHERE clause filters transactions, both approaches yield the same customer_id values with their corresponding sums. The output structure differs slightly (c.id vs customer_id) but represents the same data."}
{"example_id": 4947, "sql_complexity": "aggregation", "prompt": "What is the total revenue for drugs approved between 2017 and 2019?", "context": "CREATE TABLE drug_sales_3 (drug_name TEXT, revenue FLOAT, year INT); INSERT INTO drug_sales_3 (drug_name, revenue, year) VALUES ('DrugG', 20000000, 2019), ('DrugG', 19000000, 2018), ('DrugH', 15000000, 2017), ('DrugH', 16000000, 2018);", "reference_sql": "SELECT drug_name, SUM(revenue) FROM drug_sales_3 WHERE year BETWEEN 2017 AND 2019 GROUP BY drug_name;", "generated_sql": "SELECT SUM(revenue) AS total_revenue\nFROM drug_sales_3\nWHERE year BETWEEN 2017 AND 2019;", "raw_model_output": "SELECT SUM(revenue) AS total_revenue\nFROM drug_sales_3\nWHERE year BETWEEN 2017 AND 2019;", "latency_sec": 1.6345181465148926, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 167, "prompt_eval_sec": null, "tokens_completion": 174, "completion_eval_sec": null, "tokens_total": 341, "tokens_per_sec": 208.6241750983785, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query groups results by drug_name and calculates per-drug revenue sums, while the generated query calculates a single total revenue for all drugs combined. The GROUP BY clause in the reference query ensures per-drug aggregation, which is missing in the generated query. This leads to different result structures (multiple rows vs. single row) and values (per-drug totals vs. overall total)."}
{"example_id": 4767, "sql_complexity": "window functions", "prompt": "List the top 2 AI algorithms with the highest explainability scores, by algorithm subtype, ordered by scores in descending order for the European region.", "context": "CREATE TABLE ai_algorithms (algorithm_id INT, algorithm_name VARCHAR(50), algorithm_subtype VARCHAR(50), region VARCHAR(50), explainability_score FLOAT); INSERT INTO ai_algorithms (algorithm_id, algorithm_name, algorithm_subtype, region, explainability_score) VALUES (1, 'AlgoA', 'Tree-based', 'Europe', 0.85), (2, 'AlgoB', 'Computer Vision', 'Europe', 0.92), (3, 'AlgoC', 'Tree-based', 'Europe', 0.78), (4, 'AlgoD', 'Transformer', 'Europe', 0.90), (5, 'AlgoE', 'Tree-based', 'Europe', 0.80);", "reference_sql": "SELECT algorithm_subtype, region, * FROM (SELECT algorithm_subtype, region, algorithm_id, algorithm_name, explainability_score, RANK() OVER (PARTITION BY algorithm_subtype ORDER BY explainability_score DESC) AS rank FROM ai_algorithms WHERE region = 'Europe') ranked WHERE rank <= 2 ORDER BY algorithm_subtype, region, explainability_score DESC;", "generated_sql": "SELECT\n  algorithm_subtype,\n  algorithm_id,\n  algorithm_name,\n  explainability_score\nFROM (\n  SELECT\n    algorithm_subtype,\n    algorithm_id,\n    algorithm_name,\n    explainability_score,\n    ROW_NUMBER() OVER (\n      PARTITION BY algorithm_subtype\n      ORDER BY explainability_score DESC\n    ) AS rn\n  FROM ai_algorithms\n  WHERE region = 'Europe'\n) AS ranked\nWHERE rn <= 2\nORDER BY\n  algorithm_subtype,\n  explainability_score DESC;", "raw_model_output": "```sql\nSELECT\n  algorithm_subtype,\n  algorithm_id,\n  algorithm_name,\n  explainability_score\nFROM (\n  SELECT\n    algorithm_subtype,\n    algorithm_id,\n    algorithm_name,\n    explainability_score,\n    ROW_NUMBER() OVER (\n      PARTITION BY algorithm_subtype\n      ORDER BY explainability_score DESC\n    ) AS rn\n  FROM ai_algorithms\n  WHERE region = 'Europe'\n) AS ranked\nWHERE rn <= 2\nORDER BY\n  algorithm_subtype,\n  explainability_score DESC;\n```", "latency_sec": 5.330783128738403, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 245, "prompt_eval_sec": null, "tokens_completion": 514, "completion_eval_sec": null, "tokens_total": 759, "tokens_per_sec": 142.3805811773151, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL includes 'region' in the output and uses 'RANK()', while the Generated SQL omits 'region' and uses 'ROW_NUMBER()'. Additionally, the Reference SQL selects all columns via '*' which includes 'algorithm_subtype', 'region', and other fields, whereas the Generated SQL explicitly lists only specific columns. The ranking functions (RANK vs ROW_NUMBER) could also produce different results if there were ties, but the column selection differences alone make them non-equivalent."}
{"example_id": 4495, "sql_complexity": "basic SQL", "prompt": "Which countries are the top 3 sources of sustainable textiles?", "context": "CREATE TABLE Textile_Sources (Source_ID INT, Source_Country TEXT, Sustainable BOOLEAN, Quantity INT); INSERT INTO Textile_Sources (Source_ID, Source_Country, Sustainable, Quantity) VALUES (1, 'India', true, 1000), (2, 'Bangladesh', false, 800), (3, 'China', true, 1200), (4, 'Vietnam', false, 900), (5, 'Italy', true, 1100), (6, 'USA', false, 700);", "reference_sql": "SELECT Source_Country FROM Textile_Sources WHERE Sustainable = true ORDER BY Quantity DESC LIMIT 3;", "generated_sql": "SELECT Source_Country\nFROM Textile_Sources\nWHERE Sustainable = TRUE\nORDER BY Quantity DESC\nFETCH FIRST 3 ROWS ONLY;", "raw_model_output": "SELECT Source_Country\nFROM Textile_Sources\nWHERE Sustainable = TRUE\nORDER BY Quantity DESC\nFETCH FIRST 3 ROWS ONLY;", "latency_sec": 5.208179950714111, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 187, "prompt_eval_sec": null, "tokens_completion": 303, "completion_eval_sec": null, "tokens_total": 490, "tokens_per_sec": 94.082770687064, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select Source_Country from Textile_Sources where Sustainable is true, order by Quantity descending, and limit to 3 results. The difference is purely syntactic: 'LIMIT 3' (Reference) vs 'FETCH FIRST 3 ROWS ONLY' (Generated), which are equivalent in modern SQL standards for achieving the same result."}
{"example_id": 2513, "sql_complexity": "single join", "prompt": "What is the total number of concert ticket sales for artists who released their first album between 2015 and 2017?", "context": "CREATE TABLE ConcertTicketSales (id INT, year INT, artist_id INT); CREATE TABLE ArtistAlbums (id INT, artist_id INT, year INT);", "reference_sql": "SELECT COUNT(DISTINCT cts.artist_id) FROM ConcertTicketSales cts JOIN ArtistAlbums a ON cts.artist_id = a.artist_id WHERE a.year BETWEEN 2015 AND 2017;", "generated_sql": "SELECT COUNT(*) AS total_sales\nFROM ConcertTicketSales c\nWHERE c.artist_id IN (\n  SELECT artist_id\n  FROM ArtistAlbums\n  GROUP BY artist_id\n  HAVING MIN(year) BETWEEN 2015 AND 2017\n);", "raw_model_output": "SELECT COUNT(*) AS total_sales\nFROM ConcertTicketSales c\nWHERE c.artist_id IN (\n  SELECT artist_id\n  FROM ArtistAlbums\n  GROUP BY artist_id\n  HAVING MIN(year) BETWEEN 2015 AND 2017\n);", "latency_sec": 3.4621028900146484, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 122, "prompt_eval_sec": null, "tokens_completion": 454, "completion_eval_sec": null, "tokens_total": 576, "tokens_per_sec": 166.3728717194661, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query counts distinct artists with at least one album between 2015-2017 (via JOIN), while the generated query counts artists whose earliest album is between 2015-2017 (via HAVING MIN(year)). The generated query's subquery filters artists based on their minimum album year, whereas the reference query considers any album in the range. This makes them semantically different."}
{"example_id": 873, "sql_complexity": "subqueries", "prompt": "Identify attorneys who have never handled cases in the 'West' region but have in the 'North' or 'South'.", "context": "CREATE TABLE attorney_regions(attorney_id INT, region VARCHAR(20)); INSERT INTO attorney_regions(attorney_id, region) VALUES (1, 'North'), (2, 'South'), (3, 'East'), (4, 'West'), (5, 'West'), (6, 'North'); CREATE TABLE handled_cases(attorney_id INT, case_id INT); INSERT INTO handled_cases(attorney_id, case_id) VALUES (1, 101), (2, 102), (3, 103), (4, 104), (5, 105), (6, 106), (1, 107), (1, 108);", "reference_sql": "SELECT h.attorney_id FROM attorney_regions h LEFT JOIN handled_cases i ON h.attorney_id = i.attorney_id WHERE h.region IN ('North', 'South') AND h.region != 'West' AND i.attorney_id IS NOT NULL AND h.attorney_id NOT IN (SELECT attorney_id FROM attorney_regions WHERE region = 'West');", "generated_sql": "SELECT DISTINCT attorney_id\nFROM attorney_regions\nWHERE region IN ('North', 'South')\n  AND attorney_id NOT IN (\n    SELECT attorney_id\n    FROM attorney_regions\n    WHERE region = 'West'\n  );", "raw_model_output": "SELECT DISTINCT attorney_id\nFROM attorney_regions\nWHERE region IN ('North', 'South')\n  AND attorney_id NOT IN (\n    SELECT attorney_id\n    FROM attorney_regions\n    WHERE region = 'West'\n  );", "latency_sec": 4.953927993774414, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 224, "prompt_eval_sec": null, "tokens_completion": 703, "completion_eval_sec": null, "tokens_total": 927, "tokens_per_sec": 187.12423780986686, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a LEFT JOIN with handled_cases and filters for non-null i.attorney_id, ensuring only attorneys with cases are selected. The Generated SQL omits this condition, potentially including attorneys without cases. Additionally, the Reference SQL's subquery for 'West' region exclusion is redundant given the region IN ('North','South') filter, but the core difference lies in the handled_cases requirement."}
{"example_id": 471, "sql_complexity": "set operations", "prompt": "Find the number of donations made by first-time donors in the last quarter.", "context": "CREATE TABLE Donations (DonationID INT, DonorID INT, DonationDate DATE, DonationType TEXT, DonationAmount FLOAT); INSERT INTO Donations (DonationID, DonorID, DonationDate, DonationType, DonationAmount) VALUES (1, 1, '2021-01-01', 'Individual', 100), (2, 2, '2021-02-01', 'Corporate', 5000);", "reference_sql": "SELECT COUNT(*) FROM (SELECT DonationID FROM Donations WHERE DonationType = 'Individual' AND DonationDate >= DATEADD(quarter, -1, CURRENT_DATE) EXCEPT SELECT DonationID FROM PreviousDonations) AS FirstTimeDonors;", "generated_sql": "SELECT \n  COUNT(*) AS FirstTimeDonationsLastQuarter\nFROM \n  Donations d\nWHERE \n  EXTRACT(YEAR FROM d.DonationDate) = CASE \n    WHEN EXTRACT(QUARTER FROM CURRENT_DATE) = 1 \n    THEN EXTRACT(YEAR FROM CURRENT_DATE) - 1 \n    ELSE EXTRACT(YEAR FROM CURRENT_DATE) \n  END\n  AND EXTRACT(QUARTER FROM d.DonationDate) = CASE \n    WHEN EXTRACT(QUARTER FROM CURRENT_DATE) = 1 \n    THEN 4 \n    ELSE EXTRACT(QUARTER FROM CURRENT_DATE) - 1 \n  END\n  AND d.DonationDate = (\n    SELECT \n      MIN(d2.DonationDate) \n    FROM \n      Donations d2 \n    WHERE \n      d2.DonorID = d.DonorID\n  );", "raw_model_output": "SELECT \n  COUNT(*) AS FirstTimeDonationsLastQuarter\nFROM \n  Donations d\nWHERE \n  EXTRACT(YEAR FROM d.DonationDate) = CASE \n    WHEN EXTRACT(QUARTER FROM CURRENT_DATE) = 1 \n    THEN EXTRACT(YEAR FROM CURRENT_DATE) - 1 \n    ELSE EXTRACT(YEAR FROM CURRENT_DATE) \n  END\n  AND EXTRACT(QUARTER FROM d.DonationDate) = CASE \n    WHEN EXTRACT(QUARTER FROM CURRENT_DATE) = 1 \n    THEN 4 \n    ELSE EXTRACT(QUARTER FROM CURRENT_DATE) - 1 \n  END\n  AND d.DonationDate = (\n    SELECT \n      MIN(d2.DonationDate) \n    FROM \n      Donations d2 \n    WHERE \n      d2.DonorID = d.DonorID\n  );", "latency_sec": 8.105156183242798, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 168, "prompt_eval_sec": null, "tokens_completion": 1288, "completion_eval_sec": null, "tokens_total": 1456, "tokens_per_sec": 179.63873453916196, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL counts unique 'Individual' donations in the last quarter not present in PreviousDonations, while the Generated SQL counts first-time donations in the previous quarter. The date logic differs (quarter vs. 3-month window), and the Generated SQL includes a first-donation check via MIN(DonationDate) subquery, which the Reference SQL lacks. The semantics of 'new' donations vs. 'first-time' donations also differ."}
{"example_id": 1301, "sql_complexity": "multiple_joins", "prompt": "What is the total quantity of corn sold by farmers in 'Summerfield'?", "context": "CREATE TABLE farmers (id INT, name VARCHAR(50), location VARCHAR(50), crops VARCHAR(50)); CREATE TABLE crops (id INT, name VARCHAR(50), yield INT); CREATE TABLE sales (id INT, farmer_id INT, crop_name VARCHAR(50), quantity INT, price DECIMAL(5,2)); INSERT INTO farmers VALUES (1, 'Jane Doe', 'Summerfield', 'Corn'); INSERT INTO crops VALUES (1, 'Corn', 100); INSERT INTO sales VALUES (1, 1, 'Corn', 50, 2.50);", "reference_sql": "SELECT SUM(quantity) FROM sales INNER JOIN farmers ON sales.farmer_id = farmers.id INNER JOIN crops ON sales.crop_name = crops.name WHERE farmers.location = 'Summerfield' AND crops.name = 'Corn';", "generated_sql": "SELECT SUM(s.quantity) AS total_quantity\nFROM farmers f\nJOIN sales s ON f.id = s.farmer_id\nWHERE f.location = 'Summerfield'\n  AND s.crop_name = 'Corn';", "raw_model_output": "SELECT SUM(s.quantity) AS total_quantity\nFROM farmers f\nJOIN sales s ON f.id = s.farmer_id\nWHERE f.location = 'Summerfield'\n  AND s.crop_name = 'Corn';", "latency_sec": 2.2180941104888916, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 199, "prompt_eval_sec": null, "tokens_completion": 254, "completion_eval_sec": null, "tokens_total": 453, "tokens_per_sec": 204.22938677753126, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the total quantity of sales for farmers in 'Summerfield' with crop 'Corn'. The Reference SQL joins with the crops table but filters on crops.name = 'Corn', which is equivalent to filtering sales.crop_name = 'Corn' in the Generated SQL. Since the sales.crop_name is a foreign key to crops.name, the join is redundant and the WHERE clauses achieve the same result."}
{"example_id": 4667, "sql_complexity": "aggregation", "prompt": "Find the number of unique organizations in each country in the Philanthropy Trends table?", "context": "CREATE TABLE PhilanthropyTrends (OrgID INT, Name TEXT, Country TEXT);", "reference_sql": "SELECT Country, COUNT(DISTINCT OrgID) as UniqueOrganizations FROM PhilanthropyTrends GROUP BY Country;", "generated_sql": "SELECT\n  Country,\n  COUNT(DISTINCT OrgID) AS UniqueOrganizationCount\nFROM\n  PhilanthropyTrends\nGROUP BY\n  Country;", "raw_model_output": "SELECT\n  Country,\n  COUNT(DISTINCT OrgID) AS UniqueOrganizationCount\nFROM\n  PhilanthropyTrends\nGROUP BY\n  Country;", "latency_sec": 2.1419761180877686, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 101, "prompt_eval_sec": null, "tokens_completion": 180, "completion_eval_sec": null, "tokens_total": 281, "tokens_per_sec": 131.18727030946565, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. Both aggregate the count of distinct OrgID per Country. The only difference is the column alias name ('UniqueOrganizations' vs 'UniqueOrganizationCount'), which does not affect the result's content or structure."}
{"example_id": 1006, "sql_complexity": "subqueries", "prompt": "What is the average word count of news articles written by investigative journalists?", "context": "CREATE TABLE reporters (id INT, name VARCHAR(50), gender VARCHAR(10), age INT, position VARCHAR(20), country VARCHAR(50)); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (1, 'Anna Smith', 'Female', 35, 'News Reporter', 'USA'); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (2, 'Mike Johnson', 'Male', 40, 'Investigative Journalist', 'Canada'); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (3, 'Sofia Rodriguez', 'Female', 32, 'Investigative Journalist', 'Mexico'); CREATE TABLE news_articles (id INT, title VARCHAR(100), content TEXT, publication_date DATE, reporter_id INT); INSERT INTO news_articles (id, title, content, publication_date, reporter_id) VALUES (1, 'News Article 1', 'Content of News Article 1', '2021-01-01', 2); INSERT INTO news_articles (id, title, content, publication_date, reporter_id) VALUES (2, 'News Article 2', 'Content of News Article 2', '2021-02-01', 3);", "reference_sql": "SELECT AVG(LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1) AS avg_word_count FROM news_articles WHERE reporter_id IN (SELECT id FROM reporters WHERE position = 'Investigative Journalist');", "generated_sql": "SELECT AVG(\n  (CHAR_LENGTH(na.content)\n   - CHAR_LENGTH(REPLACE(na.content, ' ', ''))\n  ) + 1\n) AS average_word_count\nFROM news_articles AS na\nJOIN reporters AS r\n  ON na.reporter_id = r.id\nWHERE r.position = 'Investigative Journalist';", "raw_model_output": "SELECT AVG(\n  (CHAR_LENGTH(na.content)\n   - CHAR_LENGTH(REPLACE(na.content, ' ', ''))\n  ) + 1\n) AS average_word_count\nFROM news_articles AS na\nJOIN reporters AS r\n  ON na.reporter_id = r.id\nWHERE r.position = 'Investigative Journalist';", "latency_sec": 3.9940848350524902, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 340, "prompt_eval_sec": null, "tokens_completion": 406, "completion_eval_sec": null, "tokens_total": 746, "tokens_per_sec": 186.7762030122718, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average word count of news articles written by 'Investigative Journalists'. The Reference SQL uses a subquery to filter reporter_ids, while the Generated SQL uses a JOIN. The word count calculation (CHAR_LENGTH/LENGTH difference + 1) is functionally equivalent in this context, assuming single-byte character sets. The logical result set and aggregation method are identical."}
{"example_id": 3635, "sql_complexity": "set operations", "prompt": "Which brands have certifications related to cruelty-free, vegan, or organic products?", "context": "CREATE TABLE brands (brand_name VARCHAR(50), is_cruelty_free BOOLEAN, is_vegan BOOLEAN, is_organic BOOLEAN); INSERT INTO brands (brand_name, is_cruelty_free, is_vegan, is_organic) VALUES ('Lush', TRUE, TRUE, FALSE), ('The Body Shop', TRUE, FALSE, FALSE), ('Est\u00e9e Lauder', FALSE, FALSE, FALSE), ('Urban Decay', TRUE, TRUE, FALSE), ('Maybelline', FALSE, FALSE, FALSE), ('Kat Von D', TRUE, TRUE, FALSE), ('Tarte', TRUE, TRUE, TRUE);", "reference_sql": "SELECT brand_name, 'Cruelty-free' as certification FROM brands WHERE is_cruelty_free = TRUE UNION SELECT brand_name, 'Vegan' as certification FROM brands WHERE is_vegan = TRUE UNION SELECT brand_name, 'Organic' as certification FROM brands WHERE is_organic = TRUE;", "generated_sql": "SELECT brand_name\nFROM brands\nWHERE is_cruelty_free = TRUE\n   OR is_vegan = TRUE\n   OR is_organic = TRUE;", "raw_model_output": "SELECT brand_name\nFROM brands\nWHERE is_cruelty_free = TRUE\n   OR is_vegan = TRUE\n   OR is_organic = TRUE;", "latency_sec": 2.4457006454467773, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 208, "prompt_eval_sec": null, "tokens_completion": 244, "completion_eval_sec": null, "tokens_total": 452, "tokens_per_sec": 184.81411485968238, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns each brand once per certification they meet (e.g., a brand with both cruelty-free and vegan would appear twice), while the Generated SQL returns each brand only once if they meet any of the conditions. The first query explicitly labels certifications, while the second query only lists brands without distinguishing between certification types."}
{"example_id": 4932, "sql_complexity": "basic SQL", "prompt": "Delete the workout row with the id of 2.", "context": "CREATE TABLE Workouts (id INT, user_id INT, workout_name TEXT, calories INT); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (1, 1, 'Running', 300); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (2, 1, 'Cycling', 400); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (3, 2, 'Yoga', 200);", "reference_sql": "DELETE FROM Workouts WHERE id = 2;", "generated_sql": "DELETE FROM Workouts\nWHERE id = 2;", "raw_model_output": "DELETE FROM Workouts\nWHERE id = 2;", "latency_sec": 1.4139740467071533, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 181, "prompt_eval_sec": null, "tokens_completion": 30, "completion_eval_sec": null, "tokens_total": 211, "tokens_per_sec": 149.2248040134643, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries perform the same DELETE operation on the Workouts table with the identical WHERE condition (id = 2). The only difference is formatting (line break), which does not affect semantic meaning."}
{"example_id": 365, "sql_complexity": "aggregation", "prompt": "Identify the total number of military personnel and their corresponding rank for each branch and country in the 'military_personnel' table, sorted by the total number of personnel in descending order.", "context": "CREATE TABLE military_personnel (id INT, branch VARCHAR(255), rank VARCHAR(255), country VARCHAR(255), personnel INT);", "reference_sql": "SELECT branch, country, SUM(personnel) as total_personnel FROM military_personnel GROUP BY branch, country ORDER BY total_personnel DESC;", "generated_sql": "SELECT \n  branch,\n  country,\n  rank,\n  SUM(personnel) AS total_personnel\nFROM military_personnel\nGROUP BY\n  branch,\n  country,\n  rank\nORDER BY\n  total_personnel DESC;", "raw_model_output": "SELECT \n  branch,\n  country,\n  rank,\n  SUM(personnel) AS total_personnel\nFROM military_personnel\nGROUP BY\n  branch,\n  country,\n  rank\nORDER BY\n  total_personnel DESC;", "latency_sec": 2.022156000137329, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 130, "prompt_eval_sec": null, "tokens_completion": 194, "completion_eval_sec": null, "tokens_total": 324, "tokens_per_sec": 160.22502713835948, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The generated query includes an additional 'rank' column in both the SELECT and GROUP BY clauses, which changes the aggregation logic. The reference query groups only by 'branch' and 'country', while the generated query groups by 'branch', 'country', and 'rank', leading to different result sets."}
{"example_id": 521, "sql_complexity": "subqueries", "prompt": "How many vessels have not had an inspection in the past year?", "context": "CREATE TABLE safety_records(id INT, vessel_name VARCHAR(50), inspection_date DATE); CREATE TABLE vessels(id INT, name VARCHAR(50), country VARCHAR(50)); INSERT INTO vessels(id, name, country) VALUES (1, 'Vessel A', 'Philippines'), (2, 'Vessel B', 'Philippines'); INSERT INTO safety_records(id, vessel_name, inspection_date) VALUES (1, 'Vessel A', '2022-01-01');", "reference_sql": "SELECT COUNT(*) FROM vessels WHERE name NOT IN (SELECT vessel_name FROM safety_records WHERE inspection_date BETWEEN DATE_SUB(NOW(), INTERVAL 1 YEAR) AND NOW());", "generated_sql": "SELECT COUNT(*) AS vessels_without_recent_inspection\nFROM vessels v\nWHERE NOT EXISTS (\n  SELECT 1\n  FROM safety_records s\n  WHERE s.vessel_name = v.name\n    AND s.inspection_date >= CURRENT_DATE - INTERVAL '1' YEAR\n);", "raw_model_output": "SELECT COUNT(*) AS vessels_without_recent_inspection\nFROM vessels v\nWHERE NOT EXISTS (\n  SELECT 1\n  FROM safety_records s\n  WHERE s.vessel_name = v.name\n    AND s.inspection_date >= CURRENT_DATE - INTERVAL '1' YEAR\n);", "latency_sec": 5.97079873085022, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 175, "prompt_eval_sec": null, "tokens_completion": 780, "completion_eval_sec": null, "tokens_total": 955, "tokens_per_sec": 159.9450999856449, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count vessels that do not have a safety record with an inspection date within the last year. The Reference SQL uses NOT IN with a subquery filtering by date range, while the Generated SQL uses NOT EXISTS with an explicit date condition. The date ranges (BETWEEN DATE_SUB(NOW(), INTERVAL 1 YEAR) AND NOW() vs. >= CURRENT_DATE - INTERVAL '1' YEAR) are semantically equivalent for DATE-type columns. Both approaches correctly exclude vessels with recent inspections, and the subquery results are comparable since they both check for vessel name existence."}
{"example_id": 5687, "sql_complexity": "multiple_joins", "prompt": "List organizations with more than 200 volunteers, and their average donation amounts, excluding donations less than $10.", "context": "CREATE TABLE organizations (org_id INT, org_name TEXT, social_impact_score INT);CREATE TABLE volunteers (vol_id INT, org_id INT, vol_country TEXT);CREATE TABLE donations (donation_id INT, donor_id INT, donation_amount INT, donation_date DATE);", "reference_sql": "SELECT o.org_name, AVG(donation_amount) AS avg_donation_amount FROM organizations o JOIN volunteers v ON o.org_id = v.org_id JOIN donations don ON o.org_id = don.org_id WHERE donation_amount >= 10 GROUP BY o.org_name HAVING COUNT(v.vol_id) > 200;", "generated_sql": "SELECT \n  o.org_id,\n  o.org_name,\n  (\n    SELECT AVG(d.donation_amount)\n    FROM donations d\n      JOIN volunteers v2 \n        ON v2.vol_id = d.donor_id\n    WHERE v2.org_id = o.org_id\n      AND d.donation_amount >= 10\n  ) AS avg_donation\nFROM organizations o\nWHERE (\n  SELECT COUNT(*) \n  FROM volunteers v \n  WHERE v.org_id = o.org_id\n) > 200;", "raw_model_output": "Here\u2019s one way to do it in a single ANSI\u2010SQL statement (no non\u2010standard extensions).  It first filters to orgs with >200 volunteers, then computes each org\u2019s average donation \u226510 by correlating through the volunteers table:\n\nSELECT \n  o.org_id,\n  o.org_name,\n  (\n    SELECT AVG(d.donation_amount)\n    FROM donations d\n      JOIN volunteers v2 \n        ON v2.vol_id = d.donor_id\n    WHERE v2.org_id = o.org_id\n      AND d.donation_amount >= 10\n  ) AS avg_donation\nFROM organizations o\nWHERE (\n  SELECT COUNT(*) \n  FROM volunteers v \n  WHERE v.org_id = o.org_id\n) > 200;", "latency_sec": 15.386359930038452, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 143, "prompt_eval_sec": null, "tokens_completion": 2349, "completion_eval_sec": null, "tokens_total": 2492, "tokens_per_sec": 161.96163428719245, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in join logic and aggregation. The reference query joins organizations, volunteers, and donations on org_id, filtering donations >=10 and grouping by org_name. The generated query uses subqueries that join donations with volunteers on vol_id = donor_id (not org_id), which changes the relationship between tables. Additionally, the generated query calculates avg_donation per organization without proper context of the original join conditions, and the HAVING clause in the reference is replaced by a WHERE subquery that may count volunteers differently. These differences in join logic and filtering lead to non-equivalent results."}
{"example_id": 1281, "sql_complexity": "subqueries", "prompt": "Find the top 3 contributors with the lowest recycling rate in the 'waste_contributors' table.", "context": "CREATE TABLE waste_contributors (contributor VARCHAR(20), recycling_rate FLOAT); INSERT INTO waste_contributors (contributor, recycling_rate) VALUES ('Manufacturing', 0.4), ('Commercial', 0.38), ('Residential', 0.35), ('Institutional', 0.32), ('Agricultural', 0.2), ('Industrial', 0.15);", "reference_sql": "SELECT contributor FROM waste_contributors WHERE recycling_rate IN (SELECT MIN(recycling_rate) FROM waste_contributors) LIMIT 3;", "generated_sql": "SELECT contributor, recycling_rate\nFROM waste_contributors\nORDER BY recycling_rate ASC\nFETCH FIRST 3 ROWS ONLY;", "raw_model_output": "SELECT contributor, recycling_rate\nFROM waste_contributors\nORDER BY recycling_rate ASC\nFETCH FIRST 3 ROWS ONLY;", "latency_sec": 3.018568992614746, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 167, "prompt_eval_sec": null, "tokens_completion": 300, "completion_eval_sec": null, "tokens_total": 467, "tokens_per_sec": 154.7090694771482, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL selects contributors with the minimum recycling rate (0.15, only 'Industrial') and limits to 3 rows. The Generated SQL orders all contributors by ascending recycling rate and returns the first 3 rows (Industrial, Agricultural, Institutional). The first query focuses on the absolute minimum value, while the second retrieves the top 3 lowest values, resulting in different outputs."}
{"example_id": 5669, "sql_complexity": "window functions", "prompt": "What is the total number of new and returning volunteers in each program in each month?", "context": "CREATE TABLE Volunteers (VolunteerID INT, VolunteerName TEXT, ProgramID INT, VolunteerDate DATE, IsReturning BOOLEAN); INSERT INTO Volunteers (VolunteerID, VolunteerName, ProgramID, VolunteerDate, IsReturning) VALUES (6, 'David Kim', 1, '2022-03-01', FALSE), (7, 'Emily Chen', 2, '2022-03-15', TRUE), (8, 'James Lee', 2, '2022-04-01', FALSE), (9, 'Grace Park', 3, '2022-04-15', TRUE), (10, 'Daniel Kim', 1, '2022-04-01', FALSE);", "reference_sql": "SELECT ProgramID, EXTRACT(MONTH FROM VolunteerDate) AS Month, SUM(CASE WHEN IsReturning THEN 1 ELSE 0 END) OVER (PARTITION BY ProgramID, EXTRACT(MONTH FROM VolunteerDate) ORDER BY ProgramID, EXTRACT(MONTH FROM VolunteerDate)) + COUNT(DISTINCT VolunteerID) OVER (PARTITION BY ProgramID, EXTRACT(MONTH FROM VolunteerDate) ORDER BY ProgramID, EXTRACT(MONTH FROM VolunteerDate)) AS TotalVolunteers FROM Volunteers;", "generated_sql": "SELECT\n  ProgramID,\n  EXTRACT(YEAR FROM VolunteerDate) AS Year,\n  EXTRACT(MONTH FROM VolunteerDate) AS Month,\n  SUM(CASE WHEN IsReturning = TRUE THEN 1 ELSE 0 END) AS ReturningVolunteers,\n  SUM(CASE WHEN IsReturning = FALSE THEN 1 ELSE 0 END) AS NewVolunteers\nFROM Volunteers\nGROUP BY\n  ProgramID,\n  EXTRACT(YEAR FROM VolunteerDate),\n  EXTRACT(MONTH FROM VolunteerDate)\nORDER BY\n  ProgramID,\n  Year,\n  Month;", "raw_model_output": "SELECT\n  ProgramID,\n  EXTRACT(YEAR FROM VolunteerDate) AS Year,\n  EXTRACT(MONTH FROM VolunteerDate) AS Month,\n  SUM(CASE WHEN IsReturning = TRUE THEN 1 ELSE 0 END) AS ReturningVolunteers,\n  SUM(CASE WHEN IsReturning = FALSE THEN 1 ELSE 0 END) AS NewVolunteers\nFROM Volunteers\nGROUP BY\n  ProgramID,\n  EXTRACT(YEAR FROM VolunteerDate),\n  EXTRACT(MONTH FROM VolunteerDate)\nORDER BY\n  ProgramID,\n  Year,\n  Month;", "latency_sec": 3.7214999198913574, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 227, "prompt_eval_sec": null, "tokens_completion": 456, "completion_eval_sec": null, "tokens_total": 683, "tokens_per_sec": 183.52815120306087, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL uses window functions to calculate a cumulative total per ProgramID and month, returning one row per volunteer with aggregated values. The Generated SQL groups data by ProgramID, year, and month, returning distinct counts of returning and new volunteers per group. Differences include column structure (month vs. year, total vs. separate counts), aggregation approach, and output row structure."}
{"example_id": 3576, "sql_complexity": "window functions", "prompt": "What is the difference in the number of eco-friendly hotels between the top 2 countries?", "context": "CREATE TABLE eco_hotel_count (country TEXT, num_hotels INT); INSERT INTO eco_hotel_count (country, num_hotels) VALUES ('France', 100), ('Italy', 120), ('Germany', 150), ('Spain', 110), ('UK', 160);", "reference_sql": "SELECT (MAX(num_hotels) OVER (PARTITION BY num_hotels <= 2) - MIN(num_hotels) OVER (PARTITION BY num_hotels <= 2)) AS hotel_difference FROM eco_hotel_count WHERE country IN ('France', 'Italy');", "generated_sql": "SELECT\n    num_hotels,\n    ROW_NUMBER() OVER (ORDER BY num_hotels DESC) AS rn\n  FROM eco_hotel_count\n)\nSELECT\n  (SELECT num_hotels FROM ranked_hotels WHERE rn = 1)\n  - \n  (SELECT num_hotels FROM ranked_hotels WHERE rn = 2)\n  AS difference;", "raw_model_output": "WITH ranked_hotels AS (\n  SELECT\n    num_hotels,\n    ROW_NUMBER() OVER (ORDER BY num_hotels DESC) AS rn\n  FROM eco_hotel_count\n)\nSELECT\n  (SELECT num_hotels FROM ranked_hotels WHERE rn = 1)\n  - \n  (SELECT num_hotels FROM ranked_hotels WHERE rn = 2)\n  AS difference;", "latency_sec": 5.488378047943115, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 143, "prompt_eval_sec": null, "tokens_completion": 802, "completion_eval_sec": null, "tokens_total": 945, "tokens_per_sec": 172.18201657120878, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL contains invalid syntax. The PARTITION BY clause uses a boolean expression (num_hotels <= 2), which is not valid SQL. The Generated SQL is syntactically correct and calculates the difference between the top two num_hotels values for France and Italy (120 - 100 = 20). The Reference SQL would fail to execute due to the invalid partitioning, making them non-equivalent."}
{"example_id": 1970, "sql_complexity": "multiple_joins", "prompt": "List all players who have played a specific VR game, 'CyberSphere', and their ages.", "context": "CREATE TABLE Players (PlayerID INT, Age INT, Gender VARCHAR(10), Country VARCHAR(50)); CREATE TABLE VRPlayers (PlayerID INT, VRGameID INT); CREATE TABLE VRGames (VRGameID INT, Title VARCHAR(50)); INSERT INTO Players (PlayerID, Age, Gender, Country) VALUES (1, 25, 'Male', 'USA'); INSERT INTO Players (PlayerID, Age, Gender, Country) VALUES (2, 28, 'Female', 'Canada'); INSERT INTO VRPlayers (PlayerID, VRGameID) VALUES (1, 1); INSERT INTO VRPlayers (PlayerID, VRGameID) VALUES (2, 1); INSERT INTO VRGames (VRGameID, Title) VALUES (1, 'CyberSphere');", "reference_sql": "SELECT Players.Age, Players.PlayerID FROM Players INNER JOIN VRPlayers ON Players.PlayerID = VRPlayers.PlayerID INNER JOIN VRGames ON VRPlayers.VRGameID = VRGames.VRGameID WHERE VRGames.Title = 'CyberSphere';", "generated_sql": "SELECT p.PlayerID,\n       p.Age\nFROM Players AS p\nJOIN VRPlayers AS rp\n  ON p.PlayerID = rp.PlayerID\nJOIN VRGames AS vg\n  ON rp.VRGameID = vg.VRGameID\nWHERE vg.Title = 'CyberSphere';", "raw_model_output": "SELECT p.PlayerID,\n       p.Age\nFROM Players AS p\nJOIN VRPlayers AS rp\n  ON p.PlayerID = rp.PlayerID\nJOIN VRGames AS vg\n  ON rp.VRGameID = vg.VRGameID\nWHERE vg.Title = 'CyberSphere';", "latency_sec": 2.638174057006836, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 244, "prompt_eval_sec": null, "tokens_completion": 334, "completion_eval_sec": null, "tokens_total": 578, "tokens_per_sec": 219.0909270996983, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same data by joining the same tables (Players, VRPlayers, VRGames) on identical conditions. The generated query uses table aliases (p, rp, vg) but maintains the same logical structure, column selections, and WHERE clause. The order of columns in the SELECT list does not affect semantic equivalence."}
{"example_id": 2414, "sql_complexity": "window functions", "prompt": "List the policy areas with the lowest citizen satisfaction scores.", "context": "CREATE TABLE Policy (Area VARCHAR(20), Score INT); INSERT INTO Policy (Area, Score) VALUES ('Transportation', 70), ('Education', 85), ('Healthcare', 75), ('PublicSafety', 80);", "reference_sql": "SELECT Area, Score FROM (SELECT Area, Score, ROW_NUMBER() OVER (ORDER BY Score) AS RN FROM Policy) X WHERE RN IN (1, 2);", "generated_sql": "SELECT Area\nFROM Policy\nWHERE Score = (\n  SELECT MIN(Score)\n  FROM Policy\n);", "raw_model_output": "SELECT Area\nFROM Policy\nWHERE Score = (\n  SELECT MIN(Score)\n  FROM Policy\n);", "latency_sec": 2.2406411170959473, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 123, "prompt_eval_sec": null, "tokens_completion": 296, "completion_eval_sec": null, "tokens_total": 419, "tokens_per_sec": 187.00004958538742, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query selects the top 2 rows ordered by Score (Transportation and Healthcare), while the generated query only selects the row with the minimum Score (Transportation). The generated query returns a single row, whereas the reference query returns two rows. They are not semantically equivalent."}
{"example_id": 1898, "sql_complexity": "single join", "prompt": "What are the total sales for each drug in Q2 2020?", "context": "CREATE TABLE drugs (drug_id INT, drug_name TEXT); INSERT INTO drugs (drug_id, drug_name) VALUES (1001, 'Ibuprofen'), (1002, 'Paracetamol'), (1003, 'Aspirin'); CREATE TABLE sales (sale_id INT, drug_id INT, sale_date DATE, revenue FLOAT); INSERT INTO sales (sale_id, drug_id, sale_date, revenue) VALUES (1, 1001, '2020-04-05', 1800.0), (2, 1002, '2020-04-10', 2300.0), (3, 1003, '2020-04-15', 1400.0), (4, 1001, '2020-05-20', 1900.0), (5, 1002, '2020-06-25', 2400.0);", "reference_sql": "SELECT drug_name, SUM(revenue) as total_sales FROM sales JOIN drugs ON sales.drug_id = drugs.drug_id WHERE sale_date BETWEEN '2020-04-01' AND '2020-06-30' GROUP BY drug_name;", "generated_sql": "SELECT d.drug_name,\n       SUM(s.revenue) AS total_sales\nFROM drugs AS d\nJOIN sales AS s\n  ON d.drug_id = s.drug_id\nWHERE s.sale_date BETWEEN '2020-04-01' AND '2020-06-30'\nGROUP BY d.drug_name;", "raw_model_output": "SELECT d.drug_name,\n       SUM(s.revenue) AS total_sales\nFROM drugs AS d\nJOIN sales AS s\n  ON d.drug_id = s.drug_id\nWHERE s.sale_date BETWEEN '2020-04-01' AND '2020-06-30'\nGROUP BY d.drug_name;", "latency_sec": 3.0981807708740234, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 270, "prompt_eval_sec": null, "tokens_completion": 342, "completion_eval_sec": null, "tokens_total": 612, "tokens_per_sec": 197.53527804232982, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between 'drugs' and 'sales' on drug_id, filter sales within the date range '2020-04-01' to '2020-06-30', and group by drug_name to calculate total sales. The generated query uses table aliases (d/drugs, s/sales) but maintains identical logical structure, column references, and aggregation logic. The GROUP BY clause references the same drug_name column via alias in both cases."}
{"example_id": 2403, "sql_complexity": "multiple_joins", "prompt": "Who is the most frequent customer ordering vegetarian items?", "context": "CREATE TABLE customers (customer_id INT, customer_name VARCHAR(50)); INSERT INTO customers VALUES (1, 'John Doe'), (2, 'Jane Smith'), (3, 'Alice Johnson'); CREATE TABLE orders (order_id INT, customer_id INT, menu_id INT, order_date DATE); INSERT INTO orders VALUES (1, 1, 1, '2022-01-01'), (2, 2, 3, '2022-01-02'), (3, 3, 2, '2022-01-03'); CREATE TABLE menu (menu_id INT, item_name VARCHAR(50), is_vegetarian BOOLEAN, price DECIMAL(5,2)); INSERT INTO menu VALUES (1, 'Veggie Burger', true, 8.99), (2, 'Cheeseburger', false, 7.99), (3, 'Tofu Stir Fry', true, 11.99);", "reference_sql": "SELECT customers.customer_name, COUNT(orders.order_id) as order_count FROM customers INNER JOIN orders ON customers.customer_id = orders.customer_id INNER JOIN menu ON orders.menu_id = menu.menu_id WHERE menu.is_vegetarian = true GROUP BY customers.customer_name ORDER BY order_count DESC LIMIT 1;", "generated_sql": "SELECT\n  c.customer_name\nFROM\n  customers c\n  JOIN orders o ON c.customer_id = o.customer_id\n  JOIN menu m ON o.menu_id = m.menu_id\nWHERE\n  m.is_vegetarian = TRUE\nGROUP BY\n  c.customer_name\nORDER BY\n  COUNT(*) DESC\nFETCH FIRST 1 ROW ONLY;", "raw_model_output": "SELECT\n  c.customer_name\nFROM\n  customers c\n  JOIN orders o ON c.customer_id = o.customer_id\n  JOIN menu m ON o.menu_id = m.menu_id\nWHERE\n  m.is_vegetarian = TRUE\nGROUP BY\n  c.customer_name\nORDER BY\n  COUNT(*) DESC\nFETCH FIRST 1 ROW ONLY;", "latency_sec": 3.8596839904785156, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 269, "prompt_eval_sec": null, "tokens_completion": 412, "completion_eval_sec": null, "tokens_total": 681, "tokens_per_sec": 176.43931515636103, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the customer with the highest count of vegetarian orders. They join the same tables with identical conditions, filter on vegetarian items, group by customer name, and order by count descending. The difference in COUNT syntax (COUNT(*) vs COUNT(orders.order_id)) is irrelevant here since each order record is unique. The LIMIT 1 and FETCH FIRST 1 ROW ONLY clauses are functionally equivalent in this context."}
{"example_id": 124, "sql_complexity": "set operations", "prompt": "Find the intersection of AI and accessibility research projects in the EU and those in Africa.", "context": "CREATE SCHEMA if not exists accessibility; CREATE TABLE if not exists accessibility.research (id INT PRIMARY KEY, project_name VARCHAR(255), region VARCHAR(255)); INSERT INTO accessibility.research (id, project_name, region) VALUES (1, 'AI for Accessibility EU', 'EU'), (2, 'Accessibility Africa', 'Africa'), (3, 'AI for Accessibility Africa', 'Africa'), (4, 'Accessibility EU', 'EU');", "reference_sql": "SELECT project_name FROM accessibility.research WHERE region = 'EU' INTERSECT SELECT project_name FROM accessibility.research WHERE region = 'Africa';", "generated_sql": "SELECT project_name\nFROM accessibility.research\nWHERE region = 'EU'\n  AND project_name LIKE '%AI%'\n  AND project_name LIKE '%Accessibility%'\nINTERSECT\nSELECT project_name\nFROM accessibility.research\nWHERE region = 'Africa'\n  AND project_name LIKE '%AI%'\n  AND project_name LIKE '%Accessibility%';", "raw_model_output": "SELECT project_name\nFROM accessibility.research\nWHERE region = 'EU'\n  AND project_name LIKE '%AI%'\n  AND project_name LIKE '%Accessibility%'\nINTERSECT\nSELECT project_name\nFROM accessibility.research\nWHERE region = 'Africa'\n  AND project_name LIKE '%AI%'\n  AND project_name LIKE '%Accessibility%';", "latency_sec": 9.142786979675293, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 174, "prompt_eval_sec": null, "tokens_completion": 1430, "completion_eval_sec": null, "tokens_total": 1604, "tokens_per_sec": 175.4388463349024, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Generated SQL adds additional LIKE conditions ('%AI%' and '%Accessibility%') in both SELECT clauses, which restrict the results. The Reference SQL performs an INTERSECT on all project_names from EU and Africa regions without these filters. While both queries return empty results for the given data, the Generated SQL is more restrictive and would produce different results for other datasets."}
{"example_id": 1231, "sql_complexity": "basic SQL", "prompt": "What is the average ticket price for performances at the 'Downtown Theater'?", "context": "CREATE TABLE DowntownTheater (show_name TEXT, date DATE, ticket_price FLOAT); INSERT INTO DowntownTheater (show_name, date, ticket_price) VALUES ('Play 1', '2022-01-01', 30.0), ('Play 2', '2022-01-02', 40.0), ('Concert 1', '2022-01-03', 50.0);", "reference_sql": "SELECT AVG(ticket_price) FROM DowntownTheater WHERE show_name = 'Downtown Theater'", "generated_sql": "SELECT AVG(ticket_price) AS average_ticket_price\nFROM DowntownTheater;", "raw_model_output": "SELECT AVG(ticket_price) AS average_ticket_price\nFROM DowntownTheater;", "latency_sec": 2.032947063446045, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 168, "prompt_eval_sec": null, "tokens_completion": 98, "completion_eval_sec": null, "tokens_total": 266, "tokens_per_sec": 130.84452850882593, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters for show_name = 'Downtown Theater' which doesn't exist in the data, returning no rows. The Generated SQL calculates the average of all ticket prices. The first query would return NULL or no results, while the second returns 40.0. They have different WHERE conditions and thus different results."}
{"example_id": 1485, "sql_complexity": "set operations", "prompt": "How many public schools and public libraries exist in total, in the 'CityData' schema's 'CityEducation' and 'CityLibrary' tables?", "context": "CREATE SCHEMA CityData; CREATE TABLE CityEducation (Name varchar(255), Type varchar(255)); INSERT INTO CityEducation (Name, Type) VALUES ('SchoolA', 'Public'), ('SchoolB', 'Public'), ('SchoolC', 'Private'); CREATE TABLE CityLibrary (Name varchar(255), Type varchar(255)); INSERT INTO CityLibrary (Name, Type) VALUES ('LibraryA', 'Public'), ('LibraryB', 'Public'), ('LibraryC', 'Private');", "reference_sql": "SELECT COUNT(*) FROM CityData.CityEducation WHERE Type = 'Public' UNION ALL SELECT COUNT(*) FROM CityData.CityLibrary WHERE Type = 'Public';", "generated_sql": "SELECT COUNT(*) AS total_public\nFROM (\n  SELECT Name\n  FROM CityData.CityEducation\n  WHERE Type = 'Public'\n  UNION ALL\n  SELECT Name\n  FROM CityData.CityLibrary\n  WHERE Type = 'Public'\n) AS combined;", "raw_model_output": "```sql\nSELECT COUNT(*) AS total_public\nFROM (\n  SELECT Name\n  FROM CityData.CityEducation\n  WHERE Type = 'Public'\n  UNION ALL\n  SELECT Name\n  FROM CityData.CityLibrary\n  WHERE Type = 'Public'\n) AS combined;\n```", "latency_sec": 3.072908878326416, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 194, "prompt_eval_sec": null, "tokens_completion": 396, "completion_eval_sec": null, "tokens_total": 590, "tokens_per_sec": 192.00048662729267, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate counts (one for CityEducation and one for CityLibrary) as two rows, while the Generated SQL combines all matching rows from both tables into a single count of total public institutions. The structure and result format differ: the first produces two rows, the second produces one row with a summed count."}
{"example_id": 5806, "sql_complexity": "single join", "prompt": "List the top 3 countries with the most veteran employment in the IT industry", "context": "CREATE TABLE veteran_employment (employee_id INT, industry VARCHAR(255), salary DECIMAL(10,2), state VARCHAR(2), country VARCHAR(255)); CREATE TABLE countries (country_id INT, country VARCHAR(255));", "reference_sql": "SELECT country, COUNT(*) as num_veterans FROM veteran_employment JOIN countries ON veteran_employment.country = countries.country WHERE industry = 'IT' GROUP BY country ORDER BY num_veterans DESC LIMIT 3;", "generated_sql": "SELECT c.country,\n       COUNT(*) AS num_employees\nFROM veteran_employment ve\nJOIN countries c\n  ON ve.country = c.country\nWHERE ve.industry = 'IT'\nGROUP BY c.country\nORDER BY num_employees DESC\nFETCH FIRST 3 ROWS ONLY;", "raw_model_output": "SELECT c.country,\n       COUNT(*) AS num_employees\nFROM veteran_employment ve\nJOIN countries c\n  ON ve.country = c.country\nWHERE ve.industry = 'IT'\nGROUP BY c.country\nORDER BY num_employees DESC\nFETCH FIRST 3 ROWS ONLY;", "latency_sec": 3.901888847351074, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 128, "prompt_eval_sec": null, "tokens_completion": 525, "completion_eval_sec": null, "tokens_total": 653, "tokens_per_sec": 167.35484416561752, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the top 3 countries with the highest number of IT industry veterans. They use equivalent JOIN conditions, filtering on 'IT' industry, grouping by country, and ordering by count descending. The only differences are alias names (num_veterans vs num_employees) and the row-limiting syntax (LIMIT 3 vs FETCH FIRST 3 ROWS ONLY), which are functionally equivalent in modern SQL dialects."}
{"example_id": 4126, "sql_complexity": "window functions", "prompt": "What is the average crime rate per capita in each neighborhood?", "context": "CREATE TABLE neighborhoods (name VARCHAR(255), population INT, crime_count INT); INSERT INTO neighborhoods (name, population, crime_count) VALUES ('Central Park', 1000, 25), ('Harlem', 2500, 75), ('Brooklyn', 5000, 120);", "reference_sql": "SELECT name, AVG(crime_count/population) OVER (PARTITION BY name) FROM neighborhoods;", "generated_sql": "SELECT\n  name,\n  CAST(crime_count AS DECIMAL) / NULLIF(population, 0) AS crime_rate_per_capita\nFROM\n  neighborhoods;", "raw_model_output": "SELECT\n  name,\n  CAST(crime_count AS DECIMAL) / NULLIF(population, 0) AS crime_rate_per_capita\nFROM\n  neighborhoods;", "latency_sec": 2.5037522315979004, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 139, "prompt_eval_sec": null, "tokens_completion": 246, "completion_eval_sec": null, "tokens_total": 385, "tokens_per_sec": 153.7692089261932, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates AVG(crime_count/population) over a window partitioned by name, which for unique names would return the same value as crime_count/population. However, this uses integer division (if the database enforces it) and lacks NULLIF handling. The Generated SQL explicitly casts to DECIMAL for floating-point division and uses NULLIF to avoid division by zero. Differences in data types and error handling make them non-equivalent."}
{"example_id": 4559, "sql_complexity": "basic SQL", "prompt": "List the top 3 energy efficient appliances in the US by energy star rating?", "context": "CREATE TABLE appliances (id INT, name VARCHAR(255), country VARCHAR(255), energy_star_rating INT); INSERT INTO appliances (id, name, country, energy_star_rating) VALUES (1, 'Fridge A', 'USA', 5), (2, 'TV B', 'USA', 4), (3, 'Laptop C', 'USA', 5), (4, 'Microwave D', 'USA', 3);", "reference_sql": "SELECT name, energy_star_rating FROM appliances WHERE country = 'USA' ORDER BY energy_star_rating DESC LIMIT 3;", "generated_sql": "SELECT name, energy_star_rating\nFROM appliances\nWHERE country = 'USA'\nORDER BY energy_star_rating DESC\nFETCH FIRST 3 ROWS ONLY;", "raw_model_output": "SELECT name, energy_star_rating\nFROM appliances\nWHERE country = 'USA'\nORDER BY energy_star_rating DESC\nFETCH FIRST 3 ROWS ONLY;", "latency_sec": 2.873465061187744, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 173, "prompt_eval_sec": null, "tokens_completion": 242, "completion_eval_sec": null, "tokens_total": 415, "tokens_per_sec": 144.42493336893406, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (name, energy_star_rating) from the appliances table where country is 'USA', order the results by energy_star_rating in descending order, and limit the output to 3 rows. The difference between LIMIT 3 and FETCH FIRST 3 ROWS ONLY is syntactic and does not affect the result set in this context."}
{"example_id": 456, "sql_complexity": "window functions", "prompt": "List the intelligence operations and their corresponding threat levels, and rank them based on their threat level and budget.", "context": "CREATE TABLE intel_ops_threat (id INT, operation VARCHAR, threat VARCHAR, budget INT); INSERT INTO intel_ops_threat (id, operation, threat, budget) VALUES (1, 'Operation Red Folder', 'High', 5000000), (2, 'Operation Black Vault', 'Medium', 7000000), (3, 'Operation Blue Sail', 'Low', 6000000);", "reference_sql": "SELECT operation, threat, budget, ROW_NUMBER() OVER (PARTITION BY threat ORDER BY budget DESC) as rank FROM intel_ops_threat;", "generated_sql": "SELECT\n  operation,\n  threat,\n  RANK() OVER (\n    ORDER BY\n      CASE threat\n        WHEN 'High'   THEN 1\n        WHEN 'Medium' THEN 2\n        WHEN 'Low'    THEN 3\n      END,\n      budget DESC\n  ) AS rank\nFROM intel_ops_threat\nORDER BY rank;", "raw_model_output": "SELECT\n  operation,\n  threat,\n  RANK() OVER (\n    ORDER BY\n      CASE threat\n        WHEN 'High'   THEN 1\n        WHEN 'Medium' THEN 2\n        WHEN 'Low'    THEN 3\n      END,\n      budget DESC\n  ) AS rank\nFROM intel_ops_threat\nORDER BY rank;", "latency_sec": 6.729895830154419, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 170, "prompt_eval_sec": null, "tokens_completion": 1052, "completion_eval_sec": null, "tokens_total": 1222, "tokens_per_sec": 181.57784768742266, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses ROW_NUMBER() with PARTITION BY threat, ranking within each threat category. The Generated SQL uses RANK() without partitioning, ordering first by threat priority (High/Medium/Low) and then by budget. This results in different ranking logic: the Reference ranks within threat groups, while the Generated ranks all rows globally based on the custom threat order and budget. The output ranks and ordering will differ."}
{"example_id": 459, "sql_complexity": "set operations", "prompt": "What is the total installed capacity of hydroelectric power plants in Brazil and Canada?", "context": "CREATE TABLE hydroelectric_power (country TEXT, capacity INTEGER); INSERT INTO hydroelectric_power (country, capacity) VALUES ('Brazil', 104000), ('Canada', 78000), ('China', 350000), ('United States', 100000), ('Russia', 45000);", "reference_sql": "(SELECT capacity FROM hydroelectric_power WHERE country = 'Brazil') UNION (SELECT capacity FROM hydroelectric_power WHERE country = 'Canada');", "generated_sql": "SELECT SUM(capacity) AS total_capacity\nFROM hydroelectric_power\nWHERE country IN ('Brazil', 'Canada');", "raw_model_output": "SELECT SUM(capacity) AS total_capacity\nFROM hydroelectric_power\nWHERE country IN ('Brazil', 'Canada');", "latency_sec": 1.542626142501831, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 141, "prompt_eval_sec": null, "tokens_completion": 106, "completion_eval_sec": null, "tokens_total": 247, "tokens_per_sec": 160.11656563748843, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns individual capacity values as separate rows (Brazil and Canada's capacities), while the Generated SQL returns a single summed value of those capacities. The output structures differ (two rows vs. one row with a total), making them non-equivalent."}
{"example_id": 2356, "sql_complexity": "window functions", "prompt": "Find the total billing amount for attorneys in the 'Criminal Law' practice area, for the year 2020, partitioned by attorney's last name and ordered by the total billing amount in descending order.", "context": "CREATE TABLE Attorneys (AttorneyID INT, FirstName VARCHAR(50), LastName VARCHAR(50), PracticeArea VARCHAR(50), TotalBilling FLOAT, BillingYear INT); INSERT INTO Attorneys (AttorneyID, FirstName, LastName, PracticeArea, TotalBilling, BillingYear) VALUES (1, 'Clara', 'Rivera', 'Personal Injury', 8000.00, 2020), (2, 'Jamal', 'Lee', 'Personal Injury', 6000.00, 2019), (3, 'Sophia', 'Gomez', 'Criminal Law', 9000.00, 2020);", "reference_sql": "SELECT LastName, SUM(TotalBilling) OVER (PARTITION BY PracticeArea, LastName, BillingYear) AS TotalBilling FROM Attorneys WHERE PracticeArea = 'Criminal Law' AND BillingYear = 2020 ORDER BY TotalBilling DESC;", "generated_sql": "SELECT\n  LastName,\n  SUM(TotalBilling) AS TotalBilling\nFROM Attorneys\nWHERE PracticeArea = 'Criminal Law'\n  AND BillingYear = 2020\nGROUP BY LastName\nORDER BY TotalBilling DESC;", "raw_model_output": "SELECT\n  LastName,\n  SUM(TotalBilling) AS TotalBilling\nFROM Attorneys\nWHERE PracticeArea = 'Criminal Law'\n  AND BillingYear = 2020\nGROUP BY LastName\nORDER BY TotalBilling DESC;", "latency_sec": 5.062536954879761, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 240, "prompt_eval_sec": null, "tokens_completion": 579, "completion_eval_sec": null, "tokens_total": 819, "tokens_per_sec": 161.77659685240795, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same data for 'Criminal Law' in 2020. The Reference SQL uses a window function that sums TotalBilling within the same PracticeArea, LastName, and BillingYear, but since there's only one matching row (Sophia Gomez), the result is identical to the Generated SQL's grouped aggregation. The final output (LastName and TotalBilling) and ordering are the same."}
