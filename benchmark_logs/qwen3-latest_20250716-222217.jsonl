{"example_id": 2656, "sql_complexity": "multiple_joins", "prompt": "Find the drugs and their respective total sales for rare diseases indication with sales greater than the average sales for infectious diseases.", "context": "CREATE TABLE sales (id INT, drug_id INT, quarter INT, year INT, revenue FLOAT); INSERT INTO sales (id, drug_id, quarter, year, revenue) VALUES (1, 1, 1, 2022, 1500000); CREATE TABLE drugs (id INT, name VARCHAR(50), company VARCHAR(50), indication VARCHAR(50)); INSERT INTO drugs (id, name, company, indication) VALUES (1, 'DrugA', 'ABC Corp', 'Rare_Diseases');", "reference_sql": "SELECT s.drug_id, d.name, SUM(s.revenue) as total_sales FROM sales s JOIN drugs d ON s.drug_id = d.id WHERE d.indication = 'Rare_Diseases' GROUP BY s.drug_id HAVING total_sales > (SELECT AVG(s2.revenue) FROM sales s2 JOIN drugs d2 ON s2.drug_id = d2.id WHERE d2.indication = 'Infectious_Diseases')", "generated_sql": "SELECT d.name, SUM(s.revenue) AS total_sales\nFROM drugs d\nJOIN sales s ON d.id = s.drug_id\nWHERE d.indication = 'Rare_Diseases'\nGROUP BY d.name\nHAVING SUM(s.revenue) > (\n    SELECT AVG(s2.revenue)\n    FROM sales s2\n    JOIN drugs d2 ON s2.drug_id = d2.id\n    WHERE d2.indication = 'Infectious_Diseases'\n);", "raw_model_output": "<think>\n\n</think>\n\nSELECT d.name, SUM(s.revenue) AS total_sales\nFROM drugs d\nJOIN sales s ON d.id = s.drug_id\nWHERE d.indication = 'Rare_Diseases'\nGROUP BY d.name\nHAVING SUM(s.revenue) > (\n    SELECT AVG(s2.revenue)\n    FROM sales s2\n    JOIN drugs d2 ON s2.drug_id = d2.id\n    WHERE d2.indication = 'Infectious_Diseases'\n);", "latency_sec": 5.664631128311157, "total_duration_sec": 5.562466546, "load_duration_sec": 3.96205309, "tokens_prompt": 210, "prompt_eval_sec": 0.136167381, "tokens_completion": 105, "completion_eval_sec": 1.454979357, "tokens_total": 315, "tokens_per_sec": 55.60821046681526, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their GROUP BY clauses (drug_id vs. name) and selected columns. If multiple drugs share the same name, grouping by name would aggregate their sales, while grouping by drug_id would not. Additionally, the Reference SQL includes drug_id in the output, whereas the Generated SQL does not. These differences in grouping and projection make them non-equivalent."}
{"example_id": 3008, "sql_complexity": "multiple_joins", "prompt": "Who are the users who used electric vehicles and their trip details?", "context": "CREATE TABLE users (id INT, name VARCHAR(50), age INT, gender VARCHAR(10), city VARCHAR(50));CREATE TABLE vehicles (id INT, vehicle_type VARCHAR(20), is_electric BOOLEAN);CREATE TABLE trips (id INT, user_id INT, vehicle_id INT, trip_distance FLOAT, trip_duration INT, departure_time TIMESTAMP, arrival_time TIMESTAMP);INSERT INTO users (id, name, age, gender, city) VALUES (3, 'Alex', 30, 'Female', 'New York');INSERT INTO vehicles (id, vehicle_type, is_electric) VALUES (1, 'Tesla', true), (2, 'Bike', false);INSERT INTO trips (id, user_id, vehicle_id, trip_distance, trip_duration, departure_time, arrival_time) VALUES (3, 3, 1, 15.3, 25, '2022-01-03 12:00:00', '2022-01-03 12:25:00');", "reference_sql": "SELECT u.name, v.vehicle_type, t.trip_distance, t.trip_duration FROM users u JOIN trips t ON u.id = t.user_id JOIN vehicles v ON t.vehicle_id = v.id WHERE v.is_electric = true;", "generated_sql": "SELECT u.id AS user_id, u.name, u.age, u.gender, u.city, \n       v.id AS vehicle_id, v.vehicle_type, v.is_electric,\n       t.trip_distance, t.trip_duration, t.departure_time, t.arrival_time\nFROM users u\nJOIN trips t ON u.id = t.user_id\nJOIN vehicles v ON t.vehicle_id = v.id\nWHERE v.is_electric = TRUE;", "raw_model_output": "<think>\n\n</think>\n\nSELECT u.id AS user_id, u.name, u.age, u.gender, u.city, \n       v.id AS vehicle_id, v.vehicle_type, v.is_electric,\n       t.trip_distance, t.trip_duration, t.departure_time, t.arrival_time\nFROM users u\nJOIN trips t ON u.id = t.user_id\nJOIN vehicles v ON t.vehicle_id = v.id\nWHERE v.is_electric = TRUE;", "latency_sec": 1.8722829818725586, "total_duration_sec": 1.41026717, "load_duration_sec": 0.014201181, "tokens_prompt": 312, "prompt_eval_sec": 0.032955426, "tokens_completion": 94, "completion_eval_sec": 1.360909402, "tokens_total": 406, "tokens_per_sec": 216.8475620036562, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects only 4 columns (name, vehicle_type, trip_distance, trip_duration), while the Generated SQL selects 11 columns including additional user/vehicle/trip details not present in the Reference. The result sets have different structures and data content."}
{"example_id": 2531, "sql_complexity": "basic SQL", "prompt": "Who is the top customer by sales in 2022?", "context": "CREATE TABLE customers (customer_id INT, total_sales_2022 FLOAT); INSERT INTO customers (customer_id, total_sales_2022) VALUES (1, 25000.0), (2, 30000.0), (3, 22000.0), (4, 35000.0);", "reference_sql": "SELECT customer_id, total_sales_2022 FROM customers ORDER BY total_sales_2022 DESC LIMIT 1;", "generated_sql": "SELECT customer_id\nFROM customers\nORDER BY total_sales_2022 DESC\nLIMIT 1;", "raw_model_output": "<think>\n\n</think>\n\nSELECT customer_id\nFROM customers\nORDER BY total_sales_2022 DESC\nLIMIT 1;", "latency_sec": 0.48717403411865234, "total_duration_sec": 0.424659344, "load_duration_sec": 0.019084783, "tokens_prompt": 167, "prompt_eval_sec": 0.019003937, "tokens_completion": 27, "completion_eval_sec": 0.384545684, "tokens_total": 194, "tokens_per_sec": 398.2149835858265, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query returns both customer_id and total_sales_2022 columns, while the generated query only returns customer_id. The additional column in the reference query makes them semantically different."}
{"example_id": 3792, "sql_complexity": "single join", "prompt": "What is the maximum distance traveled by an electric vehicle in a single trip, grouped by vehicle model?", "context": "CREATE TABLE Trips (trip_id INT, vehicle_id INT, distance FLOAT); CREATE TABLE ElectricVehicleModels (vehicle_id INT, vehicle_model TEXT);", "reference_sql": "SELECT evm.vehicle_model, MAX(trips.distance) AS max_distance_traveled FROM Trips trips INNER JOIN ElectricVehicleModels evm ON trips.vehicle_id = evm.vehicle_id GROUP BY 1;", "generated_sql": "SELECT vehicle_model, MAX(distance) AS max_distance\nFROM Trips\nJOIN ElectricVehicleModels ON Trips.vehicle_id = ElectricVehicleModels.vehicle_id\nGROUP BY vehicle_model;", "raw_model_output": "<think>\n\n</think>\n\nSELECT vehicle_model, MAX(distance) AS max_distance\nFROM Trips\nJOIN ElectricVehicleModels ON Trips.vehicle_id = ElectricVehicleModels.vehicle_id\nGROUP BY vehicle_model;", "latency_sec": 0.6806678771972656, "total_duration_sec": 0.621824946, "load_duration_sec": 0.018580818, "tokens_prompt": 122, "prompt_eval_sec": 0.029243636, "tokens_completion": 41, "completion_eval_sec": 0.570975399, "tokens_total": 163, "tokens_per_sec": 239.47068087181182, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the maximum distance traveled per vehicle model by joining the Trips and ElectricVehicleModels tables on vehicle_id. The Reference SQL uses table aliases and groups by the first column (vehicle_model), while the Generated SQL references table names directly and groups by the column name. The semantic logic remains identical, as grouping by the column name or position (1) produces the same aggregation. Column aliases (max_distance_traveled vs. max_distance) do not affect the result's correctness or structure."}
{"example_id": 2311, "sql_complexity": "subqueries", "prompt": "Determine the percentage of sales from each ingredient category", "context": "CREATE TABLE Sales_Details (sale_id INT, ingredient_id INT, quantity INT); INSERT INTO Sales_Details (sale_id, ingredient_id, quantity) VALUES (1, 1, 2), (1, 2, 8), (2, 1, 3), (2, 2, 7); CREATE TABLE Ingredient_Categories (ingredient_id INT, ingredient_category VARCHAR(255)); INSERT INTO Ingredient_Categories (ingredient_id, ingredient_category) VALUES (1, 'Legumes'), (2, 'Poultry');", "reference_sql": "SELECT ingredient_category, SUM(quantity) AS total_quantity, SUM(quantity) * 100.0 / (SELECT SUM(quantity) FROM Sales_Details) AS percentage_of_sales FROM Sales_Details, Ingredient_Categories WHERE Sales_Details.ingredient_id = Ingredient_Categories.ingredient_id GROUP BY ingredient_category;", "generated_sql": "SELECT \n    ic.ingredient_category,\n    (SUM(sd.quantity) * 100.0 / SUM(TOTAL.quantity)) AS percentage_of_sales\nFROM \n    Sales_Details sd\nJOIN \n    Ingredient_Categories ic ON sd.ingredient_id = ic.ingredient_id\nCROSS JOIN (\n    SELECT SUM(quantity) AS quantity\n    FROM Sales_Details\n) AS TOTAL\nGROUP BY \n    ic.ingredient_category;", "raw_model_output": "<think>\n\n</think>\n\nSELECT \n    ic.ingredient_category,\n    (SUM(sd.quantity) * 100.0 / SUM(TOTAL.quantity)) AS percentage_of_sales\nFROM \n    Sales_Details sd\nJOIN \n    Ingredient_Categories ic ON sd.ingredient_id = ic.ingredient_id\nCROSS JOIN (\n    SELECT SUM(quantity) AS quantity\n    FROM Sales_Details\n) AS TOTAL\nGROUP BY \n    ic.ingredient_category;", "latency_sec": 1.5129661560058594, "total_duration_sec": 1.333370667, "load_duration_sec": 0.013740714, "tokens_prompt": 194, "prompt_eval_sec": 0.020463756, "tokens_completion": 92, "completion_eval_sec": 1.296959322, "tokens_total": 286, "tokens_per_sec": 189.03264879038866, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses a scalar subquery to calculate the total quantity, ensuring correct percentage computation. The Generated SQL uses a CROSS JOIN with a subquery, leading to SUM(TOTAL.quantity) aggregating the total multiple times (once per row in the group), which inflates the denominator and produces incorrect percentages."}
{"example_id": 3329, "sql_complexity": "set operations", "prompt": "Which causes received funding from donors in both the United States and Canada?", "context": "CREATE TABLE donor_location (donor_id INT, country VARCHAR(50), cause VARCHAR(50), donation DECIMAL(10,2)); INSERT INTO donor_location (donor_id, country, cause, donation) VALUES (1, 'United States', 'Global Health', 1000.00), (2, 'Canada', 'Education', 2000.00), (3, 'United States', 'Environment', 1500.00), (4, 'Canada', 'Animal Welfare', 2500.00);", "reference_sql": "SELECT cause FROM donor_location WHERE country = 'United States' INTERSECT SELECT cause FROM donor_location WHERE country = 'Canada';", "generated_sql": "SELECT DISTINCT cause\nFROM donor_location\nWHERE country IN ('United States', 'Canada')\nGROUP BY cause\nHAVING COUNT(DISTINCT country) = 2;", "raw_model_output": "<think>\n\n</think>\n\nSELECT DISTINCT cause\nFROM donor_location\nWHERE country IN ('United States', 'Canada')\nGROUP BY cause\nHAVING COUNT(DISTINCT country) = 2;", "latency_sec": 0.7997760772705078, "total_duration_sec": 0.608020541, "load_duration_sec": 0.019840806, "tokens_prompt": 209, "prompt_eval_sec": 0.024101091, "tokens_completion": 39, "completion_eval_sec": 0.56164969, "tokens_total": 248, "tokens_per_sec": 310.0867943517134, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve causes that appear in both 'United States' and 'Canada'. The reference uses INTERSECT to find common causes between the two countries, while the generated query uses GROUP BY and HAVING to ensure a cause exists in both countries. Both approaches yield the same result set."}
{"example_id": 2912, "sql_complexity": "single join", "prompt": "Which company has manufactured the most satellites?", "context": "CREATE TABLE manufacturers (id INT, name TEXT); CREATE TABLE satellites (id INT, manufacturer_id INT, name TEXT, launch_date DATE); INSERT INTO manufacturers (id, name) VALUES (1, 'SpaceX'), (2, 'Blue Origin'), (3, 'ISRO'), (4, 'CAST'); INSERT INTO satellites (id, manufacturer_id, name, launch_date) VALUES (1, 1, 'StarDragon', '2012-05-25'), (2, 1, 'Falcon', '2015-12-21'), (3, 2, 'New Glenn', '2022-01-11'), (4, 3, 'ChinaSat 1E', '2000-12-05'), (5, 3, 'ChinaSat 2A', '2003-08-13'), (6, 4, 'Shijian 9', '2017-11-19'), (7, 1, 'StarLink', '2020-05-24'), (8, 1, 'StarLink', '2020-06-13');", "reference_sql": "SELECT m.name, COUNT(s.id) FROM manufacturers m JOIN satellites s ON m.id = s.manufacturer_id GROUP BY m.name ORDER BY COUNT(s.id) DESC;", "generated_sql": "SELECT m.name, COUNT(*) AS satellite_count\nFROM manufacturers m\nJOIN satellites s ON m.id = s.manufacturer_id\nGROUP BY m.id\nORDER BY satellite_count DESC\nLIMIT 1;", "raw_model_output": "<think>\n\n</think>\n\nSELECT m.name, COUNT(*) AS satellite_count\nFROM manufacturers m\nJOIN satellites s ON m.id = s.manufacturer_id\nGROUP BY m.id\nORDER BY satellite_count DESC\nLIMIT 1;", "latency_sec": 0.9546220302581787, "total_duration_sec": 0.751769836, "load_duration_sec": 0.014394928, "tokens_prompt": 344, "prompt_eval_sec": 0.0372116, "tokens_completion": 46, "completion_eval_sec": 0.697933848, "tokens_total": 390, "tokens_per_sec": 408.53865471188004, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in grouping (by m.name vs m.id) and output (all rows vs top 1). While grouping by id/name may yield same results here, the Generated query adds LIMIT 1 which restricts output to a single row, making them non-equivalent."}
{"example_id": 3170, "sql_complexity": "aggregation", "prompt": "Determine the total production quantity of silver for mining sites in Mexico, between the dates '2017-05-01' and '2017-09-30', having less than 40 employees.", "context": "CREATE TABLE silver_mine_2 (site_id INT, country VARCHAR(50), num_employees INT, extraction_date DATE, quantity INT); INSERT INTO silver_mine_2 (site_id, country, num_employees, extraction_date, quantity) VALUES (1, 'Mexico', 35, '2017-05-02', 1200), (2, 'Mexico', 30, '2017-08-31', 1800), (3, 'Mexico', 37, '2017-07-04', 2200);", "reference_sql": "SELECT country, SUM(quantity) as total_silver_prod FROM silver_mine_2 WHERE num_employees < 40 AND country = 'Mexico' AND extraction_date >= '2017-05-01' AND extraction_date <= '2017-09-30' GROUP BY country;", "generated_sql": "SELECT SUM(quantity) AS total_production\nFROM silver_mine_2\nWHERE country = 'Mexico'\n  AND extraction_date BETWEEN '2017-05-01' AND '2017-09-30'\n  AND num_employees < 40;", "raw_model_output": "<think>\n\n</think>\n\nSELECT SUM(quantity) AS total_production\nFROM silver_mine_2\nWHERE country = 'Mexico'\n  AND extraction_date BETWEEN '2017-05-01' AND '2017-09-30'\n  AND num_employees < 40;", "latency_sec": 1.3229219913482666, "total_duration_sec": 0.996842743, "load_duration_sec": 0.020279805, "tokens_prompt": 259, "prompt_eval_sec": 0.027097373, "tokens_completion": 66, "completion_eval_sec": 0.94738263, "tokens_total": 325, "tokens_per_sec": 245.6683025344326, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a GROUP BY country, which returns two columns (country and total_silver_prod), while the Generated SQL returns only a single column (total_production). Although both queries sum the same subset of data, their result structures differ, making them semantically non-equivalent."}
{"example_id": 3518, "sql_complexity": "basic SQL", "prompt": "Insert new records of ticket sales for a new event, including event and salesperson information.", "context": "CREATE TABLE salesperson (salesperson_id INT, name VARCHAR(50), position VARCHAR(50)); CREATE TABLE tickets (ticket_id INT, salesperson_id INT, event_id INT, price DECIMAL(5,2), quantity INT); CREATE TABLE events (event_id INT, name VARCHAR(50), date DATE); INSERT INTO salesperson VALUES (1, 'John Doe', 'Senior Salesperson'); INSERT INTO events VALUES (2, 'New Event', '2023-04-15');", "reference_sql": "INSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity) VALUES (2, 1, 2, 75, 50), (3, 2, 2, 65, 75); INSERT INTO events (event_id, name, date) VALUES (2, 'New Event', '2023-04-15');", "generated_sql": "INSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity) \nVALUES (1, 1, 2, 99.99, 5);", "raw_model_output": "<think>\n\n</think>\n\nINSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity) \nVALUES (1, 1, 2, 99.99, 5);", "latency_sec": 0.7415280342102051, "total_duration_sec": 0.678792693, "load_duration_sec": 0.024838654, "tokens_prompt": 197, "prompt_eval_sec": 0.021539023, "tokens_completion": 44, "completion_eval_sec": 0.629255296, "tokens_total": 241, "tokens_per_sec": 325.0045701329242, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL inserts two rows into the tickets table and one row into the events table, while the Generated SQL only inserts a single row into the tickets table. The data values (e.g., ticket_id, price, quantity) also differ between the two queries. The Generated SQL lacks the second ticket row and the events table insertion entirely."}
{"example_id": 3925, "sql_complexity": "set operations", "prompt": "What is the total number of students and staff with accommodations in the \"disability_services\" schema, excluding the \"accessibility_parking\" type?", "context": "CREATE SCHEMA disability_services; CREATE TABLE staff (id INT, name VARCHAR(50), accommodation VARCHAR(50)); CREATE TABLE students (id INT, name VARCHAR(50), accommodation VARCHAR(50));", "reference_sql": "SELECT COUNT(*) FROM disability_services.staff WHERE accommodation != 'accessibility_parking' UNION SELECT COUNT(*) FROM disability_services.students WHERE accommodation != 'accessibility_parking';", "generated_sql": "SELECT COUNT(*) AS total_with_accommodations\nFROM (\n    SELECT id\n    FROM disability_services.staff\n    WHERE accommodation != 'accessibility_parking'\n    UNION ALL\n    SELECT id\n    FROM disability_services.students\n    WHERE accommodation != 'accessibility_parking'\n) AS combined;", "raw_model_output": "<think>\n\n</think>\n\nSELECT COUNT(*) AS total_with_accommodations\nFROM (\n    SELECT id\n    FROM disability_services.staff\n    WHERE accommodation != 'accessibility_parking'\n    UNION ALL\n    SELECT id\n    FROM disability_services.students\n    WHERE accommodation != 'accessibility_parking'\n) AS combined;", "latency_sec": 0.993549108505249, "total_duration_sec": 0.95169444, "load_duration_sec": 0.014455449, "tokens_prompt": 146, "prompt_eval_sec": 0.01360553, "tokens_completion": 66, "completion_eval_sec": 0.921008129, "tokens_total": 212, "tokens_per_sec": 213.37646844547493, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate counts (staff and students) as individual rows via UNION, while the Generated SQL combines both results into a single total count using UNION ALL and then counts the combined rows. The Reference SQL produces two rows of output, whereas the Generated SQL produces one row with the sum of both counts."}
{"example_id": 3340, "sql_complexity": "subqueries", "prompt": "Calculate the total revenue for garments manufactured in the US and sold in California.", "context": "CREATE TABLE garment_manufacturing(id INT PRIMARY KEY, garment_id INT, country VARCHAR(50), material VARCHAR(50), manufacturing_date DATE, quantity INT); CREATE TABLE garment_sales(id INT PRIMARY KEY, garment_id INT, store_id INT, sale_date DATE, units INT, revenue DECIMAL(10,2));", "reference_sql": "SELECT SUM(gs.revenue) FROM garment_manufacturing gm JOIN garment_sales gs ON gm.garment_id = gs.garment_id WHERE gm.country = 'United States' AND gs.store_id IN (SELECT id FROM stores WHERE region = 'California');", "generated_sql": "SELECT SUM(gs.revenue) AS total_revenue\nFROM garment_sales gs\nJOIN garment_manufacturing gm ON gs.garment_id = gm.garment_id\nWHERE gm.country = 'US' AND gs.store_id = 1;", "raw_model_output": "<think>\n\n</think>\n\nSELECT SUM(gs.revenue) AS total_revenue\nFROM garment_sales gs\nJOIN garment_manufacturing gm ON gs.garment_id = gm.garment_id\nWHERE gm.country = 'US' AND gs.store_id = 1;", "latency_sec": 0.9019949436187744, "total_duration_sec": 0.813616811, "load_duration_sec": 0.014008961, "tokens_prompt": 154, "prompt_eval_sec": 0.015492225, "tokens_completion": 56, "completion_eval_sec": 0.781467763, "tokens_total": 210, "tokens_per_sec": 232.81726963732947, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. 1) The country condition uses 'US' vs 'United States' which may not be equivalent depending on the data. 2) The store_id condition in the generated query is a specific value (1) while the reference uses a subquery to find all stores in California. These differences mean the queries could return different results."}
{"example_id": 596, "sql_complexity": "basic SQL", "prompt": "What is the minimum energy production cost of wind farms in Spain?", "context": "CREATE TABLE wind_farm_costs (id INT, name TEXT, country TEXT, energy_production_cost FLOAT); INSERT INTO wind_farm_costs (id, name, country, energy_production_cost) VALUES (1, 'Las Tiesas', 'Spain', 0.045), (2, 'Eolo', 'Spain', 0.050);", "reference_sql": "SELECT MIN(energy_production_cost) FROM wind_farm_costs WHERE country = 'Spain';", "generated_sql": "SELECT MIN(energy_production_cost) AS min_energy_production_cost\nFROM wind_farm_costs\nWHERE country = 'Spain';", "raw_model_output": "<think>\n\n</think>\n\nSELECT MIN(energy_production_cost) AS min_energy_production_cost\nFROM wind_farm_costs\nWHERE country = 'Spain';", "latency_sec": 0.46979379653930664, "total_duration_sec": 0.458971044, "load_duration_sec": 0.013811917, "tokens_prompt": 160, "prompt_eval_sec": 0.015494431, "tokens_completion": 30, "completion_eval_sec": 0.426698228, "tokens_total": 190, "tokens_per_sec": 404.43275624245734, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the minimum energy_production_cost from the wind_farm_costs table where country is 'Spain'. The generated query adds an alias (min_energy_production_cost) for the column, but this does not affect the semantic result. The core logic (aggregation, filtering, and column selection) remains identical."}
{"example_id": 2604, "sql_complexity": "subqueries", "prompt": "What is the maximum number of virtual tours taken by a single user in the UK?", "context": "CREATE TABLE virtual_tour_data (user_id INT, hotel_id INT, tour_date DATE); INSERT INTO virtual_tour_data (user_id, hotel_id, tour_date) VALUES (1, 10, '2022-01-01'), (2, 11, '2022-01-03'), (3, 12, '2022-01-05'), (4, 10, '2022-01-07'), (5, 10, '2022-01-09'); CREATE TABLE hotels (hotel_id INT, hotel_name TEXT, country TEXT); INSERT INTO hotels (hotel_id, hotel_name, country) VALUES (10, 'Royal Park Hotel', 'UK'), (11, 'The Ritz London', 'UK'), (12, 'Hotel de Crillon', 'France');", "reference_sql": "SELECT MAX(vt.user_tours) FROM (SELECT user_id, COUNT(DISTINCT hotel_id) as user_tours FROM virtual_tour_data WHERE country = 'UK' GROUP BY user_id) as vt;", "generated_sql": "SELECT MAX(tour_count) AS max_tours_by_user\nFROM (\n    SELECT user_id, COUNT(*) AS tour_count\n    FROM virtual_tour_data\n    JOIN hotels ON virtual_tour_data.hotel_id = hotels.hotel_id\n    WHERE hotels.country = 'UK'\n    GROUP BY user_id\n) AS user_tour_counts;", "raw_model_output": "<think>\n\n</think>\n\nSELECT MAX(tour_count) AS max_tours_by_user\nFROM (\n    SELECT user_id, COUNT(*) AS tour_count\n    FROM virtual_tour_data\n    JOIN hotels ON virtual_tour_data.hotel_id = hotels.hotel_id\n    WHERE hotels.country = 'UK'\n    GROUP BY user_id\n) AS user_tour_counts;", "latency_sec": 1.1544148921966553, "total_duration_sec": 1.144563242, "load_duration_sec": 0.014074342, "tokens_prompt": 286, "prompt_eval_sec": 0.028469984, "tokens_completion": 76, "completion_eval_sec": 1.099665554, "tokens_total": 362, "tokens_per_sec": 313.57876829809044, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references a 'country' column in the virtual_tour_data table, which does not exist. The Generated SQL correctly joins with the hotels table to filter by country. Additionally, the Reference SQL uses COUNT(DISTINCT hotel_id) while the Generated SQL uses COUNT(*), leading to different aggregation logic."}
{"example_id": 5812, "sql_complexity": "single join", "prompt": "Calculate the percentage of Shariah-compliant investments held by each investor in the top 5 countries with the highest percentage?", "context": "CREATE TABLE investors (investor_id INT, investor_name TEXT, country TEXT); INSERT INTO investors (investor_id, investor_name, country) VALUES (1, 'Al Thani', 'Qatar'), (2, 'Saudi Investment Group', 'Saudi Arabia'), (3, 'Temasek Holdings', 'Singapore'); CREATE TABLE investments (investment_id INT, investor_id INT, investment_type TEXT, investment_value DECIMAL, is_shariah_compliant BOOLEAN); INSERT INTO investments (investment_id, investor_id, investment_type, investment_value, is_shariah_compliant) VALUES (1, 1, 'Real Estate', 15000000, true), (2, 2, 'Stocks', 20000000, false);", "reference_sql": "SELECT investor_name, ROUND((SUM(CASE WHEN is_shariah_compliant THEN investment_value ELSE 0 END) / SUM(investment_value)) * 100, 2) AS percentage FROM investments JOIN investors ON investments.investor_id = investors.investor_id GROUP BY investor_name ORDER BY percentage DESC LIMIT 5;", "generated_sql": "SELECT \n    i.country, \n    i.investor_id, \n    i.investor_name, \n    (SUM(CASE WHEN inv.is_shariah_compliant THEN inv.investment_value ELSE 0 END) / SUM(inv.investment_value)) * 100 AS shariah_compliance_percentage\nFROM \n    investors i\nJOIN \n    investments inv ON i.investor_id = inv.investor_id\nGROUP BY \n    i.country, i.investor_id, i.investor_name\nORDER BY \n    shariah_compliance_percentage DESC\nLIMIT 5;", "raw_model_output": "<think>\n\n</think>\n\nSELECT \n    i.country, \n    i.investor_id, \n    i.investor_name, \n    (SUM(CASE WHEN inv.is_shariah_compliant THEN inv.investment_value ELSE 0 END) / SUM(inv.investment_value)) * 100 AS shariah_compliance_percentage\nFROM \n    investors i\nJOIN \n    investments inv ON i.investor_id = inv.investor_id\nGROUP BY \n    i.country, i.investor_id, i.investor_name\nORDER BY \n    shariah_compliance_percentage DESC\nLIMIT 5;", "latency_sec": 1.9128730297088623, "total_duration_sec": 1.897440566, "load_duration_sec": 0.013496452, "tokens_prompt": 259, "prompt_eval_sec": 0.027518312, "tokens_completion": 130, "completion_eval_sec": 1.854335686, "tokens_total": 389, "tokens_per_sec": 203.35902799529015, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in selected columns (Reference includes only investor_name, Generated includes country/investor_id), grouping logic (Reference groups by investor_name alone, Generated groups by country/investor_id/investor_name), and output formatting (Reference uses ROUND, Generated does not). These differences in structure and calculation precision make the results non-equivalent."}
{"example_id": 4706, "sql_complexity": "multiple_joins", "prompt": "Who are the top 3 customers by total spend on makeup products from Italy and Spain?", "context": "CREATE TABLE customers (customer_id INT, customer_name TEXT, country TEXT); INSERT INTO customers (customer_id, customer_name, country) VALUES (1, 'Alessandro Martini', 'IT'), (2, 'Laura Rossi', 'ES'), (3, 'Daniela Gonzalez', 'MX'), (4, 'Jose Hernandez', 'ES'), (5, 'Sophia Rodriguez', 'IT'); CREATE TABLE sales (sale_id INT, customer_id INT, product_id INT, sale_quantity INT, sale_country TEXT); INSERT INTO sales (sale_id, customer_id, product_id, sale_quantity, sale_country) VALUES (1, 1, 1, 100, 'IT'), (2, 2, 2, 150, 'ES'), (3, 3, 3, 200, 'MX'), (4, 4, 4, 250, 'ES'), (5, 5, 5, 300, 'IT'); CREATE TABLE products (product_id INT, product_name TEXT, category TEXT); INSERT INTO products (product_id, product_name, category) VALUES (1, 'Eyeshadow Palette', 'makeup'), (2, 'Liquid Lipstick', 'makeup'), (3, 'BB Cream', 'makeup'), (4, 'Volumizing Mascara', 'makeup'), (5, 'Nourishing Lip Balm', 'makeup');", "reference_sql": "SELECT c.customer_name, SUM(s.sale_quantity) as total_spent_on_makeup FROM sales s JOIN customers c ON s.customer_id = c.customer_id JOIN products p ON s.product_id = p.product_id WHERE c.country IN ('IT', 'ES') AND p.category = 'makeup' GROUP BY c.customer_name ORDER BY total_spent_on_makeup DESC LIMIT 3;", "generated_sql": "SELECT c.customer_id, c.customer_name, SUM(s.sale_quantity) AS total_spend\nFROM customers c\nJOIN sales s ON c.customer_id = s.customer_id\nJOIN products p ON s.product_id = p.product_id\nWHERE p.category = 'makeup' AND c.country IN ('IT', 'ES')\nGROUP BY c.customer_id, c.customer_name\nORDER BY total_spend DESC\nLIMIT 3;", "raw_model_output": "<think>\n\n</think>\n\nSELECT c.customer_id, c.customer_name, SUM(s.sale_quantity) AS total_spend\nFROM customers c\nJOIN sales s ON c.customer_id = s.customer_id\nJOIN products p ON s.product_id = p.product_id\nWHERE p.category = 'makeup' AND c.country IN ('IT', 'ES')\nGROUP BY c.customer_id, c.customer_name\nORDER BY total_spend DESC\nLIMIT 3;", "latency_sec": 1.4273700714111328, "total_duration_sec": 1.406699233, "load_duration_sec": 0.014057069, "tokens_prompt": 395, "prompt_eval_sec": 0.040753499, "tokens_completion": 91, "completion_eval_sec": 1.349095522, "tokens_total": 486, "tokens_per_sec": 340.48633198503916, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in selected columns (generated includes customer_id) and grouping strategy (reference groups by customer_name, generated groups by customer_id and customer_name). While the core aggregation and filtering are similar, the additional column and grouping key make them non-equivalent."}
{"example_id": 1515, "sql_complexity": "multiple_joins", "prompt": "What is the average age of clients who lost cases in the 'personal injury' category?", "context": "CREATE TABLE Cases (CaseID int, ClientID int, Category varchar(50)); INSERT INTO Cases (CaseID, ClientID, Category) VALUES (701, 7, 'Personal Injury'); CREATE TABLE Clients (ClientID int, Age int, Gender varchar(10)); INSERT INTO Clients (ClientID, Age, Gender) VALUES (7, 45, 'Male'); CREATE TABLE CaseOutcomes (CaseID int, Outcome varchar(50)); INSERT INTO CaseOutcomes (CaseID, Outcome) VALUES (701, 'Lost');", "reference_sql": "SELECT AVG(C.Age) as AvgAge FROM Clients C INNER JOIN Cases CA ON C.ClientID = CA.ClientID INNER JOIN CaseOutcomes CO ON CA.CaseID = CO.CaseID WHERE CA.Category = 'Personal Injury' AND CO.Outcome = 'Lost';", "generated_sql": "SELECT AVG(Clients.Age) AS AverageAge\nFROM Clients\nJOIN Cases ON Clients.ClientID = Cases.ClientID\nJOIN CaseOutcomes ON Cases.CaseID = CaseOutcomes.CaseID\nWHERE Cases.Category = 'Personal Injury' AND CaseOutcomes.Outcome = 'Lost';", "raw_model_output": "<think>\n\n</think>\n\nSELECT AVG(Clients.Age) AS AverageAge\nFROM Clients\nJOIN Cases ON Clients.ClientID = Cases.ClientID\nJOIN CaseOutcomes ON Cases.CaseID = CaseOutcomes.CaseID\nWHERE Cases.Category = 'Personal Injury' AND CaseOutcomes.Outcome = 'Lost';", "latency_sec": 0.9710469245910645, "total_duration_sec": 0.959862964, "load_duration_sec": 0.021079581, "tokens_prompt": 208, "prompt_eval_sec": 0.02581954, "tokens_completion": 64, "completion_eval_sec": 0.908685764, "tokens_total": 272, "tokens_per_sec": 280.1100473229416, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average age of clients with 'Personal Injury' cases that resulted in 'Lost'. They use identical table joins (Clients \u2192 Cases \u2192 CaseOutcomes), same WHERE conditions, and same aggregate function. The only differences are table alias names (C/CA/CO vs. Clients/Cases/CaseOutcomes) and column alias name (AvgAge vs. AverageAge), which do not affect semantic meaning."}
{"example_id": 4388, "sql_complexity": "subqueries", "prompt": "Insert a new drug with a price 10% higher than the average price", "context": "CREATE TABLE drugs (drug_id INT, drug_name VARCHAR(50), price DECIMAL(10, 2)); INSERT INTO drugs (drug_id, drug_name, price) VALUES (1, 'DrugA', 50), (2, 'DrugB', 75), (3, 'DrugC', 100)", "reference_sql": "INSERT INTO drugs (drug_id, drug_name, price) VALUES ((SELECT MAX(drug_id) FROM drugs) + 1, 'DrugD', (SELECT AVG(price) * 1.1 FROM drugs))", "generated_sql": "INSERT INTO drugs (drug_name, price)\nVALUES ('NewDrug', (SELECT AVG(price) * 1.1 FROM drugs));", "raw_model_output": "<think>\n\n</think>\n\nINSERT INTO drugs (drug_name, price)\nVALUES ('NewDrug', (SELECT AVG(price) * 1.1 FROM drugs));", "latency_sec": 0.5353138446807861, "total_duration_sec": 0.499654071, "load_duration_sec": 0.022490526, "tokens_prompt": 161, "prompt_eval_sec": 0.023253628, "tokens_completion": 32, "completion_eval_sec": 0.448652589, "tokens_total": 193, "tokens_per_sec": 360.5361638182329, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL explicitly sets drug_id to (MAX(drug_id) + 1) and uses 'DrugD' as the drug_name, while the Generated SQL omits drug_id (relying on auto-increment or defaults) and uses 'NewDrug' as the drug_name. Additionally, the price calculation is identical, but the differing drug_name and potential drug_id handling make the results different."}
{"example_id": 5431, "sql_complexity": "basic SQL", "prompt": "What is the average CO2 emission of ride-hailing vehicles in San Francisco?", "context": "CREATE TABLE SFRideHailing (id INT, company VARCHAR(20), co2_emission DECIMAL(5,2));", "reference_sql": "SELECT AVG(co2_emission) FROM SFRideHailing WHERE company = 'Uber';", "generated_sql": "SELECT AVG(co2_emission) AS average_co2_emission\nFROM SFRideHailing;", "raw_model_output": "<think>\n\n</think>\n\nSELECT AVG(co2_emission) AS average_co2_emission\nFROM SFRideHailing;", "latency_sec": 0.6278700828552246, "total_duration_sec": 0.399885247, "load_duration_sec": 0.027045525, "tokens_prompt": 116, "prompt_eval_sec": 0.011305061, "tokens_completion": 26, "completion_eval_sec": 0.35947458, "tokens_total": 142, "tokens_per_sec": 226.16143670081922, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters results to only include rows where company = 'Uber', while the Generated SQL calculates the average for all rows in the table without any filtering. The presence of the WHERE clause in the Reference query makes it semantically different from the Generated SQL."}
{"example_id": 3531, "sql_complexity": "single join", "prompt": "What is the total number of workouts and total workout time per user for users with a membership type of 'Basic'?", "context": "CREATE TABLE Members (id INT, user_name VARCHAR, membership_type VARCHAR, signup_date DATE); CREATE TABLE Workouts (id INT, user_id INT, workout_date DATE, workout_duration INT); INSERT INTO Members (id, user_name, membership_type, signup_date) VALUES (1, 'John Doe', 'Premium', '2020-01-01'), (2, 'Jane Smith', 'Basic', '2019-06-15'), (3, 'Alice Johnson', 'Premium', '2020-03-20'); INSERT INTO Workouts (id, user_id, workout_date, workout_duration) VALUES (1, 1, '2020-01-01', 60), (2, 1, '2020-01-02', 70), (3, 2, '2019-06-15', 90), (4, 3, '2020-03-20', 65), (5, 3, '2020-03-21', 70);", "reference_sql": "SELECT Members.user_name, SUM(Workouts.workout_duration) AS total_workout_time, COUNT(Workouts.id) AS total_workouts FROM Members JOIN Workouts ON Members.id = Workouts.user_id WHERE Members.membership_type = 'Basic' GROUP BY Members.user_name;", "generated_sql": "SELECT \n    m.id AS user_id, \n    COUNT(w.id) AS total_workouts, \n    SUM(w.workout_duration) AS total_workout_time\nFROM \n    Members m\nJOIN \n    Workouts w ON m.id = w.user_id\nWHERE \n    m.membership_type = 'Basic'\nGROUP BY \n    m.id;", "raw_model_output": "<think>\n\n</think>\n\nSELECT \n    m.id AS user_id, \n    COUNT(w.id) AS total_workouts, \n    SUM(w.workout_duration) AS total_workout_time\nFROM \n    Members m\nJOIN \n    Workouts w ON m.id = w.user_id\nWHERE \n    m.membership_type = 'Basic'\nGROUP BY \n    m.id;", "latency_sec": 1.2120907306671143, "total_duration_sec": 1.205828078, "load_duration_sec": 0.026330213, "tokens_prompt": 344, "prompt_eval_sec": 0.03722915, "tokens_completion": 77, "completion_eval_sec": 1.140111732, "tokens_total": 421, "tokens_per_sec": 347.3337344707592, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL groups by Members.user_name (which may not be unique) and selects user_name, while the Generated SQL groups by Members.id (unique) and selects user_id. Additionally, the column order and names differ, leading to different result structures. Even in the sample data, the output columns would differ (user_name vs. user_id), making the results structurally distinct."}
{"example_id": 5678, "sql_complexity": "set operations", "prompt": "How many public works projects are there in 'Sydney' and 'Melbourne' combined?", "context": "CREATE TABLE PublicWorksC(id INT, city VARCHAR(20), project VARCHAR(30)); INSERT INTO PublicWorksC(id, city, project) VALUES (1, 'Sydney', 'Park Renovation'), (2, 'Melbourne', 'Sidewalk Repair');", "reference_sql": "SELECT COUNT(*) FROM (SELECT city FROM PublicWorksC WHERE city = 'Sydney' UNION ALL SELECT city FROM PublicWorksC WHERE city = 'Melbourne') AS Total;", "generated_sql": "SELECT COUNT(*) \nFROM PublicWorksC \nWHERE city IN ('Sydney', 'Melbourne');", "raw_model_output": "<think>\n\n</think>\n\nSELECT COUNT(*) \nFROM PublicWorksC \nWHERE city IN ('Sydney', 'Melbourne');", "latency_sec": 0.6880209445953369, "total_duration_sec": 0.386434921, "load_duration_sec": 0.013528231, "tokens_prompt": 148, "prompt_eval_sec": 0.015772479, "tokens_completion": 25, "completion_eval_sec": 0.354924345, "tokens_total": 173, "tokens_per_sec": 251.44583367552983, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the total number of rows where the city is either 'Sydney' or 'Melbourne'. The Reference SQL uses a UNION ALL to combine two separate selects (which would have no duplicates since each subquery filters for a single city) and then counts the combined rows. The Generated SQL uses a single WHERE clause with IN, which achieves the same result. The final count will be identical in both cases."}
{"example_id": 5792, "sql_complexity": "multiple_joins", "prompt": "How many cases were handled by attorneys in the 'Los Angeles' office?", "context": "CREATE TABLE offices (office_id INT, office_name VARCHAR(20), city VARCHAR(20), state VARCHAR(20)); INSERT INTO offices (office_id, office_name, city, state) VALUES (1, 'Boston', 'Boston', 'MA'), (2, 'New York', 'New York', 'NY'), (3, 'Los Angeles', 'Los Angeles', 'CA'); CREATE TABLE attorneys (attorney_id INT, office_id INT); INSERT INTO attorneys (attorney_id, office_id) VALUES (1, 1), (2, 2), (3, 3); CREATE TABLE cases (case_id INT, attorney_id INT); INSERT INTO cases (case_id, attorney_id) VALUES (1, 1), (2, 2), (3, 3);", "reference_sql": "SELECT COUNT(*) FROM cases JOIN attorneys ON cases.attorney_id = attorneys.attorney_id JOIN offices ON attorneys.office_id = offices.office_id WHERE offices.city = 'Los Angeles';", "generated_sql": "SELECT COUNT(*) \nFROM cases \nJOIN attorneys ON cases.attorney_id = attorneys.attorney_id \nJOIN offices ON attorneys.office_id = offices.office_id \nWHERE offices.city = 'Los Angeles';", "raw_model_output": "<think>\n\n</think>\n\nSELECT COUNT(*) \nFROM cases \nJOIN attorneys ON cases.attorney_id = attorneys.attorney_id \nJOIN offices ON attorneys.office_id = offices.office_id \nWHERE offices.city = 'Los Angeles';", "latency_sec": 0.7220649719238281, "total_duration_sec": 0.679719469, "load_duration_sec": 0.014016274, "tokens_prompt": 253, "prompt_eval_sec": 0.023445042, "tokens_completion": 44, "completion_eval_sec": 0.640299806, "tokens_total": 297, "tokens_per_sec": 411.3203264917981, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure, join conditions, and WHERE clause. Both count cases linked to attorneys in the 'Los Angeles' office by joining the same tables with the same relationships and filters."}
{"example_id": 5148, "sql_complexity": "window functions", "prompt": "List the unique types of smart city technologies that have been implemented in the top 3 most populous countries in the world.", "context": "CREATE TABLE smart_city_tech (tech_type VARCHAR(255), country VARCHAR(255)); CREATE TABLE country_populations (country VARCHAR(255), population INT);", "reference_sql": "SELECT DISTINCT tech_type FROM smart_city_tech SCT WHERE country IN (SELECT country FROM (SELECT country, ROW_NUMBER() OVER (ORDER BY population DESC) as rank FROM country_populations) CP WHERE rank <= 3);", "generated_sql": "SELECT DISTINCT tech_type\nFROM smart_city_tech\nWHERE country IN (\n    SELECT country\n    FROM country_populations\n    ORDER BY population DESC\n    LIMIT 3\n);", "raw_model_output": "<think>\n\n</think>\n\nSELECT DISTINCT tech_type\nFROM smart_city_tech\nWHERE country IN (\n    SELECT country\n    FROM country_populations\n    ORDER BY population DESC\n    LIMIT 3\n);", "latency_sec": 1.0758800506591797, "total_duration_sec": 0.614256826, "load_duration_sec": 0.015427501, "tokens_prompt": 134, "prompt_eval_sec": 0.013222291, "tokens_completion": 42, "completion_eval_sec": 0.583467319, "tokens_total": 176, "tokens_per_sec": 163.5870094367553, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries aim to select distinct tech_types from smart_city_tech where the country is among the top 3 most populous countries. The reference query uses a window function to assign ranks and filter the top 3, while the generated query directly orders by population and limits to 3. Since both approaches ultimately retrieve the same set of countries (assuming deterministic ordering), the final results are semantically equivalent."}
{"example_id": 5547, "sql_complexity": "multiple_joins", "prompt": "Which species have a population growth rate higher than the average for protected areas?", "context": "CREATE TABLE species (id INT, name VARCHAR(50), population DECIMAL(5,2), protected_area_id INT, growth_rate DECIMAL(5,2)); INSERT INTO species (id, name, population, protected_area_id, growth_rate) VALUES (1, 'Species 1', 500.00, 1, 0.05), (2, 'Species 2', 800.00, 1, 0.03), (3, 'Species 3', 1200.00, 2, 0.07), (4, 'Species 4', 700.00, 2, 0.02); CREATE TABLE protected_areas (id INT, name VARCHAR(50)); INSERT INTO protected_areas (id, name) VALUES (1, 'Area 1'), (2, 'Area 2');", "reference_sql": "SELECT s.name, s.growth_rate FROM species s INNER JOIN protected_areas pa ON s.protected_area_id = pa.id GROUP BY s.name, s.growth_rate HAVING s.growth_rate > (SELECT AVG(s.growth_rate) FROM species s INNER JOIN protected_areas pa ON s.protected_area_id = pa.id);", "generated_sql": "SELECT species.id, species.name, species.growth_rate\nFROM species\nWHERE species.growth_rate > (\n    SELECT AVG(growth_rate)\n    FROM species\n);", "raw_model_output": "<think>\n\n</think>\n\nSELECT species.id, species.name, species.growth_rate\nFROM species\nWHERE species.growth_rate > (\n    SELECT AVG(growth_rate)\n    FROM species\n);", "latency_sec": 4.71652889251709, "total_duration_sec": 0.625815646, "load_duration_sec": 0.018500002, "tokens_prompt": 281, "prompt_eval_sec": 0.035598033, "tokens_completion": 39, "completion_eval_sec": 0.569581287, "tokens_total": 320, "tokens_per_sec": 67.84650476915117, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects 'name' and 'growth_rate' with a GROUP BY and HAVING clause that compares against an average calculated from a joined table. The Generated SQL selects 'id', 'name', and 'growth_rate' with a WHERE clause comparing against an average calculated from the species table alone. Differences include: 1) Column selection (id is missing in Reference SQL), 2) The Reference SQL's HAVING clause uses a subquery that joins protected_areas (though it doesn't filter rows), and 3) The GROUP BY in Reference SQL may alter result set structure compared to Generated SQL's simple WHERE filter."}
{"example_id": 5498, "sql_complexity": "aggregation", "prompt": "Identify the destinations with the highest number of repeat visitors from the US.", "context": "CREATE TABLE RepeatTravelers (Visitor VARCHAR(20), Destination VARCHAR(20), VisitCount INT); INSERT INTO RepeatTravelers (Visitor, Destination, VisitCount) VALUES ('David', 'Paris', 3), ('Ella', 'London', 4), ('Fiona', 'Paris', 2);", "reference_sql": "SELECT Destination, AVG(VisitCount) AS AvgVisitCount FROM RepeatTravelers WHERE Visitor LIKE '%USA%' GROUP BY Destination ORDER BY AvgVisitCount DESC;", "generated_sql": "SELECT Destination\nFROM RepeatTravelers\nWHERE Visitor = 'US';", "raw_model_output": "<think>\n\n</think>\n\nSELECT Destination\nFROM RepeatTravelers\nWHERE Visitor = 'US';", "latency_sec": 0.6275680065155029, "total_duration_sec": 0.319897177, "load_duration_sec": 0.019535996, "tokens_prompt": 152, "prompt_eval_sec": 0.021074126, "tokens_completion": 19, "completion_eval_sec": 0.275675058, "tokens_total": 171, "tokens_per_sec": 272.48042957042577, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates the average VisitCount per destination for visitors with 'USA' in their name, groups by destination, and orders results. The Generated SQL simply selects destinations where the visitor is exactly 'US' without any aggregation, grouping, or ordering. The conditions (LIKE '%USA%' vs = 'US') and the presence of aggregation/grouping in the Reference SQL further distinguish them."}
{"example_id": 3546, "sql_complexity": "window functions", "prompt": "What are the cryptocurrency exchanges with their corresponding blockchain companies, ranked by exchange ID in ascending order, for the Bitcoin platform?", "context": "CREATE TABLE cryptocurrency_exchanges (exchange_id INT, exchange_name VARCHAR(50), company_id INT); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (1, 'Binance', 1); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (2, 'Coinbase', 2); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (3, 'Kraken', 3); CREATE TABLE blockchain_companies (company_id INT, company_name VARCHAR(50), platform VARCHAR(50)); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (1, 'Binance', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (2, 'Blockstream', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (3, 'Blockchair', 'Bitcoin');", "reference_sql": "SELECT ce.exchange_name, bc.company_name, ce.exchange_id, ROW_NUMBER() OVER (PARTITION BY bc.platform ORDER BY ce.exchange_id ASC) as rank FROM cryptocurrency_exchanges ce JOIN blockchain_companies bc ON ce.company_id = bc.company_id WHERE bc.platform = 'Bitcoin';", "generated_sql": "SELECT ce.exchange_name, bc.company_name\nFROM cryptocurrency_exchanges ce\nJOIN blockchain_companies bc ON ce.company_id = bc.company_id\nWHERE bc.platform = 'Bitcoin'\nORDER BY ce.exchange_id ASC;", "raw_model_output": "<think>\n\n</think>\n\nSELECT ce.exchange_name, bc.company_name\nFROM cryptocurrency_exchanges ce\nJOIN blockchain_companies bc ON ce.company_id = bc.company_id\nWHERE bc.platform = 'Bitcoin'\nORDER BY ce.exchange_id ASC;", "latency_sec": 1.1109380722045898, "total_duration_sec": 0.767466323, "load_duration_sec": 0.027003868, "tokens_prompt": 293, "prompt_eval_sec": 0.030272313, "tokens_completion": 48, "completion_eval_sec": 0.707410866, "tokens_total": 341, "tokens_per_sec": 306.9478025208966, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL includes an additional 'exchange_id' column and a calculated 'rank' column using ROW_NUMBER(), while the Generated SQL omits these. Additionally, the Generated SQL includes an ORDER BY clause not present in the Reference SQL, which could affect result ordering. The semantic equivalence is broken by differing selected columns and calculated fields."}
{"example_id": 486, "sql_complexity": "single join", "prompt": "What is the average price of paintings from African artists in our collection?", "context": "CREATE TABLE Artworks (id INT, title VARCHAR(50), price DECIMAL(10,2), medium VARCHAR(50), artist_nationality VARCHAR(50)); CREATE TABLE Collections (id INT, name VARCHAR(50), continent VARCHAR(50));", "reference_sql": "SELECT AVG(Artworks.price) FROM Artworks INNER JOIN Collections ON Artworks.artist_nationality = Collections.continent WHERE Artworks.medium = 'Painting' AND Collections.continent = 'Africa';", "generated_sql": "SELECT AVG(Artworks.price) AS average_price\nFROM Artworks\nJOIN Collections ON Artworks.id = Collections.id\nWHERE Collections.continent = 'Africa';", "raw_model_output": "<think>\n\n</think>\n\nSELECT AVG(Artworks.price) AS average_price\nFROM Artworks\nJOIN Collections ON Artworks.id = Collections.id\nWHERE Collections.continent = 'Africa';", "latency_sec": 1.1471359729766846, "total_duration_sec": 0.554162227, "load_duration_sec": 0.022017598, "tokens_prompt": 143, "prompt_eval_sec": 0.012673615, "tokens_completion": 37, "completion_eval_sec": 0.51747787, "tokens_total": 180, "tokens_per_sec": 156.91252322331147, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL joins Artworks and Collections on Artworks.artist_nationality = Collections.continent and filters for 'Painting' medium, while the Generated SQL joins on Artworks.id = Collections.id and lacks the medium filter. The join conditions and WHERE clauses differ significantly."}
{"example_id": 794, "sql_complexity": "multiple_joins", "prompt": "Which suppliers have provided raw materials for the production of chemicals with high environmental impact?", "context": "CREATE TABLE suppliers (id INT, name TEXT); INSERT INTO suppliers (id, name) VALUES (1, 'Supplier1'), (2, 'Supplier2'), (3, 'Supplier3'); CREATE TABLE chemicals (id INT, name TEXT, environmental_impact INT); INSERT INTO chemicals (id, name, environmental_impact) VALUES (1, 'ChemA', 10), (2, 'ChemB', 20), (3, 'ChemC', 15); CREATE TABLE raw_materials (chemical_id INT, supplier_id INT); INSERT INTO raw_materials (chemical_id, supplier_id) VALUES (1, 1), (1, 2), (2, 3), (3, 1);", "reference_sql": "SELECT s.name FROM suppliers s INNER JOIN raw_materials rm ON s.id = rm.supplier_id INNER JOIN chemicals c ON rm.chemical_id = c.id WHERE c.environmental_impact > 10;", "generated_sql": "SELECT DISTINCT s.name\nFROM suppliers s\nJOIN raw_materials rm ON s.id = rm.supplier_id\nJOIN chemicals c ON rm.chemical_id = c.id\nWHERE c.environmental_impact > 15;", "raw_model_output": "<think>\n\n</think>\n\nSELECT DISTINCT s.name\nFROM suppliers s\nJOIN raw_materials rm ON s.id = rm.supplier_id\nJOIN chemicals c ON rm.chemical_id = c.id\nWHERE c.environmental_impact > 15;", "latency_sec": 1.1297709941864014, "total_duration_sec": 0.782241719, "load_duration_sec": 0.013884135, "tokens_prompt": 240, "prompt_eval_sec": 0.024849804, "tokens_completion": 51, "completion_eval_sec": 0.741041221, "tokens_total": 291, "tokens_per_sec": 257.5743239093885, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their WHERE conditions (10 vs 15) and use of DISTINCT. The Reference query includes suppliers with chemicals having environmental_impact > 10 (ChemB=20, ChemC=15), while the Generated query only includes those with >15 (ChemB=20). This results in different supplier sets: Reference returns Supplier1 and Supplier3, while Generated only returns Supplier3. The DISTINCT clause in Generated also affects potential duplicates but the primary discrepancy is the filter threshold."}
{"example_id": 3164, "sql_complexity": "set operations", "prompt": "What is the average age of patients who received therapy in 'clinic_a' and 'clinic_b'?", "context": "CREATE TABLE clinic_a (patient_id INT, age INT, therapy_received BOOLEAN); INSERT INTO clinic_a (patient_id, age, therapy_received) VALUES (1, 35, true), (2, 42, true), (3, 28, false); CREATE TABLE clinic_b (patient_id INT, age INT, therapy_received BOOLEAN); INSERT INTO clinic_b (patient_id, age, therapy_received) VALUES (4, 50, true), (5, 32, false), (6, 45, true);", "reference_sql": "SELECT AVG(age) FROM (SELECT age FROM clinic_a WHERE therapy_received = true UNION ALL SELECT age FROM clinic_b WHERE therapy_received = true) AS combined_clinics;", "generated_sql": "SELECT AVG(age) AS average_age\nFROM (\n    SELECT age FROM clinic_a WHERE therapy_received = TRUE\n    UNION ALL\n    SELECT age FROM clinic_b WHERE therapy_received = TRUE\n) AS combined_therapies;", "raw_model_output": "<think>\n\n</think>\n\nSELECT AVG(age) AS average_age\nFROM (\n    SELECT age FROM clinic_a WHERE therapy_received = TRUE\n    UNION ALL\n    SELECT age FROM clinic_b WHERE therapy_received = TRUE\n) AS combined_therapies;", "latency_sec": 0.916348934173584, "total_duration_sec": 0.76491957, "load_duration_sec": 0.019037707, "tokens_prompt": 207, "prompt_eval_sec": 0.022139273, "tokens_completion": 51, "completion_eval_sec": 0.721553426, "tokens_total": 258, "tokens_per_sec": 281.5521362860308, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average age of patients who received therapy by combining data from clinic_a and clinic_b using UNION ALL. The only differences are the alias names for the subquery (combined_clinics vs. combined_therapies) and the column alias (average_age in the generated query). These syntactic variations do not affect the semantic result, as the underlying data processing and calculation remain identical."}
{"example_id": 3704, "sql_complexity": "aggregation", "prompt": "What is the total sales revenue for each category of garments in the South America region in Q1 2022?", "context": "CREATE TABLE sales_category (sale_id INT, garment_category VARCHAR(50), sale_date DATE, total_sales DECIMAL(10, 2), region VARCHAR(50));", "reference_sql": "SELECT garment_category, SUM(total_sales) FROM sales_category WHERE sale_date BETWEEN '2022-01-01' AND '2022-03-31' AND region = 'South America' GROUP BY garment_category;", "generated_sql": "SELECT garment_category, SUM(total_sales) AS total_sales_revenue\nFROM sales_category\nWHERE region = 'South America'\n  AND sale_date BETWEEN '2022-01-01' AND '2022-03-31'\nGROUP BY garment_category;", "raw_model_output": "<think>\n\n</think>\n\nSELECT garment_category, SUM(total_sales) AS total_sales_revenue\nFROM sales_category\nWHERE region = 'South America'\n  AND sale_date BETWEEN '2022-01-01' AND '2022-03-31'\nGROUP BY garment_category;", "latency_sec": 1.0627751350402832, "total_duration_sec": 0.931928489, "load_duration_sec": 0.014004122, "tokens_prompt": 134, "prompt_eval_sec": 0.014783192, "tokens_completion": 65, "completion_eval_sec": 0.900950355, "tokens_total": 199, "tokens_per_sec": 187.24563027385577, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. Both select the same columns (garment_category and summed total_sales) from the same table with identical WHERE conditions and GROUP BY clause. The only difference is the column alias (total_sales_revenue) in the generated query, which does not affect the result's content."}
{"example_id": 2851, "sql_complexity": "single join", "prompt": "How many cases were handled by attorneys who joined the firm in 2015 or later?", "context": "CREATE TABLE attorneys (attorney_id INT, join_year INT); CREATE TABLE cases (case_id INT, attorney_id INT, billing_amount INT);", "reference_sql": "SELECT COUNT(DISTINCT cases.case_id) FROM cases INNER JOIN attorneys ON cases.attorney_id = attorneys.attorney_id WHERE attorneys.join_year >= 2015;", "generated_sql": "SELECT COUNT(DISTINCT case_id) \nFROM cases \nWHERE attorney_id IN (\n    SELECT attorney_id \n    FROM attorneys \n    WHERE join_year >= 2015\n);", "raw_model_output": "<think>\n\n</think>\n\nSELECT COUNT(DISTINCT case_id) \nFROM cases \nWHERE attorney_id IN (\n    SELECT attorney_id \n    FROM attorneys \n    WHERE join_year >= 2015\n);", "latency_sec": 0.9008638858795166, "total_duration_sec": 0.626728415, "load_duration_sec": 0.014338229, "tokens_prompt": 121, "prompt_eval_sec": 0.013709483, "tokens_completion": 43, "completion_eval_sec": 0.596623381, "tokens_total": 164, "tokens_per_sec": 182.04747972540403, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count distinct case_ids from cases where the attorney's join_year is >= 2015. The reference query uses an INNER JOIN to filter cases through the attorneys table, while the generated query uses a subquery with IN to achieve the same filtering. Since both approaches ensure only cases with qualifying attorneys are counted, they produce identical results."}
{"example_id": 3246, "sql_complexity": "single join", "prompt": "What is the average eco-friendliness score of accommodations in Oceania by year?", "context": "CREATE TABLE Accommodations (Accommodation_ID INT, Accommodation_Name VARCHAR(50), City VARCHAR(30), Country VARCHAR(50), Eco_Friendliness_Score INT, Visit_Year INT); INSERT INTO Accommodations (Accommodation_ID, Accommodation_Name, City, Country, Eco_Friendliness_Score, Visit_Year) VALUES (1, 'EcoLodge', 'Sydney', 'Australia', 85, 2019), (2, 'GreenHotel', 'Melbourne', 'Australia', 90, 2019), (3, 'SustainableResort', 'Auckland', 'New Zealand', 80, 2019), (4, 'EcoVilla', 'Wellington', 'New Zealand', 88, 2019); CREATE TABLE Countries (Country VARCHAR(50), Continent VARCHAR(30)); INSERT INTO Countries (Country, Continent) VALUES ('Australia', 'Oceania'), ('New Zealand', 'Oceania');", "reference_sql": "SELECT C.Continent, V.Visit_Year, AVG(A.Eco_Friendliness_Score) AS Avg_Eco_Score  FROM Accommodations A  JOIN Countries C  ON A.Country = C.Country  WHERE C.Continent = 'Oceania'  GROUP BY C.Continent, V.Visit_Year  ORDER BY V.Visit_Year;", "generated_sql": "SELECT Visit_Year, AVG(Eco_Friendliness_Score) AS Avg_Eco_Friendliness_Score\nFROM Accommodations\nJOIN Countries ON Accommodations.Country = Countries.Country\nWHERE Countries.Continent = 'Oceania'\nGROUP BY Visit_Year;", "raw_model_output": "<think>\n\n</think>\n\nSELECT Visit_Year, AVG(Eco_Friendliness_Score) AS Avg_Eco_Friendliness_Score\nFROM Accommodations\nJOIN Countries ON Accommodations.Country = Countries.Country\nWHERE Countries.Continent = 'Oceania'\nGROUP BY Visit_Year;", "latency_sec": 1.0621488094329834, "total_duration_sec": 0.941376934, "load_duration_sec": 0.015645325, "tokens_prompt": 312, "prompt_eval_sec": 0.032276096, "tokens_completion": 61, "completion_eval_sec": 0.89112626, "tokens_total": 373, "tokens_per_sec": 351.1748981756351, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes 'Continent' in both the SELECT and GROUP BY clauses, while the Generated SQL omits it. Although the WHERE clause restricts Continent to 'Oceania', the output structure differs: Reference returns three columns (Continent, Visit_Year, Avg_Eco_Score) whereas Generated returns two (Visit_Year, Avg_Eco_Score). This makes their result sets structurally different."}
{"example_id": 3056, "sql_complexity": "multiple_joins", "prompt": "Identify all suppliers who provide non-GMO ingredients to restaurants with Michelin stars.", "context": "CREATE TABLE Suppliers (id INT, name VARCHAR(50), isNonGMO BOOLEAN); CREATE TABLE Restaurants (id INT, name VARCHAR(50), numStars INT); CREATE TABLE Ingredients (supplierId INT, restaurantId INT, isNonGMO BOOLEAN);", "reference_sql": "SELECT Suppliers.name FROM Suppliers INNER JOIN Ingredients ON Suppliers.id = Ingredients.supplierId INNER JOIN Restaurants ON Ingredients.restaurantId = Restaurants.id WHERE Restaurants.numStars > 2 AND Ingredients.isNonGMO = TRUE;", "generated_sql": "SELECT DISTINCT s.id, s.name\nFROM Suppliers s\nJOIN Ingredients i ON s.id = i.supplierId\nJOIN Restaurants r ON i.restaurantId = r.id\nWHERE r.numStars > 0 AND i.isNonGMO = TRUE;", "raw_model_output": "<think>\n\n</think>\n\nSELECT DISTINCT s.id, s.name\nFROM Suppliers s\nJOIN Ingredients i ON s.id = i.supplierId\nJOIN Restaurants r ON i.restaurantId = r.id\nWHERE r.numStars > 0 AND i.isNonGMO = TRUE;", "latency_sec": 0.822484016418457, "total_duration_sec": 0.808443196, "load_duration_sec": 0.015558644, "tokens_prompt": 143, "prompt_eval_sec": 0.013898095, "tokens_completion": 56, "completion_eval_sec": 0.776796503, "tokens_total": 199, "tokens_per_sec": 241.94999055003439, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in three key aspects: 1) The reference query selects only 'Suppliers.name' while the generated query selects 's.id' and 's.name' (different column sets). 2) The WHERE clause in the reference uses 'Restaurants.numStars > 2' whereas the generated uses 'r.numStars > 0' (different numeric thresholds). 3) The generated query includes 'DISTINCT' which isn't present in the reference. These differences ensure they would produce non-equivalent results."}
{"example_id": 264, "sql_complexity": "set operations", "prompt": "List the number of community health centers and infectious disease tracking facilities in 'southwest' regions.", "context": "CREATE TABLE centers (id INT, name TEXT, region TEXT); INSERT INTO centers (id, name, region) VALUES (1, 'Center A', 'southwest'); INSERT INTO centers (id, name, region) VALUES (2, 'Center B', 'northeast'); INSERT INTO centers (id, name, region) VALUES (3, 'Center C', 'northwest'); CREATE TABLE diseases (id INT, name TEXT, region TEXT); INSERT INTO diseases (id, name, region) VALUES (1, 'Disease A', 'southwest'); INSERT INTO diseases (id, name, region) VALUES (2, 'Disease B', 'southeast');", "reference_sql": "SELECT COUNT(*) FROM ( (SELECT * FROM centers WHERE region = 'southwest') UNION (SELECT * FROM diseases WHERE region = 'southwest') );", "generated_sql": "SELECT \n  COUNT(*) AS total_centers\nFROM \n  centers\nWHERE \n  region = 'southwest';", "raw_model_output": "<think>\n\n</think>\n\nSELECT \n  COUNT(*) AS total_centers\nFROM \n  centers\nWHERE \n  region = 'southwest';", "latency_sec": 0.457277774810791, "total_duration_sec": 0.450743842, "load_duration_sec": 0.014470366, "tokens_prompt": 230, "prompt_eval_sec": 0.024160482, "tokens_completion": 28, "completion_eval_sec": 0.40997037, "tokens_total": 258, "tokens_per_sec": 564.2084837968636, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL counts rows from both 'centers' and 'diseases' tables where region = 'southwest' (e.g., 2 rows: Center A and Disease A). The Generated SQL only counts rows from the 'centers' table (e.g., 1 row: Center A). The UNION in the Reference SQL combines two separate tables, while the Generated SQL focuses on a single table."}
{"example_id": 2838, "sql_complexity": "basic SQL", "prompt": "What is the minimum safety rating of electric vehicles in the 'green_cars' table?", "context": "CREATE TABLE green_cars (id INT, make VARCHAR(50), model VARCHAR(50), type VARCHAR(50), safety_rating INT);", "reference_sql": "SELECT MIN(safety_rating) FROM green_cars WHERE type = 'Electric';", "generated_sql": "SELECT MIN(safety_rating) AS min_safety_rating\nFROM green_cars\nWHERE type = 'electric';", "raw_model_output": "<think>\n\n</think>\n\nSELECT MIN(safety_rating) AS min_safety_rating\nFROM green_cars\nWHERE type = 'electric';", "latency_sec": 0.5562129020690918, "total_duration_sec": 0.42240462, "load_duration_sec": 0.020270233, "tokens_prompt": 121, "prompt_eval_sec": 0.011221995, "tokens_completion": 28, "completion_eval_sec": 0.38900548, "tokens_total": 149, "tokens_per_sec": 267.88303443829767, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the minimum safety_rating from green_cars where type matches a specific value. The difference in string case ('Electric' vs 'electric') is likely irrelevant under standard SQL collation rules (case-insensitive comparisons by default). The alias in the generated query (min_safety_rating) affects column naming but not the computed value. The core logic and result set remain equivalent."}
{"example_id": 1187, "sql_complexity": "multiple_joins", "prompt": "Who are the top 3 authors with the highest number of articles published in The Guardian?", "context": "CREATE TABLE authors (id INT, name VARCHAR(100), publisher VARCHAR(50)); CREATE TABLE articles_authors (article_id INT, author_id INT); INSERT INTO authors (id, name, publisher) VALUES (1, 'Author1', 'The Guardian'), (2, 'Author2', 'The Guardian'), (3, 'Author3', 'The Guardian'); INSERT INTO articles_authors (article_id, author_id) VALUES (1, 1), (2, 2), (3, 1), (3, 2), (3, 3); INSERT INTO articles (id, title, publication_date, publisher) VALUES (1, 'Article1', '2021-01-01', 'The Guardian'), (2, 'Article2', '2021-01-02', 'The Guardian'), (3, 'Article3', '2021-01-03', 'The Guardian');", "reference_sql": "SELECT a.name, COUNT(aa.article_id) AS articles_count FROM authors a JOIN articles_authors aa ON a.id = aa.author_id JOIN articles ar ON aa.article_id = ar.id WHERE ar.publisher = 'The Guardian' GROUP BY a.name ORDER BY articles_count DESC LIMIT 3;", "generated_sql": "SELECT a.name, COUNT(DISTINCT aa.article_id) AS article_count\nFROM authors a\nJOIN articles_authors aa ON a.id = aa.author_id\nJOIN articles ar ON aa.article_id = ar.id\nWHERE ar.publisher = 'The Guardian'\nGROUP BY a.name\nORDER BY article_count DESC\nLIMIT 3;", "raw_model_output": "<think>\n\n</think>\n\nSELECT a.name, COUNT(DISTINCT aa.article_id) AS article_count\nFROM authors a\nJOIN articles_authors aa ON a.id = aa.author_id\nJOIN articles ar ON aa.article_id = ar.id\nWHERE ar.publisher = 'The Guardian'\nGROUP BY a.name\nORDER BY article_count DESC\nLIMIT 3;", "latency_sec": 1.1234519481658936, "total_duration_sec": 1.096248714, "load_duration_sec": 0.019967914, "tokens_prompt": 294, "prompt_eval_sec": 0.030941347, "tokens_completion": 72, "completion_eval_sec": 1.04311656, "tokens_total": 366, "tokens_per_sec": 325.7816238580726, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the aggregation function: the Reference SQL uses COUNT(aa.article_id) while the Generated SQL uses COUNT(DISTINCT aa.article_id). This means the Generated SQL would count unique article_ids per author, whereas the Reference SQL counts all occurrences. If an author is linked to the same article multiple times in the articles_authors table (which is possible given the schema), the two queries would produce different results. Since the schema allows for duplicate (article_id, author_id) pairs, the queries are not semantically equivalent."}
{"example_id": 360, "sql_complexity": "window functions", "prompt": "What is the change in crime rate for each category, between this year and last year, for the same time period?", "context": "CREATE TABLE CrimeStatistics (ID INT, CrimeType VARCHAR(50), Date TIMESTAMP, Count INT); INSERT INTO CrimeStatistics (ID, CrimeType, Date, Count) VALUES (1, 'Theft', '2022-01-01 00:00:00', 100), (2, 'Vandalism', '2022-01-01 00:00:00', 50), (3, 'Theft', '2022-01-02 00:00:00', 120), (4, 'Vandalism', '2022-01-02 00:00:00', 60), (5, 'Theft', '2021-01-01 00:00:00', 80), (6, 'Vandalism', '2021-01-01 00:00:00', 40), (7, 'Theft', '2021-01-02 00:00:00', 90), (8, 'Vandalism', '2021-01-02 00:00:00', 45);", "reference_sql": "SELECT CrimeType, (SUM(Count) OVER (PARTITION BY CrimeType ORDER BY EXTRACT(YEAR FROM Date) ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)) - SUM(Count) OVER (PARTITION BY CrimeType ORDER BY EXTRACT(YEAR FROM Date)) AS CrimeRateChange FROM CrimeStatistics WHERE Date BETWEEN DATE_TRUNC('year', CURRENT_DATE - INTERVAL '1 year') AND CURRENT_DATE;", "generated_sql": "SELECT \n    CrimeType,\n    SUM(CASE WHEN EXTRACT(YEAR FROM Date) = 2022 THEN Count ELSE 0 END) AS ThisYearCount,\n    SUM(CASE WHEN EXTRACT(YEAR FROM Date) = 2021 THEN Count ELSE 0 END) AS LastYearCount,\n    SUM(CASE WHEN EXTRACT(YEAR FROM Date) = 2022 THEN Count ELSE 0 END) - \n    SUM(CASE WHEN EXTRACT(YEAR FROM Date) = 2021 THEN Count ELSE 0 END) AS ChangeInCount\nFROM \n    CrimeStatistics\nGROUP BY \n    CrimeType;", "raw_model_output": "<think>\n\n</think>\n\nSELECT \n    CrimeType,\n    SUM(CASE WHEN EXTRACT(YEAR FROM Date) = 2022 THEN Count ELSE 0 END) AS ThisYearCount,\n    SUM(CASE WHEN EXTRACT(YEAR FROM Date) = 2021 THEN Count ELSE 0 END) AS LastYearCount,\n    SUM(CASE WHEN EXTRACT(YEAR FROM Date) = 2022 THEN Count ELSE 0 END) - \n    SUM(CASE WHEN EXTRACT(YEAR FROM Date) = 2021 THEN Count ELSE 0 END) AS ChangeInCount\nFROM \n    CrimeStatistics\nGROUP BY \n    CrimeType;", "latency_sec": 2.1971561908721924, "total_duration_sec": 2.123150403, "load_duration_sec": 0.024722034, "tokens_prompt": 394, "prompt_eval_sec": 0.04043669, "tokens_completion": 141, "completion_eval_sec": 2.055809599, "tokens_total": 535, "tokens_per_sec": 243.49657171510603, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL uses window functions to calculate a year-over-year change based on ordered rows, but its logic appears flawed (e.g., subtracting cumulative sums in a way that may not represent true year-over-year differences). The Generated SQL explicitly aggregates counts for specific years (2022 vs. 2021) and calculates their difference. Additionally, the Reference SQL applies a date filter that may exclude data considered by the Generated SQL. The two approaches compute different metrics and have different filtering logic."}
{"example_id": 335, "sql_complexity": "single join", "prompt": "List the policy numbers, claim amounts, and claim dates for policies that have more than two claims and the total claim amount exceeds $5000", "context": "CREATE TABLE policies (policy_number INT);CREATE TABLE claims (claim_id INT, policy_number INT, claim_amount DECIMAL(10,2), claim_date DATE);", "reference_sql": "SELECT p.policy_number, c.claim_amount, c.claim_date FROM policies p INNER JOIN claims c ON p.policy_number = c.policy_number GROUP BY p.policy_number, c.claim_amount, c.claim_date HAVING COUNT(c.claim_id) > 2 AND SUM(c.claim_amount) > 5000;", "generated_sql": "SELECT p.policy_number, c.claim_amount, c.claim_date\nFROM policies p\nJOIN claims c ON p.policy_number = c.policy_number\nWHERE p.policy_number IN (\n    SELECT policy_number\n    FROM claims\n    GROUP BY policy_number\n    HAVING COUNT(*) > 2 AND SUM(claim_amount) > 5000\n);", "raw_model_output": "<think>\n\n</think>\n\nSELECT p.policy_number, c.claim_amount, c.claim_date\nFROM policies p\nJOIN claims c ON p.policy_number = c.policy_number\nWHERE p.policy_number IN (\n    SELECT policy_number\n    FROM claims\n    GROUP BY policy_number\n    HAVING COUNT(*) > 2 AND SUM(claim_amount) > 5000\n);", "latency_sec": 1.1474699974060059, "total_duration_sec": 1.122051081, "load_duration_sec": 0.014327964, "tokens_prompt": 137, "prompt_eval_sec": 0.013004475, "tokens_completion": 79, "completion_eval_sec": 1.092546738, "tokens_total": 216, "tokens_per_sec": 188.24021585600846, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their grouping and filtering logic. The reference query groups by policy_number, claim_amount, and claim_date, then applies HAVING conditions on per-group counts and sums. The generated query uses a subquery to filter policies with total claims >2 and sum >5000, then returns all claims for those policies. This means the generated query returns individual claims for qualifying policies, while the reference query aggregates claims into groups based on claim_amount and claim_date. The semantic results would differ in cases where a policy has multiple claims with varying amounts/dates."}
{"example_id": 2866, "sql_complexity": "basic SQL", "prompt": "What is the number of hospitals in 'rural_healthcare' table?", "context": "CREATE TABLE rural_healthcare (name VARCHAR(255), type VARCHAR(255), location VARCHAR(255)); INSERT INTO rural_healthcare (name, type, location) VALUES ('Rural General Hospital', 'Hospital', 'Bushland'), ('Rural Community Hospital', 'Hospital', 'Forest Region');", "reference_sql": "SELECT COUNT(*) FROM rural_healthcare WHERE type = 'Hospital';", "generated_sql": "SELECT COUNT(*) FROM rural_healthcare WHERE type = 'Hospital';", "raw_model_output": "<think>\n\n</think>\n\nSELECT COUNT(*) FROM rural_healthcare WHERE type = 'Hospital';", "latency_sec": 0.3487989902496338, "total_duration_sec": 0.291376056, "load_duration_sec": 0.015062209, "tokens_prompt": 153, "prompt_eval_sec": 0.01453565, "tokens_completion": 18, "completion_eval_sec": 0.259590361, "tokens_total": 171, "tokens_per_sec": 490.25371282645085, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They both count all rows in the 'rural_healthcare' table where the 'type' column equals 'Hospital'. The SQL syntax, table name, column references, and filter condition are exactly the same in both queries."}
{"example_id": 4440, "sql_complexity": "multiple_joins", "prompt": "What is the average session length for each game genre in the last month, sorted by average session length.", "context": "CREATE TABLE game_sessions(id INT, user_id INT, game_name VARCHAR(50), start_time DATETIME, end_time DATETIME); CREATE TABLE games(id INT, name VARCHAR(50), genre VARCHAR(50));", "reference_sql": "SELECT genres.genre, AVG(TIMESTAMPDIFF(SECOND, start_time, end_time)) as avg_session_length FROM game_sessions JOIN games ON game_sessions.game_name = games.name JOIN (SELECT DISTINCT game_name, genre FROM game_sessions JOIN games ON game_sessions.game_name = games.name) genres ON games.name = genres.game_name WHERE start_time >= DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH) GROUP BY genres.genre ORDER BY avg_session_length DESC;", "generated_sql": "SELECT \n    g.genre, \n    AVG(TIMESTAMPDIFF(MINUTE, gs.start_time, gs.end_time)) AS avg_session_length\nFROM \n    game_sessions gs\nJOIN \n    games g ON gs.game_name = g.name\nWHERE \n    gs.end_time >= CURRENT_DATE - INTERVAL '1 month'\nORDER BY \n    avg_session_length;", "raw_model_output": "<think>\n\n</think>\n\nSELECT \n    g.genre, \n    AVG(TIMESTAMPDIFF(MINUTE, gs.start_time, gs.end_time)) AS avg_session_length\nFROM \n    game_sessions gs\nJOIN \n    games g ON gs.game_name = g.name\nWHERE \n    gs.end_time >= CURRENT_DATE - INTERVAL '1 month'\nORDER BY \n    avg_session_length;", "latency_sec": 1.2682719230651855, "total_duration_sec": 1.093233585, "load_duration_sec": 0.014034029, "tokens_prompt": 139, "prompt_eval_sec": 0.013047445, "tokens_completion": 77, "completion_eval_sec": 1.064022214, "tokens_total": 216, "tokens_per_sec": 170.310480009655, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in several key aspects: 1) The Reference uses start_time >= DATE_SUB(...) while Generated uses end_time >= ...; 2) The Reference groups by genre with AVG(seconds) while Generated lacks GROUP BY and uses AVG(minutes); 3) The Reference includes a subquery for distinct game_name/genre pairs which the Generated lacks. These differences in filtering, aggregation, and structure make them non-equivalent."}
{"example_id": 451, "sql_complexity": "single join", "prompt": "Which customers have made a transaction over 500 in the \"risk_management\" category?", "context": "CREATE TABLE customers (id INT, name VARCHAR(50), category VARCHAR(50)); INSERT INTO customers (id, name, category) VALUES (1, 'John Doe', 'risk_management'); INSERT INTO customers (id, name, category) VALUES (2, 'Jane Smith', 'compliance'); INSERT INTO customers (id, name, category) VALUES (3, 'Jim Brown', 'risk_management'); CREATE TABLE transactions (id INT, customer_id INT, amount DECIMAL(10, 2)); INSERT INTO transactions (id, customer_id, amount) VALUES (1, 1, 500.00); INSERT INTO transactions (id, customer_id, amount) VALUES (2, 1, 200.00); INSERT INTO transactions (id, customer_id, amount) VALUES (3, 2, 100.00); INSERT INTO transactions (id, customer_id, amount) VALUES (4, 3, 750.00);", "reference_sql": "SELECT c.name FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE c.category = 'risk_management' AND t.amount > 500;", "generated_sql": "SELECT DISTINCT c.name\nFROM customers c\nJOIN transactions t ON c.id = t.customer_id\nWHERE c.category = 'risk_management'\nAND t.amount > 500;", "raw_model_output": "<think>\n\n</think>\n\nSELECT DISTINCT c.name\nFROM customers c\nJOIN transactions t ON c.id = t.customer_id\nWHERE c.category = 'risk_management'\nAND t.amount > 500;", "latency_sec": 0.8842179775238037, "total_duration_sec": 0.672801101, "load_duration_sec": 0.018922135, "tokens_prompt": 301, "prompt_eval_sec": 0.029317776, "tokens_completion": 42, "completion_eval_sec": 0.622306018, "tokens_total": 343, "tokens_per_sec": 387.91339773542006, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Generated SQL includes DISTINCT which ensures unique names, while the Reference SQL may return duplicate names if a customer has multiple qualifying transactions. Although the test data produces the same result, the queries differ in handling duplicates."}
{"example_id": 2879, "sql_complexity": "basic SQL", "prompt": "Update the FoodSafetyRecords.OrganicFarms table to include a new record for a certified organic farm in Kenya.", "context": "CREATE TABLE FoodSafetyRecords.OrganicFarms (farmName TEXT, country TEXT, certified BOOLEAN);", "reference_sql": "INSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('Ngong Organic Farm', 'Kenya', TRUE);", "generated_sql": "INSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('GreenHarvest Kenya', 'Kenya', TRUE);", "raw_model_output": "<think>\n\n</think>\n\nINSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('GreenHarvest Kenya', 'Kenya', TRUE);", "latency_sec": 0.6037740707397461, "total_duration_sec": 0.52999345, "load_duration_sec": 0.014625964, "tokens_prompt": 117, "prompt_eval_sec": 0.012737284, "tokens_completion": 36, "completion_eval_sec": 0.500474136, "tokens_total": 153, "tokens_per_sec": 253.40604609360562, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The two queries differ in the farmName value inserted. The reference SQL inserts 'Ngong Organic Farm' while the generated SQL inserts 'GreenHarvest Kenya'. Since the farmName is a textual field and the values differ, the resulting data would not be identical."}
{"example_id": 5688, "sql_complexity": "single join", "prompt": "What is the total amount donated to a specific cause?", "context": "CREATE TABLE causes (id INT, name TEXT); CREATE TABLE donations (id INT, donor_id INT, cause_id INT, donation_amount DECIMAL(10,2)); INSERT INTO causes (id, name) VALUES (1, 'Cause A'), (2, 'Cause B'); INSERT INTO donations (id, donor_id, cause_id, donation_amount) VALUES (1, 1, 1, 50.00), (2, 2, 1, 100.00);", "reference_sql": "SELECT SUM(donation_amount) FROM donations JOIN causes ON donations.cause_id = causes.id WHERE causes.name = 'Cause A';", "generated_sql": "SELECT SUM(donation_amount) AS total_donation\nFROM donations\nWHERE cause_id = 1;", "raw_model_output": "<think>\n\n</think>\n\nSELECT SUM(donation_amount) AS total_donation\nFROM donations\nWHERE cause_id = 1;", "latency_sec": 0.5251460075378418, "total_duration_sec": 0.405043456, "load_duration_sec": 0.014070339, "tokens_prompt": 190, "prompt_eval_sec": 0.018581309, "tokens_completion": 26, "completion_eval_sec": 0.370199611, "tokens_total": 216, "tokens_per_sec": 411.31418100790785, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the total donations for 'Cause A'. The Reference SQL uses a JOIN to filter by cause name, while the Generated SQL directly uses the known cause_id (1) corresponding to 'Cause A'. Since the data maps cause_id 1 to 'Cause A', both queries sum the same donations."}
{"example_id": 3273, "sql_complexity": "multiple_joins", "prompt": "List all departments, the number of chemicals they handle, and the number of machines used in their manufacturing processes.", "context": "CREATE TABLE Departments (DepartmentID INT, DepartmentName VARCHAR(20)); INSERT INTO Departments (DepartmentID, DepartmentName) VALUES (1, 'Manufacturing'), (2, 'Engineering'), (3, 'Chemical Safety'), (4, 'Product Development'); CREATE TABLE Chemicals (ChemicalID INT, ChemicalName VARCHAR(20), DepartmentID INT); INSERT INTO Chemicals (ChemicalID, ChemicalName, DepartmentID) VALUES (1, 'Hydrochloric Acid', 1), (2, 'Nitric Acid', 2), (3, 'Sodium Hydroxide', 3), (4, 'New Chemical', 4); CREATE TABLE Machinery (MachineID INT, MachineName VARCHAR(20), DepartmentID INT); INSERT INTO Machinery (MachineID, MachineName, DepartmentID) VALUES (1, 'Mixer 1', 1), (2, 'Cutter 2', 2), (3, 'Dispenser 3', 3), (4, 'Innovator 4', 4);", "reference_sql": "SELECT D.DepartmentName, COUNT(C.ChemicalID) AS ChemicalCount, COUNT(M.MachineID) AS MachineCount FROM Departments D LEFT JOIN Chemicals C ON D.DepartmentID = C.DepartmentID LEFT JOIN Machinery M ON D.DepartmentID = M.DepartmentID GROUP BY D.DepartmentName;", "generated_sql": "SELECT \n    D.DepartmentID, \n    D.DepartmentName, \n    COUNT(C.ChemicalID) AS ChemicalCount, \n    COUNT(M.MachineID) AS MachineCount\nFROM \n    Departments D\nLEFT JOIN \n    Chemicals C ON D.DepartmentID = C.DepartmentID\nLEFT JOIN \n    Machinery M ON D.DepartmentID = M.DepartmentID\nGROUP BY \n    D.DepartmentID, D.DepartmentName;", "raw_model_output": "<think>\n\n</think>\n\nSELECT \n    D.DepartmentID, \n    D.DepartmentName, \n    COUNT(C.ChemicalID) AS ChemicalCount, \n    COUNT(M.MachineID) AS MachineCount\nFROM \n    Departments D\nLEFT JOIN \n    Chemicals C ON D.DepartmentID = C.DepartmentID\nLEFT JOIN \n    Machinery M ON D.DepartmentID = M.DepartmentID\nGROUP BY \n    D.DepartmentID, D.DepartmentName;", "latency_sec": 1.4441378116607666, "total_duration_sec": 1.382759426, "load_duration_sec": 0.014124179, "tokens_prompt": 314, "prompt_eval_sec": 0.033072349, "tokens_completion": 92, "completion_eval_sec": 1.332938591, "tokens_total": 406, "tokens_per_sec": 281.13660394578113, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects only DepartmentName, while the Generated SQL includes DepartmentID as an additional column. Although both group by DepartmentName (Reference) or DepartmentID/DepartmentName (Generated), the presence of the extra DepartmentID column in the Generated SQL changes the result set structure, making them non-equivalent."}
{"example_id": 1895, "sql_complexity": "window functions", "prompt": "What is the average safety score of chemical production sites in the United States, partitioned by state and ranked in descending order?", "context": "CREATE TABLE production_sites (site_id INT, site_name TEXT, country TEXT, state TEXT, safety_score FLOAT); INSERT INTO production_sites (site_id, site_name, country, state, safety_score) VALUES (1, 'Site A', 'USA', 'NY', 92.5), (2, 'Site B', 'USA', 'CA', 87.4), (3, 'Site C', 'USA', 'TX', 95.3), (4, 'Site D', 'USA', 'FL', 89.2);", "reference_sql": "SELECT state, AVG(safety_score) as avg_safety_score, ROW_NUMBER() OVER (ORDER BY AVG(safety_score) DESC) as rank FROM production_sites WHERE country = 'USA' GROUP BY state ORDER BY rank;", "generated_sql": "SELECT \n    state, \n    AVG(safety_score) AS avg_safety_score\nFROM \n    production_sites\nWHERE \n    country = 'USA'\nGROUP BY \n    state\nORDER BY \n    avg_safety_score DESC;", "raw_model_output": "<think>\n\n</think>\n\nSELECT \n    state, \n    AVG(safety_score) AS avg_safety_score\nFROM \n    production_sites\nWHERE \n    country = 'USA'\nGROUP BY \n    state\nORDER BY \n    avg_safety_score DESC;", "latency_sec": 1.0204877853393555, "total_duration_sec": 0.799433556, "load_duration_sec": 0.015199254, "tokens_prompt": 215, "prompt_eval_sec": 0.022615596, "tokens_completion": 53, "completion_eval_sec": 0.758552551, "tokens_total": 268, "tokens_per_sec": 262.61950789629356, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a 'rank' column generated by ROW_NUMBER() and orders by this rank, while the Generated SQL omits the rank column and orders directly by 'avg_safety_score'. Although both group by state and filter by country='USA', the Reference SQL's ordering logic and additional column make the result sets structurally different."}
{"example_id": 4669, "sql_complexity": "set operations", "prompt": "Identify the number of IoT devices in each country and the total number of devices.", "context": "CREATE TABLE device_country (device_id INT, country TEXT); INSERT INTO device_country (device_id, country) VALUES (1, 'USA'), (2, 'Canada'), (3, 'Mexico'), (4, 'Brazil'); CREATE TABLE device_info (device_id INT, device_type TEXT); INSERT INTO device_info (device_id, device_type) VALUES (1, 'Soil Sensor'), (2, 'Temperature Sensor'), (3, 'Humidity Sensor'), (4, 'Precision Sprayer');", "reference_sql": "SELECT country, COUNT(*) AS device_count FROM device_country GROUP BY country UNION SELECT 'Total' AS country, COUNT(*) FROM device_country;", "generated_sql": "SELECT \n    dc.country, \n    COUNT(dc.device_id) AS device_count_per_country,\n    (SELECT COUNT(*) FROM device_country) AS total_devices\nFROM \n    device_country dc\nGROUP BY \n    dc.country;", "raw_model_output": "<think>\n\n</think>\n\nSELECT \n    dc.country, \n    COUNT(dc.device_id) AS device_count_per_country,\n    (SELECT COUNT(*) FROM device_country) AS total_devices\nFROM \n    device_country dc\nGROUP BY \n    dc.country;", "latency_sec": 0.7781102657318115, "total_duration_sec": 0.765720987, "load_duration_sec": 0.01935417, "tokens_prompt": 192, "prompt_eval_sec": 0.022413052, "tokens_completion": 51, "completion_eval_sec": 0.719984243, "tokens_total": 243, "tokens_per_sec": 312.2950701228172, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns separate rows for each country's count and a distinct 'Total' row, while the Generated SQL includes the total devices as a column in every row. The structure and output format differ: the first uses a UNION to combine country counts with a total row, and the second embeds the total as a repeated value in each row. The results are not semantically equivalent."}
{"example_id": 5302, "sql_complexity": "multiple_joins", "prompt": "Find the supplier with the lowest average delivery time for orders in the last month.", "context": "CREATE TABLE Suppliers (SupplierID int, SupplierName varchar(50)); CREATE TABLE Products (ProductID int, ProductName varchar(50), SupplierID int); CREATE TABLE Orders (OrderID int, ProductID int, OrderDate date, DeliveryTime int); INSERT INTO Suppliers VALUES (1, 'SupplierA'), (2, 'SupplierB'); INSERT INTO Products VALUES (1, 'Organic Apples', 1), (2, 'Bananas', 2); INSERT INTO Orders VALUES (1, 1, '2022-01-01', 2), (2, 2, '2022-01-03', 3);", "reference_sql": "SELECT SupplierName, AVG(DeliveryTime) as AvgDeliveryTime FROM Orders o JOIN Products p ON o.ProductID = p.ProductID JOIN Suppliers sp ON p.SupplierID = sp.SupplierID WHERE OrderDate >= DATEADD(month, -1, GETDATE()) GROUP BY SupplierName ORDER BY AvgDeliveryTime ASC;", "generated_sql": "SELECT s.SupplierName, AVG(o.DeliveryTime) AS AvgDeliveryTime\nFROM Orders o\nJOIN Products p ON o.ProductID = p.ProductID\nJOIN Suppliers s ON p.SupplierID = s.SupplierID\nWHERE o.OrderDate >= CURRENT_DATE - INTERVAL '1 month'\nGROUP BY s.SupplierID, s.SupplierName\nORDER BY AvgDeliveryTime ASC\nLIMIT 1;", "raw_model_output": "<think>\n\n</think>\n\nSELECT s.SupplierName, AVG(o.DeliveryTime) AS AvgDeliveryTime\nFROM Orders o\nJOIN Products p ON o.ProductID = p.ProductID\nJOIN Suppliers s ON p.SupplierID = s.SupplierID\nWHERE o.OrderDate >= CURRENT_DATE - INTERVAL '1 month'\nGROUP BY s.SupplierID, s.SupplierName\nORDER BY AvgDeliveryTime ASC\nLIMIT 1;", "latency_sec": 1.3097031116485596, "total_duration_sec": 1.296524225, "load_duration_sec": 0.019479049, "tokens_prompt": 232, "prompt_eval_sec": 0.021847049, "tokens_completion": 88, "completion_eval_sec": 1.252792922, "tokens_total": 320, "tokens_per_sec": 244.33018227864414, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Generated SQL includes a LIMIT 1 clause which restricts the result to a single row, while the Reference SQL does not. Second, the Generated SQL groups by both SupplierID and SupplierName (though SupplierName is functionally dependent on SupplierID in this schema). The most critical difference is the LIMIT 1, which makes the Generated SQL return only one row while the Reference SQL returns all suppliers sorted by average delivery time."}
{"example_id": 267, "sql_complexity": "subqueries", "prompt": "What is the total number of disability support programs offered in urban and rural areas, and the percentage of total programs for each area type?", "context": "CREATE TABLE programs (program_id INT, program_name VARCHAR(255), area_type VARCHAR(255));", "reference_sql": "SELECT area_type, COUNT(*) as total_programs, ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM programs) , 2) as percentage_of_total FROM programs WHERE area_type IN ('urban', 'rural') GROUP BY area_type;", "generated_sql": "SELECT \n    area_type,\n    COUNT(*) AS total_programs,\n    (COUNT(*) * 100.0 / SUM(COUNT(*)) OVER ()) AS percentage_of_total\nFROM \n    programs\nGROUP BY \n    area_type;", "raw_model_output": "<think>\n\n</think>\n\nSELECT \n    area_type,\n    COUNT(*) AS total_programs,\n    (COUNT(*) * 100.0 / SUM(COUNT(*)) OVER ()) AS percentage_of_total\nFROM \n    programs\nGROUP BY \n    area_type;", "latency_sec": 0.9334897994995117, "total_duration_sec": 0.792376221, "load_duration_sec": 0.014222215, "tokens_prompt": 123, "prompt_eval_sec": 0.013704056, "tokens_completion": 55, "completion_eval_sec": 0.761786478, "tokens_total": 178, "tokens_per_sec": 190.68231928772468, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL includes a WHERE clause filtering area_type to ('urban', 'rural'), while the Generated SQL does not apply this filter. This means the Generated SQL may include other area_type values not present in the Reference SQL, leading to different results. Additionally, the percentage calculation method differs (subquery vs window function), but the core discrepancy is the missing filter in the Generated SQL."}
{"example_id": 3028, "sql_complexity": "basic SQL", "prompt": "What is the number of startups founded by non-binary individuals in the technology industry?", "context": "CREATE TABLE company (id INT, name TEXT, founder_gender TEXT, industry TEXT); INSERT INTO company (id, name, founder_gender, industry) VALUES (1, 'CodeForAll', 'Non-binary', 'Technology'); INSERT INTO company (id, name, founder_gender, industry) VALUES (2, 'TechVillage', 'Male', 'Technology');", "reference_sql": "SELECT COUNT(*) FROM company WHERE founder_gender = 'Non-binary' AND industry = 'Technology';", "generated_sql": "SELECT COUNT(*) \nFROM company \nWHERE founder_gender = 'Non-binary' AND industry = 'Technology';", "raw_model_output": "<think>\n\n</think>\n\nSELECT COUNT(*) \nFROM company \nWHERE founder_gender = 'Non-binary' AND industry = 'Technology';", "latency_sec": 0.6592319011688232, "total_duration_sec": 0.406622069, "load_duration_sec": 0.018548352, "tokens_prompt": 162, "prompt_eval_sec": 0.01679152, "tokens_completion": 26, "completion_eval_sec": 0.368356705, "tokens_total": 188, "tokens_per_sec": 285.18037380574964, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries have identical structure, conditions, and logic. The Generated SQL is a formatted version of the Reference SQL with no semantic differences. They both count companies where founder_gender = 'Non-binary' and industry = 'Technology'."}
{"example_id": 3282, "sql_complexity": "aggregation", "prompt": "Which marine species have been observed in both the Arctic and Antarctic oceans?", "context": "CREATE TABLE marine_species (id INT, species_name VARCHAR(50), common_name VARCHAR(50), region VARCHAR(20));INSERT INTO marine_species (id, species_name, common_name, region) VALUES (1, 'Orcinus_orca', 'Killer Whale', 'Arctic');INSERT INTO marine_species (id, species_name, common_name, region) VALUES (2, 'Balaenoptera_bonaerensis', 'Antarctic Minke Whale', 'Antarctic');", "reference_sql": "SELECT species_name FROM marine_species WHERE region IN ('Arctic', 'Antarctic') GROUP BY species_name HAVING COUNT(DISTINCT region) = 2;", "generated_sql": "SELECT DISTINCT ms1.common_name\nFROM marine_species ms1\nJOIN marine_species ms2 ON ms1.species_name = ms2.species_name\nWHERE ms1.region = 'Arctic' AND ms2.region = 'Antarctic';", "raw_model_output": "<think>\n\n</think>\n\nSELECT DISTINCT ms1.common_name\nFROM marine_species ms1\nJOIN marine_species ms2 ON ms1.species_name = ms2.species_name\nWHERE ms1.region = 'Arctic' AND ms2.region = 'Antarctic';", "latency_sec": 0.7876238822937012, "total_duration_sec": 0.781782888, "load_duration_sec": 0.01545057, "tokens_prompt": 192, "prompt_eval_sec": 0.018807608, "tokens_completion": 53, "completion_eval_sec": 0.745295991, "tokens_total": 245, "tokens_per_sec": 311.0621776558074, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the selected columns (species_name vs. common_name) and their output structures. The Reference SQL returns species names present in both regions, while the Generated SQL returns common names for species with entries in both regions. Even if the underlying data values coincidentally matched, the column differences make them non-equivalent."}
{"example_id": 3474, "sql_complexity": "subqueries", "prompt": "What is the total transaction volume for the top 3 digital assets by market capitalization in the 'developed_markets' schema?", "context": "CREATE SCHEMA developed_markets; CREATE TABLE developed_markets.digital_assets (asset_name VARCHAR(10), market_cap BIGINT, daily_transaction_volume BIGINT); INSERT INTO developed_markets.digital_assets (asset_name, market_cap, daily_transaction_volume) VALUES ('AssetG', 30000000, 15000000), ('AssetH', 25000000, 12000000), ('AssetI', 20000000, 10000000), ('AssetJ', 15000000, 8000000), ('AssetK', 10000000, 6000000);", "reference_sql": "SELECT SUM(daily_transaction_volume) FROM (SELECT daily_transaction_volume FROM developed_markets.digital_assets ORDER BY market_cap DESC FETCH NEXT 3 ROWS ONLY) t;", "generated_sql": "SELECT SUM(daily_transaction_volume) AS total_transaction_volume\nFROM (\n  SELECT asset_name, daily_transaction_volume\n  FROM developed_markets.digital_assets\n  ORDER BY market_cap DESC\n  LIMIT 3\n) AS top_assets;", "raw_model_output": "<think>\n\n</think>\n\nSELECT SUM(daily_transaction_volume) AS total_transaction_volume\nFROM (\n  SELECT asset_name, daily_transaction_volume\n  FROM developed_markets.digital_assets\n  ORDER BY market_cap DESC\n  LIMIT 3\n) AS top_assets;", "latency_sec": 0.8368875980377197, "total_duration_sec": 0.823175094, "load_duration_sec": 0.016497864, "tokens_prompt": 269, "prompt_eval_sec": 0.030054671, "tokens_completion": 53, "completion_eval_sec": 0.773192068, "tokens_total": 322, "tokens_per_sec": 384.75895777999926, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of daily_transaction_volume for the top 3 assets by market_cap descending. The Reference SQL uses FETCH NEXT 3 ROWS ONLY while the Generated SQL uses LIMIT 3, which are functionally equivalent in this context. The Generated SQL includes asset_name in the subquery but it doesn't affect the SUM calculation of daily_transaction_volume. The ordering and row limitation logic is identical."}
{"example_id": 1626, "sql_complexity": "aggregation", "prompt": "Find the total value of social impact bonds issued by each organization.", "context": "CREATE TABLE social_impact_bonds (id INT, organization_name VARCHAR(255), issue_year INT, value FLOAT); INSERT INTO social_impact_bonds (id, organization_name, issue_year, value) VALUES (1, 'Acme Corp', 2018, 2000000), (2, 'XYZ Foundation', 2019, 3000000), (3, 'Global Giving', 2018, 1500000), (4, 'Acme Corp', 2019, 2500000), (5, 'XYZ Foundation', 2018, 1000000);", "reference_sql": "SELECT organization_name, SUM(value) as total_value FROM social_impact_bonds GROUP BY organization_name;", "generated_sql": "SELECT organization_name, SUM(value) AS total_value\nFROM social_impact_bonds\nGROUP BY organization_name;", "raw_model_output": "<think>\n\n</think>\n\nSELECT organization_name, SUM(value) AS total_value\nFROM social_impact_bonds\nGROUP BY organization_name;", "latency_sec": 0.5035169124603271, "total_duration_sec": 0.45300023, "load_duration_sec": 0.014277806, "tokens_prompt": 242, "prompt_eval_sec": 0.025395601, "tokens_completion": 28, "completion_eval_sec": 0.410223932, "tokens_total": 270, "tokens_per_sec": 536.2282642716071, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select organization_name and the sum of value grouped by organization_name. The only differences are whitespace and formatting, which do not affect semantic equivalence."}
{"example_id": 1315, "sql_complexity": "single join", "prompt": "List all the transactions made by clients living in New York with a transaction amount greater than $1000.", "context": "CREATE TABLE transactions (id INT, client_id INT, transaction_amount DECIMAL(10,2), transaction_date DATE); INSERT INTO transactions (id, client_id, transaction_amount, transaction_date) VALUES (1, 3, 1500.00, '2022-01-01'), (2, 4, 800.00, '2022-01-02'), (3, 3, 1200.00, '2022-01-03'); CREATE TABLE clients (id INT, name VARCHAR(255), state VARCHAR(255)); INSERT INTO clients (id, name, state) VALUES (3, 'Mike Johnson', 'New York'), (4, 'Sara Lee', 'California');", "reference_sql": "SELECT transactions.id, transactions.client_id, transactions.transaction_amount, transactions.transaction_date FROM transactions INNER JOIN clients ON transactions.client_id = clients.id WHERE clients.state = 'New York' AND transactions.transaction_amount > 1000.00;", "generated_sql": "SELECT t.id, t.client_id, t.transaction_amount, t.transaction_date\nFROM transactions t\nJOIN clients c ON t.client_id = c.id\nWHERE c.state = 'New York' AND t.transaction_amount > 1000;", "raw_model_output": "<think>\n\n</think>\n\nSELECT t.id, t.client_id, t.transaction_amount, t.transaction_date\nFROM transactions t\nJOIN clients c ON t.client_id = c.id\nWHERE c.state = 'New York' AND t.transaction_amount > 1000;", "latency_sec": 0.8774228096008301, "total_duration_sec": 0.833001193, "load_duration_sec": 0.01480016, "tokens_prompt": 270, "prompt_eval_sec": 0.026279786, "tokens_completion": 55, "completion_eval_sec": 0.789291522, "tokens_total": 325, "tokens_per_sec": 370.40295333540934, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between transactions and clients on client_id, filter for clients in 'New York' and transactions over 1000. The generated query uses table aliases (t/c) and omits INNER keyword (equivalent to INNER JOIN), but the semantic logic remains identical. Column aliases and decimal literal formatting (1000.00 vs 1000) don't affect results."}
{"example_id": 520, "sql_complexity": "multiple_joins", "prompt": "What is the total number of electric vehicles sold in 'California' in the 'sales' schema?", "context": "CREATE TABLE sales_regions (id INT, name VARCHAR(50));   CREATE TABLE sales (id INT, region_id INT, vehicle_count INT);   CREATE TABLE vehicles (id INT, type VARCHAR(50));   INSERT INTO sales_regions VALUES (1, 'California');   INSERT INTO sales VALUES (1, 1, 5000);   INSERT INTO vehicles VALUES (1, 'electric');", "reference_sql": "SELECT SUM(sales.vehicle_count) FROM sales INNER JOIN sales_regions ON sales.region_id = sales_regions.id INNER JOIN vehicles ON sales.id = vehicles.id WHERE vehicles.type = 'electric' AND sales_regions.name = 'California';", "generated_sql": "SELECT SUM(s.vehicle_count) AS total_electric_vehicles_sold\nFROM sales s\nJOIN sales_regions sr ON s.region_id = sr.id\nJOIN vehicles v ON s.id = v.id\nWHERE sr.name = 'California'\nAND v.type = 'electric';", "raw_model_output": "<think>\n\n</think>\n\nSELECT SUM(s.vehicle_count) AS total_electric_vehicles_sold\nFROM sales s\nJOIN sales_regions sr ON s.region_id = sr.id\nJOIN vehicles v ON s.id = v.id\nWHERE sr.name = 'California'\nAND v.type = 'electric';", "latency_sec": 0.8678829669952393, "total_duration_sec": 0.861059475, "load_duration_sec": 0.014499568, "tokens_prompt": 176, "prompt_eval_sec": 0.016410728, "tokens_completion": 59, "completion_eval_sec": 0.827792874, "tokens_total": 235, "tokens_per_sec": 270.7738358013991, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of vehicle_count from the sales table joined with sales_regions and vehicles. They use equivalent JOIN conditions (sales.region_id = sales_regions.id and sales.id = vehicles.id), same WHERE filters (region name 'California' and vehicle type 'electric'), and identical aggregate function. The differences are only in table aliases (sales vs s, sales_regions vs sr, vehicles vs v) and a column alias in the generated query, which do not affect semantic equivalence."}
{"example_id": 3999, "sql_complexity": "single join", "prompt": "What is the total number of tickets sold for performances with a rating of 5?", "context": "CREATE TABLE performance (id INT PRIMARY KEY, name VARCHAR(255), date DATE, artist_id INT, rating INT); INSERT INTO performance (id, name, date, artist_id, rating) VALUES (1, 'Dance Recital', '2022-03-01', 1, 5);", "reference_sql": "SELECT SUM(t.quantity) as total_tickets_sold FROM performance p INNER JOIN ticket t ON p.id = t.performance_id WHERE p.rating = 5;", "generated_sql": "SELECT COUNT(*) AS total_tickets_sold\nFROM performance\nWHERE rating = 5;", "raw_model_output": "<think>\n\n</think>\n\nSELECT COUNT(*) AS total_tickets_sold\nFROM performance\nWHERE rating = 5;", "latency_sec": 0.4595682621002197, "total_duration_sec": 0.350222726, "load_duration_sec": 0.017870517, "tokens_prompt": 158, "prompt_eval_sec": 0.015897198, "tokens_completion": 22, "completion_eval_sec": 0.314288764, "tokens_total": 180, "tokens_per_sec": 391.67195571209123, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the total tickets sold (sum of quantity) for performances with a rating of 5 by joining with the ticket table. The Generated SQL counts the number of performances with a rating of 5 without considering ticket data. They differ in both the calculation (SUM vs COUNT) and the tables involved (ticket table missing in Generated SQL)."}
{"example_id": 2261, "sql_complexity": "multiple_joins", "prompt": "What is the total number of animals that have been released into 'protected' habitats, and the average weight of those animals?", "context": "CREATE TABLE habitats (habitat_id INT, habitat_name VARCHAR(50), habitat_status VARCHAR(50)); INSERT INTO habitats (habitat_id, habitat_name, habitat_status) VALUES (1, 'Habitat A', 'protected'), (2, 'Habitat B', 'unprotected'); CREATE TABLE animal_habitats (animal_id INT, habitat_id INT, animal_weight FLOAT); INSERT INTO animal_habitats (animal_id, habitat_id, animal_weight) VALUES (101, 1, 25.5), (102, 2, 15.2); CREATE TABLE animals (animal_id INT, animal_name VARCHAR(50)); INSERT INTO animals (animal_id, animal_name) VALUES (101, 'Dog'), (102, 'Cat');", "reference_sql": "SELECT COUNT(*), AVG(animal_habitats.animal_weight) FROM animal_habitats INNER JOIN animals ON animal_habitats.animal_id = animals.animal_id INNER JOIN habitats ON animal_habitats.habitat_id = habitats.habitat_id WHERE habitats.habitat_status = 'protected';", "generated_sql": "SELECT \n    COUNT(animal_habitats.animal_id) AS total_animals_released,\n    AVG(animal_habitats.animal_weight) AS average_weight\nFROM \n    animal_habitats\nJOIN \n    habitats ON animal_habitats.habitat_id = habitats.habitat_id\nWHERE \n    habitats.habitat_status = 'protected';", "raw_model_output": "<think>\n\n</think>\n\nSELECT \n    COUNT(animal_habitats.animal_id) AS total_animals_released,\n    AVG(animal_habitats.animal_weight) AS average_weight\nFROM \n    animal_habitats\nJOIN \n    habitats ON animal_habitats.habitat_id = habitats.habitat_id\nWHERE \n    habitats.habitat_status = 'protected';", "latency_sec": 1.3177599906921387, "total_duration_sec": 1.198262594, "load_duration_sec": 0.01826057, "tokens_prompt": 266, "prompt_eval_sec": 0.028241182, "tokens_completion": 80, "completion_eval_sec": 1.14849696, "tokens_total": 346, "tokens_per_sec": 262.5667818448998, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the count of animal_habitats entries and the average animal weight in 'protected' habitats. The Reference SQL includes an unnecessary join with the animals table, but since no columns from animals are used in the select or where clause, it doesn't affect the result. The Generated SQL omits this redundant join but produces the same output because the habitat_status filter and aggregation are identical."}
{"example_id": 3439, "sql_complexity": "multiple_joins", "prompt": "How many menu items contain ingredients sourced from local suppliers for each restaurant?", "context": "CREATE TABLE restaurants (id INT, name VARCHAR(50), location VARCHAR(50)); INSERT INTO restaurants VALUES (1, 'Restaurant A', 'City A'); INSERT INTO restaurants VALUES (2, 'Restaurant B', 'City B'); CREATE TABLE menu_items (id INT, name VARCHAR(50), restaurant_id INT, price DECIMAL(5,2)); INSERT INTO menu_items VALUES (1, 'Item A', 1, 10.99); INSERT INTO menu_items VALUES (2, 'Item B', 1, 12.99); INSERT INTO menu_items VALUES (3, 'Item C', 2, 11.99); CREATE TABLE ingredients (id INT, name VARCHAR(50), local_source BOOLEAN, menu_item_id INT); INSERT INTO ingredients VALUES (1, 'Ingredient A', TRUE, 1); INSERT INTO ingredients VALUES (2, 'Ingredient B', FALSE, 1); INSERT INTO ingredients VALUES (3, 'Ingredient C', TRUE, 2); INSERT INTO ingredients VALUES (4, 'Ingredient D', FALSE, 2); INSERT INTO ingredients VALUES (5, 'Ingredient E', TRUE, 3);", "reference_sql": "SELECT r.name, COUNT(DISTINCT mi.id) as num_local_items FROM restaurants r JOIN menu_items mi ON r.id = mi.restaurant_id JOIN ingredients i ON mi.id = i.menu_item_id WHERE i.local_source = TRUE GROUP BY r.name;", "generated_sql": "SELECT \n    r.id AS restaurant_id, \n    r.name AS restaurant_name, \n    COUNT(DISTINCT mi.id) AS local_ingredient_menu_items\nFROM \n    restaurants r\nJOIN \n    menu_items mi ON r.id = mi.restaurant_id\nJOIN \n    ingredients i ON mi.id = i.menu_item_id\nWHERE \n    i.local_source = TRUE\nGROUP BY \n    r.id, r.name;", "raw_model_output": "<think>\n\n</think>\n\nSELECT \n    r.id AS restaurant_id, \n    r.name AS restaurant_name, \n    COUNT(DISTINCT mi.id) AS local_ingredient_menu_items\nFROM \n    restaurants r\nJOIN \n    menu_items mi ON r.id = mi.restaurant_id\nJOIN \n    ingredients i ON mi.id = i.menu_item_id\nWHERE \n    i.local_source = TRUE\nGROUP BY \n    r.id, r.name;", "latency_sec": 1.4441030025482178, "total_duration_sec": 1.380409939, "load_duration_sec": 0.013910786, "tokens_prompt": 329, "prompt_eval_sec": 0.03450697, "tokens_completion": 91, "completion_eval_sec": 1.329320914, "tokens_total": 420, "tokens_per_sec": 290.8379798801619, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in selected columns and grouping. The Reference SQL groups by r.name, while the Generated SQL groups by r.id and r.name. Additionally, the Generated SQL includes restaurant_id in the output, which the Reference does not. These differences in structure and grouping may lead to different results if there are restaurants with the same name."}
{"example_id": 2265, "sql_complexity": "aggregation", "prompt": "Hourly revenue for a specific movie?", "context": "CREATE TABLE Movie_Revenue (id INT, movie_title VARCHAR(100), revenue_time TIME, revenue DECIMAL(10,2));", "reference_sql": "SELECT revenue_time, SUM(revenue) FROM Movie_Revenue WHERE movie_title = 'Spider-Man: No Way Home' GROUP BY revenue_time;", "generated_sql": "SELECT revenue_time, SUM(revenue) AS hourly_revenue\nFROM Movie_Revenue\nGROUP BY revenue_time;", "raw_model_output": "<think>\n\n</think>\n\nSELECT revenue_time, SUM(revenue) AS hourly_revenue\nFROM Movie_Revenue\nGROUP BY revenue_time;", "latency_sec": 0.4469451904296875, "total_duration_sec": 0.413526102, "load_duration_sec": 0.013572361, "tokens_prompt": 110, "prompt_eval_sec": 0.011600935, "tokens_completion": 28, "completion_eval_sec": 0.386416185, "tokens_total": 138, "tokens_per_sec": 308.7626916117579, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters results for a specific movie ('Spider-Man: No Way Home') while the Generated SQL aggregates revenue for all movies without any filter. The WHERE clause in the Reference SQL ensures only data for a specific movie is considered, making the queries non-equivalent."}
{"example_id": 1763, "sql_complexity": "multiple_joins", "prompt": "What is the total food and beverage revenue last month for hotels in 'Bangkok'?", "context": "CREATE TABLE revenue (hotel_id INT, revenue_source VARCHAR(50), revenue INT, revenue_date DATE); INSERT INTO revenue (hotel_id, revenue_source, revenue, revenue_date) VALUES (5, 'Room revenue', 12000, '2022-03-01'), (5, 'Food and beverage', 4000, '2022-03-02'), (5, 'Other revenue', 1000, '2022-03-03'); CREATE TABLE hotels (hotel_id INT, city VARCHAR(50)); INSERT INTO hotels (hotel_id, city) VALUES (5, 'Bangkok'); CREATE TABLE dates (date DATE); INSERT INTO dates (date) VALUES ('2022-03-01'), ('2022-03-02'), ('2022-03-03');", "reference_sql": "SELECT SUM(revenue) FROM revenue JOIN hotels ON revenue.hotel_id = hotels.hotel_id JOIN dates ON revenue.revenue_date = dates.date WHERE hotels.city = 'Bangkok' AND revenue_source = 'Food and beverage' AND dates.date >= DATEADD(month, -1, GETDATE());", "generated_sql": "SELECT SUM(revenue) AS total_food_and_beverage_revenue\nFROM revenue\nJOIN hotels ON revenue.hotel_id = hotels.hotel_id\nWHERE hotels.city = 'Bangkok'\nAND revenue_date BETWEEN '2022-02-01' AND '2022-02-28';", "raw_model_output": "<think>\n\n</think>\n\nSELECT SUM(revenue) AS total_food_and_beverage_revenue\nFROM revenue\nJOIN hotels ON revenue.hotel_id = hotels.hotel_id\nWHERE hotels.city = 'Bangkok'\nAND revenue_date BETWEEN '2022-02-01' AND '2022-02-28';", "latency_sec": 1.2121000289916992, "total_duration_sec": 1.120110051, "load_duration_sec": 0.029820889, "tokens_prompt": 286, "prompt_eval_sec": 0.030331483, "tokens_completion": 73, "completion_eval_sec": 1.056545224, "tokens_total": 359, "tokens_per_sec": 296.1801760689988, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL uses a dynamic date condition (dates.date >= DATEADD(month, -1, GETDATE())) which depends on the current date, while the Generated SQL uses a fixed date range ('2022-02-01' to '2022-02-28'). Additionally, the Reference SQL joins with the dates table, but the Generated SQL omits this join. In the provided example data, the dates table contains March 2022 dates, so the Reference SQL's dynamic condition would include these dates (if current date is March 2022), while the Generated SQL's fixed range would not. This results in different filtering and potentially different results."}
{"example_id": 5499, "sql_complexity": "set operations", "prompt": "How many legal aid clinics and community mediation centers are there in total, and what is the sum of cases handled by each type of center, for centers located in the state of California?", "context": "CREATE TABLE LegalAidClinics (ClinicName text, State text, NumCases int); INSERT INTO LegalAidClinics VALUES ('Clinic1', 'CA', 30, '2022-01-01'), ('Clinic2', 'CA', 25, '2022-01-01'); CREATE TABLE CommunityMediationCenters (CenterName text, State text, NumCases int); INSERT INTO CommunityMediationCenters VALUES ('CM1', 'CA', 22, '2022-01-01'), ('CM2', 'CA', 28, '2022-01-01');", "reference_sql": "SELECT State, 'Legal Aid Clinics' AS CenterType, COUNT(*) AS NumCenters, SUM(NumCases) AS TotalCases FROM LegalAidClinics WHERE State = 'CA' UNION ALL SELECT State, 'Community Mediation Centers', COUNT(*), SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA';", "generated_sql": "SELECT \n    COUNT(DISTINCT LegalAidClinics.ClinicName) AS LegalAidClinicCount,\n    COUNT(DISTINCT CommunityMediationCenters.CenterName) AS CommunityMediationCenterCount,\n    SUM(LegalAidClinics.NumCases) AS TotalLegalAidCases,\n    SUM(CommunityMediationCenters.NumCases) AS TotalCommunityMediationCases\nFROM \n    LegalAidClinics\nFULL OUTER JOIN \n    CommunityMediationCenters\nON \n    LegalAidClinics.State = CommunityMediationCenters.State\nWHERE \n    LegalAidClinics.State = 'CA'\n    OR CommunityMediationCenters.State = 'CA';", "raw_model_output": "<think>\n\n</think>\n\nSELECT \n    COUNT(DISTINCT LegalAidClinics.ClinicName) AS LegalAidClinicCount,\n    COUNT(DISTINCT CommunityMediationCenters.CenterName) AS CommunityMediationCenterCount,\n    SUM(LegalAidClinics.NumCases) AS TotalLegalAidCases,\n    SUM(CommunityMediationCenters.NumCases) AS TotalCommunityMediationCases\nFROM \n    LegalAidClinics\nFULL OUTER JOIN \n    CommunityMediationCenters\nON \n    LegalAidClinics.State = CommunityMediationCenters.State\nWHERE \n    LegalAidClinics.State = 'CA'\n    OR CommunityMediationCenters.State = 'CA';", "latency_sec": 2.2129158973693848, "total_duration_sec": 2.16352224, "load_duration_sec": 0.0168146, "tokens_prompt": 258, "prompt_eval_sec": 0.027739745, "tokens_completion": 148, "completion_eval_sec": 2.116294397, "tokens_total": 406, "tokens_per_sec": 183.46833717568506, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two rows (one for each center type) with aggregated metrics per State, while the Generated SQL returns a single row with combined counts and sums across both tables. The Generated SQL's FULL OUTER JOIN and WHERE clause also introduce different data combination logic, leading to structurally different results."}
{"example_id": 2408, "sql_complexity": "aggregation", "prompt": "What is the average number of victories for players from Japan and South Korea, partitioned by game mode?", "context": "CREATE TABLE PlayerVictories (PlayerID INT, GameMode VARCHAR(255), Victories INT, Country VARCHAR(255)); INSERT INTO PlayerVictories (PlayerID, GameMode, Victories, Country) VALUES (1, 'Battle Royale', 25, 'Japan'), (2, 'Team Deathmatch', 18, 'South Korea');", "reference_sql": "SELECT GameMode, AVG(Victories) as AvgVictories FROM PlayerVictories WHERE Country IN ('Japan', 'South Korea') GROUP BY GameMode, Country WITH ROLLUP;", "generated_sql": "SELECT GameMode, AVG(Victories) AS AverageVictories\nFROM PlayerVictories\nWHERE Country IN ('Japan', 'South Korea')\nGROUP BY GameMode;", "raw_model_output": "<think>\n\n</think>\n\nSELECT GameMode, AVG(Victories) AS AverageVictories\nFROM PlayerVictories\nWHERE Country IN ('Japan', 'South Korea')\nGROUP BY GameMode;", "latency_sec": 0.6057400703430176, "total_duration_sec": 0.583214168, "load_duration_sec": 0.016077182, "tokens_prompt": 170, "prompt_eval_sec": 0.016907593, "tokens_completion": 39, "completion_eval_sec": 0.547561616, "tokens_total": 209, "tokens_per_sec": 345.0324821365174, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in grouping and aggregation. The Reference SQL groups by both GameMode and Country with ROLLUP, producing subtotals for each country-game mode combination and a grand total. The Generated SQL only groups by GameMode, averaging Victories across all countries. The ROLLUP adds summary rows not present in the Generated SQL, and the grouping criteria differ, leading to different result structures and values."}
{"example_id": 2729, "sql_complexity": "subqueries", "prompt": "Find the total number of trips made by shared autonomous vehicles in Seattle", "context": "CREATE TABLE shared_vehicles (id INT, vehicle_type VARCHAR(20), is_autonomous BOOLEAN, trip_count INT); INSERT INTO shared_vehicles (id, vehicle_type, is_autonomous, trip_count) VALUES (1, 'ebike', false, 1200), (2, 'escooter', false, 800), (3, 'car', true, 1500); CREATE TABLE city_data (city VARCHAR(20), has_autonomous_vehicles BOOLEAN); INSERT INTO city_data (city, has_autonomous_vehicles) VALUES ('Seattle', true), ('Denver', false), ('Portland', true);", "reference_sql": "SELECT SUM(trip_count) FROM shared_vehicles WHERE is_autonomous = true AND vehicle_type != 'ebike' AND vehicle_type != 'escooter' AND city IN (SELECT city FROM city_data WHERE has_autonomous_vehicles = true AND city = 'Seattle');", "generated_sql": "SELECT SUM(sv.trip_count) AS total_trips\nFROM shared_vehicles sv\nJOIN city_data cd ON sv.is_autonomous = cd.has_autonomous_vehicles\nWHERE cd.city = 'Seattle';", "raw_model_output": "<think>\n\n</think>\n\nSELECT SUM(sv.trip_count) AS total_trips\nFROM shared_vehicles sv\nJOIN city_data cd ON sv.is_autonomous = cd.has_autonomous_vehicles\nWHERE cd.city = 'Seattle';", "latency_sec": 0.8000380992889404, "total_duration_sec": 0.694320667, "load_duration_sec": 0.014052821, "tokens_prompt": 220, "prompt_eval_sec": 0.020579889, "tokens_completion": 46, "completion_eval_sec": 0.657311437, "tokens_total": 266, "tokens_per_sec": 332.48416573712683, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes explicit filters for vehicle_type (excluding 'ebike' and 'escooter') and uses a subquery to validate the city condition, while the Generated SQL uses a JOIN condition that implicitly links is_autonomous with city_data's has_autonomous_vehicles. The Generated SQL lacks the vehicle_type restrictions, leading to potential inclusion of different vehicle types. Additionally, the JOIN logic in the Generated SQL may not strictly replicate the subquery's city validation, making them non-equivalent."}
{"example_id": 2952, "sql_complexity": "aggregation", "prompt": "Show the total budget allocated for each program category in 2023.", "context": "CREATE TABLE Budget (id INT, category TEXT, year INT, allocated_amount INT); INSERT INTO Budget (id, category, year, allocated_amount) VALUES (1, 'Education', 2023, 30000); INSERT INTO Budget (id, category, year, allocated_amount) VALUES (2, 'Healthcare', 2023, 50000);", "reference_sql": "SELECT category, SUM(allocated_amount) FROM Budget WHERE year = 2023 GROUP BY category;", "generated_sql": "SELECT category, SUM(allocated_amount) AS total_budget\nFROM Budget\nWHERE year = 2023\nGROUP BY category;", "raw_model_output": "<think>\n\n</think>\n\nSELECT category, SUM(allocated_amount) AS total_budget\nFROM Budget\nWHERE year = 2023\nGROUP BY category;", "latency_sec": 0.5882458686828613, "total_duration_sec": 0.509548131, "load_duration_sec": 0.025616287, "tokens_prompt": 172, "prompt_eval_sec": 0.01535132, "tokens_completion": 33, "completion_eval_sec": 0.466049204, "tokens_total": 205, "tokens_per_sec": 348.4937352114594, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (category and summed allocated_amount) from the Budget table where year is 2023, grouped by category. The only difference is the alias 'total_budget' in the generated query, which doesn't affect the semantic meaning of the result."}
{"example_id": 4328, "sql_complexity": "aggregation", "prompt": "What is the average cargo handling time in hours for each port?", "context": "CREATE TABLE cargo_handling (id INT, port_id INT, time_in_hours DECIMAL(5,2)); INSERT INTO cargo_handling (id, port_id, time_in_hours) VALUES (1, 1, 20.5), (2, 1, 22.3), (3, 2, 18.7);", "reference_sql": "SELECT port_id, AVG(time_in_hours) FROM cargo_handling GROUP BY port_id;", "generated_sql": "SELECT port_id, AVG(time_in_hours) AS average_time\nFROM cargo_handling\nGROUP BY port_id;", "raw_model_output": "<think>\n\n</think>\n\nSELECT port_id, AVG(time_in_hours) AS average_time\nFROM cargo_handling\nGROUP BY port_id;", "latency_sec": 0.41892027854919434, "total_duration_sec": 0.412769493, "load_duration_sec": 0.02089133, "tokens_prompt": 158, "prompt_eval_sec": 0.013376113, "tokens_completion": 27, "completion_eval_sec": 0.376530953, "tokens_total": 185, "tokens_per_sec": 441.61146994528985, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries group by port_id and calculate the average time_in_hours. The generated query adds an alias (average_time) for the calculated column, but this does not affect the semantic result set content. The grouping and aggregation logic are identical."}
{"example_id": 4915, "sql_complexity": "window functions", "prompt": "Calculate the percentage of total Europium production for each country.", "context": "CREATE TABLE europium_production (country VARCHAR(50), quantity INT);", "reference_sql": "SELECT country, quantity * 100.0 / SUM(quantity) OVER (PARTITION BY NULL) AS percentage FROM europium_production;", "generated_sql": "SELECT \n    country, \n    (CAST(quantity AS FLOAT) / SUM(quantity) OVER () * 100) AS percentage_of_total\nFROM \n    europium_production;", "raw_model_output": "<think>\n\n</think>\n\nSELECT \n    country, \n    (CAST(quantity AS FLOAT) / SUM(quantity) OVER () * 100) AS percentage_of_total\nFROM \n    europium_production;", "latency_sec": 0.9039342403411865, "total_duration_sec": 0.599700283, "load_duration_sec": 0.013896461, "tokens_prompt": 99, "prompt_eval_sec": 0.009580715, "tokens_completion": 42, "completion_eval_sec": 0.574332819, "tokens_total": 141, "tokens_per_sec": 155.98479812732847, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the percentage of each country's production relative to the total. The Reference SQL uses `quantity * 100.0 / SUM(...)`, while the Generated SQL uses `CAST(quantity AS FLOAT) / SUM(...) * 100`. Mathematically, these are equivalent due to commutative properties of multiplication/division. Both use the same window function `SUM(quantity) OVER ()` (equivalent to `PARTITION BY NULL`). The only differences are syntax (order of operations, explicit cast vs. 100.0) and column alias, which do not affect the result."}
{"example_id": 5030, "sql_complexity": "subqueries", "prompt": "What is the success rate of diverse-led startups (at least 1 female or underrepresented racial or ethnic group executive) in the past 3 years?", "context": "CREATE TABLE DiverseStartups(id INT, name TEXT, country TEXT, year INT, success BOOLEAN);   INSERT INTO DiverseStartups VALUES (1, 'FemTech', 'USA', 2020, true), (2, 'GreenCity', 'Canada', 2019, false), (3, 'AI-Health', 'UK', 2021, true), (4, 'SolarEnergy', 'USA', 2020, false), (5, 'DataAnalytics', 'Germany', 2019, true), (6, 'SmartGrid', 'USA', 2021, true), (7, 'CloudServices', 'India', 2020, false), (8, 'RenewableEnergy', 'USA', 2019, true);", "reference_sql": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3) AS success_rate FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3 AND success = true;", "generated_sql": "SELECT \n  COUNT(CASE WHEN success THEN 1 END) * 100.0 / COUNT(*) AS success_rate\nFROM \n  DiverseStartups\nWHERE \n  year >= EXTRACT(YEAR FROM CURRENT_DATE) - 3;", "raw_model_output": "<think>\n\n</think>\n\nSELECT \n  COUNT(CASE WHEN success THEN 1 END) * 100.0 / COUNT(*) AS success_rate\nFROM \n  DiverseStartups\nWHERE \n  year >= EXTRACT(YEAR FROM CURRENT_DATE) - 3;", "latency_sec": 1.0824401378631592, "total_duration_sec": 0.877103343, "load_duration_sec": 0.020611403, "tokens_prompt": 280, "prompt_eval_sec": 0.028746376, "tokens_completion": 57, "completion_eval_sec": 0.825400334, "tokens_total": 337, "tokens_per_sec": 311.3336139449433, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the success rate of startups in the last 3 years. The Reference SQL uses a subquery to get the total count and explicitly filters the success=true condition. The Generated SQL achieves the same by using COUNT(CASE WHEN success THEN 1 END) for the numerator and COUNT(*) for the denominator, with the same WHERE clause. The result is the same ratio of successful startups to total startups in the filtered timeframe."}
{"example_id": 4626, "sql_complexity": "aggregation", "prompt": "What was the maximum number of training hours for farmers in each country in 2020?", "context": "CREATE TABLE training (id INT, country_id INT, farmer_id INT, hours INT, date DATE);", "reference_sql": "SELECT country_id, MAX(hours) FROM training WHERE YEAR(date) = 2020 GROUP BY country_id;", "generated_sql": "SELECT country_id, MAX(hours) AS max_hours\nFROM training\nWHERE YEAR(date) = 2020\nGROUP BY country_id;", "raw_model_output": "<think>\n\n</think>\n\nSELECT country_id, MAX(hours) AS max_hours\nFROM training\nWHERE YEAR(date) = 2020\nGROUP BY country_id;", "latency_sec": 0.5594139099121094, "total_duration_sec": 0.511622218, "load_duration_sec": 0.015059304, "tokens_prompt": 113, "prompt_eval_sec": 0.012664035, "tokens_completion": 35, "completion_eval_sec": 0.481480312, "tokens_total": 148, "tokens_per_sec": 264.5626027126365, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. The generated query adds an explicit alias (AS max_hours) for the MAX(hours) column, but this does not affect the result set's data. Both queries select the same columns, apply the same filter (YEAR(date) = 2020), and group by country_id, producing identical output values."}
{"example_id": 2703, "sql_complexity": "set operations", "prompt": "Identify the species unique to 'MarineResearchAreaA' and 'MarineResearchAreaB'", "context": "CREATE TABLE ResearchAreaSpecies (area VARCHAR(255), species VARCHAR(255)); INSERT INTO ResearchAreaSpecies (area, species) VALUES ('MarineResearchAreaA', 'Coral'), ('MarineResearchAreaA', 'Starfish'), ('MarineResearchAreaB', 'Jellyfish');", "reference_sql": "(SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB') UNION (SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA');", "generated_sql": "SELECT species\nFROM ResearchAreaSpecies\nWHERE area IN ('MarineResearchAreaA', 'MarineResearchAreaB')\nGROUP BY species\nHAVING COUNT(DISTINCT area) = 1;", "raw_model_output": "<think>\n\n</think>\n\nSELECT species\nFROM ResearchAreaSpecies\nWHERE area IN ('MarineResearchAreaA', 'MarineResearchAreaB')\nGROUP BY species\nHAVING COUNT(DISTINCT area) = 1;", "latency_sec": 0.8158988952636719, "total_duration_sec": 0.688160672, "load_duration_sec": 0.024895356, "tokens_prompt": 158, "prompt_eval_sec": 0.015147194, "tokens_completion": 46, "completion_eval_sec": 0.645615946, "tokens_total": 204, "tokens_per_sec": 250.03097955424226, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve species that are present in exactly one of the two research areas. The Reference SQL uses EXCEPT and UNION to compute the symmetric difference between the two areas, while the Generated SQL uses GROUP BY and HAVING to find species appearing in only one area. The sample data confirms they produce identical results."}
{"example_id": 200, "sql_complexity": "window functions", "prompt": "List the top three categories of workforce development programs with the highest budget increases.", "context": "CREATE TABLE programs (program_id INT, program_name VARCHAR(50), budget DECIMAL(10, 2), category VARCHAR(50), budget_date DATE);", "reference_sql": "SELECT category, SUM(budget - LAG(budget) OVER (PARTITION BY category ORDER BY budget_date)) as total_budget_increase FROM programs GROUP BY category ORDER BY total_budget_increase DESC LIMIT 3;", "generated_sql": "SELECT category, SUM(budget) AS total_budget\nFROM programs\nGROUP BY category\nORDER BY total_budget DESC\nLIMIT 3;", "raw_model_output": "<think>\n\n</think>\n\nSELECT category, SUM(budget) AS total_budget\nFROM programs\nGROUP BY category\nORDER BY total_budget DESC\nLIMIT 3;", "latency_sec": 0.5734689235687256, "total_duration_sec": 0.484620393, "load_duration_sec": 0.013573184, "tokens_prompt": 122, "prompt_eval_sec": 0.01118587, "tokens_completion": 33, "completion_eval_sec": 0.457891726, "tokens_total": 155, "tokens_per_sec": 270.28491628705405, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates the total budget increase per category by subtracting the previous budget (using LAG) from the current budget and summing these differences. The generated query simply sums all budgets per category. The first computes a cumulative difference between consecutive budgets, while the second computes total budget amounts. Their results will differ fundamentally."}
{"example_id": 5131, "sql_complexity": "basic SQL", "prompt": "How many wells were drilled in the Eagle Ford Shale and Bakken Formation?", "context": "CREATE TABLE wells (id INT, region VARCHAR(255), well_type VARCHAR(255), num_drilled INT); INSERT INTO wells (id, region, well_type, num_drilled) VALUES (1, 'Eagle Ford Shale', 'Oil', 2000), (2, 'Eagle Ford Shale', 'Gas', 1500), (3, 'Bakken Formation', 'Oil', 1000), (4, 'Bakken Formation', 'Gas', 1200);", "reference_sql": "SELECT SUM(num_drilled) as total_wells FROM wells WHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "generated_sql": "SELECT SUM(num_drilled) FROM wells WHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "raw_model_output": "<think>\n\n</think>\n\nSELECT SUM(num_drilled) FROM wells WHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "latency_sec": 0.48187994956970215, "total_duration_sec": 0.474077835, "load_duration_sec": 0.017895406, "tokens_prompt": 205, "prompt_eval_sec": 0.028913225, "tokens_completion": 29, "completion_eval_sec": 0.424607143, "tokens_total": 234, "tokens_per_sec": 485.5981250287584, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of num_drilled for wells in the specified regions. The only difference is the column alias (total_wells) in the reference query, which doesn't affect the semantic result since the SUM calculation and WHERE conditions are identical."}
{"example_id": 1160, "sql_complexity": "subqueries", "prompt": "What is the total revenue generated from ads on Instagram in March 2021, for users in the 'brand' category who have posted more than 10 times?", "context": "CREATE TABLE ads (ad_id INT, user_id INT, platform VARCHAR(255), ad_revenue DECIMAL(10,2), post_count INT); INSERT INTO ads (ad_id, user_id, platform, ad_revenue, post_count) VALUES (1, 1, 'Instagram', 150.50, 12), (2, 2, 'Twitter', 80.00, 15), (3, 3, 'Instagram', 120.75, 8);", "reference_sql": "SELECT SUM(ad_revenue) FROM ads WHERE platform = 'Instagram' AND MONTH(ad_date) = 3 AND YEAR(ad_date) = 2021 AND user_id IN (SELECT user_id FROM users WHERE category = 'brand' AND post_count > 10);", "generated_sql": "SELECT SUM(ad_revenue) AS total_revenue\nFROM ads\nWHERE platform = 'Instagram'\n  AND user_id IN (SELECT user_id FROM users WHERE category = 'brand')\n  AND post_count > 10;", "raw_model_output": "<think>\n\n</think>\n\nSELECT SUM(ad_revenue) AS total_revenue\nFROM ads\nWHERE platform = 'Instagram'\n  AND user_id IN (SELECT user_id FROM users WHERE category = 'brand')\n  AND post_count > 10;", "latency_sec": 0.8659088611602783, "total_duration_sec": 0.770181179, "load_duration_sec": 0.014491251, "tokens_prompt": 223, "prompt_eval_sec": 0.022510956, "tokens_completion": 51, "completion_eval_sec": 0.731057972, "tokens_total": 274, "tokens_per_sec": 316.43053015169806, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL includes conditions on ad_date (MONTH and YEAR) which are not present in the Generated SQL. Additionally, the Reference SQL applies post_count > 10 in the subquery (users table), while the Generated SQL applies it in the main query (ads table). The ad_date column also does not exist in the ads table according to the provided schema, making the Reference SQL invalid."}
{"example_id": 4708, "sql_complexity": "subqueries", "prompt": "What is the maximum number of high-level threats reported by a single agency in a month?", "context": "CREATE TABLE Threat_Intelligence (Threat_ID INT, Threat_Type VARCHAR(50), Threat_Level VARCHAR(50), Reported_Date DATE, Reporting_Agency VARCHAR(50)); CREATE VIEW High_Level_Threats AS SELECT Threat_Type, Threat_Level, Reported_Date FROM Threat_Intelligence WHERE Threat_Level = 'High';", "reference_sql": "SELECT Reporting_Agency, MAX(Number_of_High_Level_Threats) as Max_High_Level_Threats_in_a_Month FROM (SELECT Reporting_Agency, TO_CHAR(Reported_Date, 'YYYY-MM') as Month, COUNT(*) as Number_of_High_Level_Threats FROM High_Level_Threats GROUP BY Reporting_Agency, Month) GROUP BY Reporting_Agency;", "generated_sql": "SELECT COUNT(*) AS Max_High_Level_Threats\nFROM (\n    SELECT Reporting_Agency, \n           EXTRACT(MONTH FROM Reported_Date) AS Report_Month,\n           COUNT(*) AS Threats_Per_Agency_Month\n    FROM Threat_Intelligence\n    WHERE Threat_Level = 'High'\n    GROUP BY Reporting_Agency, EXTRACT(MONTH FROM Reported_Date)\n) AS Subquery\nORDER BY Threats_Per_Agency_Month DESC\nLIMIT 1;", "raw_model_output": "<think>\n\n</think>\n\nSELECT COUNT(*) AS Max_High_Level_Threats\nFROM (\n    SELECT Reporting_Agency, \n           EXTRACT(MONTH FROM Reported_Date) AS Report_Month,\n           COUNT(*) AS Threats_Per_Agency_Month\n    FROM Threat_Intelligence\n    WHERE Threat_Level = 'High'\n    GROUP BY Reporting_Agency, EXTRACT(MONTH FROM Reported_Date)\n) AS Subquery\nORDER BY Threats_Per_Agency_Month DESC\nLIMIT 1;", "latency_sec": 1.604248046875, "total_duration_sec": 1.477143419, "load_duration_sec": 0.013566426, "tokens_prompt": 156, "prompt_eval_sec": 0.015831684, "tokens_completion": 104, "completion_eval_sec": 1.444936778, "tokens_total": 260, "tokens_per_sec": 162.06970019783898, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the maximum number of high-level threats per agency across months, returning one row per agency with their highest monthly count. The Generated SQL finds the single highest threat count across all agencies and months, returning only one row. Additionally, the Generated SQL uses EXTRACT(MONTH) which ignores the year, while the Reference SQL uses TO_CHAR(Reported_Date, 'YYYY-MM') which includes the year, leading to different grouping behavior."}
{"example_id": 5608, "sql_complexity": "set operations", "prompt": "List the suppliers that provide materials for both product A and product C.", "context": "CREATE TABLE products (product_id INT, product_name TEXT); CREATE TABLE materials (material_id INT, material_name TEXT, product_id INT, supplier_id INT); INSERT INTO products (product_id, product_name) VALUES (1, 'Product A'), (2, 'Product B'), (3, 'Product C'); INSERT INTO materials (material_id, material_name, product_id, supplier_id) VALUES (1, 'Material 1', 1, 101), (2, 'Material 2', 1, 102), (3, 'Material 3', 2, 103), (4, 'Material 4', 3, 101), (5, 'Material 5', 3, 102);", "reference_sql": "SELECT supplier_id FROM materials WHERE product_id = 1 INTERSECT SELECT supplier_id FROM materials WHERE product_id = 3;", "generated_sql": "SELECT DISTINCT m1.supplier_id\nFROM materials m1\nJOIN products p1 ON m1.product_id = p1.product_id\nJOIN materials m2 ON m2.product_id = 3\nWHERE p1.product_name = 'Product A'\nAND m1.supplier_id = m2.supplier_id;", "raw_model_output": "<think>\n\n</think>\n\nSELECT DISTINCT m1.supplier_id\nFROM materials m1\nJOIN products p1 ON m1.product_id = p1.product_id\nJOIN materials m2 ON m2.product_id = 3\nWHERE p1.product_name = 'Product A'\nAND m1.supplier_id = m2.supplier_id;", "latency_sec": 1.068814992904663, "total_duration_sec": 1.039054683, "load_duration_sec": 0.024135678, "tokens_prompt": 247, "prompt_eval_sec": 0.023339584, "tokens_completion": 69, "completion_eval_sec": 0.989415195, "tokens_total": 316, "tokens_per_sec": 295.6545352542475, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve supplier_ids that are common between product_id=1 and product_id=3. The Reference uses INTERSECT to find common supplier_ids directly from materials, while the Generated uses a JOIN between materials for product 1 (via products table) and materials for product 3, filtering on matching supplier_ids. Both approaches yield the same distinct supplier_ids (101 and 102) from the sample data."}
{"example_id": 1506, "sql_complexity": "basic SQL", "prompt": "How many habitats are in the 'animal_habitats' table?", "context": "CREATE TABLE animal_habitats (id INT PRIMARY KEY, habitat_name VARCHAR, num_animals INT);", "reference_sql": "SELECT COUNT(*) FROM animal_habitats;", "generated_sql": "SELECT COUNT(*) FROM animal_habitats;", "raw_model_output": "<think>\n\n</think>\n\nSELECT COUNT(*) FROM animal_habitats;", "latency_sec": 0.24307918548583984, "total_duration_sec": 0.23162136, "load_duration_sec": 0.023160847, "tokens_prompt": 107, "prompt_eval_sec": 0.010122433, "tokens_completion": 14, "completion_eval_sec": 0.196281878, "tokens_total": 121, "tokens_per_sec": 497.7801770980866, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical: they select the count of all rows from the 'animal_habitats' table using COUNT(*). The structure, table name, and aggregation function are exactly the same in both queries."}
{"example_id": 3117, "sql_complexity": "aggregation", "prompt": "What is the percentage of the population that has access to clean water in each continent?", "context": "CREATE TABLE water_data (id INT, country VARCHAR(50), continent CHAR(2), access_to_clean_water BOOLEAN); INSERT INTO water_data VALUES (1, 'Canada', 'NA', true), (2, 'Mexico', 'NA', false), (3, 'Brazil', 'SA', true), (4, 'Russia', 'EU', true);", "reference_sql": "SELECT continent, COUNT(*) FILTER (WHERE access_to_clean_water) * 100.0 / COUNT(*) AS percentage FROM water_data GROUP BY continent;", "generated_sql": "SELECT \n    continent, \n    ROUND(COUNT(CASE WHEN access_to_clean_water THEN 1 END) * 100.0 / COUNT(*), 2) AS percentage_with_access\nFROM \n    water_data\nGROUP BY \n    continent;", "raw_model_output": "<think>\n\n</think>\n\nSELECT \n    continent, \n    ROUND(COUNT(CASE WHEN access_to_clean_water THEN 1 END) * 100.0 / COUNT(*), 2) AS percentage_with_access\nFROM \n    water_data\nGROUP BY \n    continent;", "latency_sec": 0.870758056640625, "total_duration_sec": 0.837295024, "load_duration_sec": 0.014790361, "tokens_prompt": 163, "prompt_eval_sec": 0.016396736, "tokens_completion": 58, "completion_eval_sec": 0.803960706, "tokens_total": 221, "tokens_per_sec": 253.8018434794799, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the use of the ROUND function in the Generated SQL, which rounds the percentage to two decimal places, while the Reference SQL calculates the exact percentage without rounding. This would result in different numerical outputs (e.g., 50.0 vs 50.00) even though the underlying calculation logic is similar."}
{"example_id": 3542, "sql_complexity": "window functions", "prompt": "What is the average yield of crops for each country, ranked by average yield?", "context": "CREATE TABLE farming (id INT, name TEXT, country TEXT, crop TEXT, yield INT); INSERT INTO farming VALUES (1, 'Smith Farm', 'USA', 'Corn', 120), (2, 'Brown Farm', 'Canada', 'Soybeans', 45), (3, 'Jones Farm', 'Mexico', 'Wheat', 80);", "reference_sql": "SELECT country, AVG(yield) as avg_yield, ROW_NUMBER() OVER (ORDER BY AVG(yield) DESC) as rank FROM farming GROUP BY country;", "generated_sql": "SELECT country, AVG(yield) AS average_yield\nFROM farming\nGROUP BY country\nORDER BY average_yield DESC;", "raw_model_output": "<think>\n\n</think>\n\nSELECT country, AVG(yield) AS average_yield\nFROM farming\nGROUP BY country\nORDER BY average_yield DESC;", "latency_sec": 0.7955608367919922, "total_duration_sec": 0.442127479, "load_duration_sec": 0.013954921, "tokens_prompt": 166, "prompt_eval_sec": 0.017408379, "tokens_completion": 29, "completion_eval_sec": 0.408591216, "tokens_total": 195, "tokens_per_sec": 245.1101046983599, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a ROW_NUMBER() column that ranks countries by average yield, while the Generated SQL only orders results by average yield without adding a rank column. The result sets differ in structure (3 columns vs 2 columns) and content (includes ranking vs. ordered list)."}
{"example_id": 2274, "sql_complexity": "subqueries", "prompt": "Add a new crop 'amaranth' to farm 'Nourishing Harvest' with yield 50 in 2023", "context": "CREATE TABLE farms (id INT, name TEXT, location TEXT, size FLOAT); INSERT INTO farms (id, name, location, size) VALUES (1, 'Nourishing Harvest', 'Mexico', 120.0); CREATE TABLE crops (id INT, farm_id INT, crop TEXT, yield INT, year INT);", "reference_sql": "INSERT INTO crops (id, farm_id, crop, yield, year) VALUES (5, (SELECT id FROM farms WHERE name = 'Nourishing Harvest'), 'amaranth', 50, 2023);", "generated_sql": "INSERT INTO crops (id, farm_id, crop, yield, year) VALUES (1, (SELECT id FROM farms WHERE name = 'Nourishing Harvest'), 'amaranth', 50, 2023);", "raw_model_output": "<think>\n\n</think>\n\nINSERT INTO crops (id, farm_id, crop, yield, year) VALUES (1, (SELECT id FROM farms WHERE name = 'Nourishing Harvest'), 'amaranth', 50, 2023);", "latency_sec": 0.9534811973571777, "total_duration_sec": 0.770343077, "load_duration_sec": 0.024000109, "tokens_prompt": 168, "prompt_eval_sec": 0.015257259, "tokens_completion": 52, "completion_eval_sec": 0.728993232, "tokens_total": 220, "tokens_per_sec": 230.73344352231328, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the 'id' value being inserted (5 vs 1). While both use the same subquery to get farm_id, the explicit id values are different, leading to distinct inserted rows. Semantic equivalence requires identical output, which these queries do not produce."}
{"example_id": 3705, "sql_complexity": "subqueries", "prompt": "What is the percentage of unions with collective bargaining agreements in the Midwest region?", "context": "CREATE TABLE collective_bargaining (bargaining_id INT, union_name VARCHAR(50), contract_start_date DATE, contract_end_date DATE, region VARCHAR(50));CREATE VIEW union_region AS SELECT DISTINCT union_name, region FROM collective_bargaining;", "reference_sql": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM union_region) as percentage FROM union_region ur WHERE ur.region = 'Midwest' AND EXISTS (SELECT 1 FROM collective_bargaining cb WHERE cb.union_name = ur.union_name);", "generated_sql": "SELECT \n  ROUND(COUNT(DISTINCT union_name) * 100.0 / (SELECT COUNT(DISTINCT union_name) FROM collective_bargaining), 2) AS percentage\nFROM union_region\nWHERE region = 'Midwest';", "raw_model_output": "<think>\n\n</think>\n\nSELECT \n  ROUND(COUNT(DISTINCT union_name) * 100.0 / (SELECT COUNT(DISTINCT union_name) FROM collective_bargaining), 2) AS percentage\nFROM union_region\nWHERE region = 'Midwest';", "latency_sec": 0.8868420124053955, "total_duration_sec": 0.820957134, "load_duration_sec": 0.013482519, "tokens_prompt": 140, "prompt_eval_sec": 0.014873073, "tokens_completion": 57, "completion_eval_sec": 0.79020726, "tokens_total": 197, "tokens_per_sec": 222.1365217753654, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their denominator calculations and handling of distinct values. The reference query uses COUNT(*) on union_region (total (union, region) pairs) while the generated query uses COUNT(DISTINCT union_name) from collective_bargaining (total unique unions). Additionally, the generated query includes ROUND which the reference does not. These differences in aggregation logic and denominator definitions make the results non-equivalent."}
{"example_id": 240, "sql_complexity": "aggregation", "prompt": "What is the average capacity of renewable energy projects for each country?", "context": "CREATE TABLE projects (name TEXT, type TEXT, capacity INTEGER, country TEXT); INSERT INTO projects (name, type, capacity, country) VALUES ('Project 1', 'Wind', 100, 'USA'), ('Project 2', 'Solar', 200, 'Germany'), ('Project 3', 'Wind', 300, 'France');", "reference_sql": "SELECT country, AVG(capacity) FROM projects GROUP BY country", "generated_sql": "SELECT country, AVG(capacity) AS average_capacity\nFROM projects\nWHERE type IN ('Wind', 'Solar')\nGROUP BY country;", "raw_model_output": "<think>\n\n</think>\n\nSELECT country, AVG(capacity) AS average_capacity\nFROM projects\nWHERE type IN ('Wind', 'Solar')\nGROUP BY country;", "latency_sec": 0.6111171245574951, "total_duration_sec": 0.488022118, "load_duration_sec": 0.01407044, "tokens_prompt": 162, "prompt_eval_sec": 0.016317784, "tokens_completion": 32, "completion_eval_sec": 0.455515413, "tokens_total": 194, "tokens_per_sec": 317.4514216738302, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "In the provided dataset, all projects are either 'Wind' or 'Solar', so the WHERE clause in the Generated SQL does not exclude any rows. Both queries calculate the average capacity per country using the same grouping, resulting in identical outputs."}
{"example_id": 2132, "sql_complexity": "set operations", "prompt": "What is the average caseload per attorney in community legal clinics in California, and how does it compare to the state average?", "context": "CREATE TABLE cali_community_legal_clinics(id INT, attorney_count INT, cases_handled INT, state VARCHAR(255));", "reference_sql": "SELECT state, AVG(cases_handled/attorney_count) AS avg_caseload FROM cali_community_legal_clinics WHERE state = 'California' GROUP BY state UNION ALL SELECT 'California', AVG(cases_handled/attorney_count) FROM cali_community_legal_clinics WHERE state = 'California';", "generated_sql": "SELECT \n    AVG(cases_handled / attorney_count) AS clinic_avg_caseload_per_attorney,\n    (SELECT AVG(cases_handled / attorney_count) FROM cali_community_legal_clinics) AS state_avg_caseload_per_attorney\nFROM cali_community_legal_clinics;", "raw_model_output": "<think>\n\n</think>\n\nSELECT \n    AVG(cases_handled / attorney_count) AS clinic_avg_caseload_per_attorney,\n    (SELECT AVG(cases_handled / attorney_count) FROM cali_community_legal_clinics) AS state_avg_caseload_per_attorney\nFROM cali_community_legal_clinics;", "latency_sec": 0.9617009162902832, "total_duration_sec": 0.952847115, "load_duration_sec": 0.014009286, "tokens_prompt": 125, "prompt_eval_sec": 0.012153208, "tokens_completion": 67, "completion_eval_sec": 0.924691985, "tokens_total": 192, "tokens_per_sec": 199.64626917548455, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two rows with the same average caseload for California, while the Generated SQL returns a single row with two columns containing the same average value. The structure and output format differ significantly, making them non-equivalent."}
{"example_id": 3276, "sql_complexity": "basic SQL", "prompt": "What is the total energy consumption of the Chemical Plant B in the last quarter?", "context": "CREATE TABLE EnergyConsumption (EnergyID INT, Plant VARCHAR(255), EnergyQuantity DECIMAL(5,2), Timestamp DATETIME);", "reference_sql": "SELECT SUM(EnergyQuantity) FROM EnergyConsumption WHERE Plant = 'Chemical Plant B' AND Timestamp BETWEEN DATE_SUB(CURRENT_DATE(), INTERVAL 3 MONTH) AND CURRENT_DATE();", "generated_sql": "SELECT SUM(EnergyQuantity) AS TotalEnergyConsumption\nFROM EnergyConsumption\nWHERE Plant = 'Chemical Plant B'\nAND Timestamp >= DATEADD(QUARTER, -1, GETDATE())\nAND Timestamp < GETDATE();", "raw_model_output": "<think>\n\n</think>\n\nSELECT SUM(EnergyQuantity) AS TotalEnergyConsumption\nFROM EnergyConsumption\nWHERE Plant = 'Chemical Plant B'\nAND Timestamp >= DATEADD(QUARTER, -1, GETDATE())\nAND Timestamp < GETDATE();", "latency_sec": 0.7793090343475342, "total_duration_sec": 0.767298793, "load_duration_sec": 0.021133805, "tokens_prompt": 118, "prompt_eval_sec": 0.011559728, "tokens_completion": 53, "completion_eval_sec": 0.731778288, "tokens_total": 171, "tokens_per_sec": 219.42514774407488, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in date handling. The reference uses CURRENT_DATE() (date-only) with BETWEEN, while the generated uses GETDATE() (datetime) with >= and <. This causes discrepancies: 1) DATE_SUB(CURRENT_DATE(), 3 MONTH) vs DATEADD(QUARTER, -1, GETDATE()) creates different start ranges when time components exist. 2) BETWEEN includes both endpoints, while the generated query excludes the end time (GETDATE()). These differences in date boundaries make the queries non-equivalent."}
{"example_id": 3074, "sql_complexity": "multiple_joins", "prompt": "Find the top 5 players with the highest scores in the 'historical_tournaments' view, including their scores and the names of the tournaments they participated in.", "context": "CREATE VIEW historical_tournaments AS SELECT tournaments.tournament_name, players.player_name, players.score FROM tournaments JOIN players_scores ON tournaments.tournament_id = players_scores.tournament_id JOIN players ON players_scores.player_id = players.player_id;  CREATE TABLE tournaments (tournament_id INT, tournament_name TEXT);  CREATE TABLE players_scores (player_id INT, tournament_id INT, score INT);  CREATE TABLE players (player_id INT, player_name TEXT);", "reference_sql": "SELECT players.player_name, MAX(players_scores.score) as high_score, tournaments.tournament_name FROM historical_tournaments JOIN players ON historical_tournaments.player_id = players.player_id JOIN players_scores ON historical_tournaments.player_id = players_scores.player_id JOIN tournaments ON players_scores.tournament_id = tournaments.tournament_id GROUP BY players.player_id, tournaments.tournament_name ORDER BY high_score DESC LIMIT 5;", "generated_sql": "SELECT DISTINCT players.player_name, players_scores.score, tournaments.tournament_name\nFROM historical_tournaments\nORDER BY players_scores.score DESC\nLIMIT 5;", "raw_model_output": "<think>\n\n</think>\n\nSELECT DISTINCT players.player_name, players_scores.score, tournaments.tournament_name\nFROM historical_tournaments\nORDER BY players_scores.score DESC\nLIMIT 5;", "latency_sec": 0.6596989631652832, "total_duration_sec": 0.574235125, "load_duration_sec": 0.033328207, "tokens_prompt": 194, "prompt_eval_sec": 0.020639762, "tokens_completion": 36, "completion_eval_sec": 0.517686186, "tokens_total": 230, "tokens_per_sec": 348.6438706776852, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates the maximum score per player per tournament using GROUP BY and aggregates scores, while the Generated SQL simply selects top 5 scores without aggregation or grouping. The Generated SQL lacks the MAX() aggregation, GROUP BY clauses, and proper joins to ensure per-player-per-tournament score tracking. Additionally, the Generated SQL uses DISTINCT which doesn't address the fundamental differences in logic."}
{"example_id": 2219, "sql_complexity": "window functions", "prompt": "What is the average population of cities with a UNESCO World Heritage designation, ordered by designation date?", "context": "CREATE TABLE cities (name VARCHAR(255), population INT, designation_date DATE); INSERT INTO cities (name, population, designation_date) VALUES ('Paris', 2141000, '1991-09-16'); INSERT INTO cities (name, population, designation_date) VALUES ('Rio de Janeiro', 6727000, '2012-07-01');", "reference_sql": "SELECT AVG(population) FROM (SELECT population, ROW_NUMBER() OVER (ORDER BY designation_date) rn FROM cities WHERE name IN (SELECT name FROM heritagesites)) t WHERE rn % 2 = 1;", "generated_sql": "SELECT AVG(population) AS average_population\nFROM cities\nORDER BY designation_date;", "raw_model_output": "<think>\n\n</think>\n\nSELECT AVG(population) AS average_population\nFROM cities\nORDER BY designation_date;", "latency_sec": 0.3658158779144287, "total_duration_sec": 0.35816764, "load_duration_sec": 0.016829078, "tokens_prompt": 183, "prompt_eval_sec": 0.019313145, "tokens_completion": 22, "completion_eval_sec": 0.319996753, "tokens_total": 205, "tokens_per_sec": 560.3912032707159, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the average of populations from cities in heritagesites, ordered by designation_date, and only includes odd-numbered rows (using ROW_NUMBER()). The Generated SQL simply computes the average population of all cities without any filtering or row-numbering. The Reference SQL involves a subquery with a conditional filter and row-numbering logic, while the Generated SQL lacks these elements entirely. Additionally, the Generated SQL's ORDER BY clause has no effect on the final average calculation."}
{"example_id": 3786, "sql_complexity": "aggregation", "prompt": "Display the names and average co-owner percentages for all properties in the 'property_coownership' table where the co-owner percentage is greater than 60.", "context": "CREATE TABLE property_coownership (property_id INT, owner VARCHAR(255), percentage INT); INSERT INTO property_coownership (property_id, owner, percentage) VALUES (1, 'Mohammed', 70), (1, 'Fatima', 30), (2, 'Jamal', 65), (2, 'Aisha', 35), (3, 'Ali', 75), (3, 'Khadija', 25);", "reference_sql": "SELECT owner, AVG(percentage) FROM property_coownership WHERE percentage > 60 GROUP BY owner;", "generated_sql": "SELECT owner, AVG(percentage) AS average_percentage\nFROM property_coownership\nWHERE percentage > 60\nGROUP BY owner;", "raw_model_output": "<think>\n\n</think>\n\nSELECT owner, AVG(percentage) AS average_percentage\nFROM property_coownership\nWHERE percentage > 60\nGROUP BY owner;", "latency_sec": 0.7630982398986816, "total_duration_sec": 0.510988148, "load_duration_sec": 0.021453786, "tokens_prompt": 203, "prompt_eval_sec": 0.02668465, "tokens_completion": 32, "completion_eval_sec": 0.460149574, "tokens_total": 235, "tokens_per_sec": 307.9551068433882, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. The only difference is that the Generated SQL adds an alias 'average_percentage' to the AVG(percentage) column. Both queries select the same data, apply the same filter (percentage > 60), and group by the same column (owner). The result set's content remains identical, with the same values in the same order, even though the column name differs."}
{"example_id": 2357, "sql_complexity": "basic SQL", "prompt": "What is the total amount of climate finance invested in renewable energy projects by public and private sectors in Africa?", "context": "CREATE TABLE renewable_energy_projects (project_id INT, sector TEXT, investor_type TEXT, region TEXT, amount FLOAT); INSERT INTO renewable_energy_projects (project_id, sector, investor_type, region, amount) VALUES (1, 'Renewable Energy', 'Public', 'Africa', 5000000); INSERT INTO renewable_energy_projects (project_id, sector, investor_type, region, amount) VALUES (2, 'Renewable Energy', 'Private', 'Africa', 7000000);", "reference_sql": "SELECT SUM(amount) FROM renewable_energy_projects WHERE sector = 'Renewable Energy' AND region = 'Africa';", "generated_sql": "SELECT SUM(amount) AS total_climate_finance\nFROM renewable_energy_projects\nWHERE sector = 'Renewable Energy' AND region = 'Africa';", "raw_model_output": "<think>\n\n</think>\n\nSELECT SUM(amount) AS total_climate_finance\nFROM renewable_energy_projects\nWHERE sector = 'Renewable Energy' AND region = 'Africa';", "latency_sec": 0.6114790439605713, "total_duration_sec": 0.558437991, "load_duration_sec": 0.013987604, "tokens_prompt": 202, "prompt_eval_sec": 0.020753281, "tokens_completion": 36, "completion_eval_sec": 0.521526599, "tokens_total": 238, "tokens_per_sec": 389.2202068912544, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of 'amount' for projects in the 'Renewable Energy' sector and 'Africa' region. The generated query adds an alias 'total_climate_finance' to the sum, but this does not affect the semantic result - the numerical value returned remains the same. The alias only changes the column name in the output, not the underlying data or calculation."}
{"example_id": 1009, "sql_complexity": "multiple_joins", "prompt": "Find the number of IoT sensors installed in each farm that use Sprinkler irrigation.", "context": "CREATE TABLE IoT_Sensors (id INT, sensor_type VARCHAR(50), Farm_id INT); INSERT INTO IoT_Sensors (id, sensor_type, Farm_id) VALUES (1, 'Soil Moisture', 1), (2, 'Temperature', 1), (3, 'Humidity', 2); CREATE TABLE Irrigation (id INT, Farm_id INT, irrigation_type VARCHAR(50), duration INT); INSERT INTO Irrigation (id, Farm_id, irrigation_type, duration) VALUES (1, 1, 'Sprinkler', 30), (2, 2, 'Drip', 45);", "reference_sql": "SELECT f.id, COUNT(s.id) FROM Farmers f JOIN Irrigation i ON f.id = i.Farm_id JOIN IoT_Sensors s ON f.id = s.Farm_id WHERE i.irrigation_type = 'Sprinkler' GROUP BY f.id;", "generated_sql": "SELECT Farm_id, COUNT(*) AS sensor_count\nFROM IoT_Sensors\nWHERE Farm_id IN (\n    SELECT Farm_id\n    FROM Irrigation\n    WHERE irrigation_type = 'Sprinkler'\n)\nGROUP BY Farm_id;", "raw_model_output": "<think>\n\n</think>\n\nSELECT Farm_id, COUNT(*) AS sensor_count\nFROM IoT_Sensors\nWHERE Farm_id IN (\n    SELECT Farm_id\n    FROM Irrigation\n    WHERE irrigation_type = 'Sprinkler'\n)\nGROUP BY Farm_id;", "latency_sec": 0.8969616889953613, "total_duration_sec": 0.771129701, "load_duration_sec": 0.014591087, "tokens_prompt": 222, "prompt_eval_sec": 0.021093196, "tokens_completion": 51, "completion_eval_sec": 0.733268958, "tokens_total": 273, "tokens_per_sec": 304.36082538349285, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL may produce inflated counts due to joining Irrigation and IoT_Sensors tables, which could multiply sensor counts if a farm has multiple Sprinkler entries. The Generated SQL correctly counts sensors per farm once, as it filters Farm_ids with Sprinkler irrigation first and then counts sensors directly. This leads to different results when a farm has multiple Sprinkler entries."}
{"example_id": 4217, "sql_complexity": "subqueries", "prompt": "Show consumer preference data for foundations, excluding products from the USA.", "context": "CREATE TABLE cosmetics (product_id INT, product_name VARCHAR(100), product_type VARCHAR(50), is_cruelty_free BOOLEAN, consumer_preference_score INT); INSERT INTO cosmetics (product_id, product_name, product_type, is_cruelty_free, consumer_preference_score) VALUES (1, 'Lipstick A', 'Lipstick', TRUE, 80), (2, 'Foundation B', 'Foundation', FALSE, 90), (3, 'Mascara C', 'Mascara', TRUE, 85), (4, 'Eyeshadow D', 'Eyeshadow', TRUE, 70), (5, 'Blush E', 'Blush', FALSE, 95); CREATE TABLE ingredient_sourcing (ingredient_id INT, ingredient_name VARCHAR(100), sourcing_country VARCHAR(50), is_organic BOOLEAN); INSERT INTO ingredient_sourcing (ingredient_id, ingredient_name, sourcing_country, is_organic) VALUES (1, 'Rosehip Oil', 'Chile', TRUE), (2, 'Shea Butter', 'Ghana', TRUE), (3, 'Jojoba Oil', 'India', TRUE), (4, 'Coconut Oil', 'Philippines', FALSE), (5, 'Aloe Vera', 'USA', TRUE);", "reference_sql": "SELECT * FROM cosmetics WHERE product_type = 'Foundation' AND product_id NOT IN (SELECT cosmetics.product_id FROM cosmetics INNER JOIN ingredient_sourcing ON cosmetics.product_id = ingredient_sourcing.ingredient_id WHERE ingredient_sourcing.sourcing_country = 'USA');", "generated_sql": "SELECT consumer_preference_score\nFROM cosmetics\nWHERE product_type = 'Foundation' AND sourcing_country != 'USA';", "raw_model_output": "<think>\n\n</think>\n\nSELECT consumer_preference_score\nFROM cosmetics\nWHERE product_type = 'Foundation' AND sourcing_country != 'USA';", "latency_sec": 0.6200602054595947, "total_duration_sec": 0.479758304, "load_duration_sec": 0.014251553, "tokens_prompt": 359, "prompt_eval_sec": 0.036282865, "tokens_completion": 27, "completion_eval_sec": 0.427016527, "tokens_total": 386, "tokens_per_sec": 622.5201949767007, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL correctly joins cosmetics with ingredient_sourcing to exclude Foundation products linked to USA-sourced ingredients. The Generated SQL incorrectly references a non-existent 'sourcing_country' column in the cosmetics table and lacks the necessary join, leading to a syntax error and different logic."}
{"example_id": 5620, "sql_complexity": "basic SQL", "prompt": "What is the recycling rate of plastic in the residential sector in the state of New York?", "context": "CREATE TABLE recycling_rates_city (sector VARCHAR(20), city VARCHAR(20), material VARCHAR(20), recycling_rate DECIMAL(5,2)); INSERT INTO recycling_rates_city (sector, city, material, recycling_rate) VALUES ('residential', 'New York City', 'plastic', 0.25), ('commercial', 'New York City', 'plastic', 0.30), ('residential', 'New York City', 'paper', 0.45), ('commercial', 'New York City', 'paper', 0.50), ('residential', 'Los Angeles', 'plastic', 0.20), ('commercial', 'Los Angeles', 'plastic', 0.35), ('residential', 'Los Angeles', 'paper', 0.40), ('commercial', 'Los Angeles', 'paper', 0.50);", "reference_sql": "SELECT recycling_rate FROM recycling_rates_city WHERE sector = 'residential' AND material = 'plastic' AND city = 'New York City';", "generated_sql": "SELECT recycling_rate\nFROM recycling_rates_city\nWHERE sector = 'residential'\n  AND material = 'plastic'\n  AND city = 'New York City';", "raw_model_output": "<think>\n\n</think>\n\nSELECT recycling_rate\nFROM recycling_rates_city\nWHERE sector = 'residential'\n  AND material = 'plastic'\n  AND city = 'New York City';", "latency_sec": 0.6366548538208008, "total_duration_sec": 0.614940193, "load_duration_sec": 0.024826496, "tokens_prompt": 279, "prompt_eval_sec": 0.026043685, "tokens_completion": 38, "completion_eval_sec": 0.561897465, "tokens_total": 317, "tokens_per_sec": 497.9149975808179, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the same column (recycling_rate) from the same table (recycling_rates_city) with identical WHERE conditions (sector = 'residential', material = 'plastic', city = 'New York City'). The only difference is formatting (whitespace/indentation), which does not affect semantic meaning in SQL."}
{"example_id": 3151, "sql_complexity": "basic SQL", "prompt": "List all biotech startups that received funding in 2022 and their respective funding amounts.", "context": "CREATE TABLE biotech_startups (name TEXT, funding FLOAT, date DATE); INSERT INTO biotech_startups (name, funding, date) VALUES ('StartupA', 3500000, '2022-02-28'); INSERT INTO biotech_startups (name, funding, date) VALUES ('StartupB', 4500000, '2022-07-12');", "reference_sql": "SELECT name, funding FROM biotech_startups WHERE date BETWEEN '2022-01-01' AND '2022-12-31';", "generated_sql": "SELECT name, funding\nFROM biotech_startups\nWHERE date BETWEEN '2022-01-01' AND '2022-12-31';", "raw_model_output": "<think>\n\n</think>\n\nSELECT name, funding\nFROM biotech_startups\nWHERE date BETWEEN '2022-01-01' AND '2022-12-31';", "latency_sec": 0.6978001594543457, "total_duration_sec": 0.65711143, "load_duration_sec": 0.014669904, "tokens_prompt": 186, "prompt_eval_sec": 0.017590295, "tokens_completion": 44, "completion_eval_sec": 0.622338469, "tokens_total": 230, "tokens_per_sec": 329.60726202735697, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (name, funding) from the same table (biotech_startups) with identical WHERE conditions using BETWEEN. The only difference is formatting (line breaks), which does not affect semantic equivalence."}
{"example_id": 2136, "sql_complexity": "window functions", "prompt": "What is the total military equipment sales revenue for each sales representative by fiscal year?", "context": "CREATE TABLE SalesReps (SalesRepID INT, SalesRepName VARCHAR(50), FiscalYear INT, Revenue DECIMAL(10,2)); INSERT INTO SalesReps (SalesRepID, SalesRepName, FiscalYear, Revenue) VALUES (1, 'John Doe', 2020, 150000.00), (2, 'Jane Smith', 2020, 200000.00), (1, 'John Doe', 2021, 180000.00), (2, 'Jane Smith', 2021, 250000.00);", "reference_sql": "SELECT SalesRepName, FiscalYear, SUM(Revenue) OVER (PARTITION BY SalesRepName ORDER BY FiscalYear) AS TotalRevenue FROM SalesReps;", "generated_sql": "SELECT SalesRepName, FiscalYear, SUM(Revenue) AS TotalRevenue\nFROM SalesReps\nGROUP BY SalesRepName, FiscalYear;", "raw_model_output": "<think>\n\n</think>\n\nSELECT SalesRepName, FiscalYear, SUM(Revenue) AS TotalRevenue\nFROM SalesReps\nGROUP BY SalesRepName, FiscalYear;", "latency_sec": 0.5645270347595215, "total_duration_sec": 0.558266862, "load_duration_sec": 0.020387017, "tokens_prompt": 236, "prompt_eval_sec": 0.022309395, "tokens_completion": 35, "completion_eval_sec": 0.513169401, "tokens_total": 271, "tokens_per_sec": 480.0478689482802, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query uses a window function to calculate a running total of revenue per sales rep ordered by fiscal year, while the generated query aggregates revenue per sales rep and fiscal year. The first produces cumulative sums (e.g., 2020: 150000, 2021: 150000+180000=330000), whereas the second returns individual year totals (e.g., 2020: 150000, 2021: 180000)."}
{"example_id": 5452, "sql_complexity": "basic SQL", "prompt": "What is the name of the farms with a size greater than 150 acres located in 'Texas'?", "context": "CREATE TABLE farms (id INT PRIMARY KEY, name VARCHAR(50), size INT, location VARCHAR(50)); INSERT INTO farms (id, name, size, location) VALUES (1, 'Smith Farms', 200, 'Texas'), (2, 'Johnson Farms', 100, 'California');", "reference_sql": "SELECT name FROM farms WHERE size > 150 AND location = 'Texas'", "generated_sql": "SELECT name FROM farms WHERE size > 150 AND location = 'Texas';", "raw_model_output": "<think>\n\n</think>\n\nSELECT name FROM farms WHERE size > 150 AND location = 'Texas';", "latency_sec": 0.43227601051330566, "total_duration_sec": 0.350129472, "load_duration_sec": 0.014319404, "tokens_prompt": 162, "prompt_eval_sec": 0.019267167, "tokens_completion": 22, "completion_eval_sec": 0.313627347, "tokens_total": 184, "tokens_per_sec": 425.65396997513096, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and content, including the same column selections, table name, and WHERE conditions. The whitespace formatting (e.g., line breaks) does not affect semantic equivalence in SQL."}
{"example_id": 5152, "sql_complexity": "aggregation", "prompt": "How many international tourists visited Portugal in 2020, broken down by continent?", "context": "CREATE TABLE international_tourists(tourist_id INT, country TEXT, arrival_year INT, continent TEXT);INSERT INTO international_tourists (tourist_id, country, arrival_year, continent) VALUES (1, 'Spain', 2020, 'Europe'), (2, 'France', 2020, 'Europe'), (3, 'Brazil', 2020, 'South America'), (4, 'United States', 2020, 'North America'), (5, 'China', 2020, 'Asia');", "reference_sql": "SELECT continent, COUNT(*) FROM international_tourists WHERE arrival_year = 2020 GROUP BY continent;", "generated_sql": "SELECT continent, COUNT(*) AS num_tourists\nFROM international_tourists\nWHERE country = 'Portugal' AND arrival_year = 2020\nGROUP BY continent;", "raw_model_output": "<think>\n\n</think>\n\nSELECT continent, COUNT(*) AS num_tourists\nFROM international_tourists\nWHERE country = 'Portugal' AND arrival_year = 2020\nGROUP BY continent;", "latency_sec": 0.8788809776306152, "total_duration_sec": 0.655720951, "load_duration_sec": 0.01485733, "tokens_prompt": 209, "prompt_eval_sec": 0.021370717, "tokens_completion": 43, "completion_eval_sec": 0.617474905, "tokens_total": 252, "tokens_per_sec": 286.7282446815148, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query counts all tourists from 2020 grouped by continent, while the generated query filters for 'Portugal' (which has no entries in the data) and would return an empty result. The WHERE clause in the generated query drastically changes the dataset being analyzed."}
{"example_id": 2477, "sql_complexity": "set operations", "prompt": "What is the carbon price in Europe and Australia for the last quarter of 2020?", "context": "CREATE TABLE CarbonPrices (Country TEXT, Year INT, Quarter INT, CarbonPrice NUMBER); INSERT INTO CarbonPrices (Country, Year, Quarter, CarbonPrice) VALUES ('Europe', 2020, 4, 25), ('Australia', 2020, 4, 15); CREATE TABLE CarbonTaxes (Country TEXT, Year INT, Quarter INT, CarbonPrice NUMBER); INSERT INTO CarbonTaxes (Country, Year, Quarter, CarbonPrice) VALUES ('Europe', 2019, 4, 20), ('Australia', 2019, 4, 10);", "reference_sql": "SELECT Context.Country, Context.CarbonPrice FROM ( SELECT * FROM CarbonPrices WHERE CarbonPrices.Country IN ('Europe', 'Australia') AND CarbonPrices.Year = 2020 AND CarbonPrices.Quarter = 4 UNION SELECT * FROM CarbonTaxes WHERE CarbonTaxes.Country IN ('Europe', 'Australia') AND CarbonTaxes.Year = 2020 AND CarbonTaxes.Quarter = 4 ) AS Context;", "generated_sql": "SELECT Country, Year, Quarter, CarbonPrice\nFROM CarbonPrices\nWHERE Country IN ('Europe', 'Australia')\n  AND Year = 2020\n  AND Quarter = 4;", "raw_model_output": "<think>\n\n</think>\n\nSELECT Country, Year, Quarter, CarbonPrice\nFROM CarbonPrices\nWHERE Country IN ('Europe', 'Australia')\n  AND Year = 2020\n  AND Quarter = 4;", "latency_sec": 0.6932590007781982, "total_duration_sec": 0.6864165, "load_duration_sec": 0.013828902, "tokens_prompt": 224, "prompt_eval_sec": 0.022289719, "tokens_completion": 45, "completion_eval_sec": 0.648100521, "tokens_total": 269, "tokens_per_sec": 388.0223692704194, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL combines data from both CarbonPrices and CarbonTaxes tables using UNION, while the Generated SQL only queries CarbonPrices. Additionally, the Reference SQL selects only Country and CarbonPrice columns, whereas the Generated SQL selects all four columns (Country, Year, Quarter, CarbonPrice). The Generated SQL also lacks the UNION logic and would not include CarbonTaxes data even if it existed for 2020."}
{"example_id": 4573, "sql_complexity": "subqueries", "prompt": "Find the names of all the indigenous communities in the 'Arctic_Communities' table that have a population size greater than the average population size in the 'Antarctic_Communities' table.", "context": "CREATE TABLE Arctic_Communities (name TEXT, population INTEGER); CREATE TABLE Antarctic_Communities (name TEXT, population INTEGER);", "reference_sql": "SELECT name FROM Arctic_Communities WHERE Arctic_Communities.population > (SELECT AVG(population) FROM Antarctic_Communities)", "generated_sql": "SELECT name\nFROM Arctic_Communities\nWHERE population > (\n    SELECT AVG(population)\n    FROM Antarctic_Communities\n);", "raw_model_output": "<think>\n\n</think>\n\nSELECT name\nFROM Arctic_Communities\nWHERE population > (\n    SELECT AVG(population)\n    FROM Antarctic_Communities\n);", "latency_sec": 0.4628129005432129, "total_duration_sec": 0.455104701, "load_duration_sec": 0.019660522, "tokens_prompt": 135, "prompt_eval_sec": 0.012863464, "tokens_completion": 30, "completion_eval_sec": 0.420510262, "tokens_total": 165, "tokens_per_sec": 356.5155591089534, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select names from Arctic_Communities where population exceeds the average population of Antarctic_Communities. The generated query omits the table name in the WHERE clause, but since the main query's FROM clause specifies Arctic_Communities, the population column is unambiguously from that table. The subquery is identical in both cases."}
{"example_id": 3596, "sql_complexity": "window functions", "prompt": "What is the total revenue for each game in the \"Gaming\" category?", "context": "CREATE TABLE Games (GameID int, GameName varchar(50), Category varchar(50), Revenue decimal(10,2));", "reference_sql": "SELECT Category, SUM(Revenue) OVER(PARTITION BY Category) as TotalRevenue FROM Games;", "generated_sql": "SELECT Category, SUM(Revenue) AS TotalRevenue\nFROM Games\nWHERE Category = 'Gaming'\nGROUP BY Category;", "raw_model_output": "<think>\n\n</think>\n\nSELECT Category, SUM(Revenue) AS TotalRevenue\nFROM Games\nWHERE Category = 'Gaming'\nGROUP BY Category;", "latency_sec": 0.47739481925964355, "total_duration_sec": 0.456493725, "load_duration_sec": 0.024901415, "tokens_prompt": 117, "prompt_eval_sec": 0.011367549, "tokens_completion": 30, "completion_eval_sec": 0.418267857, "tokens_total": 147, "tokens_per_sec": 307.92123012137307, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query calculates total revenue per category for all categories using a window function, while the generated query filters only 'Gaming' category and groups by category. The generated query restricts results to a single category and removes the window function logic, leading to different output."}
{"example_id": 5039, "sql_complexity": "subqueries", "prompt": "What is the total number of community policing events in 'City Park' in 2021?", "context": "CREATE TABLE locations (id INT, name VARCHAR(255)); CREATE TABLE community_policing (id INT, location_id INT, year INT, events INT); INSERT INTO locations (id, name) VALUES (1, 'City Park'); INSERT INTO community_policing (id, location_id, year, events) VALUES (1, 1, 2021, 5);", "reference_sql": "SELECT SUM(events) FROM community_policing WHERE location_id = (SELECT id FROM locations WHERE name = 'City Park') AND year = 2021;", "generated_sql": "SELECT SUM(events) AS total_events\nFROM community_policing\nJOIN locations ON community_policing.location_id = locations.id\nWHERE locations.name = 'City Park' AND community_policing.year = 2021;", "raw_model_output": "<think>\n\n</think>\n\nSELECT SUM(events) AS total_events\nFROM community_policing\nJOIN locations ON community_policing.location_id = locations.id\nWHERE locations.name = 'City Park' AND community_policing.year = 2021;", "latency_sec": 0.9327130317687988, "total_duration_sec": 0.785028888, "load_duration_sec": 0.024726301, "tokens_prompt": 175, "prompt_eval_sec": 0.015258083, "tokens_completion": 53, "completion_eval_sec": 0.742949303, "tokens_total": 228, "tokens_per_sec": 244.44817669977266, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of 'events' for the location named 'City Park' in 2021. The reference query uses a subquery to get the location ID, while the generated query uses a JOIN to combine the tables. Both enforce the same filtering conditions (location name and year) and will produce identical results given the schema and sample data."}
{"example_id": 2724, "sql_complexity": "basic SQL", "prompt": "What is the earliest installation date for solar panels in Italy?", "context": "CREATE TABLE solar_panels_italy (id INT, installation_date DATE); INSERT INTO solar_panels_italy (id, installation_date) VALUES (1, '2018-01-01'), (2, '2019-01-01'), (3, '2020-01-01');", "reference_sql": "SELECT MIN(installation_date) as earliest_date FROM solar_panels_italy;", "generated_sql": "SELECT MIN(installation_date) FROM solar_panels_italy;", "raw_model_output": "<think>\n\n</think>\n\nSELECT MIN(installation_date) FROM solar_panels_italy;", "latency_sec": 0.6110048294067383, "total_duration_sec": 0.315789792, "load_duration_sec": 0.013770085, "tokens_prompt": 160, "prompt_eval_sec": 0.014533144, "tokens_completion": 20, "completion_eval_sec": 0.285532913, "tokens_total": 180, "tokens_per_sec": 294.5966894807901, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the minimum installation_date from the solar_panels_italy table. The only difference is the alias 'earliest_date' in the reference query, which does not affect the semantic result. The generated query omits the alias but returns the same value."}
{"example_id": 2200, "sql_complexity": "single join", "prompt": "Which diversity programs are currently being participated in by employees in the HR department?", "context": "CREATE TABLE Employees (Employee_ID INT, First_Name VARCHAR(20), Last_Name VARCHAR(20), Department VARCHAR(20), Salary DECIMAL(10,2), Date_Hired DATE); CREATE TABLE Diversity_Programs (Program_ID INT, Program_Name VARCHAR(50), Participant_ID INT, Date_Started DATE, Date_Ended DATE);", "reference_sql": "SELECT dp.Program_Name FROM Diversity_Programs dp JOIN Employees e ON dp.Participant_ID = e.Employee_ID WHERE e.Department = 'HR' AND dp.Date_Ended IS NULL;", "generated_sql": "SELECT DISTINCT dp.Program_Name\nFROM Diversity_Programs dp\nJOIN Employees e ON dp.Participant_ID = e.Employee_ID\nWHERE e.Department = 'HR'\nAND dp.Date_Ended > CURRENT_DATE;", "raw_model_output": "<think>\n\n</think>\n\nSELECT DISTINCT dp.Program_Name\nFROM Diversity_Programs dp\nJOIN Employees e ON dp.Participant_ID = e.Employee_ID\nWHERE e.Department = 'HR'\nAND dp.Date_Ended > CURRENT_DATE;", "latency_sec": 0.7909202575683594, "total_duration_sec": 0.684135718, "load_duration_sec": 0.024511343, "tokens_prompt": 160, "prompt_eval_sec": 0.015155166, "tokens_completion": 46, "completion_eval_sec": 0.642328512, "tokens_total": 206, "tokens_per_sec": 260.4560927966817, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL checks for programs where Date_Ended is NULL (indicating active programs), while the Generated SQL checks for programs where Date_Ended is in the future. These conditions are not equivalent because NULL values are not considered greater than CURRENT_DATE. Additionally, the Generated SQL includes DISTINCT which may further alter results."}
{"example_id": 4359, "sql_complexity": "window functions", "prompt": "Which destinations have the least hotel awards?", "context": "CREATE TABLE Destinations (destination_id INT, destination_name TEXT, country TEXT, awards INT); INSERT INTO Destinations (destination_id, destination_name, country, awards) VALUES (1, 'City A', 'Germany', 3), (2, 'City B', 'Switzerland', 5), (3, 'City C', 'Norway', 2);", "reference_sql": "SELECT destination_name, country, awards, RANK() OVER (PARTITION BY country ORDER BY awards ASC) AS rank FROM Destinations;", "generated_sql": "SELECT destination_name\nFROM Destinations\nORDER BY awards ASC\nLIMIT 1;", "raw_model_output": "<think>\n\n</think>\n\nSELECT destination_name\nFROM Destinations\nORDER BY awards ASC\nLIMIT 1;", "latency_sec": 0.6567699909210205, "total_duration_sec": 0.348737544, "load_duration_sec": 0.019352559, "tokens_prompt": 156, "prompt_eval_sec": 0.014876021, "tokens_completion": 22, "completion_eval_sec": 0.311822035, "tokens_total": 178, "tokens_per_sec": 271.0233452511768, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates ranks for destinations within each country based on awards, returning all rows with their respective ranks. The Generated SQL only retrieves the single destination with the lowest awards, limiting output to one row. The two queries differ in both result structure and content."}
{"example_id": 1373, "sql_complexity": "subqueries", "prompt": "What is the total value of military equipment sales to Africa in the last 12 months?", "context": "CREATE TABLE Military_Equipment_Sales(sale_id INT, sale_date DATE, equipment_type VARCHAR(50), country VARCHAR(50), sale_value DECIMAL(10,2));", "reference_sql": "SELECT SUM(sale_value) FROM Military_Equipment_Sales WHERE country IN (SELECT country FROM World_Countries WHERE continent = 'Africa') AND sale_date >= DATE_SUB(CURRENT_DATE, INTERVAL 12 MONTH);", "generated_sql": "SELECT SUM(sale_value) AS total_value\nFROM Military_Equipment_Sales\nWHERE country = 'Africa'\nAND sale_date >= CURRENT_DATE - INTERVAL '12 months';", "raw_model_output": "<think>\n\n</think>\n\nSELECT SUM(sale_value) AS total_value\nFROM Military_Equipment_Sales\nWHERE country = 'Africa'\nAND sale_date >= CURRENT_DATE - INTERVAL '12 months';", "latency_sec": 3.3683876991271973, "total_duration_sec": 0.59960565, "load_duration_sec": 0.013334429, "tokens_prompt": 130, "prompt_eval_sec": 0.014611534, "tokens_completion": 41, "completion_eval_sec": 0.569629035, "tokens_total": 171, "tokens_per_sec": 50.76612767714026, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their country filtering logic. The Reference SQL uses a subquery to select countries in the 'Africa' continent from World_Countries, while the Generated SQL incorrectly filters for a country named 'Africa' (which likely doesn't exist). This makes them non-equivalent as they target different datasets."}
{"example_id": 904, "sql_complexity": "basic SQL", "prompt": "What is the minimum Shariah-compliant loan amount issued in the last quarter of 2021?", "context": "CREATE TABLE loans (id INT, amount DECIMAL, date DATE, loan_type VARCHAR); INSERT INTO loans (id, amount, date, loan_type) VALUES (1, 5000, '2021-09-05', 'Shariah-compliant'), (2, 7000, '2021-10-07', 'socially responsible'), (3, 9000, '2021-11-03', 'Shariah-compliant'), (4, 11000, '2021-12-31', 'Shariah-compliant');", "reference_sql": "SELECT MIN(amount) FROM loans WHERE EXTRACT(YEAR FROM date) = 2021 AND EXTRACT(QUARTER FROM date) = 4 AND loan_type = 'Shariah-compliant';", "generated_sql": "SELECT MIN(amount) AS min_shariah_compliant_amount\nFROM loans\nWHERE loan_type = 'Shariah-compliant'\n  AND date BETWEEN '2021-10-01' AND '2021-12-31';", "raw_model_output": "<think>\n\n</think>\n\nSELECT MIN(amount) AS min_shariah_compliant_amount\nFROM loans\nWHERE loan_type = 'Shariah-compliant'\n  AND date BETWEEN '2021-10-01' AND '2021-12-31';", "latency_sec": 0.9230380058288574, "total_duration_sec": 0.917062136, "load_duration_sec": 0.014174272, "tokens_prompt": 237, "prompt_eval_sec": 0.024695734, "tokens_completion": 61, "completion_eval_sec": 0.876113666, "tokens_total": 298, "tokens_per_sec": 322.84694467418586, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter for 'Shariah-compliant' loans in the 4th quarter of 2021. The reference query uses EXTRACT(QUARTER) = 4 and EXTRACT(YEAR) = 2021, while the generated query uses a date range from '2021-10-01' to '2021-12-31', which corresponds to Q4. Both approaches capture the same set of dates (October-December 2021) and loan type, ensuring identical results."}
{"example_id": 3299, "sql_complexity": "set operations", "prompt": "How many schools and hospitals are there in Colombia and which ones need repairs?", "context": "CREATE TABLE schools (id INT, country VARCHAR(20), name VARCHAR(50), needs_repair BOOLEAN); CREATE TABLE hospitals (id INT, country VARCHAR(20), name VARCHAR(50), needs_repair BOOLEAN);", "reference_sql": "SELECT 'Schools' as facility_type, COUNT(*) as total, SUM(needs_repair) as repairs_needed FROM schools WHERE country = 'Colombia' UNION ALL SELECT 'Hospitals' as facility_type, COUNT(*) as total, SUM(needs_repair) as repairs_needed FROM hospitals WHERE country = 'Colombia';", "generated_sql": "SELECT \n    COUNT(*) AS total_institutions,\n    SUM(CASE WHEN needs_repair THEN 1 ELSE 0 END) AS needs_repair_count\nFROM \n    schools\nWHERE \n    country = 'Colombia'\nUNION ALL\nSELECT \n    COUNT(*) AS total_institutions,\n    SUM(CASE WHEN needs_repair THEN 1 ELSE 0 END) AS needs_repair_count\nFROM \n    hospitals\nWHERE \n    country = 'Colombia';", "raw_model_output": "<think>\n\n</think>\n\nSELECT \n    COUNT(*) AS total_institutions,\n    SUM(CASE WHEN needs_repair THEN 1 ELSE 0 END) AS needs_repair_count\nFROM \n    schools\nWHERE \n    country = 'Colombia'\nUNION ALL\nSELECT \n    COUNT(*) AS total_institutions,\n    SUM(CASE WHEN needs_repair THEN 1 ELSE 0 END) AS needs_repair_count\nFROM \n    hospitals\nWHERE \n    country = 'Colombia';", "latency_sec": 1.4724197387695312, "total_duration_sec": 1.458030965, "load_duration_sec": 0.018807764, "tokens_prompt": 135, "prompt_eval_sec": 0.013413872, "tokens_completion": 103, "completion_eval_sec": 1.423836707, "tokens_total": 238, "tokens_per_sec": 161.6386915587612, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a 'facility_type' column ('Schools' or 'Hospitals') which the Generated SQL lacks. The Generated SQL returns only two columns (total_institutions, needs_repair_count) while the Reference SQL returns three columns (facility_type, total, repairs_needed). This structural difference in output columns makes them non-equivalent."}
{"example_id": 907, "sql_complexity": "set operations", "prompt": "What is the total quantity of items with type 'E' or type 'F' in warehouse O and warehouse P?", "context": "CREATE TABLE warehouse_o(item_id INT, item_type VARCHAR(10), quantity INT);CREATE TABLE warehouse_p(item_id INT, item_type VARCHAR(10), quantity INT);INSERT INTO warehouse_o(item_id, item_type, quantity) VALUES (1, 'E', 200), (2, 'F', 300), (3, 'E', 50), (4, 'F', 400);INSERT INTO warehouse_p(item_id, item_type, quantity) VALUES (1, 'E', 150), (2, 'F', 250), (3, 'E', 40), (4, 'F', 350);", "reference_sql": "SELECT quantity FROM warehouse_o WHERE item_type IN ('E', 'F') UNION ALL SELECT quantity FROM warehouse_p WHERE item_type IN ('E', 'F');", "generated_sql": "SELECT SUM(CASE WHEN item_type = 'E' OR item_type = 'F' THEN quantity ELSE 0 END) AS total_quantity\nFROM warehouse_o\nUNION ALL\nSELECT SUM(CASE WHEN item_type = 'E' OR item_type = 'F' THEN quantity ELSE 0 END) AS total_quantity\nFROM warehouse_p;", "raw_model_output": "<think>\n\n</think>\n\nSELECT SUM(CASE WHEN item_type = 'E' OR item_type = 'F' THEN quantity ELSE 0 END) AS total_quantity\nFROM warehouse_o\nUNION ALL\nSELECT SUM(CASE WHEN item_type = 'E' OR item_type = 'F' THEN quantity ELSE 0 END) AS total_quantity\nFROM warehouse_p;", "latency_sec": 1.244560718536377, "total_duration_sec": 1.117198794, "load_duration_sec": 0.023338679, "tokens_prompt": 244, "prompt_eval_sec": 0.022726628, "tokens_completion": 75, "completion_eval_sec": 1.069169472, "tokens_total": 319, "tokens_per_sec": 256.31533700914895, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns individual quantity values from both tables where item_type is 'E' or 'F', while the Generated SQL returns summed totals of quantities for each table. The first produces multiple rows of raw values, the second produces two rows of aggregated sums. The result sets have different structures and content."}
{"example_id": 1400, "sql_complexity": "single join", "prompt": "What is the maximum co-ownership duration for properties in the neighborhood of 'Chinatown' in San Francisco?'", "context": "CREATE TABLE sf_neighborhoods (neighborhood_id INT, name VARCHAR(255), city VARCHAR(255)); INSERT INTO sf_neighborhoods (neighborhood_id, name, city) VALUES (1, 'Chinatown', 'San Francisco'); CREATE TABLE co_ownership (co_ownership_id INT, property_id INT, co_owner_id INT, start_date DATE, end_date DATE); INSERT INTO co_ownership (co_ownership_id, property_id, co_owner_id, start_date, end_date) VALUES (1, 1, 2, '2010-01-01', '2020-01-01'), (2, 2, 3, '2015-01-01', '2022-01-01'); CREATE TABLE properties (property_id INT, city VARCHAR(255)); INSERT INTO properties (property_id, city) VALUES (1, 'San Francisco'), (2, 'San Francisco');", "reference_sql": "SELECT MAX(DATEDIFF(end_date, start_date)) as max_duration FROM co_ownership JOIN properties ON co_ownership.property_id = properties.property_id WHERE properties.city = 'San Francisco' AND name = 'Chinatown';", "generated_sql": "SELECT MAX(JULIANDAY(end_date) - JULIANDAY(start_date)) AS max_co_ownership_duration\nFROM co_ownership\nJOIN properties ON co_ownership.property_id = properties.property_id\nJOIN sf_neighborhoods ON properties.city = sf_neighborhoods.city\nWHERE sf_neighborhoods.name = 'Chinatown';", "raw_model_output": "<think>\n\n</think>\n\nSELECT MAX(JULIANDAY(end_date) - JULIANDAY(start_date)) AS max_co_ownership_duration\nFROM co_ownership\nJOIN properties ON co_ownership.property_id = properties.property_id\nJOIN sf_neighborhoods ON properties.city = sf_neighborhoods.city\nWHERE sf_neighborhoods.name = 'Chinatown';", "latency_sec": 1.2912609577178955, "total_duration_sec": 1.148624935, "load_duration_sec": 0.023886456, "tokens_prompt": 308, "prompt_eval_sec": 0.029590176, "tokens_completion": 75, "completion_eval_sec": 1.092990943, "tokens_total": 383, "tokens_per_sec": 296.6092931957715, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references a 'name' column in the WHERE clause that does not exist in the joined tables (properties or co_ownership), causing an error. The Generated SQL correctly joins with sf_neighborhoods and filters on sf_neighborhoods.name. Additionally, the Generated SQL uses JULIANDAY for date difference calculation, while the Reference SQL uses DATEDIFF, which may yield different results depending on SQL dialect. The missing join in the Reference SQL makes the queries non-equivalent."}
{"example_id": 5248, "sql_complexity": "window functions", "prompt": "Find the top 5 games by rating", "context": "CREATE TABLE games (game_id INT PRIMARY KEY, name VARCHAR(50), genre VARCHAR(50), rating DECIMAL(3,2));", "reference_sql": "SELECT * FROM (SELECT name, rating, ROW_NUMBER() OVER (ORDER BY rating DESC) as rn FROM games) t WHERE rn <= 5;", "generated_sql": "SELECT game_id, name, genre, rating\nFROM games\nORDER BY rating DESC\nLIMIT 5;", "raw_model_output": "<think>\n\n</think>\n\nSELECT game_id, name, genre, rating\nFROM games\nORDER BY rating DESC\nLIMIT 5;", "latency_sec": 0.4354848861694336, "total_duration_sec": 0.417585436, "load_duration_sec": 0.025832041, "tokens_prompt": 111, "prompt_eval_sec": 0.014679374, "tokens_completion": 27, "completion_eval_sec": 0.373009788, "tokens_total": 138, "tokens_per_sec": 316.88815015800225, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL selects only 'name', 'rating', and a row number ('rn'), while the Generated SQL selects all columns ('game_id', 'name', 'genre', 'rating'). Additionally, the Reference SQL uses a subquery with ROW_NUMBER() to limit results, whereas the Generated SQL uses LIMIT 5. The column sets and output structure differ, making their results non-equivalent."}
{"example_id": 778, "sql_complexity": "single join", "prompt": "What is the maximum property price in wheelchair-accessible neighborhoods in Singapore?", "context": "CREATE TABLE Singapore_Neighborhoods (Neighborhood_Name TEXT, Wheelchair_Accessibility BOOLEAN); INSERT INTO Singapore_Neighborhoods (Neighborhood_Name, Wheelchair_Accessibility) VALUES ('Orchard', true), ('Marina Bay', true), ('Chinatown', false), ('Little India', false), ('Bugis', true); CREATE TABLE Singapore_Properties (Neighborhood_Name TEXT, Property_Price INTEGER); INSERT INTO Singapore_Properties (Neighborhood_Name, Property_Price) VALUES ('Orchard', 2000000), ('Marina Bay', 3000000), ('Chinatown', 1500000), ('Little India', 1200000), ('Bugis', 1800000);", "reference_sql": "SELECT MAX(Singapore_Properties.Property_Price) FROM Singapore_Properties INNER JOIN Singapore_Neighborhoods ON Singapore_Properties.Neighborhood_Name = Singapore_Neighborhoods.Neighborhood_Name WHERE Singapore_Neighborhoods.Wheelchair_Accessibility = true;", "generated_sql": "SELECT MAX(Property_Price) \nFROM Singapore_Properties \nWHERE Neighborhood_Name IN (\n    SELECT Neighborhood_Name \n    FROM Singapore_Neighborhoods \n    WHERE Wheelchair_Accessibility = TRUE\n);", "raw_model_output": "<think>\n\n</think>\n\nSELECT MAX(Property_Price) \nFROM Singapore_Properties \nWHERE Neighborhood_Name IN (\n    SELECT Neighborhood_Name \n    FROM Singapore_Neighborhoods \n    WHERE Wheelchair_Accessibility = TRUE\n);", "latency_sec": 0.7291288375854492, "total_duration_sec": 0.703600267, "load_duration_sec": 0.014921081, "tokens_prompt": 255, "prompt_eval_sec": 0.024706395, "tokens_completion": 45, "completion_eval_sec": 0.661800769, "tokens_total": 300, "tokens_per_sec": 411.44991740206945, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the maximum property price from neighborhoods with wheelchair accessibility. The Reference SQL uses an INNER JOIN to combine tables and filter accessible neighborhoods, while the Generated SQL uses a subquery with IN to achieve the same filtering. Both approaches ensure only properties in accessible neighborhoods are considered, resulting in the same MAX(Property_Price) value."}
{"example_id": 3859, "sql_complexity": "aggregation", "prompt": "What is the total number of mental health parity violations by month and year?", "context": "CREATE TABLE mental_health_parity_reports (report_id INT, violation_date DATE); INSERT INTO mental_health_parity_reports (report_id, violation_date) VALUES (1, '2022-01-01'), (2, '2022-02-15'), (3, '2022-03-05'), (4, '2022-04-20'), (5, '2021-06-12'), (6, '2021-07-28');", "reference_sql": "SELECT EXTRACT(MONTH FROM violation_date) AS month, EXTRACT(YEAR FROM violation_date) AS year, COUNT(*) FROM mental_health_parity_reports GROUP BY month, year;", "generated_sql": "SELECT \n    EXTRACT(YEAR FROM violation_date) AS year,\n    EXTRACT(MONTH FROM violation_date) AS month,\n    COUNT(*) AS total_violations\nFROM \n    mental_health_parity_reports\nGROUP BY \n    EXTRACT(YEAR FROM violation_date),\n    EXTRACT(MONTH FROM violation_date)\nORDER BY \n    year, month;", "raw_model_output": "<think>\n\n</think>\n\nSELECT \n    EXTRACT(YEAR FROM violation_date) AS year,\n    EXTRACT(MONTH FROM violation_date) AS month,\n    COUNT(*) AS total_violations\nFROM \n    mental_health_parity_reports\nGROUP BY \n    EXTRACT(YEAR FROM violation_date),\n    EXTRACT(MONTH FROM violation_date)\nORDER BY \n    year, month;", "latency_sec": 1.221040964126587, "total_duration_sec": 1.169237549, "load_duration_sec": 0.014710957, "tokens_prompt": 208, "prompt_eval_sec": 0.021771535, "tokens_completion": 80, "completion_eval_sec": 1.130804211, "tokens_total": 288, "tokens_per_sec": 235.8643227060011, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries group by year and month (in different order) and count violations. The SELECT clause columns are reordered but represent the same data. The Generated SQL adds an ORDER BY, but semantic equivalence focuses on result content, not row order. Column aliases differ but do not affect data equivalence."}
{"example_id": 3551, "sql_complexity": "multiple_joins", "prompt": "List all artists who have performed in New York and Chicago, along with their highest-earning performance.", "context": "CREATE TABLE artist_events (artist_id INT, event_id INT, earnings DECIMAL(5,2)); CREATE TABLE artists (id INT, name VARCHAR(50)); CREATE TABLE events (id INT, city VARCHAR(20));", "reference_sql": "SELECT artists.name, MAX(artist_events.earnings) FROM artists INNER JOIN artist_events ON artists.id = artist_events.artist_id INNER JOIN events ON artist_events.event_id = events.id WHERE city IN ('New York', 'Chicago') GROUP BY artists.name;", "generated_sql": "SELECT a.name, MAX(ae.earnings) AS highest_earning\nFROM artists a\nJOIN artist_events ae ON a.id = ae.artist_id\nJOIN events e ON ae.event_id = e.id\nWHERE e.city IN ('New York', 'Chicago')\nGROUP BY a.name;", "raw_model_output": "<think>\n\n</think>\n\nSELECT a.name, MAX(ae.earnings) AS highest_earning\nFROM artists a\nJOIN artist_events ae ON a.id = ae.artist_id\nJOIN events e ON ae.event_id = e.id\nWHERE e.city IN ('New York', 'Chicago')\nGROUP BY a.name;", "latency_sec": 1.0314910411834717, "total_duration_sec": 0.914586485, "load_duration_sec": 0.013590004, "tokens_prompt": 139, "prompt_eval_sec": 0.013363303, "tokens_completion": 64, "completion_eval_sec": 0.885504189, "tokens_total": 203, "tokens_per_sec": 196.80248484474458, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the artist's name and their maximum earnings from events in 'New York' or 'Chicago'. They use identical JOIN conditions, WHERE filters, and GROUP BY clauses. The generated query uses table aliases and a different column alias ('highest_earning' vs. implicit name), but this does not affect semantic equivalence."}
{"example_id": 5168, "sql_complexity": "aggregation", "prompt": "Get the number of renewable energy projects in Australia for each project type.", "context": "CREATE TABLE renewable_projects (id INT PRIMARY KEY, project_name VARCHAR(255), project_location VARCHAR(255), project_type VARCHAR(255), capacity_mw FLOAT);", "reference_sql": "SELECT project_type, COUNT(*) FROM renewable_projects WHERE project_location = 'Australia' GROUP BY project_type;", "generated_sql": "SELECT project_type, COUNT(*) AS project_count\nFROM renewable_projects\nWHERE project_location = 'Australia'\nGROUP BY project_type;", "raw_model_output": "<think>\n\n</think>\n\nSELECT project_type, COUNT(*) AS project_count\nFROM renewable_projects\nWHERE project_location = 'Australia'\nGROUP BY project_type;", "latency_sec": 0.5264739990234375, "total_duration_sec": 0.457252323, "load_duration_sec": 0.013746257, "tokens_prompt": 125, "prompt_eval_sec": 0.012711549, "tokens_completion": 31, "completion_eval_sec": 0.428774045, "tokens_total": 156, "tokens_per_sec": 296.31092948439266, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. The generated query adds an alias 'project_count' to the COUNT(*) column, but this does not affect the actual data returned. Both queries filter for 'Australia' locations, group by project_type, and count the number of projects per type. The alias is purely syntactic and does not change the result set's content."}
{"example_id": 4916, "sql_complexity": "aggregation", "prompt": "What is the maximum revenue generated from selling Yttrium in India in the past 3 years?", "context": "CREATE TABLE Yttrium_Sales (id INT PRIMARY KEY, year INT, country VARCHAR(20), quantity INT, price PER_KG); INSERT INTO Yttrium_Sales (id, year, country, quantity, price) VALUES (1, 2019, 'India', 120, 40), (2, 2020, 'India', 130, 45), (3, 2021, 'India', 140, 50), (4, 2019, 'China', 150, 35), (5, 2020, 'China', 160, 40), (6, 2021, 'China', 170, 45);", "reference_sql": "SELECT MAX(quantity * price) FROM Yttrium_Sales WHERE country = 'India' GROUP BY year ORDER BY year DESC LIMIT 3;", "generated_sql": "SELECT MAX(quantity * price) AS max_revenue\nFROM Yttrium_Sales\nWHERE country = 'India'\nAND year IN (SELECT year FROM Yttrium_Sales WHERE country = 'India' ORDER BY year DESC LIMIT 3);", "raw_model_output": "<think>\n\n</think>\n\nSELECT MAX(quantity * price) AS max_revenue\nFROM Yttrium_Sales\nWHERE country = 'India'\nAND year IN (SELECT year FROM Yttrium_Sales WHERE country = 'India' ORDER BY year DESC LIMIT 3);", "latency_sec": 0.9900791645050049, "total_duration_sec": 0.879392233, "load_duration_sec": 0.020815225, "tokens_prompt": 270, "prompt_eval_sec": 0.028717823, "tokens_completion": 57, "completion_eval_sec": 0.827734897, "tokens_total": 327, "tokens_per_sec": 330.27662001501193, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns the maximum quantity*price per year for India, grouped by year and ordered descending (3 rows). The Generated SQL calculates the maximum quantity*price across the top 3 years (2021, 2020, 2019) as a single value. The first query returns 3 rows, while the second returns 1 row, making them semantically different."}
{"example_id": 812, "sql_complexity": "multiple_joins", "prompt": "What is the average salary of 'engineer' workers in each factory?", "context": "CREATE TABLE factories (factory_id INT, factory_name VARCHAR(20)); INSERT INTO factories VALUES (1, 'Factory X'), (2, 'Factory Y'), (3, 'Factory Z'); CREATE TABLE roles (role_id INT, role_name VARCHAR(20)); INSERT INTO roles VALUES (1, 'engineer'), (2, 'manager'), (3, 'assistant'); CREATE TABLE workers (worker_id INT, factory_id INT, role_id INT, salary DECIMAL(5,2)); INSERT INTO workers VALUES (1, 1, 1, 50000.00), (2, 1, 2, 70000.00), (3, 2, 1, 55000.00), (4, 2, 3, 40000.00), (5, 3, 1, 60000.00);", "reference_sql": "SELECT f.factory_name, AVG(salary) FROM workers w INNER JOIN factories f ON w.factory_id = f.factory_id INNER JOIN roles r ON w.role_id = r.role_id WHERE r.role_name = 'engineer' GROUP BY f.factory_name;", "generated_sql": "SELECT f.factory_name, AVG(w.salary) AS average_salary\nFROM workers w\nJOIN factories f ON w.factory_id = f.factory_id\nWHERE w.role_id = (\n    SELECT role_id\n    FROM roles\n    WHERE role_name = 'engineer'\n)\nGROUP BY f.factory_id, f.factory_name;", "raw_model_output": "<think>\n\n</think>\n\nSELECT f.factory_name, AVG(w.salary) AS average_salary\nFROM workers w\nJOIN factories f ON w.factory_id = f.factory_id\nWHERE w.role_id = (\n    SELECT role_id\n    FROM roles\n    WHERE role_name = 'engineer'\n)\nGROUP BY f.factory_id, f.factory_name;", "latency_sec": 1.1744792461395264, "total_duration_sec": 1.052349387, "load_duration_sec": 0.020186075, "tokens_prompt": 288, "prompt_eval_sec": 0.02853045, "tokens_completion": 69, "completion_eval_sec": 1.00150821, "tokens_total": 357, "tokens_per_sec": 303.9645027133914, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their GROUP BY clauses. The Reference SQL groups by factory_name, which could combine multiple factories with the same name (if they existed). The Generated SQL groups by both factory_id and factory_name, ensuring each factory is uniquely identified. Since factory_name is not guaranteed to be unique in the schema, the grouping logic makes the queries non-equivalent."}
{"example_id": 5784, "sql_complexity": "set operations", "prompt": "List the number of users who have completed a workout of a specific type (e.g. Running) and have a membership status of 'Active'.", "context": "CREATE TABLE workouts (id INT, user_id INT, workout_type VARCHAR(20)); CREATE TABLE members (id INT, name VARCHAR(50), membership_status VARCHAR(20), state VARCHAR(20)); INSERT INTO workouts (id, user_id, workout_type) VALUES (1, 1, 'Running'), (2, 1, 'Cycling'), (3, 2, 'Running'), (4, 3, 'Cycling'), (5, 3, 'Swimming'), (6, 4, 'Running'), (7, 4, 'Swimming'); INSERT INTO members (id, name, membership_status, state) VALUES (1, 'John Doe', 'Active', 'Texas'), (2, 'Jane Doe', 'Inactive', 'California'), (3, 'Bob Smith', 'Active', 'Texas'), (4, 'Alice Johnson', 'Active', 'California');", "reference_sql": "SELECT COUNT(*) FROM (SELECT user_id FROM workouts WHERE workout_type = 'Running' INTERSECT SELECT id FROM members WHERE membership_status = 'Active') AS user_set;", "generated_sql": "SELECT COUNT(DISTINCT user_id) AS active_users_with_running_workout\nFROM workouts\nJOIN members ON workouts.user_id = members.id\nWHERE workouts.workout_type = 'Running'\n  AND members.membership_status = 'Active';", "raw_model_output": "<think>\n\n</think>\n\nSELECT COUNT(DISTINCT user_id) AS active_users_with_running_workout\nFROM workouts\nJOIN members ON workouts.user_id = members.id\nWHERE workouts.workout_type = 'Running'\n  AND members.membership_status = 'Active';", "latency_sec": 0.9382638931274414, "total_duration_sec": 0.821486977, "load_duration_sec": 0.013038678, "tokens_prompt": 291, "prompt_eval_sec": 0.031297483, "tokens_completion": 53, "completion_eval_sec": 0.774568449, "tokens_total": 344, "tokens_per_sec": 366.63459237824, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of distinct user_ids that have a 'Running' workout and an active membership. The Reference SQL uses INTERSECT to find common user_ids between the two sets, while the Generated SQL joins the tables and counts distinct user_ids with the required conditions. Both approaches yield the same result."}
{"example_id": 3038, "sql_complexity": "subqueries", "prompt": "What is the total assets of clients who have invested in mutual funds but not in stocks?", "context": "CREATE TABLE clients (client_id INT, name TEXT, age INT, gender TEXT, total_assets DECIMAL(10,2)); INSERT INTO clients VALUES (1, 'John Doe', 35, 'Male', 250000.00), (2, 'Jane Smith', 45, 'Female', 500000.00); CREATE TABLE investments (client_id INT, investment_type TEXT); INSERT INTO investments VALUES (1, 'Stocks'), (1, 'Bonds'), (2, 'Stocks'), (3, 'Mutual Funds');", "reference_sql": "SELECT c.total_assets FROM clients c INNER JOIN investments i ON c.client_id = i.client_id WHERE i.investment_type = 'Mutual Funds' AND c.client_id NOT IN (SELECT client_id FROM investments WHERE investment_type = 'Stocks');", "generated_sql": "SELECT c.total_assets\nFROM clients c\nJOIN investments i ON c.client_id = i.client_id\nWHERE i.investment_type = 'Mutual Funds'\nAND c.client_id NOT IN (\n    SELECT client_id\n    FROM investments\n    WHERE investment_type = 'Stocks'\n);", "raw_model_output": "<think>\n\n</think>\n\nSELECT c.total_assets\nFROM clients c\nJOIN investments i ON c.client_id = i.client_id\nWHERE i.investment_type = 'Mutual Funds'\nAND c.client_id NOT IN (\n    SELECT client_id\n    FROM investments\n    WHERE investment_type = 'Stocks'\n);", "latency_sec": 0.9592950344085693, "total_duration_sec": 0.946998815, "load_duration_sec": 0.027397183, "tokens_prompt": 216, "prompt_eval_sec": 0.022041114, "tokens_completion": 63, "completion_eval_sec": 0.895323594, "tokens_total": 279, "tokens_per_sec": 290.83857415358233, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between clients and investments tables on client_id, filter for 'Mutual Funds' investment type, and exclude clients with 'Stocks' investments using a NOT IN clause. The structure, conditions, and subquery are identical in both queries."}
{"example_id": 1078, "sql_complexity": "basic SQL", "prompt": "What is the maximum and minimum temperature difference between any two Arctic research stations?", "context": "CREATE TABLE arctic_stations (id INT, name TEXT, location TEXT, temperature DECIMAL(5,2)); INSERT INTO arctic_stations (id, name, location, temperature) VALUES (1, 'Station A', 'Greenland', 2.3), (2, 'Station B', 'Canada', -5.2);", "reference_sql": "SELECT a.name as station1, b.name as station2, MAX(ABS(a.temperature - b.temperature)) as temp_diff FROM arctic_stations a, arctic_stations b ORDER BY temp_diff DESC LIMIT 1", "generated_sql": "SELECT MAX(temp_diff) AS max_temp_diff, MIN(temp_diff) AS min_temp_diff\nFROM (\n    SELECT ABS(a.temperature - b.temperature) AS temp_diff\n    FROM arctic_stations a\n    CROSS JOIN arctic_stations b\n    WHERE a.id != b.id\n) AS temp_differences;", "raw_model_output": "<think>\n\n</think>\n\nSELECT MAX(temp_diff) AS max_temp_diff, MIN(temp_diff) AS min_temp_diff\nFROM (\n    SELECT ABS(a.temperature - b.temperature) AS temp_diff\n    FROM arctic_stations a\n    CROSS JOIN arctic_stations b\n    WHERE a.id != b.id\n) AS temp_differences;", "latency_sec": 1.0124540328979492, "total_duration_sec": 1.005180116, "load_duration_sec": 0.014827065, "tokens_prompt": 158, "prompt_eval_sec": 0.015456454, "tokens_completion": 70, "completion_eval_sec": 0.972853286, "tokens_total": 228, "tokens_per_sec": 225.1954089682424, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The reference query returns the specific station pair with the maximum temperature difference, while the generated query only returns the maximum and minimum temperature differences without station names. Additionally, the generated query includes both max and min values, whereas the reference query focuses solely on the maximum."}
{"example_id": 5015, "sql_complexity": "basic SQL", "prompt": "Calculate the average recycling rate", "context": "CREATE TABLE recycling_rates (id INT PRIMARY KEY, location VARCHAR(50), rate FLOAT);", "reference_sql": "SELECT AVG(rate) FROM recycling_rates;", "generated_sql": "SELECT AVG(rate) FROM recycling_rates;", "raw_model_output": "<think>\n\n</think>\n\nSELECT AVG(rate) FROM recycling_rates;", "latency_sec": 0.3170430660247803, "total_duration_sec": 0.215269928, "load_duration_sec": 0.017175724, "tokens_prompt": 97, "prompt_eval_sec": 0.013075363, "tokens_completion": 13, "completion_eval_sec": 0.181804017, "tokens_total": 110, "tokens_per_sec": 346.9560188753737, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic, both calculating the average of the 'rate' column from the 'recycling_rates' table. No differences in syntax, semantics, or output expectations exist between them."}
{"example_id": 1533, "sql_complexity": "subqueries", "prompt": "Which programs had the highest volunteer participation rate in the last quarter?", "context": "CREATE TABLE Programs (ProgramID INT, ProgramName TEXT, Budget DECIMAL(10,2), NumVolunteers INT); CREATE TABLE VolunteerEvents (EventID INT, ProgramID INT, EventDate DATE, NumVolunteers INT);", "reference_sql": "SELECT p.ProgramName, COUNT(v.EventID) / (SELECT COUNT(*) FROM VolunteerEvents WHERE EventDate >= DATEADD(quarter, -1, GETDATE())) * 100.0 AS VolunteerParticipationRate FROM Programs p INNER JOIN VolunteerEvents v ON p.ProgramID = v.ProgramID WHERE v.EventDate >= DATEADD(quarter, -1, GETDATE()) GROUP BY p.ProgramName ORDER BY VolunteerParticipationRate DESC;", "generated_sql": "SELECT p.ProgramID, p.ProgramName, \n       (ve.NumVolunteers * 100.0 / p.NumVolunteers) AS ParticipationRate\nFROM Programs p\nJOIN VolunteerEvents ve ON p.ProgramID = ve.ProgramID\nWHERE ve.EventDate >= DATE_SUB(CURRENT_DATE, INTERVAL 3 MONTH)\nORDER BY ParticipationRate DESC\nLIMIT 1;", "raw_model_output": "<think>\n\n</think>\n\nSELECT p.ProgramID, p.ProgramName, \n       (ve.NumVolunteers * 100.0 / p.NumVolunteers) AS ParticipationRate\nFROM Programs p\nJOIN VolunteerEvents ve ON p.ProgramID = ve.ProgramID\nWHERE ve.EventDate >= DATE_SUB(CURRENT_DATE, INTERVAL 3 MONTH)\nORDER BY ParticipationRate DESC\nLIMIT 1;", "latency_sec": 1.2274839878082275, "total_duration_sec": 1.144991057, "load_duration_sec": 0.013923602, "tokens_prompt": 133, "prompt_eval_sec": 0.011593258, "tokens_completion": 81, "completion_eval_sec": 1.1169722, "tokens_total": 214, "tokens_per_sec": 174.34035973219855, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The reference query calculates a participation rate based on event counts relative to total events in the last quarter, while the generated query uses a per-event volunteer ratio compared to program-wide volunteer counts. Additionally, the generated query includes a LIMIT 1 clause and returns ProgramID, which the reference query does not. The aggregation, calculation logic, and output structure differ significantly."}
{"example_id": 4021, "sql_complexity": "subqueries", "prompt": "What is the percentage of energy efficiency improvement, per sector, compared to 2015 levels?", "context": "CREATE TABLE energy_efficiency (id INT, sector VARCHAR(50), year INT, efficiency FLOAT); INSERT INTO energy_efficiency (id, sector, year, efficiency) VALUES (1, 'Industry', 2015, 100.0), (2, 'Industry', 2020, 105.0), (3, 'Residential', 2015, 100.0), (4, 'Residential', 2020, 103.0);", "reference_sql": "SELECT sector, (SUM(efficiency) / (SELECT SUM(efficiency) FROM energy_efficiency WHERE year = 2015 AND sector = e.sector) * 100.0) - 100.0 AS improvement FROM energy_efficiency e WHERE year = 2020 GROUP BY sector;", "generated_sql": "SELECT sector, \n       ((efficiency - (SELECT efficiency FROM energy_efficiency e2 WHERE e2.sector = e1.sector AND e2.year = 2015)) / (SELECT efficiency FROM energy_efficiency e2 WHERE e2.sector = e1.sector AND e2.year = 2015)) * 100 AS percentage_improvement\nFROM energy_efficiency e1\nWHERE year = 2020\nGROUP BY sector;", "raw_model_output": "<think>\n\n</think>\n\nSELECT sector, \n       ((efficiency - (SELECT efficiency FROM energy_efficiency e2 WHERE e2.sector = e1.sector AND e2.year = 2015)) / (SELECT efficiency FROM energy_efficiency e2 WHERE e2.sector = e1.sector AND e2.year = 2015)) * 100 AS percentage_improvement\nFROM energy_efficiency e1\nWHERE year = 2020\nGROUP BY sector;", "latency_sec": 1.642077922821045, "total_duration_sec": 1.534468455, "load_duration_sec": 0.013965236, "tokens_prompt": 207, "prompt_eval_sec": 0.021811726, "tokens_completion": 106, "completion_eval_sec": 1.496537854, "tokens_total": 313, "tokens_per_sec": 190.6121479681516, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the percentage improvement by summing efficiencies for each sector in 2020 and comparing it to the 2015 sum, while the Generated SQL computes the improvement for each individual 2020 row relative to the 2015 value. If there are multiple entries per sector in 2020, the SUM in Reference SQL would aggregate them, whereas Generated SQL would process each row separately, leading to different results."}
{"example_id": 1551, "sql_complexity": "single join", "prompt": "How many unique donors made donations in the healthcare industry in Q3 2022?", "context": "CREATE TABLE donations (id INT, donor_id INT, amount FLOAT, donation_date DATE); INSERT INTO donations (id, donor_id, amount, donation_date) VALUES (1, 7, 100, '2022-07-01'); INSERT INTO donations (id, donor_id, amount, donation_date) VALUES (2, 8, 200, '2022-09-15'); INSERT INTO donors (id, name, industry, first_donation_date DATE) VALUES (7, 'Charlie Davis', 'Healthcare', '2022-07-01'); INSERT INTO donors (id, name, industry, first_donation_date DATE) VALUES (8, 'Dana Wilson', 'Healthcare', '2022-09-15');", "reference_sql": "SELECT COUNT(DISTINCT donor_id) FROM donations d JOIN donors don ON d.donor_id = don.id WHERE industry = 'Healthcare' AND donation_date BETWEEN '2022-07-01' AND '2022-09-30';", "generated_sql": "SELECT COUNT(DISTINCT donor_id)\nFROM donations\nWHERE donor_id IN (\n    SELECT id\n    FROM donors\n    WHERE industry = 'Healthcare'\n)\nAND donation_date BETWEEN '2022-07-01' AND '2022-09-30';", "raw_model_output": "<think>\n\n</think>\n\nSELECT COUNT(DISTINCT donor_id)\nFROM donations\nWHERE donor_id IN (\n    SELECT id\n    FROM donors\n    WHERE industry = 'Healthcare'\n)\nAND donation_date BETWEEN '2022-07-01' AND '2022-09-30';", "latency_sec": 1.0845062732696533, "total_duration_sec": 1.023517091, "load_duration_sec": 0.024622022, "tokens_prompt": 266, "prompt_eval_sec": 0.026059895, "tokens_completion": 67, "completion_eval_sec": 0.970739102, "tokens_total": 333, "tokens_per_sec": 307.05216577129227, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count distinct donor_ids from donations where the donor belongs to the 'Healthcare' industry and the donation date falls between '2022-07-01' and '2022-09-30'. The Reference SQL uses an explicit JOIN with a WHERE condition, while the Generated SQL uses a subquery with IN. Both approaches filter the same set of donor_ids and apply the same date range constraint, resulting in identical semantic outcomes."}
{"example_id": 2592, "sql_complexity": "window functions", "prompt": "What is the third highest account balance for Shariah-compliant finance customers?", "context": "CREATE TABLE shariah_compliant_finance(customer_id INT, account_balance DECIMAL(10, 2)); INSERT INTO shariah_compliant_finance VALUES (1, 5000), (2, 7000), (3, 6000), (4, 8000), (5, 9000);", "reference_sql": "SELECT account_balance FROM (SELECT account_balance, RANK() OVER (ORDER BY account_balance DESC) as rn FROM shariah_compliant_finance) t WHERE rn = 3;", "generated_sql": "SELECT DISTINCT account_balance\nFROM shariah_compliant_finance\nORDER BY account_balance DESC\nLIMIT 1 OFFSET 2;", "raw_model_output": "<think>\n\n</think>\n\nSELECT DISTINCT account_balance\nFROM shariah_compliant_finance\nORDER BY account_balance DESC\nLIMIT 1 OFFSET 2;", "latency_sec": 0.4959588050842285, "total_duration_sec": 0.483816014, "load_duration_sec": 0.01344329, "tokens_prompt": 166, "prompt_eval_sec": 0.015850823, "tokens_completion": 32, "completion_eval_sec": 0.452177776, "tokens_total": 198, "tokens_per_sec": 399.22670586798785, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the third highest account balance. The reference query uses RANK() to find the third distinct value, while the generated query uses LIMIT/OFFSET to directly access the third row after sorting. Since all account_balance values are unique in the dataset, both approaches yield the same result (7000)."}
{"example_id": 3795, "sql_complexity": "single join", "prompt": "What is the total quantity of unsold garments for each manufacturer based in 'Italy' or 'Spain'?", "context": "CREATE TABLE manufacturers (id INT PRIMARY KEY, name VARCHAR(255), country VARCHAR(255)); CREATE TABLE garments (id INT PRIMARY KEY, manufacturer_id INT, quantity_manufactured INT, quantity_sold INT);", "reference_sql": "SELECT m.name, SUM(g.quantity_manufactured - g.quantity_sold) as total_unsold_quantity FROM manufacturers m JOIN garments g ON m.id = g.manufacturer_id WHERE m.country IN ('Italy', 'Spain') GROUP BY m.name;", "generated_sql": "SELECT m.id AS manufacturer_id, m.name AS manufacturer_name, SUM(g.quantity_manufactured - g.quantity_sold) AS total_unsold_quantity\nFROM manufacturers m\nJOIN garments g ON m.id = g.manufacturer_id\nWHERE m.country IN ('Italy', 'Spain')\nGROUP BY m.id, m.name;", "raw_model_output": "<think>\n\n</think>\n\nSELECT m.id AS manufacturer_id, m.name AS manufacturer_name, SUM(g.quantity_manufactured - g.quantity_sold) AS total_unsold_quantity\nFROM manufacturers m\nJOIN garments g ON m.id = g.manufacturer_id\nWHERE m.country IN ('Italy', 'Spain')\nGROUP BY m.id, m.name;", "latency_sec": 1.3029601573944092, "total_duration_sec": 0.983569921, "load_duration_sec": 0.014315089, "tokens_prompt": 140, "prompt_eval_sec": 0.014794687, "tokens_completion": 69, "completion_eval_sec": 0.952293321, "tokens_total": 209, "tokens_per_sec": 160.40398381631803, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in selected columns and grouping logic. The reference query groups by 'm.name' only, while the generated query groups by both 'm.id' and 'm.name'. Since 'm.id' is the primary key, grouping by both ensures unique aggregation per manufacturer, whereas grouping by 'm.name' alone could combine multiple manufacturers with the same name. Additionally, the generated query includes 'manufacturer_id' in the output, which the reference query does not. These differences in grouping and selected columns make the results non-equivalent."}
{"example_id": 4138, "sql_complexity": "window functions", "prompt": "How many lifelong learning courses has a student with ID '2' completed, in chronological order?", "context": "CREATE TABLE lifelong_learning (student_id INT, course_id INT, completion_date DATE); INSERT INTO lifelong_learning VALUES (2, 1001, '2015-01-01'), (2, 1002, '2016-01-01');", "reference_sql": "SELECT student_id, course_id, COUNT(course_id) OVER (PARTITION BY student_id ORDER BY completion_date) as completed_courses FROM lifelong_learning WHERE student_id = 2;", "generated_sql": "SELECT COUNT(*) AS completed_courses\nFROM lifelong_learning\nWHERE student_id = 2\nORDER BY completion_date;", "raw_model_output": "<think>\n\n</think>\n\nSELECT COUNT(*) AS completed_courses\nFROM lifelong_learning\nWHERE student_id = 2\nORDER BY completion_date;", "latency_sec": 0.44130682945251465, "total_duration_sec": 0.429619205, "load_duration_sec": 0.013819324, "tokens_prompt": 155, "prompt_eval_sec": 0.014796351, "tokens_completion": 28, "completion_eval_sec": 0.398928272, "tokens_total": 183, "tokens_per_sec": 414.67747106254814, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns multiple rows with a cumulative count of courses per student, while the Generated SQL returns a single row with the total count. The window function in Reference SQL produces row-level counts, whereas Generated SQL's COUNT(*) aggregates all rows into one value."}
{"example_id": 312, "sql_complexity": "aggregation", "prompt": "List the top 3 most represented ethnicities in movies produced in the USA.", "context": "CREATE TABLE movies (title VARCHAR(255), production_country VARCHAR(64), lead_actor_ethnicity VARCHAR(64));", "reference_sql": "SELECT lead_actor_ethnicity, COUNT(*) AS count FROM movies WHERE production_country = 'USA' GROUP BY lead_actor_ethnicity ORDER BY count DESC LIMIT 3;", "generated_sql": "SELECT lead_actor_ethnicity, COUNT(*) AS count\nFROM movies\nWHERE production_country = 'USA'\nGROUP BY lead_actor_ethnicity\nORDER BY count DESC\nLIMIT 3;", "raw_model_output": "<think>\n\n</think>\n\nSELECT lead_actor_ethnicity, COUNT(*) AS count\nFROM movies\nWHERE production_country = 'USA'\nGROUP BY lead_actor_ethnicity\nORDER BY count DESC\nLIMIT 3;", "latency_sec": 0.9665889739990234, "total_duration_sec": 0.640008798, "load_duration_sec": 0.015575805, "tokens_prompt": 116, "prompt_eval_sec": 0.012107301, "tokens_completion": 44, "completion_eval_sec": 0.610321433, "tokens_total": 160, "tokens_per_sec": 165.53054535480524, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select the lead_actor_ethnicity column, count occurrences, filter for USA production_country, group by ethnicity, order by count descending, and limit to top 3 results. The generated query is a direct copy of the reference query with no semantic differences."}
{"example_id": 4298, "sql_complexity": "single join", "prompt": "How many users joined the gym in Q1 2023?", "context": "CREATE TABLE memberships (id INT, user_id INT, join_date DATE); INSERT INTO memberships (id, user_id, join_date) VALUES (1, 5, '2023-01-15'), (2, 6, '2023-02-03'), (3, 7, '2023-03-20'), (4, 8, '2022-12-31');", "reference_sql": "SELECT COUNT(*) FROM memberships WHERE join_date BETWEEN '2023-01-01' AND '2023-03-31';", "generated_sql": "SELECT COUNT(DISTINCT user_id) \nFROM memberships \nWHERE EXTRACT(QUARTER FROM join_date) = 1 \n  AND EXTRACT(YEAR FROM join_date) = 2023;", "raw_model_output": "<think>\n\n</think>\n\nSELECT COUNT(DISTINCT user_id) \nFROM memberships \nWHERE EXTRACT(QUARTER FROM join_date) = 1 \n  AND EXTRACT(YEAR FROM join_date) = 2023;", "latency_sec": 0.7547860145568848, "total_duration_sec": 0.72573232, "load_duration_sec": 0.014132541, "tokens_prompt": 187, "prompt_eval_sec": 0.01767566, "tokens_completion": 49, "completion_eval_sec": 0.691620838, "tokens_total": 236, "tokens_per_sec": 312.6714001696884, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query counts all rows where join_date is between 2023-01-01 and 2023-03-31 (inclusive), while the generated query counts distinct user_ids where join_date falls in Q1 2023. The key differences are: 1) COUNT(*) vs COUNT(DISTINCT user_id) 2) BETWEEN includes all dates in the range while EXTRACT(QUARTER) = 1 with EXTRACT(YEAR) = 2023 achieves the same date range but may behave differently with edge cases (though in this specific case it's equivalent). However, the fundamental difference in aggregation (all rows vs distinct users) makes them non-equivalent."}
{"example_id": 5211, "sql_complexity": "multiple_joins", "prompt": "What is the average transaction value in the last week, split by product category and customer demographics?", "context": "CREATE TABLE transactions (transaction_id INT, customer_id INT, product_id INT, category_id INT, transaction_date DATE, amount DECIMAL(10,2)); CREATE TABLE customers (customer_id INT, age INT, gender VARCHAR(10), location VARCHAR(255)); CREATE TABLE products (product_id INT, name VARCHAR(255), category_id INT);", "reference_sql": "SELECT c.age, c.gender, p.category_id, AVG(t.amount) as avg_transaction_value FROM transactions t INNER JOIN customers c ON t.customer_id = c.customer_id INNER JOIN products p ON t.product_id = p.product_id WHERE t.transaction_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 WEEK) GROUP BY c.age, c.gender, p.category_id;", "generated_sql": "SELECT \n    p.category_id,\n    c.gender,\n    c.location,\n    AVG(t.amount) AS average_transaction_value\nFROM \n    transactions t\nJOIN \n    customers c ON t.customer_id = c.customer_id\nJOIN \n    products p ON t.product_id = p.product_id\nWHERE \n    t.transaction_date >= CURRENT_DATE - INTERVAL '7 days'\nGROUP BY \n    p.category_id, c.gender, c.location;", "raw_model_output": "<think>\n\n</think>\n\nSELECT \n    p.category_id,\n    c.gender,\n    c.location,\n    AVG(t.amount) AS average_transaction_value\nFROM \n    transactions t\nJOIN \n    customers c ON t.customer_id = c.customer_id\nJOIN \n    products p ON t.product_id = p.product_id\nWHERE \n    t.transaction_date >= CURRENT_DATE - INTERVAL '7 days'\nGROUP BY \n    p.category_id, c.gender, c.location;", "latency_sec": 1.355835199356079, "total_duration_sec": 1.323493883, "load_duration_sec": 0.013728253, "tokens_prompt": 167, "prompt_eval_sec": 0.016348083, "tokens_completion": 93, "completion_eval_sec": 1.291136891, "tokens_total": 260, "tokens_per_sec": 191.76371886751477, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in selected columns and grouping fields. Reference includes 'age' and 'category_id', while generated includes 'location' and 'category_id'. The GROUP BY clause also differs (age/gender/category_id vs category_id/gender/location), leading to different aggregation results."}
{"example_id": 382, "sql_complexity": "window functions", "prompt": "What is the average annual precipitation in the past 10 years for each weather station?", "context": "CREATE TABLE WeatherStation (ID INT, Name VARCHAR(100), Location VARCHAR(100), Elevation FLOAT, AnnualPrecipitation FLOAT); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (1, 'Station A', 'Arctic Circle', 100, 450); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (2, 'Station B', 'North Pole', 200, 300);", "reference_sql": "SELECT Name, AVG(AnnualPrecipitation) OVER (PARTITION BY Name ORDER BY Name ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS AvgAnnualPrecipitation FROM WeatherStation WHERE YEAR(CurrentDate) - YEAR(DateInstalled) BETWEEN 1 AND 10;", "generated_sql": "SELECT ID, Name, Location, Elevation, AnnualPrecipitation\nFROM WeatherStation;", "raw_model_output": "<think>\n\n</think>\n\nSELECT ID, Name, Location, Elevation, AnnualPrecipitation\nFROM WeatherStation;", "latency_sec": 0.6928958892822266, "total_duration_sec": 0.397398802, "load_duration_sec": 0.018736082, "tokens_prompt": 205, "prompt_eval_sec": 0.02140011, "tokens_completion": 24, "completion_eval_sec": 0.354484411, "tokens_total": 229, "tokens_per_sec": 330.4969816421078, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL selects only 'Name' and a window function calculation, includes a WHERE clause referencing non-existent 'DateInstalled' column, and uses complex windowing logic. The Generated SQL selects all columns without any filtering. Column sets and query logic differ significantly."}
{"example_id": 2190, "sql_complexity": "single join", "prompt": "What is the total number of humanitarian assistance events by each country in the last 3 years?", "context": "CREATE TABLE Humanitarian_Assistance (id INT, country VARCHAR(50), year INT, events INT); CREATE TABLE Countries (id INT, name VARCHAR(50), region VARCHAR(50));", "reference_sql": "SELECT co.name, SUM(ha.events) FROM Humanitarian_Assistance ha INNER JOIN Countries co ON ha.country = co.name WHERE ha.year BETWEEN (YEAR(CURRENT_DATE) - 3) AND YEAR(CURRENT_DATE) GROUP BY co.name;", "generated_sql": "SELECT h.country, SUM(h.events) AS total_events\nFROM Humanitarian_Assistance h\nJOIN Countries c ON h.country = c.name\nWHERE h.year >= (SELECT MAX(year) - 2 FROM Humanitarian_Assistance)\nGROUP BY h.country;", "raw_model_output": "<think>\n\n</think>\n\nSELECT h.country, SUM(h.events) AS total_events\nFROM Humanitarian_Assistance h\nJOIN Countries c ON h.country = c.name\nWHERE h.year >= (SELECT MAX(year) - 2 FROM Humanitarian_Assistance)\nGROUP BY h.country;", "latency_sec": 0.8227381706237793, "total_duration_sec": 0.815896822, "load_duration_sec": 0.014426968, "tokens_prompt": 132, "prompt_eval_sec": 0.013114119, "tokens_completion": 57, "completion_eval_sec": 0.786044398, "tokens_total": 189, "tokens_per_sec": 229.7207140112449, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their year filtering logic. The Reference SQL uses a fixed range (current year -3 to current year), while the Generated SQL uses a dynamic range based on MAX(year) - 2. This can lead to different results if the maximum year in the table is not the current year. For example, if the current year is 2023 but the latest year in the data is 2022, the Generated SQL would include 2020-2022, while the Reference SQL would include 2020-2023 (but only up to 2022 in practice). Additionally, the Generated SQL's subquery might not account for all edge cases in year ranges."}
{"example_id": 1852, "sql_complexity": "set operations", "prompt": "Compare coal production and employment rates in China and India between 2018 and 2020.", "context": "CREATE TABLE china_coal_production (year INT, production FLOAT); INSERT INTO china_coal_production (year, production) VALUES (2018, 3500.0), (2019, 3600.0), (2020, 3700.0); CREATE TABLE china_employment (year INT, employment FLOAT); INSERT INTO china_employment (year, employment) VALUES (2018, 8000000.0), (2019, 8100000.0), (2020, 8200000.0); CREATE TABLE india_coal_production (year INT, production FLOAT); INSERT INTO india_coal_production (year, production) VALUES (2018, 700.0), (2019, 750.0), (2020, 800.0); CREATE TABLE india_employment (year INT, employment FLOAT); INSERT INTO india_employment (year, employment) VALUES (2018, 1000000.0), (2019, 1050000.0), (2020, 1100000.0);", "reference_sql": "SELECT 'China' AS country, china_coal_production.production, china_employment.employment FROM china_coal_production INNER JOIN china_employment ON china_coal_production.year = china_employment.year WHERE china_coal_production.year BETWEEN 2018 AND 2020 UNION ALL SELECT 'India', india_coal_production.production, india_employment.employment FROM india_coal_production INNER JOIN india_employment ON india_coal_production.year = india_employment.year WHERE india_coal_production.year BETWEEN 2018 AND 2020;", "generated_sql": "SELECT \n    cp.year,\n    cp.production AS china_coal_production,\n    ce.employment AS china_employment,\n    ip.production AS india_coal_production,\n    ie.employment AS india_employment\nFROM \n    china_coal_production cp\nJOIN \n    china_employment ce ON cp.year = ce.year\nJOIN \n    india_coal_production ip ON cp.year = ip.year\nJOIN \n    india_employment ie ON cp.year = ie.year\nWHERE \n    cp.year BETWEEN 2018 AND 2020;", "raw_model_output": "<think>\n\n</think>\n\nSELECT \n    cp.year,\n    cp.production AS china_coal_production,\n    ce.employment AS china_employment,\n    ip.production AS india_coal_production,\n    ie.employment AS india_employment\nFROM \n    china_coal_production cp\nJOIN \n    china_employment ce ON cp.year = ce.year\nJOIN \n    india_coal_production ip ON cp.year = ip.year\nJOIN \n    india_employment ie ON cp.year = ie.year\nWHERE \n    cp.year BETWEEN 2018 AND 2020;", "latency_sec": 1.8665671348571777, "total_duration_sec": 1.787688374, "load_duration_sec": 0.021412257, "tokens_prompt": 374, "prompt_eval_sec": 0.037754485, "tokens_completion": 117, "completion_eval_sec": 1.726256633, "tokens_total": 491, "tokens_per_sec": 263.04974025891084, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two rows per year (China and India) with columns 'country', 'production', and 'employment', while the Generated SQL returns one row per year with separate columns for China and India's production/employment. The structure and number of rows differ, making them non-equivalent."}
{"example_id": 2535, "sql_complexity": "subqueries", "prompt": "What is the maximum safety rating for vehicles in the vehiclesafety schema?", "context": "CREATE TABLE VehicleSafety (id INT, vehicle_id INT, safetyrating INT, PRIMARY KEY (id)); CREATE TABLE Vehicles (id INT, make VARCHAR(50), model VARCHAR(50), PRIMARY KEY (id)); CREATE TABLE LuxuryVehicles (id INT, vehicle_id INT, PRIMARY KEY (id), FOREIGN KEY (vehicle_id) REFERENCES Vehicles(id));", "reference_sql": "SELECT MAX(safetyrating) FROM vehicleSafety JOIN Vehicles ON vehicleSafety.vehicle_id = Vehicles.id WHERE EXISTS (SELECT * FROM LuxuryVehicles WHERE Vehicles.id = LuxuryVehicles.vehicle_id);", "generated_sql": "SELECT MAX(safetyrating) FROM VehicleSafety;", "raw_model_output": "<think>\n\n</think>\n\nSELECT MAX(safetyrating) FROM VehicleSafety;", "latency_sec": 0.3190267086029053, "total_duration_sec": 0.251103508, "load_duration_sec": 0.014566545, "tokens_prompt": 159, "prompt_eval_sec": 0.015021309, "tokens_completion": 15, "completion_eval_sec": 0.219424409, "tokens_total": 174, "tokens_per_sec": 545.408880535388, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters vehicles to only those that exist in LuxuryVehicles (via the EXISTS clause), while the Generated SQL selects from all VehicleSafety records without any filtering. The MAX(safetyrating) could differ if non-luxury vehicles have higher safety ratings than luxury ones."}
{"example_id": 2140, "sql_complexity": "aggregation", "prompt": "What was the total amount of minerals extracted in the 'north' region for each month in 2020?", "context": "CREATE TABLE extraction(id INT, location TEXT, month INT, year INT, minerals_extracted FLOAT);INSERT INTO extraction(id, location, month, year, minerals_extracted) VALUES (1, 'north', 1, 2020, 1500), (2, 'north', 2, 2020, 1800), (3, 'south', 1, 2020, 1200);", "reference_sql": "SELECT month, SUM(minerals_extracted) FROM extraction WHERE location = 'north' AND year = 2020 GROUP BY month;", "generated_sql": "SELECT month, SUM(minerals_extracted) AS total_minerals\nFROM extraction\nWHERE location = 'north' AND year = 2020\nGROUP BY month;", "raw_model_output": "<think>\n\n</think>\n\nSELECT month, SUM(minerals_extracted) AS total_minerals\nFROM extraction\nWHERE location = 'north' AND year = 2020\nGROUP BY month;", "latency_sec": 0.6365890502929688, "total_duration_sec": 0.629900474, "load_duration_sec": 0.016928676, "tokens_prompt": 195, "prompt_eval_sec": 0.022427204, "tokens_completion": 41, "completion_eval_sec": 0.586573624, "tokens_total": 236, "tokens_per_sec": 370.7258236556047, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (month and SUM(minerals_extracted)) from the same table with identical WHERE and GROUP BY clauses. The only difference is the alias 'total_minerals' in the generated query, which does not affect the semantic result but only the column name in the output."}
{"example_id": 4779, "sql_complexity": "window functions", "prompt": "What is the average CO2 emission for the top 3 highest emitting countries since 2015?", "context": "CREATE TABLE emissions (country VARCHAR(50), year INT, co2_emission INT); INSERT INTO emissions (country, year, co2_emission) VALUES ('USA', 2015, 5373978000); INSERT INTO emissions (country, year, co2_emission) VALUES ('China', 2015, 10498600000); INSERT INTO emissions (country, year, co2_emission) VALUES ('India', 2015, 2633830000); INSERT INTO emissions (country, year, co2_emission) VALUES ('USA', 2016, 5518004000); INSERT INTO emissions (country, year, co2_emission) VALUES ('China', 2016, 10813000000); INSERT INTO emissions (country, year, co2_emission) VALUES ('India', 2016, 2799280000);", "reference_sql": "SELECT AVG(co2_emission) as avg_emission FROM (SELECT country, year, co2_emission, ROW_NUMBER() OVER (ORDER BY co2_emission DESC) as rn FROM emissions WHERE year >= 2015) t WHERE rn <= 3 GROUP BY country;", "generated_sql": "SELECT AVG(co2_emission) AS average_co2_emission\nFROM (\n    SELECT country, co2_emission\n    FROM emissions\n    WHERE year IN (2015, 2016)\n    ORDER BY co2_emission DESC\n    LIMIT 3\n) AS top_3_countries;", "raw_model_output": "<think>\n\n</think>\n\nSELECT AVG(co2_emission) AS average_co2_emission\nFROM (\n    SELECT country, co2_emission\n    FROM emissions\n    WHERE year IN (2015, 2016)\n    ORDER BY co2_emission DESC\n    LIMIT 3\n) AS top_3_countries;", "latency_sec": 1.376145839691162, "total_duration_sec": 1.094432255, "load_duration_sec": 0.014293687, "tokens_prompt": 325, "prompt_eval_sec": 0.035299018, "tokens_completion": 71, "completion_eval_sec": 1.042640497, "tokens_total": 396, "tokens_per_sec": 287.7601985040127, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the average CO2 emission per country for the top 3 entries ordered by emission (grouped by country), while the Generated SQL calculates a single average of the top 3 emissions regardless of country. The Reference SQL's grouping by country and the Generated SQL's aggregation of all top 3 entries lead to different results. Additionally, the Reference SQL includes all years >=2015, but the Generated SQL restricts to 2015/2016 (though in this case, the data only has those years). The structure and logic of the two queries differ significantly."}
{"example_id": 1015, "sql_complexity": "subqueries", "prompt": "List the top 3 most expensive eco-friendly products in Europe and their suppliers.", "context": "CREATE TABLE Suppliers (supplierID INT, supplierName VARCHAR(50), country VARCHAR(50)); CREATE TABLE Products (productID INT, productName VARCHAR(50), price DECIMAL(10,2), ecoFriendly BOOLEAN, supplierID INT);", "reference_sql": "SELECT P.productName, P.price, S.supplierName FROM (SELECT * FROM Products WHERE ecoFriendly = TRUE ORDER BY price DESC LIMIT 3) P JOIN Suppliers S ON P.supplierID = S.supplierID;", "generated_sql": "SELECT p.productID, p.productName, p.price, s.supplierName\nFROM Products p\nJOIN Suppliers s ON p.supplierID = s.supplierID\nWHERE p.ecoFriendly = TRUE AND s.country = 'Europe'\nORDER BY p.price DESC\nLIMIT 3;", "raw_model_output": "<think>\n\n</think>\n\nSELECT p.productID, p.productName, p.price, s.supplierName\nFROM Products p\nJOIN Suppliers s ON p.supplierID = s.supplierID\nWHERE p.ecoFriendly = TRUE AND s.country = 'Europe'\nORDER BY p.price DESC\nLIMIT 3;", "latency_sec": 0.9301409721374512, "total_duration_sec": 0.9196054, "load_duration_sec": 0.015710163, "tokens_prompt": 140, "prompt_eval_sec": 0.013591624, "tokens_completion": 64, "completion_eval_sec": 0.887477774, "tokens_total": 204, "tokens_per_sec": 219.32159329699326, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL filters ecoFriendly = TRUE in a subquery, then joins with Suppliers without country restrictions. The Generated SQL adds an additional WHERE condition (s.country = 'Europe') and selects an extra column (productID). The filtering criteria and selected columns differ, leading to different results."}
{"example_id": 3715, "sql_complexity": "aggregation", "prompt": "What is the average age of engines still in service for each engine type?", "context": "CREATE TABLE Engine (id INT, aircraft_id INT, engine_type VARCHAR(255), hours_since_last_service INT, manufacture_year INT); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (1, 1, 'GE90-115B', 500, 2000); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (2, 2, 'CFM56-5B', 1000, 1995); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (3, 1, 'GE90-115B', 700, 2002);", "reference_sql": "SELECT engine_type, AVG(YEAR(CURRENT_DATE) - manufacture_year) as avg_age FROM Engine GROUP BY engine_type;", "generated_sql": "SELECT engine_type, AVG(CURRENT_YEAR - manufacture_year) AS average_age\nFROM Engine\nWHERE hours_since_last_service < 1000\nGROUP BY engine_type;", "raw_model_output": "<think>\n\n</think>\n\nSELECT engine_type, AVG(CURRENT_YEAR - manufacture_year) AS average_age\nFROM Engine\nWHERE hours_since_last_service < 1000\nGROUP BY engine_type;", "latency_sec": 0.8122758865356445, "total_duration_sec": 0.657042607, "load_duration_sec": 0.019795012, "tokens_prompt": 260, "prompt_eval_sec": 0.033678175, "tokens_completion": 41, "completion_eval_sec": 0.599964572, "tokens_total": 301, "tokens_per_sec": 370.5637517860644, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the average age of all engines grouped by type, while the Generated SQL only includes engines with 'hours_since_last_service' less than 1000. The WHERE clause in the Generated SQL filters the dataset, leading to different results unless all engines meet the condition (which they don't in the sample data)."}
{"example_id": 1957, "sql_complexity": "set operations", "prompt": "What is the average temperature recorded for the 'polar_bear' species in the 'Arctic_Animals' table compared to the 'penguin' species in the 'Antarctic_Animals' table?", "context": "CREATE TABLE Arctic_Animals (species TEXT, avg_temp FLOAT); CREATE TABLE Antarctic_Animals (species TEXT, avg_temp FLOAT);", "reference_sql": "SELECT AVG(Arctic_Animals.avg_temp) FROM Arctic_Animals WHERE Arctic_Animals.species = 'polar_bear' INTERSECT SELECT AVG(Antarctic_Animals.avg_temp) FROM Antarctic_Animals WHERE Antarctic_Animals.species = 'penguin'", "generated_sql": "SELECT \n    (SELECT avg_temp FROM Arctic_Animals WHERE species = 'polar_bear') AS arctic_temp,\n    (SELECT avg_temp FROM Antarctic_Animals WHERE species = 'penguin') AS antarctic_temp;", "raw_model_output": "<think>\n\n</think>\n\nSELECT \n    (SELECT avg_temp FROM Arctic_Animals WHERE species = 'polar_bear') AS arctic_temp,\n    (SELECT avg_temp FROM Antarctic_Animals WHERE species = 'penguin') AS antarctic_temp;", "latency_sec": 0.9985969066619873, "total_duration_sec": 0.752030456, "load_duration_sec": 0.016241391, "tokens_prompt": 141, "prompt_eval_sec": 0.0130333, "tokens_completion": 52, "completion_eval_sec": 0.720632622, "tokens_total": 193, "tokens_per_sec": 193.27117750158234, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses INTERSECT to find common values between two AVG() results, returning a single column with matching values. The Generated SQL retrieves two separate scalar values in parallel columns. The first query checks for equality between the two averages (returning a result only if they match), while the second returns both values independently. Their result structures and logical operations differ fundamentally."}
{"example_id": 1311, "sql_complexity": "basic SQL", "prompt": "What is the total number of veteran job applications in Texas in the last year?", "context": "CREATE TABLE veteran_jobs (id INT, state VARCHAR(50), application_date DATE); INSERT INTO veteran_jobs (id, state, application_date) VALUES (1, 'Texas', '2021-02-15'), (2, 'California', '2021-04-10'), (3, 'Texas', '2022-01-05');", "reference_sql": "SELECT COUNT(*) FROM veteran_jobs WHERE state = 'Texas' AND application_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR);", "generated_sql": "SELECT COUNT(*) AS total_applications\nFROM veteran_jobs\nWHERE state = 'Texas'\nAND application_date >= CURRENT_DATE - INTERVAL '1 year';", "raw_model_output": "<think>\n\n</think>\n\nSELECT COUNT(*) AS total_applications\nFROM veteran_jobs\nWHERE state = 'Texas'\nAND application_date >= CURRENT_DATE - INTERVAL '1 year';", "latency_sec": 0.6974990367889404, "total_duration_sec": 0.532937907, "load_duration_sec": 0.019716605, "tokens_prompt": 173, "prompt_eval_sec": 0.016880625, "tokens_completion": 35, "completion_eval_sec": 0.494334775, "tokens_total": 208, "tokens_per_sec": 298.2082971147381, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count records where state is 'Texas' and application_date is within the last year. The date calculation syntax differs (DATE_SUB vs. CURRENT_DATE - INTERVAL), but both expressions evaluate to the same date. The column alias in the generated query does not affect the result."}
{"example_id": 2997, "sql_complexity": "window functions", "prompt": "What is the earliest capture time for each satellite image in the 'satellite_images' table?", "context": "CREATE TABLE satellite_images (image_id INT, image_url TEXT, capture_time TIMESTAMP); INSERT INTO satellite_images (image_id, image_url, capture_time) VALUES (1, 'image1.jpg', '2022-01-01 10:00:00'), (2, 'image2.jpg', '2021-05-01 10:00:00');", "reference_sql": "SELECT image_id, MIN(capture_time) OVER (PARTITION BY image_id) FROM satellite_images;", "generated_sql": "SELECT image_id, MIN(capture_time) AS earliest_capture_time\nFROM satellite_images\nGROUP BY image_id;", "raw_model_output": "<think>\n\n</think>\n\nSELECT image_id, MIN(capture_time) AS earliest_capture_time\nFROM satellite_images\nGROUP BY image_id;", "latency_sec": 0.53159499168396, "total_duration_sec": 0.438128464, "load_duration_sec": 0.014276979, "tokens_prompt": 181, "prompt_eval_sec": 0.017226323, "tokens_completion": 28, "completion_eval_sec": 0.404061545, "tokens_total": 209, "tokens_per_sec": 393.1564504359612, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries return the same result because image_id is unique. The Reference SQL uses a window function that returns the same capture_time for each row (since each partition has one row), while the Generated SQL groups by image_id (also resulting in one row per image_id with the same capture_time). The output is identical in both cases."}
{"example_id": 3743, "sql_complexity": "aggregation", "prompt": "What is the maximum budget spent on peacekeeping operations by each department?", "context": "CREATE TABLE DepartmentPeacekeeping (id INT, department VARCHAR(50), budget INT);", "reference_sql": "SELECT department, MAX(budget) FROM DepartmentPeacekeeping GROUP BY department;", "generated_sql": "SELECT department, MAX(budget) AS max_budget\nFROM DepartmentPeacekeeping\nGROUP BY department;", "raw_model_output": "<think>\n\n</think>\n\nSELECT department, MAX(budget) AS max_budget\nFROM DepartmentPeacekeeping\nGROUP BY department;", "latency_sec": 0.46813392639160156, "total_duration_sec": 0.381491917, "load_duration_sec": 0.025441463, "tokens_prompt": 104, "prompt_eval_sec": 0.0108857, "tokens_completion": 25, "completion_eval_sec": 0.343008965, "tokens_total": 129, "tokens_per_sec": 275.56216870317024, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries group by 'department' and calculate the maximum 'budget' for each group. The generated query adds an alias 'max_budget' to the MAX(budget) column, but this does not affect the semantic result set. The core logic and output data remain identical."}
{"example_id": 4664, "sql_complexity": "multiple_joins", "prompt": "Calculate the total number of volunteer hours contributed by volunteers from 'California' in 'Health' projects in 2021.", "context": "CREATE TABLE volunteers (volunteer_id INT, name VARCHAR(255), state VARCHAR(255));", "reference_sql": "SELECT SUM(vh.hours) as total_hours FROM volunteer_projects vp JOIN volunteer_hours vh ON vp.project_id = vh.project_id JOIN volunteers vol ON vh.volunteer_id = vol.volunteer_id WHERE vp.cause = 'Health' AND vol.state = 'California' AND vh.volunteer_date BETWEEN '2021-01-01' AND '2021-12-31';", "generated_sql": "SELECT SUM(hours) AS total_volunteer_hours\nFROM volunteers\nWHERE state = 'California';", "raw_model_output": "<think>\n\n</think>\n\nSELECT SUM(hours) AS total_volunteer_hours\nFROM volunteers\nWHERE state = 'California';", "latency_sec": 0.6748218536376953, "total_duration_sec": 0.364592465, "load_duration_sec": 0.01483501, "tokens_prompt": 121, "prompt_eval_sec": 0.011828345, "tokens_completion": 24, "completion_eval_sec": 0.335889263, "tokens_total": 145, "tokens_per_sec": 214.8715238227139, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates total volunteer hours for Health projects in California during 2021 by joining multiple tables and filtering on specific criteria. The Generated SQL incorrectly references a non-existent 'hours' column in the 'volunteers' table and lacks all the necessary joins and filters, making it invalid and semantically different."}
{"example_id": 251, "sql_complexity": "set operations", "prompt": "Compare the number of economic diversification projects in two regions, one in Europe and one in Oceania, by showing the project type and the number of projects in each region.", "context": "CREATE TABLE economic_diversification (region VARCHAR(50), project_type VARCHAR(50), project_start_date DATE);", "reference_sql": "SELECT 'Europe' as region, project_type, COUNT(*) as project_count FROM economic_diversification WHERE region = 'Europe' UNION ALL SELECT 'Oceania' as region, project_type, COUNT(*) as project_count FROM economic_diversification WHERE region = 'Oceania';", "generated_sql": "SELECT project_type, \n       SUM(CASE WHEN region = 'Europe' THEN 1 ELSE 0 END) AS europe_count,\n       SUM(CASE WHEN region = 'Oceania' THEN 1 ELSE 0 END) AS oceania_count\nFROM economic_diversification\nWHERE region IN ('Europe', 'Oceania')\nGROUP BY project_type;", "raw_model_output": "<think>\n\n</think>\n\nSELECT project_type, \n       SUM(CASE WHEN region = 'Europe' THEN 1 ELSE 0 END) AS europe_count,\n       SUM(CASE WHEN region = 'Oceania' THEN 1 ELSE 0 END) AS oceania_count\nFROM economic_diversification\nWHERE region IN ('Europe', 'Oceania')\nGROUP BY project_type;", "latency_sec": 1.2424700260162354, "total_duration_sec": 1.137288187, "load_duration_sec": 0.014127052, "tokens_prompt": 133, "prompt_eval_sec": 0.014631667, "tokens_completion": 80, "completion_eval_sec": 1.10645756, "tokens_total": 213, "tokens_per_sec": 171.43270705929828, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two rows per project_type (one for Europe and one for Oceania), while the Generated SQL returns one row per project_type with separate columns for Europe and Oceania counts. The result set structures differ (long vs. wide format), so they are not semantically equivalent."}
{"example_id": 610, "sql_complexity": "subqueries", "prompt": "What is the percentage of community development projects completed in 'Caribbean' in 2020?", "context": "CREATE TABLE community_projects (project_id INT, project_name TEXT, location TEXT, completion_year INT); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (1, 'Community Center', 'Southern Region, Caribbean', 2020); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (2, 'Park Renovation', 'Northern Region, Caribbean', 2019); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (3, 'Library Construction', 'Caribbean', 2020);", "reference_sql": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM community_projects WHERE location = 'Caribbean')) FROM community_projects WHERE completion_year = 2020 AND location = 'Caribbean';", "generated_sql": "SELECT \n  (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM community_projects)) AS percentage_completed_in_caribbean_2020\nFROM community_projects\nWHERE location = 'Caribbean' AND completion_year = 2020;", "raw_model_output": "<think>\n\n</think>\n\nSELECT \n  (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM community_projects)) AS percentage_completed_in_caribbean_2020\nFROM community_projects\nWHERE location = 'Caribbean' AND completion_year = 2020;", "latency_sec": 0.9441399574279785, "total_duration_sec": 0.893896034, "load_duration_sec": 0.014057158, "tokens_prompt": 220, "prompt_eval_sec": 0.021179954, "tokens_completion": 60, "completion_eval_sec": 0.855997559, "tokens_total": 280, "tokens_per_sec": 296.56620059040256, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the percentage of 2020 Caribbean projects relative to all Caribbean projects (denominator: COUNT(*) WHERE location = 'Caribbean'), while the Generated SQL uses the total projects in the entire table as the denominator (COUNT(*) without location filter). This difference in denominators makes the queries non-equivalent."}
{"example_id": 421, "sql_complexity": "set operations", "prompt": "What is the combined landfill capacity for 'City A' and 'City B'?", "context": "CREATE TABLE landfill_capacity (city VARCHAR(255), capacity INT); INSERT INTO landfill_capacity (city, capacity) VALUES ('City A', 500000), ('City B', 600000);", "reference_sql": "SELECT SUM(capacity) FROM (SELECT capacity FROM landfill_capacity WHERE city = 'City A' UNION ALL SELECT capacity FROM landfill_capacity WHERE city = 'City B') AS combined_capacity;", "generated_sql": "SELECT SUM(capacity) AS combined_capacity\nFROM landfill_capacity\nWHERE city IN ('City A', 'City B');", "raw_model_output": "<think>\n\n</think>\n\nSELECT SUM(capacity) AS combined_capacity\nFROM landfill_capacity\nWHERE city IN ('City A', 'City B');", "latency_sec": 0.6327660083770752, "total_duration_sec": 0.447850708, "load_duration_sec": 0.024698005, "tokens_prompt": 138, "prompt_eval_sec": 0.011989472, "tokens_completion": 29, "completion_eval_sec": 0.409129225, "tokens_total": 167, "tokens_per_sec": 263.9206243526313, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of capacities for 'City A' and 'City B'. The reference query uses a subquery with UNION ALL to combine the capacities of each city individually, while the generated query directly filters the cities using IN. Since both approaches sum the same set of capacity values (500000 + 600000), they produce identical results."}
{"example_id": 880, "sql_complexity": "aggregation", "prompt": "Show veteran employment statistics for each state in the 'veteran_employment' table", "context": "CREATE TABLE veteran_employment (employee_id INT, state VARCHAR(2), job_title VARCHAR(50), employment_date DATE);", "reference_sql": "SELECT state, COUNT(*) as veteran_employees FROM veteran_employment WHERE state IN ('CA', 'NY', 'TX', 'FL', 'PA') GROUP BY state;", "generated_sql": "SELECT state, COUNT(*) AS veteran_employment_count\nFROM veteran_employment\nGROUP BY state;", "raw_model_output": "<think>\n\n</think>\n\nSELECT state, COUNT(*) AS veteran_employment_count\nFROM veteran_employment\nGROUP BY state;", "latency_sec": 0.5926210880279541, "total_duration_sec": 0.374892459, "load_duration_sec": 0.013501936, "tokens_prompt": 116, "prompt_eval_sec": 0.01237173, "tokens_completion": 25, "completion_eval_sec": 0.34651518, "tokens_total": 141, "tokens_per_sec": 237.92605907629968, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters results to only include records where state is in ('CA', 'NY', 'TX', 'FL', 'PA'), while the Generated SQL includes all states present in the table. The GROUP BY state clause is equivalent, but the WHERE condition in the Reference SQL restricts the output to specific states, making the queries non-equivalent."}
{"example_id": 454, "sql_complexity": "single join", "prompt": "Which excavation sites have more than 10 artifacts?", "context": "CREATE TABLE ExcavationSite (SiteID INT, SiteName VARCHAR(50)); INSERT INTO ExcavationSite (SiteID, SiteName) VALUES (1, 'Site A'), (2, 'Site B'), (3, 'Site C'); CREATE TABLE Artifact (ArtifactID INT, SiteID INT, ObjectType VARCHAR(50)); INSERT INTO Artifact (ArtifactID, SiteID, ObjectType) VALUES (1, 1, 'Pottery'), (2, 1, 'Tool'), (3, 2, 'Statue'), (4, 2, 'Bead'), (5, 3, 'Bead'), (6, 3, 'Bead'), (7, 3, 'Bead'), (8, 3, 'Bead'), (9, 3, 'Bead'), (10, 3, 'Bead'), (11, 3, 'Bead');", "reference_sql": "SELECT e.SiteName FROM ExcavationSite e JOIN Artifact a ON e.SiteID = a.SiteID GROUP BY e.SiteName HAVING COUNT(a.ArtifactID) > 10;", "generated_sql": "SELECT e.SiteName\nFROM ExcavationSite e\nJOIN Artifact a ON e.SiteID = a.SiteID\nGROUP BY e.SiteID, e.SiteName\nHAVING COUNT(a.ArtifactID) > 10;", "raw_model_output": "<think>\n\n</think>\n\nSELECT e.SiteName\nFROM ExcavationSite e\nJOIN Artifact a ON e.SiteID = a.SiteID\nGROUP BY e.SiteID, e.SiteName\nHAVING COUNT(a.ArtifactID) > 10;", "latency_sec": 1.0776481628417969, "total_duration_sec": 0.800175658, "load_duration_sec": 0.013675591, "tokens_prompt": 278, "prompt_eval_sec": 0.028312807, "tokens_completion": 52, "completion_eval_sec": 0.756232654, "tokens_total": 330, "tokens_per_sec": 306.22239370758837, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries group by SiteID and SiteName (either explicitly or implicitly) and filter for sites with more than 10 artifacts. Since SiteID and SiteName are functionally dependent (each SiteID maps to a unique SiteName in the provided data), grouping by either produces the same result. The HAVING clause and join logic are identical, ensuring semantic equivalence in this context."}
{"example_id": 1086, "sql_complexity": "aggregation", "prompt": "What is the total CO2 emission for each equipment type, excluding equipment that is older than 8 years?", "context": "CREATE TABLE EmissionData (EquipmentID INT, EquipmentType VARCHAR(50), CO2Emission INT, Age INT); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (1, 'Excavator', 50, 8); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (2, 'Haul Truck', 70, 7); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (3, 'Shovel', 30, 6); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (4, 'Drilling Rig', 40, 3);", "reference_sql": "SELECT EquipmentType, SUM(CO2Emission) as TotalCO2Emission FROM EmissionData WHERE Age <= 8 GROUP BY EquipmentType;", "generated_sql": "SELECT EquipmentType, SUM(CO2Emission) AS TotalCO2Emission\nFROM EmissionData\nWHERE Age <= 8\nGROUP BY EquipmentType;", "raw_model_output": "<think>\n\n</think>\n\nSELECT EquipmentType, SUM(CO2Emission) AS TotalCO2Emission\nFROM EmissionData\nWHERE Age <= 8\nGROUP BY EquipmentType;", "latency_sec": 0.6994960308074951, "total_duration_sec": 0.615401454, "load_duration_sec": 0.014701702, "tokens_prompt": 259, "prompt_eval_sec": 0.025775167, "tokens_completion": 39, "completion_eval_sec": 0.572679949, "tokens_total": 298, "tokens_per_sec": 426.02100208630225, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select EquipmentType and sum CO2Emission where Age <= 8, grouping by EquipmentType. The only differences are formatting (capitalization of keywords and line breaks), which do not affect semantic meaning."}
{"example_id": 3455, "sql_complexity": "basic SQL", "prompt": "What are the names of all innovation projects in the 'rural_infrastructure' table, excluding those with a budget over 50000?", "context": "CREATE TABLE rural_infrastructure (name VARCHAR(255), budget INT); INSERT INTO rural_infrastructure (name, budget) VALUES ('Dam Construction', 40000), ('Well Digging', 30000), ('Irrigation System', 70000);", "reference_sql": "SELECT name FROM rural_infrastructure WHERE budget <= 50000;", "generated_sql": "SELECT name FROM rural_infrastructure WHERE budget <= 50000;", "raw_model_output": "<think>\n\n</think>\n\nSELECT name FROM rural_infrastructure WHERE budget <= 50000;", "latency_sec": 0.3370089530944824, "total_duration_sec": 0.329802524, "load_duration_sec": 0.01347485, "tokens_prompt": 166, "prompt_eval_sec": 0.014930032, "tokens_completion": 21, "completion_eval_sec": 0.29934999, "tokens_total": 187, "tokens_per_sec": 554.8814008735651, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They select the 'name' column from the 'rural_infrastructure' table where the 'budget' is less than or equal to 50000. The result set will contain the same rows ('Dam Construction' and 'Well Digging') as the condition matches the same values in both cases."}
{"example_id": 3936, "sql_complexity": "window functions", "prompt": "What is the total investment per client for each investment type?", "context": "CREATE TABLE clients (client_id INT, name TEXT, investment_type TEXT, investment FLOAT); INSERT INTO clients (client_id, name, investment_type, investment) VALUES (1, 'John Doe', 'Stocks', 3000.00), (1, 'John Doe', 'Bonds', 2000.00), (2, 'Jane Smith', 'Stocks', 5000.00);", "reference_sql": "SELECT client_id, name, investment_type, SUM(investment) OVER (PARTITION BY client_id, investment_type ORDER BY client_id) as total_investment FROM clients;", "generated_sql": "SELECT client_id, investment_type, SUM(investment) AS total_investment\nFROM clients\nGROUP BY client_id, investment_type;", "raw_model_output": "<think>\n\n</think>\n\nSELECT client_id, investment_type, SUM(investment) AS total_investment\nFROM clients\nGROUP BY client_id, investment_type;", "latency_sec": 0.607194185256958, "total_duration_sec": 0.496419238, "load_duration_sec": 0.023844987, "tokens_prompt": 177, "prompt_eval_sec": 0.01634233, "tokens_completion": 32, "completion_eval_sec": 0.454301938, "tokens_total": 209, "tokens_per_sec": 344.2061947802637, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses a window function to retain original rows while adding a cumulative sum, whereas the Generated SQL aggregates rows into summary values. The Reference includes 'name' and returns all original rows with summed values, while the Generated SQL removes 'name', groups by client_id/investment_type, and returns one row per group. The output structures and results differ."}
{"example_id": 1838, "sql_complexity": "window functions", "prompt": "What are the top 3 species with the most sightings across all arctic research stations?", "context": "CREATE TABLE research_station (id INT, name TEXT); INSERT INTO research_station (id, name) VALUES (1, 'Station A'); INSERT INTO research_station (id, name) VALUES (2, 'Station B'); CREATE TABLE species_observations (station_id INT, species_name TEXT, sightings INT); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (1, 'Species 1', 10); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (1, 'Species 2', 5); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (2, 'Species 1', 8); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (2, 'Species 3', 15);", "reference_sql": "SELECT species_name, SUM(sightings) as total_sightings, RANK() OVER (ORDER BY SUM(sightings) DESC) as rank FROM species_observations GROUP BY species_name HAVING rank <= 3;", "generated_sql": "SELECT species_name, SUM(sightings) AS total_sightings\nFROM species_observations\nGROUP BY species_name\nORDER BY total_sightings DESC\nLIMIT 3;", "raw_model_output": "<think>\n\n</think>\n\nSELECT species_name, SUM(sightings) AS total_sightings\nFROM species_observations\nGROUP BY species_name\nORDER BY total_sightings DESC\nLIMIT 3;", "latency_sec": 0.879702091217041, "total_duration_sec": 0.658680132, "load_duration_sec": 0.01512341, "tokens_prompt": 258, "prompt_eval_sec": 0.026754792, "tokens_completion": 42, "completion_eval_sec": 0.614638044, "tokens_total": 300, "tokens_per_sec": 341.02453886969755, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL includes a RANK() column and uses HAVING rank <= 3, which is invalid syntax because window functions like RANK() cannot be used in HAVING clauses. The Generated SQL correctly uses ORDER BY and LIMIT to get top 3 results. Additionally, the Reference SQL would return an extra 'rank' column not present in the Generated SQL's output."}
{"example_id": 3091, "sql_complexity": "single join", "prompt": "Find the number of hybrid vehicles sold in the US, Germany, and Japan.", "context": "CREATE TABLE vehicle_sales (sale_id INT, vehicle_id INT, country VARCHAR(20), quantity INT); CREATE TABLE vehicles (vehicle_id INT, model VARCHAR(20), manufacture VARCHAR(20), vehicle_type VARCHAR(20));", "reference_sql": "SELECT SUM(vs.quantity) FROM vehicle_sales vs JOIN vehicles v ON vs.vehicle_id = v.vehicle_id WHERE v.vehicle_type = 'hybrid' AND vs.country IN ('US', 'Germany', 'Japan');", "generated_sql": "SELECT COUNT(*) AS hybrid_vehicles_sold\nFROM vehicle_sales vs\nJOIN vehicles v ON vs.vehicle_id = v.vehicle_id\nWHERE v.vehicle_type = 'hybrid'\nAND vs.country IN ('US', 'Germany', 'Japan');", "raw_model_output": "<think>\n\n</think>\n\nSELECT COUNT(*) AS hybrid_vehicles_sold\nFROM vehicle_sales vs\nJOIN vehicles v ON vs.vehicle_id = v.vehicle_id\nWHERE v.vehicle_type = 'hybrid'\nAND vs.country IN ('US', 'Germany', 'Japan');", "latency_sec": 0.8819441795349121, "total_duration_sec": 0.774208588, "load_duration_sec": 0.019329945, "tokens_prompt": 137, "prompt_eval_sec": 0.015497338, "tokens_completion": 53, "completion_eval_sec": 0.73501381, "tokens_total": 190, "tokens_per_sec": 215.43313557576323, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates the total quantity sold (SUM(vs.quantity)), while the Generated SQL counts the number of sales records (COUNT(*)). These would produce different numerical results unless every sale record had a quantity of 1."}
{"example_id": 2399, "sql_complexity": "set operations", "prompt": "What is the average duration of criminal trials for Indigenous defendants compared to non-Indigenous defendants in Canada and New Zealand?", "context": "CREATE TABLE canada_criminal_trials (id INT, defendant_type VARCHAR(255), days_to_completion INT); INSERT INTO canada_criminal_trials (id, defendant_type, days_to_completion) VALUES (1, 'Indigenous', 60), (2, 'Non-Indigenous', 45);CREATE TABLE nz_criminal_trials (id INT, defendant_type VARCHAR(255), days_to_completion INT); INSERT INTO nz_criminal_trials (id, defendant_type, days_to_completion) VALUES (1, 'Indigenous', 70), (2, 'Non-Indigenous', 50);", "reference_sql": "SELECT AVG(days_to_completion) AS avg_duration FROM canada_criminal_trials WHERE defendant_type = 'Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM canada_criminal_trials WHERE defendant_type = 'Non-Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM nz_criminal_trials WHERE defendant_type = 'Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM nz_criminal_trials WHERE defendant_type = 'Non-Indigenous';", "generated_sql": "SELECT \n  'Canada' AS country, \n  defendant_type, \n  AVG(days_to_completion) AS average_duration\nFROM \n  canada_criminal_trials\nGROUP BY \n  defendant_type\nUNION ALL\nSELECT \n  'New Zealand' AS country, \n  defendant_type, \n  AVG(days_to_completion) AS average_duration\nFROM \n  nz_criminal_trials\nGROUP BY \n  defendant_type;", "raw_model_output": "<think>\n\n</think>\n\nSELECT \n  'Canada' AS country, \n  defendant_type, \n  AVG(days_to_completion) AS average_duration\nFROM \n  canada_criminal_trials\nGROUP BY \n  defendant_type\nUNION ALL\nSELECT \n  'New Zealand' AS country, \n  defendant_type, \n  AVG(days_to_completion) AS average_duration\nFROM \n  nz_criminal_trials\nGROUP BY \n  defendant_type;", "latency_sec": 1.4115607738494873, "total_duration_sec": 1.316489904, "load_duration_sec": 0.02131176, "tokens_prompt": 224, "prompt_eval_sec": 0.021169818, "tokens_completion": 90, "completion_eval_sec": 1.271773257, "tokens_total": 314, "tokens_per_sec": 222.44879980880043, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL returns four rows with only the average duration values, while the Generated SQL adds a 'country' column and returns three columns per row. The structure of the result sets differs, making them non-equivalent despite calculating the same average values."}
{"example_id": 2972, "sql_complexity": "set operations", "prompt": "How many indigenous communities are in the Arctic Research Station 13 and 14?", "context": "CREATE TABLE Arctic_Research_Station_13 (id INT, community TEXT); CREATE TABLE Arctic_Research_Station_14 (id INT, community TEXT);", "reference_sql": "SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_13; SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_14; SELECT COUNT(DISTINCT community) FROM (SELECT * FROM Arctic_Research_Station_13 UNION ALL SELECT * FROM Arctic_Research_Station_14) AS Arctic_Communities;", "generated_sql": "SELECT COUNT(DISTINCT community) \nFROM Arctic_Research_Station_13 \nUNION ALL \nSELECT COUNT(DISTINCT community) \nFROM Arctic_Research_Station_14;", "raw_model_output": "<think>\n\n</think>\n\nSELECT COUNT(DISTINCT community) \nFROM Arctic_Research_Station_13 \nUNION ALL \nSELECT COUNT(DISTINCT community) \nFROM Arctic_Research_Station_14;", "latency_sec": 0.7877569198608398, "total_duration_sec": 0.669773637, "load_duration_sec": 0.030207139, "tokens_prompt": 124, "prompt_eval_sec": 0.013005445, "tokens_completion": 45, "completion_eval_sec": 0.624016204, "tokens_total": 169, "tokens_per_sec": 214.533183700696, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL executes three separate queries: two COUNT(DISTINCT community) on individual tables and one combined count after unioning both tables. The Generated SQL combines only the first two queries with UNION ALL, returning two rows instead of three. Additionally, the third query in the Reference SQL (unioned count) is not present in the Generated SQL, making them semantically different."}
{"example_id": 5576, "sql_complexity": "window functions", "prompt": "Who are the top 5 users with the most followers, and what is their location?", "context": "CREATE TABLE user_data (user_id INT, name VARCHAR(50), followers INT, location VARCHAR(50)); INSERT INTO user_data (user_id, name, followers, location) VALUES (1, 'Alice', 10000, 'New York'), (2, 'Bob', 15000, 'California'), (3, 'Charlie', 12000, 'Texas'), (4, 'David', 8000, 'Florida'), (5, 'Eve', 9000, 'Illinois');", "reference_sql": "SELECT name, location FROM (SELECT name, location, ROW_NUMBER() OVER (ORDER BY followers DESC) AS rank FROM user_data) AS user_ranks WHERE rank <= 5;", "generated_sql": "SELECT user_id, name, followers, location\nFROM user_data\nORDER BY followers DESC\nLIMIT 5;", "raw_model_output": "<think>\n\n</think>\n\nSELECT user_id, name, followers, location\nFROM user_data\nORDER BY followers DESC\nLIMIT 5;", "latency_sec": 0.7518489360809326, "total_duration_sec": 0.457109688, "load_duration_sec": 0.020241797, "tokens_prompt": 210, "prompt_eval_sec": 0.027611612, "tokens_completion": 28, "completion_eval_sec": 0.405174336, "tokens_total": 238, "tokens_per_sec": 316.5529517679341, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL returns only 'name' and 'location' columns from the top 5 users by followers, while the Generated SQL returns all columns (user_id, name, followers, location) for the top 5 users. The column sets differ, making their result structures incompatible."}
{"example_id": 1560, "sql_complexity": "basic SQL", "prompt": "What is the average media literacy score for users in the 'Young Adult' age group who have completed at least one disinformation detection course?", "context": "CREATE TABLE users (id INT, age VARCHAR(20), media_literacy_score INT, courses_completed INT);", "reference_sql": "SELECT AVG(media_literacy_score) FROM users WHERE age = 'Young Adult' AND courses_completed > 0;", "generated_sql": "SELECT AVG(media_literacy_score) AS average_media_literacy_score\nFROM users\nWHERE age = 'Young Adult' AND courses_completed >= 1;", "raw_model_output": "<think>\n\n</think>\n\nSELECT AVG(media_literacy_score) AS average_media_literacy_score\nFROM users\nWHERE age = 'Young Adult' AND courses_completed >= 1;", "latency_sec": 0.5795812606811523, "total_duration_sec": 0.57289085, "load_duration_sec": 0.03129052, "tokens_prompt": 124, "prompt_eval_sec": 0.013265768, "tokens_completion": 38, "completion_eval_sec": 0.526363811, "tokens_total": 162, "tokens_per_sec": 279.51214262795463, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The WHERE clauses 'courses_completed > 0' and 'courses_completed >= 1' are mathematically equivalent for integer values. Both conditions filter rows where courses_completed is 1 or higher. The generated query adds an alias to the output column, but this does not affect the semantic result."}
{"example_id": 1201, "sql_complexity": "basic SQL", "prompt": "What is the maximum energy efficiency rating of hydroelectric dams in Canada?", "context": "CREATE TABLE hydro_dams (id INT, name TEXT, country TEXT, energy_efficiency_rating FLOAT); INSERT INTO hydro_dams (id, name, country, energy_efficiency_rating) VALUES (1, 'Robert-Bourassa', 'Canada', 0.94), (2, 'Churchill Falls', 'Canada', 0.92);", "reference_sql": "SELECT MAX(energy_efficiency_rating) FROM hydro_dams WHERE country = 'Canada';", "generated_sql": "SELECT MAX(energy_efficiency_rating) FROM hydro_dams WHERE country = 'Canada';", "raw_model_output": "<think>\n\n</think>\n\nSELECT MAX(energy_efficiency_rating) FROM hydro_dams WHERE country = 'Canada';", "latency_sec": 0.4441509246826172, "total_duration_sec": 0.372597578, "load_duration_sec": 0.024267225, "tokens_prompt": 160, "prompt_eval_sec": 0.017138698, "tokens_completion": 23, "completion_eval_sec": 0.328267729, "tokens_total": 183, "tokens_per_sec": 412.02210741938393, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They select the maximum energy_efficiency_rating from the hydro_dams table where the country is 'Canada'. The SQL syntax, table name, column names, and conditions are exactly the same in both queries."}
{"example_id": 4243, "sql_complexity": "single join", "prompt": "How many orders were placed by new and returning customers in each month of the year 2021?'", "context": "CREATE TABLE customer (id INT, first_order_date DATE, last_order_date DATE);", "reference_sql": "INSERT INTO customer (id, first_order_date, last_order_date) SELECT customer_id, MIN(order_date) AS first_order_date, MAX(order_date) AS last_order_date FROM orders GROUP BY customer_id; SELECT YEAR(order_date) AS year, MONTH(order_date) AS month, CASE WHEN DATEDIFF(last_order_date, first_order_date) > 30 THEN 'returning' ELSE 'new' END AS customer_type, COUNT(DISTINCT id) AS num_orders FROM orders JOIN customer ON orders.customer_id = customer.id WHERE YEAR(order_date) = 2021 GROUP BY year, month, customer_type;", "generated_sql": "SELECT \n    EXTRACT(MONTH FROM order_date) AS month,\n    COUNT(DISTINCT customer_id) AS num_customers,\n    COUNT(*) AS total_orders\nFROM \n    orders\nWHERE \n    order_date BETWEEN '2021-01-01' AND '2021-12-31'\nGROUP BY \n    EXTRACT(MONTH FROM order_date)\nORDER BY \n    month;", "raw_model_output": "<think>\n\n</think>\n\nSELECT \n    EXTRACT(MONTH FROM order_date) AS month,\n    COUNT(DISTINCT customer_id) AS num_customers,\n    COUNT(*) AS total_orders\nFROM \n    orders\nWHERE \n    order_date BETWEEN '2021-01-01' AND '2021-12-31'\nGROUP BY \n    EXTRACT(MONTH FROM order_date)\nORDER BY \n    month;", "latency_sec": 1.6162140369415283, "total_duration_sec": 1.333408303, "load_duration_sec": 0.013483952, "tokens_prompt": 111, "prompt_eval_sec": 0.013117929, "tokens_completion": 95, "completion_eval_sec": 1.304632648, "tokens_total": 206, "tokens_per_sec": 127.45836584232853, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates customer retention types (new/returning) based on order date ranges and groups by year/month/customer_type, while the Generated SQL counts monthly customers and total orders without considering customer type or using the customer table. The schema usage, aggregation logic, and output columns differ significantly."}
{"example_id": 2321, "sql_complexity": "subqueries", "prompt": "What are the names and types of vessels used in research expeditions in the regions with the lowest ocean acidification levels?", "context": "CREATE TABLE ocean_acidification (id INT PRIMARY KEY, region VARCHAR(255), year INT, acidification_level INT); INSERT INTO ocean_acidification (id, region, year, acidification_level) VALUES (1, 'Arctic Ocean', 2018, 20), (2, 'Southern Ocean', 2019, 22); CREATE TABLE expedition_vessels (id INT PRIMARY KEY, name VARCHAR(255), type VARCHAR(255), region VARCHAR(255)); INSERT INTO expedition_vessels (id, name, type, region) VALUES (1, 'Sea Researcher', 'Research Vessel', 'Arctic Ocean');", "reference_sql": "SELECT v.name, v.type FROM expedition_vessels v INNER JOIN ocean_acidification oa ON v.region = oa.region WHERE oa.acidification_level = (SELECT MIN(acidification_level) FROM ocean_acidification);", "generated_sql": "SELECT v.name, v.type\nFROM expedition_vessels v\nJOIN ocean_acidification a ON v.region = a.region\nWHERE a.acidification_level = (\n    SELECT MIN(acidification_level)\n    FROM ocean_acidification\n);", "raw_model_output": "<think>\n\n</think>\n\nSELECT v.name, v.type\nFROM expedition_vessels v\nJOIN ocean_acidification a ON v.region = a.region\nWHERE a.acidification_level = (\n    SELECT MIN(acidification_level)\n    FROM ocean_acidification\n);", "latency_sec": 0.9599616527557373, "total_duration_sec": 0.861738263, "load_duration_sec": 0.026079656, "tokens_prompt": 243, "prompt_eval_sec": 0.024692957, "tokens_completion": 56, "completion_eval_sec": 0.808407718, "tokens_total": 299, "tokens_per_sec": 311.4707750478036, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The two queries are semantically equivalent. The only difference is the alias name used for the ocean_acidification table (oa vs. a), which does not affect the query's logic or result. Both queries perform the same INNER JOIN on region, filter using the same subquery to find the minimum acidification_level, and select the same columns from expedition_vessels."}
{"example_id": 4349, "sql_complexity": "multiple_joins", "prompt": "Show the research grants awarded to professors in the Computer Science department.", "context": "CREATE TABLE departments (id INT, name VARCHAR(50)); INSERT INTO departments (id, name) VALUES (1, 'Computer Science'), (2, 'Mathematics'); CREATE TABLE professors (id INT, name VARCHAR(50), department_id INT); INSERT INTO professors (id, name, department_id) VALUES (1, 'John Smith', 1), (2, 'Jane Doe', 2); CREATE TABLE grants (id INT, professor_id INT, year INT, amount FLOAT); INSERT INTO grants (id, professor_id, year, amount) VALUES (1, 1, 2021, 5000.0), (2, 2, 2020, 7000.0);", "reference_sql": "SELECT professors.name, grants.amount FROM professors INNER JOIN grants ON professors.id = grants.professor_id INNER JOIN departments ON professors.department_id = departments.id WHERE departments.name = 'Computer Science';", "generated_sql": "SELECT g.amount\nFROM grants g\nJOIN professors p ON g.professor_id = p.id\nJOIN departments d ON p.department_id = d.id\nWHERE d.name = 'Computer Science';", "raw_model_output": "<think>\n\n</think>\n\nSELECT g.amount\nFROM grants g\nJOIN professors p ON g.professor_id = p.id\nJOIN departments d ON p.department_id = d.id\nWHERE d.name = 'Computer Science';", "latency_sec": 0.8914129734039307, "total_duration_sec": 0.677229062, "load_duration_sec": 0.01475738, "tokens_prompt": 241, "prompt_eval_sec": 0.024361838, "tokens_completion": 44, "completion_eval_sec": 0.635720679, "tokens_total": 285, "tokens_per_sec": 319.717132802886, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects both 'professors.name' and 'grants.amount', while the Generated SQL only selects 'grants.amount'. The join conditions and WHERE clause are equivalent, but the selected columns differ, leading to different result structures."}
{"example_id": 476, "sql_complexity": "basic SQL", "prompt": "Insert new food safety records for locations \"A123\", \"B456\", and \"C789\"", "context": "CREATE TABLE food_safety_records (id INT, location VARCHAR(255), inspection_date DATE, violation_count INT);", "reference_sql": "INSERT INTO food_safety_records (location, inspection_date, violation_count) VALUES ('A123', '2022-03-01', 0), ('B456', '2022-03-05', 2), ('C789', '2022-03-10', 1);", "generated_sql": "INSERT INTO food_safety_records (location) VALUES ('A123'), ('B456'), ('C789');", "raw_model_output": "<think>\n\n</think>\n\nINSERT INTO food_safety_records (location) VALUES ('A123'), ('B456'), ('C789');", "latency_sec": 0.6030302047729492, "total_duration_sec": 0.486885014, "load_duration_sec": 0.013266197, "tokens_prompt": 123, "prompt_eval_sec": 0.013012701, "tokens_completion": 33, "completion_eval_sec": 0.458234246, "tokens_total": 156, "tokens_per_sec": 258.69350948803066, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL inserts all four columns (location, inspection_date, violation_count) with specific values, while the Generated SQL only inserts the 'location' column. The other columns (id, inspection_date, violation_count) would either be NULL or use default values, leading to different data being stored. Semantically, they are not equivalent as they don't produce the same dataset."}
{"example_id": 2908, "sql_complexity": "single join", "prompt": "List all co-owners and the properties they own in New York, NY.", "context": "CREATE TABLE properties (id INT, city VARCHAR(50), price INT); CREATE TABLE co_owners (property_id INT, owner_name VARCHAR(50)); INSERT INTO properties (id, city, price) VALUES (1, 'New York', 800000), (2, 'Los Angeles', 600000); INSERT INTO co_owners (property_id, owner_name) VALUES (1, 'David'), (1, 'Ella'), (2, 'Frank');", "reference_sql": "SELECT properties.city, co_owners.owner_name FROM properties INNER JOIN co_owners ON properties.id = co_owners.property_id WHERE properties.city = 'New York';", "generated_sql": "SELECT co_owners.owner_name, properties.id\nFROM co_owners\nJOIN properties ON co_owners.property_id = properties.id\nWHERE properties.city = 'New York';", "raw_model_output": "<think>\n\n</think>\n\nSELECT co_owners.owner_name, properties.id\nFROM co_owners\nJOIN properties ON co_owners.property_id = properties.id\nWHERE properties.city = 'New York';", "latency_sec": 0.7447361946105957, "total_duration_sec": 0.609276253, "load_duration_sec": 0.014134086, "tokens_prompt": 194, "prompt_eval_sec": 0.021027677, "tokens_completion": 40, "completion_eval_sec": 0.571524116, "tokens_total": 234, "tokens_per_sec": 314.20522017511564, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects 'properties.city' and 'co_owners.owner_name', while the Generated SQL selects 'co_owners.owner_name' and 'properties.id'. Although both queries join the same tables and filter by 'New York', the column outputs differ in both name and content (city vs. property ID), resulting in different result sets."}
{"example_id": 636, "sql_complexity": "set operations", "prompt": "Insert new data into the 'cosmetic_ingredients' table for a vegan eyeshadow product by brand 'Ara' with ingredients 'Mica', 'Iron Oxide', 'Titanium Dioxide' and 'Zinc Oxide'.", "context": "CREATE TABLE cosmetic_ingredients (ingredient_id INT, product_name TEXT, brand_name TEXT, ingredient_type TEXT);", "reference_sql": "INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type) VALUES (NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient'); INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type, ingredient_name) SELECT ingredient_id, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Mica' FROM cosmetic_ingredients WHERE ingredient_name = 'Mica' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Iron Oxide' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Titanium Dioxide' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Zinc Oxide';", "generated_sql": "INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type)\nVALUES (1, 'Vegan Eyeshadow', 'Ara', 'Mica'), (2, 'Vegan Eyeshadow', 'Ara', 'Iron Oxide'), (3, 'Vegan Eyeshadow', 'Ara', 'Titanium Dioxide'), (4, 'Vegan Eyeshadow', 'Ara', 'Zinc Oxide');", "raw_model_output": "<think>\n\n</think>\n\nINSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type)\nVALUES (1, 'Vegan Eyeshadow', 'Ara', 'Mica'), (2, 'Vegan Eyeshadow', 'Ara', 'Iron Oxide'), (3, 'Vegan Eyeshadow', 'Ara', 'Titanium Dioxide'), (4, 'Vegan Eyeshadow', 'Ara', 'Zinc Oxide');", "latency_sec": 1.664959192276001, "total_duration_sec": 1.428633241, "load_duration_sec": 0.01431307, "tokens_prompt": 143, "prompt_eval_sec": 0.013471182, "tokens_completion": 101, "completion_eval_sec": 1.398887868, "tokens_total": 244, "tokens_per_sec": 146.55013836492398, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL inserts a row with ingredient_type 'Ingredient' and additional rows via a SELECT, while the Generated SQL directly inserts rows with specific ingredient_ids and ingredient_type values matching the actual ingredient names. The Reference SQL's first INSERT adds a row with ingredient_type 'Ingredient' (not present in Generated SQL), and the SELECT part may include existing ingredient_ids from the table, whereas the Generated SQL uses explicit numeric IDs. The two queries do not produce identical results."}
{"example_id": 3404, "sql_complexity": "multiple_joins", "prompt": "What are the names of startups that have received funding from investors with over 3 million funds, and are involved in Genetic Research or Bioprocess Engineering?", "context": "CREATE TABLE public.investors ( id SERIAL PRIMARY KEY, name VARCHAR(100), type VARCHAR(50), funds INTEGER ); CREATE TABLE public.investments ( id SERIAL PRIMARY KEY, investor_id INTEGER, startup_id INTEGER ); CREATE TABLE public.startups ( id SERIAL PRIMARY KEY, name VARCHAR(100), industry VARCHAR(50), funding INTEGER );", "reference_sql": "SELECT startups.name FROM public.startups JOIN public.investments ON startups.id = investments.startup_id JOIN public.investors ON investments.investor_id = investors.id WHERE (startups.industry = 'Genetic Research' OR startups.industry = 'Bioprocess Engineering') AND investors.funds > 3000000;", "generated_sql": "SELECT DISTINCT s.name\nFROM startups s\nJOIN investments i ON s.id = i.startup_id\nJOIN investors inv ON i.investor_id = inv.id\nWHERE inv.funds > 3000000\n  AND s.industry IN ('Genetic Research', 'Bioprocess Engineering');", "raw_model_output": "<think>\n\n</think>\n\nSELECT DISTINCT s.name\nFROM startups s\nJOIN investments i ON s.id = i.startup_id\nJOIN investors inv ON i.investor_id = inv.id\nWHERE inv.funds > 3000000\n  AND s.industry IN ('Genetic Research', 'Bioprocess Engineering');", "latency_sec": 1.3236892223358154, "total_duration_sec": 1.018951771, "load_duration_sec": 0.020278999, "tokens_prompt": 178, "prompt_eval_sec": 0.018195135, "tokens_completion": 70, "completion_eval_sec": 0.978144774, "tokens_total": 248, "tokens_per_sec": 187.35515543623822, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their handling of duplicate results. The generated query uses DISTINCT to eliminate duplicates, while the reference query does not. If a startup has multiple investments from qualifying investors, the reference query could return duplicate startup names whereas the generated query would not. This difference in output behavior makes them non-equivalent."}
{"example_id": 134, "sql_complexity": "subqueries", "prompt": "Who are the top 3 authors with the most citations in the Mathematics department in the past 5 years?", "context": "CREATE TABLE authors (id INT, name VARCHAR(50), department VARCHAR(50)); INSERT INTO authors (id, name, department) VALUES (1, 'Author Name', 'Mathematics'); CREATE TABLE publications (id INT, title VARCHAR(100), author VARCHAR(50), journal VARCHAR(50), year INT, cites INT); INSERT INTO publications (id, title, author, journal, year, cites) VALUES (1, 'Publication Title', 'Author Name', 'Journal Name', 2021, 10);", "reference_sql": "SELECT author, SUM(cites) as total_cites FROM publications WHERE author IN (SELECT name FROM authors WHERE department = 'Mathematics') AND year BETWEEN YEAR(CURRENT_DATE) - 5 AND YEAR(CURRENT_DATE) GROUP BY author ORDER BY total_cites DESC LIMIT 3;", "generated_sql": "SELECT a.name, SUM(p.cites) AS total_citations\nFROM authors a\nJOIN publications p ON a.name = p.author\nWHERE a.department = 'Mathematics'\n  AND p.year >= EXTRACT(YEAR FROM CURRENT_DATE) - 5\nGROUP BY a.name\nORDER BY total_citations DESC\nLIMIT 3;", "raw_model_output": "<think>\n\n</think>\n\nSELECT a.name, SUM(p.cites) AS total_citations\nFROM authors a\nJOIN publications p ON a.name = p.author\nWHERE a.department = 'Mathematics'\n  AND p.year >= EXTRACT(YEAR FROM CURRENT_DATE) - 5\nGROUP BY a.name\nORDER BY total_citations DESC\nLIMIT 3;", "latency_sec": 1.228874921798706, "total_duration_sec": 1.101051691, "load_duration_sec": 0.025379311, "tokens_prompt": 209, "prompt_eval_sec": 0.020854418, "tokens_completion": 74, "completion_eval_sec": 1.052401846, "tokens_total": 283, "tokens_per_sec": 230.2919483341498, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their year filtering logic. The Reference SQL uses BETWEEN YEAR(CURRENT_DATE) - 5 AND YEAR(CURRENT_DATE), which includes both lower and upper bounds (e.g., 2018-2023 if current year is 2023). The Generated SQL uses p.year >= EXTRACT(YEAR FROM CURRENT_DATE) - 5, which only enforces the lower bound but allows any year above it (including future years if present). This makes the Generated SQL potentially include more rows than the Reference SQL, leading to different results."}
{"example_id": 592, "sql_complexity": "set operations", "prompt": "How many public healthcare facilities and public parks are there in total, in the 'StateData' schema's 'StateHealthcare' and 'StateParks' tables?", "context": "CREATE SCHEMA StateData; CREATE TABLE StateHealthcare (Name varchar(255), Type varchar(255)); INSERT INTO StateHealthcare (Name, Type) VALUES ('FacilityA', 'Public'), ('FacilityB', 'Public'), ('FacilityC', 'Private'); CREATE TABLE StateParks (Name varchar(255), Type varchar(255)); INSERT INTO StateParks (Name, Type) VALUES ('ParkA', 'Public'), ('ParkB', 'Public'), ('ParkC', 'Private');", "reference_sql": "SELECT COUNT(*) FROM StateData.StateHealthcare WHERE Type = 'Public' UNION ALL SELECT COUNT(*) FROM StateData.StateParks WHERE Type = 'Public';", "generated_sql": "SELECT \n  (SELECT COUNT(*) FROM StateHealthcare WHERE Type = 'Public') + \n  (SELECT COUNT(*) FROM StateParks WHERE Type = 'Public') AS Total_Public_Facilities_Parks;", "raw_model_output": "<think>\n\n</think>\n\nSELECT \n  (SELECT COUNT(*) FROM StateHealthcare WHERE Type = 'Public') + \n  (SELECT COUNT(*) FROM StateParks WHERE Type = 'Public') AS Total_Public_Facilities_Parks;", "latency_sec": 1.0488488674163818, "total_duration_sec": 0.735212304, "load_duration_sec": 0.026268387, "tokens_prompt": 219, "prompt_eval_sec": 0.02118745, "tokens_completion": 48, "completion_eval_sec": 0.685503996, "tokens_total": 267, "tokens_per_sec": 254.56479793671156, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query returns two separate counts (one for StateHealthcare and one for StateParks) as two rows, while the generated query returns a single row with the summed total of both counts. The structure and output format differ, making them non-equivalent."}
{"example_id": 1989, "sql_complexity": "single join", "prompt": "What are the names and production dates of garments made from fabrics with a sustainability score over 70, produced after 2021-01-01?", "context": "CREATE TABLE fabrics (id INT, name VARCHAR(50), type VARCHAR(50), sustainability_score INT); INSERT INTO fabrics (id, name, type, sustainability_score) VALUES (1, 'Organic Linen', 'Natural', 80); INSERT INTO fabrics (id, name, type, sustainability_score) VALUES (2, 'Recycled Nylon', 'Synthetic', 72);", "reference_sql": "SELECT garments.name, garments.production_date FROM garments JOIN fabrics ON garments.fabric_id = fabrics.id WHERE fabrics.sustainability_score > 70 AND garments.production_date > '2021-01-01';", "generated_sql": "SELECT g.name, g.production_date\nFROM garments g\nJOIN fabrics f ON g.fabric_id = f.id\nWHERE f.sustainability_score > 70\nAND g.production_date > '2021-01-01';", "raw_model_output": "<think>\n\n</think>\n\nSELECT g.name, g.production_date\nFROM garments g\nJOIN fabrics f ON g.fabric_id = f.id\nWHERE f.sustainability_score > 70\nAND g.production_date > '2021-01-01';", "latency_sec": 0.8685917854309082, "total_duration_sec": 0.823559637, "load_duration_sec": 0.013932208, "tokens_prompt": 190, "prompt_eval_sec": 0.018415528, "tokens_completion": 56, "completion_eval_sec": 0.789112677, "tokens_total": 246, "tokens_per_sec": 283.2170464034028, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform the same inner join between 'garments' and 'fabrics' tables on fabric_id, apply identical WHERE conditions (sustainability_score > 70 and production_date > '2021-01-01'), and select the same columns. The only differences are table aliases ('g'/'f' vs. full names) which do not affect semantic meaning."}
{"example_id": 1388, "sql_complexity": "aggregation", "prompt": "What was the total donation amount by each organization in the last 30 days?", "context": "CREATE TABLE organization_donations (id INT, organization TEXT, donation_date DATE, donation_amount DECIMAL(10,2)); INSERT INTO organization_donations (id, organization, donation_date, donation_amount) VALUES (1, 'Organization A', '2021-03-15', 100.00), (2, 'Organization B', '2021-03-25', 200.00);", "reference_sql": "SELECT organization, SUM(donation_amount) FROM organization_donations WHERE donation_date >= DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY) GROUP BY organization;", "generated_sql": "SELECT organization, SUM(donation_amount) AS total_donation_amount\nFROM organization_donations\nWHERE donation_date >= CURRENT_DATE - INTERVAL '30 days'\nGROUP BY organization;", "raw_model_output": "<think>\n\n</think>\n\nSELECT organization, SUM(donation_amount) AS total_donation_amount\nFROM organization_donations\nWHERE donation_date >= CURRENT_DATE - INTERVAL '30 days'\nGROUP BY organization;", "latency_sec": 0.8560450077056885, "total_duration_sec": 0.624659227, "load_duration_sec": 0.018594726, "tokens_prompt": 186, "prompt_eval_sec": 0.020691113, "tokens_completion": 41, "completion_eval_sec": 0.581544676, "tokens_total": 227, "tokens_per_sec": 265.17297333278003, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the total donations per organization for the last 30 days. The date calculation syntax differs (DATE_SUB vs. CURRENT_DATE - INTERVAL), but both evaluate to the same date range. The column alias in the generated query ('total_donation_amount') doesn't affect semantic equivalence as the result set structure remains functionally equivalent."}
{"example_id": 1628, "sql_complexity": "window functions", "prompt": "What is the ranking of national security measures for Russia based on the publication date?", "context": "CREATE TABLE national_security (id INT, title VARCHAR(255), description TEXT, agency VARCHAR(255), date DATE); INSERT INTO national_security (id, title, description, agency, date) VALUES (1, 'National Cyber Strategy', 'Outlines the approach to protecting the American people and the American way of life in the digital age', 'White House', '2018-09-20'); INSERT INTO national_security (id, title, description, agency, date) VALUES (2, 'Cybersecurity and Infrastructure Security Agency Act of 2018', 'Establishes the Cybersecurity and Infrastructure Security Agency within the Department of Homeland Security', 'Congress', '2018-11-16'); INSERT INTO national_security (id, title, description, agency, date) VALUES (3, 'Russian Military Doctrine', 'Outlines the country\u2019s stance on military security', 'Russian Government', '2014-12-26');", "reference_sql": "SELECT title, description, agency, date, ROW_NUMBER() OVER (PARTITION BY agency ORDER BY date DESC) as ranking FROM national_security WHERE agency = 'Russian Government';", "generated_sql": "SELECT id, title, description, agency, date, \n       RANK() OVER (ORDER BY date DESC) AS ranking\nFROM national_security\nWHERE agency = 'Russian Government';", "raw_model_output": "<think>\n\n</think>\n\nSELECT id, title, description, agency, date, \n       RANK() OVER (ORDER BY date DESC) AS ranking\nFROM national_security\nWHERE agency = 'Russian Government';", "latency_sec": 0.9691052436828613, "total_duration_sec": 0.668172136, "load_duration_sec": 0.013440058, "tokens_prompt": 295, "prompt_eval_sec": 0.031184472, "tokens_completion": 42, "completion_eval_sec": 0.620925531, "tokens_total": 337, "tokens_per_sec": 347.74344912148973, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the generated query includes an extra 'id' column in the SELECT list, while the reference query does not. Second, the reference uses ROW_NUMBER() with PARTITION BY agency (redundant here due to the WHERE clause) while the generated query uses RANK() without a partition. Although both would produce rank 1 for the single Russian Government entry, the column differences make the result sets non-equivalent."}
{"example_id": 2300, "sql_complexity": "aggregation", "prompt": "What is the minimum capacity for schools in each location ('community_development')?", "context": "CREATE TABLE community_development.schools (id INT, name VARCHAR(50), capacity INT, location VARCHAR(50));", "reference_sql": "SELECT location, MIN(capacity) FROM community_development.schools GROUP BY location;", "generated_sql": "SELECT location, MIN(capacity) AS min_capacity\nFROM community_development.schools\nGROUP BY location;", "raw_model_output": "<think>\n\n</think>\n\nSELECT location, MIN(capacity) AS min_capacity\nFROM community_development.schools\nGROUP BY location;", "latency_sec": 0.631554126739502, "total_duration_sec": 0.416047787, "load_duration_sec": 0.026256705, "tokens_prompt": 114, "prompt_eval_sec": 0.011196652, "tokens_completion": 27, "completion_eval_sec": 0.376672354, "tokens_total": 141, "tokens_per_sec": 223.25877392003565, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the minimum capacity per location. The generated query adds an alias (min_capacity) for the MIN(capacity) column, but this does not affect the semantic result set. The GROUP BY clause and aggregate function remain identical."}
{"example_id": 4976, "sql_complexity": "set operations", "prompt": "What is the most common hashtag used in posts made by users from Brazil?", "context": "CREATE TABLE posts (id INT, user_id INT, content TEXT, hashtags TEXT, post_date DATE); INSERT INTO posts (id, user_id, content, hashtags, post_date) VALUES (1, 1, 'Hello World', '#datascience', '2022-06-01'), (2, 1, 'I love data', '#ai', '2022-06-02'), (3, 2, 'Ol\u00e1 Mundo', '#brasil', '2022-06-03'); CREATE TABLE users (id INT, name VARCHAR(100), country VARCHAR(50)); INSERT INTO users (id, name, country) VALUES (1, 'Jo\u00e3o Silva', 'Brazil'), (2, 'Maria Souza', 'Brazil');", "reference_sql": "SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(hashtags, ' ', n.n), ' ', -1) hashtag, COUNT(*) count FROM posts JOIN users ON posts.user_id = users.id CROSS JOIN (SELECT 1 n UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5) n WHERE users.country = 'Brazil' GROUP BY hashtag ORDER BY count DESC LIMIT 1;", "generated_sql": "SELECT hashtags\nFROM posts\nJOIN users ON posts.user_id = users.id\nWHERE users.country = 'Brazil'\nGROUP BY hashtags\nORDER BY COUNT(*) DESC\nLIMIT 1;", "raw_model_output": "<think>\n\n</think>\n\nSELECT hashtags\nFROM posts\nJOIN users ON posts.user_id = users.id\nWHERE users.country = 'Brazil'\nGROUP BY hashtags\nORDER BY COUNT(*) DESC\nLIMIT 1;", "latency_sec": 0.94476318359375, "total_duration_sec": 0.657090846, "load_duration_sec": 0.013618907, "tokens_prompt": 258, "prompt_eval_sec": 0.025674658, "tokens_completion": 42, "completion_eval_sec": 0.61564434, "tokens_total": 300, "tokens_per_sec": 317.5398927579301, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses a cross join with numbers and substring functions to split hashtags, which would generate multiple rows per post (e.g., 5 rows per post) and overcount hashtags. The Generated SQL directly groups by the hashtags column, producing accurate counts. The Reference SQL's approach is incorrect for single-word hashtags and would return different results due to overcounting."}
{"example_id": 4637, "sql_complexity": "single join", "prompt": "What is the total value of transactions for each customer in the last 30 days?", "context": "CREATE TABLE transactions (id INT, customer_id INT, value DECIMAL(10, 2), transaction_date DATE); INSERT INTO transactions (id, customer_id, value, transaction_date) VALUES (1, 1, 100, '2022-01-01'), (2, 1, 200, '2022-01-15'), (3, 2, 50, '2022-01-05'), (4, 2, 150, '2022-01-30'), (5, 3, 300, '2022-01-20');", "reference_sql": "SELECT c.id, SUM(t.value) FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE t.transaction_date >= CURDATE() - INTERVAL 30 DAY GROUP BY c.id;", "generated_sql": "SELECT customer_id, SUM(value) AS total_value\nFROM transactions\nWHERE transaction_date >= CURRENT_DATE - INTERVAL '30 days'\nGROUP BY customer_id;", "raw_model_output": "<think>\n\n</think>\n\nSELECT customer_id, SUM(value) AS total_value\nFROM transactions\nWHERE transaction_date >= CURRENT_DATE - INTERVAL '30 days'\nGROUP BY customer_id;", "latency_sec": 0.6705069541931152, "total_duration_sec": 0.578286599, "load_duration_sec": 0.014835773, "tokens_prompt": 244, "prompt_eval_sec": 0.023118104, "tokens_completion": 37, "completion_eval_sec": 0.538347168, "tokens_total": 281, "tokens_per_sec": 419.08588455753454, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the total transaction value per customer for the last 30 days. The Reference SQL uses an INNER JOIN with customers (which implicitly filters to customers with transactions) and groups by c.id. The Generated SQL directly groups transactions by customer_id. The date filters (CURDATE() - INTERVAL 30 DAY vs CURRENT_DATE - INTERVAL '30 days') are functionally equivalent in MySQL. Both produce the same result set with identical aggregation logic."}
{"example_id": 4947, "sql_complexity": "aggregation", "prompt": "What is the total revenue for drugs approved between 2017 and 2019?", "context": "CREATE TABLE drug_sales_3 (drug_name TEXT, revenue FLOAT, year INT); INSERT INTO drug_sales_3 (drug_name, revenue, year) VALUES ('DrugG', 20000000, 2019), ('DrugG', 19000000, 2018), ('DrugH', 15000000, 2017), ('DrugH', 16000000, 2018);", "reference_sql": "SELECT drug_name, SUM(revenue) FROM drug_sales_3 WHERE year BETWEEN 2017 AND 2019 GROUP BY drug_name;", "generated_sql": "SELECT SUM(revenue) AS total_revenue\nFROM drug_sales_3\nWHERE year BETWEEN 2017 AND 2019;", "raw_model_output": "<think>\n\n</think>\n\nSELECT SUM(revenue) AS total_revenue\nFROM drug_sales_3\nWHERE year BETWEEN 2017 AND 2019;", "latency_sec": 0.853029727935791, "total_duration_sec": 0.553774963, "load_duration_sec": 0.014068777, "tokens_prompt": 205, "prompt_eval_sec": 0.019602257, "tokens_completion": 36, "completion_eval_sec": 0.517967984, "tokens_total": 241, "tokens_per_sec": 282.5223929571426, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query groups results by drug_name and returns individual drug revenues, while the generated query returns a single total revenue for all drugs combined. The GROUP BY clause is missing in the generated query, leading to different result structures and values."}
{"example_id": 4767, "sql_complexity": "window functions", "prompt": "List the top 2 AI algorithms with the highest explainability scores, by algorithm subtype, ordered by scores in descending order for the European region.", "context": "CREATE TABLE ai_algorithms (algorithm_id INT, algorithm_name VARCHAR(50), algorithm_subtype VARCHAR(50), region VARCHAR(50), explainability_score FLOAT); INSERT INTO ai_algorithms (algorithm_id, algorithm_name, algorithm_subtype, region, explainability_score) VALUES (1, 'AlgoA', 'Tree-based', 'Europe', 0.85), (2, 'AlgoB', 'Computer Vision', 'Europe', 0.92), (3, 'AlgoC', 'Tree-based', 'Europe', 0.78), (4, 'AlgoD', 'Transformer', 'Europe', 0.90), (5, 'AlgoE', 'Tree-based', 'Europe', 0.80);", "reference_sql": "SELECT algorithm_subtype, region, * FROM (SELECT algorithm_subtype, region, algorithm_id, algorithm_name, explainability_score, RANK() OVER (PARTITION BY algorithm_subtype ORDER BY explainability_score DESC) AS rank FROM ai_algorithms WHERE region = 'Europe') ranked WHERE rank <= 2 ORDER BY algorithm_subtype, region, explainability_score DESC;", "generated_sql": "SELECT algorithm_name, explainability_score, algorithm_subtype\nFROM ai_algorithms\nWHERE region = 'Europe'\nORDER BY explainability_score DESC\nLIMIT 2;", "raw_model_output": "<think>\n\n</think>\n\nSELECT algorithm_name, explainability_score, algorithm_subtype\nFROM ai_algorithms\nWHERE region = 'Europe'\nORDER BY explainability_score DESC\nLIMIT 2;", "latency_sec": 0.6596300601959229, "total_duration_sec": 0.606057295, "load_duration_sec": 0.02091087, "tokens_prompt": 262, "prompt_eval_sec": 0.025884153, "tokens_completion": 38, "completion_eval_sec": 0.557012064, "tokens_total": 300, "tokens_per_sec": 454.8003769126201, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL selects top 2 algorithms per subtype (using RANK() with PARTITION BY algorithm_subtype) while the Generated SQL selects top 2 overall based on explainability_score. The Reference query returns multiple rows per subtype, whereas the Generated query returns only 2 rows total. For example, the Reference would return 2 Tree-based algorithms and 1 each from other subtypes, while the Generated would return the two highest-scoring algorithms overall (AlgoB and AlgoD)."}
{"example_id": 4495, "sql_complexity": "basic SQL", "prompt": "Which countries are the top 3 sources of sustainable textiles?", "context": "CREATE TABLE Textile_Sources (Source_ID INT, Source_Country TEXT, Sustainable BOOLEAN, Quantity INT); INSERT INTO Textile_Sources (Source_ID, Source_Country, Sustainable, Quantity) VALUES (1, 'India', true, 1000), (2, 'Bangladesh', false, 800), (3, 'China', true, 1200), (4, 'Vietnam', false, 900), (5, 'Italy', true, 1100), (6, 'USA', false, 700);", "reference_sql": "SELECT Source_Country FROM Textile_Sources WHERE Sustainable = true ORDER BY Quantity DESC LIMIT 3;", "generated_sql": "SELECT Source_Country\nFROM Textile_Sources\nWHERE Sustainable = TRUE\nORDER BY Quantity DESC\nLIMIT 3;", "raw_model_output": "<think>\n\n</think>\n\nSELECT Source_Country\nFROM Textile_Sources\nWHERE Sustainable = TRUE\nORDER BY Quantity DESC\nLIMIT 3;", "latency_sec": 0.7622308731079102, "total_duration_sec": 0.484211592, "load_duration_sec": 0.022560106, "tokens_prompt": 208, "prompt_eval_sec": 0.022059758, "tokens_completion": 30, "completion_eval_sec": 0.437326411, "tokens_total": 238, "tokens_per_sec": 312.2413541576739, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. The only differences are formatting (line breaks/indentation) and case sensitivity of the boolean value ('true' vs 'TRUE'), which SQL handles case-insensitively. Both queries select the same columns, apply the same filter (Sustainable = true), sort by Quantity descending, and limit to 3 results."}
{"example_id": 2513, "sql_complexity": "single join", "prompt": "What is the total number of concert ticket sales for artists who released their first album between 2015 and 2017?", "context": "CREATE TABLE ConcertTicketSales (id INT, year INT, artist_id INT); CREATE TABLE ArtistAlbums (id INT, artist_id INT, year INT);", "reference_sql": "SELECT COUNT(DISTINCT cts.artist_id) FROM ConcertTicketSales cts JOIN ArtistAlbums a ON cts.artist_id = a.artist_id WHERE a.year BETWEEN 2015 AND 2017;", "generated_sql": "SELECT COUNT(*) AS total_concert_ticket_sales\nFROM ConcertTicketSales\nWHERE artist_id IN (\n    SELECT artist_id\n    FROM ArtistAlbums\n    WHERE year BETWEEN 2015 AND 2017\n    GROUP BY artist_id\n    HAVING MIN(year) BETWEEN 2015 AND 2017\n);", "raw_model_output": "<think>\n\n</think>\n\nSELECT COUNT(*) AS total_concert_ticket_sales\nFROM ConcertTicketSales\nWHERE artist_id IN (\n    SELECT artist_id\n    FROM ArtistAlbums\n    WHERE year BETWEEN 2015 AND 2017\n    GROUP BY artist_id\n    HAVING MIN(year) BETWEEN 2015 AND 2017\n);", "latency_sec": 1.2320752143859863, "total_duration_sec": 1.103393614, "load_duration_sec": 0.013811483, "tokens_prompt": 133, "prompt_eval_sec": 0.012216836, "tokens_completion": 78, "completion_eval_sec": 1.074906522, "tokens_total": 211, "tokens_per_sec": 171.25577849169977, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query counts distinct artist_ids from ConcertTicketSales that have a matching entry in ArtistAlbums between 2015-2017, while the generated query counts all concert ticket sales entries where the artist_id exists in a subquery. The generated query's subquery uses a HAVING clause that's redundant but doesn't change the result. However, the main difference is that the reference uses COUNT(DISTINCT) while the generated uses COUNT(*), leading to different results when an artist has multiple entries in ConcertTicketSales."}
{"example_id": 873, "sql_complexity": "subqueries", "prompt": "Identify attorneys who have never handled cases in the 'West' region but have in the 'North' or 'South'.", "context": "CREATE TABLE attorney_regions(attorney_id INT, region VARCHAR(20)); INSERT INTO attorney_regions(attorney_id, region) VALUES (1, 'North'), (2, 'South'), (3, 'East'), (4, 'West'), (5, 'West'), (6, 'North'); CREATE TABLE handled_cases(attorney_id INT, case_id INT); INSERT INTO handled_cases(attorney_id, case_id) VALUES (1, 101), (2, 102), (3, 103), (4, 104), (5, 105), (6, 106), (1, 107), (1, 108);", "reference_sql": "SELECT h.attorney_id FROM attorney_regions h LEFT JOIN handled_cases i ON h.attorney_id = i.attorney_id WHERE h.region IN ('North', 'South') AND h.region != 'West' AND i.attorney_id IS NOT NULL AND h.attorney_id NOT IN (SELECT attorney_id FROM attorney_regions WHERE region = 'West');", "generated_sql": "SELECT DISTINCT ar.attorney_id\nFROM attorney_regions ar\nWHERE ar.region IN ('North', 'South')\nAND ar.attorney_id NOT IN (\n    SELECT DISTINCT ar2.attorney_id\n    FROM attorney_regions ar2\n    WHERE ar2.region = 'West'\n    UNION\n    SELECT hc.attorney_id\n    FROM handled_cases hc\n    JOIN attorney_regions ar2 ON hc.attorney_id = ar2.attorney_id\n    WHERE ar2.region = 'West'\n);", "raw_model_output": "<think>\n\n</think>\n\nSELECT DISTINCT ar.attorney_id\nFROM attorney_regions ar\nWHERE ar.region IN ('North', 'South')\nAND ar.attorney_id NOT IN (\n    SELECT DISTINCT ar2.attorney_id\n    FROM attorney_regions ar2\n    WHERE ar2.region = 'West'\n    UNION\n    SELECT hc.attorney_id\n    FROM handled_cases hc\n    JOIN attorney_regions ar2 ON hc.attorney_id = ar2.attorney_id\n    WHERE ar2.region = 'West'\n);", "latency_sec": 1.8476290702819824, "total_duration_sec": 1.535341309, "load_duration_sec": 0.027732458, "tokens_prompt": 248, "prompt_eval_sec": 0.023418233, "tokens_completion": 104, "completion_eval_sec": 1.481497829, "tokens_total": 352, "tokens_per_sec": 190.51443044586773, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a condition (i.attorney_id IS NOT NULL) to ensure only attorneys with handled cases are selected, while the Generated SQL lacks this filter. The Generated SQL's subquery also redundantly combines West region attorneys with those having cases in West, but the core difference lies in the absence of the 'handled cases' check in the Generated SQL, leading to potential inclusion of attorneys without cases."}
{"example_id": 471, "sql_complexity": "set operations", "prompt": "Find the number of donations made by first-time donors in the last quarter.", "context": "CREATE TABLE Donations (DonationID INT, DonorID INT, DonationDate DATE, DonationType TEXT, DonationAmount FLOAT); INSERT INTO Donations (DonationID, DonorID, DonationDate, DonationType, DonationAmount) VALUES (1, 1, '2021-01-01', 'Individual', 100), (2, 2, '2021-02-01', 'Corporate', 5000);", "reference_sql": "SELECT COUNT(*) FROM (SELECT DonationID FROM Donations WHERE DonationType = 'Individual' AND DonationDate >= DATEADD(quarter, -1, CURRENT_DATE) EXCEPT SELECT DonationID FROM PreviousDonations) AS FirstTimeDonors;", "generated_sql": "SELECT COUNT(DISTINCT d.DonorID) AS FirstTimeDonorsCount\nFROM Donations d\nWHERE d.DonationDate >= DATEADD(QUARTER, -1, GETDATE())\nAND NOT EXISTS (\n    SELECT 1\n    FROM Donations d2\n    WHERE d2.DonorID = d.DonorID\n    AND d2.DonationDate < d.DonationDate\n);", "raw_model_output": "<think>\n\n</think>\n\nSELECT COUNT(DISTINCT d.DonorID) AS FirstTimeDonorsCount\nFROM Donations d\nWHERE d.DonationDate >= DATEADD(QUARTER, -1, GETDATE())\nAND NOT EXISTS (\n    SELECT 1\n    FROM Donations d2\n    WHERE d2.DonorID = d.DonorID\n    AND d2.DonationDate < d.DonationDate\n);", "latency_sec": 1.4383840560913086, "total_duration_sec": 1.299109659, "load_duration_sec": 0.021253865, "tokens_prompt": 190, "prompt_eval_sec": 0.02574693, "tokens_completion": 89, "completion_eval_sec": 1.246253557, "tokens_total": 279, "tokens_per_sec": 193.96766727111796, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in several key aspects. The Reference SQL counts DonationIDs from Donations (filtered by 'Individual' type and recent quarter) that are not in PreviousDonations, while the Generated SQL counts distinct DonorIDs who made their first donation in the last quarter (without checking PreviousDonations). The Reference SQL focuses on donation-level uniqueness, whereas the Generated SQL focuses on donor-level first-time donations. Additionally, the Reference SQL includes a DonationType filter not present in the Generated SQL."}
{"example_id": 1301, "sql_complexity": "multiple_joins", "prompt": "What is the total quantity of corn sold by farmers in 'Summerfield'?", "context": "CREATE TABLE farmers (id INT, name VARCHAR(50), location VARCHAR(50), crops VARCHAR(50)); CREATE TABLE crops (id INT, name VARCHAR(50), yield INT); CREATE TABLE sales (id INT, farmer_id INT, crop_name VARCHAR(50), quantity INT, price DECIMAL(5,2)); INSERT INTO farmers VALUES (1, 'Jane Doe', 'Summerfield', 'Corn'); INSERT INTO crops VALUES (1, 'Corn', 100); INSERT INTO sales VALUES (1, 1, 'Corn', 50, 2.50);", "reference_sql": "SELECT SUM(quantity) FROM sales INNER JOIN farmers ON sales.farmer_id = farmers.id INNER JOIN crops ON sales.crop_name = crops.name WHERE farmers.location = 'Summerfield' AND crops.name = 'Corn';", "generated_sql": "SELECT SUM(s.quantity) \nFROM sales s\nJOIN farmers f ON s.farmer_id = f.id\nWHERE f.location = 'Summerfield' AND f.crops = 'Corn';", "raw_model_output": "<think>\n\n</think>\n\nSELECT SUM(s.quantity) \nFROM sales s\nJOIN farmers f ON s.farmer_id = f.id\nWHERE f.location = 'Summerfield' AND f.crops = 'Corn';", "latency_sec": 0.7143096923828125, "total_duration_sec": 0.667957601, "load_duration_sec": 0.015887995, "tokens_prompt": 214, "prompt_eval_sec": 0.022299391, "tokens_completion": 44, "completion_eval_sec": 0.627434414, "tokens_total": 258, "tokens_per_sec": 361.1878751628821, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL joins with the 'crops' table and filters on crops.name = 'Corn', ensuring the crop name matches the crops table. The Generated SQL uses farmers.crops = 'Corn' without joining the crops table, which may not validate the crop name against the crops table. This difference in logic means they are not semantically equivalent."}
{"example_id": 4667, "sql_complexity": "aggregation", "prompt": "Find the number of unique organizations in each country in the Philanthropy Trends table?", "context": "CREATE TABLE PhilanthropyTrends (OrgID INT, Name TEXT, Country TEXT);", "reference_sql": "SELECT Country, COUNT(DISTINCT OrgID) as UniqueOrganizations FROM PhilanthropyTrends GROUP BY Country;", "generated_sql": "SELECT Country, COUNT(DISTINCT OrgID) AS UniqueOrganizations\nFROM PhilanthropyTrends\nGROUP BY Country;", "raw_model_output": "<think>\n\n</think>\n\nSELECT Country, COUNT(DISTINCT OrgID) AS UniqueOrganizations\nFROM PhilanthropyTrends\nGROUP BY Country;", "latency_sec": 0.7827248573303223, "total_duration_sec": 0.460435648, "load_duration_sec": 0.019795426, "tokens_prompt": 107, "prompt_eval_sec": 0.011559263, "tokens_completion": 31, "completion_eval_sec": 0.426787231, "tokens_total": 138, "tokens_per_sec": 176.30716427057564, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select the 'Country' column and count distinct 'OrgID' values, grouping by 'Country'. The differences are purely syntactic (capitalization of keywords and formatting) and do not affect the semantic meaning or result."}
{"example_id": 1006, "sql_complexity": "subqueries", "prompt": "What is the average word count of news articles written by investigative journalists?", "context": "CREATE TABLE reporters (id INT, name VARCHAR(50), gender VARCHAR(10), age INT, position VARCHAR(20), country VARCHAR(50)); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (1, 'Anna Smith', 'Female', 35, 'News Reporter', 'USA'); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (2, 'Mike Johnson', 'Male', 40, 'Investigative Journalist', 'Canada'); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (3, 'Sofia Rodriguez', 'Female', 32, 'Investigative Journalist', 'Mexico'); CREATE TABLE news_articles (id INT, title VARCHAR(100), content TEXT, publication_date DATE, reporter_id INT); INSERT INTO news_articles (id, title, content, publication_date, reporter_id) VALUES (1, 'News Article 1', 'Content of News Article 1', '2021-01-01', 2); INSERT INTO news_articles (id, title, content, publication_date, reporter_id) VALUES (2, 'News Article 2', 'Content of News Article 2', '2021-02-01', 3);", "reference_sql": "SELECT AVG(LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1) AS avg_word_count FROM news_articles WHERE reporter_id IN (SELECT id FROM reporters WHERE position = 'Investigative Journalist');", "generated_sql": "SELECT AVG(word_count) AS average_word_count\nFROM (\n    SELECT COUNT(*) AS word_count\n    FROM news_articles\n    JOIN reporters ON news_articles.reporter_id = reporters.id\n    WHERE reporters.position = 'Investigative Journalist'\n    AND news_articles.content IS NOT NULL\n    GROUP BY news_articles.reporter_id\n) AS word_counts;", "raw_model_output": "<think>\n\n</think>\n\nSELECT AVG(word_count) AS average_word_count\nFROM (\n    SELECT COUNT(*) AS word_count\n    FROM news_articles\n    JOIN reporters ON news_articles.reporter_id = reporters.id\n    WHERE reporters.position = 'Investigative Journalist'\n    AND news_articles.content IS NOT NULL\n    GROUP BY news_articles.reporter_id\n) AS word_counts;", "latency_sec": 1.350459098815918, "total_duration_sec": 1.213824264, "load_duration_sec": 0.014456782, "tokens_prompt": 368, "prompt_eval_sec": 0.038253076, "tokens_completion": 78, "completion_eval_sec": 1.158563615, "tokens_total": 446, "tokens_per_sec": 330.25805845660386, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the average word count per article using a formula that counts spaces, while the Generated SQL computes the average number of articles per reporter. The first focuses on word counts per article, the second on article counts per reporter, leading to different results."}
{"example_id": 3635, "sql_complexity": "set operations", "prompt": "Which brands have certifications related to cruelty-free, vegan, or organic products?", "context": "CREATE TABLE brands (brand_name VARCHAR(50), is_cruelty_free BOOLEAN, is_vegan BOOLEAN, is_organic BOOLEAN); INSERT INTO brands (brand_name, is_cruelty_free, is_vegan, is_organic) VALUES ('Lush', TRUE, TRUE, FALSE), ('The Body Shop', TRUE, FALSE, FALSE), ('Est\u00e9e Lauder', FALSE, FALSE, FALSE), ('Urban Decay', TRUE, TRUE, FALSE), ('Maybelline', FALSE, FALSE, FALSE), ('Kat Von D', TRUE, TRUE, FALSE), ('Tarte', TRUE, TRUE, TRUE);", "reference_sql": "SELECT brand_name, 'Cruelty-free' as certification FROM brands WHERE is_cruelty_free = TRUE UNION SELECT brand_name, 'Vegan' as certification FROM brands WHERE is_vegan = TRUE UNION SELECT brand_name, 'Organic' as certification FROM brands WHERE is_organic = TRUE;", "generated_sql": "SELECT brand_name\nFROM brands\nWHERE is_cruelty_free = TRUE OR is_vegan = TRUE OR is_organic = TRUE;", "raw_model_output": "<think>\n\n</think>\n\nSELECT brand_name\nFROM brands\nWHERE is_cruelty_free = TRUE OR is_vegan = TRUE OR is_organic = TRUE;", "latency_sec": 0.834867000579834, "total_duration_sec": 0.539815776, "load_duration_sec": 0.02216339, "tokens_prompt": 214, "prompt_eval_sec": 0.023203575, "tokens_completion": 34, "completion_eval_sec": 0.492100695, "tokens_total": 248, "tokens_per_sec": 297.05330289466275, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query returns each brand with its specific certification type (Cruelty-free/Vegan/Organic) as separate rows, while the generated query returns brands that meet any of the conditions without indicating which certification they have. The first produces multiple rows per brand if they have multiple certifications, while the second produces one row per brand regardless of how many certifications they have."}
{"example_id": 4932, "sql_complexity": "basic SQL", "prompt": "Delete the workout row with the id of 2.", "context": "CREATE TABLE Workouts (id INT, user_id INT, workout_name TEXT, calories INT); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (1, 1, 'Running', 300); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (2, 1, 'Cycling', 400); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (3, 2, 'Yoga', 200);", "reference_sql": "DELETE FROM Workouts WHERE id = 2;", "generated_sql": "DELETE FROM Workouts WHERE id = 2;", "raw_model_output": "<think>\n\n</think>\n\nDELETE FROM Workouts WHERE id = 2;", "latency_sec": 0.371412992477417, "total_duration_sec": 0.262080056, "load_duration_sec": 0.013796887, "tokens_prompt": 194, "prompt_eval_sec": 0.02150706, "tokens_completion": 15, "completion_eval_sec": 0.224601332, "tokens_total": 209, "tokens_per_sec": 562.7159098714292, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They both delete the record from the Workouts table where the id is 2. The SQL syntax, table name, and WHERE condition are exactly the same in both queries."}
{"example_id": 365, "sql_complexity": "aggregation", "prompt": "Identify the total number of military personnel and their corresponding rank for each branch and country in the 'military_personnel' table, sorted by the total number of personnel in descending order.", "context": "CREATE TABLE military_personnel (id INT, branch VARCHAR(255), rank VARCHAR(255), country VARCHAR(255), personnel INT);", "reference_sql": "SELECT branch, country, SUM(personnel) as total_personnel FROM military_personnel GROUP BY branch, country ORDER BY total_personnel DESC;", "generated_sql": "SELECT branch, country, rank, SUM(personnel) AS total_personnel\nFROM military_personnel\nGROUP BY branch, country, rank\nORDER BY total_personnel DESC;", "raw_model_output": "<think>\n\n</think>\n\nSELECT branch, country, rank, SUM(personnel) AS total_personnel\nFROM military_personnel\nGROUP BY branch, country, rank\nORDER BY total_personnel DESC;", "latency_sec": 0.745373010635376, "total_duration_sec": 0.610524684, "load_duration_sec": 0.023807933, "tokens_prompt": 143, "prompt_eval_sec": 0.012242066, "tokens_completion": 41, "completion_eval_sec": 0.5724497, "tokens_total": 184, "tokens_per_sec": 246.8562684382058, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their GROUP BY clauses. The reference query groups by (branch, country), aggregating all ranks within each branch-country combination. The generated query adds 'rank' to the GROUP BY, creating separate groups for each (branch, country, rank) triplet. This results in different aggregation granularities and output structures."}
{"example_id": 521, "sql_complexity": "subqueries", "prompt": "How many vessels have not had an inspection in the past year?", "context": "CREATE TABLE safety_records(id INT, vessel_name VARCHAR(50), inspection_date DATE); CREATE TABLE vessels(id INT, name VARCHAR(50), country VARCHAR(50)); INSERT INTO vessels(id, name, country) VALUES (1, 'Vessel A', 'Philippines'), (2, 'Vessel B', 'Philippines'); INSERT INTO safety_records(id, vessel_name, inspection_date) VALUES (1, 'Vessel A', '2022-01-01');", "reference_sql": "SELECT COUNT(*) FROM vessels WHERE name NOT IN (SELECT vessel_name FROM safety_records WHERE inspection_date BETWEEN DATE_SUB(NOW(), INTERVAL 1 YEAR) AND NOW());", "generated_sql": "SELECT COUNT(*) AS vessels_without_inspection\nFROM vessels v\nWHERE NOT EXISTS (\n    SELECT 1\n    FROM safety_records sr\n    WHERE sr.vessel_name = v.name\n    AND sr.inspection_date >= CURRENT_DATE - INTERVAL '1 year'\n);", "raw_model_output": "<think>\n\n</think>\n\nSELECT COUNT(*) AS vessels_without_inspection\nFROM vessels v\nWHERE NOT EXISTS (\n    SELECT 1\n    FROM safety_records sr\n    WHERE sr.vessel_name = v.name\n    AND sr.inspection_date >= CURRENT_DATE - INTERVAL '1 year'\n);", "latency_sec": 1.19679594039917, "total_duration_sec": 0.878155099, "load_duration_sec": 0.024914774, "tokens_prompt": 188, "prompt_eval_sec": 0.02219711, "tokens_completion": 59, "completion_eval_sec": 0.826820771, "tokens_total": 247, "tokens_per_sec": 206.384389904947, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries aim to count vessels without inspections in the last year. The Reference SQL uses NOT IN with a subquery filtering inspections in the last year, while the Generated SQL uses NOT EXISTS with a correlated subquery. The date conditions (BETWEEN DATE_SUB(NOW(), 1 YEAR) AND NOW vs >= CURRENT_DATE - INTERVAL '1 YEAR') are effectively equivalent for DATE-typed inspection_date, as both capture the same one-year window. Both approaches exclude vessels with at least one inspection in the period, and the sample data shows they would produce the same result. The NOT IN and NOT EXISTS logic also align in this context, as the subquery does not return NULLs."}
{"example_id": 5687, "sql_complexity": "multiple_joins", "prompt": "List organizations with more than 200 volunteers, and their average donation amounts, excluding donations less than $10.", "context": "CREATE TABLE organizations (org_id INT, org_name TEXT, social_impact_score INT);CREATE TABLE volunteers (vol_id INT, org_id INT, vol_country TEXT);CREATE TABLE donations (donation_id INT, donor_id INT, donation_amount INT, donation_date DATE);", "reference_sql": "SELECT o.org_name, AVG(donation_amount) AS avg_donation_amount FROM organizations o JOIN volunteers v ON o.org_id = v.org_id JOIN donations don ON o.org_id = don.org_id WHERE donation_amount >= 10 GROUP BY o.org_name HAVING COUNT(v.vol_id) > 200;", "generated_sql": "SELECT o.org_id, o.org_name, AVG(d.donation_amount) AS avg_donation_amount\nFROM organizations o\nJOIN volunteers v ON o.org_id = v.org_id\nJOIN donations d ON v.vol_id = d.donor_id\nWHERE d.donation_amount >= 10\nGROUP BY o.org_id, o.org_name\nHAVING COUNT(v.vol_id) > 200;", "raw_model_output": "<think>\n\n</think>\n\nSELECT o.org_id, o.org_name, AVG(d.donation_amount) AS avg_donation_amount\nFROM organizations o\nJOIN volunteers v ON o.org_id = v.org_id\nJOIN donations d ON v.vol_id = d.donor_id\nWHERE d.donation_amount >= 10\nGROUP BY o.org_id, o.org_name\nHAVING COUNT(v.vol_id) > 200;", "latency_sec": 1.563138723373413, "total_duration_sec": 1.271493719, "load_duration_sec": 0.010279834, "tokens_prompt": 152, "prompt_eval_sec": 0.030859408, "tokens_completion": 88, "completion_eval_sec": 1.227555221, "tokens_total": 240, "tokens_per_sec": 153.53723659411077, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their join conditions between 'volunteers' and 'donations'. The Reference SQL joins donations on 'o.org_id' (organization ID), while the Generated SQL joins donations on 'v.vol_id = d.donor_id' (volunteer ID to donor ID). This changes the data being aggregated, leading to different results. Additionally, the Generated SQL groups by both 'org_id' and 'org_name' while the Reference SQL only groups by 'org_name', which could affect results if organizations have non-unique names."}
{"example_id": 1281, "sql_complexity": "subqueries", "prompt": "Find the top 3 contributors with the lowest recycling rate in the 'waste_contributors' table.", "context": "CREATE TABLE waste_contributors (contributor VARCHAR(20), recycling_rate FLOAT); INSERT INTO waste_contributors (contributor, recycling_rate) VALUES ('Manufacturing', 0.4), ('Commercial', 0.38), ('Residential', 0.35), ('Institutional', 0.32), ('Agricultural', 0.2), ('Industrial', 0.15);", "reference_sql": "SELECT contributor FROM waste_contributors WHERE recycling_rate IN (SELECT MIN(recycling_rate) FROM waste_contributors) LIMIT 3;", "generated_sql": "SELECT contributor, recycling_rate\nFROM waste_contributors\nORDER BY recycling_rate ASC\nLIMIT 3;", "raw_model_output": "<think>\n\n</think>\n\nSELECT contributor, recycling_rate\nFROM waste_contributors\nORDER BY recycling_rate ASC\nLIMIT 3;", "latency_sec": 0.6423468589782715, "total_duration_sec": 0.419628176, "load_duration_sec": 0.026458807, "tokens_prompt": 181, "prompt_eval_sec": 0.016770899, "tokens_completion": 26, "completion_eval_sec": 0.374270215, "tokens_total": 207, "tokens_per_sec": 322.2557985715972, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL selects contributors with the minimum recycling rate (only 'Industrial' in this case) and limits to 3 rows. The Generated SQL orders all contributors by recycling rate ascending and returns the top 3 (Industrial, Agricultural, Institutional). The queries differ in: 1) Column selection (contributor only vs contributor+recycling_rate), 2) Logic (filtering for minimum value vs ordering and limiting), and 3) Result count (1 row vs 3 rows)."}
{"example_id": 5669, "sql_complexity": "window functions", "prompt": "What is the total number of new and returning volunteers in each program in each month?", "context": "CREATE TABLE Volunteers (VolunteerID INT, VolunteerName TEXT, ProgramID INT, VolunteerDate DATE, IsReturning BOOLEAN); INSERT INTO Volunteers (VolunteerID, VolunteerName, ProgramID, VolunteerDate, IsReturning) VALUES (6, 'David Kim', 1, '2022-03-01', FALSE), (7, 'Emily Chen', 2, '2022-03-15', TRUE), (8, 'James Lee', 2, '2022-04-01', FALSE), (9, 'Grace Park', 3, '2022-04-15', TRUE), (10, 'Daniel Kim', 1, '2022-04-01', FALSE);", "reference_sql": "SELECT ProgramID, EXTRACT(MONTH FROM VolunteerDate) AS Month, SUM(CASE WHEN IsReturning THEN 1 ELSE 0 END) OVER (PARTITION BY ProgramID, EXTRACT(MONTH FROM VolunteerDate) ORDER BY ProgramID, EXTRACT(MONTH FROM VolunteerDate)) + COUNT(DISTINCT VolunteerID) OVER (PARTITION BY ProgramID, EXTRACT(MONTH FROM VolunteerDate) ORDER BY ProgramID, EXTRACT(MONTH FROM VolunteerDate)) AS TotalVolunteers FROM Volunteers;", "generated_sql": "SELECT \n    ProgramID, \n    EXTRACT(MONTH FROM VolunteerDate) AS Month, \n    SUM(CASE WHEN IsReturning = TRUE THEN 1 ELSE 0 END) AS ReturningVolunteers, \n    SUM(CASE WHEN IsReturning = FALSE THEN 1 ELSE 0 END) AS NewVolunteers\nFROM Volunteers\nGROUP BY ProgramID, EXTRACT(MONTH FROM VolunteerDate);", "raw_model_output": "<think>\n\n</think>\n\nSELECT \n    ProgramID, \n    EXTRACT(MONTH FROM VolunteerDate) AS Month, \n    SUM(CASE WHEN IsReturning = TRUE THEN 1 ELSE 0 END) AS ReturningVolunteers, \n    SUM(CASE WHEN IsReturning = FALSE THEN 1 ELSE 0 END) AS NewVolunteers\nFROM Volunteers\nGROUP BY ProgramID, EXTRACT(MONTH FROM VolunteerDate);", "latency_sec": 1.5162789821624756, "total_duration_sec": 1.307043074, "load_duration_sec": 0.013953829, "tokens_prompt": 256, "prompt_eval_sec": 0.024739942, "tokens_completion": 88, "completion_eval_sec": 1.265753665, "tokens_total": 344, "tokens_per_sec": 226.87117875194485, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL uses window functions to calculate a combined 'TotalVolunteers' by summing returning volunteers and distinct volunteer counts within partitions, while the Generated SQL groups data to separately count returning and new volunteers. The Reference SQL returns multiple rows per group with redundant values, whereas the Generated SQL aggregates into one row per group. Additionally, the calculation logic differs: the Reference SQL adds returning counts and distinct counts (which is not equivalent to separate returning/new counts)."}
{"example_id": 3576, "sql_complexity": "window functions", "prompt": "What is the difference in the number of eco-friendly hotels between the top 2 countries?", "context": "CREATE TABLE eco_hotel_count (country TEXT, num_hotels INT); INSERT INTO eco_hotel_count (country, num_hotels) VALUES ('France', 100), ('Italy', 120), ('Germany', 150), ('Spain', 110), ('UK', 160);", "reference_sql": "SELECT (MAX(num_hotels) OVER (PARTITION BY num_hotels <= 2) - MIN(num_hotels) OVER (PARTITION BY num_hotels <= 2)) AS hotel_difference FROM eco_hotel_count WHERE country IN ('France', 'Italy');", "generated_sql": "SELECT (SELECT num_hotels FROM eco_hotel_count ORDER BY num_hotels DESC LIMIT 1) - (SELECT num_hotels FROM eco_hotel_count ORDER BY num_hotels DESC LIMIT 1 OFFSET 1) AS difference;", "raw_model_output": "<think>\n\n</think>\n\nSELECT (SELECT num_hotels FROM eco_hotel_count ORDER BY num_hotels DESC LIMIT 1) - (SELECT num_hotels FROM eco_hotel_count ORDER BY num_hotels DESC LIMIT 1 OFFSET 1) AS difference;", "latency_sec": 1.0673589706420898, "total_duration_sec": 0.779338676, "load_duration_sec": 0.016927462, "tokens_prompt": 159, "prompt_eval_sec": 0.016054329, "tokens_completion": 53, "completion_eval_sec": 0.743129945, "tokens_total": 212, "tokens_per_sec": 198.6210879667479, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters rows to only 'France' and 'Italy' before calculating the difference between MAX and MIN of num_hotels, resulting in 120-100=20. The Generated SQL operates on the entire table without filtering, calculating 160-150=10. The different data subsets lead to different results."}
{"example_id": 1970, "sql_complexity": "multiple_joins", "prompt": "List all players who have played a specific VR game, 'CyberSphere', and their ages.", "context": "CREATE TABLE Players (PlayerID INT, Age INT, Gender VARCHAR(10), Country VARCHAR(50)); CREATE TABLE VRPlayers (PlayerID INT, VRGameID INT); CREATE TABLE VRGames (VRGameID INT, Title VARCHAR(50)); INSERT INTO Players (PlayerID, Age, Gender, Country) VALUES (1, 25, 'Male', 'USA'); INSERT INTO Players (PlayerID, Age, Gender, Country) VALUES (2, 28, 'Female', 'Canada'); INSERT INTO VRPlayers (PlayerID, VRGameID) VALUES (1, 1); INSERT INTO VRPlayers (PlayerID, VRGameID) VALUES (2, 1); INSERT INTO VRGames (VRGameID, Title) VALUES (1, 'CyberSphere');", "reference_sql": "SELECT Players.Age, Players.PlayerID FROM Players INNER JOIN VRPlayers ON Players.PlayerID = VRPlayers.PlayerID INNER JOIN VRGames ON VRPlayers.VRGameID = VRGames.VRGameID WHERE VRGames.Title = 'CyberSphere';", "generated_sql": "SELECT P.PlayerID, P.Age\nFROM Players P\nJOIN VRPlayers VP ON P.PlayerID = VP.PlayerID\nJOIN VRGames VG ON VP.VRGameID = VG.VRGameID\nWHERE VG.Title = 'CyberSphere';", "raw_model_output": "<think>\n\n</think>\n\nSELECT P.PlayerID, P.Age\nFROM Players P\nJOIN VRPlayers VP ON P.PlayerID = VP.PlayerID\nJOIN VRGames VG ON VP.VRGameID = VG.VRGameID\nWHERE VG.Title = 'CyberSphere';", "latency_sec": 0.9841501712799072, "total_duration_sec": 0.869761625, "load_duration_sec": 0.023600492, "tokens_prompt": 257, "prompt_eval_sec": 0.030012989, "tokens_completion": 56, "completion_eval_sec": 0.813689343, "tokens_total": 313, "tokens_per_sec": 318.0408936909874, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (PlayerID and Age) from the Players table, join with VRPlayers and VRGames on identical conditions, and filter where VRGames.Title equals 'CyberSphere'. The differences are purely syntactic (table aliases and column order) and do not affect the result."}
{"example_id": 2414, "sql_complexity": "window functions", "prompt": "List the policy areas with the lowest citizen satisfaction scores.", "context": "CREATE TABLE Policy (Area VARCHAR(20), Score INT); INSERT INTO Policy (Area, Score) VALUES ('Transportation', 70), ('Education', 85), ('Healthcare', 75), ('PublicSafety', 80);", "reference_sql": "SELECT Area, Score FROM (SELECT Area, Score, ROW_NUMBER() OVER (ORDER BY Score) AS RN FROM Policy) X WHERE RN IN (1, 2);", "generated_sql": "SELECT Area\nFROM Policy\nORDER BY Score ASC\nLIMIT 1;", "raw_model_output": "<think>\n\n</think>\n\nSELECT Area\nFROM Policy\nORDER BY Score ASC\nLIMIT 1;", "latency_sec": 0.40024495124816895, "total_duration_sec": 0.314163573, "load_duration_sec": 0.014779907, "tokens_prompt": 136, "prompt_eval_sec": 0.014521375, "tokens_completion": 20, "completion_eval_sec": 0.281923206, "tokens_total": 156, "tokens_per_sec": 389.76131869624345, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL retrieves the top 2 rows ordered by Score (Transportation and Healthcare), while the Generated SQL only retrieves the top 1 row (Transportation). The Generated SQL lacks the second row and omits the Score column, making them non-equivalent."}
{"example_id": 1898, "sql_complexity": "single join", "prompt": "What are the total sales for each drug in Q2 2020?", "context": "CREATE TABLE drugs (drug_id INT, drug_name TEXT); INSERT INTO drugs (drug_id, drug_name) VALUES (1001, 'Ibuprofen'), (1002, 'Paracetamol'), (1003, 'Aspirin'); CREATE TABLE sales (sale_id INT, drug_id INT, sale_date DATE, revenue FLOAT); INSERT INTO sales (sale_id, drug_id, sale_date, revenue) VALUES (1, 1001, '2020-04-05', 1800.0), (2, 1002, '2020-04-10', 2300.0), (3, 1003, '2020-04-15', 1400.0), (4, 1001, '2020-05-20', 1900.0), (5, 1002, '2020-06-25', 2400.0);", "reference_sql": "SELECT drug_name, SUM(revenue) as total_sales FROM sales JOIN drugs ON sales.drug_id = drugs.drug_id WHERE sale_date BETWEEN '2020-04-01' AND '2020-06-30' GROUP BY drug_name;", "generated_sql": "SELECT d.drug_name, SUM(s.revenue) AS total_sales\nFROM drugs d\nJOIN sales s ON d.drug_id = s.drug_id\nWHERE s.sale_date BETWEEN '2020-04-01' AND '2020-06-30'\nGROUP BY d.drug_id, d.drug_name;", "raw_model_output": "<think>\n\n</think>\n\nSELECT d.drug_name, SUM(s.revenue) AS total_sales\nFROM drugs d\nJOIN sales s ON d.drug_id = s.drug_id\nWHERE s.sale_date BETWEEN '2020-04-01' AND '2020-06-30'\nGROUP BY d.drug_id, d.drug_name;", "latency_sec": 1.4420249462127686, "total_duration_sec": 1.220171545, "load_duration_sec": 0.014292286, "tokens_prompt": 327, "prompt_eval_sec": 0.034022518, "tokens_completion": 80, "completion_eval_sec": 1.169861675, "tokens_total": 407, "tokens_per_sec": 282.241996623509, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate total sales per drug within the same date range. The Reference SQL groups by drug_name, while the Generated SQL groups by both drug_id and drug_name. Since drug_id is a primary key (unique and non-null), grouping by either drug_id or drug_name (which is functionally dependent on drug_id) produces identical results. The JOIN conditions, WHERE clause, and aggregation are equivalent."}
{"example_id": 2403, "sql_complexity": "multiple_joins", "prompt": "Who is the most frequent customer ordering vegetarian items?", "context": "CREATE TABLE customers (customer_id INT, customer_name VARCHAR(50)); INSERT INTO customers VALUES (1, 'John Doe'), (2, 'Jane Smith'), (3, 'Alice Johnson'); CREATE TABLE orders (order_id INT, customer_id INT, menu_id INT, order_date DATE); INSERT INTO orders VALUES (1, 1, 1, '2022-01-01'), (2, 2, 3, '2022-01-02'), (3, 3, 2, '2022-01-03'); CREATE TABLE menu (menu_id INT, item_name VARCHAR(50), is_vegetarian BOOLEAN, price DECIMAL(5,2)); INSERT INTO menu VALUES (1, 'Veggie Burger', true, 8.99), (2, 'Cheeseburger', false, 7.99), (3, 'Tofu Stir Fry', true, 11.99);", "reference_sql": "SELECT customers.customer_name, COUNT(orders.order_id) as order_count FROM customers INNER JOIN orders ON customers.customer_id = orders.customer_id INNER JOIN menu ON orders.menu_id = menu.menu_id WHERE menu.is_vegetarian = true GROUP BY customers.customer_name ORDER BY order_count DESC LIMIT 1;", "generated_sql": "SELECT c.customer_name, COUNT(*) AS order_count\nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nJOIN menu m ON o.menu_id = m.menu_id\nWHERE m.is_vegetarian = TRUE\nGROUP BY c.customer_id\nORDER BY order_count DESC\nLIMIT 1;", "raw_model_output": "<think>\n\n</think>\n\nSELECT c.customer_name, COUNT(*) AS order_count\nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nJOIN menu m ON o.menu_id = m.menu_id\nWHERE m.is_vegetarian = TRUE\nGROUP BY c.customer_id\nORDER BY order_count DESC\nLIMIT 1;", "latency_sec": 1.1220080852508545, "total_duration_sec": 1.05821286, "load_duration_sec": 0.019209105, "tokens_prompt": 294, "prompt_eval_sec": 0.034519256, "tokens_completion": 69, "completion_eval_sec": 1.001013294, "tokens_total": 363, "tokens_per_sec": 323.527080394293, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their GROUP BY clauses. The reference query groups by customer_name, while the generated query groups by customer_id. Although customer_id is unique, the generated query's GROUP BY clause does not include customer_name (which is selected) and may produce different results if customer_name is not unique. Additionally, the generated query uses COUNT(*) instead of COUNT(orders.order_id), which could differ if there were NULLs in order_id, but in this case, they are equivalent. However, the GROUP BY discrepancy makes them non-equivalent."}
{"example_id": 124, "sql_complexity": "set operations", "prompt": "Find the intersection of AI and accessibility research projects in the EU and those in Africa.", "context": "CREATE SCHEMA if not exists accessibility; CREATE TABLE if not exists accessibility.research (id INT PRIMARY KEY, project_name VARCHAR(255), region VARCHAR(255)); INSERT INTO accessibility.research (id, project_name, region) VALUES (1, 'AI for Accessibility EU', 'EU'), (2, 'Accessibility Africa', 'Africa'), (3, 'AI for Accessibility Africa', 'Africa'), (4, 'Accessibility EU', 'EU');", "reference_sql": "SELECT project_name FROM accessibility.research WHERE region = 'EU' INTERSECT SELECT project_name FROM accessibility.research WHERE region = 'Africa';", "generated_sql": "SELECT project_name\nFROM accessibility.research\nWHERE (project_name LIKE '%AI%' AND region = 'EU')\n   OR (project_name LIKE '%AI%' AND region = 'Africa');", "raw_model_output": "<think>\n\n</think>\n\nSELECT project_name\nFROM accessibility.research\nWHERE (project_name LIKE '%AI%' AND region = 'EU')\n   OR (project_name LIKE '%AI%' AND region = 'Africa');", "latency_sec": 0.7503910064697266, "total_duration_sec": 0.659842722, "load_duration_sec": 0.024842072, "tokens_prompt": 184, "prompt_eval_sec": 0.018229837, "tokens_completion": 43, "completion_eval_sec": 0.61362961, "tokens_total": 227, "tokens_per_sec": 302.5089560547098, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses INTERSECT to find project_names present in both 'EU' and 'Africa' regions, which returns no results because no project names are shared between the regions. The Generated SQL selects project_names containing 'AI' in either region, returning two rows ('AI for Accessibility EU' and 'AI for Accessibility Africa'). The queries have different logical conditions and produce distinct results."}
{"example_id": 1231, "sql_complexity": "basic SQL", "prompt": "What is the average ticket price for performances at the 'Downtown Theater'?", "context": "CREATE TABLE DowntownTheater (show_name TEXT, date DATE, ticket_price FLOAT); INSERT INTO DowntownTheater (show_name, date, ticket_price) VALUES ('Play 1', '2022-01-01', 30.0), ('Play 2', '2022-01-02', 40.0), ('Concert 1', '2022-01-03', 50.0);", "reference_sql": "SELECT AVG(ticket_price) FROM DowntownTheater WHERE show_name = 'Downtown Theater'", "generated_sql": "SELECT AVG(ticket_price) AS average_ticket_price\nFROM DowntownTheater;", "raw_model_output": "<think>\n\n</think>\n\nSELECT AVG(ticket_price) AS average_ticket_price\nFROM DowntownTheater;", "latency_sec": 0.5861611366271973, "total_duration_sec": 0.328984927, "load_duration_sec": 0.019002034, "tokens_prompt": 190, "prompt_eval_sec": 0.018166038, "tokens_completion": 20, "completion_eval_sec": 0.289660031, "tokens_total": 210, "tokens_per_sec": 358.2632605231239, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters for show_name = 'Downtown Theater' which doesn't exist in the sample data (returns NULL), while the Generated SQL calculates the average of all tickets. The WHERE clause in Reference SQL makes them non-equivalent."}
{"example_id": 1485, "sql_complexity": "set operations", "prompt": "How many public schools and public libraries exist in total, in the 'CityData' schema's 'CityEducation' and 'CityLibrary' tables?", "context": "CREATE SCHEMA CityData; CREATE TABLE CityEducation (Name varchar(255), Type varchar(255)); INSERT INTO CityEducation (Name, Type) VALUES ('SchoolA', 'Public'), ('SchoolB', 'Public'), ('SchoolC', 'Private'); CREATE TABLE CityLibrary (Name varchar(255), Type varchar(255)); INSERT INTO CityLibrary (Name, Type) VALUES ('LibraryA', 'Public'), ('LibraryB', 'Public'), ('LibraryC', 'Private');", "reference_sql": "SELECT COUNT(*) FROM CityData.CityEducation WHERE Type = 'Public' UNION ALL SELECT COUNT(*) FROM CityData.CityLibrary WHERE Type = 'Public';", "generated_sql": "SELECT COUNT(*) AS TotalPublicInstitutions\nFROM (\n    SELECT Name FROM CityEducation WHERE Type = 'Public'\n    UNION ALL\n    SELECT Name FROM CityLibrary WHERE Type = 'Public'\n) AS PublicInstitutions;", "raw_model_output": "<think>\n\n</think>\n\nSELECT COUNT(*) AS TotalPublicInstitutions\nFROM (\n    SELECT Name FROM CityEducation WHERE Type = 'Public'\n    UNION ALL\n    SELECT Name FROM CityLibrary WHERE Type = 'Public'\n) AS PublicInstitutions;", "latency_sec": 0.8502521514892578, "total_duration_sec": 0.762578119, "load_duration_sec": 0.024029081, "tokens_prompt": 208, "prompt_eval_sec": 0.020985657, "tokens_completion": 50, "completion_eval_sec": 0.715323549, "tokens_total": 258, "tokens_per_sec": 303.43939682845905, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate counts (one for CityEducation and one for CityLibrary) as two rows, while the Generated SQL combines all public institutions into a single count. The Reference SQL's output structure differs from the Generated SQL's output, making them non-equivalent."}
{"example_id": 5806, "sql_complexity": "single join", "prompt": "List the top 3 countries with the most veteran employment in the IT industry", "context": "CREATE TABLE veteran_employment (employee_id INT, industry VARCHAR(255), salary DECIMAL(10,2), state VARCHAR(2), country VARCHAR(255)); CREATE TABLE countries (country_id INT, country VARCHAR(255));", "reference_sql": "SELECT country, COUNT(*) as num_veterans FROM veteran_employment JOIN countries ON veteran_employment.country = countries.country WHERE industry = 'IT' GROUP BY country ORDER BY num_veterans DESC LIMIT 3;", "generated_sql": "SELECT c.country, COUNT(*) AS veteran_employment_count\nFROM veteran_employment ve\nJOIN countries c ON ve.country = c.country\nWHERE ve.industry = 'IT'\nGROUP BY c.country\nORDER BY veteran_employment_count DESC\nLIMIT 3;", "raw_model_output": "<think>\n\n</think>\n\nSELECT c.country, COUNT(*) AS veteran_employment_count\nFROM veteran_employment ve\nJOIN countries c ON ve.country = c.country\nWHERE ve.industry = 'IT'\nGROUP BY c.country\nORDER BY veteran_employment_count DESC\nLIMIT 3;", "latency_sec": 0.9928381443023682, "total_duration_sec": 0.836535091, "load_duration_sec": 0.013761837, "tokens_prompt": 141, "prompt_eval_sec": 0.013420162, "tokens_completion": 58, "completion_eval_sec": 0.807146916, "tokens_total": 199, "tokens_per_sec": 200.43549005646855, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between veteran_employment and countries on the country column, filter for industry = 'IT', group by country, and order by count in descending order with a limit of 3. The differences are purely syntactic (table aliases and column aliases) and do not affect the semantic result."}
{"example_id": 4126, "sql_complexity": "window functions", "prompt": "What is the average crime rate per capita in each neighborhood?", "context": "CREATE TABLE neighborhoods (name VARCHAR(255), population INT, crime_count INT); INSERT INTO neighborhoods (name, population, crime_count) VALUES ('Central Park', 1000, 25), ('Harlem', 2500, 75), ('Brooklyn', 5000, 120);", "reference_sql": "SELECT name, AVG(crime_count/population) OVER (PARTITION BY name) FROM neighborhoods;", "generated_sql": "SELECT name, crime_count * 1000.0 / population AS crime_rate_per_capita\nFROM neighborhoods;", "raw_model_output": "<think>\n\n</think>\n\nSELECT name, crime_count * 1000.0 / population AS crime_rate_per_capita\nFROM neighborhoods;", "latency_sec": 0.597700834274292, "total_duration_sec": 0.455454543, "load_duration_sec": 0.013544563, "tokens_prompt": 157, "prompt_eval_sec": 0.014887564, "tokens_completion": 30, "completion_eval_sec": 0.42369381, "tokens_total": 187, "tokens_per_sec": 312.8655495805841, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates the average of (crime_count/population) over each neighborhood (which simplifies to crime_count/population due to single-row partitions), while the Generated SQL computes (crime_count * 1000.0) / population. The latter scales the result by 1000, producing values 1000x larger than the former."}
{"example_id": 4559, "sql_complexity": "basic SQL", "prompt": "List the top 3 energy efficient appliances in the US by energy star rating?", "context": "CREATE TABLE appliances (id INT, name VARCHAR(255), country VARCHAR(255), energy_star_rating INT); INSERT INTO appliances (id, name, country, energy_star_rating) VALUES (1, 'Fridge A', 'USA', 5), (2, 'TV B', 'USA', 4), (3, 'Laptop C', 'USA', 5), (4, 'Microwave D', 'USA', 3);", "reference_sql": "SELECT name, energy_star_rating FROM appliances WHERE country = 'USA' ORDER BY energy_star_rating DESC LIMIT 3;", "generated_sql": "SELECT id, name, energy_star_rating\nFROM appliances\nWHERE country = 'USA'\nORDER BY energy_star_rating DESC\nLIMIT 3;", "raw_model_output": "<think>\n\n</think>\n\nSELECT id, name, energy_star_rating\nFROM appliances\nWHERE country = 'USA'\nORDER BY energy_star_rating DESC\nLIMIT 3;", "latency_sec": 0.6174209117889404, "total_duration_sec": 0.535520876, "load_duration_sec": 0.028795892, "tokens_prompt": 184, "prompt_eval_sec": 0.01804235, "tokens_completion": 34, "completion_eval_sec": 0.48639984, "tokens_total": 218, "tokens_per_sec": 353.08165926605557, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent because they select different columns. The Reference SQL selects only 'name' and 'energy_star_rating', while the Generated SQL includes an additional 'id' column. Although both filter and sort the same data, the extra column in the Generated SQL changes the result set structure, making them semantically different."}
{"example_id": 456, "sql_complexity": "window functions", "prompt": "List the intelligence operations and their corresponding threat levels, and rank them based on their threat level and budget.", "context": "CREATE TABLE intel_ops_threat (id INT, operation VARCHAR, threat VARCHAR, budget INT); INSERT INTO intel_ops_threat (id, operation, threat, budget) VALUES (1, 'Operation Red Folder', 'High', 5000000), (2, 'Operation Black Vault', 'Medium', 7000000), (3, 'Operation Blue Sail', 'Low', 6000000);", "reference_sql": "SELECT operation, threat, budget, ROW_NUMBER() OVER (PARTITION BY threat ORDER BY budget DESC) as rank FROM intel_ops_threat;", "generated_sql": "SELECT operation, threat, budget\nFROM intel_ops_threat\nORDER BY \n    CASE WHEN threat = 'High' THEN 1 \n         WHEN threat = 'Medium' THEN 2 \n         WHEN threat = 'Low' THEN 3 \n         ELSE 4 END,\n    budget DESC;", "raw_model_output": "<think>\n\n</think>\n\nSELECT operation, threat, budget\nFROM intel_ops_threat\nORDER BY \n    CASE WHEN threat = 'High' THEN 1 \n         WHEN threat = 'Medium' THEN 2 \n         WHEN threat = 'Low' THEN 3 \n         ELSE 4 END,\n    budget DESC;", "latency_sec": 1.2680647373199463, "total_duration_sec": 0.947491032, "load_duration_sec": 0.014343998, "tokens_prompt": 188, "prompt_eval_sec": 0.019546237, "tokens_completion": 65, "completion_eval_sec": 0.911456858, "tokens_total": 253, "tokens_per_sec": 199.5166276247972, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL includes a ROW_NUMBER() column that assigns ranks within threat partitions, while the Generated SQL omits this column. Additionally, the Generated SQL explicitly orders results by threat priority and budget, whereas the Reference SQL lacks an ORDER BY clause, making its output order undefined. The presence of different columns and differing ordering logic ensures they produce distinct results."}
{"example_id": 459, "sql_complexity": "set operations", "prompt": "What is the total installed capacity of hydroelectric power plants in Brazil and Canada?", "context": "CREATE TABLE hydroelectric_power (country TEXT, capacity INTEGER); INSERT INTO hydroelectric_power (country, capacity) VALUES ('Brazil', 104000), ('Canada', 78000), ('China', 350000), ('United States', 100000), ('Russia', 45000);", "reference_sql": "(SELECT capacity FROM hydroelectric_power WHERE country = 'Brazil') UNION (SELECT capacity FROM hydroelectric_power WHERE country = 'Canada');", "generated_sql": "SELECT SUM(capacity) AS total_capacity\nFROM hydroelectric_power\nWHERE country IN ('Brazil', 'Canada');", "raw_model_output": "<think>\n\n</think>\n\nSELECT SUM(capacity) AS total_capacity\nFROM hydroelectric_power\nWHERE country IN ('Brazil', 'Canada');", "latency_sec": 0.5235641002655029, "total_duration_sec": 0.431819121, "load_duration_sec": 0.0181455, "tokens_prompt": 165, "prompt_eval_sec": 0.016752312, "tokens_completion": 28, "completion_eval_sec": 0.39469646, "tokens_total": 193, "tokens_per_sec": 368.62726054389213, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate capacity values for Brazil and Canada as individual rows, while the Generated SQL returns a single summed value of their capacities. The first query produces multiple rows, the second a single aggregated value, so they are not semantically equivalent."}
{"example_id": 2356, "sql_complexity": "window functions", "prompt": "Find the total billing amount for attorneys in the 'Criminal Law' practice area, for the year 2020, partitioned by attorney's last name and ordered by the total billing amount in descending order.", "context": "CREATE TABLE Attorneys (AttorneyID INT, FirstName VARCHAR(50), LastName VARCHAR(50), PracticeArea VARCHAR(50), TotalBilling FLOAT, BillingYear INT); INSERT INTO Attorneys (AttorneyID, FirstName, LastName, PracticeArea, TotalBilling, BillingYear) VALUES (1, 'Clara', 'Rivera', 'Personal Injury', 8000.00, 2020), (2, 'Jamal', 'Lee', 'Personal Injury', 6000.00, 2019), (3, 'Sophia', 'Gomez', 'Criminal Law', 9000.00, 2020);", "reference_sql": "SELECT LastName, SUM(TotalBilling) OVER (PARTITION BY PracticeArea, LastName, BillingYear) AS TotalBilling FROM Attorneys WHERE PracticeArea = 'Criminal Law' AND BillingYear = 2020 ORDER BY TotalBilling DESC;", "generated_sql": "SELECT \n    LastName, \n    SUM(TotalBilling) AS TotalBilling\nFROM \n    Attorneys\nWHERE \n    PracticeArea = 'Criminal Law' \n    AND BillingYear = 2020\nGROUP BY \n    LastName\nORDER BY \n    TotalBilling DESC;", "raw_model_output": "<think>\n\n</think>\n\nSELECT \n    LastName, \n    SUM(TotalBilling) AS TotalBilling\nFROM \n    Attorneys\nWHERE \n    PracticeArea = 'Criminal Law' \n    AND BillingYear = 2020\nGROUP BY \n    LastName\nORDER BY \n    TotalBilling DESC;", "latency_sec": 1.18048095703125, "total_duration_sec": 0.965691508, "load_duration_sec": 0.013724616, "tokens_prompt": 266, "prompt_eval_sec": 0.027020383, "tokens_completion": 64, "completion_eval_sec": 0.922782362, "tokens_total": 330, "tokens_per_sec": 279.54707615945404, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL uses a window function to calculate the sum per (PracticeArea, LastName, BillingYear) without grouping, retaining all rows. The Generated SQL groups by LastName, aggregating rows. If multiple entries exist for the same LastName in the filtered criteria, the Reference SQL would return multiple rows with the same sum, while the Generated SQL would consolidate them into a single row. In the given data, they produce the same result due to unique LastName entries, but they differ in general cases."}
