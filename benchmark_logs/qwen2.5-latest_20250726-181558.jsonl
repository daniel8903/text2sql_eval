{"example_id": 904, "sql_complexity": "basic SQL", "prompt": "What is the minimum Shariah-compliant loan amount issued in the last quarter of 2021?", "context": "CREATE TABLE loans (id INT, amount DECIMAL, date DATE, loan_type VARCHAR); INSERT INTO loans (id, amount, date, loan_type) VALUES (1, 5000, '2021-09-05', 'Shariah-compliant'), (2, 7000, '2021-10-07', 'socially responsible'), (3, 9000, '2021-11-03', 'Shariah-compliant'), (4, 11000, '2021-12-31', 'Shariah-compliant');", "reference_sql": "SELECT MIN(amount) FROM loans WHERE EXTRACT(YEAR FROM date) = 2021 AND EXTRACT(QUARTER FROM date) = 4 AND loan_type = 'Shariah-compliant';", "generated_sql": "SELECT MIN(amount) AS min_shariah_compliant_loan_amount \nFROM loans \nWHERE loan_type = 'Shariah-compliant' AND date BETWEEN '2021-10-01' AND '2021-12-31';", "raw_model_output": "```sql\nSELECT MIN(amount) AS min_shariah_compliant_loan_amount \nFROM loans \nWHERE loan_type = 'Shariah-compliant' AND date BETWEEN '2021-10-01' AND '2021-12-31';\n```", "latency_sec": 29.27164626121521, "total_duration_sec": 28.968844208, "load_duration_sec": 0.025749171, "tokens_prompt": 897, "prompt_eval_sec": 23.961014702, "tokens_completion": 61, "completion_eval_sec": 4.978803093, "tokens_total": 958, "tokens_per_sec": 32.727916682613966, "retrieval_latency_sec": 0.7035391330718994, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter 'Shariah-compliant' loans in the fourth quarter of 2021. The Reference SQL uses EXTRACT(QUARTER) = 4 (which corresponds to October-December) and EXTRACT(YEAR) = 2021. The Generated SQL uses a date range from '2021-10-01' to '2021-12-31', which covers the same period. Since the date range in the Generated SQL implicitly ensures the year is 2021, both queries select the same subset of loans, resulting in the same MIN(amount)."}
{"example_id": 5168, "sql_complexity": "aggregation", "prompt": "Get the number of renewable energy projects in Australia for each project type.", "context": "CREATE TABLE renewable_projects (id INT PRIMARY KEY, project_name VARCHAR(255), project_location VARCHAR(255), project_type VARCHAR(255), capacity_mw FLOAT);", "reference_sql": "SELECT project_type, COUNT(*) FROM renewable_projects WHERE project_location = 'Australia' GROUP BY project_type;", "generated_sql": "SELECT project_type, COUNT(*) \nFROM renewable_projects \nWHERE project_location = 'Australia' \nGROUP BY project_type;", "raw_model_output": "```sql\nSELECT project_type, COUNT(*) \nFROM renewable_projects \nWHERE project_location = 'Australia' \nGROUP BY project_type;\n```", "latency_sec": 17.173943042755127, "total_duration_sec": 17.071866586, "load_duration_sec": 0.032159678, "tokens_prompt": 581, "prompt_eval_sec": 14.717082258, "tokens_completion": 29, "completion_eval_sec": 2.318587735, "tokens_total": 610, "tokens_per_sec": 35.51892529755012, "retrieval_latency_sec": 0.10370516777038574, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. The only differences are formatting (line breaks and whitespace) which do not affect semantic meaning. Both select project_type and count rows from renewable_projects where project_location is 'Australia', grouped by project_type."}
{"example_id": 5039, "sql_complexity": "subqueries", "prompt": "What is the total number of community policing events in 'City Park' in 2021?", "context": "CREATE TABLE locations (id INT, name VARCHAR(255)); CREATE TABLE community_policing (id INT, location_id INT, year INT, events INT); INSERT INTO locations (id, name) VALUES (1, 'City Park'); INSERT INTO community_policing (id, location_id, year, events) VALUES (1, 1, 2021, 5);", "reference_sql": "SELECT SUM(events) FROM community_policing WHERE location_id = (SELECT id FROM locations WHERE name = 'City Park') AND year = 2021;", "generated_sql": "SELECT SUM(events) AS total_events\nFROM community_policing cp\nJOIN locations l ON cp.location_id = l.id\nWHERE l.name = 'City Park' AND cp.year = 2021;", "raw_model_output": "```sql\nSELECT SUM(events) AS total_events\nFROM community_policing cp\nJOIN locations l ON cp.location_id = l.id\nWHERE l.name = 'City Park' AND cp.year = 2021;\n```", "latency_sec": 25.11000084877014, "total_duration_sec": 24.962800239, "load_duration_sec": 0.029432073, "tokens_prompt": 797, "prompt_eval_sec": 20.953488691, "tokens_completion": 49, "completion_eval_sec": 3.971587539, "tokens_total": 846, "tokens_per_sec": 33.691755133550146, "retrieval_latency_sec": 0.10161375999450684, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of 'events' for the 'City Park' location in 2021. The reference query uses a subquery to get the location ID, while the generated query uses a JOIN. Since there's a one-to-one relationship between 'City Park' and its ID in the data, both approaches yield the same result. The WHERE conditions and aggregation are equivalent in effect."}
{"example_id": 335, "sql_complexity": "single join", "prompt": "List the policy numbers, claim amounts, and claim dates for policies that have more than two claims and the total claim amount exceeds $5000", "context": "CREATE TABLE policies (policy_number INT);CREATE TABLE claims (claim_id INT, policy_number INT, claim_amount DECIMAL(10,2), claim_date DATE);", "reference_sql": "SELECT p.policy_number, c.claim_amount, c.claim_date FROM policies p INNER JOIN claims c ON p.policy_number = c.policy_number GROUP BY p.policy_number, c.claim_amount, c.claim_date HAVING COUNT(c.claim_id) > 2 AND SUM(c.claim_amount) > 5000;", "generated_sql": "SELECT p.policy_number, c.claim_amount, c.claim_date \nFROM policies p \nJOIN claims c ON p.policy_number = c.policy_number \nGROUP BY p.policy_number, c.claim_amount, c.claim_date \nHAVING COUNT(c.claim_id) > 2 AND SUM(c.claim_amount) > 5000;", "raw_model_output": "```sql\nSELECT p.policy_number, c.claim_amount, c.claim_date \nFROM policies p \nJOIN claims c ON p.policy_number = c.policy_number \nGROUP BY p.policy_number, c.claim_amount, c.claim_date \nHAVING COUNT(c.claim_id) > 2 AND SUM(c.claim_amount) > 5000;\n```", "latency_sec": 36.40279507637024, "total_duration_sec": 36.307555231, "load_duration_sec": 0.011206591, "tokens_prompt": 1093, "prompt_eval_sec": 29.881588477, "tokens_completion": 77, "completion_eval_sec": 6.411740632, "tokens_total": 1170, "tokens_per_sec": 32.140389152685415, "retrieval_latency_sec": 0.12883925437927246, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The two queries are semantically equivalent. The only difference is the use of 'INNER JOIN' versus 'JOIN', which are syntactically equivalent in SQL. Both queries select the same columns, join the same tables on the same condition, group by the same expressions, and apply identical HAVING clause conditions. The result set will be identical."}
{"example_id": 5792, "sql_complexity": "multiple_joins", "prompt": "How many cases were handled by attorneys in the 'Los Angeles' office?", "context": "CREATE TABLE offices (office_id INT, office_name VARCHAR(20), city VARCHAR(20), state VARCHAR(20)); INSERT INTO offices (office_id, office_name, city, state) VALUES (1, 'Boston', 'Boston', 'MA'), (2, 'New York', 'New York', 'NY'), (3, 'Los Angeles', 'Los Angeles', 'CA'); CREATE TABLE attorneys (attorney_id INT, office_id INT); INSERT INTO attorneys (attorney_id, office_id) VALUES (1, 1), (2, 2), (3, 3); CREATE TABLE cases (case_id INT, attorney_id INT); INSERT INTO cases (case_id, attorney_id) VALUES (1, 1), (2, 2), (3, 3);", "reference_sql": "SELECT COUNT(*) FROM cases JOIN attorneys ON cases.attorney_id = attorneys.attorney_id JOIN offices ON attorneys.office_id = offices.office_id WHERE offices.city = 'Los Angeles';", "generated_sql": "SELECT COUNT(*) AS cases_handled \nFROM cases \nINNER JOIN attorneys ON cases.attorney_id = attorneys.attorney_id \nINNER JOIN offices ON attorneys.office_id = offices.office_id \nWHERE offices.city = 'Los Angeles';", "raw_model_output": "```sql\nSELECT COUNT(*) AS cases_handled \nFROM cases \nINNER JOIN attorneys ON cases.attorney_id = attorneys.attorney_id \nINNER JOIN offices ON attorneys.office_id = offices.office_id \nWHERE offices.city = 'Los Angeles';\n```", "latency_sec": 28.33258295059204, "total_duration_sec": 28.258322802, "load_duration_sec": 0.032461373, "tokens_prompt": 895, "prompt_eval_sec": 24.13344893, "tokens_completion": 50, "completion_eval_sec": 4.087055062, "tokens_total": 945, "tokens_per_sec": 33.35382452238627, "retrieval_latency_sec": 0.11854696273803711, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform the same three-table join (cases \u2192 attorneys \u2192 offices) with identical join conditions and WHERE clause filtering on offices.city = 'Los Angeles'. The only difference is the aliasing of the COUNT(*) result, which doesn't affect the semantic output."}
{"example_id": 4138, "sql_complexity": "window functions", "prompt": "How many lifelong learning courses has a student with ID '2' completed, in chronological order?", "context": "CREATE TABLE lifelong_learning (student_id INT, course_id INT, completion_date DATE); INSERT INTO lifelong_learning VALUES (2, 1001, '2015-01-01'), (2, 1002, '2016-01-01');", "reference_sql": "SELECT student_id, course_id, COUNT(course_id) OVER (PARTITION BY student_id ORDER BY completion_date) as completed_courses FROM lifelong_learning WHERE student_id = 2;", "generated_sql": "SELECT COUNT(course_id) AS completed_courses\nFROM lifelong_learning\nWHERE student_id = 2\nORDER BY completion_date;", "raw_model_output": "```sql\nSELECT COUNT(course_id) AS completed_courses\nFROM lifelong_learning\nWHERE student_id = 2\nORDER BY completion_date;\n```\n\nThis SQL statement counts the number of courses completed by a student with ID '2', ordering them chronologically based on the `completion_date`.", "latency_sec": 31.70873498916626, "total_duration_sec": 31.546132826, "load_duration_sec": 0.024946287, "tokens_prompt": 978, "prompt_eval_sec": 26.641445769, "tokens_completion": 59, "completion_eval_sec": 4.87529848, "tokens_total": 1037, "tokens_per_sec": 32.703922132317985, "retrieval_latency_sec": 0.129378080368042, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns multiple rows with an incremental count of completed courses per row (using a window function), while the Generated SQL returns a single row with a total count. The output structure and values differ: Reference shows [1, 2] for two rows, Generated shows [2] as a single value."}
{"example_id": 4669, "sql_complexity": "set operations", "prompt": "Identify the number of IoT devices in each country and the total number of devices.", "context": "CREATE TABLE device_country (device_id INT, country TEXT); INSERT INTO device_country (device_id, country) VALUES (1, 'USA'), (2, 'Canada'), (3, 'Mexico'), (4, 'Brazil'); CREATE TABLE device_info (device_id INT, device_type TEXT); INSERT INTO device_info (device_id, device_type) VALUES (1, 'Soil Sensor'), (2, 'Temperature Sensor'), (3, 'Humidity Sensor'), (4, 'Precision Sprayer');", "reference_sql": "SELECT country, COUNT(*) AS device_count FROM device_country GROUP BY country UNION SELECT 'Total' AS country, COUNT(*) FROM device_country;", "generated_sql": "SELECT \n    dc.country,\n    COUNT(*) AS device_count\nFROM \n    device_country dc\nJOIN \n    device_info di ON dc.device_id = di.device_id\nGROUP BY \n    dc.country;", "raw_model_output": "```sql\nSELECT \n    dc.country,\n    COUNT(*) AS device_count\nFROM \n    device_country dc\nJOIN \n    device_info di ON dc.device_id = di.device_id\nGROUP BY \n    dc.country;\n```\n\nThis SQL statement joins the `device_country` and `device_info` tables on the `device_id` column, groups the results by country, and counts the number of devices in each country.", "latency_sec": 30.090497970581055, "total_duration_sec": 30.083371744, "load_duration_sec": 0.028558091, "tokens_prompt": 852, "prompt_eval_sec": 22.847431293, "tokens_completion": 87, "completion_eval_sec": 7.20433645, "tokens_total": 939, "tokens_per_sec": 31.205864419992107, "retrieval_latency_sec": 0.1276559829711914, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a 'Total' row in its result set via a UNION, while the Generated SQL does not. Additionally, the Generated SQL performs an unnecessary JOIN with device_info, which doesn't affect the count in this specific dataset but changes the query's structure. The core difference is the missing 'Total' row in the Generated SQL."}
