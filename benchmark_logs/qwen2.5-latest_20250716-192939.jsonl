{"example_id": 2656, "sql_complexity": "multiple_joins", "prompt": "Find the drugs and their respective total sales for rare diseases indication with sales greater than the average sales for infectious diseases.", "context": "CREATE TABLE sales (id INT, drug_id INT, quarter INT, year INT, revenue FLOAT); INSERT INTO sales (id, drug_id, quarter, year, revenue) VALUES (1, 1, 1, 2022, 1500000); CREATE TABLE drugs (id INT, name VARCHAR(50), company VARCHAR(50), indication VARCHAR(50)); INSERT INTO drugs (id, name, company, indication) VALUES (1, 'DrugA', 'ABC Corp', 'Rare_Diseases');", "reference_sql": "SELECT s.drug_id, d.name, SUM(s.revenue) as total_sales FROM sales s JOIN drugs d ON s.drug_id = d.id WHERE d.indication = 'Rare_Diseases' GROUP BY s.drug_id HAVING total_sales > (SELECT AVG(s2.revenue) FROM sales s2 JOIN drugs d2 ON s2.drug_id = d2.id WHERE d2.indication = 'Infectious_Diseases')", "generated_sql": "SELECT \n    d.name, \n    SUM(s.revenue) AS total_sales\nFROM \n    sales s\nJOIN \n    drugs d ON s.drug_id = d.id\nWHERE \n    d.indication = 'Rare_Diseases'\nGROUP BY \n    d.name\nHAVING \n    SUM(s.revenue) > (\n        SELECT \n            AVG(revenue) \n        FROM \n            sales s2\n        JOIN \n            drugs d2 ON s2.drug_id = d2.id\n        WHERE \n            d2.indication = 'Infectious_Diseases'\n    );", "raw_model_output": "```sql\nSELECT \n    d.name, \n    SUM(s.revenue) AS total_sales\nFROM \n    sales s\nJOIN \n    drugs d ON s.drug_id = d.id\nWHERE \n    d.indication = 'Rare_Diseases'\nGROUP BY \n    d.name\nHAVING \n    SUM(s.revenue) > (\n        SELECT \n            AVG(revenue) \n        FROM \n            sales s2\n        JOIN \n            drugs d2 ON s2.drug_id = d2.id\n        WHERE \n            d2.indication = 'Infectious_Diseases'\n    );\n```", "latency_sec": 6.182629823684692, "total_duration_sec": 6.121174207, "load_duration_sec": 4.460936415, "tokens_prompt": 207, "prompt_eval_sec": 0.131940715, "tokens_completion": 127, "completion_eval_sec": 1.5201525, "tokens_total": 334, "tokens_per_sec": 54.02231890392305, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their GROUP BY clauses. The Reference SQL groups by s.drug_id (which is the primary key of drugs), ensuring unique drug identifiers, while the Generated SQL groups by d.name, which may not be unique. This could lead to different aggregation results if multiple drugs share the same name. Additionally, the Generated SQL omits drug_id from the output, though this doesn't affect semantic equivalence. The HAVING clause's subquery is equivalent, but the grouping difference makes the overall queries non-equivalent."}
{"example_id": 3008, "sql_complexity": "multiple_joins", "prompt": "Who are the users who used electric vehicles and their trip details?", "context": "CREATE TABLE users (id INT, name VARCHAR(50), age INT, gender VARCHAR(10), city VARCHAR(50));CREATE TABLE vehicles (id INT, vehicle_type VARCHAR(20), is_electric BOOLEAN);CREATE TABLE trips (id INT, user_id INT, vehicle_id INT, trip_distance FLOAT, trip_duration INT, departure_time TIMESTAMP, arrival_time TIMESTAMP);INSERT INTO users (id, name, age, gender, city) VALUES (3, 'Alex', 30, 'Female', 'New York');INSERT INTO vehicles (id, vehicle_type, is_electric) VALUES (1, 'Tesla', true), (2, 'Bike', false);INSERT INTO trips (id, user_id, vehicle_id, trip_distance, trip_duration, departure_time, arrival_time) VALUES (3, 3, 1, 15.3, 25, '2022-01-03 12:00:00', '2022-01-03 12:25:00');", "reference_sql": "SELECT u.name, v.vehicle_type, t.trip_distance, t.trip_duration FROM users u JOIN trips t ON u.id = t.user_id JOIN vehicles v ON t.vehicle_id = v.id WHERE v.is_electric = true;", "generated_sql": "SELECT u.name, v.vehicle_type, t.trip_distance, t.trip_duration, t.departure_time, t.arrival_time\nFROM users u\nJOIN trips t ON u.id = t.user_id\nJOIN vehicles v ON t.vehicle_id = v.id\nWHERE v.is_electric = true;", "raw_model_output": "```sql\nSELECT u.name, v.vehicle_type, t.trip_distance, t.trip_duration, t.departure_time, t.arrival_time\nFROM users u\nJOIN trips t ON u.id = t.user_id\nJOIN vehicles v ON t.vehicle_id = v.id\nWHERE v.is_electric = true;\n```", "latency_sec": 1.0699620246887207, "total_duration_sec": 0.870367231, "load_duration_sec": 0.021895102, "tokens_prompt": 309, "prompt_eval_sec": 0.018787578, "tokens_completion": 65, "completion_eval_sec": 0.825945568, "tokens_total": 374, "tokens_per_sec": 349.54511596690185, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Generated SQL includes additional columns (departure_time, arrival_time) not present in the Reference SQL. While both queries share the same joins and WHERE condition, the difference in selected columns makes their result sets structurally distinct."}
{"example_id": 2531, "sql_complexity": "basic SQL", "prompt": "Who is the top customer by sales in 2022?", "context": "CREATE TABLE customers (customer_id INT, total_sales_2022 FLOAT); INSERT INTO customers (customer_id, total_sales_2022) VALUES (1, 25000.0), (2, 30000.0), (3, 22000.0), (4, 35000.0);", "reference_sql": "SELECT customer_id, total_sales_2022 FROM customers ORDER BY total_sales_2022 DESC LIMIT 1;", "generated_sql": "SELECT customer_id\nFROM customers\nORDER BY total_sales_2022 DESC\nLIMIT 1;", "raw_model_output": "```sql\nSELECT customer_id\nFROM customers\nORDER BY total_sales_2022 DESC\nLIMIT 1;\n```", "latency_sec": 0.5606939792633057, "total_duration_sec": 0.360224035, "load_duration_sec": 0.013712809, "tokens_prompt": 164, "prompt_eval_sec": 0.008935307, "tokens_completion": 27, "completion_eval_sec": 0.335255117, "tokens_total": 191, "tokens_per_sec": 340.64927940006487, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query returns both customer_id and total_sales_2022 columns, while the generated query only returns customer_id. Although both identify the same customer_id (due to the same ORDER BY and LIMIT), the result sets have different structures (columns), making them semantically distinct."}
{"example_id": 3792, "sql_complexity": "single join", "prompt": "What is the maximum distance traveled by an electric vehicle in a single trip, grouped by vehicle model?", "context": "CREATE TABLE Trips (trip_id INT, vehicle_id INT, distance FLOAT); CREATE TABLE ElectricVehicleModels (vehicle_id INT, vehicle_model TEXT);", "reference_sql": "SELECT evm.vehicle_model, MAX(trips.distance) AS max_distance_traveled FROM Trips trips INNER JOIN ElectricVehicleModels evm ON trips.vehicle_id = evm.vehicle_id GROUP BY 1;", "generated_sql": "SELECT \n    evm.vehicle_model,\n    MAX(t.distance) AS max_distance\nFROM \n    Trips t\nJOIN \n    ElectricVehicleModels evm ON t.vehicle_id = evm.vehicle_id\nGROUP BY \n    evm.vehicle_model;", "raw_model_output": "```sql\nSELECT \n    evm.vehicle_model,\n    MAX(t.distance) AS max_distance\nFROM \n    Trips t\nJOIN \n    ElectricVehicleModels evm ON t.vehicle_id = evm.vehicle_id\nGROUP BY \n    evm.vehicle_model;\n```", "latency_sec": 0.8988239765167236, "total_duration_sec": 0.701647881, "load_duration_sec": 0.013779519, "tokens_prompt": 119, "prompt_eval_sec": 0.007667457, "tokens_completion": 56, "completion_eval_sec": 0.678123786, "tokens_total": 175, "tokens_per_sec": 194.69885602984237, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between Trips and ElectricVehicleModels on vehicle_id, group by vehicle_model, and calculate the maximum distance traveled. The differences are purely syntactic (alias names and column alias formatting) and do not affect the semantic result."}
{"example_id": 2311, "sql_complexity": "subqueries", "prompt": "Determine the percentage of sales from each ingredient category", "context": "CREATE TABLE Sales_Details (sale_id INT, ingredient_id INT, quantity INT); INSERT INTO Sales_Details (sale_id, ingredient_id, quantity) VALUES (1, 1, 2), (1, 2, 8), (2, 1, 3), (2, 2, 7); CREATE TABLE Ingredient_Categories (ingredient_id INT, ingredient_category VARCHAR(255)); INSERT INTO Ingredient_Categories (ingredient_id, ingredient_category) VALUES (1, 'Legumes'), (2, 'Poultry');", "reference_sql": "SELECT ingredient_category, SUM(quantity) AS total_quantity, SUM(quantity) * 100.0 / (SELECT SUM(quantity) FROM Sales_Details) AS percentage_of_sales FROM Sales_Details, Ingredient_Categories WHERE Sales_Details.ingredient_id = Ingredient_Categories.ingredient_id GROUP BY ingredient_category;", "generated_sql": "SELECT \n    ic.ingredient_category,\n    SUM(CASE WHEN sd.ingredient_id = 1 THEN sd.quantity ELSE 0 END) * 100 / SUM(sd.quantity) AS legumes_percentage,\n    SUM(CASE WHEN sd.ingredient_id = 2 THEN sd.quantity ELSE 0 END) * 100 / SUM(sd.quantity) AS poultry_percentage\nFROM \n    Sales_Details sd\nJOIN \n    Ingredient_Categories ic ON sd.ingredient_id = ic.ingredient_id\nGROUP BY \n    ic.ingredient_category;", "raw_model_output": "```sql\nSELECT \n    ic.ingredient_category,\n    SUM(CASE WHEN sd.ingredient_id = 1 THEN sd.quantity ELSE 0 END) * 100 / SUM(sd.quantity) AS legumes_percentage,\n    SUM(CASE WHEN sd.ingredient_id = 2 THEN sd.quantity ELSE 0 END) * 100 / SUM(sd.quantity) AS poultry_percentage\nFROM \n    Sales_Details sd\nJOIN \n    Ingredient_Categories ic ON sd.ingredient_id = ic.ingredient_id\nGROUP BY \n    ic.ingredient_category;\n```", "latency_sec": 1.4531562328338623, "total_duration_sec": 1.447485134, "load_duration_sec": 0.016586457, "tokens_prompt": 191, "prompt_eval_sec": 0.010699297, "tokens_completion": 116, "completion_eval_sec": 1.417925211, "tokens_total": 307, "tokens_per_sec": 211.2642763822484, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The reference query returns a single percentage column showing each category's contribution to total sales, while the generated query splits percentages into separate columns for each ingredient (legumes_percentage and poultry_percentage). The generated query's structure results in two columns with conditional aggregation, whereas the reference uses a single calculated percentage. Additionally, the generated query's output would have two rows (one per category) with one non-zero percentage each, while the reference returns two rows with one percentage per row. The result sets differ in structure and column semantics."}
{"example_id": 3329, "sql_complexity": "set operations", "prompt": "Which causes received funding from donors in both the United States and Canada?", "context": "CREATE TABLE donor_location (donor_id INT, country VARCHAR(50), cause VARCHAR(50), donation DECIMAL(10,2)); INSERT INTO donor_location (donor_id, country, cause, donation) VALUES (1, 'United States', 'Global Health', 1000.00), (2, 'Canada', 'Education', 2000.00), (3, 'United States', 'Environment', 1500.00), (4, 'Canada', 'Animal Welfare', 2500.00);", "reference_sql": "SELECT cause FROM donor_location WHERE country = 'United States' INTERSECT SELECT cause FROM donor_location WHERE country = 'Canada';", "generated_sql": "SELECT cause \nFROM donor_location \nWHERE country = 'United States'\nINTERSECT\nSELECT cause \nFROM donor_location \nWHERE country = 'Canada';", "raw_model_output": "```sql\nSELECT cause \nFROM donor_location \nWHERE country = 'United States'\nINTERSECT\nSELECT cause \nFROM donor_location \nWHERE country = 'Canada';\n```", "latency_sec": 0.8234281539916992, "total_duration_sec": 0.490294195, "load_duration_sec": 0.021820535, "tokens_prompt": 206, "prompt_eval_sec": 0.010711174, "tokens_completion": 36, "completion_eval_sec": 0.455325781, "tokens_total": 242, "tokens_per_sec": 293.8932787601036, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They select the 'cause' column from the donor_location table where country is 'United States' and intersect it with the 'cause' column where country is 'Canada'. The INTERSECT operator ensures only distinct common causes between the two countries are returned, and both queries are syntactically and semantically the same."}
{"example_id": 2912, "sql_complexity": "single join", "prompt": "Which company has manufactured the most satellites?", "context": "CREATE TABLE manufacturers (id INT, name TEXT); CREATE TABLE satellites (id INT, manufacturer_id INT, name TEXT, launch_date DATE); INSERT INTO manufacturers (id, name) VALUES (1, 'SpaceX'), (2, 'Blue Origin'), (3, 'ISRO'), (4, 'CAST'); INSERT INTO satellites (id, manufacturer_id, name, launch_date) VALUES (1, 1, 'StarDragon', '2012-05-25'), (2, 1, 'Falcon', '2015-12-21'), (3, 2, 'New Glenn', '2022-01-11'), (4, 3, 'ChinaSat 1E', '2000-12-05'), (5, 3, 'ChinaSat 2A', '2003-08-13'), (6, 4, 'Shijian 9', '2017-11-19'), (7, 1, 'StarLink', '2020-05-24'), (8, 1, 'StarLink', '2020-06-13');", "reference_sql": "SELECT m.name, COUNT(s.id) FROM manufacturers m JOIN satellites s ON m.id = s.manufacturer_id GROUP BY m.name ORDER BY COUNT(s.id) DESC;", "generated_sql": "SELECT m.name\nFROM manufacturers m\nJOIN satellites s ON m.id = s.manufacturer_id\nGROUP BY m.name\nORDER BY COUNT(s.id) DESC\nLIMIT 1;", "raw_model_output": "```sql\nSELECT m.name\nFROM manufacturers m\nJOIN satellites s ON m.id = s.manufacturer_id\nGROUP BY m.name\nORDER BY COUNT(s.id) DESC\nLIMIT 1;\n```", "latency_sec": 0.6917989253997803, "total_duration_sec": 0.595521348, "load_duration_sec": 0.013644964, "tokens_prompt": 341, "prompt_eval_sec": 0.019386548, "tokens_completion": 42, "completion_eval_sec": 0.559961483, "tokens_total": 383, "tokens_per_sec": 553.6290762213457, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns all manufacturers with their satellite counts ordered by count descending, while the Generated SQL adds a LIMIT 1 clause which restricts the result to only the top row. This makes them non-equivalent as the Generated query cannot return multiple rows."}
{"example_id": 3170, "sql_complexity": "aggregation", "prompt": "Determine the total production quantity of silver for mining sites in Mexico, between the dates '2017-05-01' and '2017-09-30', having less than 40 employees.", "context": "CREATE TABLE silver_mine_2 (site_id INT, country VARCHAR(50), num_employees INT, extraction_date DATE, quantity INT); INSERT INTO silver_mine_2 (site_id, country, num_employees, extraction_date, quantity) VALUES (1, 'Mexico', 35, '2017-05-02', 1200), (2, 'Mexico', 30, '2017-08-31', 1800), (3, 'Mexico', 37, '2017-07-04', 2200);", "reference_sql": "SELECT country, SUM(quantity) as total_silver_prod FROM silver_mine_2 WHERE num_employees < 40 AND country = 'Mexico' AND extraction_date >= '2017-05-01' AND extraction_date <= '2017-09-30' GROUP BY country;", "generated_sql": "SELECT SUM(quantity) AS total_production_quantity\nFROM silver_mine_2\nWHERE country = 'Mexico'\n  AND extraction_date BETWEEN '2017-05-01' AND '2017-09-30'\n  AND num_employees < 40;", "raw_model_output": "```sql\nSELECT SUM(quantity) AS total_production_quantity\nFROM silver_mine_2\nWHERE country = 'Mexico'\n  AND extraction_date BETWEEN '2017-05-01' AND '2017-09-30'\n  AND num_employees < 40;\n```", "latency_sec": 0.970858097076416, "total_duration_sec": 0.874353997, "load_duration_sec": 0.013981676, "tokens_prompt": 256, "prompt_eval_sec": 0.013633295, "tokens_completion": 67, "completion_eval_sec": 0.844250574, "tokens_total": 323, "tokens_per_sec": 332.6953763610386, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter the same dataset (Mexico, employees <40, extraction dates between 2017-05-01 and 2017-09-30) and calculate the sum of quantity. The Reference query groups by country (which is redundant here since all rows are Mexico), while the Generated query returns a single aggregated value. The final result (total sum) is identical, though the Reference includes an extra 'country' column with a constant value."}
{"example_id": 3518, "sql_complexity": "basic SQL", "prompt": "Insert new records of ticket sales for a new event, including event and salesperson information.", "context": "CREATE TABLE salesperson (salesperson_id INT, name VARCHAR(50), position VARCHAR(50)); CREATE TABLE tickets (ticket_id INT, salesperson_id INT, event_id INT, price DECIMAL(5,2), quantity INT); CREATE TABLE events (event_id INT, name VARCHAR(50), date DATE); INSERT INTO salesperson VALUES (1, 'John Doe', 'Senior Salesperson'); INSERT INTO events VALUES (2, 'New Event', '2023-04-15');", "reference_sql": "INSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity) VALUES (2, 1, 2, 75, 50), (3, 2, 2, 65, 75); INSERT INTO events (event_id, name, date) VALUES (2, 'New Event', '2023-04-15');", "generated_sql": "INSERT INTO tickets (salesperson_id, event_id, price, quantity)\nVALUES \n(1, 2, 50.00, 10),\n(1, 2, 60.00, 5);", "raw_model_output": "```sql\nINSERT INTO tickets (salesperson_id, event_id, price, quantity)\nVALUES \n(1, 2, 50.00, 10),\n(1, 2, 60.00, 5);\n```\n\nThis SQL statement inserts new records into the `tickets` table for a new event and includes the relevant salesperson information.", "latency_sec": 1.1255371570587158, "total_duration_sec": 1.028220878, "load_duration_sec": 0.021731964, "tokens_prompt": 194, "prompt_eval_sec": 0.015037602, "tokens_completion": 80, "completion_eval_sec": 0.984772335, "tokens_total": 274, "tokens_per_sec": 243.43931986752372, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL inserts into both 'tickets' and 'events' tables, while the Generated SQL only inserts into 'tickets'. Additionally, the 'tickets' data differs: the Reference SQL specifies explicit ticket_id values and includes a salesperson_id=2, whereas the Generated SQL omits ticket_id and uses salesperson_id=1 for both entries. The 'events' table is also modified in the Reference SQL but not in the Generated SQL."}
{"example_id": 3925, "sql_complexity": "set operations", "prompt": "What is the total number of students and staff with accommodations in the \"disability_services\" schema, excluding the \"accessibility_parking\" type?", "context": "CREATE SCHEMA disability_services; CREATE TABLE staff (id INT, name VARCHAR(50), accommodation VARCHAR(50)); CREATE TABLE students (id INT, name VARCHAR(50), accommodation VARCHAR(50));", "reference_sql": "SELECT COUNT(*) FROM disability_services.staff WHERE accommodation != 'accessibility_parking' UNION SELECT COUNT(*) FROM disability_services.students WHERE accommodation != 'accessibility_parking';", "generated_sql": "SELECT \n    COUNT(*) AS total_count\nFROM \n    disability_services.staff\nWHERE \n    accommodation != 'accessibility_parking'\nUNION ALL\nSELECT \n    COUNT(*) AS total_count\nFROM \n    disability_services.students\nWHERE \n    accommodation != 'accessibility_parking';", "raw_model_output": "```sql\nSELECT \n    COUNT(*) AS total_count\nFROM \n    disability_services.staff\nWHERE \n    accommodation != 'accessibility_parking'\nUNION ALL\nSELECT \n    COUNT(*) AS total_count\nFROM \n    disability_services.students\nWHERE \n    accommodation != 'accessibility_parking';\n```", "latency_sec": 1.0952060222625732, "total_duration_sec": 0.788479298, "load_duration_sec": 0.013978734, "tokens_prompt": 143, "prompt_eval_sec": 0.008546635, "tokens_completion": 63, "completion_eval_sec": 0.763910926, "tokens_total": 206, "tokens_per_sec": 188.09246462544738, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses UNION (which removes duplicates) while the Generated SQL uses UNION ALL (which retains all rows). If the counts from both tables are identical, the Reference would return 1 row whereas the Generated would return 2 rows. This difference in behavior makes them non-equivalent."}
{"example_id": 3340, "sql_complexity": "subqueries", "prompt": "Calculate the total revenue for garments manufactured in the US and sold in California.", "context": "CREATE TABLE garment_manufacturing(id INT PRIMARY KEY, garment_id INT, country VARCHAR(50), material VARCHAR(50), manufacturing_date DATE, quantity INT); CREATE TABLE garment_sales(id INT PRIMARY KEY, garment_id INT, store_id INT, sale_date DATE, units INT, revenue DECIMAL(10,2));", "reference_sql": "SELECT SUM(gs.revenue) FROM garment_manufacturing gm JOIN garment_sales gs ON gm.garment_id = gs.garment_id WHERE gm.country = 'United States' AND gs.store_id IN (SELECT id FROM stores WHERE region = 'California');", "generated_sql": "SELECT SUM(garment_sales.revenue) AS total_revenue\nFROM garment_manufacturing\nJOIN garment_sales ON garment_manufacturing.garment_id = garment_sales.garment_id\nWHERE garment_manufacturing.country = 'US'\nAND garment_sales.store_id = (SELECT store_id FROM store WHERE state = 'California')\nGROUP BY garment_manufacturing.id;", "raw_model_output": "```sql\nSELECT SUM(garment_sales.revenue) AS total_revenue\nFROM garment_manufacturing\nJOIN garment_sales ON garment_manufacturing.garment_id = garment_sales.garment_id\nWHERE garment_manufacturing.country = 'US'\nAND garment_sales.store_id = (SELECT store_id FROM store WHERE state = 'California')\nGROUP BY garment_manufacturing.id;\n```", "latency_sec": 1.1945481300354004, "total_duration_sec": 1.030191793, "load_duration_sec": 0.01622163, "tokens_prompt": 151, "prompt_eval_sec": 0.008949719, "tokens_completion": 81, "completion_eval_sec": 1.00290255, "tokens_total": 232, "tokens_per_sec": 194.2156989464499, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in several key aspects. 1) The Reference SQL uses 'United States' while the Generated SQL uses 'US' for country filtering. 2) The Generated SQL uses a subquery with '=' operator (expecting a single value) while the Reference SQL uses 'IN' (allowing multiple values). 3) The Generated SQL includes a GROUP BY clause on garment_manufacturing.id, which would return multiple rows with aggregated values, whereas the Reference SQL returns a single aggregated value. 4) The subquery in the Generated SQL references a 'state' column while the Reference SQL uses 'region', potentially accessing different data."}
{"example_id": 596, "sql_complexity": "basic SQL", "prompt": "What is the minimum energy production cost of wind farms in Spain?", "context": "CREATE TABLE wind_farm_costs (id INT, name TEXT, country TEXT, energy_production_cost FLOAT); INSERT INTO wind_farm_costs (id, name, country, energy_production_cost) VALUES (1, 'Las Tiesas', 'Spain', 0.045), (2, 'Eolo', 'Spain', 0.050);", "reference_sql": "SELECT MIN(energy_production_cost) FROM wind_farm_costs WHERE country = 'Spain';", "generated_sql": "SELECT MIN(energy_production_cost) AS min_cost FROM wind_farm_costs WHERE country = 'Spain';", "raw_model_output": "SELECT MIN(energy_production_cost) AS min_cost FROM wind_farm_costs WHERE country = 'Spain';", "latency_sec": 0.5293838977813721, "total_duration_sec": 0.325615468, "load_duration_sec": 0.025766973, "tokens_prompt": 157, "prompt_eval_sec": 0.007364144, "tokens_completion": 22, "completion_eval_sec": 0.290427378, "tokens_total": 179, "tokens_per_sec": 338.128909379719, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the minimum energy_production_cost for wind farms in Spain. The only difference is the alias 'min_cost' in the generated query, which does not affect the semantic result. The MIN() function and WHERE clause are identical."}
{"example_id": 2604, "sql_complexity": "subqueries", "prompt": "What is the maximum number of virtual tours taken by a single user in the UK?", "context": "CREATE TABLE virtual_tour_data (user_id INT, hotel_id INT, tour_date DATE); INSERT INTO virtual_tour_data (user_id, hotel_id, tour_date) VALUES (1, 10, '2022-01-01'), (2, 11, '2022-01-03'), (3, 12, '2022-01-05'), (4, 10, '2022-01-07'), (5, 10, '2022-01-09'); CREATE TABLE hotels (hotel_id INT, hotel_name TEXT, country TEXT); INSERT INTO hotels (hotel_id, hotel_name, country) VALUES (10, 'Royal Park Hotel', 'UK'), (11, 'The Ritz London', 'UK'), (12, 'Hotel de Crillon', 'France');", "reference_sql": "SELECT MAX(vt.user_tours) FROM (SELECT user_id, COUNT(DISTINCT hotel_id) as user_tours FROM virtual_tour_data WHERE country = 'UK' GROUP BY user_id) as vt;", "generated_sql": "SELECT MAX(count) AS max_tours\nFROM (\n    SELECT COUNT(*) AS count\n    FROM virtual_tour_data vd\n    JOIN hotels h ON vd.hotel_id = h.hotel_id\n    WHERE h.country = 'UK'\n    GROUP BY user_id\n) subquery;", "raw_model_output": "```sql\nSELECT MAX(count) AS max_tours\nFROM (\n    SELECT COUNT(*) AS count\n    FROM virtual_tour_data vd\n    JOIN hotels h ON vd.hotel_id = h.hotel_id\n    WHERE h.country = 'UK'\n    GROUP BY user_id\n) subquery;\n```\n\nThis SQL statement first joins the `virtual_tour_data` and `hotels` tables to filter tours taken in the UK. It then groups the results by `user_id` and counts the number of virtual tours for each user. Finally, it finds the maximum count from these grouped results.", "latency_sec": 1.6700572967529297, "total_duration_sec": 1.638152395, "load_duration_sec": 0.014493831, "tokens_prompt": 283, "prompt_eval_sec": 0.013669955, "tokens_completion": 124, "completion_eval_sec": 1.60791277, "tokens_total": 407, "tokens_per_sec": 243.70421349694092, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references a non-existent 'country' column in the virtual_tour_data table, making it invalid. The Generated SQL correctly joins with the hotels table to filter by country. Additionally, the Reference SQL uses COUNT(DISTINCT hotel_id) while the Generated SQL uses COUNT(*), which would produce different results if there are duplicate hotel_id entries for a user."}
{"example_id": 5812, "sql_complexity": "single join", "prompt": "Calculate the percentage of Shariah-compliant investments held by each investor in the top 5 countries with the highest percentage?", "context": "CREATE TABLE investors (investor_id INT, investor_name TEXT, country TEXT); INSERT INTO investors (investor_id, investor_name, country) VALUES (1, 'Al Thani', 'Qatar'), (2, 'Saudi Investment Group', 'Saudi Arabia'), (3, 'Temasek Holdings', 'Singapore'); CREATE TABLE investments (investment_id INT, investor_id INT, investment_type TEXT, investment_value DECIMAL, is_shariah_compliant BOOLEAN); INSERT INTO investments (investment_id, investor_id, investment_type, investment_value, is_shariah_compliant) VALUES (1, 1, 'Real Estate', 15000000, true), (2, 2, 'Stocks', 20000000, false);", "reference_sql": "SELECT investor_name, ROUND((SUM(CASE WHEN is_shariah_compliant THEN investment_value ELSE 0 END) / SUM(investment_value)) * 100, 2) AS percentage FROM investments JOIN investors ON investments.investor_id = investors.investor_id GROUP BY investor_name ORDER BY percentage DESC LIMIT 5;", "generated_sql": "WITH InvestorStats AS (\n    SELECT \n        i.investor_id,\n        i.investor_name,\n        i.country,\n        COUNT(iv.investment_id) AS total_investments,\n        SUM(CASE WHEN iv.is_shariah_compliant THEN 1 ELSE 0 END) AS shariah_compliant_investments\n    FROM \n        investments iv\n    JOIN \n        investors i ON iv.investor_id = i.investor_id\n    GROUP BY \n        i.investor_id, i.investor_name, i.country\n),\nCountryStats AS (\n    SELECT \n        country,\n        SUM(total_investments) AS total_investments_country,\n        SUM(shariah_compliant_investments) AS shariah_compliant_investments_country\n    FROM \n        InvestorStats\n    GROUP BY \n        country\n)\nSELECT \n    cs.country,\n    (cs.shariah_compliant_investments_country * 100.0 / cs.total_investments_country) AS percentage_shariah_compliant\nFROM \n    CountryStats cs\nORDER BY \n    percentage_shariah_compliant DESC\nLIMIT 5;", "raw_model_output": "To solve this problem, we need to follow these steps:\n\n1. Calculate the total number of investments for each investor.\n2. Calculate the number of Shariah-compliant investments for each investor.\n3. Determine the percentage of Shariah-compliant investments for each investor.\n4. Join with the `investors` table to get the country information.\n5. Group by country and calculate the top 5 countries based on the highest percentage of Shariah-compliant investments.\n\nHere is the SQL query:\n\n```sql\nWITH InvestorStats AS (\n    SELECT \n        i.investor_id,\n        i.investor_name,\n        i.country,\n        COUNT(iv.investment_id) AS total_investments,\n        SUM(CASE WHEN iv.is_shariah_compliant THEN 1 ELSE 0 END) AS shariah_compliant_investments\n    FROM \n        investments iv\n    JOIN \n        investors i ON iv.investor_id = i.investor_id\n    GROUP BY \n        i.investor_id, i.investor_name, i.country\n),\nCountryStats AS (\n    SELECT \n        country,\n        SUM(total_investments) AS total_investments_country,\n        SUM(shariah_compliant_investments) AS shariah_compliant_investments_country\n    FROM \n        InvestorStats\n    GROUP BY \n        country\n)\nSELECT \n    cs.country,\n    (cs.shariah_compliant_investments_country * 100.0 / cs.total_investments_country) AS percentage_shariah_compliant\nFROM \n    CountryStats cs\nORDER BY \n    percentage_shariah_compliant DESC\nLIMIT 5;\n```\n\n### Explanation:\n- **InvestorStats CTE**: This Common Table Expression (CTE) calculates the total number of investments and the number of Shariah-compliant investments for each investor.\n- **CountryStats CTE**: This CTE aggregates the data from `InvestorStats` to get the total number of investments and Shariah-compliant investments per country.\n- The final `SELECT` statement orders the countries by the percentage of Shariah-compliant investments in descending order and limits the result to the top 5.", "latency_sec": 5.864455938339233, "total_duration_sec": 5.780739193, "load_duration_sec": 0.014271287, "tokens_prompt": 256, "prompt_eval_sec": 0.013292016, "tokens_completion": 452, "completion_eval_sec": 5.751019536, "tokens_total": 708, "tokens_per_sec": 120.72731169679483, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL calculates the percentage of shariah-compliant investment value per investor, while the Generated SQL calculates the percentage of shariah-compliant investments (count) per country. The aggregation metrics (value vs. count), grouping fields (investor_name vs. country), and calculation logic differ significantly."}
{"example_id": 4706, "sql_complexity": "multiple_joins", "prompt": "Who are the top 3 customers by total spend on makeup products from Italy and Spain?", "context": "CREATE TABLE customers (customer_id INT, customer_name TEXT, country TEXT); INSERT INTO customers (customer_id, customer_name, country) VALUES (1, 'Alessandro Martini', 'IT'), (2, 'Laura Rossi', 'ES'), (3, 'Daniela Gonzalez', 'MX'), (4, 'Jose Hernandez', 'ES'), (5, 'Sophia Rodriguez', 'IT'); CREATE TABLE sales (sale_id INT, customer_id INT, product_id INT, sale_quantity INT, sale_country TEXT); INSERT INTO sales (sale_id, customer_id, product_id, sale_quantity, sale_country) VALUES (1, 1, 1, 100, 'IT'), (2, 2, 2, 150, 'ES'), (3, 3, 3, 200, 'MX'), (4, 4, 4, 250, 'ES'), (5, 5, 5, 300, 'IT'); CREATE TABLE products (product_id INT, product_name TEXT, category TEXT); INSERT INTO products (product_id, product_name, category) VALUES (1, 'Eyeshadow Palette', 'makeup'), (2, 'Liquid Lipstick', 'makeup'), (3, 'BB Cream', 'makeup'), (4, 'Volumizing Mascara', 'makeup'), (5, 'Nourishing Lip Balm', 'makeup');", "reference_sql": "SELECT c.customer_name, SUM(s.sale_quantity) as total_spent_on_makeup FROM sales s JOIN customers c ON s.customer_id = c.customer_id JOIN products p ON s.product_id = p.product_id WHERE c.country IN ('IT', 'ES') AND p.category = 'makeup' GROUP BY c.customer_name ORDER BY total_spent_on_makeup DESC LIMIT 3;", "generated_sql": "SELECT c.customer_name, SUM(s.sale_quantity * p.category = 'makeup') AS total_spend\nFROM customers c\nJOIN sales s ON c.customer_id = s.customer_id\nJOIN products p ON s.product_id = p.product_id\nWHERE c.country IN ('IT', 'ES')\nGROUP BY c.customer_id, c.customer_name\nORDER BY total_spend DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT c.customer_name, SUM(s.sale_quantity * p.category = 'makeup') AS total_spend\nFROM customers c\nJOIN sales s ON c.customer_id = s.customer_id\nJOIN products p ON s.product_id = p.product_id\nWHERE c.country IN ('IT', 'ES')\nGROUP BY c.customer_id, c.customer_name\nORDER BY total_spend DESC\nLIMIT 3;\n```", "latency_sec": 1.3661839962005615, "total_duration_sec": 1.194867637, "load_duration_sec": 0.014567292, "tokens_prompt": 392, "prompt_eval_sec": 0.020099211, "tokens_completion": 86, "completion_eval_sec": 1.157597694, "tokens_total": 478, "tokens_per_sec": 349.87966579124503, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Generated SQL incorrectly uses a boolean expression (p.category = 'makeup') in the SUM, which would not work in standard SQL (returns 0/1 but requires explicit CASE/IF). Additionally, the Reference SQL filters products with p.category = 'makeup' in the WHERE clause, while the Generated SQL attempts to handle this in the SUM, which could lead to different results if the SQL dialect doesn't implicitly convert booleans to 0/1. The GROUP BY in the Generated SQL includes customer_id (which is correct) but the Reference SQL groups by customer_name (which could be problematic if names are not unique)."}
{"example_id": 1515, "sql_complexity": "multiple_joins", "prompt": "What is the average age of clients who lost cases in the 'personal injury' category?", "context": "CREATE TABLE Cases (CaseID int, ClientID int, Category varchar(50)); INSERT INTO Cases (CaseID, ClientID, Category) VALUES (701, 7, 'Personal Injury'); CREATE TABLE Clients (ClientID int, Age int, Gender varchar(10)); INSERT INTO Clients (ClientID, Age, Gender) VALUES (7, 45, 'Male'); CREATE TABLE CaseOutcomes (CaseID int, Outcome varchar(50)); INSERT INTO CaseOutcomes (CaseID, Outcome) VALUES (701, 'Lost');", "reference_sql": "SELECT AVG(C.Age) as AvgAge FROM Clients C INNER JOIN Cases CA ON C.ClientID = CA.ClientID INNER JOIN CaseOutcomes CO ON CA.CaseID = CO.CaseID WHERE CA.Category = 'Personal Injury' AND CO.Outcome = 'Lost';", "generated_sql": "SELECT AVG(Clients.Age) AS AverageAge\nFROM Clients\nJOIN Cases ON Clients.ClientID = Cases.ClientID\nJOIN CaseOutcomes ON Cases.CaseID = CaseOutcomes.CaseID\nWHERE Cases.Category = 'Personal Injury' AND CaseOutcomes.Outcome = 'Lost';", "raw_model_output": "```sql\nSELECT AVG(Clients.Age) AS AverageAge\nFROM Clients\nJOIN Cases ON Clients.ClientID = Cases.ClientID\nJOIN CaseOutcomes ON Cases.CaseID = CaseOutcomes.CaseID\nWHERE Cases.Category = 'Personal Injury' AND CaseOutcomes.Outcome = 'Lost';\n```", "latency_sec": 1.137331247329712, "total_duration_sec": 0.846354912, "load_duration_sec": 0.019581571, "tokens_prompt": 205, "prompt_eval_sec": 0.010056213, "tokens_completion": 64, "completion_eval_sec": 0.814550109, "tokens_total": 269, "tokens_per_sec": 236.5186049636575, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average age of clients with 'Personal Injury' cases that resulted in a 'Lost' outcome. They use identical table joins (Clients \u2192 Cases \u2192 CaseOutcomes), same filtering conditions, and the same aggregate function. The only differences are aliasing conventions (table names vs. aliases) and column reference styles (Clients.Age vs. C.Age), which do not affect semantic meaning."}
{"example_id": 4388, "sql_complexity": "subqueries", "prompt": "Insert a new drug with a price 10% higher than the average price", "context": "CREATE TABLE drugs (drug_id INT, drug_name VARCHAR(50), price DECIMAL(10, 2)); INSERT INTO drugs (drug_id, drug_name, price) VALUES (1, 'DrugA', 50), (2, 'DrugB', 75), (3, 'DrugC', 100)", "reference_sql": "INSERT INTO drugs (drug_id, drug_name, price) VALUES ((SELECT MAX(drug_id) FROM drugs) + 1, 'DrugD', (SELECT AVG(price) * 1.1 FROM drugs))", "generated_sql": "INSERT INTO drugs (drug_id, drug_name, price)\nSELECT NULL, 'NewDrug', AVG(price) * 1.1\nFROM drugs;", "raw_model_output": "```sql\nINSERT INTO drugs (drug_id, drug_name, price)\nSELECT NULL, 'NewDrug', AVG(price) * 1.1\nFROM drugs;\n```", "latency_sec": 0.5273830890655518, "total_duration_sec": 0.476147007, "load_duration_sec": 0.013766236, "tokens_prompt": 158, "prompt_eval_sec": 0.008947643, "tokens_completion": 36, "completion_eval_sec": 0.451450285, "tokens_total": 194, "tokens_per_sec": 367.8540401129292, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL explicitly sets drug_id to (MAX(drug_id) + 1) and calculates price as AVG(price)*1.1. The Generated SQL uses NULL for drug_id (assuming auto-increment) and calculates price similarly. However, the drug_id values will differ: Reference uses 4 (since existing IDs are 1-3), while Generated uses NULL (assuming auto-increment). Additionally, if the database doesn't support auto-increment, Generated SQL would fail due to NULL in a non-nullable column. The price calculation is equivalent, but the drug_id handling makes them non-equivalent."}
{"example_id": 5431, "sql_complexity": "basic SQL", "prompt": "What is the average CO2 emission of ride-hailing vehicles in San Francisco?", "context": "CREATE TABLE SFRideHailing (id INT, company VARCHAR(20), co2_emission DECIMAL(5,2));", "reference_sql": "SELECT AVG(co2_emission) FROM SFRideHailing WHERE company = 'Uber';", "generated_sql": "SELECT AVG(co2_emission) AS average_co2_emission\nFROM SFRideHailing\nWHERE company = 'San Francisco';", "raw_model_output": "```sql\nSELECT AVG(co2_emission) AS average_co2_emission\nFROM SFRideHailing\nWHERE company = 'San Francisco';\n```", "latency_sec": 0.745549201965332, "total_duration_sec": 0.443255718, "load_duration_sec": 0.019886631, "tokens_prompt": 113, "prompt_eval_sec": 0.011707722, "tokens_completion": 33, "completion_eval_sec": 0.406992489, "tokens_total": 146, "tokens_per_sec": 195.82879253995765, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries filter on different values in the 'company' column ('Uber' vs 'San Francisco'). The reference query calculates the average CO2 emission for Uber rides, while the generated query calculates it for rides in San Francisco (assuming 'company' refers to location, which is semantically different from the company name)."}
{"example_id": 3531, "sql_complexity": "single join", "prompt": "What is the total number of workouts and total workout time per user for users with a membership type of 'Basic'?", "context": "CREATE TABLE Members (id INT, user_name VARCHAR, membership_type VARCHAR, signup_date DATE); CREATE TABLE Workouts (id INT, user_id INT, workout_date DATE, workout_duration INT); INSERT INTO Members (id, user_name, membership_type, signup_date) VALUES (1, 'John Doe', 'Premium', '2020-01-01'), (2, 'Jane Smith', 'Basic', '2019-06-15'), (3, 'Alice Johnson', 'Premium', '2020-03-20'); INSERT INTO Workouts (id, user_id, workout_date, workout_duration) VALUES (1, 1, '2020-01-01', 60), (2, 1, '2020-01-02', 70), (3, 2, '2019-06-15', 90), (4, 3, '2020-03-20', 65), (5, 3, '2020-03-21', 70);", "reference_sql": "SELECT Members.user_name, SUM(Workouts.workout_duration) AS total_workout_time, COUNT(Workouts.id) AS total_workouts FROM Members JOIN Workouts ON Members.id = Workouts.user_id WHERE Members.membership_type = 'Basic' GROUP BY Members.user_name;", "generated_sql": "SELECT \n    m.user_name,\n    COUNT(w.id) AS total_workouts,\n    SUM(w.workout_duration) AS total_workout_time\nFROM \n    Members m\nJOIN \n    Workouts w ON m.id = w.user_id\nWHERE \n    m.membership_type = 'Basic'\nGROUP BY \n    m.user_name;", "raw_model_output": "```sql\nSELECT \n    m.user_name,\n    COUNT(w.id) AS total_workouts,\n    SUM(w.workout_duration) AS total_workout_time\nFROM \n    Members m\nJOIN \n    Workouts w ON m.id = w.user_id\nWHERE \n    m.membership_type = 'Basic'\nGROUP BY \n    m.user_name;\n```", "latency_sec": 1.2969310283660889, "total_duration_sec": 0.99700357, "load_duration_sec": 0.014814034, "tokens_prompt": 341, "prompt_eval_sec": 0.016120963, "tokens_completion": 74, "completion_eval_sec": 0.963582969, "tokens_total": 415, "tokens_per_sec": 319.9861757666705, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between Members and Workouts on user_id, filter for 'Basic' membership type, and group by user_name. The generated query uses table aliases (m/w) instead of full table names and swaps the order of columns in the SELECT clause, but these are syntactic differences that do not affect the semantic result. The aggregation functions (SUM and COUNT) are applied to the same columns in both queries."}
{"example_id": 5678, "sql_complexity": "set operations", "prompt": "How many public works projects are there in 'Sydney' and 'Melbourne' combined?", "context": "CREATE TABLE PublicWorksC(id INT, city VARCHAR(20), project VARCHAR(30)); INSERT INTO PublicWorksC(id, city, project) VALUES (1, 'Sydney', 'Park Renovation'), (2, 'Melbourne', 'Sidewalk Repair');", "reference_sql": "SELECT COUNT(*) FROM (SELECT city FROM PublicWorksC WHERE city = 'Sydney' UNION ALL SELECT city FROM PublicWorksC WHERE city = 'Melbourne') AS Total;", "generated_sql": "SELECT COUNT(*) AS num_projects\nFROM PublicWorksC\nWHERE city IN ('Sydney', 'Melbourne');", "raw_model_output": "```sql\nSELECT COUNT(*) AS num_projects\nFROM PublicWorksC\nWHERE city IN ('Sydney', 'Melbourne');\n```", "latency_sec": 0.39850687980651855, "total_duration_sec": 0.388918502, "load_duration_sec": 0.017806255, "tokens_prompt": 145, "prompt_eval_sec": 0.013146361, "tokens_completion": 28, "completion_eval_sec": 0.351301744, "tokens_total": 173, "tokens_per_sec": 434.1204851569796, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of rows in PublicWorksC where the city is either 'Sydney' or 'Melbourne'. The Reference SQL uses UNION ALL to combine two separate selects (which preserves duplicates) and then counts all resulting rows. The Generated SQL uses IN to directly filter rows meeting the condition. Since both approaches count all matching rows (including duplicates), they produce the same result."}
{"example_id": 5792, "sql_complexity": "multiple_joins", "prompt": "How many cases were handled by attorneys in the 'Los Angeles' office?", "context": "CREATE TABLE offices (office_id INT, office_name VARCHAR(20), city VARCHAR(20), state VARCHAR(20)); INSERT INTO offices (office_id, office_name, city, state) VALUES (1, 'Boston', 'Boston', 'MA'), (2, 'New York', 'New York', 'NY'), (3, 'Los Angeles', 'Los Angeles', 'CA'); CREATE TABLE attorneys (attorney_id INT, office_id INT); INSERT INTO attorneys (attorney_id, office_id) VALUES (1, 1), (2, 2), (3, 3); CREATE TABLE cases (case_id INT, attorney_id INT); INSERT INTO cases (case_id, attorney_id) VALUES (1, 1), (2, 2), (3, 3);", "reference_sql": "SELECT COUNT(*) FROM cases JOIN attorneys ON cases.attorney_id = attorneys.attorney_id JOIN offices ON attorneys.office_id = offices.office_id WHERE offices.city = 'Los Angeles';", "generated_sql": "SELECT COUNT(c.case_id) AS number_of_cases\nFROM cases c\nJOIN attorneys a ON c.attorney_id = a.attorney_id\nJOIN offices o ON a.office_id = o.office_id\nWHERE o.city = 'Los Angeles';", "raw_model_output": "```sql\nSELECT COUNT(c.case_id) AS number_of_cases\nFROM cases c\nJOIN attorneys a ON c.attorney_id = a.attorney_id\nJOIN offices o ON a.office_id = o.office_id\nWHERE o.city = 'Los Angeles';\n```", "latency_sec": 1.0303089618682861, "total_duration_sec": 0.722959723, "load_duration_sec": 0.01483546, "tokens_prompt": 250, "prompt_eval_sec": 0.012914738, "tokens_completion": 54, "completion_eval_sec": 0.692723527, "tokens_total": 304, "tokens_per_sec": 295.05712485383884, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count cases linked to offices in 'Los Angeles' via identical join conditions and WHERE filters. The generated query uses table aliases and counts a specific column (c.case_id) instead of *, but since case_id is a primary key with no nulls, the result is equivalent. The logical structure and filtering criteria are identical."}
{"example_id": 5148, "sql_complexity": "window functions", "prompt": "List the unique types of smart city technologies that have been implemented in the top 3 most populous countries in the world.", "context": "CREATE TABLE smart_city_tech (tech_type VARCHAR(255), country VARCHAR(255)); CREATE TABLE country_populations (country VARCHAR(255), population INT);", "reference_sql": "SELECT DISTINCT tech_type FROM smart_city_tech SCT WHERE country IN (SELECT country FROM (SELECT country, ROW_NUMBER() OVER (ORDER BY population DESC) as rank FROM country_populations) CP WHERE rank <= 3);", "generated_sql": "SELECT DISTINCT sct.tech_type\nFROM smart_city_tech sct\nJOIN country_populations cp ON sct.country = cp.country\nWHERE cp.population IN (\n    SELECT population \n    FROM country_populations \n    ORDER BY population DESC \n    LIMIT 3\n);", "raw_model_output": "```sql\nSELECT DISTINCT sct.tech_type\nFROM smart_city_tech sct\nJOIN country_populations cp ON sct.country = cp.country\nWHERE cp.population IN (\n    SELECT population \n    FROM country_populations \n    ORDER BY population DESC \n    LIMIT 3\n);\n```", "latency_sec": 0.9768218994140625, "total_duration_sec": 0.777068765, "load_duration_sec": 0.026847327, "tokens_prompt": 131, "prompt_eval_sec": 0.012256538, "tokens_completion": 60, "completion_eval_sec": 0.735874717, "tokens_total": 191, "tokens_per_sec": 195.5320617960854, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses ROW_NUMBER() to select exactly 3 countries (top 3 by population), while the Generated SQL selects all countries with population values in the top 3 (which could include more than 3 countries if there are population ties). This difference in handling ties makes them non-equivalent."}
{"example_id": 5547, "sql_complexity": "multiple_joins", "prompt": "Which species have a population growth rate higher than the average for protected areas?", "context": "CREATE TABLE species (id INT, name VARCHAR(50), population DECIMAL(5,2), protected_area_id INT, growth_rate DECIMAL(5,2)); INSERT INTO species (id, name, population, protected_area_id, growth_rate) VALUES (1, 'Species 1', 500.00, 1, 0.05), (2, 'Species 2', 800.00, 1, 0.03), (3, 'Species 3', 1200.00, 2, 0.07), (4, 'Species 4', 700.00, 2, 0.02); CREATE TABLE protected_areas (id INT, name VARCHAR(50)); INSERT INTO protected_areas (id, name) VALUES (1, 'Area 1'), (2, 'Area 2');", "reference_sql": "SELECT s.name, s.growth_rate FROM species s INNER JOIN protected_areas pa ON s.protected_area_id = pa.id GROUP BY s.name, s.growth_rate HAVING s.growth_rate > (SELECT AVG(s.growth_rate) FROM species s INNER JOIN protected_areas pa ON s.protected_area_id = pa.id);", "generated_sql": "SELECT s.name\nFROM species s\nWHERE s.growth_rate > (\n    SELECT AVG(growth_rate)\n    FROM species\n);", "raw_model_output": "```sql\nSELECT s.name\nFROM species s\nWHERE s.growth_rate > (\n    SELECT AVG(growth_rate)\n    FROM species\n);\n```", "latency_sec": 0.47878503799438477, "total_duration_sec": 0.467548301, "load_duration_sec": 0.022773174, "tokens_prompt": 278, "prompt_eval_sec": 0.014686663, "tokens_completion": 32, "completion_eval_sec": 0.427500912, "tokens_total": 310, "tokens_per_sec": 647.4721960790172, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects both 'name' and 'growth_rate' columns, while the Generated SQL only selects 'name'. Additionally, the Reference SQL uses a GROUP BY and HAVING clause, which, although functionally similar to the WHERE clause in the Generated SQL, introduces structural differences. The subqueries in both cases calculate the same average growth rate, but the output columns and query structure differ, leading to different result sets."}
{"example_id": 5498, "sql_complexity": "aggregation", "prompt": "Identify the destinations with the highest number of repeat visitors from the US.", "context": "CREATE TABLE RepeatTravelers (Visitor VARCHAR(20), Destination VARCHAR(20), VisitCount INT); INSERT INTO RepeatTravelers (Visitor, Destination, VisitCount) VALUES ('David', 'Paris', 3), ('Ella', 'London', 4), ('Fiona', 'Paris', 2);", "reference_sql": "SELECT Destination, AVG(VisitCount) AS AvgVisitCount FROM RepeatTravelers WHERE Visitor LIKE '%USA%' GROUP BY Destination ORDER BY AvgVisitCount DESC;", "generated_sql": "SELECT Destination \nFROM RepeatTravelers \nWHERE Visitor IN (SELECT Visitor FROM RepeatTravelers WHERE VisitCount > 1) \nGROUP BY Destination \nORDER BY COUNT(DISTINCT Visitor) DESC \nLIMIT 1;", "raw_model_output": "```sql\nSELECT Destination \nFROM RepeatTravelers \nWHERE Visitor IN (SELECT Visitor FROM RepeatTravelers WHERE VisitCount > 1) \nGROUP BY Destination \nORDER BY COUNT(DISTINCT Visitor) DESC \nLIMIT 1;\n```\n\nThis query identifies destinations with repeat visitors from the US by filtering on `VisitCount` greater than 1, then groups by destination and counts distinct visitors to find the destination with the highest number of repeat visitors.", "latency_sec": 1.3513081073760986, "total_duration_sec": 1.169377926, "load_duration_sec": 0.017183281, "tokens_prompt": 149, "prompt_eval_sec": 0.022508148, "tokens_completion": 92, "completion_eval_sec": 1.127569808, "tokens_total": 241, "tokens_per_sec": 178.34570715923664, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters rows where Visitor contains 'USA' (which returns no rows given the sample data) and calculates average VisitCount per destination. The Generated SQL selects destinations where visitors have VisitCount > 1 (all visitors in the data) and returns the destination with the most distinct visitors. The first query returns no rows, while the second returns 'Paris'."}
{"example_id": 3546, "sql_complexity": "window functions", "prompt": "What are the cryptocurrency exchanges with their corresponding blockchain companies, ranked by exchange ID in ascending order, for the Bitcoin platform?", "context": "CREATE TABLE cryptocurrency_exchanges (exchange_id INT, exchange_name VARCHAR(50), company_id INT); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (1, 'Binance', 1); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (2, 'Coinbase', 2); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (3, 'Kraken', 3); CREATE TABLE blockchain_companies (company_id INT, company_name VARCHAR(50), platform VARCHAR(50)); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (1, 'Binance', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (2, 'Blockstream', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (3, 'Blockchair', 'Bitcoin');", "reference_sql": "SELECT ce.exchange_name, bc.company_name, ce.exchange_id, ROW_NUMBER() OVER (PARTITION BY bc.platform ORDER BY ce.exchange_id ASC) as rank FROM cryptocurrency_exchanges ce JOIN blockchain_companies bc ON ce.company_id = bc.company_id WHERE bc.platform = 'Bitcoin';", "generated_sql": "SELECT \n    ce.exchange_name,\n    bc.company_name\nFROM \n    cryptocurrency_exchanges ce\nJOIN \n    blockchain_companies bc ON ce.company_id = bc.company_id\nWHERE \n    bc.platform = 'Bitcoin'\nORDER BY \n    ce.exchange_id ASC;", "raw_model_output": "```sql\nSELECT \n    ce.exchange_name,\n    bc.company_name\nFROM \n    cryptocurrency_exchanges ce\nJOIN \n    blockchain_companies bc ON ce.company_id = bc.company_id\nWHERE \n    bc.platform = 'Bitcoin'\nORDER BY \n    ce.exchange_id ASC;\n```", "latency_sec": 1.0007810592651367, "total_duration_sec": 0.796749855, "load_duration_sec": 0.014146978, "tokens_prompt": 290, "prompt_eval_sec": 0.014892661, "tokens_completion": 59, "completion_eval_sec": 0.765436412, "tokens_total": 349, "tokens_per_sec": 348.7276230590007, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL includes an additional 'exchange_id' column and a 'rank' column generated by ROW_NUMBER(), while the Generated SQL omits these. Additionally, the Reference SQL does not have an ORDER BY clause, whereas the Generated SQL orders results by 'exchange_id'. The presence of different columns and ordering logic means the result sets differ in structure and content."}
{"example_id": 486, "sql_complexity": "single join", "prompt": "What is the average price of paintings from African artists in our collection?", "context": "CREATE TABLE Artworks (id INT, title VARCHAR(50), price DECIMAL(10,2), medium VARCHAR(50), artist_nationality VARCHAR(50)); CREATE TABLE Collections (id INT, name VARCHAR(50), continent VARCHAR(50));", "reference_sql": "SELECT AVG(Artworks.price) FROM Artworks INNER JOIN Collections ON Artworks.artist_nationality = Collections.continent WHERE Artworks.medium = 'Painting' AND Collections.continent = 'Africa';", "generated_sql": "SELECT AVG(price) AS average_price\nFROM Artworks\nWHERE medium = 'painting' AND artist_nationality = 'African';", "raw_model_output": "```sql\nSELECT AVG(price) AS average_price\nFROM Artworks\nWHERE medium = 'painting' AND artist_nationality = 'African';\n```", "latency_sec": 0.743488073348999, "total_duration_sec": 0.446513359, "load_duration_sec": 0.014205022, "tokens_prompt": 140, "prompt_eval_sec": 0.007723055, "tokens_completion": 34, "completion_eval_sec": 0.422542046, "tokens_total": 174, "tokens_per_sec": 234.0319989481836, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL joins Artworks with Collections on Artworks.artist_nationality = Collections.continent and filters Collections.continent = 'Africa', which implies Artworks.artist_nationality = 'Africa'. The Generated SQL incorrectly uses artist_nationality = 'African' (a different value) instead of 'Africa', making the conditions semantically different."}
{"example_id": 794, "sql_complexity": "multiple_joins", "prompt": "Which suppliers have provided raw materials for the production of chemicals with high environmental impact?", "context": "CREATE TABLE suppliers (id INT, name TEXT); INSERT INTO suppliers (id, name) VALUES (1, 'Supplier1'), (2, 'Supplier2'), (3, 'Supplier3'); CREATE TABLE chemicals (id INT, name TEXT, environmental_impact INT); INSERT INTO chemicals (id, name, environmental_impact) VALUES (1, 'ChemA', 10), (2, 'ChemB', 20), (3, 'ChemC', 15); CREATE TABLE raw_materials (chemical_id INT, supplier_id INT); INSERT INTO raw_materials (chemical_id, supplier_id) VALUES (1, 1), (1, 2), (2, 3), (3, 1);", "reference_sql": "SELECT s.name FROM suppliers s INNER JOIN raw_materials rm ON s.id = rm.supplier_id INNER JOIN chemicals c ON rm.chemical_id = c.id WHERE c.environmental_impact > 10;", "generated_sql": "SELECT DISTINCT s.name\nFROM suppliers s\nJOIN raw_materials rm ON s.id = rm.supplier_id\nJOIN chemicals c ON rm.chemical_id = c.id\nWHERE c.environmental_impact > 15;", "raw_model_output": "```sql\nSELECT DISTINCT s.name\nFROM suppliers s\nJOIN raw_materials rm ON s.id = rm.supplier_id\nJOIN chemicals c ON rm.chemical_id = c.id\nWHERE c.environmental_impact > 15;\n```", "latency_sec": 0.992948055267334, "total_duration_sec": 0.689670044, "load_duration_sec": 0.024610189, "tokens_prompt": 237, "prompt_eval_sec": 0.011417648, "tokens_completion": 51, "completion_eval_sec": 0.651488543, "tokens_total": 288, "tokens_per_sec": 290.04538401806025, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Reference SQL uses WHERE c.environmental_impact > 10 while the Generated SQL uses WHERE c.environmental_impact > 15, filtering different sets of chemicals. Second, the Generated SQL includes DISTINCT which removes duplicates, whereas the Reference SQL may return duplicate supplier names if a supplier is linked to multiple qualifying chemicals. In the given dataset, the Reference SQL returns suppliers linked to chemicals with impact >10 (Supplier1 and Supplier3), while the Generated SQL returns only those linked to chemicals with impact >15 (Supplier3)."}
{"example_id": 3164, "sql_complexity": "set operations", "prompt": "What is the average age of patients who received therapy in 'clinic_a' and 'clinic_b'?", "context": "CREATE TABLE clinic_a (patient_id INT, age INT, therapy_received BOOLEAN); INSERT INTO clinic_a (patient_id, age, therapy_received) VALUES (1, 35, true), (2, 42, true), (3, 28, false); CREATE TABLE clinic_b (patient_id INT, age INT, therapy_received BOOLEAN); INSERT INTO clinic_b (patient_id, age, therapy_received) VALUES (4, 50, true), (5, 32, false), (6, 45, true);", "reference_sql": "SELECT AVG(age) FROM (SELECT age FROM clinic_a WHERE therapy_received = true UNION ALL SELECT age FROM clinic_b WHERE therapy_received = true) AS combined_clinics;", "generated_sql": "SELECT \n    AVG(a.age + b.age) / 2 AS average_age\nFROM \n    clinic_a a\nJOIN \n    clinic_b b ON a.patient_id = b.patient_id\nWHERE \n    a.therapy_received = true AND b.therapy_received = true;", "raw_model_output": "```sql\nSELECT \n    AVG(a.age + b.age) / 2 AS average_age\nFROM \n    clinic_a a\nJOIN \n    clinic_b b ON a.patient_id = b.patient_id\nWHERE \n    a.therapy_received = true AND b.therapy_received = true;\n```", "latency_sec": 1.1137831211090088, "total_duration_sec": 0.806165363, "load_duration_sec": 0.020893576, "tokens_prompt": 204, "prompt_eval_sec": 0.01308841, "tokens_completion": 61, "completion_eval_sec": 0.768578215, "tokens_total": 265, "tokens_per_sec": 237.92782901588234, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the average age of all patients who received therapy from both clinics combined, while the Generated SQL attempts to join clinic_a and clinic_b on patient_id (which has no matches) and averages summed ages. The Generated SQL returns NULL due to no matching rows, whereas the Reference SQL returns a valid average of 43. The approaches differ in logic and data combination."}
{"example_id": 3704, "sql_complexity": "aggregation", "prompt": "What is the total sales revenue for each category of garments in the South America region in Q1 2022?", "context": "CREATE TABLE sales_category (sale_id INT, garment_category VARCHAR(50), sale_date DATE, total_sales DECIMAL(10, 2), region VARCHAR(50));", "reference_sql": "SELECT garment_category, SUM(total_sales) FROM sales_category WHERE sale_date BETWEEN '2022-01-01' AND '2022-03-31' AND region = 'South America' GROUP BY garment_category;", "generated_sql": "SELECT \n    garment_category, \n    SUM(total_sales) AS total_sales_revenue\nFROM \n    sales_category\nWHERE \n    region = 'South America' \n    AND sale_date BETWEEN '2022-01-01' AND '2022-03-31'\nGROUP BY \n    garment_category;", "raw_model_output": "```sql\nSELECT \n    garment_category, \n    SUM(total_sales) AS total_sales_revenue\nFROM \n    sales_category\nWHERE \n    region = 'South America' \n    AND sale_date BETWEEN '2022-01-01' AND '2022-03-31'\nGROUP BY \n    garment_category;\n```", "latency_sec": 1.0659708976745605, "total_duration_sec": 0.964632365, "load_duration_sec": 0.01330808, "tokens_prompt": 131, "prompt_eval_sec": 0.008481083, "tokens_completion": 76, "completion_eval_sec": 0.940720869, "tokens_total": 207, "tokens_per_sec": 194.18916637553158, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (garment_category and SUM(total_sales)), apply identical WHERE conditions (region = 'South America' and sale_date between '2022-01-01' and '2022-03-31'), and group by the same column (garment_category). The only difference is the aliasing of the aggregated column (SUM(total_sales) vs. SUM(total_sales) AS total_sales_revenue), which does not affect the semantic result."}
{"example_id": 2851, "sql_complexity": "single join", "prompt": "How many cases were handled by attorneys who joined the firm in 2015 or later?", "context": "CREATE TABLE attorneys (attorney_id INT, join_year INT); CREATE TABLE cases (case_id INT, attorney_id INT, billing_amount INT);", "reference_sql": "SELECT COUNT(DISTINCT cases.case_id) FROM cases INNER JOIN attorneys ON cases.attorney_id = attorneys.attorney_id WHERE attorneys.join_year >= 2015;", "generated_sql": "SELECT COUNT(DISTINCT c.case_id)\nFROM cases c\nJOIN attorneys a ON c.attorney_id = a.attorney_id\nWHERE a.join_year >= 2015;", "raw_model_output": "```sql\nSELECT COUNT(DISTINCT c.case_id)\nFROM cases c\nJOIN attorneys a ON c.attorney_id = a.attorney_id\nWHERE a.join_year >= 2015;\n```", "latency_sec": 0.8536412715911865, "total_duration_sec": 0.551670483, "load_duration_sec": 0.015232012, "tokens_prompt": 118, "prompt_eval_sec": 0.00736765, "tokens_completion": 43, "completion_eval_sec": 0.526901673, "tokens_total": 161, "tokens_per_sec": 188.6038144569746, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between 'cases' and 'attorneys' on attorney_id, filter where join_year >= 2015, and count distinct case_ids. The generated query uses table aliases ('c' and 'a') which do not affect semantic meaning. All logical components (tables, columns, conditions, aggregation) are equivalent."}
{"example_id": 3246, "sql_complexity": "single join", "prompt": "What is the average eco-friendliness score of accommodations in Oceania by year?", "context": "CREATE TABLE Accommodations (Accommodation_ID INT, Accommodation_Name VARCHAR(50), City VARCHAR(30), Country VARCHAR(50), Eco_Friendliness_Score INT, Visit_Year INT); INSERT INTO Accommodations (Accommodation_ID, Accommodation_Name, City, Country, Eco_Friendliness_Score, Visit_Year) VALUES (1, 'EcoLodge', 'Sydney', 'Australia', 85, 2019), (2, 'GreenHotel', 'Melbourne', 'Australia', 90, 2019), (3, 'SustainableResort', 'Auckland', 'New Zealand', 80, 2019), (4, 'EcoVilla', 'Wellington', 'New Zealand', 88, 2019); CREATE TABLE Countries (Country VARCHAR(50), Continent VARCHAR(30)); INSERT INTO Countries (Country, Continent) VALUES ('Australia', 'Oceania'), ('New Zealand', 'Oceania');", "reference_sql": "SELECT C.Continent, V.Visit_Year, AVG(A.Eco_Friendliness_Score) AS Avg_Eco_Score  FROM Accommodations A  JOIN Countries C  ON A.Country = C.Country  WHERE C.Continent = 'Oceania'  GROUP BY C.Continent, V.Visit_Year  ORDER BY V.Visit_Year;", "generated_sql": "SELECT \n    a.Visit_Year,\n    AVG(a.Eco_Friendliness_Score) AS Average_Eco_Friendliness_Score\nFROM \n    Accommodations a\nJOIN \n    Countries c ON a.Country = c.Country\nWHERE \n    c.Continent = 'Oceania'\nGROUP BY \n    a.Visit_Year;", "raw_model_output": "```sql\nSELECT \n    a.Visit_Year,\n    AVG(a.Eco_Friendliness_Score) AS Average_Eco_Friendliness_Score\nFROM \n    Accommodations a\nJOIN \n    Countries c ON a.Country = c.Country\nWHERE \n    c.Continent = 'Oceania'\nGROUP BY \n    a.Visit_Year;\n```", "latency_sec": 1.1936120986938477, "total_duration_sec": 1.01966548, "load_duration_sec": 0.013884795, "tokens_prompt": 309, "prompt_eval_sec": 0.01592584, "tokens_completion": 77, "completion_eval_sec": 0.986919894, "tokens_total": 386, "tokens_per_sec": 323.3881429506237, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes 'Continent' in the SELECT and GROUP BY clauses, while the Generated SQL omits it. Although the WHERE clause filters to 'Oceania', the result sets differ in structure (one includes Continent, the other does not). Semantic equivalence requires identical output columns and values, which is not the case here."}
{"example_id": 3056, "sql_complexity": "multiple_joins", "prompt": "Identify all suppliers who provide non-GMO ingredients to restaurants with Michelin stars.", "context": "CREATE TABLE Suppliers (id INT, name VARCHAR(50), isNonGMO BOOLEAN); CREATE TABLE Restaurants (id INT, name VARCHAR(50), numStars INT); CREATE TABLE Ingredients (supplierId INT, restaurantId INT, isNonGMO BOOLEAN);", "reference_sql": "SELECT Suppliers.name FROM Suppliers INNER JOIN Ingredients ON Suppliers.id = Ingredients.supplierId INNER JOIN Restaurants ON Ingredients.restaurantId = Restaurants.id WHERE Restaurants.numStars > 2 AND Ingredients.isNonGMO = TRUE;", "generated_sql": "SELECT DISTINCT s.name\nFROM Suppliers s\nJOIN Ingredients i ON s.id = i.supplierId\nJOIN Restaurants r ON i.restaurantId = r.id\nWHERE i.isNonGMO = TRUE AND r.numStars > 0;", "raw_model_output": "```sql\nSELECT DISTINCT s.name\nFROM Suppliers s\nJOIN Ingredients i ON s.id = i.supplierId\nJOIN Restaurants r ON i.restaurantId = r.id\nWHERE i.isNonGMO = TRUE AND r.numStars > 0;\n```", "latency_sec": 0.8340258598327637, "total_duration_sec": 0.682413055, "load_duration_sec": 0.019078101, "tokens_prompt": 140, "prompt_eval_sec": 0.008028441, "tokens_completion": 53, "completion_eval_sec": 0.652746006, "tokens_total": 193, "tokens_per_sec": 231.40769284863634, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the WHERE clause condition for numStars. The Reference SQL uses 'Restaurants.numStars > 2' while the Generated SQL uses 'r.numStars > 0'. This changes the filtering criteria for restaurant stars, leading to different result sets. Additionally, the Generated SQL includes 'DISTINCT' which could eliminate duplicates not present in the original query."}
{"example_id": 264, "sql_complexity": "set operations", "prompt": "List the number of community health centers and infectious disease tracking facilities in 'southwest' regions.", "context": "CREATE TABLE centers (id INT, name TEXT, region TEXT); INSERT INTO centers (id, name, region) VALUES (1, 'Center A', 'southwest'); INSERT INTO centers (id, name, region) VALUES (2, 'Center B', 'northeast'); INSERT INTO centers (id, name, region) VALUES (3, 'Center C', 'northwest'); CREATE TABLE diseases (id INT, name TEXT, region TEXT); INSERT INTO diseases (id, name, region) VALUES (1, 'Disease A', 'southwest'); INSERT INTO diseases (id, name, region) VALUES (2, 'Disease B', 'southeast');", "reference_sql": "SELECT COUNT(*) FROM ( (SELECT * FROM centers WHERE region = 'southwest') UNION (SELECT * FROM diseases WHERE region = 'southwest') );", "generated_sql": "SELECT \n    (SELECT COUNT(*) FROM centers WHERE region = 'southwest') AS center_count,\n    (SELECT COUNT(*) FROM diseases WHERE region = 'southwest') AS disease_count;", "raw_model_output": "```sql\nSELECT \n    (SELECT COUNT(*) FROM centers WHERE region = 'southwest') AS center_count,\n    (SELECT COUNT(*) FROM diseases WHERE region = 'southwest') AS disease_count;\n```", "latency_sec": 0.6863377094268799, "total_duration_sec": 0.582260091, "load_duration_sec": 0.013653768, "tokens_prompt": 227, "prompt_eval_sec": 0.012685888, "tokens_completion": 43, "completion_eval_sec": 0.553740332, "tokens_total": 270, "tokens_per_sec": 393.3923435817931, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns a single count of all rows from both tables where region = 'southwest' (using UNION to combine results), while the Generated SQL returns two separate counts (one for centers and one for diseases). The first query's result is a single integer (e.g., 2 in the sample data), whereas the second returns two integers (e.g., 1 and 1). The output structure and semantics differ."}
{"example_id": 2838, "sql_complexity": "basic SQL", "prompt": "What is the minimum safety rating of electric vehicles in the 'green_cars' table?", "context": "CREATE TABLE green_cars (id INT, make VARCHAR(50), model VARCHAR(50), type VARCHAR(50), safety_rating INT);", "reference_sql": "SELECT MIN(safety_rating) FROM green_cars WHERE type = 'Electric';", "generated_sql": "SELECT MIN(safety_rating) AS min_safety_rating\nFROM green_cars\nWHERE type = 'electric';", "raw_model_output": "```sql\nSELECT MIN(safety_rating) AS min_safety_rating\nFROM green_cars\nWHERE type = 'electric';\n```", "latency_sec": 0.4700770378112793, "total_duration_sec": 0.372960603, "load_duration_sec": 0.013769469, "tokens_prompt": 118, "prompt_eval_sec": 0.008433266, "tokens_completion": 28, "completion_eval_sec": 0.348703521, "tokens_total": 146, "tokens_per_sec": 310.5873894198046, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the minimum safety_rating from green_cars where type matches a specific value. The difference in string case ('Electric' vs 'electric') is negligible in most SQL implementations due to case-insensitive string comparison by default. The alias (min_safety_rating) in the generated query only affects column naming, not the result set's content."}
{"example_id": 1187, "sql_complexity": "multiple_joins", "prompt": "Who are the top 3 authors with the highest number of articles published in The Guardian?", "context": "CREATE TABLE authors (id INT, name VARCHAR(100), publisher VARCHAR(50)); CREATE TABLE articles_authors (article_id INT, author_id INT); INSERT INTO authors (id, name, publisher) VALUES (1, 'Author1', 'The Guardian'), (2, 'Author2', 'The Guardian'), (3, 'Author3', 'The Guardian'); INSERT INTO articles_authors (article_id, author_id) VALUES (1, 1), (2, 2), (3, 1), (3, 2), (3, 3); INSERT INTO articles (id, title, publication_date, publisher) VALUES (1, 'Article1', '2021-01-01', 'The Guardian'), (2, 'Article2', '2021-01-02', 'The Guardian'), (3, 'Article3', '2021-01-03', 'The Guardian');", "reference_sql": "SELECT a.name, COUNT(aa.article_id) AS articles_count FROM authors a JOIN articles_authors aa ON a.id = aa.author_id JOIN articles ar ON aa.article_id = ar.id WHERE ar.publisher = 'The Guardian' GROUP BY a.name ORDER BY articles_count DESC LIMIT 3;", "generated_sql": "SELECT a.name\nFROM authors a\nJOIN articles_authors aa ON a.id = aa.author_id\nWHERE a.publisher = 'The Guardian'\nGROUP BY a.name\nORDER BY COUNT(aa.article_id) DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT a.name\nFROM authors a\nJOIN articles_authors aa ON a.id = aa.author_id\nWHERE a.publisher = 'The Guardian'\nGROUP BY a.name\nORDER BY COUNT(aa.article_id) DESC\nLIMIT 3;\n```", "latency_sec": 0.9140560626983643, "total_duration_sec": 0.710962699, "load_duration_sec": 0.013410639, "tokens_prompt": 291, "prompt_eval_sec": 0.015516769, "tokens_completion": 52, "completion_eval_sec": 0.678805719, "tokens_total": 343, "tokens_per_sec": 375.2505059563168, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters articles by publisher ('The Guardian') via a join with the articles table, while the Generated SQL filters authors by publisher. This difference means the Generated SQL might include authors with articles from other publishers (if they exist), whereas the Reference SQL only counts articles explicitly tied to 'The Guardian'. Though results may overlap in this specific dataset, the queries are not semantically equivalent in general."}
{"example_id": 360, "sql_complexity": "window functions", "prompt": "What is the change in crime rate for each category, between this year and last year, for the same time period?", "context": "CREATE TABLE CrimeStatistics (ID INT, CrimeType VARCHAR(50), Date TIMESTAMP, Count INT); INSERT INTO CrimeStatistics (ID, CrimeType, Date, Count) VALUES (1, 'Theft', '2022-01-01 00:00:00', 100), (2, 'Vandalism', '2022-01-01 00:00:00', 50), (3, 'Theft', '2022-01-02 00:00:00', 120), (4, 'Vandalism', '2022-01-02 00:00:00', 60), (5, 'Theft', '2021-01-01 00:00:00', 80), (6, 'Vandalism', '2021-01-01 00:00:00', 40), (7, 'Theft', '2021-01-02 00:00:00', 90), (8, 'Vandalism', '2021-01-02 00:00:00', 45);", "reference_sql": "SELECT CrimeType, (SUM(Count) OVER (PARTITION BY CrimeType ORDER BY EXTRACT(YEAR FROM Date) ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)) - SUM(Count) OVER (PARTITION BY CrimeType ORDER BY EXTRACT(YEAR FROM Date)) AS CrimeRateChange FROM CrimeStatistics WHERE Date BETWEEN DATE_TRUNC('year', CURRENT_DATE - INTERVAL '1 year') AND CURRENT_DATE;", "generated_sql": "SELECT \n    CrimeType,\n    (SUM(CASE WHEN Date >= '2022-01-01' THEN Count ELSE 0 END) - \n     SUM(CASE WHEN Date >= '2021-01-01' AND Date < '2022-01-01' THEN Count ELSE 0 END)) AS ChangeInCrimeRate\nFROM \n    CrimeStatistics\nGROUP BY \n    CrimeType;", "raw_model_output": "```sql\nSELECT \n    CrimeType,\n    (SUM(CASE WHEN Date >= '2022-01-01' THEN Count ELSE 0 END) - \n     SUM(CASE WHEN Date >= '2021-01-01' AND Date < '2022-01-01' THEN Count ELSE 0 END)) AS ChangeInCrimeRate\nFROM \n    CrimeStatistics\nGROUP BY \n    CrimeType;\n```\n\nThis SQL query calculates the change in crime rate for each category between the year 2022 and 2021, considering only records within the same time period.", "latency_sec": 2.086904764175415, "total_duration_sec": 1.794248508, "load_duration_sec": 0.029835522, "tokens_prompt": 391, "prompt_eval_sec": 0.018319553, "tokens_completion": 137, "completion_eval_sec": 1.743943111, "tokens_total": 528, "tokens_per_sec": 253.00627468193315, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates the difference between the previous year's sum and the current year's sum using window functions, but it filters data from the previous year (2022) and current year (2023). The Generated SQL compares fixed 2022 and 2021 data ranges. Additionally, the Reference SQL's window function logic may not correctly capture the intended comparison due to the ROWS BETWEEN 1 PRECEDING clause, while the Generated SQL uses explicit date ranges for 2021 and 2022. The time frames and calculation methods differ, leading to different results."}
{"example_id": 335, "sql_complexity": "single join", "prompt": "List the policy numbers, claim amounts, and claim dates for policies that have more than two claims and the total claim amount exceeds $5000", "context": "CREATE TABLE policies (policy_number INT);CREATE TABLE claims (claim_id INT, policy_number INT, claim_amount DECIMAL(10,2), claim_date DATE);", "reference_sql": "SELECT p.policy_number, c.claim_amount, c.claim_date FROM policies p INNER JOIN claims c ON p.policy_number = c.policy_number GROUP BY p.policy_number, c.claim_amount, c.claim_date HAVING COUNT(c.claim_id) > 2 AND SUM(c.claim_amount) > 5000;", "generated_sql": "SELECT p.policy_number, c.claim_amount, c.claim_date\nFROM policies p\nJOIN (\n    SELECT policy_number, SUM(claim_amount) AS total_claim_amount, COUNT(*) AS claim_count\n    FROM claims\n    GROUP BY policy_number\n    HAVING COUNT(*) > 2 AND SUM(claim_amount) > 5000\n) c ON p.policy_number = c.policy_number;", "raw_model_output": "```sql\nSELECT p.policy_number, c.claim_amount, c.claim_date\nFROM policies p\nJOIN (\n    SELECT policy_number, SUM(claim_amount) AS total_claim_amount, COUNT(*) AS claim_count\n    FROM claims\n    GROUP BY policy_number\n    HAVING COUNT(*) > 2 AND SUM(claim_amount) > 5000\n) c ON p.policy_number = c.policy_number;\n```", "latency_sec": 1.4431869983673096, "total_duration_sec": 1.126914747, "load_duration_sec": 0.018511299, "tokens_prompt": 134, "prompt_eval_sec": 0.023296772, "tokens_completion": 89, "completion_eval_sec": 1.082708474, "tokens_total": 223, "tokens_per_sec": 154.5191304053334, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The generated SQL is invalid because it references columns 'claim_amount' and 'claim_date' from the subquery 'c', which does not contain these columns. The subquery only includes 'policy_number', 'total_claim_amount', and 'claim_count'. The reference query, however, groups by 'policy_number', 'claim_amount', and 'claim_date', which is a fundamentally different logic. Additionally, the generated query's HAVING clause uses aggregated values from the subquery, while the reference query applies HAVING directly on the joined tables."}
{"example_id": 2866, "sql_complexity": "basic SQL", "prompt": "What is the number of hospitals in 'rural_healthcare' table?", "context": "CREATE TABLE rural_healthcare (name VARCHAR(255), type VARCHAR(255), location VARCHAR(255)); INSERT INTO rural_healthcare (name, type, location) VALUES ('Rural General Hospital', 'Hospital', 'Bushland'), ('Rural Community Hospital', 'Hospital', 'Forest Region');", "reference_sql": "SELECT COUNT(*) FROM rural_healthcare WHERE type = 'Hospital';", "generated_sql": "SELECT COUNT(*) AS number_of_hospitals\nFROM rural_healthcare\nWHERE type = 'Hospital';", "raw_model_output": "```sql\nSELECT COUNT(*) AS number_of_hospitals\nFROM rural_healthcare\nWHERE type = 'Hospital';\n```", "latency_sec": 0.38937807083129883, "total_duration_sec": 0.35824017, "load_duration_sec": 0.017343064, "tokens_prompt": 150, "prompt_eval_sec": 0.01098545, "tokens_completion": 26, "completion_eval_sec": 0.327584173, "tokens_total": 176, "tokens_per_sec": 452.00285579578366, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries count the number of rows where type = 'Hospital'. The generated query adds an alias (number_of_hospitals) for the COUNT(*) result, but this does not affect the actual value returned. The semantic meaning and result remain identical."}
{"example_id": 4440, "sql_complexity": "multiple_joins", "prompt": "What is the average session length for each game genre in the last month, sorted by average session length.", "context": "CREATE TABLE game_sessions(id INT, user_id INT, game_name VARCHAR(50), start_time DATETIME, end_time DATETIME); CREATE TABLE games(id INT, name VARCHAR(50), genre VARCHAR(50));", "reference_sql": "SELECT genres.genre, AVG(TIMESTAMPDIFF(SECOND, start_time, end_time)) as avg_session_length FROM game_sessions JOIN games ON game_sessions.game_name = games.name JOIN (SELECT DISTINCT game_name, genre FROM game_sessions JOIN games ON game_sessions.game_name = games.name) genres ON games.name = genres.game_name WHERE start_time >= DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH) GROUP BY genres.genre ORDER BY avg_session_length DESC;", "generated_sql": "SELECT \n    g.genre,\n    AVG(TIMESTAMPDIFF(SECOND, s.start_time, s.end_time)) / 60 AS avg_session_length_minutes\nFROM \n    game_sessions s\nJOIN \n    games g ON s.game_name = g.name\nWHERE \n    s.end_time >= DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH)\nGROUP BY \n    g.genre\nORDER BY \n    avg_session_length_minutes;", "raw_model_output": "```sql\nSELECT \n    g.genre,\n    AVG(TIMESTAMPDIFF(SECOND, s.start_time, s.end_time)) / 60 AS avg_session_length_minutes\nFROM \n    game_sessions s\nJOIN \n    games g ON s.game_name = g.name\nWHERE \n    s.end_time >= DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH)\nGROUP BY \n    g.genre\nORDER BY \n    avg_session_length_minutes;\n```", "latency_sec": 1.3394219875335693, "total_duration_sec": 1.13947561, "load_duration_sec": 0.014338333, "tokens_prompt": 136, "prompt_eval_sec": 0.008117698, "tokens_completion": 91, "completion_eval_sec": 1.114575533, "tokens_total": 227, "tokens_per_sec": 169.47608902404315, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in three key aspects: 1) The Reference uses start_time >= ... while Generated uses end_time >= ..., filtering different time windows. 2) The Reference calculates average in seconds while Generated converts to minutes. 3) The Reference includes a redundant subquery for distinct game_name/genre pairs, which could affect grouping if duplicates exist. These differences in filtering logic, output units, and query structure make the results non-equivalent."}
{"example_id": 451, "sql_complexity": "single join", "prompt": "Which customers have made a transaction over 500 in the \"risk_management\" category?", "context": "CREATE TABLE customers (id INT, name VARCHAR(50), category VARCHAR(50)); INSERT INTO customers (id, name, category) VALUES (1, 'John Doe', 'risk_management'); INSERT INTO customers (id, name, category) VALUES (2, 'Jane Smith', 'compliance'); INSERT INTO customers (id, name, category) VALUES (3, 'Jim Brown', 'risk_management'); CREATE TABLE transactions (id INT, customer_id INT, amount DECIMAL(10, 2)); INSERT INTO transactions (id, customer_id, amount) VALUES (1, 1, 500.00); INSERT INTO transactions (id, customer_id, amount) VALUES (2, 1, 200.00); INSERT INTO transactions (id, customer_id, amount) VALUES (3, 2, 100.00); INSERT INTO transactions (id, customer_id, amount) VALUES (4, 3, 750.00);", "reference_sql": "SELECT c.name FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE c.category = 'risk_management' AND t.amount > 500;", "generated_sql": "SELECT DISTINCT c.name\nFROM customers c\nJOIN transactions t ON c.id = t.customer_id\nWHERE c.category = 'risk_management' AND t.amount > 500;", "raw_model_output": "```sql\nSELECT DISTINCT c.name\nFROM customers c\nJOIN transactions t ON c.id = t.customer_id\nWHERE c.category = 'risk_management' AND t.amount > 500;\n```", "latency_sec": 0.8041598796844482, "total_duration_sec": 0.599362946, "load_duration_sec": 0.028424879, "tokens_prompt": 298, "prompt_eval_sec": 0.014054364, "tokens_completion": 42, "completion_eval_sec": 0.554672248, "tokens_total": 340, "tokens_per_sec": 422.8014958087884, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Generated SQL includes a DISTINCT keyword, which ensures unique customer names in the result, while the Reference SQL may return duplicate names if a customer has multiple transactions meeting the criteria. Although the sample data shows only one matching transaction, the presence of DISTINCT in the Generated SQL changes the output behavior for cases with multiple qualifying transactions per customer."}
{"example_id": 2879, "sql_complexity": "basic SQL", "prompt": "Update the FoodSafetyRecords.OrganicFarms table to include a new record for a certified organic farm in Kenya.", "context": "CREATE TABLE FoodSafetyRecords.OrganicFarms (farmName TEXT, country TEXT, certified BOOLEAN);", "reference_sql": "INSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('Ngong Organic Farm', 'Kenya', TRUE);", "generated_sql": "INSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('New Organic Farm', 'Kenya', TRUE);", "raw_model_output": "```sql\nINSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('New Organic Farm', 'Kenya', TRUE);\n```", "latency_sec": 0.5813987255096436, "total_duration_sec": 0.463819766, "load_duration_sec": 0.024391712, "tokens_prompt": 114, "prompt_eval_sec": 0.006401016, "tokens_completion": 35, "completion_eval_sec": 0.430615255, "tokens_total": 149, "tokens_per_sec": 256.27851156603293, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The two queries differ in the farmName value inserted. The reference query inserts 'Ngong Organic Farm' while the generated query inserts 'New Organic Farm'. Since the actual data being inserted is different, they are not semantically equivalent."}
{"example_id": 5688, "sql_complexity": "single join", "prompt": "What is the total amount donated to a specific cause?", "context": "CREATE TABLE causes (id INT, name TEXT); CREATE TABLE donations (id INT, donor_id INT, cause_id INT, donation_amount DECIMAL(10,2)); INSERT INTO causes (id, name) VALUES (1, 'Cause A'), (2, 'Cause B'); INSERT INTO donations (id, donor_id, cause_id, donation_amount) VALUES (1, 1, 1, 50.00), (2, 2, 1, 100.00);", "reference_sql": "SELECT SUM(donation_amount) FROM donations JOIN causes ON donations.cause_id = causes.id WHERE causes.name = 'Cause A';", "generated_sql": "SELECT SUM(donation_amount) AS total_donations\nFROM donations\nWHERE cause_id = 1;", "raw_model_output": "To find the total amount donated to a specific cause, you need to specify which cause's ID you are interested in. Let's assume you want to know the total donations for `Cause A` (which has an ID of 1).\n\nHere is the SQL statement:\n\n```sql\nSELECT SUM(donation_amount) AS total_donations\nFROM donations\nWHERE cause_id = 1;\n```\n\nThis query sums up all the donation amounts where the `cause_id` is 1, which corresponds to `Cause A`.", "latency_sec": 1.4049463272094727, "total_duration_sec": 1.336651345, "load_duration_sec": 0.013761494, "tokens_prompt": 187, "prompt_eval_sec": 0.011067646, "tokens_completion": 106, "completion_eval_sec": 1.309362689, "tokens_total": 293, "tokens_per_sec": 208.54889210035617, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query filters donations based on the cause's name ('Cause A') via a JOIN, while the generated query directly filters by cause_id=1. Although in the provided data cause_id=1 corresponds to 'Cause A', the queries are not equivalent in general. The generated query assumes a specific ID, whereas the reference query uses the name, which could differ if the causes table changes (e.g., if cause_id=1 had a different name)."}
{"example_id": 3273, "sql_complexity": "multiple_joins", "prompt": "List all departments, the number of chemicals they handle, and the number of machines used in their manufacturing processes.", "context": "CREATE TABLE Departments (DepartmentID INT, DepartmentName VARCHAR(20)); INSERT INTO Departments (DepartmentID, DepartmentName) VALUES (1, 'Manufacturing'), (2, 'Engineering'), (3, 'Chemical Safety'), (4, 'Product Development'); CREATE TABLE Chemicals (ChemicalID INT, ChemicalName VARCHAR(20), DepartmentID INT); INSERT INTO Chemicals (ChemicalID, ChemicalName, DepartmentID) VALUES (1, 'Hydrochloric Acid', 1), (2, 'Nitric Acid', 2), (3, 'Sodium Hydroxide', 3), (4, 'New Chemical', 4); CREATE TABLE Machinery (MachineID INT, MachineName VARCHAR(20), DepartmentID INT); INSERT INTO Machinery (MachineID, MachineName, DepartmentID) VALUES (1, 'Mixer 1', 1), (2, 'Cutter 2', 2), (3, 'Dispenser 3', 3), (4, 'Innovator 4', 4);", "reference_sql": "SELECT D.DepartmentName, COUNT(C.ChemicalID) AS ChemicalCount, COUNT(M.MachineID) AS MachineCount FROM Departments D LEFT JOIN Chemicals C ON D.DepartmentID = C.DepartmentID LEFT JOIN Machinery M ON D.DepartmentID = M.DepartmentID GROUP BY D.DepartmentName;", "generated_sql": "SELECT \n    D.DepartmentName,\n    COUNT(C.ChemicalID) AS NumberOfChemicals,\n    COUNT(M.MachineID) AS NumberOfMachines\nFROM \n    Departments D\nLEFT JOIN \n    Chemicals C ON D.DepartmentID = C.DepartmentID\nLEFT JOIN \n    Machinery M ON D.DepartmentID = M.DepartmentID\nGROUP BY \n    D.DepartmentName;", "raw_model_output": "```sql\nSELECT \n    D.DepartmentName,\n    COUNT(C.ChemicalID) AS NumberOfChemicals,\n    COUNT(M.MachineID) AS NumberOfMachines\nFROM \n    Departments D\nLEFT JOIN \n    Chemicals C ON D.DepartmentID = C.DepartmentID\nLEFT JOIN \n    Machinery M ON D.DepartmentID = M.DepartmentID\nGROUP BY \n    D.DepartmentName;\n```", "latency_sec": 1.3896958827972412, "total_duration_sec": 1.081919927, "load_duration_sec": 0.014281936, "tokens_prompt": 311, "prompt_eval_sec": 0.015457081, "tokens_completion": 82, "completion_eval_sec": 1.049894317, "tokens_total": 393, "tokens_per_sec": 282.7956856351566, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries perform the same LEFT JOIN operations between Departments, Chemicals, and Machinery tables, group by DepartmentName, and count chemical/machine entries. The only difference is column alias names (ChemicalCount/MachineCount vs. NumberOfChemicals/NumberOfMachines), which does not affect the semantic result."}
{"example_id": 1895, "sql_complexity": "window functions", "prompt": "What is the average safety score of chemical production sites in the United States, partitioned by state and ranked in descending order?", "context": "CREATE TABLE production_sites (site_id INT, site_name TEXT, country TEXT, state TEXT, safety_score FLOAT); INSERT INTO production_sites (site_id, site_name, country, state, safety_score) VALUES (1, 'Site A', 'USA', 'NY', 92.5), (2, 'Site B', 'USA', 'CA', 87.4), (3, 'Site C', 'USA', 'TX', 95.3), (4, 'Site D', 'USA', 'FL', 89.2);", "reference_sql": "SELECT state, AVG(safety_score) as avg_safety_score, ROW_NUMBER() OVER (ORDER BY AVG(safety_score) DESC) as rank FROM production_sites WHERE country = 'USA' GROUP BY state ORDER BY rank;", "generated_sql": "SELECT state, AVG(safety_score) AS avg_safety_score\nFROM production_sites\nWHERE country = 'USA'\nGROUP BY state\nORDER BY avg_safety_score DESC;", "raw_model_output": "```sql\nSELECT state, AVG(safety_score) AS avg_safety_score\nFROM production_sites\nWHERE country = 'USA'\nGROUP BY state\nORDER BY avg_safety_score DESC;\n```", "latency_sec": 0.7265341281890869, "total_duration_sec": 0.551659034, "load_duration_sec": 0.015877652, "tokens_prompt": 212, "prompt_eval_sec": 0.010831216, "tokens_completion": 41, "completion_eval_sec": 0.522973893, "tokens_total": 253, "tokens_per_sec": 348.2286518743611, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes an additional 'rank' column generated by ROW_NUMBER() and orders by this rank, while the Generated SQL only returns state and average safety score, ordered by the average directly. The presence of the 'rank' column and different ordering mechanism make the result sets structurally and semantically different."}
{"example_id": 4669, "sql_complexity": "set operations", "prompt": "Identify the number of IoT devices in each country and the total number of devices.", "context": "CREATE TABLE device_country (device_id INT, country TEXT); INSERT INTO device_country (device_id, country) VALUES (1, 'USA'), (2, 'Canada'), (3, 'Mexico'), (4, 'Brazil'); CREATE TABLE device_info (device_id INT, device_type TEXT); INSERT INTO device_info (device_id, device_type) VALUES (1, 'Soil Sensor'), (2, 'Temperature Sensor'), (3, 'Humidity Sensor'), (4, 'Precision Sprayer');", "reference_sql": "SELECT country, COUNT(*) AS device_count FROM device_country GROUP BY country UNION SELECT 'Total' AS country, COUNT(*) FROM device_country;", "generated_sql": "SELECT \n    c.country,\n    COUNT(c.device_id) AS num_iot_devices_in_country,\n    (SELECT COUNT(*) FROM device_country) AS total_num_devices\nFROM \n    device_country c\nGROUP BY \n    c.country;", "raw_model_output": "```sql\nSELECT \n    c.country,\n    COUNT(c.device_id) AS num_iot_devices_in_country,\n    (SELECT COUNT(*) FROM device_country) AS total_num_devices\nFROM \n    device_country c\nGROUP BY \n    c.country;\n```", "latency_sec": 0.786618709564209, "total_duration_sec": 0.68673417, "load_duration_sec": 0.014140163, "tokens_prompt": 189, "prompt_eval_sec": 0.00976404, "tokens_completion": 53, "completion_eval_sec": 0.660717587, "tokens_total": 242, "tokens_per_sec": 307.6458734805193, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL produces a two-column result with country counts and a 'Total' row via UNION, while the Generated SQL returns three columns (including a repeated total in every row) without a dedicated 'Total' row. The structure and semantics differ: the Reference includes a summary row, while the Generated SQL embeds the total as a scalar column value."}
{"example_id": 5302, "sql_complexity": "multiple_joins", "prompt": "Find the supplier with the lowest average delivery time for orders in the last month.", "context": "CREATE TABLE Suppliers (SupplierID int, SupplierName varchar(50)); CREATE TABLE Products (ProductID int, ProductName varchar(50), SupplierID int); CREATE TABLE Orders (OrderID int, ProductID int, OrderDate date, DeliveryTime int); INSERT INTO Suppliers VALUES (1, 'SupplierA'), (2, 'SupplierB'); INSERT INTO Products VALUES (1, 'Organic Apples', 1), (2, 'Bananas', 2); INSERT INTO Orders VALUES (1, 1, '2022-01-01', 2), (2, 2, '2022-01-03', 3);", "reference_sql": "SELECT SupplierName, AVG(DeliveryTime) as AvgDeliveryTime FROM Orders o JOIN Products p ON o.ProductID = p.ProductID JOIN Suppliers sp ON p.SupplierID = sp.SupplierID WHERE OrderDate >= DATEADD(month, -1, GETDATE()) GROUP BY SupplierName ORDER BY AvgDeliveryTime ASC;", "generated_sql": "SELECT s.SupplierName\nFROM Suppliers s\nJOIN Products p ON s.SupplierID = p.SupplierID\nJOIN Orders o ON p.ProductID = o.ProductID\nWHERE o.OrderDate >= DATEADD(month, -1, GETDATE())\nGROUP BY s.SupplierName\nORDER BY AVG(o.DeliveryTime) ASC\nLIMIT 1;", "raw_model_output": "```sql\nSELECT s.SupplierName\nFROM Suppliers s\nJOIN Products p ON s.SupplierID = p.SupplierID\nJOIN Orders o ON p.ProductID = o.ProductID\nWHERE o.OrderDate >= DATEADD(month, -1, GETDATE())\nGROUP BY s.SupplierName\nORDER BY AVG(o.DeliveryTime) ASC\nLIMIT 1;\n```\n\n### Explanation:\n- **Suppliers (s)**: Join with `Products` on `SupplierID`.\n- **Products (p)**: Join with `Orders` on `ProductID`.\n- **Orders (o)**: Filter orders from the last month using `WHERE o.OrderDate >= DATEADD(month, -1, GETDATE())`.\n- **GROUP BY s.SupplierName**: Group by supplier name to calculate the average delivery time.\n- **ORDER BY AVG(o.DeliveryTime) ASC**: Order suppliers by their average delivery time in ascending order (lowest first).\n- **LIMIT 1**: Select only the supplier with the lowest average delivery time.", "latency_sec": 2.7319979667663574, "total_duration_sec": 2.638784647, "load_duration_sec": 0.015661197, "tokens_prompt": 229, "prompt_eval_sec": 0.013624809, "tokens_completion": 210, "completion_eval_sec": 2.60607266, "tokens_total": 439, "tokens_per_sec": 160.688260145233, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL returns all suppliers with their average delivery times sorted by ascending average, while the Generated SQL only returns the top 1 supplier (due to LIMIT 1) and omits the average delivery time column. The Generated SQL also uses a different column aliasing/selection strategy."}
{"example_id": 267, "sql_complexity": "subqueries", "prompt": "What is the total number of disability support programs offered in urban and rural areas, and the percentage of total programs for each area type?", "context": "CREATE TABLE programs (program_id INT, program_name VARCHAR(255), area_type VARCHAR(255));", "reference_sql": "SELECT area_type, COUNT(*) as total_programs, ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM programs) , 2) as percentage_of_total FROM programs WHERE area_type IN ('urban', 'rural') GROUP BY area_type;", "generated_sql": "SELECT \n    area_type,\n    COUNT(*) AS num_programs,\n    (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM programs)) AS percentage_of_total\nFROM \n    programs\nWHERE \n    area_type IN ('urban', 'rural')\nGROUP BY \n    area_type;", "raw_model_output": "```sql\nSELECT \n    area_type,\n    COUNT(*) AS num_programs,\n    (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM programs)) AS percentage_of_total\nFROM \n    programs\nWHERE \n    area_type IN ('urban', 'rural')\nGROUP BY \n    area_type;\n```", "latency_sec": 1.1688141822814941, "total_duration_sec": 0.853625521, "load_duration_sec": 0.01421313, "tokens_prompt": 120, "prompt_eval_sec": 0.00739184, "tokens_completion": 68, "completion_eval_sec": 0.829939894, "tokens_total": 188, "tokens_per_sec": 160.84678202058518, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses ROUND() to format the percentage to 2 decimal places, while the Generated SQL does not apply any rounding. This difference in precision means the percentage values would not be identical, making the queries semantically distinct."}
{"example_id": 3028, "sql_complexity": "basic SQL", "prompt": "What is the number of startups founded by non-binary individuals in the technology industry?", "context": "CREATE TABLE company (id INT, name TEXT, founder_gender TEXT, industry TEXT); INSERT INTO company (id, name, founder_gender, industry) VALUES (1, 'CodeForAll', 'Non-binary', 'Technology'); INSERT INTO company (id, name, founder_gender, industry) VALUES (2, 'TechVillage', 'Male', 'Technology');", "reference_sql": "SELECT COUNT(*) FROM company WHERE founder_gender = 'Non-binary' AND industry = 'Technology';", "generated_sql": "SELECT COUNT(*) AS number_of_startups\nFROM company\nWHERE founder_gender = 'Non-binary' AND industry = 'Technology';", "raw_model_output": "```sql\nSELECT COUNT(*) AS number_of_startups\nFROM company\nWHERE founder_gender = 'Non-binary' AND industry = 'Technology';\n```", "latency_sec": 0.5128152370452881, "total_duration_sec": 0.413689422, "load_duration_sec": 0.013828159, "tokens_prompt": 159, "prompt_eval_sec": 0.008943928, "tokens_completion": 31, "completion_eval_sec": 0.388609228, "tokens_total": 190, "tokens_per_sec": 370.5038116549189, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries count the number of companies where founder_gender is 'Non-binary' and industry is 'Technology'. The generated query adds an alias 'number_of_startups' to the COUNT(*) result, but this does not affect the semantic result - the value returned will be identical. The WHERE conditions and table structure are exactly the same in both queries."}
{"example_id": 3282, "sql_complexity": "aggregation", "prompt": "Which marine species have been observed in both the Arctic and Antarctic oceans?", "context": "CREATE TABLE marine_species (id INT, species_name VARCHAR(50), common_name VARCHAR(50), region VARCHAR(20));INSERT INTO marine_species (id, species_name, common_name, region) VALUES (1, 'Orcinus_orca', 'Killer Whale', 'Arctic');INSERT INTO marine_species (id, species_name, common_name, region) VALUES (2, 'Balaenoptera_bonaerensis', 'Antarctic Minke Whale', 'Antarctic');", "reference_sql": "SELECT species_name FROM marine_species WHERE region IN ('Arctic', 'Antarctic') GROUP BY species_name HAVING COUNT(DISTINCT region) = 2;", "generated_sql": "SELECT DISTINCT s1.species_name\nFROM marine_species s1\nJOIN marine_species s2 ON s1.species_name = s1.species_name\nWHERE s1.region = 'Arctic' AND s2.region = 'Antarctic';", "raw_model_output": "```sql\nSELECT DISTINCT s1.species_name\nFROM marine_species s1\nJOIN marine_species s2 ON s1.species_name = s1.species_name\nWHERE s1.region = 'Arctic' AND s2.region = 'Antarctic';\n```", "latency_sec": 0.7811629772186279, "total_duration_sec": 0.686930958, "load_duration_sec": 0.015408061, "tokens_prompt": 189, "prompt_eval_sec": 0.009632961, "tokens_completion": 53, "completion_eval_sec": 0.659685966, "tokens_total": 242, "tokens_per_sec": 309.7945077500393, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL finds species present in both 'Arctic' and 'Antarctic' regions by grouping and counting distinct regions. The Generated SQL incorrectly uses a self-join on a tautology (s1.species_name = s1.species_name), creating a cross-join between Arctic and Antarctic entries. This returns all Arctic species (e.g., 'Orcinus_orca') regardless of Antarctic presence, while the Reference SQL would return nothing in the provided data. The Generated SQL's logic is flawed and does not match the semantic intent."}
{"example_id": 3474, "sql_complexity": "subqueries", "prompt": "What is the total transaction volume for the top 3 digital assets by market capitalization in the 'developed_markets' schema?", "context": "CREATE SCHEMA developed_markets; CREATE TABLE developed_markets.digital_assets (asset_name VARCHAR(10), market_cap BIGINT, daily_transaction_volume BIGINT); INSERT INTO developed_markets.digital_assets (asset_name, market_cap, daily_transaction_volume) VALUES ('AssetG', 30000000, 15000000), ('AssetH', 25000000, 12000000), ('AssetI', 20000000, 10000000), ('AssetJ', 15000000, 8000000), ('AssetK', 10000000, 6000000);", "reference_sql": "SELECT SUM(daily_transaction_volume) FROM (SELECT daily_transaction_volume FROM developed_markets.digital_assets ORDER BY market_cap DESC FETCH NEXT 3 ROWS ONLY) t;", "generated_sql": "SELECT SUM(daily_transaction_volume) AS total_transaction_volume\nFROM developed_markets.digital_assets\nWHERE asset_name IN (\n    SELECT asset_name\n    FROM developed_markets.digital_assets\n    ORDER BY market_cap DESC\n    LIMIT 3\n);", "raw_model_output": "```sql\nSELECT SUM(daily_transaction_volume) AS total_transaction_volume\nFROM developed_markets.digital_assets\nWHERE asset_name IN (\n    SELECT asset_name\n    FROM developed_markets.digital_assets\n    ORDER BY market_cap DESC\n    LIMIT 3\n);\n```", "latency_sec": 1.0327579975128174, "total_duration_sec": 0.739284152, "load_duration_sec": 0.014680775, "tokens_prompt": 266, "prompt_eval_sec": 0.013813315, "tokens_completion": 55, "completion_eval_sec": 0.708100748, "tokens_total": 321, "tokens_per_sec": 310.81821760089167, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of daily_transaction_volume for the top 3 assets by market_cap. The reference query uses a subquery with FETCH NEXT 3 ROWS ONLY after ordering, while the generated query uses a subquery with LIMIT 3 in the IN clause. Since the data has unique market_caps, both approaches select the same three assets (AssetG, AssetH, AssetI) and sum their volumes. The final result is identical."}
{"example_id": 1626, "sql_complexity": "aggregation", "prompt": "Find the total value of social impact bonds issued by each organization.", "context": "CREATE TABLE social_impact_bonds (id INT, organization_name VARCHAR(255), issue_year INT, value FLOAT); INSERT INTO social_impact_bonds (id, organization_name, issue_year, value) VALUES (1, 'Acme Corp', 2018, 2000000), (2, 'XYZ Foundation', 2019, 3000000), (3, 'Global Giving', 2018, 1500000), (4, 'Acme Corp', 2019, 2500000), (5, 'XYZ Foundation', 2018, 1000000);", "reference_sql": "SELECT organization_name, SUM(value) as total_value FROM social_impact_bonds GROUP BY organization_name;", "generated_sql": "SELECT organization_name, SUM(value) AS total_value\nFROM social_impact_bonds\nGROUP BY organization_name;", "raw_model_output": "```sql\nSELECT organization_name, SUM(value) AS total_value\nFROM social_impact_bonds\nGROUP BY organization_name;\n```", "latency_sec": 0.5933918952941895, "total_duration_sec": 0.404218572, "load_duration_sec": 0.016196254, "tokens_prompt": 239, "prompt_eval_sec": 0.014097507, "tokens_completion": 28, "completion_eval_sec": 0.371548089, "tokens_total": 267, "tokens_per_sec": 449.95558941300976, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select organization_name and sum the value column, grouping by organization_name. The only differences are formatting (line breaks) and whitespace, which do not affect SQL execution or results."}
{"example_id": 1315, "sql_complexity": "single join", "prompt": "List all the transactions made by clients living in New York with a transaction amount greater than $1000.", "context": "CREATE TABLE transactions (id INT, client_id INT, transaction_amount DECIMAL(10,2), transaction_date DATE); INSERT INTO transactions (id, client_id, transaction_amount, transaction_date) VALUES (1, 3, 1500.00, '2022-01-01'), (2, 4, 800.00, '2022-01-02'), (3, 3, 1200.00, '2022-01-03'); CREATE TABLE clients (id INT, name VARCHAR(255), state VARCHAR(255)); INSERT INTO clients (id, name, state) VALUES (3, 'Mike Johnson', 'New York'), (4, 'Sara Lee', 'California');", "reference_sql": "SELECT transactions.id, transactions.client_id, transactions.transaction_amount, transactions.transaction_date FROM transactions INNER JOIN clients ON transactions.client_id = clients.id WHERE clients.state = 'New York' AND transactions.transaction_amount > 1000.00;", "generated_sql": "SELECT t.transaction_amount, c.name, t.transaction_date\nFROM transactions t\nJOIN clients c ON t.client_id = c.id\nWHERE c.state = 'New York' AND t.transaction_amount > 1000;", "raw_model_output": "```sql\nSELECT t.transaction_amount, c.name, t.transaction_date\nFROM transactions t\nJOIN clients c ON t.client_id = c.id\nWHERE c.state = 'New York' AND t.transaction_amount > 1000;\n```", "latency_sec": 0.7830212116241455, "total_duration_sec": 0.687590815, "load_duration_sec": 0.013612245, "tokens_prompt": 267, "prompt_eval_sec": 0.013810339, "tokens_completion": 51, "completion_eval_sec": 0.658158389, "tokens_total": 318, "tokens_per_sec": 406.11926634835754, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects columns (id, client_id, transaction_amount, transaction_date) while the Generated SQL selects (transaction_amount, name, transaction_date). The column sets differ, and the Generated SQL includes 'name' from the clients table instead of 'client_id'. Although both filter for 'New York' clients with transaction_amount > 1000, the result structures are different."}
{"example_id": 520, "sql_complexity": "multiple_joins", "prompt": "What is the total number of electric vehicles sold in 'California' in the 'sales' schema?", "context": "CREATE TABLE sales_regions (id INT, name VARCHAR(50));   CREATE TABLE sales (id INT, region_id INT, vehicle_count INT);   CREATE TABLE vehicles (id INT, type VARCHAR(50));   INSERT INTO sales_regions VALUES (1, 'California');   INSERT INTO sales VALUES (1, 1, 5000);   INSERT INTO vehicles VALUES (1, 'electric');", "reference_sql": "SELECT SUM(sales.vehicle_count) FROM sales INNER JOIN sales_regions ON sales.region_id = sales_regions.id INNER JOIN vehicles ON sales.id = vehicles.id WHERE vehicles.type = 'electric' AND sales_regions.name = 'California';", "generated_sql": "SELECT SUM(s.vehicle_count) AS total_electric_vehicles_sold\nFROM sales s\nJOIN sales_regions sr ON s.region_id = sr.id\nJOIN vehicles v ON s.id = v.id\nWHERE sr.name = 'California' AND v.type = 'electric';", "raw_model_output": "```sql\nSELECT SUM(s.vehicle_count) AS total_electric_vehicles_sold\nFROM sales s\nJOIN sales_regions sr ON s.region_id = sr.id\nJOIN vehicles v ON s.id = v.id\nWHERE sr.name = 'California' AND v.type = 'electric';\n```", "latency_sec": 0.8738608360290527, "total_duration_sec": 0.755148603, "load_duration_sec": 0.01339478, "tokens_prompt": 173, "prompt_eval_sec": 0.009010438, "tokens_completion": 59, "completion_eval_sec": 0.730702614, "tokens_total": 232, "tokens_per_sec": 265.4884970634922, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of vehicle_count from the sales table joined with sales_regions and vehicles. They use equivalent JOIN conditions (different aliases), same WHERE filters (order of conditions doesn't affect result), and sum the same column (different alias). The generated query adds a column alias but doesn't change the semantic output."}
{"example_id": 3999, "sql_complexity": "single join", "prompt": "What is the total number of tickets sold for performances with a rating of 5?", "context": "CREATE TABLE performance (id INT PRIMARY KEY, name VARCHAR(255), date DATE, artist_id INT, rating INT); INSERT INTO performance (id, name, date, artist_id, rating) VALUES (1, 'Dance Recital', '2022-03-01', 1, 5);", "reference_sql": "SELECT SUM(t.quantity) as total_tickets_sold FROM performance p INNER JOIN ticket t ON p.id = t.performance_id WHERE p.rating = 5;", "generated_sql": "SELECT COUNT(*) AS total_tickets_sold\nFROM performance\nWHERE rating = 5;", "raw_model_output": "```sql\nSELECT COUNT(*) AS total_tickets_sold\nFROM performance\nWHERE rating = 5;\n```", "latency_sec": 0.41242289543151855, "total_duration_sec": 0.305180223, "load_duration_sec": 0.013793115, "tokens_prompt": 155, "prompt_eval_sec": 0.007908945, "tokens_completion": 22, "completion_eval_sec": 0.28141679, "tokens_total": 177, "tokens_per_sec": 429.171129829746, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the total tickets sold (sum of quantity) for performances with a rating of 5 by joining with the ticket table, while the Generated SQL counts the number of performances with a rating of 5. They aggregate different data (sum vs. count) and the Generated SQL lacks the necessary join with the ticket table."}
{"example_id": 2261, "sql_complexity": "multiple_joins", "prompt": "What is the total number of animals that have been released into 'protected' habitats, and the average weight of those animals?", "context": "CREATE TABLE habitats (habitat_id INT, habitat_name VARCHAR(50), habitat_status VARCHAR(50)); INSERT INTO habitats (habitat_id, habitat_name, habitat_status) VALUES (1, 'Habitat A', 'protected'), (2, 'Habitat B', 'unprotected'); CREATE TABLE animal_habitats (animal_id INT, habitat_id INT, animal_weight FLOAT); INSERT INTO animal_habitats (animal_id, habitat_id, animal_weight) VALUES (101, 1, 25.5), (102, 2, 15.2); CREATE TABLE animals (animal_id INT, animal_name VARCHAR(50)); INSERT INTO animals (animal_id, animal_name) VALUES (101, 'Dog'), (102, 'Cat');", "reference_sql": "SELECT COUNT(*), AVG(animal_habitats.animal_weight) FROM animal_habitats INNER JOIN animals ON animal_habitats.animal_id = animals.animal_id INNER JOIN habitats ON animal_habitats.habitat_id = habitats.habitat_id WHERE habitats.habitat_status = 'protected';", "generated_sql": "SELECT COUNT(a.animal_id) AS total_animals, AVG(ah.animal_weight) AS avg_weight\nFROM animals a\nJOIN animal_habitats ah ON a.animal_id = ah.animal_id\nJOIN habitats h ON ah.habitat_id = h.habitat_id\nWHERE h.habitat_status = 'protected';", "raw_model_output": "```sql\nSELECT COUNT(a.animal_id) AS total_animals, AVG(ah.animal_weight) AS avg_weight\nFROM animals a\nJOIN animal_habitats ah ON a.animal_id = ah.animal_id\nJOIN habitats h ON ah.habitat_id = h.habitat_id\nWHERE h.habitat_status = 'protected';\n```", "latency_sec": 1.1445741653442383, "total_duration_sec": 0.977941198, "load_duration_sec": 0.013800297, "tokens_prompt": 263, "prompt_eval_sec": 0.01290429, "tokens_completion": 75, "completion_eval_sec": 0.948934747, "tokens_total": 338, "tokens_per_sec": 295.3063333369439, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform the same inner joins between animals, animal_habitats, and habitats tables, apply the same WHERE condition (habitats.habitat_status = 'protected'), and calculate identical aggregation metrics. The Reference SQL uses COUNT(*) and explicit table names, while the Generated SQL uses COUNT(a.animal_id) and table aliases. Since the joins are inner joins and the filtered dataset is identical, the count and average calculations will produce the same results."}
{"example_id": 3439, "sql_complexity": "multiple_joins", "prompt": "How many menu items contain ingredients sourced from local suppliers for each restaurant?", "context": "CREATE TABLE restaurants (id INT, name VARCHAR(50), location VARCHAR(50)); INSERT INTO restaurants VALUES (1, 'Restaurant A', 'City A'); INSERT INTO restaurants VALUES (2, 'Restaurant B', 'City B'); CREATE TABLE menu_items (id INT, name VARCHAR(50), restaurant_id INT, price DECIMAL(5,2)); INSERT INTO menu_items VALUES (1, 'Item A', 1, 10.99); INSERT INTO menu_items VALUES (2, 'Item B', 1, 12.99); INSERT INTO menu_items VALUES (3, 'Item C', 2, 11.99); CREATE TABLE ingredients (id INT, name VARCHAR(50), local_source BOOLEAN, menu_item_id INT); INSERT INTO ingredients VALUES (1, 'Ingredient A', TRUE, 1); INSERT INTO ingredients VALUES (2, 'Ingredient B', FALSE, 1); INSERT INTO ingredients VALUES (3, 'Ingredient C', TRUE, 2); INSERT INTO ingredients VALUES (4, 'Ingredient D', FALSE, 2); INSERT INTO ingredients VALUES (5, 'Ingredient E', TRUE, 3);", "reference_sql": "SELECT r.name, COUNT(DISTINCT mi.id) as num_local_items FROM restaurants r JOIN menu_items mi ON r.id = mi.restaurant_id JOIN ingredients i ON mi.id = i.menu_item_id WHERE i.local_source = TRUE GROUP BY r.name;", "generated_sql": "SELECT \n    r.name AS restaurant_name,\n    COUNT(mi.id) AS num_menu_items_with_local_ingredients\nFROM \n    restaurants r\nJOIN \n    menu_items mi ON r.id = mi.restaurant_id\nJOIN \n    ingredients i ON mi.id = i.menu_item_id\nWHERE \n    i.local_source = TRUE\nGROUP BY \n    r.name;", "raw_model_output": "```sql\nSELECT \n    r.name AS restaurant_name,\n    COUNT(mi.id) AS num_menu_items_with_local_ingredients\nFROM \n    restaurants r\nJOIN \n    menu_items mi ON r.id = mi.restaurant_id\nJOIN \n    ingredients i ON mi.id = i.menu_item_id\nWHERE \n    i.local_source = TRUE\nGROUP BY \n    r.name;\n```", "latency_sec": 1.344209909439087, "total_duration_sec": 1.041505081, "load_duration_sec": 0.014358373, "tokens_prompt": 326, "prompt_eval_sec": 0.017359673, "tokens_completion": 78, "completion_eval_sec": 1.007203366, "tokens_total": 404, "tokens_per_sec": 300.54829767516105, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their aggregation logic. The Reference SQL uses COUNT(DISTINCT mi.id) to count unique menu items with local ingredients, while the Generated SQL uses COUNT(mi.id) which counts all rows. If a menu item has multiple local ingredients (multiple rows in ingredients table), the Generated SQL would overcount that menu item, whereas the Reference SQL would count it once. This discrepancy makes them non-equivalent."}
{"example_id": 2265, "sql_complexity": "aggregation", "prompt": "Hourly revenue for a specific movie?", "context": "CREATE TABLE Movie_Revenue (id INT, movie_title VARCHAR(100), revenue_time TIME, revenue DECIMAL(10,2));", "reference_sql": "SELECT revenue_time, SUM(revenue) FROM Movie_Revenue WHERE movie_title = 'Spider-Man: No Way Home' GROUP BY revenue_time;", "generated_sql": "SELECT revenue_time::time AS hour, SUM(revenue) AS total_revenue\nFROM Movie_Revenue\nWHERE movie_title = 'specific_movie_title'\nGROUP BY revenue_time::time\nORDER BY hour;", "raw_model_output": "```sql\nSELECT revenue_time::time AS hour, SUM(revenue) AS total_revenue\nFROM Movie_Revenue\nWHERE movie_title = 'specific_movie_title'\nGROUP BY revenue_time::time\nORDER BY hour;\n```\n\n**Note:** Replace `'specific_movie_title'` with the actual title of the movie you are interested in. The `revenue_time::time` cast ensures that only the time part is considered for grouping, and the results are ordered by the hour.", "latency_sec": 1.4645578861236572, "total_duration_sec": 1.240438119, "load_duration_sec": 0.022521178, "tokens_prompt": 107, "prompt_eval_sec": 0.010701766, "tokens_completion": 99, "completion_eval_sec": 1.203967691, "tokens_total": 206, "tokens_per_sec": 140.65678246780254, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in three key aspects: 1) The WHERE clause uses 'Spider-Man: No Way Home' vs 'specific_movie_title' (different filter conditions). 2) The generated query adds an ORDER BY clause (affects result ordering but not content). 3) Column aliases differ (revenue_time vs hour, SUM(revenue) vs total_revenue). While the structure is similar, the filter condition difference ensures they are not semantically equivalent."}
{"example_id": 1763, "sql_complexity": "multiple_joins", "prompt": "What is the total food and beverage revenue last month for hotels in 'Bangkok'?", "context": "CREATE TABLE revenue (hotel_id INT, revenue_source VARCHAR(50), revenue INT, revenue_date DATE); INSERT INTO revenue (hotel_id, revenue_source, revenue, revenue_date) VALUES (5, 'Room revenue', 12000, '2022-03-01'), (5, 'Food and beverage', 4000, '2022-03-02'), (5, 'Other revenue', 1000, '2022-03-03'); CREATE TABLE hotels (hotel_id INT, city VARCHAR(50)); INSERT INTO hotels (hotel_id, city) VALUES (5, 'Bangkok'); CREATE TABLE dates (date DATE); INSERT INTO dates (date) VALUES ('2022-03-01'), ('2022-03-02'), ('2022-03-03');", "reference_sql": "SELECT SUM(revenue) FROM revenue JOIN hotels ON revenue.hotel_id = hotels.hotel_id JOIN dates ON revenue.revenue_date = dates.date WHERE hotels.city = 'Bangkok' AND revenue_source = 'Food and beverage' AND dates.date >= DATEADD(month, -1, GETDATE());", "generated_sql": "SELECT SUM(revenue) AS total_food_and_beverage_revenue\nFROM revenue r\nJOIN hotels h ON r.hotel_id = h.hotel_id\nWHERE h.city = 'Bangkok'\n  AND r.revenue_source = 'Food and beverage'\n  AND r.revenue_date >= DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month')\n  AND r.revenue_date < DATE_TRUNC('month', CURRENT_DATE);", "raw_model_output": "```sql\nSELECT SUM(revenue) AS total_food_and_beverage_revenue\nFROM revenue r\nJOIN hotels h ON r.hotel_id = h.hotel_id\nWHERE h.city = 'Bangkok'\n  AND r.revenue_source = 'Food and beverage'\n  AND r.revenue_date >= DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month')\n  AND r.revenue_date < DATE_TRUNC('month', CURRENT_DATE);\n```", "latency_sec": 1.4318530559539795, "total_duration_sec": 1.235674544, "load_duration_sec": 0.01711635, "tokens_prompt": 283, "prompt_eval_sec": 0.013888901, "tokens_completion": 93, "completion_eval_sec": 1.202499408, "tokens_total": 376, "tokens_per_sec": 262.5967786544186, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their date filtering logic. The Reference SQL uses `DATEADD(month, -1, GETDATE())` to include dates from one month ago up to the current date, while the Generated SQL uses `DATE_TRUNC('month', ...)` to capture the entire previous month (e.g., September if current date is October). Additionally, the Reference SQL joins with the `dates` table, which the Generated SQL omits, potentially affecting results if revenue dates are not present in the `dates` table."}
{"example_id": 5499, "sql_complexity": "set operations", "prompt": "How many legal aid clinics and community mediation centers are there in total, and what is the sum of cases handled by each type of center, for centers located in the state of California?", "context": "CREATE TABLE LegalAidClinics (ClinicName text, State text, NumCases int); INSERT INTO LegalAidClinics VALUES ('Clinic1', 'CA', 30, '2022-01-01'), ('Clinic2', 'CA', 25, '2022-01-01'); CREATE TABLE CommunityMediationCenters (CenterName text, State text, NumCases int); INSERT INTO CommunityMediationCenters VALUES ('CM1', 'CA', 22, '2022-01-01'), ('CM2', 'CA', 28, '2022-01-01');", "reference_sql": "SELECT State, 'Legal Aid Clinics' AS CenterType, COUNT(*) AS NumCenters, SUM(NumCases) AS TotalCases FROM LegalAidClinics WHERE State = 'CA' UNION ALL SELECT State, 'Community Mediation Centers', COUNT(*), SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA';", "generated_sql": "SELECT \n    (SELECT COUNT(*) FROM LegalAidClinics WHERE State = 'CA') AS NumLegalAidClinics,\n    (SELECT COUNT(*) FROM CommunityMediationCenters WHERE State = 'CA') AS NumCommunityMediationCenters,\n    (SELECT SUM(NumCases) FROM LegalAidClinics WHERE State = 'CA') AS TotalNumCasesLegalAidClinics,\n    (SELECT SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA') AS TotalNumCasesCommunityMediationCenters;", "raw_model_output": "```sql\nSELECT \n    (SELECT COUNT(*) FROM LegalAidClinics WHERE State = 'CA') AS NumLegalAidClinics,\n    (SELECT COUNT(*) FROM CommunityMediationCenters WHERE State = 'CA') AS NumCommunityMediationCenters,\n    (SELECT SUM(NumCases) FROM LegalAidClinics WHERE State = 'CA') AS TotalNumCasesLegalAidClinics,\n    (SELECT SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA') AS TotalNumCasesCommunityMediationCenters;\n```", "latency_sec": 1.581984043121338, "total_duration_sec": 1.503948541, "load_duration_sec": 0.014155305, "tokens_prompt": 255, "prompt_eval_sec": 0.014539549, "tokens_completion": 117, "completion_eval_sec": 1.471973317, "tokens_total": 372, "tokens_per_sec": 235.1477574110194, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two rows with columns State, CenterType, NumCenters, TotalCases, while the Generated SQL returns a single row with four separate columns for counts and sums. The structure and number of rows differ, making them non-equivalent."}
{"example_id": 2408, "sql_complexity": "aggregation", "prompt": "What is the average number of victories for players from Japan and South Korea, partitioned by game mode?", "context": "CREATE TABLE PlayerVictories (PlayerID INT, GameMode VARCHAR(255), Victories INT, Country VARCHAR(255)); INSERT INTO PlayerVictories (PlayerID, GameMode, Victories, Country) VALUES (1, 'Battle Royale', 25, 'Japan'), (2, 'Team Deathmatch', 18, 'South Korea');", "reference_sql": "SELECT GameMode, AVG(Victories) as AvgVictories FROM PlayerVictories WHERE Country IN ('Japan', 'South Korea') GROUP BY GameMode, Country WITH ROLLUP;", "generated_sql": "SELECT \n    GameMode,\n    AVG(Victories) AS AverageVictories\nFROM \n    PlayerVictories\nWHERE \n    Country IN ('Japan', 'South Korea')\nGROUP BY \n    GameMode;", "raw_model_output": "```sql\nSELECT \n    GameMode,\n    AVG(Victories) AS AverageVictories\nFROM \n    PlayerVictories\nWHERE \n    Country IN ('Japan', 'South Korea')\nGROUP BY \n    GameMode;\n```", "latency_sec": 0.8078432083129883, "total_duration_sec": 0.623808067, "load_duration_sec": 0.013506591, "tokens_prompt": 167, "prompt_eval_sec": 0.009199053, "tokens_completion": 48, "completion_eval_sec": 0.5987917, "tokens_total": 215, "tokens_per_sec": 266.14075328922127, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL groups by both GameMode and Country with ROLLUP, producing subtotals for each GameMode/Country combination and overall totals. The Generated SQL only groups by GameMode, omitting Country and ROLLUP. This results in different aggregation levels and missing summary rows, making the queries non-equivalent."}
{"example_id": 2729, "sql_complexity": "subqueries", "prompt": "Find the total number of trips made by shared autonomous vehicles in Seattle", "context": "CREATE TABLE shared_vehicles (id INT, vehicle_type VARCHAR(20), is_autonomous BOOLEAN, trip_count INT); INSERT INTO shared_vehicles (id, vehicle_type, is_autonomous, trip_count) VALUES (1, 'ebike', false, 1200), (2, 'escooter', false, 800), (3, 'car', true, 1500); CREATE TABLE city_data (city VARCHAR(20), has_autonomous_vehicles BOOLEAN); INSERT INTO city_data (city, has_autonomous_vehicles) VALUES ('Seattle', true), ('Denver', false), ('Portland', true);", "reference_sql": "SELECT SUM(trip_count) FROM shared_vehicles WHERE is_autonomous = true AND vehicle_type != 'ebike' AND vehicle_type != 'escooter' AND city IN (SELECT city FROM city_data WHERE has_autonomous_vehicles = true AND city = 'Seattle');", "generated_sql": "SELECT SUM(s.trip_count) AS total_trips\nFROM shared_vehicles s\nJOIN city_data c ON s.is_autonomous AND c.city = 'Seattle' AND c.has_autonomous_vehicles = true;", "raw_model_output": "```sql\nSELECT SUM(s.trip_count) AS total_trips\nFROM shared_vehicles s\nJOIN city_data c ON s.is_autonomous AND c.city = 'Seattle' AND c.has_autonomous_vehicles = true;\n```", "latency_sec": 0.8352749347686768, "total_duration_sec": 0.637011709, "load_duration_sec": 0.013998211, "tokens_prompt": 217, "prompt_eval_sec": 0.011440655, "tokens_completion": 48, "completion_eval_sec": 0.60922854, "tokens_total": 265, "tokens_per_sec": 317.2608071537425, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references a 'city' column in shared_vehicles, which does not exist in the schema. The Generated SQL attempts a JOIN but lacks proper join conditions between shared_vehicles and city_data. Even if schema issues are ignored, the Reference SQL includes vehicle_type filters ('!= 'ebike' AND != 'escooter'') while the Generated SQL does not, making them non-equivalent."}
{"example_id": 2952, "sql_complexity": "aggregation", "prompt": "Show the total budget allocated for each program category in 2023.", "context": "CREATE TABLE Budget (id INT, category TEXT, year INT, allocated_amount INT); INSERT INTO Budget (id, category, year, allocated_amount) VALUES (1, 'Education', 2023, 30000); INSERT INTO Budget (id, category, year, allocated_amount) VALUES (2, 'Healthcare', 2023, 50000);", "reference_sql": "SELECT category, SUM(allocated_amount) FROM Budget WHERE year = 2023 GROUP BY category;", "generated_sql": "SELECT category, SUM(allocated_amount) AS total_budget\nFROM Budget\nWHERE year = 2023\nGROUP BY category;", "raw_model_output": "```sql\nSELECT category, SUM(allocated_amount) AS total_budget\nFROM Budget\nWHERE year = 2023\nGROUP BY category;\n```", "latency_sec": 0.7213380336761475, "total_duration_sec": 0.462984178, "load_duration_sec": 0.02878188, "tokens_prompt": 169, "prompt_eval_sec": 0.01746019, "tokens_completion": 33, "completion_eval_sec": 0.414628937, "tokens_total": 202, "tokens_per_sec": 280.0351438153753, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (category and summed allocated_amount) from the Budget table where year is 2023, grouped by category. The only difference is the alias 'total_budget' in the generated query, which doesn't affect the semantic meaning of the result."}
{"example_id": 4328, "sql_complexity": "aggregation", "prompt": "What is the average cargo handling time in hours for each port?", "context": "CREATE TABLE cargo_handling (id INT, port_id INT, time_in_hours DECIMAL(5,2)); INSERT INTO cargo_handling (id, port_id, time_in_hours) VALUES (1, 1, 20.5), (2, 1, 22.3), (3, 2, 18.7);", "reference_sql": "SELECT port_id, AVG(time_in_hours) FROM cargo_handling GROUP BY port_id;", "generated_sql": "SELECT port_id, AVG(time_in_hours) AS avg_handling_time\nFROM cargo_handling\nGROUP BY port_id;", "raw_model_output": "```sql\nSELECT port_id, AVG(time_in_hours) AS avg_handling_time\nFROM cargo_handling\nGROUP BY port_id;\n```", "latency_sec": 0.4708437919616699, "total_duration_sec": 0.377199014, "load_duration_sec": 0.014573172, "tokens_prompt": 155, "prompt_eval_sec": 0.008230679, "tokens_completion": 28, "completion_eval_sec": 0.352130876, "tokens_total": 183, "tokens_per_sec": 388.6639329735445, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries group by port_id and calculate the average time_in_hours. The generated query adds an alias (avg_handling_time) for the calculated column, but this does not affect the semantic result set structure or content. The GROUP BY clause and aggregation logic are identical."}
{"example_id": 4915, "sql_complexity": "window functions", "prompt": "Calculate the percentage of total Europium production for each country.", "context": "CREATE TABLE europium_production (country VARCHAR(50), quantity INT);", "reference_sql": "SELECT country, quantity * 100.0 / SUM(quantity) OVER (PARTITION BY NULL) AS percentage FROM europium_production;", "generated_sql": "SELECT \n    country,\n    (quantity * 100.0 / SUM(quantity) OVER ()) AS percentage_of_total\nFROM \n    europium_production;", "raw_model_output": "```sql\nSELECT \n    country,\n    (quantity * 100.0 / SUM(quantity) OVER ()) AS percentage_of_total\nFROM \n    europium_production;\n```", "latency_sec": 0.5708649158477783, "total_duration_sec": 0.485279492, "load_duration_sec": 0.013909896, "tokens_prompt": 96, "prompt_eval_sec": 0.006797842, "tokens_completion": 38, "completion_eval_sec": 0.462674182, "tokens_total": 134, "tokens_per_sec": 234.73153854795873, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the percentage of each country's production relative to the total production. The window function SUM(quantity) OVER () in the generated query is equivalent to SUM(quantity) OVER (PARTITION BY NULL) in the reference query, as both compute the total sum across all rows. The column alias difference (percentage vs percentage_of_total) does not affect semantic equivalence."}
{"example_id": 5030, "sql_complexity": "subqueries", "prompt": "What is the success rate of diverse-led startups (at least 1 female or underrepresented racial or ethnic group executive) in the past 3 years?", "context": "CREATE TABLE DiverseStartups(id INT, name TEXT, country TEXT, year INT, success BOOLEAN);   INSERT INTO DiverseStartups VALUES (1, 'FemTech', 'USA', 2020, true), (2, 'GreenCity', 'Canada', 2019, false), (3, 'AI-Health', 'UK', 2021, true), (4, 'SolarEnergy', 'USA', 2020, false), (5, 'DataAnalytics', 'Germany', 2019, true), (6, 'SmartGrid', 'USA', 2021, true), (7, 'CloudServices', 'India', 2020, false), (8, 'RenewableEnergy', 'USA', 2019, true);", "reference_sql": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3) AS success_rate FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3 AND success = true;", "generated_sql": "SELECT \n    SUM(CASE WHEN year >= 2019 THEN success ELSE 0 END) AS successful_startups,\n    COUNT(*) AS total_startups,\n    (SUM(CASE WHEN year >= 2019 THEN success ELSE 0 END) * 1.0 / COUNT(*)) * 100 AS success_rate\nFROM \n    DiverseStartups;", "raw_model_output": "```sql\nSELECT \n    SUM(CASE WHEN year >= 2019 THEN success ELSE 0 END) AS successful_startups,\n    COUNT(*) AS total_startups,\n    (SUM(CASE WHEN year >= 2019 THEN success ELSE 0 END) * 1.0 / COUNT(*)) * 100 AS success_rate\nFROM \n    DiverseStartups;\n```", "latency_sec": 1.3048439025878906, "total_duration_sec": 1.105916298, "load_duration_sec": 0.013647675, "tokens_prompt": 277, "prompt_eval_sec": 0.014310813, "tokens_completion": 85, "completion_eval_sec": 1.075378621, "tokens_total": 362, "tokens_per_sec": 277.42782050944726, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Reference SQL uses a dynamic year condition (YEAR(CURRENT_DATE) - 3) while the Generated SQL uses a fixed year (2019). Second, the Generated SQL calculates the success rate using the total number of startups (COUNT(*)) across all years, whereas the Reference SQL restricts both numerator and denominator to startups from the last 3 years. This leads to different result calculations."}
{"example_id": 4626, "sql_complexity": "aggregation", "prompt": "What was the maximum number of training hours for farmers in each country in 2020?", "context": "CREATE TABLE training (id INT, country_id INT, farmer_id INT, hours INT, date DATE);", "reference_sql": "SELECT country_id, MAX(hours) FROM training WHERE YEAR(date) = 2020 GROUP BY country_id;", "generated_sql": "SELECT \n    country_id, \n    MAX(hours) AS max_hours\nFROM \n    training\nWHERE \n    YEAR(date) = 2020\nGROUP BY \n    country_id;", "raw_model_output": "```sql\nSELECT \n    country_id, \n    MAX(hours) AS max_hours\nFROM \n    training\nWHERE \n    YEAR(date) = 2020\nGROUP BY \n    country_id;\n```", "latency_sec": 0.8811378479003906, "total_duration_sec": 0.576780588, "load_duration_sec": 0.018654954, "tokens_prompt": 110, "prompt_eval_sec": 0.006989238, "tokens_completion": 45, "completion_eval_sec": 0.549028977, "tokens_total": 155, "tokens_per_sec": 175.9089118341018, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. The generated query adds an explicit alias 'max_hours' to the MAX(hours) column, but this does not affect the result set's data. Both queries select the same country_id values, apply the same filter (YEAR(date) = 2020), and group by country_id to calculate the maximum hours. The column name difference does not impact the semantic equivalence of the result."}
{"example_id": 2703, "sql_complexity": "set operations", "prompt": "Identify the species unique to 'MarineResearchAreaA' and 'MarineResearchAreaB'", "context": "CREATE TABLE ResearchAreaSpecies (area VARCHAR(255), species VARCHAR(255)); INSERT INTO ResearchAreaSpecies (area, species) VALUES ('MarineResearchAreaA', 'Coral'), ('MarineResearchAreaA', 'Starfish'), ('MarineResearchAreaB', 'Jellyfish');", "reference_sql": "(SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB') UNION (SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA');", "generated_sql": "SELECT area, species \nFROM ResearchAreaSpecies \nWHERE area IN ('MarineResearchAreaA', 'MarineResearchAreaB')\nGROUP BY area, species \nHAVING COUNT(DISTINCT area) = 1;", "raw_model_output": "```sql\nSELECT area, species \nFROM ResearchAreaSpecies \nWHERE area IN ('MarineResearchAreaA', 'MarineResearchAreaB')\nGROUP BY area, species \nHAVING COUNT(DISTINCT area) = 1;\n```\n\nThis query identifies the species that are unique to either 'MarineResearchAreaA' or 'MarineResearchAreaB'. The `COUNT(DISTINCT area)` ensures that only those species which appear in exactly one of the specified areas are selected.", "latency_sec": 1.4022390842437744, "total_duration_sec": 1.261781737, "load_duration_sec": 0.013695056, "tokens_prompt": 155, "prompt_eval_sec": 0.008537291, "tokens_completion": 101, "completion_eval_sec": 1.237178084, "tokens_total": 256, "tokens_per_sec": 182.56515802229293, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns only species names that are unique to each area (Coral, Starfish, Jellyfish), while the Generated SQL returns both area and species where the species exists in only one area (e.g., ('MarineResearchAreaA', 'Coral')). The result sets differ in column structure and content, making them semantically distinct."}
{"example_id": 200, "sql_complexity": "window functions", "prompt": "List the top three categories of workforce development programs with the highest budget increases.", "context": "CREATE TABLE programs (program_id INT, program_name VARCHAR(50), budget DECIMAL(10, 2), category VARCHAR(50), budget_date DATE);", "reference_sql": "SELECT category, SUM(budget - LAG(budget) OVER (PARTITION BY category ORDER BY budget_date)) as total_budget_increase FROM programs GROUP BY category ORDER BY total_budget_increase DESC LIMIT 3;", "generated_sql": "SELECT \n    category,\n    MAX(budget) - MIN(budget) AS budget_increase\nFROM \n    programs\nWHERE \n    category IS NOT NULL AND category != ''\nGROUP BY \n    category\nORDER BY \n    budget_increase DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT \n    category,\n    MAX(budget) - MIN(budget) AS budget_increase\nFROM \n    programs\nWHERE \n    category IS NOT NULL AND category != ''\nGROUP BY \n    category\nORDER BY \n    budget_increase DESC\nLIMIT 3;\n```\n\n### Explanation:\n- **MAX(budget) - MIN(budget)**: This calculates the budget increase for each category.\n- **WHERE category IS NOT NULL AND category != ''**: Ensures that only non-empty and non-null categories are considered.\n- **GROUP BY category**: Groups the results by category to calculate the budget increase per category.\n- **ORDER BY budget_increase DESC**: Orders the results in descending order of budget increase.\n- **LIMIT 3**: Limits the output to the top three categories with the highest budget increases.", "latency_sec": 2.2407150268554688, "total_duration_sec": 2.029059845, "load_duration_sec": 0.016775199, "tokens_prompt": 119, "prompt_eval_sec": 0.007311992, "tokens_completion": 165, "completion_eval_sec": 2.002755529, "tokens_total": 284, "tokens_per_sec": 126.74525613306321, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries calculate different metrics. The Reference SQL computes the sum of consecutive budget differences within each category (using LAG), while the Generated SQL calculates the total range (MAX - MIN) for each category. These approaches yield different results when there are fluctuations in budget values over time."}
{"example_id": 5131, "sql_complexity": "basic SQL", "prompt": "How many wells were drilled in the Eagle Ford Shale and Bakken Formation?", "context": "CREATE TABLE wells (id INT, region VARCHAR(255), well_type VARCHAR(255), num_drilled INT); INSERT INTO wells (id, region, well_type, num_drilled) VALUES (1, 'Eagle Ford Shale', 'Oil', 2000), (2, 'Eagle Ford Shale', 'Gas', 1500), (3, 'Bakken Formation', 'Oil', 1000), (4, 'Bakken Formation', 'Gas', 1200);", "reference_sql": "SELECT SUM(num_drilled) as total_wells FROM wells WHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "generated_sql": "SELECT SUM(num_drilled) AS total_wells_drilled\nFROM wells\nWHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "raw_model_output": "```sql\nSELECT SUM(num_drilled) AS total_wells_drilled\nFROM wells\nWHERE region IN ('Eagle Ford Shale', 'Bakken Formation');\n```", "latency_sec": 0.5260720252990723, "total_duration_sec": 0.499778948, "load_duration_sec": 0.013353909, "tokens_prompt": 202, "prompt_eval_sec": 0.011077331, "tokens_completion": 37, "completion_eval_sec": 0.473191327, "tokens_total": 239, "tokens_per_sec": 454.31041474620963, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of num_drilled for wells in the specified regions. The only difference is the column alias name (total_wells vs. total_wells_drilled), which doesn't affect the semantic result. The WHERE clause and aggregate function are identical."}
{"example_id": 1160, "sql_complexity": "subqueries", "prompt": "What is the total revenue generated from ads on Instagram in March 2021, for users in the 'brand' category who have posted more than 10 times?", "context": "CREATE TABLE ads (ad_id INT, user_id INT, platform VARCHAR(255), ad_revenue DECIMAL(10,2), post_count INT); INSERT INTO ads (ad_id, user_id, platform, ad_revenue, post_count) VALUES (1, 1, 'Instagram', 150.50, 12), (2, 2, 'Twitter', 80.00, 15), (3, 3, 'Instagram', 120.75, 8);", "reference_sql": "SELECT SUM(ad_revenue) FROM ads WHERE platform = 'Instagram' AND MONTH(ad_date) = 3 AND YEAR(ad_date) = 2021 AND user_id IN (SELECT user_id FROM users WHERE category = 'brand' AND post_count > 10);", "generated_sql": "SELECT SUM(ad_revenue) AS total_revenue\nFROM ads\nWHERE platform = 'Instagram'\nAND post_count > 10\nAND user_id IN (\n    SELECT user_id\n    FROM ads\n    WHERE DATE_FORMAT(CURRENT_DATE, '%Y-%m') = '2021-03'\n)\nAND DATE_FORMAT(CURRENT_DATE, '%Y-%m') = '2021-03';", "raw_model_output": "```sql\nSELECT SUM(ad_revenue) AS total_revenue\nFROM ads\nWHERE platform = 'Instagram'\nAND post_count > 10\nAND user_id IN (\n    SELECT user_id\n    FROM ads\n    WHERE DATE_FORMAT(CURRENT_DATE, '%Y-%m') = '2021-03'\n)\nAND DATE_FORMAT(CURRENT_DATE, '%Y-%m') = '2021-03';\n```\n\n### Explanation:\n- The `platform` column is checked to ensure the ad was posted on Instagram.\n- The `post_count` column ensures that only users who have posted more than 10 times are considered.\n- A subquery is used to filter users based on their activity in March 2021. This subquery checks if the user has any ads with a post count greater than 10 in March 2021.\n- The `ad_revenue` for these filtered users and ads is then summed up.\n\nHowever, since we are dealing with a specific month (March 2021), it's more straightforward to directly filter by the date:\n\n```sql\nSELECT SUM(ad_revenue) AS total_revenue\nFROM ads\nWHERE platform = 'Instagram'\nAND post_count > 10\nAND DATE_FORMAT(CAST('2021-03-01' AS DATE), '%Y-%m') = DATE_FORMAT(date_add(CURRENT_DATE, INTERVAL -DAY(CURRENT_DATE) + 1 DAY), '%Y-%m')\nAND user_id IN (\n    SELECT user_id\n    FROM ads\n    WHERE platform = 'Instagram'\n    AND post_count > 10\n);\n```\n\n### Explanation:\n- The `platform` column is checked to ensure the ad was posted on Instagram.\n- The `post_count` column ensures that only users who have posted more than 10 times are considered.\n- A subquery is used to filter users based on their activity in March 2021. This subquery checks if the user has any ads with a post count greater than 10 and whose ad was placed in March 2021.\n\nThis ensures that only relevant data is included in the final sum.", "latency_sec": 5.966767072677612, "total_duration_sec": 5.663226052, "load_duration_sec": 0.014541375, "tokens_prompt": 220, "prompt_eval_sec": 0.011558511, "tokens_completion": 456, "completion_eval_sec": 5.634897393, "tokens_total": 676, "tokens_per_sec": 113.29418289101105, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in multiple critical aspects.  The Reference SQL filters on ad_date being March 2021, while the Generated SQL uses the current date.  The subquery in the Reference SQL filters users with category 'brand' and post_count > 10, while the Generated SQL's subquery filters ads with a date condition.  Additionally, the Generated SQL includes a post_count > 10 condition in the main query, which is absent in the Reference SQL. These differences will lead to different results."}
{"example_id": 4708, "sql_complexity": "subqueries", "prompt": "What is the maximum number of high-level threats reported by a single agency in a month?", "context": "CREATE TABLE Threat_Intelligence (Threat_ID INT, Threat_Type VARCHAR(50), Threat_Level VARCHAR(50), Reported_Date DATE, Reporting_Agency VARCHAR(50)); CREATE VIEW High_Level_Threats AS SELECT Threat_Type, Threat_Level, Reported_Date FROM Threat_Intelligence WHERE Threat_Level = 'High';", "reference_sql": "SELECT Reporting_Agency, MAX(Number_of_High_Level_Threats) as Max_High_Level_Threats_in_a_Month FROM (SELECT Reporting_Agency, TO_CHAR(Reported_Date, 'YYYY-MM') as Month, COUNT(*) as Number_of_High_Level_Threats FROM High_Level_Threats GROUP BY Reporting_Agency, Month) GROUP BY Reporting_Agency;", "generated_sql": "SELECT \n    Reporting_Agency,\n    COUNT(*) AS High_Level_Threats_Reported\nFROM \n    Threat_Intelligence\nWHERE \n    Threat_Level = 'High'\nGROUP BY \n    Reporting_Agency, \n    DATE_FORMAT(Reported_Date, '%Y-%m')\nORDER BY \n    High_Level_Threats_Reported DESC\nLIMIT 1;", "raw_model_output": "```sql\nSELECT \n    Reporting_Agency,\n    COUNT(*) AS High_Level_Threats_Reported\nFROM \n    Threat_Intelligence\nWHERE \n    Threat_Level = 'High'\nGROUP BY \n    Reporting_Agency, \n    DATE_FORMAT(Reported_Date, '%Y-%m')\nORDER BY \n    High_Level_Threats_Reported DESC\nLIMIT 1;\n```", "latency_sec": 1.2030479907989502, "total_duration_sec": 1.025712111, "load_duration_sec": 0.013689872, "tokens_prompt": 153, "prompt_eval_sec": 0.008624872, "tokens_completion": 81, "completion_eval_sec": 1.001003182, "tokens_total": 234, "tokens_per_sec": 194.50595636222243, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates the maximum number of high-level threats per agency across months, grouping by agency and returning per-agency max values. The Generated SQL counts threats per agency-month, then returns only the single highest count overall (due to ORDER BY + LIMIT 1), losing per-agency context. The Generated SQL also uses DATE_FORMAT instead of TO_CHAR and lacks the outer aggregation present in the Reference SQL."}
{"example_id": 5608, "sql_complexity": "set operations", "prompt": "List the suppliers that provide materials for both product A and product C.", "context": "CREATE TABLE products (product_id INT, product_name TEXT); CREATE TABLE materials (material_id INT, material_name TEXT, product_id INT, supplier_id INT); INSERT INTO products (product_id, product_name) VALUES (1, 'Product A'), (2, 'Product B'), (3, 'Product C'); INSERT INTO materials (material_id, material_name, product_id, supplier_id) VALUES (1, 'Material 1', 1, 101), (2, 'Material 2', 1, 102), (3, 'Material 3', 2, 103), (4, 'Material 4', 3, 101), (5, 'Material 5', 3, 102);", "reference_sql": "SELECT supplier_id FROM materials WHERE product_id = 1 INTERSECT SELECT supplier_id FROM materials WHERE product_id = 3;", "generated_sql": "SELECT supplier_id \nFROM materials \nWHERE product_id IN (1, 3) \nGROUP BY supplier_id \nHAVING COUNT(DISTINCT product_id) = 2;", "raw_model_output": "```sql\nSELECT supplier_id \nFROM materials \nWHERE product_id IN (1, 3) \nGROUP BY supplier_id \nHAVING COUNT(DISTINCT product_id) = 2;\n```", "latency_sec": 0.6682140827178955, "total_duration_sec": 0.557897405, "load_duration_sec": 0.01566133, "tokens_prompt": 244, "prompt_eval_sec": 0.011170168, "tokens_completion": 41, "completion_eval_sec": 0.528551977, "tokens_total": 285, "tokens_per_sec": 426.51001732976107, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve supplier_ids that are associated with both product_id 1 and product_id 3. The Reference SQL uses INTERSECT to find common supplier_ids between the two product_id conditions, while the Generated SQL uses GROUP BY and HAVING to ensure a supplier has entries for both product_ids. In the given data, both approaches yield the same result (supplier_ids 101 and 102)."}
{"example_id": 1506, "sql_complexity": "basic SQL", "prompt": "How many habitats are in the 'animal_habitats' table?", "context": "CREATE TABLE animal_habitats (id INT PRIMARY KEY, habitat_name VARCHAR, num_animals INT);", "reference_sql": "SELECT COUNT(*) FROM animal_habitats;", "generated_sql": "SELECT COUNT(*) FROM animal_habitats;", "raw_model_output": "SELECT COUNT(*) FROM animal_habitats;", "latency_sec": 0.3620119094848633, "total_duration_sec": 0.158391687, "load_duration_sec": 0.024455318, "tokens_prompt": 104, "prompt_eval_sec": 0.005800057, "tokens_completion": 10, "completion_eval_sec": 0.126112225, "tokens_total": 114, "tokens_per_sec": 314.90676691333175, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical: they select the count of all rows from the 'animal_habitats' table using the same syntax. The result will be the same since they execute the same operation on the same table."}
{"example_id": 3117, "sql_complexity": "aggregation", "prompt": "What is the percentage of the population that has access to clean water in each continent?", "context": "CREATE TABLE water_data (id INT, country VARCHAR(50), continent CHAR(2), access_to_clean_water BOOLEAN); INSERT INTO water_data VALUES (1, 'Canada', 'NA', true), (2, 'Mexico', 'NA', false), (3, 'Brazil', 'SA', true), (4, 'Russia', 'EU', true);", "reference_sql": "SELECT continent, COUNT(*) FILTER (WHERE access_to_clean_water) * 100.0 / COUNT(*) AS percentage FROM water_data GROUP BY continent;", "generated_sql": "SELECT \n    continent,\n    SUM(CASE WHEN access_to_clean_water THEN 1 ELSE 0 END) * 100.0 / COUNT(*) AS percentage_access_to_clean_water\nFROM \n    water_data\nGROUP BY \n    continent;", "raw_model_output": "```sql\nSELECT \n    continent,\n    SUM(CASE WHEN access_to_clean_water THEN 1 ELSE 0 END) * 100.0 / COUNT(*) AS percentage_access_to_clean_water\nFROM \n    water_data\nGROUP BY \n    continent;\n```", "latency_sec": 0.8065826892852783, "total_duration_sec": 0.711700572, "load_duration_sec": 0.014795788, "tokens_prompt": 160, "prompt_eval_sec": 0.008586215, "tokens_completion": 56, "completion_eval_sec": 0.686121528, "tokens_total": 216, "tokens_per_sec": 267.7964737767927, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the percentage of countries with access to clean water per continent. The reference uses COUNT(*) FILTER (WHERE access_to_clean_water) while the generated uses SUM(CASE WHEN ... THEN 1 ELSE 0 END), which are functionally equivalent. Both divide by COUNT(*) and multiply by 100.0 to get the percentage. The only difference is the column name, which doesn't affect semantic equivalence."}
{"example_id": 3542, "sql_complexity": "window functions", "prompt": "What is the average yield of crops for each country, ranked by average yield?", "context": "CREATE TABLE farming (id INT, name TEXT, country TEXT, crop TEXT, yield INT); INSERT INTO farming VALUES (1, 'Smith Farm', 'USA', 'Corn', 120), (2, 'Brown Farm', 'Canada', 'Soybeans', 45), (3, 'Jones Farm', 'Mexico', 'Wheat', 80);", "reference_sql": "SELECT country, AVG(yield) as avg_yield, ROW_NUMBER() OVER (ORDER BY AVG(yield) DESC) as rank FROM farming GROUP BY country;", "generated_sql": "SELECT \n    country,\n    AVG(yield) AS avg_yield\nFROM \n    farming\nGROUP BY \n    country\nORDER BY \n    avg_yield DESC;", "raw_model_output": "```sql\nSELECT \n    country,\n    AVG(yield) AS avg_yield\nFROM \n    farming\nGROUP BY \n    country\nORDER BY \n    avg_yield DESC;\n```", "latency_sec": 0.5449008941650391, "total_duration_sec": 0.510934946, "load_duration_sec": 0.025157636, "tokens_prompt": 163, "prompt_eval_sec": 0.008240266, "tokens_completion": 38, "completion_eval_sec": 0.475403449, "tokens_total": 201, "tokens_per_sec": 368.87441762780685, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a ROW_NUMBER() window function to assign ranks based on average yield, while the Generated SQL only groups and orders by average yield without calculating ranks. The result sets differ in structure (the Generated SQL lacks the 'rank' column) and semantic purpose (ranking vs. simple sorting)."}
{"example_id": 2274, "sql_complexity": "subqueries", "prompt": "Add a new crop 'amaranth' to farm 'Nourishing Harvest' with yield 50 in 2023", "context": "CREATE TABLE farms (id INT, name TEXT, location TEXT, size FLOAT); INSERT INTO farms (id, name, location, size) VALUES (1, 'Nourishing Harvest', 'Mexico', 120.0); CREATE TABLE crops (id INT, farm_id INT, crop TEXT, yield INT, year INT);", "reference_sql": "INSERT INTO crops (id, farm_id, crop, yield, year) VALUES (5, (SELECT id FROM farms WHERE name = 'Nourishing Harvest'), 'amaranth', 50, 2023);", "generated_sql": "INSERT INTO crops (farm_id, crop, yield, year)\nSELECT id, 'amaranth', 50, 2023\nFROM farms\nWHERE name = 'Nourishing Harvest';", "raw_model_output": "```sql\nINSERT INTO crops (farm_id, crop, yield, year)\nSELECT id, 'amaranth', 50, 2023\nFROM farms\nWHERE name = 'Nourishing Harvest';\n```", "latency_sec": 0.9081060886383057, "total_duration_sec": 0.610102344, "load_duration_sec": 0.013947319, "tokens_prompt": 165, "prompt_eval_sec": 0.008111327, "tokens_completion": 47, "completion_eval_sec": 0.58582652, "tokens_total": 212, "tokens_per_sec": 233.4529001098225, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL explicitly specifies an id value (5) for the inserted row, while the Generated SQL omits the id column entirely. The Generated SQL also uses a SELECT statement that could insert multiple rows if multiple farms matched the name, whereas the Reference SQL inserts a single row. Additionally, the Generated SQL's structure does not guarantee the same id value as the Reference SQL."}
{"example_id": 3705, "sql_complexity": "subqueries", "prompt": "What is the percentage of unions with collective bargaining agreements in the Midwest region?", "context": "CREATE TABLE collective_bargaining (bargaining_id INT, union_name VARCHAR(50), contract_start_date DATE, contract_end_date DATE, region VARCHAR(50));CREATE VIEW union_region AS SELECT DISTINCT union_name, region FROM collective_bargaining;", "reference_sql": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM union_region) as percentage FROM union_region ur WHERE ur.region = 'Midwest' AND EXISTS (SELECT 1 FROM collective_bargaining cb WHERE cb.union_name = ur.union_name);", "generated_sql": "SELECT \n    CAST(SUM(CASE WHEN region = 'Midwest' THEN 1 ELSE 0 END) AS DECIMAL(10,2)) * 100.0 / COUNT(*) \nAS percentage_of_unions_in_midwest\nFROM union_region;", "raw_model_output": "```sql\nSELECT \n    CAST(SUM(CASE WHEN region = 'Midwest' THEN 1 ELSE 0 END) AS DECIMAL(10,2)) * 100.0 / COUNT(*) \nAS percentage_of_unions_in_midwest\nFROM union_region;\n```\n\nThis SQL query calculates the percentage of unions with collective bargaining agreements in the Midwest region by using a `CASE` statement to count the number of unions in the Midwest and dividing it by the total number of unique unions, then multiplying by 100 to get the percentage.", "latency_sec": 1.553375244140625, "total_duration_sec": 1.454211489, "load_duration_sec": 0.014765394, "tokens_prompt": 137, "prompt_eval_sec": 0.007741843, "tokens_completion": 117, "completion_eval_sec": 1.429461949, "tokens_total": 254, "tokens_per_sec": 163.51490147541307, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the percentage of unions in the 'Midwest' region relative to all unions in the union_region view. The Reference SQL counts rows in union_region where region = 'Midwest' (with a redundant EXISTS check that always evaluates to true) and divides by the total count of union_region rows. The Generated SQL uses SUM(CASE WHEN region = 'Midwest' THEN 1 ELSE 0 END) to count Midwest unions and divides by COUNT(*) for the total. Since union_region is a DISTINCT view, both approaches yield the same result."}
{"example_id": 240, "sql_complexity": "aggregation", "prompt": "What is the average capacity of renewable energy projects for each country?", "context": "CREATE TABLE projects (name TEXT, type TEXT, capacity INTEGER, country TEXT); INSERT INTO projects (name, type, capacity, country) VALUES ('Project 1', 'Wind', 100, 'USA'), ('Project 2', 'Solar', 200, 'Germany'), ('Project 3', 'Wind', 300, 'France');", "reference_sql": "SELECT country, AVG(capacity) FROM projects GROUP BY country", "generated_sql": "SELECT country, AVG(capacity) AS average_capacity\nFROM projects\nWHERE type IN ('Wind', 'Solar')\nGROUP BY country;", "raw_model_output": "```sql\nSELECT country, AVG(capacity) AS average_capacity\nFROM projects\nWHERE type IN ('Wind', 'Solar')\nGROUP BY country;\n```", "latency_sec": 0.5030820369720459, "total_duration_sec": 0.434295399, "load_duration_sec": 0.024954837, "tokens_prompt": 159, "prompt_eval_sec": 0.007787122, "tokens_completion": 32, "completion_eval_sec": 0.399458222, "tokens_total": 191, "tokens_per_sec": 379.65974923213776, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes all projects regardless of type, while the Generated SQL filters projects to only 'Wind' and 'Solar' types. Although the sample data contains only Wind and Solar projects, the WHERE clause makes the Generated SQL exclude other potential project types not present in the sample, leading to different results in general cases."}
{"example_id": 2132, "sql_complexity": "set operations", "prompt": "What is the average caseload per attorney in community legal clinics in California, and how does it compare to the state average?", "context": "CREATE TABLE cali_community_legal_clinics(id INT, attorney_count INT, cases_handled INT, state VARCHAR(255));", "reference_sql": "SELECT state, AVG(cases_handled/attorney_count) AS avg_caseload FROM cali_community_legal_clinics WHERE state = 'California' GROUP BY state UNION ALL SELECT 'California', AVG(cases_handled/attorney_count) FROM cali_community_legal_clinics WHERE state = 'California';", "generated_sql": "SELECT \n    (SUM(cases_handled) / SUM(attorney_count)) AS avg_caseload_per_attorney,\n    (SELECT (SUM(cases_handled) / SUM(attorney_count)) FROM cali_community_legal_clinics) AS state_avg_caseload_per_attorney\nFROM \n    cali_community_legal_clinics\nWHERE \n    state = 'California';", "raw_model_output": "```sql\nSELECT \n    (SUM(cases_handled) / SUM(attorney_count)) AS avg_caseload_per_attorney,\n    (SELECT (SUM(cases_handled) / SUM(attorney_count)) FROM cali_community_legal_clinics) AS state_avg_caseload_per_attorney\nFROM \n    cali_community_legal_clinics\nWHERE \n    state = 'California';\n```", "latency_sec": 1.3498859405517578, "total_duration_sec": 1.04760636, "load_duration_sec": 0.014267958, "tokens_prompt": 122, "prompt_eval_sec": 0.006218523, "tokens_completion": 84, "completion_eval_sec": 1.024862492, "tokens_total": 206, "tokens_per_sec": 152.60548599817162, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries calculate different metrics. The Reference SQL computes AVG(cases_handled/attorney_count) (average of per-clinic ratios), while the Generated SQL computes SUM(cases_handled)/SUM(attorney_count) (total cases divided by total attorneys). These methods yield different results in cases where clinics have varying attorney counts. Additionally, the output structure differs: the Reference SQL returns two rows with state and average, while the Generated SQL returns one row with two columns."}
{"example_id": 3276, "sql_complexity": "basic SQL", "prompt": "What is the total energy consumption of the Chemical Plant B in the last quarter?", "context": "CREATE TABLE EnergyConsumption (EnergyID INT, Plant VARCHAR(255), EnergyQuantity DECIMAL(5,2), Timestamp DATETIME);", "reference_sql": "SELECT SUM(EnergyQuantity) FROM EnergyConsumption WHERE Plant = 'Chemical Plant B' AND Timestamp BETWEEN DATE_SUB(CURRENT_DATE(), INTERVAL 3 MONTH) AND CURRENT_DATE();", "generated_sql": "SELECT SUM(EnergyQuantity) AS Total_Energy_Consumption\nFROM EnergyConsumption\nWHERE Plant = 'Chemical Plant B' AND Timestamp >= DATEADD(quarter, DATEDIFF(quarter, 0, GETDATE()) - 1, 0)\nAND Timestamp < DATEADD(quarter, DATEDIFF(quarter, 0, GETDATE()), 0);", "raw_model_output": "```sql\nSELECT SUM(EnergyQuantity) AS Total_Energy_Consumption\nFROM EnergyConsumption\nWHERE Plant = 'Chemical Plant B' AND Timestamp >= DATEADD(quarter, DATEDIFF(quarter, 0, GETDATE()) - 1, 0)\nAND Timestamp < DATEADD(quarter, DATEDIFF(quarter, 0, GETDATE()), 0);\n```", "latency_sec": 1.1297121047973633, "total_duration_sec": 1.031900978, "load_duration_sec": 0.014054283, "tokens_prompt": 115, "prompt_eval_sec": 0.007045973, "tokens_completion": 83, "completion_eval_sec": 1.008731305, "tokens_total": 198, "tokens_per_sec": 175.2658922208462, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their date range calculations. The reference uses DATE_SUB(CURRENT_DATE(), INTERVAL 3 MONTH) to get exactly 3 months prior, while the generated query uses DATEADD(quarter, DATEDIFF(quarter, 0, GETDATE()) - 1, 0) which captures the entire previous quarter (e.g., July 1 - September 30) rather than a 3-month window from today (e.g., July 15 - October 15). This results in different time ranges being queried."}
{"example_id": 3074, "sql_complexity": "multiple_joins", "prompt": "Find the top 5 players with the highest scores in the 'historical_tournaments' view, including their scores and the names of the tournaments they participated in.", "context": "CREATE VIEW historical_tournaments AS SELECT tournaments.tournament_name, players.player_name, players.score FROM tournaments JOIN players_scores ON tournaments.tournament_id = players_scores.tournament_id JOIN players ON players_scores.player_id = players.player_id;  CREATE TABLE tournaments (tournament_id INT, tournament_name TEXT);  CREATE TABLE players_scores (player_id INT, tournament_id INT, score INT);  CREATE TABLE players (player_id INT, player_name TEXT);", "reference_sql": "SELECT players.player_name, MAX(players_scores.score) as high_score, tournaments.tournament_name FROM historical_tournaments JOIN players ON historical_tournaments.player_id = players.player_id JOIN players_scores ON historical_tournaments.player_id = players_scores.player_id JOIN tournaments ON players_scores.tournament_id = tournaments.tournament_id GROUP BY players.player_id, tournaments.tournament_name ORDER BY high_score DESC LIMIT 5;", "generated_sql": "SELECT \n    p.player_name,\n    ht.tournament_name,\n    ps.score\nFROM \n    historical_tournaments ht\nJOIN \n    players p ON ht.player_id = p.player_id\nORDER BY \n    ht.score DESC\nLIMIT 5;", "raw_model_output": "```sql\nSELECT \n    p.player_name,\n    ht.tournament_name,\n    ps.score\nFROM \n    historical_tournaments ht\nJOIN \n    players p ON ht.player_id = p.player_id\nORDER BY \n    ht.score DESC\nLIMIT 5;\n```", "latency_sec": 1.0346081256866455, "total_duration_sec": 0.732200004, "load_duration_sec": 0.013328138, "tokens_prompt": 191, "prompt_eval_sec": 0.011057093, "tokens_completion": 56, "completion_eval_sec": 0.705046516, "tokens_total": 247, "tokens_per_sec": 238.73773447900558, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates the maximum score per player-tournament combination using GROUP BY and MAX(), while the Generated SQL simply selects raw scores without aggregation. The Generated SQL also lacks the necessary joins and grouping to ensure correct aggregation, and orders by raw score instead of the maximum score. Additionally, the Generated SQL's output structure differs by including raw scores instead of aggregated high scores."}
{"example_id": 2219, "sql_complexity": "window functions", "prompt": "What is the average population of cities with a UNESCO World Heritage designation, ordered by designation date?", "context": "CREATE TABLE cities (name VARCHAR(255), population INT, designation_date DATE); INSERT INTO cities (name, population, designation_date) VALUES ('Paris', 2141000, '1991-09-16'); INSERT INTO cities (name, population, designation_date) VALUES ('Rio de Janeiro', 6727000, '2012-07-01');", "reference_sql": "SELECT AVG(population) FROM (SELECT population, ROW_NUMBER() OVER (ORDER BY designation_date) rn FROM cities WHERE name IN (SELECT name FROM heritagesites)) t WHERE rn % 2 = 1;", "generated_sql": "SELECT AVG(population) AS average_population\nFROM cities\nWHERE designation_date IS NOT NULL\nORDER BY designation_date;", "raw_model_output": "```sql\nSELECT AVG(population) AS average_population\nFROM cities\nWHERE designation_date IS NOT NULL\nORDER BY designation_date;\n```", "latency_sec": 0.49830102920532227, "total_duration_sec": 0.399671747, "load_duration_sec": 0.01869456, "tokens_prompt": 180, "prompt_eval_sec": 0.008783136, "tokens_completion": 29, "completion_eval_sec": 0.369872585, "tokens_total": 209, "tokens_per_sec": 419.4251822704598, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates the average of populations from cities in heritagesites, ordered by designation_date, and only includes odd-numbered rows. The Generated SQL calculates the average population of all cities with non-null designation dates, without filtering by heritagesites or using row numbering. The conditions, subqueries, and logic differ significantly."}
{"example_id": 3786, "sql_complexity": "aggregation", "prompt": "Display the names and average co-owner percentages for all properties in the 'property_coownership' table where the co-owner percentage is greater than 60.", "context": "CREATE TABLE property_coownership (property_id INT, owner VARCHAR(255), percentage INT); INSERT INTO property_coownership (property_id, owner, percentage) VALUES (1, 'Mohammed', 70), (1, 'Fatima', 30), (2, 'Jamal', 65), (2, 'Aisha', 35), (3, 'Ali', 75), (3, 'Khadija', 25);", "reference_sql": "SELECT owner, AVG(percentage) FROM property_coownership WHERE percentage > 60 GROUP BY owner;", "generated_sql": "SELECT owner, AVG(percentage) AS avg_percentage\nFROM property_coownership\nWHERE percentage > 60\nGROUP BY owner;", "raw_model_output": "```sql\nSELECT owner, AVG(percentage) AS avg_percentage\nFROM property_coownership\nWHERE percentage > 60\nGROUP BY owner;\n```", "latency_sec": 0.5352671146392822, "total_duration_sec": 0.442023531, "load_duration_sec": 0.013538216, "tokens_prompt": 200, "prompt_eval_sec": 0.012119729, "tokens_completion": 32, "completion_eval_sec": 0.413365912, "tokens_total": 232, "tokens_per_sec": 433.4284577828872, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. The only difference is that the Generated SQL adds an explicit alias 'avg_percentage' for the AVG(percentage) column, while the Reference SQL omits the alias. Both queries select the same data: owner and average percentage where percentage > 60, grouped by owner. Column names in the result set do not affect semantic equivalence."}
{"example_id": 2357, "sql_complexity": "basic SQL", "prompt": "What is the total amount of climate finance invested in renewable energy projects by public and private sectors in Africa?", "context": "CREATE TABLE renewable_energy_projects (project_id INT, sector TEXT, investor_type TEXT, region TEXT, amount FLOAT); INSERT INTO renewable_energy_projects (project_id, sector, investor_type, region, amount) VALUES (1, 'Renewable Energy', 'Public', 'Africa', 5000000); INSERT INTO renewable_energy_projects (project_id, sector, investor_type, region, amount) VALUES (2, 'Renewable Energy', 'Private', 'Africa', 7000000);", "reference_sql": "SELECT SUM(amount) FROM renewable_energy_projects WHERE sector = 'Renewable Energy' AND region = 'Africa';", "generated_sql": "SELECT \n    investor_type, \n    SUM(amount) AS total_amount\nFROM \n    renewable_energy_projects\nWHERE \n    sector = 'Renewable Energy' AND \n    region = 'Africa'\nGROUP BY \n    investor_type;", "raw_model_output": "```sql\nSELECT \n    investor_type, \n    SUM(amount) AS total_amount\nFROM \n    renewable_energy_projects\nWHERE \n    sector = 'Renewable Energy' AND \n    region = 'Africa'\nGROUP BY \n    investor_type;\n```", "latency_sec": 0.9613058567047119, "total_duration_sec": 0.69766665, "load_duration_sec": 0.01305716, "tokens_prompt": 199, "prompt_eval_sec": 0.010551997, "tokens_completion": 53, "completion_eval_sec": 0.671888617, "tokens_total": 252, "tokens_per_sec": 262.143414858449, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns a single total sum of amounts for Renewable Energy projects in Africa, while the Generated SQL groups results by investor_type, returning separate sums for each investor type. The output structure and values differ."}
{"example_id": 1009, "sql_complexity": "multiple_joins", "prompt": "Find the number of IoT sensors installed in each farm that use Sprinkler irrigation.", "context": "CREATE TABLE IoT_Sensors (id INT, sensor_type VARCHAR(50), Farm_id INT); INSERT INTO IoT_Sensors (id, sensor_type, Farm_id) VALUES (1, 'Soil Moisture', 1), (2, 'Temperature', 1), (3, 'Humidity', 2); CREATE TABLE Irrigation (id INT, Farm_id INT, irrigation_type VARCHAR(50), duration INT); INSERT INTO Irrigation (id, Farm_id, irrigation_type, duration) VALUES (1, 1, 'Sprinkler', 30), (2, 2, 'Drip', 45);", "reference_sql": "SELECT f.id, COUNT(s.id) FROM Farmers f JOIN Irrigation i ON f.id = i.Farm_id JOIN IoT_Sensors s ON f.id = s.Farm_id WHERE i.irrigation_type = 'Sprinkler' GROUP BY f.id;", "generated_sql": "SELECT \n    s.Farm_id, \n    COUNT(s.id) AS num_sensors\nFROM \n    IoT_Sensors s\nJOIN \n    Irrigation i ON s.Farm_id = i.Farm_id\nWHERE \n    i.irrigation_type = 'Sprinkler'\nGROUP BY \n    s.Farm_id;", "raw_model_output": "```sql\nSELECT \n    s.Farm_id, \n    COUNT(s.id) AS num_sensors\nFROM \n    IoT_Sensors s\nJOIN \n    Irrigation i ON s.Farm_id = i.Farm_id\nWHERE \n    i.irrigation_type = 'Sprinkler'\nGROUP BY \n    s.Farm_id;\n```", "latency_sec": 1.036402940750122, "total_duration_sec": 0.940824801, "load_duration_sec": 0.019760435, "tokens_prompt": 219, "prompt_eval_sec": 0.014385838, "tokens_completion": 72, "completion_eval_sec": 0.903337373, "tokens_total": 291, "tokens_per_sec": 280.7788250671902, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a JOIN with the Farmers table, which has no data in the provided context, resulting in no output. The Generated SQL directly joins IoT_Sensors and Irrigation, producing results for Farm_id 1 (Sprinkler irrigation). Since the Farmers table's absence affects the Reference SQL's output, the queries are not equivalent."}
{"example_id": 4217, "sql_complexity": "subqueries", "prompt": "Show consumer preference data for foundations, excluding products from the USA.", "context": "CREATE TABLE cosmetics (product_id INT, product_name VARCHAR(100), product_type VARCHAR(50), is_cruelty_free BOOLEAN, consumer_preference_score INT); INSERT INTO cosmetics (product_id, product_name, product_type, is_cruelty_free, consumer_preference_score) VALUES (1, 'Lipstick A', 'Lipstick', TRUE, 80), (2, 'Foundation B', 'Foundation', FALSE, 90), (3, 'Mascara C', 'Mascara', TRUE, 85), (4, 'Eyeshadow D', 'Eyeshadow', TRUE, 70), (5, 'Blush E', 'Blush', FALSE, 95); CREATE TABLE ingredient_sourcing (ingredient_id INT, ingredient_name VARCHAR(100), sourcing_country VARCHAR(50), is_organic BOOLEAN); INSERT INTO ingredient_sourcing (ingredient_id, ingredient_name, sourcing_country, is_organic) VALUES (1, 'Rosehip Oil', 'Chile', TRUE), (2, 'Shea Butter', 'Ghana', TRUE), (3, 'Jojoba Oil', 'India', TRUE), (4, 'Coconut Oil', 'Philippines', FALSE), (5, 'Aloe Vera', 'USA', TRUE);", "reference_sql": "SELECT * FROM cosmetics WHERE product_type = 'Foundation' AND product_id NOT IN (SELECT cosmetics.product_id FROM cosmetics INNER JOIN ingredient_sourcing ON cosmetics.product_id = ingredient_sourcing.ingredient_id WHERE ingredient_sourcing.sourcing_country = 'USA');", "generated_sql": "SELECT cp.*\nFROM cosmetics cp\nJOIN ingredient_sourcing isrc ON cp.product_id = isrc.ingredient_id\nWHERE cp.product_type = 'Foundation' AND isrc.sourcing_country != 'USA';", "raw_model_output": "```sql\nSELECT cp.*\nFROM cosmetics cp\nJOIN ingredient_sourcing isrc ON cp.product_id = isrc.ingredient_id\nWHERE cp.product_type = 'Foundation' AND isrc.sourcing_country != 'USA';\n```", "latency_sec": 1.540266990661621, "total_duration_sec": 0.67248121, "load_duration_sec": 0.014160275, "tokens_prompt": 356, "prompt_eval_sec": 0.019330723, "tokens_completion": 47, "completion_eval_sec": 0.636245333, "tokens_total": 403, "tokens_per_sec": 261.64295050359516, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL excludes Foundation products that have any ingredient sourced from the USA (using NOT IN with a subquery). The Generated SQL selects Foundation products that have at least one ingredient not from the USA (using a JOIN with sourcing_country != 'USA'). These conditions are not equivalent: the Reference excludes products with any USA-sourced ingredients, while the Generated includes products with at least one non-USA ingredient. Additionally, the join condition in the Generated SQL (product_id = ingredient_id) may not logically connect the tables as intended, further diverging the results."}
{"example_id": 5620, "sql_complexity": "basic SQL", "prompt": "What is the recycling rate of plastic in the residential sector in the state of New York?", "context": "CREATE TABLE recycling_rates_city (sector VARCHAR(20), city VARCHAR(20), material VARCHAR(20), recycling_rate DECIMAL(5,2)); INSERT INTO recycling_rates_city (sector, city, material, recycling_rate) VALUES ('residential', 'New York City', 'plastic', 0.25), ('commercial', 'New York City', 'plastic', 0.30), ('residential', 'New York City', 'paper', 0.45), ('commercial', 'New York City', 'paper', 0.50), ('residential', 'Los Angeles', 'plastic', 0.20), ('commercial', 'Los Angeles', 'plastic', 0.35), ('residential', 'Los Angeles', 'paper', 0.40), ('commercial', 'Los Angeles', 'paper', 0.50);", "reference_sql": "SELECT recycling_rate FROM recycling_rates_city WHERE sector = 'residential' AND material = 'plastic' AND city = 'New York City';", "generated_sql": "SELECT recycling_rate \nFROM recycling_rates_city \nWHERE sector = 'residential' AND city LIKE 'New York%' AND material = 'plastic';", "raw_model_output": "```sql\nSELECT recycling_rate \nFROM recycling_rates_city \nWHERE sector = 'residential' AND city LIKE 'New York%' AND material = 'plastic';\n```", "latency_sec": 0.5867409706115723, "total_duration_sec": 0.503485172, "load_duration_sec": 0.020545492, "tokens_prompt": 276, "prompt_eval_sec": 0.014213395, "tokens_completion": 35, "completion_eval_sec": 0.466255156, "tokens_total": 311, "tokens_per_sec": 530.0465036144285, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select the recycling_rate where sector is 'residential', material is 'plastic', and city is 'New York City'. The Generated SQL uses 'city LIKE 'New York%'' which matches 'New York City' exactly (as per the provided data). Since the dataset only contains 'New York City' and 'Los Angeles', the LIKE condition behaves identically to the exact equality in this context."}
{"example_id": 3151, "sql_complexity": "basic SQL", "prompt": "List all biotech startups that received funding in 2022 and their respective funding amounts.", "context": "CREATE TABLE biotech_startups (name TEXT, funding FLOAT, date DATE); INSERT INTO biotech_startups (name, funding, date) VALUES ('StartupA', 3500000, '2022-02-28'); INSERT INTO biotech_startups (name, funding, date) VALUES ('StartupB', 4500000, '2022-07-12');", "reference_sql": "SELECT name, funding FROM biotech_startups WHERE date BETWEEN '2022-01-01' AND '2022-12-31';", "generated_sql": "SELECT name, funding\nFROM biotech_startups\nWHERE date >= '2022-01-01' AND date < '2023-01-01';", "raw_model_output": "```sql\nSELECT name, funding\nFROM biotech_startups\nWHERE date >= '2022-01-01' AND date < '2023-01-01';\n```", "latency_sec": 0.643049955368042, "total_duration_sec": 0.599390886, "load_duration_sec": 0.013311922, "tokens_prompt": 183, "prompt_eval_sec": 0.009554141, "tokens_completion": 46, "completion_eval_sec": 0.57449644, "tokens_total": 229, "tokens_per_sec": 356.1154123227247, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select startups with dates in 2022. The reference uses BETWEEN '2022-01-01' AND '2022-12-31' (inclusive), while the generated query uses date >= '2022-01-01' AND date < '2023-01-01' (which effectively includes the same range since '2023-01-01' is the first day of the next year). The date ranges are semantically identical."}
{"example_id": 2136, "sql_complexity": "window functions", "prompt": "What is the total military equipment sales revenue for each sales representative by fiscal year?", "context": "CREATE TABLE SalesReps (SalesRepID INT, SalesRepName VARCHAR(50), FiscalYear INT, Revenue DECIMAL(10,2)); INSERT INTO SalesReps (SalesRepID, SalesRepName, FiscalYear, Revenue) VALUES (1, 'John Doe', 2020, 150000.00), (2, 'Jane Smith', 2020, 200000.00), (1, 'John Doe', 2021, 180000.00), (2, 'Jane Smith', 2021, 250000.00);", "reference_sql": "SELECT SalesRepName, FiscalYear, SUM(Revenue) OVER (PARTITION BY SalesRepName ORDER BY FiscalYear) AS TotalRevenue FROM SalesReps;", "generated_sql": "SELECT SalesRepName, FiscalYear, SUM(Revenue) AS TotalRevenue\nFROM SalesReps\nGROUP BY SalesRepName, FiscalYear;", "raw_model_output": "```sql\nSELECT SalesRepName, FiscalYear, SUM(Revenue) AS TotalRevenue\nFROM SalesReps\nGROUP BY SalesRepName, FiscalYear;\n```", "latency_sec": 0.5098779201507568, "total_duration_sec": 0.484257177, "load_duration_sec": 0.015761771, "tokens_prompt": 233, "prompt_eval_sec": 0.01322468, "tokens_completion": 35, "completion_eval_sec": 0.453104213, "tokens_total": 268, "tokens_per_sec": 525.6160139681275, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates a running total (cumulative sum) of Revenue for each SalesRepName ordered by FiscalYear using a window function. The Generated SQL aggregates Revenue by SalesRepName and FiscalYear, returning only the individual year's Revenue instead of a cumulative sum. For example, for John Doe in 2021, Reference would show 150000+180000=330000 while Generated would show 180000. The results differ in both value and structure."}
{"example_id": 5452, "sql_complexity": "basic SQL", "prompt": "What is the name of the farms with a size greater than 150 acres located in 'Texas'?", "context": "CREATE TABLE farms (id INT PRIMARY KEY, name VARCHAR(50), size INT, location VARCHAR(50)); INSERT INTO farms (id, name, size, location) VALUES (1, 'Smith Farms', 200, 'Texas'), (2, 'Johnson Farms', 100, 'California');", "reference_sql": "SELECT name FROM farms WHERE size > 150 AND location = 'Texas'", "generated_sql": "SELECT name FROM farms WHERE size > 150 AND location = 'Texas';", "raw_model_output": "```sql\nSELECT name FROM farms WHERE size > 150 AND location = 'Texas';\n```", "latency_sec": 0.40886902809143066, "total_duration_sec": 0.30673879, "load_duration_sec": 0.013507971, "tokens_prompt": 159, "prompt_eval_sec": 0.008701344, "tokens_completion": 22, "completion_eval_sec": 0.28199576, "tokens_total": 181, "tokens_per_sec": 442.6845458187287, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. The only difference is the presence of a semicolon at the end of the generated SQL, which does not affect the query's semantics as semicolons are statement terminators in SQL and not part of the query logic."}
{"example_id": 5152, "sql_complexity": "aggregation", "prompt": "How many international tourists visited Portugal in 2020, broken down by continent?", "context": "CREATE TABLE international_tourists(tourist_id INT, country TEXT, arrival_year INT, continent TEXT);INSERT INTO international_tourists (tourist_id, country, arrival_year, continent) VALUES (1, 'Spain', 2020, 'Europe'), (2, 'France', 2020, 'Europe'), (3, 'Brazil', 2020, 'South America'), (4, 'United States', 2020, 'North America'), (5, 'China', 2020, 'Asia');", "reference_sql": "SELECT continent, COUNT(*) FROM international_tourists WHERE arrival_year = 2020 GROUP BY continent;", "generated_sql": "SELECT COUNT(*), continent\nFROM international_tourists\nWHERE country = 'Portugal' AND arrival_year = 2020\nGROUP BY continent;", "raw_model_output": "```sql\nSELECT COUNT(*), continent\nFROM international_tourists\nWHERE country = 'Portugal' AND arrival_year = 2020\nGROUP BY continent;\n```\n\nNote: The provided schema does not include any records for Portugal. If you intended to ask about a different country, please adjust the `country` value accordingly.", "latency_sec": 1.0131869316101074, "total_duration_sec": 0.918598866, "load_duration_sec": 0.016026338, "tokens_prompt": 206, "prompt_eval_sec": 0.012339183, "tokens_completion": 71, "completion_eval_sec": 0.886917859, "tokens_total": 277, "tokens_per_sec": 273.39476197132257, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query counts all tourists from any country in 2020 grouped by continent, while the generated query only counts tourists from 'Portugal' (which doesn't exist in the data) in 2020. The generated query's WHERE clause on country='Portugal' makes it return zero rows, whereas the reference query returns counts for multiple continents. The conditions and resulting datasets differ significantly."}
{"example_id": 2477, "sql_complexity": "set operations", "prompt": "What is the carbon price in Europe and Australia for the last quarter of 2020?", "context": "CREATE TABLE CarbonPrices (Country TEXT, Year INT, Quarter INT, CarbonPrice NUMBER); INSERT INTO CarbonPrices (Country, Year, Quarter, CarbonPrice) VALUES ('Europe', 2020, 4, 25), ('Australia', 2020, 4, 15); CREATE TABLE CarbonTaxes (Country TEXT, Year INT, Quarter INT, CarbonPrice NUMBER); INSERT INTO CarbonTaxes (Country, Year, Quarter, CarbonPrice) VALUES ('Europe', 2019, 4, 20), ('Australia', 2019, 4, 10);", "reference_sql": "SELECT Context.Country, Context.CarbonPrice FROM ( SELECT * FROM CarbonPrices WHERE CarbonPrices.Country IN ('Europe', 'Australia') AND CarbonPrices.Year = 2020 AND CarbonPrices.Quarter = 4 UNION SELECT * FROM CarbonTaxes WHERE CarbonTaxes.Country IN ('Europe', 'Australia') AND CarbonTaxes.Year = 2020 AND CarbonTaxes.Quarter = 4 ) AS Context;", "generated_sql": "SELECT \n    Country, \n    CarbonPrice\nFROM \n    CarbonPrices\nWHERE \n    Year = 2020 AND Quarter = 4 AND Country IN ('Europe', 'Australia')\nUNION ALL\nSELECT \n    Country, \n    CarbonPrice\nFROM \n    CarbonTaxes\nWHERE \n    Year = 2020 AND Quarter = 4 AND Country IN ('Europe', 'Australia');", "raw_model_output": "```sql\nSELECT \n    Country, \n    CarbonPrice\nFROM \n    CarbonPrices\nWHERE \n    Year = 2020 AND Quarter = 4 AND Country IN ('Europe', 'Australia')\nUNION ALL\nSELECT \n    Country, \n    CarbonPrice\nFROM \n    CarbonTaxes\nWHERE \n    Year = 2020 AND Quarter = 4 AND Country IN ('Europe', 'Australia');\n```", "latency_sec": 1.4492428302764893, "total_duration_sec": 1.145086754, "load_duration_sec": 0.013940073, "tokens_prompt": 221, "prompt_eval_sec": 0.011821306, "tokens_completion": 90, "completion_eval_sec": 1.11697357, "tokens_total": 311, "tokens_per_sec": 214.59481703329652, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their use of UNION vs. UNION ALL. The Reference SQL uses UNION, which removes duplicate rows, while the Generated SQL uses UNION ALL, which retains all rows. Although the specific data provided does not contain duplicates, the semantic equivalence depends on the query logic. Since UNION and UNION ALL behave differently in general cases (especially when duplicates exist), the queries are not semantically equivalent."}
{"example_id": 4573, "sql_complexity": "subqueries", "prompt": "Find the names of all the indigenous communities in the 'Arctic_Communities' table that have a population size greater than the average population size in the 'Antarctic_Communities' table.", "context": "CREATE TABLE Arctic_Communities (name TEXT, population INTEGER); CREATE TABLE Antarctic_Communities (name TEXT, population INTEGER);", "reference_sql": "SELECT name FROM Arctic_Communities WHERE Arctic_Communities.population > (SELECT AVG(population) FROM Antarctic_Communities)", "generated_sql": "SELECT name \nFROM Arctic_Communities \nWHERE population > (SELECT AVG(population) FROM Antarctic_Communities);", "raw_model_output": "```sql\nSELECT name \nFROM Arctic_Communities \nWHERE population > (SELECT AVG(population) FROM Antarctic_Communities);\n```", "latency_sec": 0.3833918571472168, "total_duration_sec": 0.358161009, "load_duration_sec": 0.014081235, "tokens_prompt": 132, "prompt_eval_sec": 0.006605137, "tokens_completion": 27, "completion_eval_sec": 0.335369221, "tokens_total": 159, "tokens_per_sec": 414.7192931615821, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select names from Arctic_Communities where population exceeds the average population of Antarctic_Communities. The generated query omits the table name in the WHERE clause (population > ...), but since the column exists only in Arctic_Communities, it's unambiguous and semantically equivalent to the reference query."}
{"example_id": 3596, "sql_complexity": "window functions", "prompt": "What is the total revenue for each game in the \"Gaming\" category?", "context": "CREATE TABLE Games (GameID int, GameName varchar(50), Category varchar(50), Revenue decimal(10,2));", "reference_sql": "SELECT Category, SUM(Revenue) OVER(PARTITION BY Category) as TotalRevenue FROM Games;", "generated_sql": "SELECT GameName, SUMRevenue = SUM(Revenue)\nFROM Games\nWHERE Category = 'Gaming'\nGROUP BY GameName;", "raw_model_output": "```sql\nSELECT GameName, SUMRevenue = SUM(Revenue)\nFROM Games\nWHERE Category = 'Gaming'\nGROUP BY GameName;\n```", "latency_sec": 0.5011560916900635, "total_duration_sec": 0.406182003, "load_duration_sec": 0.014261089, "tokens_prompt": 114, "prompt_eval_sec": 0.007465542, "tokens_completion": 31, "completion_eval_sec": 0.381855445, "tokens_total": 145, "tokens_per_sec": 289.3310136389088, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates total revenue per category using a window function, returning Category and TotalRevenue for all games. The generated query filters to only 'Gaming' category, groups by GameName, and returns individual game names with their revenue sums (possibly aggregating multiple entries per game). The output structure, filtering, and aggregation logic differ significantly."}
{"example_id": 5039, "sql_complexity": "subqueries", "prompt": "What is the total number of community policing events in 'City Park' in 2021?", "context": "CREATE TABLE locations (id INT, name VARCHAR(255)); CREATE TABLE community_policing (id INT, location_id INT, year INT, events INT); INSERT INTO locations (id, name) VALUES (1, 'City Park'); INSERT INTO community_policing (id, location_id, year, events) VALUES (1, 1, 2021, 5);", "reference_sql": "SELECT SUM(events) FROM community_policing WHERE location_id = (SELECT id FROM locations WHERE name = 'City Park') AND year = 2021;", "generated_sql": "SELECT SUM(events) AS total_events\nFROM community_policing cp\nJOIN locations l ON cp.location_id = l.id\nWHERE l.name = 'City Park' AND cp.year = 2021;", "raw_model_output": "```sql\nSELECT SUM(events) AS total_events\nFROM community_policing cp\nJOIN locations l ON cp.location_id = l.id\nWHERE l.name = 'City Park' AND cp.year = 2021;\n```", "latency_sec": 0.7296667098999023, "total_duration_sec": 0.634512134, "load_duration_sec": 0.013558562, "tokens_prompt": 172, "prompt_eval_sec": 0.009520475, "tokens_completion": 49, "completion_eval_sec": 0.609345052, "tokens_total": 221, "tokens_per_sec": 302.87800855039336, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of events for the location named 'City Park' in 2021. The Reference SQL uses a subquery to get the location_id, while the Generated SQL uses a JOIN to combine the tables. Since the subquery in the Reference returns a single value (as per the sample data where 'City Park' is unique), both approaches yield the same result. The logical condition (location name and year) is preserved in both queries."}
{"example_id": 2724, "sql_complexity": "basic SQL", "prompt": "What is the earliest installation date for solar panels in Italy?", "context": "CREATE TABLE solar_panels_italy (id INT, installation_date DATE); INSERT INTO solar_panels_italy (id, installation_date) VALUES (1, '2018-01-01'), (2, '2019-01-01'), (3, '2020-01-01');", "reference_sql": "SELECT MIN(installation_date) as earliest_date FROM solar_panels_italy;", "generated_sql": "SELECT MIN(installation_date) AS earliest_installation_date\nFROM solar_panels_italy;", "raw_model_output": "```sql\nSELECT MIN(installation_date) AS earliest_installation_date\nFROM solar_panels_italy;\n```", "latency_sec": 0.3648371696472168, "total_duration_sec": 0.354516583, "load_duration_sec": 0.015968425, "tokens_prompt": 157, "prompt_eval_sec": 0.008224111, "tokens_completion": 26, "completion_eval_sec": 0.328196696, "tokens_total": 183, "tokens_per_sec": 501.59362922630334, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the minimum installation_date from the same table. The only difference is the column alias name ('earliest_date' vs 'earliest_installation_date'), which does not affect the semantic result as aliases are metadata and do not change the computed values."}
{"example_id": 2200, "sql_complexity": "single join", "prompt": "Which diversity programs are currently being participated in by employees in the HR department?", "context": "CREATE TABLE Employees (Employee_ID INT, First_Name VARCHAR(20), Last_Name VARCHAR(20), Department VARCHAR(20), Salary DECIMAL(10,2), Date_Hired DATE); CREATE TABLE Diversity_Programs (Program_ID INT, Program_Name VARCHAR(50), Participant_ID INT, Date_Started DATE, Date_Ended DATE);", "reference_sql": "SELECT dp.Program_Name FROM Diversity_Programs dp JOIN Employees e ON dp.Participant_ID = e.Employee_ID WHERE e.Department = 'HR' AND dp.Date_Ended IS NULL;", "generated_sql": "SELECT dp.Program_Name\nFROM Diversity_Programs dp\nJOIN Employees e ON dp.Participant_ID = e.Employee_ID\nWHERE e.Department = 'HR' AND dp.Date_Ended IS NULL;", "raw_model_output": "```sql\nSELECT dp.Program_Name\nFROM Diversity_Programs dp\nJOIN Employees e ON dp.Participant_ID = e.Employee_ID\nWHERE e.Department = 'HR' AND dp.Date_Ended IS NULL;\n```", "latency_sec": 0.6534481048583984, "total_duration_sec": 0.582012692, "load_duration_sec": 0.014989561, "tokens_prompt": 157, "prompt_eval_sec": 0.008890265, "tokens_completion": 44, "completion_eval_sec": 0.555179189, "tokens_total": 201, "tokens_per_sec": 307.5990250879318, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure, table aliases, join conditions, and WHERE clause filters. Both select Program_Name from Diversity_Programs joined with Employees on Participant_ID = Employee_ID, filtering for HR department and unended programs. The only differences are formatting (line breaks/indentation) which do not affect semantic meaning."}
{"example_id": 4359, "sql_complexity": "window functions", "prompt": "Which destinations have the least hotel awards?", "context": "CREATE TABLE Destinations (destination_id INT, destination_name TEXT, country TEXT, awards INT); INSERT INTO Destinations (destination_id, destination_name, country, awards) VALUES (1, 'City A', 'Germany', 3), (2, 'City B', 'Switzerland', 5), (3, 'City C', 'Norway', 2);", "reference_sql": "SELECT destination_name, country, awards, RANK() OVER (PARTITION BY country ORDER BY awards ASC) AS rank FROM Destinations;", "generated_sql": "SELECT destination_name, country, awards \nFROM Destinations \nWHERE awards = (SELECT MIN(awards) FROM Destinations);", "raw_model_output": "```sql\nSELECT destination_name, country, awards \nFROM Destinations \nWHERE awards = (SELECT MIN(awards) FROM Destinations);\n```", "latency_sec": 0.7342510223388672, "total_duration_sec": 0.412143606, "load_duration_sec": 0.013725063, "tokens_prompt": 153, "prompt_eval_sec": 0.007312536, "tokens_completion": 31, "completion_eval_sec": 0.389096969, "tokens_total": 184, "tokens_per_sec": 250.59549718281687, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates a rank within each country partition based on awards, while the Generated SQL selects only destinations with the absolute minimum awards value from the entire table. The Reference SQL returns all rows with per-country ranking, whereas the Generated SQL returns only rows matching the global minimum awards value (2 in this case)."}
{"example_id": 1373, "sql_complexity": "subqueries", "prompt": "What is the total value of military equipment sales to Africa in the last 12 months?", "context": "CREATE TABLE Military_Equipment_Sales(sale_id INT, sale_date DATE, equipment_type VARCHAR(50), country VARCHAR(50), sale_value DECIMAL(10,2));", "reference_sql": "SELECT SUM(sale_value) FROM Military_Equipment_Sales WHERE country IN (SELECT country FROM World_Countries WHERE continent = 'Africa') AND sale_date >= DATE_SUB(CURRENT_DATE, INTERVAL 12 MONTH);", "generated_sql": "SELECT SUM(sale_value) AS total_sales_value\nFROM Military_Equipment_Sales\nWHERE country = 'Africa' AND sale_date >= DATEADD(year, -1, GETDATE());", "raw_model_output": "```sql\nSELECT SUM(sale_value) AS total_sales_value\nFROM Military_Equipment_Sales\nWHERE country = 'Africa' AND sale_date >= DATEADD(year, -1, GETDATE());\n```", "latency_sec": 0.7551548480987549, "total_duration_sec": 0.554268003, "load_duration_sec": 0.013312603, "tokens_prompt": 127, "prompt_eval_sec": 0.007905303, "tokens_completion": 43, "completion_eval_sec": 0.530600008, "tokens_total": 170, "tokens_per_sec": 225.11939164266394, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their country filtering logic. The Reference SQL uses a subquery to select countries from World_Countries where continent = 'Africa', while the Generated SQL directly checks if country = 'Africa'. This means the Reference SQL includes all countries listed in World_Countries for Africa, whereas the Generated SQL only considers the exact country name 'Africa'. Additionally, the date functions (DATE_SUB vs DATEADD) are functionally equivalent but not identical in syntax."}
{"example_id": 904, "sql_complexity": "basic SQL", "prompt": "What is the minimum Shariah-compliant loan amount issued in the last quarter of 2021?", "context": "CREATE TABLE loans (id INT, amount DECIMAL, date DATE, loan_type VARCHAR); INSERT INTO loans (id, amount, date, loan_type) VALUES (1, 5000, '2021-09-05', 'Shariah-compliant'), (2, 7000, '2021-10-07', 'socially responsible'), (3, 9000, '2021-11-03', 'Shariah-compliant'), (4, 11000, '2021-12-31', 'Shariah-compliant');", "reference_sql": "SELECT MIN(amount) FROM loans WHERE EXTRACT(YEAR FROM date) = 2021 AND EXTRACT(QUARTER FROM date) = 4 AND loan_type = 'Shariah-compliant';", "generated_sql": "SELECT MIN(amount) AS min_shariah_compliant_loan_amount\nFROM loans\nWHERE loan_type = 'Shariah-compliant' AND date >= '2021-10-01' AND date <= '2021-12-31';", "raw_model_output": "```sql\nSELECT MIN(amount) AS min_shariah_compliant_loan_amount\nFROM loans\nWHERE loan_type = 'Shariah-compliant' AND date >= '2021-10-01' AND date <= '2021-12-31';\n```", "latency_sec": 0.8991820812225342, "total_duration_sec": 0.834872502, "load_duration_sec": 0.024759572, "tokens_prompt": 234, "prompt_eval_sec": 0.011185646, "tokens_completion": 63, "completion_eval_sec": 0.796679901, "tokens_total": 297, "tokens_per_sec": 330.30017635159805, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter for 'Shariah-compliant' loans in the fourth quarter of 2021. The Reference SQL uses EXTRACT(QUARTER) = 4 (which corresponds to October-December) and EXTRACT(YEAR) = 2021. The Generated SQL uses a date range from '2021-10-01' to '2021-12-31', which covers the same period. Both will return the minimum amount from loans 3 (9000) and 4 (11000), resulting in 9000."}
{"example_id": 3299, "sql_complexity": "set operations", "prompt": "How many schools and hospitals are there in Colombia and which ones need repairs?", "context": "CREATE TABLE schools (id INT, country VARCHAR(20), name VARCHAR(50), needs_repair BOOLEAN); CREATE TABLE hospitals (id INT, country VARCHAR(20), name VARCHAR(50), needs_repair BOOLEAN);", "reference_sql": "SELECT 'Schools' as facility_type, COUNT(*) as total, SUM(needs_repair) as repairs_needed FROM schools WHERE country = 'Colombia' UNION ALL SELECT 'Hospitals' as facility_type, COUNT(*) as total, SUM(needs_repair) as repairs_needed FROM hospitals WHERE country = 'Colombia';", "generated_sql": "SELECT \n    'School' AS facility_type,\n    COUNT(*) AS count,\n    GROUP_CONCAT(name) AS names\nFROM \n    schools\nWHERE \n    country = 'Colombia' AND needs_repair = TRUE\nUNION ALL\nSELECT \n    'Hospital' AS facility_type,\n    COUNT(*) AS count,\n    GROUP_CONCAT(name) AS names\nFROM \n    hospitals\nWHERE \n    country = 'Colombia' AND needs_repair = TRUE;", "raw_model_output": "```sql\nSELECT \n    'School' AS facility_type,\n    COUNT(*) AS count,\n    GROUP_CONCAT(name) AS names\nFROM \n    schools\nWHERE \n    country = 'Colombia' AND needs_repair = TRUE\nUNION ALL\nSELECT \n    'Hospital' AS facility_type,\n    COUNT(*) AS count,\n    GROUP_CONCAT(name) AS names\nFROM \n    hospitals\nWHERE \n    country = 'Colombia' AND needs_repair = TRUE;\n```", "latency_sec": 1.4959261417388916, "total_duration_sec": 1.285109805, "load_duration_sec": 0.020268513, "tokens_prompt": 132, "prompt_eval_sec": 0.007406153, "tokens_completion": 103, "completion_eval_sec": 1.255402288, "tokens_total": 235, "tokens_per_sec": 157.09331727222292, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in both structure and logic. The reference query counts all facilities and sums repair flags for Colombia, while the generated query filters only facilities needing repair (needs_repair = TRUE) and concatenates names instead of summing repairs. Column names and aggregated data types also differ (e.g., 'total' vs 'count', 'repairs_needed' vs 'names')."}
{"example_id": 907, "sql_complexity": "set operations", "prompt": "What is the total quantity of items with type 'E' or type 'F' in warehouse O and warehouse P?", "context": "CREATE TABLE warehouse_o(item_id INT, item_type VARCHAR(10), quantity INT);CREATE TABLE warehouse_p(item_id INT, item_type VARCHAR(10), quantity INT);INSERT INTO warehouse_o(item_id, item_type, quantity) VALUES (1, 'E', 200), (2, 'F', 300), (3, 'E', 50), (4, 'F', 400);INSERT INTO warehouse_p(item_id, item_type, quantity) VALUES (1, 'E', 150), (2, 'F', 250), (3, 'E', 40), (4, 'F', 350);", "reference_sql": "SELECT quantity FROM warehouse_o WHERE item_type IN ('E', 'F') UNION ALL SELECT quantity FROM warehouse_p WHERE item_type IN ('E', 'F');", "generated_sql": "SELECT \n    SUM(warehouse_o.quantity + warehouse_p.quantity) AS total_quantity\nFROM \n    warehouse_o\nJOIN \n    warehouse_p ON warehouse_o.item_id = warehouse_p.item_id\nWHERE \n    warehouse_o.item_type IN ('E', 'F') AND \n    warehouse_p.item_type IN ('E', 'F');", "raw_model_output": "```sql\nSELECT \n    SUM(warehouse_o.quantity + warehouse_p.quantity) AS total_quantity\nFROM \n    warehouse_o\nJOIN \n    warehouse_p ON warehouse_o.item_id = warehouse_p.item_id\nWHERE \n    warehouse_o.item_type IN ('E', 'F') AND \n    warehouse_p.item_type IN ('E', 'F');\n```", "latency_sec": 1.0327479839324951, "total_duration_sec": 0.948044269, "load_duration_sec": 0.014792971, "tokens_prompt": 241, "prompt_eval_sec": 0.013321232, "tokens_completion": 72, "completion_eval_sec": 0.917865808, "tokens_total": 313, "tokens_per_sec": 303.07490778937125, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns a list of individual quantities from both tables (8 rows), while the Generated SQL calculates a single summed value by joining tables on item_id and adding quantities. The first query's output structure differs fundamentally from the second's single-row result, even if their total sums might coincidentally match."}
{"example_id": 1400, "sql_complexity": "single join", "prompt": "What is the maximum co-ownership duration for properties in the neighborhood of 'Chinatown' in San Francisco?'", "context": "CREATE TABLE sf_neighborhoods (neighborhood_id INT, name VARCHAR(255), city VARCHAR(255)); INSERT INTO sf_neighborhoods (neighborhood_id, name, city) VALUES (1, 'Chinatown', 'San Francisco'); CREATE TABLE co_ownership (co_ownership_id INT, property_id INT, co_owner_id INT, start_date DATE, end_date DATE); INSERT INTO co_ownership (co_ownership_id, property_id, co_owner_id, start_date, end_date) VALUES (1, 1, 2, '2010-01-01', '2020-01-01'), (2, 2, 3, '2015-01-01', '2022-01-01'); CREATE TABLE properties (property_id INT, city VARCHAR(255)); INSERT INTO properties (property_id, city) VALUES (1, 'San Francisco'), (2, 'San Francisco');", "reference_sql": "SELECT MAX(DATEDIFF(end_date, start_date)) as max_duration FROM co_ownership JOIN properties ON co_ownership.property_id = properties.property_id WHERE properties.city = 'San Francisco' AND name = 'Chinatown';", "generated_sql": "SELECT MAX(T2.end_date - T2.start_date) AS max_co_ownership_duration\nFROM sf_neighborhoods AS T1\nJOIN co_ownership AS T2 ON T1.property_id = T2.property_id\nWHERE T1.name = 'Chinatown' AND T1.city = 'San Francisco';", "raw_model_output": "```sql\nSELECT MAX(T2.end_date - T2.start_date) AS max_co_ownership_duration\nFROM sf_neighborhoods AS T1\nJOIN co_ownership AS T2 ON T1.property_id = T2.property_id\nWHERE T1.name = 'Chinatown' AND T1.city = 'San Francisco';\n```", "latency_sec": 1.0652639865875244, "total_duration_sec": 0.975825097, "load_duration_sec": 0.022569452, "tokens_prompt": 305, "prompt_eval_sec": 0.019249319, "tokens_completion": 70, "completion_eval_sec": 0.92694386, "tokens_total": 375, "tokens_per_sec": 352.0254178509105, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references a 'name' column in the WHERE clause, but the tables involved in the JOIN are co_ownership and properties. The 'name' column exists in sf_neighborhoods, which is not joined in the Reference SQL, making it invalid. The Generated SQL correctly joins sf_neighborhoods and uses its 'name' and 'city' columns. The Reference SQL would throw an error due to the missing join and invalid column reference."}
{"example_id": 5248, "sql_complexity": "window functions", "prompt": "Find the top 5 games by rating", "context": "CREATE TABLE games (game_id INT PRIMARY KEY, name VARCHAR(50), genre VARCHAR(50), rating DECIMAL(3,2));", "reference_sql": "SELECT * FROM (SELECT name, rating, ROW_NUMBER() OVER (ORDER BY rating DESC) as rn FROM games) t WHERE rn <= 5;", "generated_sql": "SELECT game_id, name, genre, rating\nFROM games\nORDER BY rating DESC\nLIMIT 5;", "raw_model_output": "```sql\nSELECT game_id, name, genre, rating\nFROM games\nORDER BY rating DESC\nLIMIT 5;\n```", "latency_sec": 0.6507530212402344, "total_duration_sec": 0.350310212, "load_duration_sec": 0.016943175, "tokens_prompt": 108, "prompt_eval_sec": 0.005842282, "tokens_completion": 27, "completion_eval_sec": 0.324740276, "tokens_total": 135, "tokens_per_sec": 207.4519757783236, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL returns only 'name', 'rating', and 'rn' columns with a row number, while the Generated SQL returns all columns (game_id, name, genre, rating) and uses LIMIT instead of ROW_NUMBER(). The column sets differ, and the Generated SQL includes additional fields (game_id, genre) not present in the Reference SQL."}
{"example_id": 778, "sql_complexity": "single join", "prompt": "What is the maximum property price in wheelchair-accessible neighborhoods in Singapore?", "context": "CREATE TABLE Singapore_Neighborhoods (Neighborhood_Name TEXT, Wheelchair_Accessibility BOOLEAN); INSERT INTO Singapore_Neighborhoods (Neighborhood_Name, Wheelchair_Accessibility) VALUES ('Orchard', true), ('Marina Bay', true), ('Chinatown', false), ('Little India', false), ('Bugis', true); CREATE TABLE Singapore_Properties (Neighborhood_Name TEXT, Property_Price INTEGER); INSERT INTO Singapore_Properties (Neighborhood_Name, Property_Price) VALUES ('Orchard', 2000000), ('Marina Bay', 3000000), ('Chinatown', 1500000), ('Little India', 1200000), ('Bugis', 1800000);", "reference_sql": "SELECT MAX(Singapore_Properties.Property_Price) FROM Singapore_Properties INNER JOIN Singapore_Neighborhoods ON Singapore_Properties.Neighborhood_Name = Singapore_Neighborhoods.Neighborhood_Name WHERE Singapore_Neighborhoods.Wheelchair_Accessibility = true;", "generated_sql": "SELECT MAX(Property_Price) AS Max_Property_Price\nFROM Singapore_Properties SP\nJOIN Singapore_Neighborhoods SN ON SP.Neighborhood_Name = SN.Neighborhood_Name\nWHERE SN.Wheelchair_Accessibility = true;", "raw_model_output": "```sql\nSELECT MAX(Property_Price) AS Max_Property_Price\nFROM Singapore_Properties SP\nJOIN Singapore_Neighborhoods SN ON SP.Neighborhood_Name = SN.Neighborhood_Name\nWHERE SN.Wheelchair_Accessibility = true;\n```", "latency_sec": 0.6878757476806641, "total_duration_sec": 0.682412308, "load_duration_sec": 0.013897473, "tokens_prompt": 252, "prompt_eval_sec": 0.01220038, "tokens_completion": 52, "completion_eval_sec": 0.654051918, "tokens_total": 304, "tokens_per_sec": 441.94027922194954, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between Singapore_Properties and Singapore_Neighborhoods on Neighborhood_Name, filter for wheelchair-accessible neighborhoods, and select the maximum property price. The only difference is the use of table aliases (SP/SN) in the generated query, which does not affect semantic meaning."}
{"example_id": 3859, "sql_complexity": "aggregation", "prompt": "What is the total number of mental health parity violations by month and year?", "context": "CREATE TABLE mental_health_parity_reports (report_id INT, violation_date DATE); INSERT INTO mental_health_parity_reports (report_id, violation_date) VALUES (1, '2022-01-01'), (2, '2022-02-15'), (3, '2022-03-05'), (4, '2022-04-20'), (5, '2021-06-12'), (6, '2021-07-28');", "reference_sql": "SELECT EXTRACT(MONTH FROM violation_date) AS month, EXTRACT(YEAR FROM violation_date) AS year, COUNT(*) FROM mental_health_parity_reports GROUP BY month, year;", "generated_sql": "SELECT \n    YEAR(violation_date) AS violation_year,\n    MONTH(violation_date) AS violation_month,\n    COUNT(*) AS num_violations\nFROM \n    mental_health_parity_reports\nGROUP BY \n    YEAR(violation_date), \n    MONTH(violation_date);", "raw_model_output": "```sql\nSELECT \n    YEAR(violation_date) AS violation_year,\n    MONTH(violation_date) AS violation_month,\n    COUNT(*) AS num_violations\nFROM \n    mental_health_parity_reports\nGROUP BY \n    YEAR(violation_date), \n    MONTH(violation_date);\n```", "latency_sec": 0.8349711894989014, "total_duration_sec": 0.830136429, "load_duration_sec": 0.013792169, "tokens_prompt": 205, "prompt_eval_sec": 0.010760323, "tokens_completion": 65, "completion_eval_sec": 0.803543645, "tokens_total": 270, "tokens_per_sec": 323.36445064893496, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries group records by the year and month of the violation_date, then count the number of violations per group. The Reference SQL uses EXTRACT(MONTH/YEAR) while the Generated SQL uses MONTH() and YEAR() functions, which are semantically equivalent for this purpose. The column aliases differ but do not affect the result's content."}
{"example_id": 3551, "sql_complexity": "multiple_joins", "prompt": "List all artists who have performed in New York and Chicago, along with their highest-earning performance.", "context": "CREATE TABLE artist_events (artist_id INT, event_id INT, earnings DECIMAL(5,2)); CREATE TABLE artists (id INT, name VARCHAR(50)); CREATE TABLE events (id INT, city VARCHAR(20));", "reference_sql": "SELECT artists.name, MAX(artist_events.earnings) FROM artists INNER JOIN artist_events ON artists.id = artist_events.artist_id INNER JOIN events ON artist_events.event_id = events.id WHERE city IN ('New York', 'Chicago') GROUP BY artists.name;", "generated_sql": "SELECT \n    a.name,\n    ae.event_id,\n    ae.earnings\nFROM \n    artists a\nJOIN \n    artist_events ae ON a.id = ae.artist_id\nJOIN \n    events e ON ae.event_id = e.id\nWHERE \n    e.city IN ('New York', 'Chicago')\nGROUP BY \n    a.name, ae.event_id\nHAVING \n    MAX(ae.earnings) OVER (PARTITION BY a.name) = ae.earnings;", "raw_model_output": "```sql\nSELECT \n    a.name,\n    ae.event_id,\n    ae.earnings\nFROM \n    artists a\nJOIN \n    artist_events ae ON a.id = ae.artist_id\nJOIN \n    events e ON ae.event_id = e.id\nWHERE \n    e.city IN ('New York', 'Chicago')\nGROUP BY \n    a.name, ae.event_id\nHAVING \n    MAX(ae.earnings) OVER (PARTITION BY a.name) = ae.earnings;\n```", "latency_sec": 1.2767081260681152, "total_duration_sec": 1.272633285, "load_duration_sec": 0.014309979, "tokens_prompt": 136, "prompt_eval_sec": 0.008656345, "tokens_completion": 104, "completion_eval_sec": 1.247079495, "tokens_total": 240, "tokens_per_sec": 187.98345142450785, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query returns each artist's maximum earnings (one row per artist), while the generated query returns individual event records where earnings equal the artist's maximum (potentially multiple rows per artist). The generated query also includes event_id in the output and uses a window function in the HAVING clause, which changes the semantics compared to the reference's GROUP BY and aggregate function."}
{"example_id": 5168, "sql_complexity": "aggregation", "prompt": "Get the number of renewable energy projects in Australia for each project type.", "context": "CREATE TABLE renewable_projects (id INT PRIMARY KEY, project_name VARCHAR(255), project_location VARCHAR(255), project_type VARCHAR(255), capacity_mw FLOAT);", "reference_sql": "SELECT project_type, COUNT(*) FROM renewable_projects WHERE project_location = 'Australia' GROUP BY project_type;", "generated_sql": "SELECT project_type, COUNT(*) AS num_projects\nFROM renewable_projects\nWHERE project_location = 'Australia'\nGROUP BY project_type;", "raw_model_output": "```sql\nSELECT project_type, COUNT(*) AS num_projects\nFROM renewable_projects\nWHERE project_location = 'Australia'\nGROUP BY project_type;\n```", "latency_sec": 0.40482568740844727, "total_duration_sec": 0.400687727, "load_duration_sec": 0.013853679, "tokens_prompt": 122, "prompt_eval_sec": 0.007363846, "tokens_completion": 31, "completion_eval_sec": 0.377222972, "tokens_total": 153, "tokens_per_sec": 377.9404438968599, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries perform the same operation: counting the number of projects in Australia grouped by project_type. The generated query adds an alias (num_projects) for the count column, but this does not affect the semantic result. The core logic (filtering, grouping, and aggregation) remains identical."}
{"example_id": 4916, "sql_complexity": "aggregation", "prompt": "What is the maximum revenue generated from selling Yttrium in India in the past 3 years?", "context": "CREATE TABLE Yttrium_Sales (id INT PRIMARY KEY, year INT, country VARCHAR(20), quantity INT, price PER_KG); INSERT INTO Yttrium_Sales (id, year, country, quantity, price) VALUES (1, 2019, 'India', 120, 40), (2, 2020, 'India', 130, 45), (3, 2021, 'India', 140, 50), (4, 2019, 'China', 150, 35), (5, 2020, 'China', 160, 40), (6, 2021, 'China', 170, 45);", "reference_sql": "SELECT MAX(quantity * price) FROM Yttrium_Sales WHERE country = 'India' GROUP BY year ORDER BY year DESC LIMIT 3;", "generated_sql": "SELECT MAX(quantity * price) AS max_revenue\nFROM Yttrium_Sales\nWHERE country = 'India' AND year >= 2019;", "raw_model_output": "```sql\nSELECT MAX(quantity * price) AS max_revenue\nFROM Yttrium_Sales\nWHERE country = 'India' AND year >= 2019;\n```", "latency_sec": 0.5372459888458252, "total_duration_sec": 0.534257865, "load_duration_sec": 0.013496981, "tokens_prompt": 267, "prompt_eval_sec": 0.013647086, "tokens_completion": 39, "completion_eval_sec": 0.504919151, "tokens_total": 306, "tokens_per_sec": 569.5714930462022, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns the maximum revenue per year for India, grouped by year and ordered descendingly with a limit of 3 results. The Generated SQL calculates a single maximum revenue value for all entries where country = 'India' and year >= 2019, without grouping or ordering. The Reference query produces multiple rows (up to 3) while the Generated query returns a single value."}
{"example_id": 812, "sql_complexity": "multiple_joins", "prompt": "What is the average salary of 'engineer' workers in each factory?", "context": "CREATE TABLE factories (factory_id INT, factory_name VARCHAR(20)); INSERT INTO factories VALUES (1, 'Factory X'), (2, 'Factory Y'), (3, 'Factory Z'); CREATE TABLE roles (role_id INT, role_name VARCHAR(20)); INSERT INTO roles VALUES (1, 'engineer'), (2, 'manager'), (3, 'assistant'); CREATE TABLE workers (worker_id INT, factory_id INT, role_id INT, salary DECIMAL(5,2)); INSERT INTO workers VALUES (1, 1, 1, 50000.00), (2, 1, 2, 70000.00), (3, 2, 1, 55000.00), (4, 2, 3, 40000.00), (5, 3, 1, 60000.00);", "reference_sql": "SELECT f.factory_name, AVG(salary) FROM workers w INNER JOIN factories f ON w.factory_id = f.factory_id INNER JOIN roles r ON w.role_id = r.role_id WHERE r.role_name = 'engineer' GROUP BY f.factory_name;", "generated_sql": "SELECT \n    f.factory_name,\n    AVG(w.salary) AS average_salary\nFROM \n    workers w\nJOIN \n    factories f ON w.factory_id = f.factory_id\nJOIN \n    roles r ON w.role_id = r.role_id\nWHERE \n    r.role_name = 'engineer'\nGROUP BY \n    f.factory_name;", "raw_model_output": "```sql\nSELECT \n    f.factory_name,\n    AVG(w.salary) AS average_salary\nFROM \n    workers w\nJOIN \n    factories f ON w.factory_id = f.factory_id\nJOIN \n    roles r ON w.role_id = r.role_id\nWHERE \n    r.role_name = 'engineer'\nGROUP BY \n    f.factory_name;\n```", "latency_sec": 0.962299108505249, "total_duration_sec": 0.956750221, "load_duration_sec": 0.013899028, "tokens_prompt": 285, "prompt_eval_sec": 0.013583195, "tokens_completion": 74, "completion_eval_sec": 0.92712607, "tokens_total": 359, "tokens_per_sec": 373.0648785050202, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same data by joining the same tables (workers, factories, roles) with identical conditions. They filter for 'engineer' roles, group by factory name, and calculate the average salary. The only differences are formatting (line breaks, aliases) and explicit table aliasing in the Generated SQL, which do not affect the result's semantic content."}
{"example_id": 5784, "sql_complexity": "set operations", "prompt": "List the number of users who have completed a workout of a specific type (e.g. Running) and have a membership status of 'Active'.", "context": "CREATE TABLE workouts (id INT, user_id INT, workout_type VARCHAR(20)); CREATE TABLE members (id INT, name VARCHAR(50), membership_status VARCHAR(20), state VARCHAR(20)); INSERT INTO workouts (id, user_id, workout_type) VALUES (1, 1, 'Running'), (2, 1, 'Cycling'), (3, 2, 'Running'), (4, 3, 'Cycling'), (5, 3, 'Swimming'), (6, 4, 'Running'), (7, 4, 'Swimming'); INSERT INTO members (id, name, membership_status, state) VALUES (1, 'John Doe', 'Active', 'Texas'), (2, 'Jane Doe', 'Inactive', 'California'), (3, 'Bob Smith', 'Active', 'Texas'), (4, 'Alice Johnson', 'Active', 'California');", "reference_sql": "SELECT COUNT(*) FROM (SELECT user_id FROM workouts WHERE workout_type = 'Running' INTERSECT SELECT id FROM members WHERE membership_status = 'Active') AS user_set;", "generated_sql": "SELECT COUNT(DISTINCT w.user_id)\nFROM workouts w\nJOIN members m ON w.user_id = m.id\nWHERE w.workout_type = 'Running' AND m.membership_status = 'Active';", "raw_model_output": "```sql\nSELECT COUNT(DISTINCT w.user_id)\nFROM workouts w\nJOIN members m ON w.user_id = m.id\nWHERE w.workout_type = 'Running' AND m.membership_status = 'Active';\n```", "latency_sec": 0.6455550193786621, "total_duration_sec": 0.637560931, "load_duration_sec": 0.014048137, "tokens_prompt": 288, "prompt_eval_sec": 0.014934015, "tokens_completion": 47, "completion_eval_sec": 0.606229492, "tokens_total": 335, "tokens_per_sec": 518.9333053632406, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of user_ids that appear in both the 'Running' workouts and active members. The Reference SQL uses INTERSECT to find the intersection of user_ids from workouts and members, while the Generated SQL uses a JOIN with conditions to achieve the same result. Both approaches ensure only users present in both datasets are counted, and the COUNT(*) vs COUNT(DISTINCT) are equivalent in this context because each user_id appears once in the intersection."}
{"example_id": 3038, "sql_complexity": "subqueries", "prompt": "What is the total assets of clients who have invested in mutual funds but not in stocks?", "context": "CREATE TABLE clients (client_id INT, name TEXT, age INT, gender TEXT, total_assets DECIMAL(10,2)); INSERT INTO clients VALUES (1, 'John Doe', 35, 'Male', 250000.00), (2, 'Jane Smith', 45, 'Female', 500000.00); CREATE TABLE investments (client_id INT, investment_type TEXT); INSERT INTO investments VALUES (1, 'Stocks'), (1, 'Bonds'), (2, 'Stocks'), (3, 'Mutual Funds');", "reference_sql": "SELECT c.total_assets FROM clients c INNER JOIN investments i ON c.client_id = i.client_id WHERE i.investment_type = 'Mutual Funds' AND c.client_id NOT IN (SELECT client_id FROM investments WHERE investment_type = 'Stocks');", "generated_sql": "SELECT SUM(c.total_assets) AS total_assets\nFROM clients c\nJOIN investments i ON c.client_id = i.client_id\nWHERE i.investment_type = 'Mutual Funds' AND i.investment_type != 'Stocks';", "raw_model_output": "```sql\nSELECT SUM(c.total_assets) AS total_assets\nFROM clients c\nJOIN investments i ON c.client_id = i.client_id\nWHERE i.investment_type = 'Mutual Funds' AND i.investment_type != 'Stocks';\n```", "latency_sec": 0.6848361492156982, "total_duration_sec": 0.677600378, "load_duration_sec": 0.014128043, "tokens_prompt": 213, "prompt_eval_sec": 0.011147494, "tokens_completion": 52, "completion_eval_sec": 0.6494388, "tokens_total": 265, "tokens_per_sec": 386.95387254818337, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL excludes clients with any 'Stocks' investments using a NOT IN subquery, while the Generated SQL incorrectly uses a redundant condition (i.investment_type != 'Stocks') that has no effect when i.investment_type = 'Mutual Funds'. Additionally, the Generated SQL aggregates results with SUM(c.total_assets) whereas the Reference SQL returns individual rows. The Generated SQL also fails to exclude clients with 'Stocks' investments, leading to different result sets."}
{"example_id": 1078, "sql_complexity": "basic SQL", "prompt": "What is the maximum and minimum temperature difference between any two Arctic research stations?", "context": "CREATE TABLE arctic_stations (id INT, name TEXT, location TEXT, temperature DECIMAL(5,2)); INSERT INTO arctic_stations (id, name, location, temperature) VALUES (1, 'Station A', 'Greenland', 2.3), (2, 'Station B', 'Canada', -5.2);", "reference_sql": "SELECT a.name as station1, b.name as station2, MAX(ABS(a.temperature - b.temperature)) as temp_diff FROM arctic_stations a, arctic_stations b ORDER BY temp_diff DESC LIMIT 1", "generated_sql": "SELECT \n    MAX(t1.temperature - t2.temperature) AS max_diff,\n    MIN(t1.temperature - t2.temperature) AS min_diff\nFROM \n    arctic_stations t1, \n    arctic_stations t2;", "raw_model_output": "```sql\nSELECT \n    MAX(t1.temperature - t2.temperature) AS max_diff,\n    MIN(t1.temperature - t2.temperature) AS min_diff\nFROM \n    arctic_stations t1, \n    arctic_stations t2;\n```", "latency_sec": 0.7060208320617676, "total_duration_sec": 0.699293437, "load_duration_sec": 0.0194244, "tokens_prompt": 155, "prompt_eval_sec": 0.007888572, "tokens_completion": 54, "completion_eval_sec": 0.669877294, "tokens_total": 209, "tokens_per_sec": 296.0252594667281, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The reference query calculates the maximum absolute temperature difference between any two stations and returns the pair of stations with this difference. The generated query calculates both the maximum and minimum of raw temperature differences (without absolute value) but does not account for absolute differences. Additionally, the generated query returns different columns (max_diff and min_diff) compared to the reference's station pairs and temp_diff. The absence of ABS and the inclusion of MIN in the generated query further differentiate their results."}
{"example_id": 5015, "sql_complexity": "basic SQL", "prompt": "Calculate the average recycling rate", "context": "CREATE TABLE recycling_rates (id INT PRIMARY KEY, location VARCHAR(50), rate FLOAT);", "reference_sql": "SELECT AVG(rate) FROM recycling_rates;", "generated_sql": "SELECT AVG(rate) AS average_recycling_rate FROM recycling_rates;", "raw_model_output": "```sql\nSELECT AVG(rate) AS average_recycling_rate FROM recycling_rates;\n```", "latency_sec": 0.2623770236968994, "total_duration_sec": 0.253800003, "load_duration_sec": 0.025894536, "tokens_prompt": 94, "prompt_eval_sec": 0.008545168, "tokens_completion": 18, "completion_eval_sec": 0.217340652, "tokens_total": 112, "tokens_per_sec": 426.8666456457084, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average of the 'rate' column from the recycling_rates table. The generated query adds an alias ('average_recycling_rate') to the result, but this does not affect the computed value. The semantic meaning (computing the average) remains identical."}
{"example_id": 1533, "sql_complexity": "subqueries", "prompt": "Which programs had the highest volunteer participation rate in the last quarter?", "context": "CREATE TABLE Programs (ProgramID INT, ProgramName TEXT, Budget DECIMAL(10,2), NumVolunteers INT); CREATE TABLE VolunteerEvents (EventID INT, ProgramID INT, EventDate DATE, NumVolunteers INT);", "reference_sql": "SELECT p.ProgramName, COUNT(v.EventID) / (SELECT COUNT(*) FROM VolunteerEvents WHERE EventDate >= DATEADD(quarter, -1, GETDATE())) * 100.0 AS VolunteerParticipationRate FROM Programs p INNER JOIN VolunteerEvents v ON p.ProgramID = v.ProgramID WHERE v.EventDate >= DATEADD(quarter, -1, GETDATE()) GROUP BY p.ProgramName ORDER BY VolunteerParticipationRate DESC;", "generated_sql": "WITH LastQuarter AS (\n    SELECT \n        ProgramID,\n        MAX(EventDate) AS MaxEventDate\n    FROM \n        VolunteerEvents\n    WHERE \n        EventDate >= DATEADD(quarter, -1, GETDATE())\n    GROUP BY \n        ProgramID\n),\nVolunteerParticipation AS (\n    SELECT \n        ve.ProgramID,\n        COUNT(ve.EventID) AS TotalEvents,\n        SUM(ve.NumVolunteers) AS TotalVolunteers\n    FROM \n        VolunteerEvents ve\n    JOIN \n        LastQuarter lq ON ve.ProgramID = lq.ProgramID AND ve.EventDate = lq.MaxEventDate\n    GROUP BY \n        ve.ProgramID\n)\nSELECT \n    p.ProgramName,\n    v.TotalEvents,\n    v.TotalVolunteers,\n    (v.TotalVolunteers * 1.0 / p.NumVolunteers) AS ParticipationRate\nFROM \n    Programs p\nJOIN \n    VolunteerParticipation v ON p.ProgramID = v.ProgramID\nORDER BY \n    ParticipationRate DESC;", "raw_model_output": "```sql\nWITH LastQuarter AS (\n    SELECT \n        ProgramID,\n        MAX(EventDate) AS MaxEventDate\n    FROM \n        VolunteerEvents\n    WHERE \n        EventDate >= DATEADD(quarter, -1, GETDATE())\n    GROUP BY \n        ProgramID\n),\nVolunteerParticipation AS (\n    SELECT \n        ve.ProgramID,\n        COUNT(ve.EventID) AS TotalEvents,\n        SUM(ve.NumVolunteers) AS TotalVolunteers\n    FROM \n        VolunteerEvents ve\n    JOIN \n        LastQuarter lq ON ve.ProgramID = lq.ProgramID AND ve.EventDate = lq.MaxEventDate\n    GROUP BY \n        ve.ProgramID\n)\nSELECT \n    p.ProgramName,\n    v.TotalEvents,\n    v.TotalVolunteers,\n    (v.TotalVolunteers * 1.0 / p.NumVolunteers) AS ParticipationRate\nFROM \n    Programs p\nJOIN \n    VolunteerParticipation v ON p.ProgramID = v.ProgramID\nORDER BY \n    ParticipationRate DESC;\n```\n\n### Explanation:\n1. **LastQuarter CTE**: Identifies the latest event date in the last quarter for each program.\n2. **VolunteerParticipation CTE**: Calculates the total number of events and volunteers for those events in the last quarter.\n3. **Final SELECT Statement**: Joins the `Programs` table with the `VolunteerParticipation` CTE to get the participation rate and orders the results by the highest participation rate.\n\nNote: The exact date functions (`DATEADD`, `GETDATE()`) are specific to SQL Server. If you're using a different database system, you may need to adjust these functions accordingly (e.g., `CURRENT_DATE - INTERVAL '3 MONTH'` in PostgreSQL).", "latency_sec": 4.402578115463257, "total_duration_sec": 4.397171818, "load_duration_sec": 0.0136101, "tokens_prompt": 130, "prompt_eval_sec": 0.007661299, "tokens_completion": 361, "completion_eval_sec": 4.373200528, "tokens_total": 491, "tokens_per_sec": 111.52556232346033, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries calculate different metrics. The reference query computes a participation rate based on event counts relative to total events in the last quarter, while the generated query calculates a volunteer participation rate using program-specific volunteer numbers and focuses on the latest event per program. The denominators and numerator calculations differ significantly."}
{"example_id": 4021, "sql_complexity": "subqueries", "prompt": "What is the percentage of energy efficiency improvement, per sector, compared to 2015 levels?", "context": "CREATE TABLE energy_efficiency (id INT, sector VARCHAR(50), year INT, efficiency FLOAT); INSERT INTO energy_efficiency (id, sector, year, efficiency) VALUES (1, 'Industry', 2015, 100.0), (2, 'Industry', 2020, 105.0), (3, 'Residential', 2015, 100.0), (4, 'Residential', 2020, 103.0);", "reference_sql": "SELECT sector, (SUM(efficiency) / (SELECT SUM(efficiency) FROM energy_efficiency WHERE year = 2015 AND sector = e.sector) * 100.0) - 100.0 AS improvement FROM energy_efficiency e WHERE year = 2020 GROUP BY sector;", "generated_sql": "SELECT \n    sector,\n    ((efficiency - (SELECT efficiency FROM energy_efficiency WHERE year = 2015 AND sector = e.sector)) / (SELECT efficiency FROM energy_efficiency WHERE year = 2015 AND sector = e.sector)) * 100 AS percentage_improvement\nFROM \n    energy_efficiency e\nWHERE \n    year = 2020;", "raw_model_output": "```sql\nSELECT \n    sector,\n    ((efficiency - (SELECT efficiency FROM energy_efficiency WHERE year = 2015 AND sector = e.sector)) / (SELECT efficiency FROM energy_efficiency WHERE year = 2015 AND sector = e.sector)) * 100 AS percentage_improvement\nFROM \n    energy_efficiency e\nWHERE \n    year = 2020;\n```", "latency_sec": 1.1534011363983154, "total_duration_sec": 1.149249574, "load_duration_sec": 0.015673921, "tokens_prompt": 204, "prompt_eval_sec": 0.012326884, "tokens_completion": 90, "completion_eval_sec": 1.117987695, "tokens_total": 294, "tokens_per_sec": 254.8983096358508, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates the percentage improvement by summing 2020 efficiencies and comparing them to 2015 sums per sector (aggregated), while the Generated SQL computes individual row-level improvements without aggregation. For example, if multiple 2020 entries exist per sector, the Reference SQL would aggregate them, but the Generated SQL would return separate rows with per-row calculations. The sample data shows matching results for single entries, but the approaches differ fundamentally in handling multiple records."}
{"example_id": 1551, "sql_complexity": "single join", "prompt": "How many unique donors made donations in the healthcare industry in Q3 2022?", "context": "CREATE TABLE donations (id INT, donor_id INT, amount FLOAT, donation_date DATE); INSERT INTO donations (id, donor_id, amount, donation_date) VALUES (1, 7, 100, '2022-07-01'); INSERT INTO donations (id, donor_id, amount, donation_date) VALUES (2, 8, 200, '2022-09-15'); INSERT INTO donors (id, name, industry, first_donation_date DATE) VALUES (7, 'Charlie Davis', 'Healthcare', '2022-07-01'); INSERT INTO donors (id, name, industry, first_donation_date DATE) VALUES (8, 'Dana Wilson', 'Healthcare', '2022-09-15');", "reference_sql": "SELECT COUNT(DISTINCT donor_id) FROM donations d JOIN donors don ON d.donor_id = don.id WHERE industry = 'Healthcare' AND donation_date BETWEEN '2022-07-01' AND '2022-09-30';", "generated_sql": "SELECT COUNT(DISTINCT d.id)\nFROM donations AS don\nJOIN donors AS d ON don.donor_id = d.id\nWHERE d.industry = 'Healthcare' AND DATE_FORMAT(don.donation_date, '%Y-%m') BETWEEN '2022-07' AND '2022-09';", "raw_model_output": "```sql\nSELECT COUNT(DISTINCT d.id)\nFROM donations AS don\nJOIN donors AS d ON don.donor_id = d.id\nWHERE d.industry = 'Healthcare' AND DATE_FORMAT(don.donation_date, '%Y-%m') BETWEEN '2022-07' AND '2022-09';\n```", "latency_sec": 0.9642720222473145, "total_duration_sec": 0.954938421, "load_duration_sec": 0.013576112, "tokens_prompt": 263, "prompt_eval_sec": 0.012656624, "tokens_completion": 74, "completion_eval_sec": 0.926638753, "tokens_total": 337, "tokens_per_sec": 349.4864438922474, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count distinct donors in the Healthcare industry with donations in July-September 2022. The Reference uses direct date comparisons, while the Generated uses DATE_FORMAT to extract year-month values. Since the date ranges (BETWEEN '2022-07-01' AND '2022-09-30' vs BETWEEN '2022-07' AND '2022-09') cover the same period, and COUNT(DISTINCT donor_id) vs COUNT(DISTINCT d.id) refer to the same values through the join, the results will be identical."}
{"example_id": 2592, "sql_complexity": "window functions", "prompt": "What is the third highest account balance for Shariah-compliant finance customers?", "context": "CREATE TABLE shariah_compliant_finance(customer_id INT, account_balance DECIMAL(10, 2)); INSERT INTO shariah_compliant_finance VALUES (1, 5000), (2, 7000), (3, 6000), (4, 8000), (5, 9000);", "reference_sql": "SELECT account_balance FROM (SELECT account_balance, RANK() OVER (ORDER BY account_balance DESC) as rn FROM shariah_compliant_finance) t WHERE rn = 3;", "generated_sql": "SELECT account_balance\nFROM shariah_compliant_finance\nORDER BY account_balance DESC\nOFFSET 2 ROWS\nFETCH NEXT 1 ROW ONLY;", "raw_model_output": "```sql\nSELECT account_balance\nFROM shariah_compliant_finance\nORDER BY account_balance DESC\nOFFSET 2 ROWS\nFETCH NEXT 1 ROW ONLY;\n```", "latency_sec": 0.4981229305267334, "total_duration_sec": 0.490443142, "load_duration_sec": 0.024706672, "tokens_prompt": 163, "prompt_eval_sec": 0.008008123, "tokens_completion": 37, "completion_eval_sec": 0.455577416, "tokens_total": 200, "tokens_per_sec": 401.50731424572785, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the third highest account balance. The reference query uses RANK() to assign ranks and filters for rank 3, while the generated query uses ORDER BY with OFFSET/FETCH to directly access the third row. With unique values in the dataset, both approaches yield the same result."}
{"example_id": 3795, "sql_complexity": "single join", "prompt": "What is the total quantity of unsold garments for each manufacturer based in 'Italy' or 'Spain'?", "context": "CREATE TABLE manufacturers (id INT PRIMARY KEY, name VARCHAR(255), country VARCHAR(255)); CREATE TABLE garments (id INT PRIMARY KEY, manufacturer_id INT, quantity_manufactured INT, quantity_sold INT);", "reference_sql": "SELECT m.name, SUM(g.quantity_manufactured - g.quantity_sold) as total_unsold_quantity FROM manufacturers m JOIN garments g ON m.id = g.manufacturer_id WHERE m.country IN ('Italy', 'Spain') GROUP BY m.name;", "generated_sql": "SELECT \n    m.name,\n    SUM(g.quantity_manufactured - g.quantity_sold) AS total_unsold_quantity\nFROM \n    manufacturers m\nJOIN \n    garments g ON m.id = g.manufacturer_id\nWHERE \n    m.country IN ('Italy', 'Spain')\nGROUP BY \n    m.name;", "raw_model_output": "```sql\nSELECT \n    m.name,\n    SUM(g.quantity_manufactured - g.quantity_sold) AS total_unsold_quantity\nFROM \n    manufacturers m\nJOIN \n    garments g ON m.id = g.manufacturer_id\nWHERE \n    m.country IN ('Italy', 'Spain')\nGROUP BY \n    m.name;\n```", "latency_sec": 0.860698938369751, "total_duration_sec": 0.855004728, "load_duration_sec": 0.025484399, "tokens_prompt": 137, "prompt_eval_sec": 0.006930178, "tokens_completion": 68, "completion_eval_sec": 0.820487566, "tokens_total": 205, "tokens_per_sec": 238.1785208057655, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure, logic, and syntax. Both select manufacturer names and calculate the total unsold quantity by summing the difference between manufactured and sold quantities for garments. The WHERE clause filters by country ('Italy', 'Spain'), and the GROUP BY clause groups results by manufacturer name. The only difference is formatting (whitespace/indentation), which does not affect semantic equivalence."}
{"example_id": 4138, "sql_complexity": "window functions", "prompt": "How many lifelong learning courses has a student with ID '2' completed, in chronological order?", "context": "CREATE TABLE lifelong_learning (student_id INT, course_id INT, completion_date DATE); INSERT INTO lifelong_learning VALUES (2, 1001, '2015-01-01'), (2, 1002, '2016-01-01');", "reference_sql": "SELECT student_id, course_id, COUNT(course_id) OVER (PARTITION BY student_id ORDER BY completion_date) as completed_courses FROM lifelong_learning WHERE student_id = 2;", "generated_sql": "SELECT COUNT(*)\nFROM lifelong_learning\nWHERE student_id = 2\nORDER BY completion_date;", "raw_model_output": "```sql\nSELECT COUNT(*)\nFROM lifelong_learning\nWHERE student_id = 2\nORDER BY completion_date;\n```", "latency_sec": 0.3473360538482666, "total_duration_sec": 0.34429579, "load_duration_sec": 0.025647386, "tokens_prompt": 152, "prompt_eval_sec": 0.00765663, "tokens_completion": 25, "completion_eval_sec": 0.308866242, "tokens_total": 177, "tokens_per_sec": 509.5929375570158, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns multiple rows with a cumulative count per row for student 2, while the Generated SQL returns a single row with a total count. The first query's window function produces per-row analytics, whereas the second query's COUNT(*) collapses all results into a single value. The output structures and purposes differ fundamentally."}
{"example_id": 312, "sql_complexity": "aggregation", "prompt": "List the top 3 most represented ethnicities in movies produced in the USA.", "context": "CREATE TABLE movies (title VARCHAR(255), production_country VARCHAR(64), lead_actor_ethnicity VARCHAR(64));", "reference_sql": "SELECT lead_actor_ethnicity, COUNT(*) AS count FROM movies WHERE production_country = 'USA' GROUP BY lead_actor_ethnicity ORDER BY count DESC LIMIT 3;", "generated_sql": "SELECT lead_actor_ethnicity, COUNT(*) AS ethnicity_count\nFROM movies\nWHERE production_country = 'USA'\nGROUP BY lead_actor_ethnicity\nORDER BY ethnicity_count DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT lead_actor_ethnicity, COUNT(*) AS ethnicity_count\nFROM movies\nWHERE production_country = 'USA'\nGROUP BY lead_actor_ethnicity\nORDER BY ethnicity_count DESC\nLIMIT 3;\n```", "latency_sec": 0.578049898147583, "total_duration_sec": 0.574274611, "load_duration_sec": 0.013468895, "tokens_prompt": 113, "prompt_eval_sec": 0.006604293, "tokens_completion": 46, "completion_eval_sec": 0.552286945, "tokens_total": 159, "tokens_per_sec": 275.0627593042243, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. The only difference is the column alias name ('count' vs 'ethnicity_count'), which does not affect the query's result set. Both queries filter by production_country = 'USA', group by lead_actor_ethnicity, count records, order by the count in descending order, and limit to 3 results."}
{"example_id": 4298, "sql_complexity": "single join", "prompt": "How many users joined the gym in Q1 2023?", "context": "CREATE TABLE memberships (id INT, user_id INT, join_date DATE); INSERT INTO memberships (id, user_id, join_date) VALUES (1, 5, '2023-01-15'), (2, 6, '2023-02-03'), (3, 7, '2023-03-20'), (4, 8, '2022-12-31');", "reference_sql": "SELECT COUNT(*) FROM memberships WHERE join_date BETWEEN '2023-01-01' AND '2023-03-31';", "generated_sql": "SELECT COUNT(DISTINCT user_id) AS q1_2023_joins\nFROM memberships\nWHERE join_date BETWEEN '2023-01-01' AND '2023-03-31';", "raw_model_output": "```sql\nSELECT COUNT(DISTINCT user_id) AS q1_2023_joins\nFROM memberships\nWHERE join_date BETWEEN '2023-01-01' AND '2023-03-31';\n```", "latency_sec": 0.714320182800293, "total_duration_sec": 0.710319493, "load_duration_sec": 0.014334986, "tokens_prompt": 184, "prompt_eval_sec": 0.009496496, "tokens_completion": 56, "completion_eval_sec": 0.684339667, "tokens_total": 240, "tokens_per_sec": 335.98378679312543, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query counts all rows matching the date range (COUNT(*)), while the generated query counts distinct user_ids (COUNT(DISTINCT user_id)). If there are multiple memberships for the same user in the date range, they would produce different results. The sample data happens to have unique user_ids, but the queries are not semantically equivalent in general."}
{"example_id": 5211, "sql_complexity": "multiple_joins", "prompt": "What is the average transaction value in the last week, split by product category and customer demographics?", "context": "CREATE TABLE transactions (transaction_id INT, customer_id INT, product_id INT, category_id INT, transaction_date DATE, amount DECIMAL(10,2)); CREATE TABLE customers (customer_id INT, age INT, gender VARCHAR(10), location VARCHAR(255)); CREATE TABLE products (product_id INT, name VARCHAR(255), category_id INT);", "reference_sql": "SELECT c.age, c.gender, p.category_id, AVG(t.amount) as avg_transaction_value FROM transactions t INNER JOIN customers c ON t.customer_id = c.customer_id INNER JOIN products p ON t.product_id = p.product_id WHERE t.transaction_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 WEEK) GROUP BY c.age, c.gender, p.category_id;", "generated_sql": "SELECT \n    p.category_id,\n    c.gender,\n    c.age,\n    AVG(t.amount) AS avg_transaction_value\nFROM \n    transactions t\nJOIN \n    customers c ON t.customer_id = c.customer_id\nJOIN \n    products p ON t.product_id = p.product_id\nWHERE \n    t.transaction_date >= DATEADD(day, -7, GETDATE())\nGROUP BY \n    p.category_id, c.gender, c.age;", "raw_model_output": "```sql\nSELECT \n    p.category_id,\n    c.gender,\n    c.age,\n    AVG(t.amount) AS avg_transaction_value\nFROM \n    transactions t\nJOIN \n    customers c ON t.customer_id = c.customer_id\nJOIN \n    products p ON t.product_id = p.product_id\nWHERE \n    t.transaction_date >= DATEADD(day, -7, GETDATE())\nGROUP BY \n    p.category_id, c.gender, c.age;\n```\n\n### Explanation:\n- **Tables and Columns Used:**\n  - `transactions`: `transaction_id`, `customer_id`, `product_id`, `category_id`, `transaction_date`, `amount`\n  - `customers`: `customer_id`, `age`, `gender`\n  - `products`: `product_id`, `name`, `category_id`\n\n- **Filtering by the Last Week:**\n  - The condition `t.transaction_date >= DATEADD(day, -7, GETDATE())` filters transactions that occurred in the last week.\n\n- **Join Conditions:**\n  - Join `transactions` with `customers` on `customer_id`.\n  - Join `transactions` with `products` on `product_id`.\n\n- **Aggregation:**\n  - Calculate the average transaction value using `AVG(t.amount)`.\n\n- **Grouping:**\n  - Group by `category_id`, `gender`, and `age` to get the average transaction value for each combination.", "latency_sec": 3.655850887298584, "total_duration_sec": 3.65011364, "load_duration_sec": 0.028139543, "tokens_prompt": 164, "prompt_eval_sec": 0.008594285, "tokens_completion": 293, "completion_eval_sec": 3.611213199, "tokens_total": 457, "tokens_per_sec": 125.00509842667319, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries compute the average transaction value per age, gender, and product category for transactions in the last week. They use equivalent JOIN conditions, date filters (DATE_SUB/CURRENT_DATE vs DATEADD/GETDATE() for same 7-day window), and group by the same columns. The SELECT column order differs but does not affect semantic equivalence."}
{"example_id": 382, "sql_complexity": "window functions", "prompt": "What is the average annual precipitation in the past 10 years for each weather station?", "context": "CREATE TABLE WeatherStation (ID INT, Name VARCHAR(100), Location VARCHAR(100), Elevation FLOAT, AnnualPrecipitation FLOAT); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (1, 'Station A', 'Arctic Circle', 100, 450); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (2, 'Station B', 'North Pole', 200, 300);", "reference_sql": "SELECT Name, AVG(AnnualPrecipitation) OVER (PARTITION BY Name ORDER BY Name ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS AvgAnnualPrecipitation FROM WeatherStation WHERE YEAR(CurrentDate) - YEAR(DateInstalled) BETWEEN 1 AND 10;", "generated_sql": "SELECT \n    Name,\n    AVG(AnnualPrecipitation) AS AverageAnnualPrecipitation\nFROM \n    WeatherStation\nGROUP BY \n    Name;", "raw_model_output": "It seems there might be a misunderstanding. The provided schema does not include any columns that would allow us to filter data based on the \"past 10 years\" or any temporal information such as dates. Therefore, we can only calculate the average annual precipitation based on the existing data.\n\nHere is the SQL statement to calculate the average annual precipitation for each weather station:\n\n```sql\nSELECT \n    Name,\n    AVG(AnnualPrecipitation) AS AverageAnnualPrecipitation\nFROM \n    WeatherStation\nGROUP BY \n    Name;\n```\n\nThis query will return the name of each weather station and its corresponding average annual precipitation based on the existing data.", "latency_sec": 1.6623938083648682, "total_duration_sec": 1.656622354, "load_duration_sec": 0.013784879, "tokens_prompt": 202, "prompt_eval_sec": 0.010940715, "tokens_completion": 133, "completion_eval_sec": 1.629589955, "tokens_total": 335, "tokens_per_sec": 201.51663120636033, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL includes a WHERE clause referencing a non-existent 'DateInstalled' column, which makes it invalid. Additionally, the Reference SQL uses a window function that would return multiple rows per Name (if duplicates existed), while the Generated SQL groups results into one row per Name. Even if the WHERE clause were valid, the window function's behavior differs from GROUP BY in edge cases (e.g., multiple rows per Name)."}
{"example_id": 2190, "sql_complexity": "single join", "prompt": "What is the total number of humanitarian assistance events by each country in the last 3 years?", "context": "CREATE TABLE Humanitarian_Assistance (id INT, country VARCHAR(50), year INT, events INT); CREATE TABLE Countries (id INT, name VARCHAR(50), region VARCHAR(50));", "reference_sql": "SELECT co.name, SUM(ha.events) FROM Humanitarian_Assistance ha INNER JOIN Countries co ON ha.country = co.name WHERE ha.year BETWEEN (YEAR(CURRENT_DATE) - 3) AND YEAR(CURRENT_DATE) GROUP BY co.name;", "generated_sql": "SELECT \n    c.name,\n    SUM(h.events) AS total_events\nFROM \n    Humanitarian_Assistance h\nJOIN \n    Countries c ON h.country = c.name\nWHERE \n    h.year >= (CURRENT YEAR - 3)\nGROUP BY \n    c.name;", "raw_model_output": "```sql\nSELECT \n    c.name,\n    SUM(h.events) AS total_events\nFROM \n    Humanitarian_Assistance h\nJOIN \n    Countries c ON h.country = c.name\nWHERE \n    h.year >= (CURRENT YEAR - 3)\nGROUP BY \n    c.name;\n```\n\nNote: Replace `CURRENT YEAR` with the appropriate function or constant to get the current year in your SQL dialect. For example, in PostgreSQL, you would use `EXTRACT(YEAR FROM CURRENT_DATE)`, and in MySQL, you would use `YEAR(CURDATE())`.", "latency_sec": 1.4594309329986572, "total_duration_sec": 1.450690076, "load_duration_sec": 0.015788008, "tokens_prompt": 129, "prompt_eval_sec": 0.008253815, "tokens_completion": 118, "completion_eval_sec": 1.423577655, "tokens_total": 247, "tokens_per_sec": 169.24404876940295, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query uses BETWEEN (YEAR(CURRENT_DATE) - 3) AND YEAR(CURRENT_DATE) which includes all years from (current year - 3) to current year inclusive. The generated query uses h.year >= (CURRENT YEAR - 3) which only filters the lower bound but lacks the upper bound restriction. This means the generated query could include years beyond the current year if they exist in the data, making them semantically different."}
{"example_id": 1852, "sql_complexity": "set operations", "prompt": "Compare coal production and employment rates in China and India between 2018 and 2020.", "context": "CREATE TABLE china_coal_production (year INT, production FLOAT); INSERT INTO china_coal_production (year, production) VALUES (2018, 3500.0), (2019, 3600.0), (2020, 3700.0); CREATE TABLE china_employment (year INT, employment FLOAT); INSERT INTO china_employment (year, employment) VALUES (2018, 8000000.0), (2019, 8100000.0), (2020, 8200000.0); CREATE TABLE india_coal_production (year INT, production FLOAT); INSERT INTO india_coal_production (year, production) VALUES (2018, 700.0), (2019, 750.0), (2020, 800.0); CREATE TABLE india_employment (year INT, employment FLOAT); INSERT INTO india_employment (year, employment) VALUES (2018, 1000000.0), (2019, 1050000.0), (2020, 1100000.0);", "reference_sql": "SELECT 'China' AS country, china_coal_production.production, china_employment.employment FROM china_coal_production INNER JOIN china_employment ON china_coal_production.year = china_employment.year WHERE china_coal_production.year BETWEEN 2018 AND 2020 UNION ALL SELECT 'India', india_coal_production.production, india_employment.employment FROM india_coal_production INNER JOIN india_employment ON india_coal_production.year = india_employment.year WHERE india_coal_production.year BETWEEN 2018 AND 2020;", "generated_sql": "SELECT \n    'China' AS country,\n    c.year,\n    c.production AS coal_production,\n    e.employment AS employment\nFROM \n    china_coal_production c\nJOIN \n    china_employment e ON c.year = e.year\nUNION ALL\nSELECT \n    'India' AS country,\n    i.year,\n    i.production AS coal_production,\n    j.employment AS employment\nFROM \n    india_coal_production i\nJOIN \n    india_employment j ON i.year = j.year;", "raw_model_output": "```sql\nSELECT \n    'China' AS country,\n    c.year,\n    c.production AS coal_production,\n    e.employment AS employment\nFROM \n    china_coal_production c\nJOIN \n    china_employment e ON c.year = e.year\nUNION ALL\nSELECT \n    'India' AS country,\n    i.year,\n    i.production AS coal_production,\n    j.employment AS employment\nFROM \n    india_coal_production i\nJOIN \n    india_employment j ON i.year = j.year;\n```\n\nThis SQL query compares the coal production and employment rates in China and India for the years 2018 to 2020 by joining the respective tables on the `year` column and using a `UNION ALL` to combine the results from both countries.", "latency_sec": 2.1166749000549316, "total_duration_sec": 2.10851472, "load_duration_sec": 0.025041333, "tokens_prompt": 371, "prompt_eval_sec": 0.01848949, "tokens_completion": 165, "completion_eval_sec": 2.062338272, "tokens_total": 536, "tokens_per_sec": 253.2273614555026, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL returns three columns: country, production, and employment. The Generated SQL returns four columns: country, year, coal_production, and employment. The additional 'year' column in the Generated SQL changes the result structure, making them incompatible."}
{"example_id": 2535, "sql_complexity": "subqueries", "prompt": "What is the maximum safety rating for vehicles in the vehiclesafety schema?", "context": "CREATE TABLE VehicleSafety (id INT, vehicle_id INT, safetyrating INT, PRIMARY KEY (id)); CREATE TABLE Vehicles (id INT, make VARCHAR(50), model VARCHAR(50), PRIMARY KEY (id)); CREATE TABLE LuxuryVehicles (id INT, vehicle_id INT, PRIMARY KEY (id), FOREIGN KEY (vehicle_id) REFERENCES Vehicles(id));", "reference_sql": "SELECT MAX(safetyrating) FROM vehicleSafety JOIN Vehicles ON vehicleSafety.vehicle_id = Vehicles.id WHERE EXISTS (SELECT * FROM LuxuryVehicles WHERE Vehicles.id = LuxuryVehicles.vehicle_id);", "generated_sql": "SELECT MAX(safetyrating) AS max_safety_rating\nFROM VehicleSafety;", "raw_model_output": "```sql\nSELECT MAX(safetyrating) AS max_safety_rating\nFROM VehicleSafety;\n```", "latency_sec": 0.2947351932525635, "total_duration_sec": 0.286752226, "load_duration_sec": 0.01385252, "tokens_prompt": 156, "prompt_eval_sec": 0.007868316, "tokens_completion": 21, "completion_eval_sec": 0.263007952, "tokens_total": 177, "tokens_per_sec": 600.5390738944628, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters vehicles that exist in LuxuryVehicles via the EXISTS clause, while the Generated SQL retrieves the maximum safetyrating from all VehicleSafety entries without any filtering. The Generated SQL lacks the join condition and existence check, so it may include safety ratings from non-luxury vehicles, leading to different results."}
{"example_id": 2140, "sql_complexity": "aggregation", "prompt": "What was the total amount of minerals extracted in the 'north' region for each month in 2020?", "context": "CREATE TABLE extraction(id INT, location TEXT, month INT, year INT, minerals_extracted FLOAT);INSERT INTO extraction(id, location, month, year, minerals_extracted) VALUES (1, 'north', 1, 2020, 1500), (2, 'north', 2, 2020, 1800), (3, 'south', 1, 2020, 1200);", "reference_sql": "SELECT month, SUM(minerals_extracted) FROM extraction WHERE location = 'north' AND year = 2020 GROUP BY month;", "generated_sql": "SELECT month, SUM(minerals_extracted) AS total_minerals_extracted\nFROM extraction\nWHERE location = 'north' AND year = 2020\nGROUP BY month;", "raw_model_output": "```sql\nSELECT month, SUM(minerals_extracted) AS total_minerals_extracted\nFROM extraction\nWHERE location = 'north' AND year = 2020\nGROUP BY month;\n```", "latency_sec": 0.5686140060424805, "total_duration_sec": 0.563093592, "load_duration_sec": 0.013579119, "tokens_prompt": 192, "prompt_eval_sec": 0.011659703, "tokens_completion": 43, "completion_eval_sec": 0.534979378, "tokens_total": 235, "tokens_per_sec": 413.28563402014305, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (month and aggregated minerals_extracted), apply identical WHERE conditions, and group by the same column. The only difference is the alias name for the aggregated column, which does not affect the semantic result."}
{"example_id": 4779, "sql_complexity": "window functions", "prompt": "What is the average CO2 emission for the top 3 highest emitting countries since 2015?", "context": "CREATE TABLE emissions (country VARCHAR(50), year INT, co2_emission INT); INSERT INTO emissions (country, year, co2_emission) VALUES ('USA', 2015, 5373978000); INSERT INTO emissions (country, year, co2_emission) VALUES ('China', 2015, 10498600000); INSERT INTO emissions (country, year, co2_emission) VALUES ('India', 2015, 2633830000); INSERT INTO emissions (country, year, co2_emission) VALUES ('USA', 2016, 5518004000); INSERT INTO emissions (country, year, co2_emission) VALUES ('China', 2016, 10813000000); INSERT INTO emissions (country, year, co2_emission) VALUES ('India', 2016, 2799280000);", "reference_sql": "SELECT AVG(co2_emission) as avg_emission FROM (SELECT country, year, co2_emission, ROW_NUMBER() OVER (ORDER BY co2_emission DESC) as rn FROM emissions WHERE year >= 2015) t WHERE rn <= 3 GROUP BY country;", "generated_sql": "SELECT AVG(co2_emission) AS average_co2_emission\nFROM (\n    SELECT co2_emission\n    FROM emissions\n    WHERE year >= 2015\n    ORDER BY co2_emission DESC\n    LIMIT 3\n) AS top_countries;", "raw_model_output": "```sql\nSELECT AVG(co2_emission) AS average_co2_emission\nFROM (\n    SELECT co2_emission\n    FROM emissions\n    WHERE year >= 2015\n    ORDER BY co2_emission DESC\n    LIMIT 3\n) AS top_countries;\n```\n\nThis SQL query first filters the records for years starting from 2015, orders them by CO2 emission in descending order, and limits the results to the top 3 highest emitting countries. Then it calculates the average CO2 emission of these top 3 countries.", "latency_sec": 1.513775110244751, "total_duration_sec": 1.509222788, "load_duration_sec": 0.014514448, "tokens_prompt": 322, "prompt_eval_sec": 0.017485826, "tokens_completion": 117, "completion_eval_sec": 1.474135899, "tokens_total": 439, "tokens_per_sec": 290.0034470305311, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the average CO2 emissions for each country in the top 3 highest emissions (grouped by country), while the Generated SQL calculates the average of the top 3 individual emissions regardless of country. The Reference SQL returns multiple rows (one per country in the top 3), whereas the Generated SQL returns a single row. Additionally, the Reference SQL's grouping by country leads to different aggregation logic compared to the Generated SQL's flat average."}
{"example_id": 1015, "sql_complexity": "subqueries", "prompt": "List the top 3 most expensive eco-friendly products in Europe and their suppliers.", "context": "CREATE TABLE Suppliers (supplierID INT, supplierName VARCHAR(50), country VARCHAR(50)); CREATE TABLE Products (productID INT, productName VARCHAR(50), price DECIMAL(10,2), ecoFriendly BOOLEAN, supplierID INT);", "reference_sql": "SELECT P.productName, P.price, S.supplierName FROM (SELECT * FROM Products WHERE ecoFriendly = TRUE ORDER BY price DESC LIMIT 3) P JOIN Suppliers S ON P.supplierID = S.supplierID;", "generated_sql": "SELECT \n    P.productName AS ProductName,\n    S.supplierName AS SupplierName\nFROM \n    Products P\nJOIN \n    Suppliers S ON P.supplierID = S.supplierID\nWHERE \n    P.ecoFriendly = TRUE AND S.country IN ('Europe', 'EU')\nORDER BY \n    P.price DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT \n    P.productName AS ProductName,\n    S.supplierName AS SupplierName\nFROM \n    Products P\nJOIN \n    Suppliers S ON P.supplierID = S.supplierID\nWHERE \n    P.ecoFriendly = TRUE AND S.country IN ('Europe', 'EU')\nORDER BY \n    P.price DESC\nLIMIT 3;\n```", "latency_sec": 0.9643421173095703, "total_duration_sec": 0.957949402, "load_duration_sec": 0.023864563, "tokens_prompt": 137, "prompt_eval_sec": 0.006664032, "tokens_completion": 77, "completion_eval_sec": 0.925361867, "tokens_total": 214, "tokens_per_sec": 221.91294578841084, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects: 1) The Reference SQL includes the 'price' column in the output while the Generated SQL does not, and 2) The Generated SQL adds a filter on 'S.country IN ('Europe', 'EU')' which is absent in the Reference SQL. Additionally, the Reference SQL applies the LIMIT 3 after ordering by price in a subquery, while the Generated SQL applies it after joining and filtering. These differences in selected columns and additional filtering conditions make them non-equivalent."}
{"example_id": 3715, "sql_complexity": "aggregation", "prompt": "What is the average age of engines still in service for each engine type?", "context": "CREATE TABLE Engine (id INT, aircraft_id INT, engine_type VARCHAR(255), hours_since_last_service INT, manufacture_year INT); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (1, 1, 'GE90-115B', 500, 2000); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (2, 2, 'CFM56-5B', 1000, 1995); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (3, 1, 'GE90-115B', 700, 2002);", "reference_sql": "SELECT engine_type, AVG(YEAR(CURRENT_DATE) - manufacture_year) as avg_age FROM Engine GROUP BY engine_type;", "generated_sql": "SELECT \n    engine_type,\n    AVG(YEAR(CURRENT_DATE) - manufacture_year) AS average_age\nFROM \n    Engine\nWHERE \n    hours_since_last_service <= 0\nGROUP BY \n    engine_type;", "raw_model_output": "```sql\nSELECT \n    engine_type,\n    AVG(YEAR(CURRENT_DATE) - manufacture_year) AS average_age\nFROM \n    Engine\nWHERE \n    hours_since_last_service <= 0\nGROUP BY \n    engine_type;\n```\n\nThis SQL statement calculates the average age of engines still in service for each engine type. The `hours_since_last_service` column is checked to ensure that only engines still in service (i.e., with non-positive values) are considered.", "latency_sec": 1.2607061862945557, "total_duration_sec": 1.255653458, "load_duration_sec": 0.015417458, "tokens_prompt": 257, "prompt_eval_sec": 0.012514381, "tokens_completion": 98, "completion_eval_sec": 1.224675427, "tokens_total": 355, "tokens_per_sec": 281.58821132099735, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the average age of all engines grouped by type, while the Generated SQL only includes engines with hours_since_last_service <= 0. The WHERE clause in the Generated SQL filters out engines that have positive hours since last service, which means it's not considering the same dataset as the Reference SQL. In the sample data, all engines have positive hours, so the Generated SQL would return no rows, making the queries non-equivalent."}
{"example_id": 1957, "sql_complexity": "set operations", "prompt": "What is the average temperature recorded for the 'polar_bear' species in the 'Arctic_Animals' table compared to the 'penguin' species in the 'Antarctic_Animals' table?", "context": "CREATE TABLE Arctic_Animals (species TEXT, avg_temp FLOAT); CREATE TABLE Antarctic_Animals (species TEXT, avg_temp FLOAT);", "reference_sql": "SELECT AVG(Arctic_Animals.avg_temp) FROM Arctic_Animals WHERE Arctic_Animals.species = 'polar_bear' INTERSECT SELECT AVG(Antarctic_Animals.avg_temp) FROM Antarctic_Animals WHERE Antarctic_Animals.species = 'penguin'", "generated_sql": "SELECT \n    (SELECT avg_temp FROM Arctic_Animals WHERE species = 'polar_bear') AS arctic_avg_temp,\n    (SELECT avg_temp FROM Antarctic_Animals WHERE species = 'penguin') AS antarctic_avg_temp;", "raw_model_output": "```sql\nSELECT \n    (SELECT avg_temp FROM Arctic_Animals WHERE species = 'polar_bear') AS arctic_avg_temp,\n    (SELECT avg_temp FROM Antarctic_Animals WHERE species = 'penguin') AS antarctic_avg_temp;\n```", "latency_sec": 0.6814401149749756, "total_duration_sec": 0.67832206, "load_duration_sec": 0.015116796, "tokens_prompt": 138, "prompt_eval_sec": 0.008351438, "tokens_completion": 54, "completion_eval_sec": 0.652002945, "tokens_total": 192, "tokens_per_sec": 281.7562332781814, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses INTERSECT to return only values present in both subqueries (i.e., when Arctic and Antarctic average temps are equal), while the Generated SQL returns two separate columns with arbitrary values from each table. The result structures differ (1 column vs 2 columns) and the semantic logic (intersection requirement vs independent selection) makes them non-equivalent."}
{"example_id": 1311, "sql_complexity": "basic SQL", "prompt": "What is the total number of veteran job applications in Texas in the last year?", "context": "CREATE TABLE veteran_jobs (id INT, state VARCHAR(50), application_date DATE); INSERT INTO veteran_jobs (id, state, application_date) VALUES (1, 'Texas', '2021-02-15'), (2, 'California', '2021-04-10'), (3, 'Texas', '2022-01-05');", "reference_sql": "SELECT COUNT(*) FROM veteran_jobs WHERE state = 'Texas' AND application_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR);", "generated_sql": "SELECT COUNT(*) AS total_applications\nFROM veteran_jobs\nWHERE state = 'Texas' AND application_date >= DATEADD(year, -1, GETDATE());", "raw_model_output": "```sql\nSELECT COUNT(*) AS total_applications\nFROM veteran_jobs\nWHERE state = 'Texas' AND application_date >= DATEADD(year, -1, GETDATE());\n```\n\nNote: The `DATEADD` function and `GETDATE()` are specific to SQL Server. If you are using a different database system, you would need to adjust the date functions accordingly. For example:\n\n- In PostgreSQL, use `CURRENT_DATE - INTERVAL '1 year'`.\n- In MySQL, use `CURDATE() - INTERVAL 1 YEAR`.\n\nHere is the adjusted query for PostgreSQL:\n\n```sql\nSELECT COUNT(*) AS total_applications\nFROM veteran_jobs\nWHERE state = 'Texas' AND application_date >= CURRENT_DATE - INTERVAL '1 year';\n```\n\nAnd for MySQL:\n\n```sql\nSELECT COUNT(*) AS total_applications\nFROM veteran_jobs\nWHERE state = 'Texas' AND application_date >= CURDATE() - INTERVAL 1 YEAR;\n```", "latency_sec": 2.3547000885009766, "total_duration_sec": 2.350538603, "load_duration_sec": 0.015270024, "tokens_prompt": 170, "prompt_eval_sec": 0.008733619, "tokens_completion": 191, "completion_eval_sec": 2.324365173, "tokens_total": 361, "tokens_per_sec": 153.3103947135008, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in date function behavior. The Reference SQL uses MySQL's DATE_SUB with CURRENT_DATE (DATE type), while the Generated SQL uses SQL Server's DATEADD with GETDATE() (DATETIME type). This leads to a comparison between DATE and DATETIME values, which may exclude dates exactly on the boundary (e.g., application_date = '2022-10-05' would be excluded in the Generated SQL if the calculated date has a time component). The semantic equivalence is compromised due to type mismatch and potential time component differences."}
{"example_id": 2997, "sql_complexity": "window functions", "prompt": "What is the earliest capture time for each satellite image in the 'satellite_images' table?", "context": "CREATE TABLE satellite_images (image_id INT, image_url TEXT, capture_time TIMESTAMP); INSERT INTO satellite_images (image_id, image_url, capture_time) VALUES (1, 'image1.jpg', '2022-01-01 10:00:00'), (2, 'image2.jpg', '2021-05-01 10:00:00');", "reference_sql": "SELECT image_id, MIN(capture_time) OVER (PARTITION BY image_id) FROM satellite_images;", "generated_sql": "SELECT MIN(capture_time) AS earliest_capture_time\nFROM satellite_images;", "raw_model_output": "```sql\nSELECT MIN(capture_time) AS earliest_capture_time\nFROM satellite_images;\n```", "latency_sec": 0.3009321689605713, "total_duration_sec": 0.293205094, "load_duration_sec": 0.015185283, "tokens_prompt": 178, "prompt_eval_sec": 0.021632982, "tokens_completion": 20, "completion_eval_sec": 0.253901362, "tokens_total": 198, "tokens_per_sec": 657.955580767247, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses a window function to return the minimum capture_time within each image_id partition (which would just repeat the capture_time for each row since image_id is unique). The Generated SQL aggregates all rows to return a single minimum capture_time value. The result structures differ (multiple rows vs single row) and the semantic intent differs (per-group vs overall minimum)."}
{"example_id": 3743, "sql_complexity": "aggregation", "prompt": "What is the maximum budget spent on peacekeeping operations by each department?", "context": "CREATE TABLE DepartmentPeacekeeping (id INT, department VARCHAR(50), budget INT);", "reference_sql": "SELECT department, MAX(budget) FROM DepartmentPeacekeeping GROUP BY department;", "generated_sql": "SELECT department, MAX(budget) AS max_budget\nFROM DepartmentPeacekeeping\nGROUP BY department;", "raw_model_output": "```sql\nSELECT department, MAX(budget) AS max_budget\nFROM DepartmentPeacekeeping\nGROUP BY department;\n```", "latency_sec": 0.33280396461486816, "total_duration_sec": 0.329337267, "load_duration_sec": 0.015462095, "tokens_prompt": 101, "prompt_eval_sec": 0.007966414, "tokens_completion": 25, "completion_eval_sec": 0.303266546, "tokens_total": 126, "tokens_per_sec": 378.6012589898423, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries group by 'department' and select the maximum 'budget' for each group. The generated query adds an alias 'max_budget' to the MAX(budget) column, but this does not affect the semantic result set content. The core logic of grouping and aggregation remains identical."}
{"example_id": 4664, "sql_complexity": "multiple_joins", "prompt": "Calculate the total number of volunteer hours contributed by volunteers from 'California' in 'Health' projects in 2021.", "context": "CREATE TABLE volunteers (volunteer_id INT, name VARCHAR(255), state VARCHAR(255));", "reference_sql": "SELECT SUM(vh.hours) as total_hours FROM volunteer_projects vp JOIN volunteer_hours vh ON vp.project_id = vh.project_id JOIN volunteers vol ON vh.volunteer_id = vol.volunteer_id WHERE vp.cause = 'Health' AND vol.state = 'California' AND vh.volunteer_date BETWEEN '2021-01-01' AND '2021-12-31';", "generated_sql": "SELECT COUNT(*) AS total_volunteers\nFROM volunteers\nWHERE state = 'California'\nAND name LIKE '%Health%';", "raw_model_output": "It seems there might be a misunderstanding because the provided schema only includes a `volunteers` table without any columns related to volunteer hours, states, project types, or years. However, based on the context and the information given, I will assume you want to calculate the total number of volunteers from 'California' who are involved in 'Health' projects in 2021.\n\nGiven this assumption, here is the SQL statement:\n\n```sql\nSELECT COUNT(*) AS total_volunteers\nFROM volunteers\nWHERE state = 'California'\nAND name LIKE '%Health%';\n```\n\nThis query counts the number of volunteers from California whose names include \"Health\" (assuming that's a proxy for being involved in Health projects). If you have additional tables or columns related to project types and years, please provide the schema details so I can adjust the query accordingly.", "latency_sec": 2.093302011489868, "total_duration_sec": 2.08890557, "load_duration_sec": 0.0158146, "tokens_prompt": 118, "prompt_eval_sec": 0.007139851, "tokens_completion": 172, "completion_eval_sec": 2.06375848, "tokens_total": 290, "tokens_per_sec": 138.53710473129388, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates total volunteer hours for Health projects in California during 2021, involving multiple tables (volunteer_projects, volunteer_hours, volunteers) with specific join conditions and date filtering. The generated query counts volunteers in California with 'Health' in their name, using only the volunteers table and a different filtering condition. The aggregate functions (SUM vs COUNT), tables involved, and filtering criteria differ significantly."}
{"example_id": 251, "sql_complexity": "set operations", "prompt": "Compare the number of economic diversification projects in two regions, one in Europe and one in Oceania, by showing the project type and the number of projects in each region.", "context": "CREATE TABLE economic_diversification (region VARCHAR(50), project_type VARCHAR(50), project_start_date DATE);", "reference_sql": "SELECT 'Europe' as region, project_type, COUNT(*) as project_count FROM economic_diversification WHERE region = 'Europe' UNION ALL SELECT 'Oceania' as region, project_type, COUNT(*) as project_count FROM economic_diversification WHERE region = 'Oceania';", "generated_sql": "SELECT \n    project_type,\n    COUNT(*) AS num_projects\nFROM \n    economic_diversification\nWHERE \n    (region = 'Europe' OR region = 'Oceania')\nGROUP BY \n    project_type;", "raw_model_output": "```sql\nSELECT \n    project_type,\n    COUNT(*) AS num_projects\nFROM \n    economic_diversification\nWHERE \n    (region = 'Europe' OR region = 'Oceania')\nGROUP BY \n    project_type;\n```", "latency_sec": 0.6338469982147217, "total_duration_sec": 0.629311099, "load_duration_sec": 0.014076184, "tokens_prompt": 130, "prompt_eval_sec": 0.00768716, "tokens_completion": 50, "completion_eval_sec": 0.605388747, "tokens_total": 180, "tokens_per_sec": 283.98020422433757, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query produces separate counts for 'Europe' and 'Oceania' as distinct rows, while the generated query aggregates all projects from both regions into a single count per project_type. The generated query lacks the region-specific grouping, leading to different result structures."}
{"example_id": 610, "sql_complexity": "subqueries", "prompt": "What is the percentage of community development projects completed in 'Caribbean' in 2020?", "context": "CREATE TABLE community_projects (project_id INT, project_name TEXT, location TEXT, completion_year INT); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (1, 'Community Center', 'Southern Region, Caribbean', 2020); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (2, 'Park Renovation', 'Northern Region, Caribbean', 2019); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (3, 'Library Construction', 'Caribbean', 2020);", "reference_sql": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM community_projects WHERE location = 'Caribbean')) FROM community_projects WHERE completion_year = 2020 AND location = 'Caribbean';", "generated_sql": "SELECT \n    CAST(SUM(CASE WHEN location = 'Caribbean' AND completion_year = 2020 THEN 1 ELSE 0 END) AS DECIMAL(10,2)) * 100 / COUNT(*)\nFROM \n    community_projects;", "raw_model_output": "```sql\nSELECT \n    CAST(SUM(CASE WHEN location = 'Caribbean' AND completion_year = 2020 THEN 1 ELSE 0 END) AS DECIMAL(10,2)) * 100 / COUNT(*)\nFROM \n    community_projects;\n```", "latency_sec": 0.7866511344909668, "total_duration_sec": 0.782767166, "load_duration_sec": 0.013345157, "tokens_prompt": 217, "prompt_eval_sec": 0.011464951, "tokens_completion": 61, "completion_eval_sec": 0.755318918, "tokens_total": 278, "tokens_per_sec": 353.3968080779426, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the percentage of Caribbean projects completed in 2020 relative to all Caribbean projects (denominator is COUNT(*) from Caribbean projects). The Generated SQL calculates the percentage of 2020 Caribbean projects relative to all projects (denominator is COUNT(*) from entire table). The denominators differ, leading to different results."}
{"example_id": 421, "sql_complexity": "set operations", "prompt": "What is the combined landfill capacity for 'City A' and 'City B'?", "context": "CREATE TABLE landfill_capacity (city VARCHAR(255), capacity INT); INSERT INTO landfill_capacity (city, capacity) VALUES ('City A', 500000), ('City B', 600000);", "reference_sql": "SELECT SUM(capacity) FROM (SELECT capacity FROM landfill_capacity WHERE city = 'City A' UNION ALL SELECT capacity FROM landfill_capacity WHERE city = 'City B') AS combined_capacity;", "generated_sql": "SELECT city, SUM(capacity) AS total_capacity FROM landfill_capacity WHERE city IN ('City A', 'City B') GROUP BY city;", "raw_model_output": "SELECT city, SUM(capacity) AS total_capacity FROM landfill_capacity WHERE city IN ('City A', 'City B') GROUP BY city;", "latency_sec": 0.3901510238647461, "total_duration_sec": 0.378762643, "load_duration_sec": 0.01540623, "tokens_prompt": 135, "prompt_eval_sec": 0.00755096, "tokens_completion": 29, "completion_eval_sec": 0.353171072, "tokens_total": 164, "tokens_per_sec": 420.350043876481, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query calculates the total sum of capacities for both 'City A' and 'City B' as a single value, while the generated query returns separate sums for each city as two rows. The first produces a single numeric result, the second produces two rows with city names and their respective totals."}
{"example_id": 880, "sql_complexity": "aggregation", "prompt": "Show veteran employment statistics for each state in the 'veteran_employment' table", "context": "CREATE TABLE veteran_employment (employee_id INT, state VARCHAR(2), job_title VARCHAR(50), employment_date DATE);", "reference_sql": "SELECT state, COUNT(*) as veteran_employees FROM veteran_employment WHERE state IN ('CA', 'NY', 'TX', 'FL', 'PA') GROUP BY state;", "generated_sql": "SELECT state, COUNT(employee_id) AS number_of_veterans\nFROM veteran_employment\nGROUP BY state;", "raw_model_output": "```sql\nSELECT state, COUNT(employee_id) AS number_of_veterans\nFROM veteran_employment\nGROUP BY state;\n```", "latency_sec": 0.36934399604797363, "total_duration_sec": 0.364344892, "load_duration_sec": 0.016258249, "tokens_prompt": 113, "prompt_eval_sec": 0.006110709, "tokens_completion": 28, "completion_eval_sec": 0.339419084, "tokens_total": 141, "tokens_per_sec": 381.75793165373585, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters results to only include records where the state is in ('CA', 'NY', 'TX', 'FL', 'PA'), while the Generated SQL includes all states. This difference in filtering leads to potentially different result sets."}
{"example_id": 454, "sql_complexity": "single join", "prompt": "Which excavation sites have more than 10 artifacts?", "context": "CREATE TABLE ExcavationSite (SiteID INT, SiteName VARCHAR(50)); INSERT INTO ExcavationSite (SiteID, SiteName) VALUES (1, 'Site A'), (2, 'Site B'), (3, 'Site C'); CREATE TABLE Artifact (ArtifactID INT, SiteID INT, ObjectType VARCHAR(50)); INSERT INTO Artifact (ArtifactID, SiteID, ObjectType) VALUES (1, 1, 'Pottery'), (2, 1, 'Tool'), (3, 2, 'Statue'), (4, 2, 'Bead'), (5, 3, 'Bead'), (6, 3, 'Bead'), (7, 3, 'Bead'), (8, 3, 'Bead'), (9, 3, 'Bead'), (10, 3, 'Bead'), (11, 3, 'Bead');", "reference_sql": "SELECT e.SiteName FROM ExcavationSite e JOIN Artifact a ON e.SiteID = a.SiteID GROUP BY e.SiteName HAVING COUNT(a.ArtifactID) > 10;", "generated_sql": "SELECT es.SiteName\nFROM ExcavationSite es\nJOIN Artifact a ON es.SiteID = a.SiteID\nGROUP BY es.SiteName\nHAVING COUNT(a.ArtifactID) > 10;", "raw_model_output": "```sql\nSELECT es.SiteName\nFROM ExcavationSite es\nJOIN Artifact a ON es.SiteID = a.SiteID\nGROUP BY es.SiteName\nHAVING COUNT(a.ArtifactID) > 10;\n```", "latency_sec": 0.6596992015838623, "total_duration_sec": 0.654532911, "load_duration_sec": 0.015597615, "tokens_prompt": 275, "prompt_eval_sec": 0.014886642, "tokens_completion": 48, "completion_eval_sec": 0.621536796, "tokens_total": 323, "tokens_per_sec": 489.6170849146307, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The two queries are semantically equivalent. The only differences are the table aliases ('e' vs 'es') and the order of clauses, which do not affect the logical execution or result. Both queries join the same tables, group by SiteName, and filter with the same HAVING condition."}
{"example_id": 1086, "sql_complexity": "aggregation", "prompt": "What is the total CO2 emission for each equipment type, excluding equipment that is older than 8 years?", "context": "CREATE TABLE EmissionData (EquipmentID INT, EquipmentType VARCHAR(50), CO2Emission INT, Age INT); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (1, 'Excavator', 50, 8); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (2, 'Haul Truck', 70, 7); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (3, 'Shovel', 30, 6); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (4, 'Drilling Rig', 40, 3);", "reference_sql": "SELECT EquipmentType, SUM(CO2Emission) as TotalCO2Emission FROM EmissionData WHERE Age <= 8 GROUP BY EquipmentType;", "generated_sql": "SELECT EquipmentType, SUM(CO2Emission) AS TotalCO2Emission\nFROM EmissionData\nWHERE Age <= 8\nGROUP BY EquipmentType;", "raw_model_output": "```sql\nSELECT EquipmentType, SUM(CO2Emission) AS TotalCO2Emission\nFROM EmissionData\nWHERE Age <= 8\nGROUP BY EquipmentType;\n```", "latency_sec": 0.5587048530578613, "total_duration_sec": 0.554520622, "load_duration_sec": 0.027154447, "tokens_prompt": 256, "prompt_eval_sec": 0.012432419, "tokens_completion": 39, "completion_eval_sec": 0.512203148, "tokens_total": 295, "tokens_per_sec": 528.0068687168695, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select EquipmentType and sum CO2Emission with the same WHERE condition (Age <= 8) and GROUP BY clause. The only difference is formatting (line breaks and use of AS keyword), which does not affect semantic equivalence."}
{"example_id": 3455, "sql_complexity": "basic SQL", "prompt": "What are the names of all innovation projects in the 'rural_infrastructure' table, excluding those with a budget over 50000?", "context": "CREATE TABLE rural_infrastructure (name VARCHAR(255), budget INT); INSERT INTO rural_infrastructure (name, budget) VALUES ('Dam Construction', 40000), ('Well Digging', 30000), ('Irrigation System', 70000);", "reference_sql": "SELECT name FROM rural_infrastructure WHERE budget <= 50000;", "generated_sql": "SELECT name FROM rural_infrastructure WHERE budget <= 50000;", "raw_model_output": "```sql\nSELECT name FROM rural_infrastructure WHERE budget <= 50000;\n```", "latency_sec": 0.30776286125183105, "total_duration_sec": 0.303820876, "load_duration_sec": 0.028686305, "tokens_prompt": 163, "prompt_eval_sec": 0.008386746, "tokens_completion": 21, "completion_eval_sec": 0.264311418, "tokens_total": 184, "tokens_per_sec": 597.86291059154, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They select the 'name' column from the 'rural_infrastructure' table where the 'budget' is less than or equal to 50000. The data and conditions are the same, so they will produce identical results."}
{"example_id": 3936, "sql_complexity": "window functions", "prompt": "What is the total investment per client for each investment type?", "context": "CREATE TABLE clients (client_id INT, name TEXT, investment_type TEXT, investment FLOAT); INSERT INTO clients (client_id, name, investment_type, investment) VALUES (1, 'John Doe', 'Stocks', 3000.00), (1, 'John Doe', 'Bonds', 2000.00), (2, 'Jane Smith', 'Stocks', 5000.00);", "reference_sql": "SELECT client_id, name, investment_type, SUM(investment) OVER (PARTITION BY client_id, investment_type ORDER BY client_id) as total_investment FROM clients;", "generated_sql": "SELECT client_id, investment_type, SUM(investment) AS total_investment\nFROM clients\nGROUP BY client_id, investment_type;", "raw_model_output": "```sql\nSELECT client_id, investment_type, SUM(investment) AS total_investment\nFROM clients\nGROUP BY client_id, investment_type;\n```", "latency_sec": 0.45657801628112793, "total_duration_sec": 0.451183311, "load_duration_sec": 0.034350104, "tokens_prompt": 174, "prompt_eval_sec": 0.009309479, "tokens_completion": 32, "completion_eval_sec": 0.40514359, "tokens_total": 206, "tokens_per_sec": 451.18247627840236, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query uses a window function to calculate a running total per client_id/investment_type while retaining all original rows and including the 'name' column. The generated query aggregates rows using GROUP BY, eliminating the 'name' column and reducing the result to one row per client_id/investment_type combination. The output structures and row counts differ."}
{"example_id": 1838, "sql_complexity": "window functions", "prompt": "What are the top 3 species with the most sightings across all arctic research stations?", "context": "CREATE TABLE research_station (id INT, name TEXT); INSERT INTO research_station (id, name) VALUES (1, 'Station A'); INSERT INTO research_station (id, name) VALUES (2, 'Station B'); CREATE TABLE species_observations (station_id INT, species_name TEXT, sightings INT); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (1, 'Species 1', 10); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (1, 'Species 2', 5); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (2, 'Species 1', 8); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (2, 'Species 3', 15);", "reference_sql": "SELECT species_name, SUM(sightings) as total_sightings, RANK() OVER (ORDER BY SUM(sightings) DESC) as rank FROM species_observations GROUP BY species_name HAVING rank <= 3;", "generated_sql": "SELECT \n    so.species_name, \n    SUM(so.sightings) AS total_sightings\nFROM \n    species_observations so\nGROUP BY \n    so.species_name\nORDER BY \n    total_sightings DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT \n    so.species_name, \n    SUM(so.sightings) AS total_sightings\nFROM \n    species_observations so\nGROUP BY \n    so.species_name\nORDER BY \n    total_sightings DESC\nLIMIT 3;\n```", "latency_sec": 0.745856761932373, "total_duration_sec": 0.738185415, "load_duration_sec": 0.013861256, "tokens_prompt": 255, "prompt_eval_sec": 0.013721069, "tokens_completion": 56, "completion_eval_sec": 0.707633566, "tokens_total": 311, "tokens_per_sec": 416.970142087682, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL contains a HAVING clause that references the RANK() window function, which is invalid in standard SQL. Window functions cannot be used in HAVING clauses. The Generated SQL correctly uses ORDER BY and LIMIT to achieve the top 3 results, while the Reference SQL would fail to execute due to this invalid construct."}
{"example_id": 3091, "sql_complexity": "single join", "prompt": "Find the number of hybrid vehicles sold in the US, Germany, and Japan.", "context": "CREATE TABLE vehicle_sales (sale_id INT, vehicle_id INT, country VARCHAR(20), quantity INT); CREATE TABLE vehicles (vehicle_id INT, model VARCHAR(20), manufacture VARCHAR(20), vehicle_type VARCHAR(20));", "reference_sql": "SELECT SUM(vs.quantity) FROM vehicle_sales vs JOIN vehicles v ON vs.vehicle_id = v.vehicle_id WHERE v.vehicle_type = 'hybrid' AND vs.country IN ('US', 'Germany', 'Japan');", "generated_sql": "SELECT \n    SUM(vs.quantity) AS total_sales\nFROM \n    vehicle_sales vs\nJOIN \n    vehicles v ON vs.vehicle_id = v.vehicle_id\nWHERE \n    v.vehicle_type = 'hybrid' AND\n    (vs.country = 'US' OR vs.country = 'Germany' OR vs.country = 'Japan');", "raw_model_output": "```sql\nSELECT \n    SUM(vs.quantity) AS total_sales\nFROM \n    vehicle_sales vs\nJOIN \n    vehicles v ON vs.vehicle_id = v.vehicle_id\nWHERE \n    v.vehicle_type = 'hybrid' AND\n    (vs.country = 'US' OR vs.country = 'Germany' OR vs.country = 'Japan');\n```", "latency_sec": 0.9123141765594482, "total_duration_sec": 0.905459549, "load_duration_sec": 0.013891976, "tokens_prompt": 134, "prompt_eval_sec": 0.009056996, "tokens_completion": 72, "completion_eval_sec": 0.879982818, "tokens_total": 206, "tokens_per_sec": 225.79940692895352, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of quantities from vehicle_sales where the vehicle type is 'hybrid' and the country is in ('US', 'Germany', 'Japan'). The WHERE clause conditions (IN vs. OR) are logically equivalent, and the SELECT clause differences (alias name) do not affect the result. The join conditions and table aliases are identical."}
{"example_id": 2399, "sql_complexity": "set operations", "prompt": "What is the average duration of criminal trials for Indigenous defendants compared to non-Indigenous defendants in Canada and New Zealand?", "context": "CREATE TABLE canada_criminal_trials (id INT, defendant_type VARCHAR(255), days_to_completion INT); INSERT INTO canada_criminal_trials (id, defendant_type, days_to_completion) VALUES (1, 'Indigenous', 60), (2, 'Non-Indigenous', 45);CREATE TABLE nz_criminal_trials (id INT, defendant_type VARCHAR(255), days_to_completion INT); INSERT INTO nz_criminal_trials (id, defendant_type, days_to_completion) VALUES (1, 'Indigenous', 70), (2, 'Non-Indigenous', 50);", "reference_sql": "SELECT AVG(days_to_completion) AS avg_duration FROM canada_criminal_trials WHERE defendant_type = 'Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM canada_criminal_trials WHERE defendant_type = 'Non-Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM nz_criminal_trials WHERE defendant_type = 'Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM nz_criminal_trials WHERE defendant_type = 'Non-Indigenous';", "generated_sql": "SELECT \n    'Canada' AS country,\n    AVG(CASE WHEN defendant_type = 'Indigenous' THEN days_to_completion ELSE NULL END) AS indigenous_avg_days,\n    AVG(CASE WHEN defendant_type = 'Non-Indigenous' THEN days_to_completion ELSE NULL END) AS non_indigenous_avg_days\nFROM \n    canada_criminal_trials\nUNION ALL\nSELECT \n    'New Zealand' AS country,\n    AVG(CASE WHEN defendant_type = 'Indigenous' THEN days_to_completion ELSE NULL END) AS indigenous_avg_days,\n    AVG(CASE WHEN defendant_type = 'Non-Indigenous' THEN days_to_completion ELSE NULL END) AS non_indigenous_avg_days\nFROM \n    nz_criminal_trials;", "raw_model_output": "```sql\nSELECT \n    'Canada' AS country,\n    AVG(CASE WHEN defendant_type = 'Indigenous' THEN days_to_completion ELSE NULL END) AS indigenous_avg_days,\n    AVG(CASE WHEN defendant_type = 'Non-Indigenous' THEN days_to_completion ELSE NULL END) AS non_indigenous_avg_days\nFROM \n    canada_criminal_trials\nUNION ALL\nSELECT \n    'New Zealand' AS country,\n    AVG(CASE WHEN defendant_type = 'Indigenous' THEN days_to_completion ELSE NULL END) AS indigenous_avg_days,\n    AVG(CASE WHEN defendant_type = 'Non-Indigenous' THEN days_to_completion ELSE NULL END) AS non_indigenous_avg_days\nFROM \n    nz_criminal_trials;\n```", "latency_sec": 1.8928279876708984, "total_duration_sec": 1.888492253, "load_duration_sec": 0.01398462, "tokens_prompt": 221, "prompt_eval_sec": 0.013044825, "tokens_completion": 152, "completion_eval_sec": 1.857955672, "tokens_total": 373, "tokens_per_sec": 197.05963903195024, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries produce different result structures. The Reference SQL returns four rows with a single average value each, while the Generated SQL returns two rows with two average values per row. Although the calculated averages are numerically equivalent, the output format differs (4 rows vs 2 rows, 1 column vs 2 columns), making them structurally and semantically distinct."}
{"example_id": 2972, "sql_complexity": "set operations", "prompt": "How many indigenous communities are in the Arctic Research Station 13 and 14?", "context": "CREATE TABLE Arctic_Research_Station_13 (id INT, community TEXT); CREATE TABLE Arctic_Research_Station_14 (id INT, community TEXT);", "reference_sql": "SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_13; SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_14; SELECT COUNT(DISTINCT community) FROM (SELECT * FROM Arctic_Research_Station_13 UNION ALL SELECT * FROM Arctic_Research_Station_14) AS Arctic_Communities;", "generated_sql": "SELECT \n    COUNT(DISTINCT community) AS number_of_indigenous_communities\nFROM \n    Arctic_Research_Station_13\nUNION ALL\nSELECT \n    COUNT(DISTINCT community)\nFROM \n    Arctic_Research_Station_14;", "raw_model_output": "```sql\nSELECT \n    COUNT(DISTINCT community) AS number_of_indigenous_communities\nFROM \n    Arctic_Research_Station_13\nUNION ALL\nSELECT \n    COUNT(DISTINCT community)\nFROM \n    Arctic_Research_Station_14;\n```\n\nThis SQL statement counts the distinct communities in both `Arctic_Research_Station_13` and `Arctic_Research_Station_14`, then combines the results using `UNION ALL`. Note that this approach assumes you want to count each community separately from both stations. If you need a combined total, you can modify it accordingly.", "latency_sec": 1.608713150024414, "total_duration_sec": 1.599750874, "load_duration_sec": 0.024294748, "tokens_prompt": 121, "prompt_eval_sec": 0.006220054, "tokens_completion": 131, "completion_eval_sec": 1.567255394, "tokens_total": 252, "tokens_per_sec": 156.64694479321912, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes three separate queries: two individual counts of distinct communities in each table, and a combined count using UNION ALL. The Generated SQL returns two separate counts using UNION ALL, which produces two rows. The Reference's third query combines both tables into a single count, while the Generated SQL does not aggregate the results. Thus, the output structures and semantics differ."}
{"example_id": 5576, "sql_complexity": "window functions", "prompt": "Who are the top 5 users with the most followers, and what is their location?", "context": "CREATE TABLE user_data (user_id INT, name VARCHAR(50), followers INT, location VARCHAR(50)); INSERT INTO user_data (user_id, name, followers, location) VALUES (1, 'Alice', 10000, 'New York'), (2, 'Bob', 15000, 'California'), (3, 'Charlie', 12000, 'Texas'), (4, 'David', 8000, 'Florida'), (5, 'Eve', 9000, 'Illinois');", "reference_sql": "SELECT name, location FROM (SELECT name, location, ROW_NUMBER() OVER (ORDER BY followers DESC) AS rank FROM user_data) AS user_ranks WHERE rank <= 5;", "generated_sql": "SELECT name, location\nFROM user_data\nORDER BY followers DESC\nLIMIT 5;", "raw_model_output": "```sql\nSELECT name, location\nFROM user_data\nORDER BY followers DESC\nLIMIT 5;\n```", "latency_sec": 0.334730863571167, "total_duration_sec": 0.32496631, "load_duration_sec": 0.014172247, "tokens_prompt": 207, "prompt_eval_sec": 0.011175532, "tokens_completion": 23, "completion_eval_sec": 0.297561062, "tokens_total": 230, "tokens_per_sec": 687.1191904629966, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the top 5 users by followers in descending order. The Reference SQL uses ROW_NUMBER() to assign ranks and filters where rank <= 5, while the Generated SQL directly orders by followers and limits to 5 rows. Since the ordering logic (followers DESC) is identical and the sample data has unique follower counts, both produce the same result. In cases with ties, ROW_NUMBER() ensures unique ranks, but the LIMIT 5 in the Generated SQL would still return the first 5 rows in the ordered list, matching the ranked subset."}
{"example_id": 1560, "sql_complexity": "basic SQL", "prompt": "What is the average media literacy score for users in the 'Young Adult' age group who have completed at least one disinformation detection course?", "context": "CREATE TABLE users (id INT, age VARCHAR(20), media_literacy_score INT, courses_completed INT);", "reference_sql": "SELECT AVG(media_literacy_score) FROM users WHERE age = 'Young Adult' AND courses_completed > 0;", "generated_sql": "SELECT AVG(media_literacy_score) AS average_media_literacy_score\nFROM users\nWHERE age = 'Young Adult' AND courses_completed >= 1;", "raw_model_output": "```sql\nSELECT AVG(media_literacy_score) AS average_media_literacy_score\nFROM users\nWHERE age = 'Young Adult' AND courses_completed >= 1;\n```", "latency_sec": 0.5043001174926758, "total_duration_sec": 0.495527162, "load_duration_sec": 0.023641197, "tokens_prompt": 121, "prompt_eval_sec": 0.009699971, "tokens_completion": 38, "completion_eval_sec": 0.459202878, "tokens_total": 159, "tokens_per_sec": 315.2884452824052, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The WHERE clauses are equivalent because 'courses_completed > 0' and 'courses_completed >= 1' produce the same filtering result for integer values. The generated query adds an alias (AS) which doesn't affect the semantic output. Both queries calculate the same average value under identical conditions."}
{"example_id": 1201, "sql_complexity": "basic SQL", "prompt": "What is the maximum energy efficiency rating of hydroelectric dams in Canada?", "context": "CREATE TABLE hydro_dams (id INT, name TEXT, country TEXT, energy_efficiency_rating FLOAT); INSERT INTO hydro_dams (id, name, country, energy_efficiency_rating) VALUES (1, 'Robert-Bourassa', 'Canada', 0.94), (2, 'Churchill Falls', 'Canada', 0.92);", "reference_sql": "SELECT MAX(energy_efficiency_rating) FROM hydro_dams WHERE country = 'Canada';", "generated_sql": "SELECT MAX(energy_efficiency_rating) AS max_energy_efficiency_rating FROM hydro_dams WHERE country = 'Canada';", "raw_model_output": "SELECT MAX(energy_efficiency_rating) AS max_energy_efficiency_rating FROM hydro_dams WHERE country = 'Canada';", "latency_sec": 0.34284090995788574, "total_duration_sec": 0.336340321, "load_duration_sec": 0.015327492, "tokens_prompt": 157, "prompt_eval_sec": 0.008442204, "tokens_completion": 25, "completion_eval_sec": 0.310130431, "tokens_total": 182, "tokens_per_sec": 530.8584673350584, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the maximum energy_efficiency_rating for dams in Canada. The generated query adds an alias (max_energy_efficiency_rating) to the result column, but this does not affect the semantic meaning or the actual value returned. The WHERE clause and aggregate function are identical in both queries."}
{"example_id": 4243, "sql_complexity": "single join", "prompt": "How many orders were placed by new and returning customers in each month of the year 2021?'", "context": "CREATE TABLE customer (id INT, first_order_date DATE, last_order_date DATE);", "reference_sql": "INSERT INTO customer (id, first_order_date, last_order_date) SELECT customer_id, MIN(order_date) AS first_order_date, MAX(order_date) AS last_order_date FROM orders GROUP BY customer_id; SELECT YEAR(order_date) AS year, MONTH(order_date) AS month, CASE WHEN DATEDIFF(last_order_date, first_order_date) > 30 THEN 'returning' ELSE 'new' END AS customer_type, COUNT(DISTINCT id) AS num_orders FROM orders JOIN customer ON orders.customer_id = customer.id WHERE YEAR(order_date) = 2021 GROUP BY year, month, customer_type;", "generated_sql": "SELECT \n    EXTRACT(MONTH FROM o.order_date) AS month,\n    CASE \n        WHEN c.first_order_date <= '2021-12-31' THEN 'Returning'\n        ELSE 'New'\n    END AS customer_type,\n    COUNT(*) AS number_of_orders\nFROM \n    customer c\nJOIN \n    (SELECT id, order_date FROM orders WHERE EXTRACT(YEAR FROM order_date) = 2021) o\nON \n    c.id = o.id\nGROUP BY \n    month, customer_type\nORDER BY \n    month, customer_type;", "raw_model_output": "```sql\nSELECT \n    EXTRACT(MONTH FROM o.order_date) AS month,\n    CASE \n        WHEN c.first_order_date <= '2021-12-31' THEN 'Returning'\n        ELSE 'New'\n    END AS customer_type,\n    COUNT(*) AS number_of_orders\nFROM \n    customer c\nJOIN \n    (SELECT id, order_date FROM orders WHERE EXTRACT(YEAR FROM order_date) = 2021) o\nON \n    c.id = o.id\nGROUP BY \n    month, customer_type\nORDER BY \n    month, customer_type;\n```\n\n### Explanation:\n- **EXTRACT(MONTH FROM o.order_date)**: Extracts the month from the `order_date` to group by month.\n- **CASE WHEN**: Determines if a customer is new or returning based on their first order date in 2021.\n- **JOIN**: Joins the `customer` table with a subquery that filters orders placed in 2021.\n- **GROUP BY**: Groups the results by month and customer type.\n- **ORDER BY**: Orders the result by month and customer type for better readability.", "latency_sec": 2.9479548931121826, "total_duration_sec": 2.941506132, "load_duration_sec": 0.014152089, "tokens_prompt": 108, "prompt_eval_sec": 0.007522017, "tokens_completion": 243, "completion_eval_sec": 2.917191733, "tokens_total": 351, "tokens_per_sec": 119.06559385291209, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in customer_type logic (DATEDIFF vs first_order_date check), counting method (COUNT(DISTINCT id) vs COUNT(*)), and grouping structure (year/month/customer_type vs month/customer_type). The generated query's customer_type condition is flawed and unrelated to the reference's 30-day window logic."}
{"example_id": 2321, "sql_complexity": "subqueries", "prompt": "What are the names and types of vessels used in research expeditions in the regions with the lowest ocean acidification levels?", "context": "CREATE TABLE ocean_acidification (id INT PRIMARY KEY, region VARCHAR(255), year INT, acidification_level INT); INSERT INTO ocean_acidification (id, region, year, acidification_level) VALUES (1, 'Arctic Ocean', 2018, 20), (2, 'Southern Ocean', 2019, 22); CREATE TABLE expedition_vessels (id INT PRIMARY KEY, name VARCHAR(255), type VARCHAR(255), region VARCHAR(255)); INSERT INTO expedition_vessels (id, name, type, region) VALUES (1, 'Sea Researcher', 'Research Vessel', 'Arctic Ocean');", "reference_sql": "SELECT v.name, v.type FROM expedition_vessels v INNER JOIN ocean_acidification oa ON v.region = oa.region WHERE oa.acidification_level = (SELECT MIN(acidification_level) FROM ocean_acidification);", "generated_sql": "SELECT ev.name, ev.type \nFROM expedition_vessels ev\nJOIN ocean_acidification oa ON ev.region = oa.region\nWHERE ev.type = 'Research Vessel' AND ev.region IN (\n    SELECT region \n    FROM ocean_acidification \n    ORDER BY acidification_level ASC \n    LIMIT 1\n);", "raw_model_output": "```sql\nSELECT ev.name, ev.type \nFROM expedition_vessels ev\nJOIN ocean_acidification oa ON ev.region = oa.region\nWHERE ev.type = 'Research Vessel' AND ev.region IN (\n    SELECT region \n    FROM ocean_acidification \n    ORDER BY acidification_level ASC \n    LIMIT 1\n);\n```", "latency_sec": 0.9292330741882324, "total_duration_sec": 0.922386904, "load_duration_sec": 0.013831042, "tokens_prompt": 240, "prompt_eval_sec": 0.012853182, "tokens_completion": 71, "completion_eval_sec": 0.892584016, "tokens_total": 311, "tokens_per_sec": 334.6846002782306, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL does not filter by vessel type, while the Generated SQL explicitly requires 'Research Vessel' type. Additionally, the Generated SQL uses a subquery with LIMIT 1 which may return only one region (vs. possible multiple regions with the same minimum acidification level in the Reference SQL). The WHERE clause conditions differ semantically."}
{"example_id": 4349, "sql_complexity": "multiple_joins", "prompt": "Show the research grants awarded to professors in the Computer Science department.", "context": "CREATE TABLE departments (id INT, name VARCHAR(50)); INSERT INTO departments (id, name) VALUES (1, 'Computer Science'), (2, 'Mathematics'); CREATE TABLE professors (id INT, name VARCHAR(50), department_id INT); INSERT INTO professors (id, name, department_id) VALUES (1, 'John Smith', 1), (2, 'Jane Doe', 2); CREATE TABLE grants (id INT, professor_id INT, year INT, amount FLOAT); INSERT INTO grants (id, professor_id, year, amount) VALUES (1, 1, 2021, 5000.0), (2, 2, 2020, 7000.0);", "reference_sql": "SELECT professors.name, grants.amount FROM professors INNER JOIN grants ON professors.id = grants.professor_id INNER JOIN departments ON professors.department_id = departments.id WHERE departments.name = 'Computer Science';", "generated_sql": "SELECT g.id, g.year, g.amount, p.name\nFROM grants g\nJOIN professors p ON g.professor_id = p.id\nJOIN departments d ON p.department_id = d.id\nWHERE d.name = 'Computer Science';", "raw_model_output": "```sql\nSELECT g.id, g.year, g.amount, p.name\nFROM grants g\nJOIN professors p ON g.professor_id = p.id\nJOIN departments d ON p.department_id = d.id\nWHERE d.name = 'Computer Science';\n```", "latency_sec": 0.7012591361999512, "total_duration_sec": 0.69354685, "load_duration_sec": 0.014365804, "tokens_prompt": 238, "prompt_eval_sec": 0.013007726, "tokens_completion": 53, "completion_eval_sec": 0.663498497, "tokens_total": 291, "tokens_per_sec": 414.96785564448845, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects only 'professors.name' and 'grants.amount', while the Generated SQL selects 'g.id', 'g.year', 'g.amount', and 'p.name'. The column sets differ, resulting in different output structures. Although both filter for 'Computer Science' department professors, the additional columns in the Generated SQL make the result sets non-equivalent."}
{"example_id": 476, "sql_complexity": "basic SQL", "prompt": "Insert new food safety records for locations \"A123\", \"B456\", and \"C789\"", "context": "CREATE TABLE food_safety_records (id INT, location VARCHAR(255), inspection_date DATE, violation_count INT);", "reference_sql": "INSERT INTO food_safety_records (location, inspection_date, violation_count) VALUES ('A123', '2022-03-01', 0), ('B456', '2022-03-05', 2), ('C789', '2022-03-10', 1);", "generated_sql": "INSERT INTO food_safety_records (location) VALUES ('A123'), ('B456'), ('C789');", "raw_model_output": "```sql\nINSERT INTO food_safety_records (location) VALUES ('A123'), ('B456'), ('C789');\n```", "latency_sec": 0.4380218982696533, "total_duration_sec": 0.433157699, "load_duration_sec": 0.024202581, "tokens_prompt": 120, "prompt_eval_sec": 0.006453276, "tokens_completion": 33, "completion_eval_sec": 0.40015718, "tokens_total": 153, "tokens_per_sec": 349.2976049928233, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL inserts all three columns (location, inspection_date, violation_count), while the Generated SQL only inserts the location column. The other columns (id, inspection_date, violation_count) would be missing or set to defaults/null, leading to different data being inserted."}
{"example_id": 2908, "sql_complexity": "single join", "prompt": "List all co-owners and the properties they own in New York, NY.", "context": "CREATE TABLE properties (id INT, city VARCHAR(50), price INT); CREATE TABLE co_owners (property_id INT, owner_name VARCHAR(50)); INSERT INTO properties (id, city, price) VALUES (1, 'New York', 800000), (2, 'Los Angeles', 600000); INSERT INTO co_owners (property_id, owner_name) VALUES (1, 'David'), (1, 'Ella'), (2, 'Frank');", "reference_sql": "SELECT properties.city, co_owners.owner_name FROM properties INNER JOIN co_owners ON properties.id = co_owners.property_id WHERE properties.city = 'New York';", "generated_sql": "SELECT co.owner_name, p.city, p.price\nFROM co_owners co\nJOIN properties p ON co.property_id = p.id\nWHERE p.city = 'New York';", "raw_model_output": "```sql\nSELECT co.owner_name, p.city, p.price\nFROM co_owners co\nJOIN properties p ON co.property_id = p.id\nWHERE p.city = 'New York';\n```", "latency_sec": 0.5574278831481934, "total_duration_sec": 0.552794901, "load_duration_sec": 0.016990694, "tokens_prompt": 191, "prompt_eval_sec": 0.012047075, "tokens_completion": 41, "completion_eval_sec": 0.521384367, "tokens_total": 232, "tokens_per_sec": 416.19733603875414, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL selects only 'city' and 'owner_name', while the Generated SQL includes an additional 'price' column. Although both perform the same join and filter condition, the result set structure differs due to the extra column in the Generated SQL."}
{"example_id": 636, "sql_complexity": "set operations", "prompt": "Insert new data into the 'cosmetic_ingredients' table for a vegan eyeshadow product by brand 'Ara' with ingredients 'Mica', 'Iron Oxide', 'Titanium Dioxide' and 'Zinc Oxide'.", "context": "CREATE TABLE cosmetic_ingredients (ingredient_id INT, product_name TEXT, brand_name TEXT, ingredient_type TEXT);", "reference_sql": "INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type) VALUES (NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient'); INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type, ingredient_name) SELECT ingredient_id, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Mica' FROM cosmetic_ingredients WHERE ingredient_name = 'Mica' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Iron Oxide' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Titanium Dioxide' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Zinc Oxide';", "generated_sql": "INSERT INTO cosmetic_ingredients (product_name, brand_name, ingredient_type)\nVALUES ('Vegan Eyeshadow', 'Ara', 'Mica'),\n       ('Vegan Eyeshadow', 'Ara', 'Iron Oxide'),\n       ('Vegan Eyeshadow', 'Ara', 'Titanium Dioxide'),\n       ('Vegan Eyeshadow', 'Ara', 'Zinc Oxide');", "raw_model_output": "```sql\nINSERT INTO cosmetic_ingredients (product_name, brand_name, ingredient_type)\nVALUES ('Vegan Eyeshadow', 'Ara', 'Mica'),\n       ('Vegan Eyeshadow', 'Ara', 'Iron Oxide'),\n       ('Vegan Eyeshadow', 'Ara', 'Titanium Dioxide'),\n       ('Vegan Eyeshadow', 'Ara', 'Zinc Oxide');\n```", "latency_sec": 1.0979242324829102, "total_duration_sec": 1.093702097, "load_duration_sec": 0.014183306, "tokens_prompt": 140, "prompt_eval_sec": 0.007500994, "tokens_completion": 89, "completion_eval_sec": 1.069841118, "tokens_total": 229, "tokens_per_sec": 208.57541278793528, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL inserts a row with 'Ingredient' as the ingredient_type and includes a SELECT that references an non-existent 'ingredient_name' column (schema mismatch). The Generated SQL directly inserts rows with specific ingredient names as the ingredient_type values. Additionally, the Reference SQL's first INSERT adds a row with NULL ingredient_id, which the Generated SQL does not include."}
{"example_id": 3404, "sql_complexity": "multiple_joins", "prompt": "What are the names of startups that have received funding from investors with over 3 million funds, and are involved in Genetic Research or Bioprocess Engineering?", "context": "CREATE TABLE public.investors ( id SERIAL PRIMARY KEY, name VARCHAR(100), type VARCHAR(50), funds INTEGER ); CREATE TABLE public.investments ( id SERIAL PRIMARY KEY, investor_id INTEGER, startup_id INTEGER ); CREATE TABLE public.startups ( id SERIAL PRIMARY KEY, name VARCHAR(100), industry VARCHAR(50), funding INTEGER );", "reference_sql": "SELECT startups.name FROM public.startups JOIN public.investments ON startups.id = investments.startup_id JOIN public.investors ON investments.investor_id = investors.id WHERE (startups.industry = 'Genetic Research' OR startups.industry = 'Bioprocess Engineering') AND investors.funds > 3000000;", "generated_sql": "SELECT DISTINCT s.name \nFROM public.startups s\nJOIN public.investments i ON s.id = i.startup_id\nJOIN public.investors inv ON i.investor_id = inv.id\nWHERE inv.funds > 3000000 AND (s.industry = 'Genetic Research' OR s.industry = 'Bioprocess Engineering');", "raw_model_output": "```sql\nSELECT DISTINCT s.name \nFROM public.startups s\nJOIN public.investments i ON s.id = i.startup_id\nJOIN public.investors inv ON i.investor_id = inv.id\nWHERE inv.funds > 3000000 AND (s.industry = 'Genetic Research' OR s.industry = 'Bioprocess Engineering');\n```", "latency_sec": 1.0282659530639648, "total_duration_sec": 1.021818031, "load_duration_sec": 0.014250566, "tokens_prompt": 175, "prompt_eval_sec": 0.009519931, "tokens_completion": 82, "completion_eval_sec": 0.995939809, "tokens_total": 257, "tokens_per_sec": 249.9353394267377, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Generated SQL includes DISTINCT which may eliminate duplicates not present in the Reference SQL. While the JOIN conditions and WHERE clauses are logically equivalent, the presence of DISTINCT in the Generated query could result in fewer rows if duplicate startup names exist in the result set."}
{"example_id": 134, "sql_complexity": "subqueries", "prompt": "Who are the top 3 authors with the most citations in the Mathematics department in the past 5 years?", "context": "CREATE TABLE authors (id INT, name VARCHAR(50), department VARCHAR(50)); INSERT INTO authors (id, name, department) VALUES (1, 'Author Name', 'Mathematics'); CREATE TABLE publications (id INT, title VARCHAR(100), author VARCHAR(50), journal VARCHAR(50), year INT, cites INT); INSERT INTO publications (id, title, author, journal, year, cites) VALUES (1, 'Publication Title', 'Author Name', 'Journal Name', 2021, 10);", "reference_sql": "SELECT author, SUM(cites) as total_cites FROM publications WHERE author IN (SELECT name FROM authors WHERE department = 'Mathematics') AND year BETWEEN YEAR(CURRENT_DATE) - 5 AND YEAR(CURRENT_DATE) GROUP BY author ORDER BY total_cites DESC LIMIT 3;", "generated_sql": "SELECT a.name \nFROM authors a\nJOIN publications p ON a.name = p.author\nWHERE a.department = 'Mathematics' AND p.year >= 2018\nGROUP BY a.name\nORDER BY SUM(p.cites) DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT a.name \nFROM authors a\nJOIN publications p ON a.name = p.author\nWHERE a.department = 'Mathematics' AND p.year >= 2018\nGROUP BY a.name\nORDER BY SUM(p.cites) DESC\nLIMIT 3;\n```", "latency_sec": 0.7646632194519043, "total_duration_sec": 0.75764508, "load_duration_sec": 0.013561718, "tokens_prompt": 206, "prompt_eval_sec": 0.011216648, "tokens_completion": 59, "completion_eval_sec": 0.730424421, "tokens_total": 265, "tokens_per_sec": 346.5577959797084, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Generated SQL uses a fixed year filter (p.year >= 2018) while the Reference SQL uses a dynamic range based on CURRENT_DATE (YEAR(CURRENT_DATE) - 5 to YEAR(CURRENT_DATE)), which may include different years. Second, the Reference SQL returns both 'author' and 'total_cites' columns, whereas the Generated SQL only returns 'name' without the aggregated sum. These differences in result structure and filtering criteria make them non-equivalent."}
{"example_id": 592, "sql_complexity": "set operations", "prompt": "How many public healthcare facilities and public parks are there in total, in the 'StateData' schema's 'StateHealthcare' and 'StateParks' tables?", "context": "CREATE SCHEMA StateData; CREATE TABLE StateHealthcare (Name varchar(255), Type varchar(255)); INSERT INTO StateHealthcare (Name, Type) VALUES ('FacilityA', 'Public'), ('FacilityB', 'Public'), ('FacilityC', 'Private'); CREATE TABLE StateParks (Name varchar(255), Type varchar(255)); INSERT INTO StateParks (Name, Type) VALUES ('ParkA', 'Public'), ('ParkB', 'Public'), ('ParkC', 'Private');", "reference_sql": "SELECT COUNT(*) FROM StateData.StateHealthcare WHERE Type = 'Public' UNION ALL SELECT COUNT(*) FROM StateData.StateParks WHERE Type = 'Public';", "generated_sql": "SELECT \n    (SELECT COUNT(*) FROM StateHealthcare WHERE Type = 'Public') + \n    (SELECT COUNT(*) FROM StateParks WHERE Type = 'Public') AS Total_Public_Facilities_And_Parks;", "raw_model_output": "```sql\nSELECT \n    (SELECT COUNT(*) FROM StateHealthcare WHERE Type = 'Public') + \n    (SELECT COUNT(*) FROM StateParks WHERE Type = 'Public') AS Total_Public_Facilities_And_Parks;\n```", "latency_sec": 0.6450953483581543, "total_duration_sec": 0.638206465, "load_duration_sec": 0.014506502, "tokens_prompt": 216, "prompt_eval_sec": 0.011284987, "tokens_completion": 49, "completion_eval_sec": 0.610077213, "tokens_total": 265, "tokens_per_sec": 410.79198706742665, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query returns two separate counts (one for StateHealthcare and one for StateParks) as two rows via UNION ALL, while the generated query returns a single row with the summed total of both counts. The output structure and values differ."}
{"example_id": 1989, "sql_complexity": "single join", "prompt": "What are the names and production dates of garments made from fabrics with a sustainability score over 70, produced after 2021-01-01?", "context": "CREATE TABLE fabrics (id INT, name VARCHAR(50), type VARCHAR(50), sustainability_score INT); INSERT INTO fabrics (id, name, type, sustainability_score) VALUES (1, 'Organic Linen', 'Natural', 80); INSERT INTO fabrics (id, name, type, sustainability_score) VALUES (2, 'Recycled Nylon', 'Synthetic', 72);", "reference_sql": "SELECT garments.name, garments.production_date FROM garments JOIN fabrics ON garments.fabric_id = fabrics.id WHERE fabrics.sustainability_score > 70 AND garments.production_date > '2021-01-01';", "generated_sql": "SELECT g.name AS garment_name, f.production_date\nFROM garments g\nJOIN fabrics f ON g.fabric_id = f.id\nWHERE f.sustainability_score > 70 AND f.type IN ('Natural', 'Synthetic') AND g.production_date > '2021-01-01';", "raw_model_output": "It seems there is no table in the provided schema that contains information about garments or their production dates. However, based on the question, we can assume there might be another table named `garments` with relevant columns such as `fabric_id` and `production_date`. Let's proceed under this assumption.\n\nHere is the SQL query:\n\n```sql\nSELECT g.name AS garment_name, f.production_date\nFROM garments g\nJOIN fabrics f ON g.fabric_id = f.id\nWHERE f.sustainability_score > 70 AND f.type IN ('Natural', 'Synthetic') AND g.production_date > '2021-01-01';\n```\n\nThis query assumes the existence of a `garments` table with columns `name` and `production_date`, and a `fabric_id` that links to the `id` in the `fabrics` table.", "latency_sec": 2.2068610191345215, "total_duration_sec": 2.201267157, "load_duration_sec": 0.013505695, "tokens_prompt": 187, "prompt_eval_sec": 0.009098422, "tokens_completion": 180, "completion_eval_sec": 2.176529689, "tokens_total": 367, "tokens_per_sec": 166.2995525399822, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The generated query incorrectly references 'f.production_date' (fabric table) instead of 'garments.production_date' and adds a redundant 'f.type IN ('Natural', 'Synthetic')' condition not present in the reference query. These differences would produce different results."}
{"example_id": 1388, "sql_complexity": "aggregation", "prompt": "What was the total donation amount by each organization in the last 30 days?", "context": "CREATE TABLE organization_donations (id INT, organization TEXT, donation_date DATE, donation_amount DECIMAL(10,2)); INSERT INTO organization_donations (id, organization, donation_date, donation_amount) VALUES (1, 'Organization A', '2021-03-15', 100.00), (2, 'Organization B', '2021-03-25', 200.00);", "reference_sql": "SELECT organization, SUM(donation_amount) FROM organization_donations WHERE donation_date >= DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY) GROUP BY organization;", "generated_sql": "SELECT \n    organization,\n    SUM(donation_amount) AS total_donation_amount\nFROM \n    organization_donations\nWHERE \n    donation_date >= DATEADD(day, -30, GETDATE())\nGROUP BY \n    organization;", "raw_model_output": "```sql\nSELECT \n    organization,\n    SUM(donation_amount) AS total_donation_amount\nFROM \n    organization_donations\nWHERE \n    donation_date >= DATEADD(day, -30, GETDATE())\nGROUP BY \n    organization;\n```\n\n**Note:** The `DATEADD` and `GETDATE()` functions are specific to SQL Server. If you are using a different database system (e.g., PostgreSQL, MySQL), the date manipulation functions will be different. Here is an example for PostgreSQL:\n\n```sql\nSELECT \n    organization,\n    SUM(donation_amount) AS total_donation_amount\nFROM \n    organization_donations\nWHERE \n    donation_date >= NOW() - INTERVAL '30 days'\nGROUP BY \n    organization;\n```\n\nAnd for MySQL:\n\n```sql\nSELECT \n    organization,\n    SUM(donation_amount) AS total_donation_amount\nFROM \n    organization_donations\nWHERE \n    donation_date >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)\nGROUP BY \n    organization;\n```", "latency_sec": 2.6282529830932617, "total_duration_sec": 2.622314831, "load_duration_sec": 0.013959704, "tokens_prompt": 183, "prompt_eval_sec": 0.009066392, "tokens_completion": 210, "completion_eval_sec": 2.597001913, "tokens_total": 393, "tokens_per_sec": 149.52898466321446, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in date calculation functions. The reference uses MySQL's DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY) which returns a DATE, while the generated uses SQL Server's DATEADD(day, -30, GETDATE()) which returns a DATETIME. This creates a semantic difference: the generated query's condition (donation_date >= DATETIME) may exclude donations on the exact 30-day boundary if their time component is earlier than GETDATE()'s time, whereas the reference query (donation_date >= DATE) includes all donations on that date. The time component difference makes them non-equivalent."}
{"example_id": 1628, "sql_complexity": "window functions", "prompt": "What is the ranking of national security measures for Russia based on the publication date?", "context": "CREATE TABLE national_security (id INT, title VARCHAR(255), description TEXT, agency VARCHAR(255), date DATE); INSERT INTO national_security (id, title, description, agency, date) VALUES (1, 'National Cyber Strategy', 'Outlines the approach to protecting the American people and the American way of life in the digital age', 'White House', '2018-09-20'); INSERT INTO national_security (id, title, description, agency, date) VALUES (2, 'Cybersecurity and Infrastructure Security Agency Act of 2018', 'Establishes the Cybersecurity and Infrastructure Security Agency within the Department of Homeland Security', 'Congress', '2018-11-16'); INSERT INTO national_security (id, title, description, agency, date) VALUES (3, 'Russian Military Doctrine', 'Outlines the country\u2019s stance on military security', 'Russian Government', '2014-12-26');", "reference_sql": "SELECT title, description, agency, date, ROW_NUMBER() OVER (PARTITION BY agency ORDER BY date DESC) as ranking FROM national_security WHERE agency = 'Russian Government';", "generated_sql": "SELECT \n    title, \n    description, \n    agency, \n    date\nFROM \n    national_security\nWHERE \n    agency = 'Russian Government'\nORDER BY \n    date DESC;", "raw_model_output": "```sql\nSELECT \n    title, \n    description, \n    agency, \n    date\nFROM \n    national_security\nWHERE \n    agency = 'Russian Government'\nORDER BY \n    date DESC;\n```", "latency_sec": 0.6258301734924316, "total_duration_sec": 0.617608544, "load_duration_sec": 0.013529643, "tokens_prompt": 292, "prompt_eval_sec": 0.033495967, "tokens_completion": 44, "completion_eval_sec": 0.568253592, "tokens_total": 336, "tokens_per_sec": 536.8868652097091, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a ROW_NUMBER() column as 'ranking' which is absent in the Generated SQL. While both filter for 'Russian Government' and order by date DESC, the additional column in the Reference query makes the result sets structurally different."}
{"example_id": 2300, "sql_complexity": "aggregation", "prompt": "What is the minimum capacity for schools in each location ('community_development')?", "context": "CREATE TABLE community_development.schools (id INT, name VARCHAR(50), capacity INT, location VARCHAR(50));", "reference_sql": "SELECT location, MIN(capacity) FROM community_development.schools GROUP BY location;", "generated_sql": "SELECT location, MIN(capacity) AS min_capacity\nFROM community_development.schools\nGROUP BY location;", "raw_model_output": "```sql\nSELECT location, MIN(capacity) AS min_capacity\nFROM community_development.schools\nGROUP BY location;\n```", "latency_sec": 0.3642749786376953, "total_duration_sec": 0.359057379, "load_duration_sec": 0.015133344, "tokens_prompt": 111, "prompt_eval_sec": 0.008633091, "tokens_completion": 27, "completion_eval_sec": 0.332214615, "tokens_total": 138, "tokens_per_sec": 378.8346938241223, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries group schools by location and retrieve the minimum capacity per group. The generated query adds an explicit column alias (min_capacity) for the MIN(capacity) result, but this does not affect the semantic meaning or the actual data returned. The core logic of grouping and aggregating remains identical."}
{"example_id": 4976, "sql_complexity": "set operations", "prompt": "What is the most common hashtag used in posts made by users from Brazil?", "context": "CREATE TABLE posts (id INT, user_id INT, content TEXT, hashtags TEXT, post_date DATE); INSERT INTO posts (id, user_id, content, hashtags, post_date) VALUES (1, 1, 'Hello World', '#datascience', '2022-06-01'), (2, 1, 'I love data', '#ai', '2022-06-02'), (3, 2, 'Ol\u00e1 Mundo', '#brasil', '2022-06-03'); CREATE TABLE users (id INT, name VARCHAR(100), country VARCHAR(50)); INSERT INTO users (id, name, country) VALUES (1, 'Jo\u00e3o Silva', 'Brazil'), (2, 'Maria Souza', 'Brazil');", "reference_sql": "SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(hashtags, ' ', n.n), ' ', -1) hashtag, COUNT(*) count FROM posts JOIN users ON posts.user_id = users.id CROSS JOIN (SELECT 1 n UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5) n WHERE users.country = 'Brazil' GROUP BY hashtag ORDER BY count DESC LIMIT 1;", "generated_sql": "SELECT \n    hashtags\nFROM \n    posts p\nJOIN \n    users u ON p.user_id = u.id\nWHERE \n    u.country = 'Brazil'\nGROUP BY \n    hashtags\nORDER BY \n    COUNT(hashtags) DESC\nLIMIT 1;", "raw_model_output": "```sql\nSELECT \n    hashtags\nFROM \n    posts p\nJOIN \n    users u ON p.user_id = u.id\nWHERE \n    u.country = 'Brazil'\nGROUP BY \n    hashtags\nORDER BY \n    COUNT(hashtags) DESC\nLIMIT 1;\n```", "latency_sec": 0.7647769451141357, "total_duration_sec": 0.760908866, "load_duration_sec": 0.014980908, "tokens_prompt": 255, "prompt_eval_sec": 0.013137581, "tokens_completion": 58, "completion_eval_sec": 0.730296974, "tokens_total": 313, "tokens_per_sec": 409.26965960419705, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL splits multi-word hashtags (if present) into individual tags using SUBSTRING_INDEX and a numbers table, while the Generated SQL treats the entire hashtags field as a single string. In the provided sample data, all posts have single hashtags, so both queries return the same result. However, if a post contained multiple space-separated hashtags (e.g., '#datascience #ai'), the Reference SQL would count them as separate tags while the Generated SQL would treat them as a single tag. This difference in handling multi-tag entries makes them non-equivalent in general cases."}
{"example_id": 4637, "sql_complexity": "single join", "prompt": "What is the total value of transactions for each customer in the last 30 days?", "context": "CREATE TABLE transactions (id INT, customer_id INT, value DECIMAL(10, 2), transaction_date DATE); INSERT INTO transactions (id, customer_id, value, transaction_date) VALUES (1, 1, 100, '2022-01-01'), (2, 1, 200, '2022-01-15'), (3, 2, 50, '2022-01-05'), (4, 2, 150, '2022-01-30'), (5, 3, 300, '2022-01-20');", "reference_sql": "SELECT c.id, SUM(t.value) FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE t.transaction_date >= CURDATE() - INTERVAL 30 DAY GROUP BY c.id;", "generated_sql": "SELECT \n    customer_id, \n    SUM(value) AS total_value\nFROM \n    transactions\nWHERE \n    transaction_date >= DATEADD(day, -30, GETDATE())\nGROUP BY \n    customer_id;", "raw_model_output": "```sql\nSELECT \n    customer_id, \n    SUM(value) AS total_value\nFROM \n    transactions\nWHERE \n    transaction_date >= DATEADD(day, -30, GETDATE())\nGROUP BY \n    customer_id;\n```\n\n**Note:** The `DATEADD` and `GETDATE()` functions are specific to SQL Server. If you are using a different database system (e.g., PostgreSQL, MySQL), the date arithmetic will be different. Here is an example for PostgreSQL:\n\n```sql\nSELECT \n    customer_id, \n    SUM(value) AS total_value\nFROM \n    transactions\nWHERE \n    transaction_date >= NOW() - INTERVAL '30 days'\nGROUP BY \n    customer_id;\n```\n\nAnd for MySQL:\n\n```sql\nSELECT \n    customer_id, \n    SUM(value) AS total_value\nFROM \n    transactions\nWHERE \n    transaction_date >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)\nGROUP BY \n    customer_id;\n```", "latency_sec": 2.5421528816223145, "total_duration_sec": 2.53626588, "load_duration_sec": 0.020950176, "tokens_prompt": 241, "prompt_eval_sec": 0.012546704, "tokens_completion": 200, "completion_eval_sec": 2.500624029, "tokens_total": 441, "tokens_per_sec": 173.4750113528062, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the total transaction value per customer for the last 30 days. The Reference SQL uses an INNER JOIN with customers and filters using CURDATE() - INTERVAL 30 DAY, while the Generated SQL directly filters transactions with DATEADD(day, -30, GETDATE()). The date functions (CURDATE() vs. GETDATE()) are functionally equivalent in this context, and the INNER JOIN in the Reference SQL is redundant since transactions.customer_id inherently references customers.id. Both queries group by customer_id and sum values, producing identical results."}
{"example_id": 4947, "sql_complexity": "aggregation", "prompt": "What is the total revenue for drugs approved between 2017 and 2019?", "context": "CREATE TABLE drug_sales_3 (drug_name TEXT, revenue FLOAT, year INT); INSERT INTO drug_sales_3 (drug_name, revenue, year) VALUES ('DrugG', 20000000, 2019), ('DrugG', 19000000, 2018), ('DrugH', 15000000, 2017), ('DrugH', 16000000, 2018);", "reference_sql": "SELECT drug_name, SUM(revenue) FROM drug_sales_3 WHERE year BETWEEN 2017 AND 2019 GROUP BY drug_name;", "generated_sql": "SELECT SUM(revenue) AS total_revenue\nFROM drug_sales_3\nWHERE year BETWEEN 2017 AND 2019;", "raw_model_output": "```sql\nSELECT SUM(revenue) AS total_revenue\nFROM drug_sales_3\nWHERE year BETWEEN 2017 AND 2019;\n```", "latency_sec": 0.48941898345947266, "total_duration_sec": 0.481240683, "load_duration_sec": 0.01463819, "tokens_prompt": 202, "prompt_eval_sec": 0.010632603, "tokens_completion": 36, "completion_eval_sec": 0.453210516, "tokens_total": 238, "tokens_per_sec": 486.2909042017331, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL groups results by drug_name and calculates per-drug revenue sums, while the Generated SQL calculates a single total revenue for all drugs combined. The presence/absence of GROUP BY causes fundamentally different output structures (per-drug vs. overall totals)."}
{"example_id": 4767, "sql_complexity": "window functions", "prompt": "List the top 2 AI algorithms with the highest explainability scores, by algorithm subtype, ordered by scores in descending order for the European region.", "context": "CREATE TABLE ai_algorithms (algorithm_id INT, algorithm_name VARCHAR(50), algorithm_subtype VARCHAR(50), region VARCHAR(50), explainability_score FLOAT); INSERT INTO ai_algorithms (algorithm_id, algorithm_name, algorithm_subtype, region, explainability_score) VALUES (1, 'AlgoA', 'Tree-based', 'Europe', 0.85), (2, 'AlgoB', 'Computer Vision', 'Europe', 0.92), (3, 'AlgoC', 'Tree-based', 'Europe', 0.78), (4, 'AlgoD', 'Transformer', 'Europe', 0.90), (5, 'AlgoE', 'Tree-based', 'Europe', 0.80);", "reference_sql": "SELECT algorithm_subtype, region, * FROM (SELECT algorithm_subtype, region, algorithm_id, algorithm_name, explainability_score, RANK() OVER (PARTITION BY algorithm_subtype ORDER BY explainability_score DESC) AS rank FROM ai_algorithms WHERE region = 'Europe') ranked WHERE rank <= 2 ORDER BY algorithm_subtype, region, explainability_score DESC;", "generated_sql": "SELECT algorithm_name, algorithm_subtype, explainability_score\nFROM ai_algorithms\nWHERE region = 'Europe'\nORDER BY algorithm_subtype, explainability_score DESC\nLIMIT 2;", "raw_model_output": "```sql\nSELECT algorithm_name, algorithm_subtype, explainability_score\nFROM ai_algorithms\nWHERE region = 'Europe'\nORDER BY algorithm_subtype, explainability_score DESC\nLIMIT 2;\n```", "latency_sec": 0.564338207244873, "total_duration_sec": 0.559280939, "load_duration_sec": 0.013836209, "tokens_prompt": 259, "prompt_eval_sec": 0.014232181, "tokens_completion": 41, "completion_eval_sec": 0.527847861, "tokens_total": 300, "tokens_per_sec": 531.5961176270782, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL selects top 2 algorithms per algorithm_subtype (using RANK()) within Europe, while the Generated SQL simply returns the first 2 rows after ordering by algorithm_subtype and explainability_score. The Reference SQL ensures 2 entries per subtype (e.g., 2 Tree-based, 1 Computer Vision, 1 Transformer), whereas the Generated SQL might return only 2 entries total (e.g., first two subtypes in alphabetical order). The sample data confirms this discrepancy in results."}
{"example_id": 4495, "sql_complexity": "basic SQL", "prompt": "Which countries are the top 3 sources of sustainable textiles?", "context": "CREATE TABLE Textile_Sources (Source_ID INT, Source_Country TEXT, Sustainable BOOLEAN, Quantity INT); INSERT INTO Textile_Sources (Source_ID, Source_Country, Sustainable, Quantity) VALUES (1, 'India', true, 1000), (2, 'Bangladesh', false, 800), (3, 'China', true, 1200), (4, 'Vietnam', false, 900), (5, 'Italy', true, 1100), (6, 'USA', false, 700);", "reference_sql": "SELECT Source_Country FROM Textile_Sources WHERE Sustainable = true ORDER BY Quantity DESC LIMIT 3;", "generated_sql": "SELECT Source_Country \nFROM Textile_Sources \nWHERE Sustainable = true \nORDER BY Quantity DESC \nLIMIT 3;", "raw_model_output": "```sql\nSELECT Source_Country \nFROM Textile_Sources \nWHERE Sustainable = true \nORDER BY Quantity DESC \nLIMIT 3;\n```", "latency_sec": 0.4352719783782959, "total_duration_sec": 0.427232603, "load_duration_sec": 0.031545833, "tokens_prompt": 205, "prompt_eval_sec": 0.010237563, "tokens_completion": 30, "completion_eval_sec": 0.383246119, "tokens_total": 235, "tokens_per_sec": 539.8923240488524, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select Source_Country from Textile_Sources where Sustainable is true, order by Quantity descending, and limit to 3 results. The only difference is formatting (whitespace), which does not affect semantic equivalence."}
{"example_id": 2513, "sql_complexity": "single join", "prompt": "What is the total number of concert ticket sales for artists who released their first album between 2015 and 2017?", "context": "CREATE TABLE ConcertTicketSales (id INT, year INT, artist_id INT); CREATE TABLE ArtistAlbums (id INT, artist_id INT, year INT);", "reference_sql": "SELECT COUNT(DISTINCT cts.artist_id) FROM ConcertTicketSales cts JOIN ArtistAlbums a ON cts.artist_id = a.artist_id WHERE a.year BETWEEN 2015 AND 2017;", "generated_sql": "SELECT SUM(T1.year - 2000) AS total_sales\nFROM ConcertTicketSales T1\nJOIN ArtistAlbums T2 ON T1.artist_id = T2.artist_id\nWHERE T2.year BETWEEN 2015 AND 2017;", "raw_model_output": "```sql\nSELECT SUM(T1.year - 2000) AS total_sales\nFROM ConcertTicketSales T1\nJOIN ArtistAlbums T2 ON T1.artist_id = T2.artist_id\nWHERE T2.year BETWEEN 2015 AND 2017;\n```\n\n### Explanation:\n- We join the `ConcertTicketSales` table with the `ArtistAlbums` table on `artist_id`.\n- We filter the artists who released their first album between 2015 and 2017 using the condition `T2.year BETWEEN 2015 AND 2017`.\n- To calculate the total number of concert ticket sales, we sum up the values in the `year` column from the `ConcertTicketSales` table. The subtraction by 2000 is used to convert the year into a simpler integer value for summation (e.g., 2015 becomes 15).", "latency_sec": 2.4854800701141357, "total_duration_sec": 2.479681313, "load_duration_sec": 0.01510092, "tokens_prompt": 130, "prompt_eval_sec": 0.00828888, "tokens_completion": 200, "completion_eval_sec": 2.453999627, "tokens_total": 330, "tokens_per_sec": 132.7711310052251, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query counts distinct artist_ids from ConcertTicketSales joined with ArtistAlbums where album year is 2015-2017. The generated query sums (year - 2000) from ConcertTicketSales joined with ArtistAlbums under the same condition. They differ in both the aggregation function (COUNT vs SUM) and the calculated value (artist_id distinct count vs year-based sum)."}
{"example_id": 873, "sql_complexity": "subqueries", "prompt": "Identify attorneys who have never handled cases in the 'West' region but have in the 'North' or 'South'.", "context": "CREATE TABLE attorney_regions(attorney_id INT, region VARCHAR(20)); INSERT INTO attorney_regions(attorney_id, region) VALUES (1, 'North'), (2, 'South'), (3, 'East'), (4, 'West'), (5, 'West'), (6, 'North'); CREATE TABLE handled_cases(attorney_id INT, case_id INT); INSERT INTO handled_cases(attorney_id, case_id) VALUES (1, 101), (2, 102), (3, 103), (4, 104), (5, 105), (6, 106), (1, 107), (1, 108);", "reference_sql": "SELECT h.attorney_id FROM attorney_regions h LEFT JOIN handled_cases i ON h.attorney_id = i.attorney_id WHERE h.region IN ('North', 'South') AND h.region != 'West' AND i.attorney_id IS NOT NULL AND h.attorney_id NOT IN (SELECT attorney_id FROM attorney_regions WHERE region = 'West');", "generated_sql": "SELECT ar.attorney_id\nFROM attorney_regions ar\nWHERE ar.region IN ('North', 'South')\n  AND ar.attorney_id NOT IN (\n    SELECT h.attorney_id\n    FROM handled_cases h\n    INNER JOIN attorney_regions ar2 ON h.attorney_id = ar2.attorney_id\n    WHERE ar2.region = 'West'\n  );", "raw_model_output": "```sql\nSELECT ar.attorney_id\nFROM attorney_regions ar\nWHERE ar.region IN ('North', 'South')\n  AND ar.attorney_id NOT IN (\n    SELECT h.attorney_id\n    FROM handled_cases h\n    INNER JOIN attorney_regions ar2 ON h.attorney_id = ar2.attorney_id\n    WHERE ar2.region = 'West'\n  );\n```", "latency_sec": 1.0000348091125488, "total_duration_sec": 0.99483943, "load_duration_sec": 0.013752154, "tokens_prompt": 245, "prompt_eval_sec": 0.01162601, "tokens_completion": 78, "completion_eval_sec": 0.967385958, "tokens_total": 323, "tokens_per_sec": 322.9887570480039, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a condition (i.attorney_id IS NOT NULL) to ensure attorneys have at least one case, while the Generated SQL does not enforce this. Additionally, the Generated SQL's subquery filters West-region attorneys who have cases, whereas the Reference SQL's subquery excludes all West-region attorneys (regardless of cases). This leads to different result sets."}
{"example_id": 471, "sql_complexity": "set operations", "prompt": "Find the number of donations made by first-time donors in the last quarter.", "context": "CREATE TABLE Donations (DonationID INT, DonorID INT, DonationDate DATE, DonationType TEXT, DonationAmount FLOAT); INSERT INTO Donations (DonationID, DonorID, DonationDate, DonationType, DonationAmount) VALUES (1, 1, '2021-01-01', 'Individual', 100), (2, 2, '2021-02-01', 'Corporate', 5000);", "reference_sql": "SELECT COUNT(*) FROM (SELECT DonationID FROM Donations WHERE DonationType = 'Individual' AND DonationDate >= DATEADD(quarter, -1, CURRENT_DATE) EXCEPT SELECT DonationID FROM PreviousDonations) AS FirstTimeDonors;", "generated_sql": "SELECT COUNT(*) AS NumberOfFirstTimeDonations\nFROM Donations d\nWHERE DonationDate BETWEEN '2020-10-01' AND '2021-12-31'\nAND DonorID IN (\n    SELECT DonorID\n    FROM Donations\n    GROUP BY DonorID\n    HAVING MIN(DonationDate) = MAX(DonationDate)\n);", "raw_model_output": "```sql\nSELECT COUNT(*) AS NumberOfFirstTimeDonations\nFROM Donations d\nWHERE DonationDate BETWEEN '2020-10-01' AND '2021-12-31'\nAND DonorID IN (\n    SELECT DonorID\n    FROM Donations\n    GROUP BY DonorID\n    HAVING MIN(DonationDate) = MAX(DonationDate)\n);\n```", "latency_sec": 1.1034443378448486, "total_duration_sec": 1.094821887, "load_duration_sec": 0.013677122, "tokens_prompt": 187, "prompt_eval_sec": 0.009619227, "tokens_completion": 88, "completion_eval_sec": 1.069292341, "tokens_total": 275, "tokens_per_sec": 249.21963942205372, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL counts 'Individual' donations from the last quarter not present in PreviousDonations, while the Generated SQL counts donations where donors have exactly one donation (MIN(DonationDate) = MAX(DonationDate)) within a specific date range. They differ in date ranges, logic for identifying first-time donors, and use of the PreviousDonations table."}
{"example_id": 1301, "sql_complexity": "multiple_joins", "prompt": "What is the total quantity of corn sold by farmers in 'Summerfield'?", "context": "CREATE TABLE farmers (id INT, name VARCHAR(50), location VARCHAR(50), crops VARCHAR(50)); CREATE TABLE crops (id INT, name VARCHAR(50), yield INT); CREATE TABLE sales (id INT, farmer_id INT, crop_name VARCHAR(50), quantity INT, price DECIMAL(5,2)); INSERT INTO farmers VALUES (1, 'Jane Doe', 'Summerfield', 'Corn'); INSERT INTO crops VALUES (1, 'Corn', 100); INSERT INTO sales VALUES (1, 1, 'Corn', 50, 2.50);", "reference_sql": "SELECT SUM(quantity) FROM sales INNER JOIN farmers ON sales.farmer_id = farmers.id INNER JOIN crops ON sales.crop_name = crops.name WHERE farmers.location = 'Summerfield' AND crops.name = 'Corn';", "generated_sql": "SELECT SUM(s.quantity) AS total_quantity_sold\nFROM sales s\nJOIN farmers f ON s.farmer_id = f.id\nWHERE f.location = 'Summerfield' AND s.crop_name = 'Corn';", "raw_model_output": "```sql\nSELECT SUM(s.quantity) AS total_quantity_sold\nFROM sales s\nJOIN farmers f ON s.farmer_id = f.id\nWHERE f.location = 'Summerfield' AND s.crop_name = 'Corn';\n```", "latency_sec": 0.6317298412322998, "total_duration_sec": 0.628343869, "load_duration_sec": 0.015350759, "tokens_prompt": 211, "prompt_eval_sec": 0.011739524, "tokens_completion": 48, "completion_eval_sec": 0.598363437, "tokens_total": 259, "tokens_per_sec": 409.98538155926764, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes an explicit join with the 'crops' table and filters on 'crops.name = 'Corn'', while the Generated SQL omits this join and relies only on 'sales.crop_name = 'Corn''. This difference could lead to different results if there are sales entries with crop_names not present in the crops table, as the Reference SQL would exclude them while the Generated SQL would include them."}
{"example_id": 4667, "sql_complexity": "aggregation", "prompt": "Find the number of unique organizations in each country in the Philanthropy Trends table?", "context": "CREATE TABLE PhilanthropyTrends (OrgID INT, Name TEXT, Country TEXT);", "reference_sql": "SELECT Country, COUNT(DISTINCT OrgID) as UniqueOrganizations FROM PhilanthropyTrends GROUP BY Country;", "generated_sql": "SELECT Country, COUNT(DISTINCT OrgID) AS UniqueOrganizationsCount\nFROM PhilanthropyTrends\nGROUP BY Country;", "raw_model_output": "```sql\nSELECT Country, COUNT(DISTINCT OrgID) AS UniqueOrganizationsCount\nFROM PhilanthropyTrends\nGROUP BY Country;\n```", "latency_sec": 0.41657400131225586, "total_duration_sec": 0.411527834, "load_duration_sec": 0.015779005, "tokens_prompt": 104, "prompt_eval_sec": 0.008689333, "tokens_completion": 32, "completion_eval_sec": 0.38404187, "tokens_total": 136, "tokens_per_sec": 326.4726064794836, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are semantically equivalent. The only difference is the alias name for the COUNT(DISTINCT OrgID) column (UniqueOrganizations vs. UniqueOrganizationsCount). The GROUP BY clause, aggregate function, and selected columns remain identical, ensuring the same result set structure and data."}
{"example_id": 1006, "sql_complexity": "subqueries", "prompt": "What is the average word count of news articles written by investigative journalists?", "context": "CREATE TABLE reporters (id INT, name VARCHAR(50), gender VARCHAR(10), age INT, position VARCHAR(20), country VARCHAR(50)); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (1, 'Anna Smith', 'Female', 35, 'News Reporter', 'USA'); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (2, 'Mike Johnson', 'Male', 40, 'Investigative Journalist', 'Canada'); INSERT INTO reporters (id, name, gender, age, position, country) VALUES (3, 'Sofia Rodriguez', 'Female', 32, 'Investigative Journalist', 'Mexico'); CREATE TABLE news_articles (id INT, title VARCHAR(100), content TEXT, publication_date DATE, reporter_id INT); INSERT INTO news_articles (id, title, content, publication_date, reporter_id) VALUES (1, 'News Article 1', 'Content of News Article 1', '2021-01-01', 2); INSERT INTO news_articles (id, title, content, publication_date, reporter_id) VALUES (2, 'News Article 2', 'Content of News Article 2', '2021-02-01', 3);", "reference_sql": "SELECT AVG(LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1) AS avg_word_count FROM news_articles WHERE reporter_id IN (SELECT id FROM reporters WHERE position = 'Investigative Journalist');", "generated_sql": "SELECT \n    AVG(LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1) AS average_word_count\nFROM \n    news_articles na\nJOIN \n    reporters r ON na.reporter_id = r.id\nWHERE \n    r.position = 'Investigative Journalist';", "raw_model_output": "```sql\nSELECT \n    AVG(LENGTH(content) - LENGTH(REPLACE(content, ' ', '')) + 1) AS average_word_count\nFROM \n    news_articles na\nJOIN \n    reporters r ON na.reporter_id = r.id\nWHERE \n    r.position = 'Investigative Journalist';\n```", "latency_sec": 0.900723934173584, "total_duration_sec": 0.895817083, "load_duration_sec": 0.013366243, "tokens_prompt": 365, "prompt_eval_sec": 0.020210364, "tokens_completion": 66, "completion_eval_sec": 0.859660261, "tokens_total": 431, "tokens_per_sec": 478.50399400726855, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average word count of news articles written by investigative journalists. The reference query uses a subquery with IN to filter reporter_ids, while the generated query uses a JOIN to achieve the same filtering. The word count calculation (LENGTH(content) - LENGTH(REPLACE(...)) + 1) is identical in both queries. The logical result set and aggregation are equivalent."}
{"example_id": 3635, "sql_complexity": "set operations", "prompt": "Which brands have certifications related to cruelty-free, vegan, or organic products?", "context": "CREATE TABLE brands (brand_name VARCHAR(50), is_cruelty_free BOOLEAN, is_vegan BOOLEAN, is_organic BOOLEAN); INSERT INTO brands (brand_name, is_cruelty_free, is_vegan, is_organic) VALUES ('Lush', TRUE, TRUE, FALSE), ('The Body Shop', TRUE, FALSE, FALSE), ('Est\u00e9e Lauder', FALSE, FALSE, FALSE), ('Urban Decay', TRUE, TRUE, FALSE), ('Maybelline', FALSE, FALSE, FALSE), ('Kat Von D', TRUE, TRUE, FALSE), ('Tarte', TRUE, TRUE, TRUE);", "reference_sql": "SELECT brand_name, 'Cruelty-free' as certification FROM brands WHERE is_cruelty_free = TRUE UNION SELECT brand_name, 'Vegan' as certification FROM brands WHERE is_vegan = TRUE UNION SELECT brand_name, 'Organic' as certification FROM brands WHERE is_organic = TRUE;", "generated_sql": "SELECT brand_name \nFROM brands \nWHERE is_cruelty_free OR is_vegan OR is_organic;", "raw_model_output": "```sql\nSELECT brand_name \nFROM brands \nWHERE is_cruelty_free OR is_vegan OR is_organic;\n```", "latency_sec": 0.39102983474731445, "total_duration_sec": 0.387244311, "load_duration_sec": 0.01459312, "tokens_prompt": 211, "prompt_eval_sec": 0.011469586, "tokens_completion": 28, "completion_eval_sec": 0.357783621, "tokens_total": 239, "tokens_per_sec": 611.2065596080234, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns each brand once per certification type they meet (e.g., a brand with all three certifications would have 3 rows), while the Generated SQL returns each brand only once if they meet any of the conditions. The output structures and row counts differ."}
{"example_id": 4932, "sql_complexity": "basic SQL", "prompt": "Delete the workout row with the id of 2.", "context": "CREATE TABLE Workouts (id INT, user_id INT, workout_name TEXT, calories INT); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (1, 1, 'Running', 300); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (2, 1, 'Cycling', 400); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (3, 2, 'Yoga', 200);", "reference_sql": "DELETE FROM Workouts WHERE id = 2;", "generated_sql": "DELETE FROM Workouts WHERE id = 2;", "raw_model_output": "DELETE FROM Workouts WHERE id = 2;", "latency_sec": 0.19937777519226074, "total_duration_sec": 0.194140041, "load_duration_sec": 0.024916601, "tokens_prompt": 191, "prompt_eval_sec": 0.010927377, "tokens_completion": 11, "completion_eval_sec": 0.155718337, "tokens_total": 202, "tokens_per_sec": 1013.1520416716991, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They both delete the record from the Workouts table where the id is 2. The SQL syntax, table name, and WHERE condition are exactly the same in both queries."}
{"example_id": 365, "sql_complexity": "aggregation", "prompt": "Identify the total number of military personnel and their corresponding rank for each branch and country in the 'military_personnel' table, sorted by the total number of personnel in descending order.", "context": "CREATE TABLE military_personnel (id INT, branch VARCHAR(255), rank VARCHAR(255), country VARCHAR(255), personnel INT);", "reference_sql": "SELECT branch, country, SUM(personnel) as total_personnel FROM military_personnel GROUP BY branch, country ORDER BY total_personnel DESC;", "generated_sql": "SELECT \n    branch, \n    rank, \n    SUM(personnel) AS total_personnel\nFROM \n    military_personnel\nGROUP BY \n    branch, \n    rank\nORDER BY \n    total_personnel DESC;", "raw_model_output": "```sql\nSELECT \n    branch, \n    rank, \n    SUM(personnel) AS total_personnel\nFROM \n    military_personnel\nGROUP BY \n    branch, \n    rank\nORDER BY \n    total_personnel DESC;\n```", "latency_sec": 0.6474356651306152, "total_duration_sec": 0.64387516, "load_duration_sec": 0.015156335, "tokens_prompt": 140, "prompt_eval_sec": 0.008202614, "tokens_completion": 51, "completion_eval_sec": 0.617304411, "tokens_total": 191, "tokens_per_sec": 295.01000684209635, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in grouping columns (branch+country vs. branch+rank) and selected columns (country vs. rank). The reference query aggregates personnel by branch-country combinations, while the generated query aggregates by branch-rank combinations. This leads to different result structures and values."}
{"example_id": 521, "sql_complexity": "subqueries", "prompt": "How many vessels have not had an inspection in the past year?", "context": "CREATE TABLE safety_records(id INT, vessel_name VARCHAR(50), inspection_date DATE); CREATE TABLE vessels(id INT, name VARCHAR(50), country VARCHAR(50)); INSERT INTO vessels(id, name, country) VALUES (1, 'Vessel A', 'Philippines'), (2, 'Vessel B', 'Philippines'); INSERT INTO safety_records(id, vessel_name, inspection_date) VALUES (1, 'Vessel A', '2022-01-01');", "reference_sql": "SELECT COUNT(*) FROM vessels WHERE name NOT IN (SELECT vessel_name FROM safety_records WHERE inspection_date BETWEEN DATE_SUB(NOW(), INTERVAL 1 YEAR) AND NOW());", "generated_sql": "SELECT COUNT(*) AS number_of_vessels_without_inspection\nFROM vessels v\nLEFT JOIN safety_records sr ON v.name = sr.vessel_name\nWHERE sr.inspection_date < DATEADD(year, -1, GETDATE());", "raw_model_output": "```sql\nSELECT COUNT(*) AS number_of_vessels_without_inspection\nFROM vessels v\nLEFT JOIN safety_records sr ON v.name = sr.vessel_name\nWHERE sr.inspection_date < DATEADD(year, -1, GETDATE());\n```\n\n**Explanation:**\n- The `vessels` table is joined with the `safety_records` table using a left join to include all vessels even if they haven't had an inspection.\n- The condition `sr.inspection_date < DATEADD(year, -1, GETDATE())` checks if there has been no inspection in the past year. \n- `GETDATE()` is used to get the current date and time, and `DATEADD(year, -1, GETDATE())` subtracts one year from it.\n- The `COUNT(*)` function counts the number of vessels that do not have an inspection in the past year.", "latency_sec": 2.2948520183563232, "total_duration_sec": 2.289219556, "load_duration_sec": 0.014819685, "tokens_prompt": 185, "prompt_eval_sec": 0.011314866, "tokens_completion": 183, "completion_eval_sec": 2.260934677, "tokens_total": 368, "tokens_per_sec": 160.35892382445567, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL counts vessels not having any inspections in the last year (using NOT IN with a subquery). The Generated SQL uses a LEFT JOIN and filters for inspections older than a year, which would include vessels with at least one old inspection but exclude those with no inspections at all. Additionally, the Generated SQL's WHERE clause excludes NULLs from the LEFT JOIN, whereas the Reference SQL's NOT IN would include vessels with no records in safety_records. The logic differs in handling vessels with no inspections and multiple inspection records."}
{"example_id": 5687, "sql_complexity": "multiple_joins", "prompt": "List organizations with more than 200 volunteers, and their average donation amounts, excluding donations less than $10.", "context": "CREATE TABLE organizations (org_id INT, org_name TEXT, social_impact_score INT);CREATE TABLE volunteers (vol_id INT, org_id INT, vol_country TEXT);CREATE TABLE donations (donation_id INT, donor_id INT, donation_amount INT, donation_date DATE);", "reference_sql": "SELECT o.org_name, AVG(donation_amount) AS avg_donation_amount FROM organizations o JOIN volunteers v ON o.org_id = v.org_id JOIN donations don ON o.org_id = don.org_id WHERE donation_amount >= 10 GROUP BY o.org_name HAVING COUNT(v.vol_id) > 200;", "generated_sql": "SELECT \n    o.org_name,\n    AVG(d.donation_amount) AS avg_donation_amount\nFROM \n    organizations o\nJOIN \n    volunteers v ON o.org_id = v.org_id\nJOIN \n    donations d ON o.org_id = d.donor_id\nWHERE \n    v.vol_country IS NOT NULL\nGROUP BY \n    o.org_name\nHAVING \n    COUNT(v.vol_id) > 200 AND AVG(d.donation_amount) > 10;", "raw_model_output": "```sql\nSELECT \n    o.org_name,\n    AVG(d.donation_amount) AS avg_donation_amount\nFROM \n    organizations o\nJOIN \n    volunteers v ON o.org_id = v.org_id\nJOIN \n    donations d ON o.org_id = d.donor_id\nWHERE \n    v.vol_country IS NOT NULL\nGROUP BY \n    o.org_name\nHAVING \n    COUNT(v.vol_id) > 200 AND AVG(d.donation_amount) > 10;\n```", "latency_sec": 1.3056118488311768, "total_duration_sec": 1.299593778, "load_duration_sec": 0.015214522, "tokens_prompt": 149, "prompt_eval_sec": 0.009836657, "tokens_completion": 104, "completion_eval_sec": 1.271703959, "tokens_total": 253, "tokens_per_sec": 193.77887863570882, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in several key aspects. 1) The join condition between organizations and donations is different (org_id vs. donor_id). 2) The Reference SQL filters donations with amount >= 10, while the Generated SQL filters on average donation amount > 10 in the HAVING clause. 3) The Generated SQL includes an additional condition on vol_country IS NOT NULL. These differences will lead to different results."}
{"example_id": 1281, "sql_complexity": "subqueries", "prompt": "Find the top 3 contributors with the lowest recycling rate in the 'waste_contributors' table.", "context": "CREATE TABLE waste_contributors (contributor VARCHAR(20), recycling_rate FLOAT); INSERT INTO waste_contributors (contributor, recycling_rate) VALUES ('Manufacturing', 0.4), ('Commercial', 0.38), ('Residential', 0.35), ('Institutional', 0.32), ('Agricultural', 0.2), ('Industrial', 0.15);", "reference_sql": "SELECT contributor FROM waste_contributors WHERE recycling_rate IN (SELECT MIN(recycling_rate) FROM waste_contributors) LIMIT 3;", "generated_sql": "SELECT contributor, recycling_rate\nFROM waste_contributors\nORDER BY recycling_rate ASC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT contributor, recycling_rate\nFROM waste_contributors\nORDER BY recycling_rate ASC\nLIMIT 3;\n```", "latency_sec": 0.37038493156433105, "total_duration_sec": 0.363256118, "load_duration_sec": 0.018680857, "tokens_prompt": 178, "prompt_eval_sec": 0.014166895, "tokens_completion": 26, "completion_eval_sec": 0.326395823, "tokens_total": 204, "tokens_per_sec": 550.7783460261203, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL selects contributors with the minimum recycling rate (only 'Industrial' in the data) and limits to 3 rows. The Generated SQL returns the 3 contributors with the lowest recycling rates (Industrial, Agricultural, Institutional) including their rates. The queries differ in both returned columns (contributor vs. contributor+recycling_rate) and result content (1 row vs. 3 rows)."}
{"example_id": 5669, "sql_complexity": "window functions", "prompt": "What is the total number of new and returning volunteers in each program in each month?", "context": "CREATE TABLE Volunteers (VolunteerID INT, VolunteerName TEXT, ProgramID INT, VolunteerDate DATE, IsReturning BOOLEAN); INSERT INTO Volunteers (VolunteerID, VolunteerName, ProgramID, VolunteerDate, IsReturning) VALUES (6, 'David Kim', 1, '2022-03-01', FALSE), (7, 'Emily Chen', 2, '2022-03-15', TRUE), (8, 'James Lee', 2, '2022-04-01', FALSE), (9, 'Grace Park', 3, '2022-04-15', TRUE), (10, 'Daniel Kim', 1, '2022-04-01', FALSE);", "reference_sql": "SELECT ProgramID, EXTRACT(MONTH FROM VolunteerDate) AS Month, SUM(CASE WHEN IsReturning THEN 1 ELSE 0 END) OVER (PARTITION BY ProgramID, EXTRACT(MONTH FROM VolunteerDate) ORDER BY ProgramID, EXTRACT(MONTH FROM VolunteerDate)) + COUNT(DISTINCT VolunteerID) OVER (PARTITION BY ProgramID, EXTRACT(MONTH FROM VolunteerDate) ORDER BY ProgramID, EXTRACT(MONTH FROM VolunteerDate)) AS TotalVolunteers FROM Volunteers;", "generated_sql": "SELECT \n    ProgramID,\n    EXTRACT(MONTH FROM VolunteerDate) AS Month,\n    SUM(CASE WHEN IsReturning THEN 1 ELSE 0 END) AS ReturningVolunteers,\n    SUM(CASE WHEN NOT IsReturning THEN 1 ELSE 0 END) AS NewVolunteers\nFROM \n    Volunteers\nGROUP BY \n    ProgramID, \n    EXTRACT(MONTH FROM VolunteerDate);", "raw_model_output": "```sql\nSELECT \n    ProgramID,\n    EXTRACT(MONTH FROM VolunteerDate) AS Month,\n    SUM(CASE WHEN IsReturning THEN 1 ELSE 0 END) AS ReturningVolunteers,\n    SUM(CASE WHEN NOT IsReturning THEN 1 ELSE 0 END) AS NewVolunteers\nFROM \n    Volunteers\nGROUP BY \n    ProgramID, \n    EXTRACT(MONTH FROM VolunteerDate);\n```", "latency_sec": 1.1269330978393555, "total_duration_sec": 1.12086266, "load_duration_sec": 0.01314882, "tokens_prompt": 253, "prompt_eval_sec": 0.011868488, "tokens_completion": 88, "completion_eval_sec": 1.093648698, "tokens_total": 341, "tokens_per_sec": 302.5911659297184, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL uses window functions to calculate a running total (SUM with ORDER BY) and adds it to a COUNT(DISTINCT) over partitions, while the Generated SQL groups data and calculates separate aggregates for returning and new volunteers. The Reference query's output structure and calculation logic differ significantly, including cumulative sums vs. grouped totals."}
{"example_id": 3576, "sql_complexity": "window functions", "prompt": "What is the difference in the number of eco-friendly hotels between the top 2 countries?", "context": "CREATE TABLE eco_hotel_count (country TEXT, num_hotels INT); INSERT INTO eco_hotel_count (country, num_hotels) VALUES ('France', 100), ('Italy', 120), ('Germany', 150), ('Spain', 110), ('UK', 160);", "reference_sql": "SELECT (MAX(num_hotels) OVER (PARTITION BY num_hotels <= 2) - MIN(num_hotels) OVER (PARTITION BY num_hotels <= 2)) AS hotel_difference FROM eco_hotel_count WHERE country IN ('France', 'Italy');", "generated_sql": "SELECT \n    (SELECT num_hotels FROM eco_hotel_count ORDER BY num_hotels DESC LIMIT 1) - \n    (SELECT num_hotels FROM eco_hotel_count ORDER BY num_hotels DESC LIMIT 1 OFFSET 1) AS difference;", "raw_model_output": "```sql\nSELECT \n    (SELECT num_hotels FROM eco_hotel_count ORDER BY num_hotels DESC LIMIT 1) - \n    (SELECT num_hotels FROM eco_hotel_count ORDER BY num_hotels DESC LIMIT 1 OFFSET 1) AS difference;\n```\n\nThis SQL query calculates the difference in the number of eco-friendly hotels between the country with the most hotels and the country with the second-most hotels.", "latency_sec": 1.0927691459655762, "total_duration_sec": 1.083675428, "load_duration_sec": 0.024568726, "tokens_prompt": 156, "prompt_eval_sec": 0.009333727, "tokens_completion": 87, "completion_eval_sec": 1.047548573, "tokens_total": 243, "tokens_per_sec": 222.37084648403393, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the difference between the maximum and minimum num_hotels for countries 'France' and 'Italy' (120 - 100 = 20). The Generated SQL computes the difference between the top two num_hotels in the entire table (160 - 150 = 10). The WHERE clause in the Reference SQL restricts data to specific countries, while the Generated SQL operates on all rows, leading to different results."}
{"example_id": 1970, "sql_complexity": "multiple_joins", "prompt": "List all players who have played a specific VR game, 'CyberSphere', and their ages.", "context": "CREATE TABLE Players (PlayerID INT, Age INT, Gender VARCHAR(10), Country VARCHAR(50)); CREATE TABLE VRPlayers (PlayerID INT, VRGameID INT); CREATE TABLE VRGames (VRGameID INT, Title VARCHAR(50)); INSERT INTO Players (PlayerID, Age, Gender, Country) VALUES (1, 25, 'Male', 'USA'); INSERT INTO Players (PlayerID, Age, Gender, Country) VALUES (2, 28, 'Female', 'Canada'); INSERT INTO VRPlayers (PlayerID, VRGameID) VALUES (1, 1); INSERT INTO VRPlayers (PlayerID, VRGameID) VALUES (2, 1); INSERT INTO VRGames (VRGameID, Title) VALUES (1, 'CyberSphere');", "reference_sql": "SELECT Players.Age, Players.PlayerID FROM Players INNER JOIN VRPlayers ON Players.PlayerID = VRPlayers.PlayerID INNER JOIN VRGames ON VRPlayers.VRGameID = VRGames.VRGameID WHERE VRGames.Title = 'CyberSphere';", "generated_sql": "SELECT P.PlayerID, P.Age \nFROM Players P\nJOIN VRPlayers V ON P.PlayerID = V.PlayerID\nJOIN VRGames VG ON V.VRGameID = VG.VRGameID\nWHERE VG.Title = 'CyberSphere';", "raw_model_output": "```sql\nSELECT P.PlayerID, P.Age \nFROM Players P\nJOIN VRPlayers V ON P.PlayerID = V.PlayerID\nJOIN VRGames VG ON V.VRGameID = VG.VRGameID\nWHERE VG.Title = 'CyberSphere';\n```", "latency_sec": 0.7475769519805908, "total_duration_sec": 0.740796236, "load_duration_sec": 0.015711563, "tokens_prompt": 254, "prompt_eval_sec": 0.013907356, "tokens_completion": 56, "completion_eval_sec": 0.708924418, "tokens_total": 310, "tokens_per_sec": 414.6730302194341, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns (PlayerID and Age) from the Players table, join with VRPlayers and VRGames on identical conditions, and filter using the same WHERE clause (VG.Title = 'CyberSphere'). The differences are purely syntactic (alias names and column order in SELECT), which do not affect the semantic result."}
{"example_id": 2414, "sql_complexity": "window functions", "prompt": "List the policy areas with the lowest citizen satisfaction scores.", "context": "CREATE TABLE Policy (Area VARCHAR(20), Score INT); INSERT INTO Policy (Area, Score) VALUES ('Transportation', 70), ('Education', 85), ('Healthcare', 75), ('PublicSafety', 80);", "reference_sql": "SELECT Area, Score FROM (SELECT Area, Score, ROW_NUMBER() OVER (ORDER BY Score) AS RN FROM Policy) X WHERE RN IN (1, 2);", "generated_sql": "SELECT Area \nFROM Policy \nWHERE Score = (SELECT MIN(Score) FROM Policy);", "raw_model_output": "```sql\nSELECT Area \nFROM Policy \nWHERE Score = (SELECT MIN(Score) FROM Policy);\n```", "latency_sec": 0.32364702224731445, "total_duration_sec": 0.32003953, "load_duration_sec": 0.02825287, "tokens_prompt": 133, "prompt_eval_sec": 0.00798601, "tokens_completion": 23, "completion_eval_sec": 0.28150511, "tokens_total": 156, "tokens_per_sec": 482.006597548093, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns the top 2 policies with the lowest scores (using ROW_NUMBER()), while the Generated SQL only returns the policy with the absolute minimum score. The first query retrieves two rows (Transportation and Healthcare) and the second only one row (Transportation)."}
{"example_id": 1898, "sql_complexity": "single join", "prompt": "What are the total sales for each drug in Q2 2020?", "context": "CREATE TABLE drugs (drug_id INT, drug_name TEXT); INSERT INTO drugs (drug_id, drug_name) VALUES (1001, 'Ibuprofen'), (1002, 'Paracetamol'), (1003, 'Aspirin'); CREATE TABLE sales (sale_id INT, drug_id INT, sale_date DATE, revenue FLOAT); INSERT INTO sales (sale_id, drug_id, sale_date, revenue) VALUES (1, 1001, '2020-04-05', 1800.0), (2, 1002, '2020-04-10', 2300.0), (3, 1003, '2020-04-15', 1400.0), (4, 1001, '2020-05-20', 1900.0), (5, 1002, '2020-06-25', 2400.0);", "reference_sql": "SELECT drug_name, SUM(revenue) as total_sales FROM sales JOIN drugs ON sales.drug_id = drugs.drug_id WHERE sale_date BETWEEN '2020-04-01' AND '2020-06-30' GROUP BY drug_name;", "generated_sql": "SELECT \n    d.drug_name,\n    SUM(s.revenue) AS total_sales\nFROM \n    drugs d\nJOIN \n    sales s ON d.drug_id = s.drug_id\nWHERE \n    s.sale_date BETWEEN '2020-04-01' AND '2020-06-30'\nGROUP BY \n    d.drug_name;", "raw_model_output": "```sql\nSELECT \n    d.drug_name,\n    SUM(s.revenue) AS total_sales\nFROM \n    drugs d\nJOIN \n    sales s ON d.drug_id = s.drug_id\nWHERE \n    s.sale_date BETWEEN '2020-04-01' AND '2020-06-30'\nGROUP BY \n    d.drug_name;\n```", "latency_sec": 1.132108211517334, "total_duration_sec": 1.128464703, "load_duration_sec": 0.015939151, "tokens_prompt": 324, "prompt_eval_sec": 0.01641149, "tokens_completion": 86, "completion_eval_sec": 1.093949363, "tokens_total": 410, "tokens_per_sec": 362.1561930466771, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between 'drugs' and 'sales' on drug_id, filter sales between '2020-04-01' and '2020-06-30', and group by drug_name to calculate total sales. The differences are purely syntactic (table aliases and column reference styles) and do not affect the result."}
{"example_id": 2403, "sql_complexity": "multiple_joins", "prompt": "Who is the most frequent customer ordering vegetarian items?", "context": "CREATE TABLE customers (customer_id INT, customer_name VARCHAR(50)); INSERT INTO customers VALUES (1, 'John Doe'), (2, 'Jane Smith'), (3, 'Alice Johnson'); CREATE TABLE orders (order_id INT, customer_id INT, menu_id INT, order_date DATE); INSERT INTO orders VALUES (1, 1, 1, '2022-01-01'), (2, 2, 3, '2022-01-02'), (3, 3, 2, '2022-01-03'); CREATE TABLE menu (menu_id INT, item_name VARCHAR(50), is_vegetarian BOOLEAN, price DECIMAL(5,2)); INSERT INTO menu VALUES (1, 'Veggie Burger', true, 8.99), (2, 'Cheeseburger', false, 7.99), (3, 'Tofu Stir Fry', true, 11.99);", "reference_sql": "SELECT customers.customer_name, COUNT(orders.order_id) as order_count FROM customers INNER JOIN orders ON customers.customer_id = orders.customer_id INNER JOIN menu ON orders.menu_id = menu.menu_id WHERE menu.is_vegetarian = true GROUP BY customers.customer_name ORDER BY order_count DESC LIMIT 1;", "generated_sql": "SELECT c.customer_name\nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nJOIN menu m ON o.menu_id = m.menu_id\nWHERE m.is_vegetarian = true\nGROUP BY c.customer_id, c.customer_name\nORDER BY COUNT(o.order_id) DESC\nLIMIT 1;", "raw_model_output": "```sql\nSELECT c.customer_name\nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nJOIN menu m ON o.menu_id = m.menu_id\nWHERE m.is_vegetarian = true\nGROUP BY c.customer_id, c.customer_name\nORDER BY COUNT(o.order_id) DESC\nLIMIT 1;\n```", "latency_sec": 0.936877965927124, "total_duration_sec": 0.932325679, "load_duration_sec": 0.0152713, "tokens_prompt": 291, "prompt_eval_sec": 0.016199656, "tokens_completion": 70, "completion_eval_sec": 0.898204386, "tokens_total": 361, "tokens_per_sec": 385.3223291923174, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their GROUP BY clauses. The Reference SQL groups by customer_name, which may not be unique, potentially aggregating orders for customers with the same name. The Generated SQL groups by both customer_id (unique) and customer_name, ensuring accurate aggregation per customer. While the sample data shows unique names, the semantic equivalence depends on the uniqueness of customer_name, which is not guaranteed by the schema. Thus, they are not strictly equivalent."}
{"example_id": 124, "sql_complexity": "set operations", "prompt": "Find the intersection of AI and accessibility research projects in the EU and those in Africa.", "context": "CREATE SCHEMA if not exists accessibility; CREATE TABLE if not exists accessibility.research (id INT PRIMARY KEY, project_name VARCHAR(255), region VARCHAR(255)); INSERT INTO accessibility.research (id, project_name, region) VALUES (1, 'AI for Accessibility EU', 'EU'), (2, 'Accessibility Africa', 'Africa'), (3, 'AI for Accessibility Africa', 'Africa'), (4, 'Accessibility EU', 'EU');", "reference_sql": "SELECT project_name FROM accessibility.research WHERE region = 'EU' INTERSECT SELECT project_name FROM accessibility.research WHERE region = 'Africa';", "generated_sql": "SELECT project_name\nFROM accessibility.research\nWHERE region = 'EU' AND project_name LIKE '%AI for Accessibility%'\nINTERSECT\nSELECT project_name\nFROM accessibility.research\nWHERE region = 'Africa' AND project_name LIKE '%AI for Accessibility%';", "raw_model_output": "```sql\nSELECT project_name\nFROM accessibility.research\nWHERE region = 'EU' AND project_name LIKE '%AI for Accessibility%'\nINTERSECT\nSELECT project_name\nFROM accessibility.research\nWHERE region = 'Africa' AND project_name LIKE '%AI for Accessibility%';\n```", "latency_sec": 0.7515828609466553, "total_duration_sec": 0.746716508, "load_duration_sec": 0.015342392, "tokens_prompt": 181, "prompt_eval_sec": 0.00977854, "tokens_completion": 58, "completion_eval_sec": 0.719333207, "tokens_total": 239, "tokens_per_sec": 317.9955430316331, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query finds project names present in both 'EU' and 'Africa' regions without any name restrictions. The generated query adds a LIKE condition filtering project names containing 'AI for Accessibility' in both regions. This makes the generated query more restrictive, potentially returning a different (smaller) result set. For example, in the sample data, the reference query would return no rows (no overlapping project names between regions), while the generated query would also return no rows, but this depends on the data. The additional filters make them non-equivalent in general."}
{"example_id": 1231, "sql_complexity": "basic SQL", "prompt": "What is the average ticket price for performances at the 'Downtown Theater'?", "context": "CREATE TABLE DowntownTheater (show_name TEXT, date DATE, ticket_price FLOAT); INSERT INTO DowntownTheater (show_name, date, ticket_price) VALUES ('Play 1', '2022-01-01', 30.0), ('Play 2', '2022-01-02', 40.0), ('Concert 1', '2022-01-03', 50.0);", "reference_sql": "SELECT AVG(ticket_price) FROM DowntownTheater WHERE show_name = 'Downtown Theater'", "generated_sql": "SELECT AVG(ticket_price) AS average_ticket_price FROM DowntownTheater;", "raw_model_output": "SELECT AVG(ticket_price) AS average_ticket_price FROM DowntownTheater;", "latency_sec": 0.22722625732421875, "total_duration_sec": 0.222773356, "load_duration_sec": 0.015383871, "tokens_prompt": 187, "prompt_eval_sec": 0.009343214, "tokens_completion": 15, "completion_eval_sec": 0.195906108, "tokens_total": 202, "tokens_per_sec": 888.9817681227546, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters for show_name = 'Downtown Theater' which doesn't exist in the sample data (the actual shows are 'Play 1', 'Play 2', 'Concert 1'), resulting in no rows and a NULL average. The Generated SQL calculates the average of all ticket prices in the table (30, 40, 50) which equals 40.0. The presence of the WHERE clause in the Reference SQL changes the dataset being aggregated, making the queries non-equivalent."}
{"example_id": 1485, "sql_complexity": "set operations", "prompt": "How many public schools and public libraries exist in total, in the 'CityData' schema's 'CityEducation' and 'CityLibrary' tables?", "context": "CREATE SCHEMA CityData; CREATE TABLE CityEducation (Name varchar(255), Type varchar(255)); INSERT INTO CityEducation (Name, Type) VALUES ('SchoolA', 'Public'), ('SchoolB', 'Public'), ('SchoolC', 'Private'); CREATE TABLE CityLibrary (Name varchar(255), Type varchar(255)); INSERT INTO CityLibrary (Name, Type) VALUES ('LibraryA', 'Public'), ('LibraryB', 'Public'), ('LibraryC', 'Private');", "reference_sql": "SELECT COUNT(*) FROM CityData.CityEducation WHERE Type = 'Public' UNION ALL SELECT COUNT(*) FROM CityData.CityLibrary WHERE Type = 'Public';", "generated_sql": "SELECT \n    (SELECT COUNT(*) FROM CityEducation WHERE Type = 'Public') + \n    (SELECT COUNT(*) FROM CityLibrary WHERE Type = 'Public') AS Total_Public_Schools_Libraries;", "raw_model_output": "```sql\nSELECT \n    (SELECT COUNT(*) FROM CityEducation WHERE Type = 'Public') + \n    (SELECT COUNT(*) FROM CityLibrary WHERE Type = 'Public') AS Total_Public_Schools_Libraries;\n```", "latency_sec": 0.6176671981811523, "total_duration_sec": 0.61109533, "load_duration_sec": 0.013050963, "tokens_prompt": 205, "prompt_eval_sec": 0.013105511, "tokens_completion": 46, "completion_eval_sec": 0.581791088, "tokens_total": 251, "tokens_per_sec": 406.3677021203667, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate counts (one for CityEducation and one for CityLibrary) as two rows, while the Generated SQL returns a single row with the sum of both counts. The output structure and values differ, making them non-equivalent."}
{"example_id": 5806, "sql_complexity": "single join", "prompt": "List the top 3 countries with the most veteran employment in the IT industry", "context": "CREATE TABLE veteran_employment (employee_id INT, industry VARCHAR(255), salary DECIMAL(10,2), state VARCHAR(2), country VARCHAR(255)); CREATE TABLE countries (country_id INT, country VARCHAR(255));", "reference_sql": "SELECT country, COUNT(*) as num_veterans FROM veteran_employment JOIN countries ON veteran_employment.country = countries.country WHERE industry = 'IT' GROUP BY country ORDER BY num_veterans DESC LIMIT 3;", "generated_sql": "SELECT c.country, COUNT(v.employee_id) AS employment_count\nFROM veteran_employment v\nJOIN countries c ON v.country = c.country\nWHERE v.industry = 'IT'\nGROUP BY c.country\nORDER BY employment_count DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT c.country, COUNT(v.employee_id) AS employment_count\nFROM veteran_employment v\nJOIN countries c ON v.country = c.country\nWHERE v.industry = 'IT'\nGROUP BY c.country\nORDER BY employment_count DESC\nLIMIT 3;\n```", "latency_sec": 0.7174110412597656, "total_duration_sec": 0.712999588, "load_duration_sec": 0.015482434, "tokens_prompt": 138, "prompt_eval_sec": 0.00789285, "tokens_completion": 57, "completion_eval_sec": 0.687185865, "tokens_total": 195, "tokens_per_sec": 271.81070374604525, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the top 3 countries with the highest number of IT industry veterans. They perform an inner join between veteran_employment and countries on the country column, filter for industry 'IT', group by country, and order by the count in descending order. The differences are purely syntactic (table aliases, column aliases) and do not affect the semantic result."}
{"example_id": 4126, "sql_complexity": "window functions", "prompt": "What is the average crime rate per capita in each neighborhood?", "context": "CREATE TABLE neighborhoods (name VARCHAR(255), population INT, crime_count INT); INSERT INTO neighborhoods (name, population, crime_count) VALUES ('Central Park', 1000, 25), ('Harlem', 2500, 75), ('Brooklyn', 5000, 120);", "reference_sql": "SELECT name, AVG(crime_count/population) OVER (PARTITION BY name) FROM neighborhoods;", "generated_sql": "SELECT \n    name,\n    crime_count / population AS crime_rate_per_capita\nFROM \n    neighborhoods;", "raw_model_output": "```sql\nSELECT \n    name,\n    crime_count / population AS crime_rate_per_capita\nFROM \n    neighborhoods;\n```", "latency_sec": 0.36403894424438477, "total_duration_sec": 0.358918787, "load_duration_sec": 0.013581745, "tokens_prompt": 154, "prompt_eval_sec": 0.00985007, "tokens_completion": 27, "completion_eval_sec": 0.332793546, "tokens_total": 181, "tokens_per_sec": 497.19955203059817, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses an AVG() window function that calculates the average of crime_count/population within each name partition, while the Generated SQL directly computes crime_count/population. If there are multiple rows with the same name, the Reference SQL would return averaged values whereas the Generated SQL would return individual ratios. Even though sample data might show similar results, they are not semantically equivalent in all cases."}
{"example_id": 4559, "sql_complexity": "basic SQL", "prompt": "List the top 3 energy efficient appliances in the US by energy star rating?", "context": "CREATE TABLE appliances (id INT, name VARCHAR(255), country VARCHAR(255), energy_star_rating INT); INSERT INTO appliances (id, name, country, energy_star_rating) VALUES (1, 'Fridge A', 'USA', 5), (2, 'TV B', 'USA', 4), (3, 'Laptop C', 'USA', 5), (4, 'Microwave D', 'USA', 3);", "reference_sql": "SELECT name, energy_star_rating FROM appliances WHERE country = 'USA' ORDER BY energy_star_rating DESC LIMIT 3;", "generated_sql": "SELECT name, country, energy_star_rating\nFROM appliances\nWHERE country = 'USA'\nORDER BY energy_star_rating DESC\nLIMIT 3;", "raw_model_output": "```sql\nSELECT name, country, energy_star_rating\nFROM appliances\nWHERE country = 'USA'\nORDER BY energy_star_rating DESC\nLIMIT 3;\n```", "latency_sec": 0.463853120803833, "total_duration_sec": 0.456901827, "load_duration_sec": 0.017628404, "tokens_prompt": 181, "prompt_eval_sec": 0.008815532, "tokens_completion": 34, "completion_eval_sec": 0.427992406, "tokens_total": 215, "tokens_per_sec": 463.508792670008, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects only 'name' and 'energy_star_rating', while the Generated SQL includes an additional 'country' column. Although both filter and sort the same data, the extra column in the Generated SQL changes the result set structure, making them non-equivalent."}
{"example_id": 456, "sql_complexity": "window functions", "prompt": "List the intelligence operations and their corresponding threat levels, and rank them based on their threat level and budget.", "context": "CREATE TABLE intel_ops_threat (id INT, operation VARCHAR, threat VARCHAR, budget INT); INSERT INTO intel_ops_threat (id, operation, threat, budget) VALUES (1, 'Operation Red Folder', 'High', 5000000), (2, 'Operation Black Vault', 'Medium', 7000000), (3, 'Operation Blue Sail', 'Low', 6000000);", "reference_sql": "SELECT operation, threat, budget, ROW_NUMBER() OVER (PARTITION BY threat ORDER BY budget DESC) as rank FROM intel_ops_threat;", "generated_sql": "SELECT \n    operation,\n    threat,\n    RANK() OVER (ORDER BY threat DESC, budget DESC) AS rank\nFROM \n    intel_ops_threat;", "raw_model_output": "```sql\nSELECT \n    operation,\n    threat,\n    RANK() OVER (ORDER BY threat DESC, budget DESC) AS rank\nFROM \n    intel_ops_threat;\n```", "latency_sec": 0.5037667751312256, "total_duration_sec": 0.498287482, "load_duration_sec": 0.013673452, "tokens_prompt": 185, "prompt_eval_sec": 0.010957799, "tokens_completion": 38, "completion_eval_sec": 0.470606221, "tokens_total": 223, "tokens_per_sec": 442.66515976944095, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in ranking logic. The Reference SQL uses ROW_NUMBER() with PARTITION BY threat, resetting the rank for each threat value. The Generated SQL uses RANK() without partitioning, ordering by threat DESC and budget DESC globally. This leads to different ranking results: the Reference assigns rank 1 to all rows (since each threat has one entry), while the Generated assigns ranks 1, 2, 3 based on threat/budget ordering."}
{"example_id": 459, "sql_complexity": "set operations", "prompt": "What is the total installed capacity of hydroelectric power plants in Brazil and Canada?", "context": "CREATE TABLE hydroelectric_power (country TEXT, capacity INTEGER); INSERT INTO hydroelectric_power (country, capacity) VALUES ('Brazil', 104000), ('Canada', 78000), ('China', 350000), ('United States', 100000), ('Russia', 45000);", "reference_sql": "(SELECT capacity FROM hydroelectric_power WHERE country = 'Brazil') UNION (SELECT capacity FROM hydroelectric_power WHERE country = 'Canada');", "generated_sql": "SELECT SUM(capacity) AS total_capacity\nFROM hydroelectric_power\nWHERE country IN ('Brazil', 'Canada');", "raw_model_output": "```sql\nSELECT SUM(capacity) AS total_capacity\nFROM hydroelectric_power\nWHERE country IN ('Brazil', 'Canada');\n```", "latency_sec": 0.3800339698791504, "total_duration_sec": 0.372615141, "load_duration_sec": 0.014647829, "tokens_prompt": 162, "prompt_eval_sec": 0.008653401, "tokens_completion": 28, "completion_eval_sec": 0.346952864, "tokens_total": 190, "tokens_per_sec": 499.95530678591547, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two separate capacity values (Brazil and Canada) as individual rows, while the Generated SQL returns a single summed value of their capacities. The first query uses UNION to combine results, whereas the second uses SUM to aggregate them, leading to different output structures and values."}
{"example_id": 2356, "sql_complexity": "window functions", "prompt": "Find the total billing amount for attorneys in the 'Criminal Law' practice area, for the year 2020, partitioned by attorney's last name and ordered by the total billing amount in descending order.", "context": "CREATE TABLE Attorneys (AttorneyID INT, FirstName VARCHAR(50), LastName VARCHAR(50), PracticeArea VARCHAR(50), TotalBilling FLOAT, BillingYear INT); INSERT INTO Attorneys (AttorneyID, FirstName, LastName, PracticeArea, TotalBilling, BillingYear) VALUES (1, 'Clara', 'Rivera', 'Personal Injury', 8000.00, 2020), (2, 'Jamal', 'Lee', 'Personal Injury', 6000.00, 2019), (3, 'Sophia', 'Gomez', 'Criminal Law', 9000.00, 2020);", "reference_sql": "SELECT LastName, SUM(TotalBilling) OVER (PARTITION BY PracticeArea, LastName, BillingYear) AS TotalBilling FROM Attorneys WHERE PracticeArea = 'Criminal Law' AND BillingYear = 2020 ORDER BY TotalBilling DESC;", "generated_sql": "SELECT LastName, SUM(TotalBilling) AS TotalBillingAmount\nFROM Attorneys\nWHERE PracticeArea = 'Criminal Law' AND BillingYear = 2020\nGROUP BY LastName\nORDER BY TotalBilling DESC;", "raw_model_output": "```sql\nSELECT LastName, SUM(TotalBilling) AS TotalBillingAmount\nFROM Attorneys\nWHERE PracticeArea = 'Criminal Law' AND BillingYear = 2020\nGROUP BY LastName\nORDER BY TotalBilling DESC;\n```", "latency_sec": 0.6847729682922363, "total_duration_sec": 0.681363249, "load_duration_sec": 0.01529565, "tokens_prompt": 263, "prompt_eval_sec": 0.013878609, "tokens_completion": 51, "completion_eval_sec": 0.649646106, "tokens_total": 314, "tokens_per_sec": 458.5461379748801, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses a window function that partitions by PracticeArea, LastName, and BillingYear, but since the WHERE clause filters to a single PracticeArea and BillingYear, it effectively partitions by LastName. This would return one row per attorney (with possible duplicates for same LastName). The Generated SQL groups by LastName, returning one row per LastName. If multiple attorneys share the same LastName, the Reference SQL would produce more rows than the Generated SQL, making them non-equivalent."}
