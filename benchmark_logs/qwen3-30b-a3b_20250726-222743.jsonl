{"example_id": 2656, "sql_complexity": "multiple_joins", "prompt": "Find the drugs and their respective total sales for rare diseases indication with sales greater than the average sales for infectious diseases.", "context": "CREATE TABLE sales (id INT, drug_id INT, quarter INT, year INT, revenue FLOAT); INSERT INTO sales (id, drug_id, quarter, year, revenue) VALUES (1, 1, 1, 2022, 1500000); CREATE TABLE drugs (id INT, name VARCHAR(50), company VARCHAR(50), indication VARCHAR(50)); INSERT INTO drugs (id, name, company, indication) VALUES (1, 'DrugA', 'ABC Corp', 'Rare_Diseases');", "reference_sql": "SELECT s.drug_id, d.name, SUM(s.revenue) as total_sales FROM sales s JOIN drugs d ON s.drug_id = d.id WHERE d.indication = 'Rare_Diseases' GROUP BY s.drug_id HAVING total_sales > (SELECT AVG(s2.revenue) FROM sales s2 JOIN drugs d2 ON s2.drug_id = d2.id WHERE d2.indication = 'Infectious_Diseases')", "generated_sql": "SELECT d.name, SUM(s.revenue) AS total_sales  \nFROM sales s  \nJOIN drugs d ON s.drug_id = d.id  \nWHERE d.indication = 'Rare_Diseases'  \nGROUP BY d.id, d.name  \nHAVING SUM(s.revenue) > (  \n    SELECT AVG(revenue)  \n    FROM sales s2  \n    JOIN drugs d2 ON s2.drug_id = d2.id  \n    WHERE d2.indication = 'Infectious Diseases'  \n);", "raw_model_output": "\n\nSELECT d.name, SUM(s.revenue) AS total_sales  \nFROM sales s  \nJOIN drugs d ON s.drug_id = d.id  \nWHERE d.indication = 'Rare_Diseases'  \nGROUP BY d.id, d.name  \nHAVING SUM(s.revenue) > (  \n    SELECT AVG(revenue)  \n    FROM sales s2  \n    JOIN drugs d2 ON s2.drug_id = d2.id  \n    WHERE d2.indication = 'Infectious Diseases'  \n);", "latency_sec": 9.617844104766846, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 782, "prompt_eval_sec": null, "tokens_completion": 1472, "completion_eval_sec": null, "tokens_total": 2254, "tokens_per_sec": 234.356054792244, "retrieval_latency_sec": 1.0744409561157227, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the subquery condition for 'Infectious_Diseases' vs. 'Infectious Diseases' (underscore vs. space). This would produce different average revenue values, making the HAVING clause comparisons non-equivalent. Additionally, the Reference SQL groups by drug_id while the Generated SQL groups by both id and name, which could affect results if names are not unique per drug_id."}
{"example_id": 3008, "sql_complexity": "multiple_joins", "prompt": "Who are the users who used electric vehicles and their trip details?", "context": "CREATE TABLE users (id INT, name VARCHAR(50), age INT, gender VARCHAR(10), city VARCHAR(50));CREATE TABLE vehicles (id INT, vehicle_type VARCHAR(20), is_electric BOOLEAN);CREATE TABLE trips (id INT, user_id INT, vehicle_id INT, trip_distance FLOAT, trip_duration INT, departure_time TIMESTAMP, arrival_time TIMESTAMP);INSERT INTO users (id, name, age, gender, city) VALUES (3, 'Alex', 30, 'Female', 'New York');INSERT INTO vehicles (id, vehicle_type, is_electric) VALUES (1, 'Tesla', true), (2, 'Bike', false);INSERT INTO trips (id, user_id, vehicle_id, trip_distance, trip_duration, departure_time, arrival_time) VALUES (3, 3, 1, 15.3, 25, '2022-01-03 12:00:00', '2022-01-03 12:25:00');", "reference_sql": "SELECT u.name, v.vehicle_type, t.trip_distance, t.trip_duration FROM users u JOIN trips t ON u.id = t.user_id JOIN vehicles v ON t.vehicle_id = v.id WHERE v.is_electric = true;", "generated_sql": "SELECT users.name, trips.trip_distance, trips.trip_duration, trips.departure_time, trips.arrival_time \nFROM trips \nJOIN vehicles ON trips.vehicle_id = vehicles.id \nJOIN users ON trips.user_id = users.id \nWHERE vehicles.is_electric = TRUE;", "raw_model_output": "\n\nSELECT users.name, trips.trip_distance, trips.trip_duration, trips.departure_time, trips.arrival_time \nFROM trips \nJOIN vehicles ON trips.vehicle_id = vehicles.id \nJOIN users ON trips.user_id = users.id \nWHERE vehicles.is_electric = TRUE;", "latency_sec": 3.6966028213500977, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 803, "prompt_eval_sec": null, "tokens_completion": 560, "completion_eval_sec": null, "tokens_total": 1363, "tokens_per_sec": 368.7169181735884, "retrieval_latency_sec": 0.13183879852294922, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL selects 'name', 'vehicle_type', 'trip_distance', and 'trip_duration', while the Generated SQL selects 'name', 'trip_distance', 'trip_duration', 'departure_time', and 'arrival_time'. The Generated SQL includes additional time columns and excludes 'vehicle_type', resulting in different output columns. Although both filter on electric vehicles, the selected fields differ, making the result sets non-equivalent."}
{"example_id": 2531, "sql_complexity": "basic SQL", "prompt": "Who is the top customer by sales in 2022?", "context": "CREATE TABLE customers (customer_id INT, total_sales_2022 FLOAT); INSERT INTO customers (customer_id, total_sales_2022) VALUES (1, 25000.0), (2, 30000.0), (3, 22000.0), (4, 35000.0);", "reference_sql": "SELECT customer_id, total_sales_2022 FROM customers ORDER BY total_sales_2022 DESC LIMIT 1;", "generated_sql": "SELECT customer_id FROM customers ORDER BY total_sales_2022 DESC LIMIT 1;", "raw_model_output": "\n\nSELECT customer_id FROM customers ORDER BY total_sales_2022 DESC LIMIT 1;", "latency_sec": 6.675697326660156, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1433, "prompt_eval_sec": null, "tokens_completion": 1023, "completion_eval_sec": null, "tokens_total": 2456, "tokens_per_sec": 367.9016408056256, "retrieval_latency_sec": 0.10364532470703125, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query returns both customer_id and total_sales_2022 columns, while the generated query only returns customer_id. The additional column in the reference query makes the result sets structurally different, even though they might return the same customer_id value."}
{"example_id": 3792, "sql_complexity": "single join", "prompt": "What is the maximum distance traveled by an electric vehicle in a single trip, grouped by vehicle model?", "context": "CREATE TABLE Trips (trip_id INT, vehicle_id INT, distance FLOAT); CREATE TABLE ElectricVehicleModels (vehicle_id INT, vehicle_model TEXT);", "reference_sql": "SELECT evm.vehicle_model, MAX(trips.distance) AS max_distance_traveled FROM Trips trips INNER JOIN ElectricVehicleModels evm ON trips.vehicle_id = evm.vehicle_id GROUP BY 1;", "generated_sql": "SELECT e.vehicle_model, MAX(t.distance) \nFROM Trips t \nJOIN ElectricVehicleModels e ON t.vehicle_id = e.vehicle_id \nGROUP BY e.vehicle_model;", "raw_model_output": "\n\nSELECT e.vehicle_model, MAX(t.distance) \nFROM Trips t \nJOIN ElectricVehicleModels e ON t.vehicle_id = e.vehicle_id \nGROUP BY e.vehicle_model;", "latency_sec": 2.8159680366516113, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 924, "prompt_eval_sec": null, "tokens_completion": 430, "completion_eval_sec": null, "tokens_total": 1354, "tokens_per_sec": 480.82932134769663, "retrieval_latency_sec": 0.14244604110717773, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the maximum distance traveled per vehicle model by joining the Trips and ElectricVehicleModels tables. The only differences are table aliases (trips/t vs evm/e vs e/t) and group by syntax (GROUP BY 1 vs GROUP BY e.vehicle_model). Since the join conditions, aggregation, and grouping columns are identical, the result sets will be semantically equivalent."}
{"example_id": 2311, "sql_complexity": "subqueries", "prompt": "Determine the percentage of sales from each ingredient category", "context": "CREATE TABLE Sales_Details (sale_id INT, ingredient_id INT, quantity INT); INSERT INTO Sales_Details (sale_id, ingredient_id, quantity) VALUES (1, 1, 2), (1, 2, 8), (2, 1, 3), (2, 2, 7); CREATE TABLE Ingredient_Categories (ingredient_id INT, ingredient_category VARCHAR(255)); INSERT INTO Ingredient_Categories (ingredient_id, ingredient_category) VALUES (1, 'Legumes'), (2, 'Poultry');", "reference_sql": "SELECT ingredient_category, SUM(quantity) AS total_quantity, SUM(quantity) * 100.0 / (SELECT SUM(quantity) FROM Sales_Details) AS percentage_of_sales FROM Sales_Details, Ingredient_Categories WHERE Sales_Details.ingredient_id = Ingredient_Categories.ingredient_id GROUP BY ingredient_category;", "generated_sql": "SELECT ic.ingredient_category, 100.0 * SUM(sd.quantity) / (SELECT SUM(quantity) FROM Sales_Details) AS percentage FROM Sales_Details sd JOIN Ingredient_Categories ic ON sd.ingredient_id = ic.ingredient_id GROUP BY ic.ingredient_category;", "raw_model_output": "\n\nSELECT ic.ingredient_category, 100.0 * SUM(sd.quantity) / (SELECT SUM(quantity) FROM Sales_Details) AS percentage FROM Sales_Details sd JOIN Ingredient_Categories ic ON sd.ingredient_id = ic.ingredient_id GROUP BY ic.ingredient_category;", "latency_sec": 5.0033721923828125, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 789, "prompt_eval_sec": null, "tokens_completion": 776, "completion_eval_sec": null, "tokens_total": 1565, "tokens_per_sec": 312.78904303433046, "retrieval_latency_sec": 0.13814711570739746, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the total quantity and percentage of sales per ingredient category. They use equivalent JOIN conditions (implicit vs explicit), same aggregation logic, and identical subquery for total sales. The differences are purely syntactic (aliases, formatting) and do not affect the result."}
{"example_id": 3329, "sql_complexity": "set operations", "prompt": "Which causes received funding from donors in both the United States and Canada?", "context": "CREATE TABLE donor_location (donor_id INT, country VARCHAR(50), cause VARCHAR(50), donation DECIMAL(10,2)); INSERT INTO donor_location (donor_id, country, cause, donation) VALUES (1, 'United States', 'Global Health', 1000.00), (2, 'Canada', 'Education', 2000.00), (3, 'United States', 'Environment', 1500.00), (4, 'Canada', 'Animal Welfare', 2500.00);", "reference_sql": "SELECT cause FROM donor_location WHERE country = 'United States' INTERSECT SELECT cause FROM donor_location WHERE country = 'Canada';", "generated_sql": "SELECT cause\nFROM donor_location\nWHERE country = 'United States'\nINTERSECT\nSELECT cause\nFROM donor_location\nWHERE country = 'Canada';", "raw_model_output": "\n\nTo determine which causes received funding from donors in **both the United States and Canada**, we need to identify causes that appear in the `donor_location` table for **both countries**.\n\n---\n\n### \u2705 Strategy\n\nWe can use the `INTERSECT` operator to find the common causes between two sets:\n\n- All causes from donors in the **United States**\n- All causes from donors in **Canada**\n\nThis approach ensures that only causes that appear in **both** countries are returned.\n\n---\n\n### \ud83e\udde0 Why `INTERSECT`?\n\n- It directly finds the **intersection** of two sets of causes.\n- It is concise and readable.\n- It avoids the need for complex `GROUP BY` or `HAVING` clauses.\n- It is fully compliant with **ANSI SQL**.\n\n---\n\n### \ud83d\udccc SQL Statement\n\n```sql\nSELECT cause\nFROM donor_location\nWHERE country = 'United States'\nINTERSECT\nSELECT cause\nFROM donor_location\nWHERE country = 'Canada';\n```\n\n---\n\n### \ud83e\uddea Example with Given Data\n\nGiven the sample data:\n\n| donor_id | country       | cause           | donation |\n|----------|---------------|------------------|----------|\n| 1        | United States | Global Health    | 1000.00  |\n| 2        | Canada        | Education        | 2000.00  |\n| 3        | United States | Environment      | 1500.00  |\n| 4        | Canada        | Animal Welfare   | 2500.00  |\n\nThere are **no causes** that appear in **both** the United States and Canada, so this query would return **no rows**.\n\n---\n\n### \u2705 Final Answer\n\n```sql\nSELECT cause\nFROM donor_location\nWHERE country = 'United States'\nINTERSECT\nSELECT cause\nFROM donor_location\nWHERE country = 'Canada';\n```", "latency_sec": 22.792060136795044, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 949, "prompt_eval_sec": null, "tokens_completion": 3563, "completion_eval_sec": null, "tokens_total": 4512, "tokens_per_sec": 197.96367563614479, "retrieval_latency_sec": 0.1356339454650879, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure and logic. Both queries select 'cause' values from donor_location where country is 'United States' and intersect them with 'cause' values where country is 'Canada'. The INTERSECT operator ensures only common causes between the two countries are returned, and the queries are syntactically and semantically identical."}
{"example_id": 2912, "sql_complexity": "single join", "prompt": "Which company has manufactured the most satellites?", "context": "CREATE TABLE manufacturers (id INT, name TEXT); CREATE TABLE satellites (id INT, manufacturer_id INT, name TEXT, launch_date DATE); INSERT INTO manufacturers (id, name) VALUES (1, 'SpaceX'), (2, 'Blue Origin'), (3, 'ISRO'), (4, 'CAST'); INSERT INTO satellites (id, manufacturer_id, name, launch_date) VALUES (1, 1, 'StarDragon', '2012-05-25'), (2, 1, 'Falcon', '2015-12-21'), (3, 2, 'New Glenn', '2022-01-11'), (4, 3, 'ChinaSat 1E', '2000-12-05'), (5, 3, 'ChinaSat 2A', '2003-08-13'), (6, 4, 'Shijian 9', '2017-11-19'), (7, 1, 'StarLink', '2020-05-24'), (8, 1, 'StarLink', '2020-06-13');", "reference_sql": "SELECT m.name, COUNT(s.id) FROM manufacturers m JOIN satellites s ON m.id = s.manufacturer_id GROUP BY m.name ORDER BY COUNT(s.id) DESC;", "generated_sql": "SELECT m.name FROM manufacturers m JOIN satellites s ON m.id = s.manufacturer_id GROUP BY m.name ORDER BY COUNT(s.id) DESC LIMIT 1;", "raw_model_output": "\n\nSELECT m.name FROM manufacturers m JOIN satellites s ON m.id = s.manufacturer_id GROUP BY m.name ORDER BY COUNT(s.id) DESC LIMIT 1;", "latency_sec": 5.55961799621582, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1025, "prompt_eval_sec": null, "tokens_completion": 865, "completion_eval_sec": null, "tokens_total": 1890, "tokens_per_sec": 339.95141415946875, "retrieval_latency_sec": 0.12631988525390625, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns both manufacturer names and their satellite counts, while the Generated SQL only returns manufacturer names. The Generated SQL also limits results to 1 row, whereas the Reference SQL returns all manufacturers ordered by count. The semantic equivalence fails due to differing column outputs and result set size."}
{"example_id": 3170, "sql_complexity": "aggregation", "prompt": "Determine the total production quantity of silver for mining sites in Mexico, between the dates '2017-05-01' and '2017-09-30', having less than 40 employees.", "context": "CREATE TABLE silver_mine_2 (site_id INT, country VARCHAR(50), num_employees INT, extraction_date DATE, quantity INT); INSERT INTO silver_mine_2 (site_id, country, num_employees, extraction_date, quantity) VALUES (1, 'Mexico', 35, '2017-05-02', 1200), (2, 'Mexico', 30, '2017-08-31', 1800), (3, 'Mexico', 37, '2017-07-04', 2200);", "reference_sql": "SELECT country, SUM(quantity) as total_silver_prod FROM silver_mine_2 WHERE num_employees < 40 AND country = 'Mexico' AND extraction_date >= '2017-05-01' AND extraction_date <= '2017-09-30' GROUP BY country;", "generated_sql": "SELECT SUM(quantity) FROM silver_mine_2 WHERE country = 'Mexico' AND extraction_date BETWEEN '2017-05-01' AND '2017-09-30' AND num_employees < 40;", "raw_model_output": "\n\nSELECT SUM(quantity) FROM silver_mine_2 WHERE country = 'Mexico' AND extraction_date BETWEEN '2017-05-01' AND '2017-09-30' AND num_employees < 40;", "latency_sec": 3.9039409160614014, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1027, "prompt_eval_sec": null, "tokens_completion": 599, "completion_eval_sec": null, "tokens_total": 1626, "tokens_per_sec": 416.5022050693418, "retrieval_latency_sec": 0.1372690200805664, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes the 'country' column in the output, while the Generated SQL does not. Although both calculate the same sum, the result sets differ in structure (one column vs. two columns), making them semantically distinct."}
{"example_id": 3518, "sql_complexity": "basic SQL", "prompt": "Insert new records of ticket sales for a new event, including event and salesperson information.", "context": "CREATE TABLE salesperson (salesperson_id INT, name VARCHAR(50), position VARCHAR(50)); CREATE TABLE tickets (ticket_id INT, salesperson_id INT, event_id INT, price DECIMAL(5,2), quantity INT); CREATE TABLE events (event_id INT, name VARCHAR(50), date DATE); INSERT INTO salesperson VALUES (1, 'John Doe', 'Senior Salesperson'); INSERT INTO events VALUES (2, 'New Event', '2023-04-15');", "reference_sql": "INSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity) VALUES (2, 1, 2, 75, 50), (3, 2, 2, 65, 75); INSERT INTO events (event_id, name, date) VALUES (2, 'New Event', '2023-04-15');", "generated_sql": "INSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity) VALUES (2, 1, 2, 75.00, 50);", "raw_model_output": "\n\nINSERT INTO tickets (ticket_id, salesperson_id, event_id, price, quantity) VALUES (2, 1, 2, 75.00, 50);", "latency_sec": 9.33997893333435, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 956, "prompt_eval_sec": null, "tokens_completion": 1445, "completion_eval_sec": null, "tokens_total": 2401, "tokens_per_sec": 257.06696097898464, "retrieval_latency_sec": 0.11617422103881836, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL inserts two rows into the tickets table and one row into the events table, while the Generated SQL only inserts a single row into the tickets table. The Generated SQL omits the second ticket row and the events table insertion, making them non-equivalent."}
{"example_id": 3925, "sql_complexity": "set operations", "prompt": "What is the total number of students and staff with accommodations in the \"disability_services\" schema, excluding the \"accessibility_parking\" type?", "context": "CREATE SCHEMA disability_services; CREATE TABLE staff (id INT, name VARCHAR(50), accommodation VARCHAR(50)); CREATE TABLE students (id INT, name VARCHAR(50), accommodation VARCHAR(50));", "reference_sql": "SELECT COUNT(*) FROM disability_services.staff WHERE accommodation != 'accessibility_parking' UNION SELECT COUNT(*) FROM disability_services.students WHERE accommodation != 'accessibility_parking';", "generated_sql": "SELECT COUNT(*) FROM disability_services.staff WHERE accommodation != 'accessibility_parking' UNION SELECT COUNT(*) FROM disability_services.students WHERE accommodation != 'accessibility_parking';", "raw_model_output": "\n\nSELECT COUNT(*) FROM disability_services.staff WHERE accommodation != 'accessibility_parking' UNION SELECT COUNT(*) FROM disability_services.students WHERE accommodation != 'accessibility_parking';", "latency_sec": 11.210603952407837, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 625, "prompt_eval_sec": null, "tokens_completion": 1759, "completion_eval_sec": null, "tokens_total": 2384, "tokens_per_sec": 212.65580428322593, "retrieval_latency_sec": 0.13496613502502441, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure and logic. Both queries perform the same operation: counting rows in 'staff' and 'students' tables where accommodation is not 'accessibility_parking', then combining results with UNION. Since the queries are exactly the same, they will produce identical results."}
{"example_id": 3340, "sql_complexity": "subqueries", "prompt": "Calculate the total revenue for garments manufactured in the US and sold in California.", "context": "CREATE TABLE garment_manufacturing(id INT PRIMARY KEY, garment_id INT, country VARCHAR(50), material VARCHAR(50), manufacturing_date DATE, quantity INT); CREATE TABLE garment_sales(id INT PRIMARY KEY, garment_id INT, store_id INT, sale_date DATE, units INT, revenue DECIMAL(10,2));", "reference_sql": "SELECT SUM(gs.revenue) FROM garment_manufacturing gm JOIN garment_sales gs ON gm.garment_id = gs.garment_id WHERE gm.country = 'United States' AND gs.store_id IN (SELECT id FROM stores WHERE region = 'California');", "generated_sql": "SELECT SUM(garment_sales.revenue)\nFROM garment_manufacturing\nJOIN garment_sales ON garment_manufacturing.garment_id = garment_sales.garment_id\nWHERE garment_manufacturing.country = 'US';", "raw_model_output": "\n\nTo calculate the **total revenue for garments manufactured in the US and sold in California**, we need to:\n\n1. **Join** the `garment_manufacturing` and `garment_sales` tables using the `garment_id` field.\n2. **Filter** the results to include only those garments:\n   - Manufactured in the **US** (`garment_manufacturing.country = 'US'`)\n   - Sold in **California** (we assume that the `store_id` in `garment_sales` corresponds to stores located in California, though this is not explicitly defined in the schema).\n3. **Sum** the `revenue` from the `garment_sales` table.\n\n---\n\n### \u2705 Final SQL Query\n\n```sql\nSELECT SUM(garment_sales.revenue)\nFROM garment_manufacturing\nJOIN garment_sales ON garment_manufacturing.garment_id = garment_sales.garment_id\nWHERE garment_manufacturing.country = 'US';\n```\n\n---\n\n### \u26a0\ufe0f Note on Limitations\n\nThe schema does **not explicitly define** how to determine the **location of the store** (i.e., whether a `store_id` corresponds to a store in California). This query assumes that the `garment_sales` table contains all sales made in California, or that the `store_id` is implicitly linked to California. If the schema included a `stores` table with location data, the query would need to be adjusted accordingly.\n\nIf such a table existed, the query would look like this:\n\n```sql\nSELECT SUM(garment_sales.revenue)\nFROM garment_manufacturing\nJOIN garment_sales ON garment_manufacturing.garment_id = garment_sales.garment_id\nJOIN stores ON garment_sales.store_id = stores.id\nWHERE garment_manufacturing.country = 'US'\n  AND stores.state = 'California';\n```\n\nBut based on the provided schema, the first query is the most accurate possible.", "latency_sec": 20.33302402496338, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 933, "prompt_eval_sec": null, "tokens_completion": 3178, "completion_eval_sec": null, "tokens_total": 4111, "tokens_per_sec": 202.18340345994866, "retrieval_latency_sec": 0.12070727348327637, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a subquery filtering store_id to those in 'California' region, while the Generated SQL omits this condition. Additionally, the country filter uses 'United States' vs 'US' (assuming 'US' is a valid country code). The missing store region filter in the Generated SQL would include sales from all stores, not just California, leading to different results."}
{"example_id": 596, "sql_complexity": "basic SQL", "prompt": "What is the minimum energy production cost of wind farms in Spain?", "context": "CREATE TABLE wind_farm_costs (id INT, name TEXT, country TEXT, energy_production_cost FLOAT); INSERT INTO wind_farm_costs (id, name, country, energy_production_cost) VALUES (1, 'Las Tiesas', 'Spain', 0.045), (2, 'Eolo', 'Spain', 0.050);", "reference_sql": "SELECT MIN(energy_production_cost) FROM wind_farm_costs WHERE country = 'Spain';", "generated_sql": "SELECT MIN(energy_production_cost) FROM wind_farm_costs WHERE country = 'Spain';", "raw_model_output": "\n\nSELECT MIN(energy_production_cost) FROM wind_farm_costs WHERE country = 'Spain';", "latency_sec": 1.5834789276123047, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 705, "prompt_eval_sec": null, "tokens_completion": 223, "completion_eval_sec": null, "tokens_total": 928, "tokens_per_sec": 586.0513732249738, "retrieval_latency_sec": 0.12075591087341309, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They both select the minimum energy_production_cost from the wind_farm_costs table where the country is 'Spain'. The SQL syntax, table name, column names, and WHERE condition are exactly the same in both queries."}
{"example_id": 2604, "sql_complexity": "subqueries", "prompt": "What is the maximum number of virtual tours taken by a single user in the UK?", "context": "CREATE TABLE virtual_tour_data (user_id INT, hotel_id INT, tour_date DATE); INSERT INTO virtual_tour_data (user_id, hotel_id, tour_date) VALUES (1, 10, '2022-01-01'), (2, 11, '2022-01-03'), (3, 12, '2022-01-05'), (4, 10, '2022-01-07'), (5, 10, '2022-01-09'); CREATE TABLE hotels (hotel_id INT, hotel_name TEXT, country TEXT); INSERT INTO hotels (hotel_id, hotel_name, country) VALUES (10, 'Royal Park Hotel', 'UK'), (11, 'The Ritz London', 'UK'), (12, 'Hotel de Crillon', 'France');", "reference_sql": "SELECT MAX(vt.user_tours) FROM (SELECT user_id, COUNT(DISTINCT hotel_id) as user_tours FROM virtual_tour_data WHERE country = 'UK' GROUP BY user_id) as vt;", "generated_sql": "SELECT MAX(tour_count) AS max_tours_per_user\nFROM (\n    SELECT COUNT(*) AS tour_count\n    FROM virtual_tour_data\n    JOIN hotels ON virtual_tour_data.hotel_id = hotels.hotel_id\n    WHERE hotels.country = 'UK'\n    GROUP BY user_id\n) AS counts;", "raw_model_output": "\n\nTo determine the **maximum number of virtual tours taken by a single user in the UK**, we need to:\n\n1. **Join** the `virtual_tour_data` table with the `hotels` table using the `hotel_id` to filter only those tours that occurred at hotels located in the UK.\n2. **Group** the resulting data by `user_id` to count how many tours each user took.\n3. **Select the maximum** of these counts.\n\n---\n\n### \u2705 SQL Query\n\n```sql\nSELECT MAX(tour_count) AS max_tours_per_user\nFROM (\n    SELECT COUNT(*) AS tour_count\n    FROM virtual_tour_data\n    JOIN hotels ON virtual_tour_data.hotel_id = hotels.hotel_id\n    WHERE hotels.country = 'UK'\n    GROUP BY user_id\n) AS counts;\n```\n\n---\n\n### \ud83d\udccc Explanation\n\n- **`JOIN hotels`** ensures we only consider tours at hotels in the UK.\n- **`GROUP BY user_id`** groups the tours by user.\n- **`COUNT(*)`** counts the number of tours per user.\n- **`MAX(tour_count)`** finds the highest number of tours taken by any single user.\n\nThis query will return the **maximum number of virtual tours taken by a single user in the UK**, based on the provided schema and data.", "latency_sec": 8.685774087905884, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 874, "prompt_eval_sec": null, "tokens_completion": 1360, "completion_eval_sec": null, "tokens_total": 2234, "tokens_per_sec": 257.20217650038046, "retrieval_latency_sec": 0.12415099143981934, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL counts distinct hotel_ids per user (COUNT(DISTINCT hotel_id)), while the Generated SQL counts total tours per user (COUNT(*)). Even if both queries had proper joins, they would differ in logic: one measures unique hotel visits, the other total visits. Additionally, the Reference SQL as written is invalid due to missing join conditions."}
{"example_id": 5812, "sql_complexity": "single join", "prompt": "Calculate the percentage of Shariah-compliant investments held by each investor in the top 5 countries with the highest percentage?", "context": "CREATE TABLE investors (investor_id INT, investor_name TEXT, country TEXT); INSERT INTO investors (investor_id, investor_name, country) VALUES (1, 'Al Thani', 'Qatar'), (2, 'Saudi Investment Group', 'Saudi Arabia'), (3, 'Temasek Holdings', 'Singapore'); CREATE TABLE investments (investment_id INT, investor_id INT, investment_type TEXT, investment_value DECIMAL, is_shariah_compliant BOOLEAN); INSERT INTO investments (investment_id, investor_id, investment_type, investment_value, is_shariah_compliant) VALUES (1, 1, 'Real Estate', 15000000, true), (2, 2, 'Stocks', 20000000, false);", "reference_sql": "SELECT investor_name, ROUND((SUM(CASE WHEN is_shariah_compliant THEN investment_value ELSE 0 END) / SUM(investment_value)) * 100, 2) AS percentage FROM investments JOIN investors ON investments.investor_id = investors.investor_id GROUP BY investor_name ORDER BY percentage DESC LIMIT 5;", "generated_sql": "WITH investor_shariah AS (\n    SELECT i.investor_id, \n           COALESCE(SUM(CASE WHEN inv.is_shariah_compliant THEN inv.investment_value ELSE 0 END) * 100.0 / NULLIF(SUM(inv.investment_value), 0), 0) AS shariah_percent\n    FROM investors i\n    LEFT JOIN investments inv ON i.investor_id = inv.investor_id\n    GROUP BY i.investor_id\n),\ncountry_avg AS (\n    SELECT i.country, AVG(is.shariah_percent) AS avg_percent\n    FROM investor_shariah is\n    JOIN investors i ON is.investor_id = i.investor_id\n    GROUP BY i.country\n),\ntop_countries AS (\n    SELECT country\n    FROM country_avg\n    ORDER BY avg_percent DESC\n    LIMIT 5\n)\nSELECT is.investor_id, i.investor_name, i.country, is.shariah_percent\nFROM investor_shariah is\nJOIN investors i ON is.investor_id = i.investor_id\nWHERE i.country IN (SELECT country FROM top_countries)\nORDER BY i.country, is.shariah_percent DESC;", "raw_model_output": "\n\n```sql\nWITH investor_shariah AS (\n    SELECT i.investor_id, \n           COALESCE(SUM(CASE WHEN inv.is_shariah_compliant THEN inv.investment_value ELSE 0 END) * 100.0 / NULLIF(SUM(inv.investment_value), 0), 0) AS shariah_percent\n    FROM investors i\n    LEFT JOIN investments inv ON i.investor_id = inv.investor_id\n    GROUP BY i.investor_id\n),\ncountry_avg AS (\n    SELECT i.country, AVG(is.shariah_percent) AS avg_percent\n    FROM investor_shariah is\n    JOIN investors i ON is.investor_id = i.investor_id\n    GROUP BY i.country\n),\ntop_countries AS (\n    SELECT country\n    FROM country_avg\n    ORDER BY avg_percent DESC\n    LIMIT 5\n)\nSELECT is.investor_id, i.investor_name, i.country, is.shariah_percent\nFROM investor_shariah is\nJOIN investors i ON is.investor_id = i.investor_id\nWHERE i.country IN (SELECT country FROM top_countries)\nORDER BY i.country, is.shariah_percent DESC;\n```", "latency_sec": 32.644270181655884, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1168, "prompt_eval_sec": null, "tokens_completion": 5062, "completion_eval_sec": null, "tokens_total": 6230, "tokens_per_sec": 190.84513041130523, "retrieval_latency_sec": 0.12297224998474121, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries have different purposes and structures. The Reference SQL calculates shariah compliance percentages per investor and orders by that metric, while the Generated SQL focuses on country-level averages and includes additional filtering/processing steps. The output columns, grouping logic, and final results differ significantly."}
{"example_id": 4706, "sql_complexity": "multiple_joins", "prompt": "Who are the top 3 customers by total spend on makeup products from Italy and Spain?", "context": "CREATE TABLE customers (customer_id INT, customer_name TEXT, country TEXT); INSERT INTO customers (customer_id, customer_name, country) VALUES (1, 'Alessandro Martini', 'IT'), (2, 'Laura Rossi', 'ES'), (3, 'Daniela Gonzalez', 'MX'), (4, 'Jose Hernandez', 'ES'), (5, 'Sophia Rodriguez', 'IT'); CREATE TABLE sales (sale_id INT, customer_id INT, product_id INT, sale_quantity INT, sale_country TEXT); INSERT INTO sales (sale_id, customer_id, product_id, sale_quantity, sale_country) VALUES (1, 1, 1, 100, 'IT'), (2, 2, 2, 150, 'ES'), (3, 3, 3, 200, 'MX'), (4, 4, 4, 250, 'ES'), (5, 5, 5, 300, 'IT'); CREATE TABLE products (product_id INT, product_name TEXT, category TEXT); INSERT INTO products (product_id, product_name, category) VALUES (1, 'Eyeshadow Palette', 'makeup'), (2, 'Liquid Lipstick', 'makeup'), (3, 'BB Cream', 'makeup'), (4, 'Volumizing Mascara', 'makeup'), (5, 'Nourishing Lip Balm', 'makeup');", "reference_sql": "SELECT c.customer_name, SUM(s.sale_quantity) as total_spent_on_makeup FROM sales s JOIN customers c ON s.customer_id = c.customer_id JOIN products p ON s.product_id = p.product_id WHERE c.country IN ('IT', 'ES') AND p.category = 'makeup' GROUP BY c.customer_name ORDER BY total_spent_on_makeup DESC LIMIT 3;", "generated_sql": "SELECT c.customer_name, SUM(s.sale_quantity) AS total_spend  \nFROM sales s  \nJOIN products p ON s.product_id = p.product_id  \nJOIN customers c ON s.customer_id = c.customer_id  \nWHERE p.category = 'makeup' AND s.sale_country IN ('IT', 'ES')  \nGROUP BY c.customer_id, c.customer_name  \nORDER BY total_spend DESC  \nLIMIT 3;", "raw_model_output": "\n\nSELECT c.customer_name, SUM(s.sale_quantity) AS total_spend  \nFROM sales s  \nJOIN products p ON s.product_id = p.product_id  \nJOIN customers c ON s.customer_id = c.customer_id  \nWHERE p.category = 'makeup' AND s.sale_country IN ('IT', 'ES')  \nGROUP BY c.customer_id, c.customer_name  \nORDER BY total_spend DESC  \nLIMIT 3;", "latency_sec": 11.486570835113525, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1405, "prompt_eval_sec": null, "tokens_completion": 1796, "completion_eval_sec": null, "tokens_total": 3201, "tokens_per_sec": 278.67324773855046, "retrieval_latency_sec": 0.12430882453918457, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Reference SQL filters customers by `c.country` while the Generated SQL filters sales by `s.sale_country`, which may not always correlate. Second, the Reference groups by `customer_name` (potentially non-unique) while the Generated groups by `customer_id` (unique) and `customer_name`. These differences could lead to different aggregation results, especially if customer names are not unique or if sale_country differs from customer country."}
{"example_id": 1515, "sql_complexity": "multiple_joins", "prompt": "What is the average age of clients who lost cases in the 'personal injury' category?", "context": "CREATE TABLE Cases (CaseID int, ClientID int, Category varchar(50)); INSERT INTO Cases (CaseID, ClientID, Category) VALUES (701, 7, 'Personal Injury'); CREATE TABLE Clients (ClientID int, Age int, Gender varchar(10)); INSERT INTO Clients (ClientID, Age, Gender) VALUES (7, 45, 'Male'); CREATE TABLE CaseOutcomes (CaseID int, Outcome varchar(50)); INSERT INTO CaseOutcomes (CaseID, Outcome) VALUES (701, 'Lost');", "reference_sql": "SELECT AVG(C.Age) as AvgAge FROM Clients C INNER JOIN Cases CA ON C.ClientID = CA.ClientID INNER JOIN CaseOutcomes CO ON CA.CaseID = CO.CaseID WHERE CA.Category = 'Personal Injury' AND CO.Outcome = 'Lost';", "generated_sql": "SELECT AVG(C.Age) FROM Clients C INNER JOIN Cases CA ON C.ClientID = CA.ClientID INNER JOIN CaseOutcomes CO ON CA.CaseID = CO.CaseID WHERE CA.Category = 'Personal Injury' AND CO.Outcome = 'Lost';", "raw_model_output": "\n\nSELECT AVG(C.Age) FROM Clients C INNER JOIN Cases CA ON C.ClientID = CA.ClientID INNER JOIN CaseOutcomes CO ON CA.CaseID = CO.CaseID WHERE CA.Category = 'Personal Injury' AND CO.Outcome = 'Lost';", "latency_sec": 2.9961299896240234, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 747, "prompt_eval_sec": null, "tokens_completion": 438, "completion_eval_sec": null, "tokens_total": 1185, "tokens_per_sec": 395.5102095382392, "retrieval_latency_sec": 0.13519906997680664, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. The only difference is the presence of an alias ('as AvgAge') in the reference query, which does not affect the computed result. Both queries calculate the average age of clients with 'Personal Injury' cases that resulted in 'Lost', using identical joins and filters."}
{"example_id": 4388, "sql_complexity": "subqueries", "prompt": "Insert a new drug with a price 10% higher than the average price", "context": "CREATE TABLE drugs (drug_id INT, drug_name VARCHAR(50), price DECIMAL(10, 2)); INSERT INTO drugs (drug_id, drug_name, price) VALUES (1, 'DrugA', 50), (2, 'DrugB', 75), (3, 'DrugC', 100)", "reference_sql": "INSERT INTO drugs (drug_id, drug_name, price) VALUES ((SELECT MAX(drug_id) FROM drugs) + 1, 'DrugD', (SELECT AVG(price) * 1.1 FROM drugs))", "generated_sql": "INSERT INTO drugs (drug_name, price) VALUES ('NewDrug', (SELECT AVG(price) * 1.10 FROM drugs));", "raw_model_output": "\n\nINSERT INTO drugs (drug_name, price) VALUES ('NewDrug', (SELECT AVG(price) * 1.10 FROM drugs));", "latency_sec": 10.846249103546143, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 773, "prompt_eval_sec": null, "tokens_completion": 1707, "completion_eval_sec": null, "tokens_total": 2480, "tokens_per_sec": 228.65047412466055, "retrieval_latency_sec": 0.12172698974609375, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL explicitly sets drug_id to (MAX(drug_id) + 1) and uses 'DrugD' as the drug_name, while the Generated SQL omits drug_id (relying on auto-increment) and uses 'NewDrug' as the drug_name. Additionally, the price calculation is identical, but the differences in drug_id and drug_name make the results distinct."}
{"example_id": 5431, "sql_complexity": "basic SQL", "prompt": "What is the average CO2 emission of ride-hailing vehicles in San Francisco?", "context": "CREATE TABLE SFRideHailing (id INT, company VARCHAR(20), co2_emission DECIMAL(5,2));", "reference_sql": "SELECT AVG(co2_emission) FROM SFRideHailing WHERE company = 'Uber';", "generated_sql": "SELECT AVG(co2_emission) FROM SFRideHailing;", "raw_model_output": "\n\nSELECT AVG(co2_emission) FROM SFRideHailing;", "latency_sec": 3.132012128829956, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 580, "prompt_eval_sec": null, "tokens_completion": 484, "completion_eval_sec": null, "tokens_total": 1064, "tokens_per_sec": 339.7177138000052, "retrieval_latency_sec": 0.10816216468811035, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query filters results to only include rows where company = 'Uber', while the generated query calculates the average for all companies in the table. The WHERE clause in the reference query restricts the dataset, leading to a different result than the generated query which includes all records."}
{"example_id": 3531, "sql_complexity": "single join", "prompt": "What is the total number of workouts and total workout time per user for users with a membership type of 'Basic'?", "context": "CREATE TABLE Members (id INT, user_name VARCHAR, membership_type VARCHAR, signup_date DATE); CREATE TABLE Workouts (id INT, user_id INT, workout_date DATE, workout_duration INT); INSERT INTO Members (id, user_name, membership_type, signup_date) VALUES (1, 'John Doe', 'Premium', '2020-01-01'), (2, 'Jane Smith', 'Basic', '2019-06-15'), (3, 'Alice Johnson', 'Premium', '2020-03-20'); INSERT INTO Workouts (id, user_id, workout_date, workout_duration) VALUES (1, 1, '2020-01-01', 60), (2, 1, '2020-01-02', 70), (3, 2, '2019-06-15', 90), (4, 3, '2020-03-20', 65), (5, 3, '2020-03-21', 70);", "reference_sql": "SELECT Members.user_name, SUM(Workouts.workout_duration) AS total_workout_time, COUNT(Workouts.id) AS total_workouts FROM Members JOIN Workouts ON Members.id = Workouts.user_id WHERE Members.membership_type = 'Basic' GROUP BY Members.user_name;", "generated_sql": "SELECT m.user_name, COUNT(w.id) AS total_workouts, SUM(w.workout_duration) AS total_duration  \nFROM Members m  \nJOIN Workouts w ON m.id = w.user_id  \nWHERE m.membership_type = 'Basic'  \nGROUP BY m.user_name;", "raw_model_output": "\n\nSELECT m.user_name, COUNT(w.id) AS total_workouts, SUM(w.workout_duration) AS total_duration  \nFROM Members m  \nJOIN Workouts w ON m.id = w.user_id  \nWHERE m.membership_type = 'Basic'  \nGROUP BY m.user_name;", "latency_sec": 17.787879943847656, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1121, "prompt_eval_sec": null, "tokens_completion": 2790, "completion_eval_sec": null, "tokens_total": 3911, "tokens_per_sec": 219.86881024305026, "retrieval_latency_sec": 0.11195921897888184, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same data by joining Members and Workouts tables on user_id, filtering for 'Basic' membership type, and grouping by user_name. The differences are purely syntactic (table aliases, column alias names, and select list order) and do not affect the semantic result."}
{"example_id": 5678, "sql_complexity": "set operations", "prompt": "How many public works projects are there in 'Sydney' and 'Melbourne' combined?", "context": "CREATE TABLE PublicWorksC(id INT, city VARCHAR(20), project VARCHAR(30)); INSERT INTO PublicWorksC(id, city, project) VALUES (1, 'Sydney', 'Park Renovation'), (2, 'Melbourne', 'Sidewalk Repair');", "reference_sql": "SELECT COUNT(*) FROM (SELECT city FROM PublicWorksC WHERE city = 'Sydney' UNION ALL SELECT city FROM PublicWorksC WHERE city = 'Melbourne') AS Total;", "generated_sql": "SELECT COUNT(*) FROM PublicWorksC WHERE city IN ('Sydney', 'Melbourne');", "raw_model_output": "\n\nSELECT COUNT(*) FROM PublicWorksC WHERE city IN ('Sydney', 'Melbourne');", "latency_sec": 3.635802745819092, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 744, "prompt_eval_sec": null, "tokens_completion": 406, "completion_eval_sec": null, "tokens_total": 1150, "tokens_per_sec": 316.298787474765, "retrieval_latency_sec": 0.1069490909576416, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of rows where the city is either 'Sydney' or 'Melbourne'. The Reference SQL uses a UNION ALL to combine results from two separate selects, while the Generated SQL uses the IN clause. Since UNION ALL preserves all rows (and the two subqueries cannot overlap due to different city values), the final count remains identical."}
{"example_id": 5792, "sql_complexity": "multiple_joins", "prompt": "How many cases were handled by attorneys in the 'Los Angeles' office?", "context": "CREATE TABLE offices (office_id INT, office_name VARCHAR(20), city VARCHAR(20), state VARCHAR(20)); INSERT INTO offices (office_id, office_name, city, state) VALUES (1, 'Boston', 'Boston', 'MA'), (2, 'New York', 'New York', 'NY'), (3, 'Los Angeles', 'Los Angeles', 'CA'); CREATE TABLE attorneys (attorney_id INT, office_id INT); INSERT INTO attorneys (attorney_id, office_id) VALUES (1, 1), (2, 2), (3, 3); CREATE TABLE cases (case_id INT, attorney_id INT); INSERT INTO cases (case_id, attorney_id) VALUES (1, 1), (2, 2), (3, 3);", "reference_sql": "SELECT COUNT(*) FROM cases JOIN attorneys ON cases.attorney_id = attorneys.attorney_id JOIN offices ON attorneys.office_id = offices.office_id WHERE offices.city = 'Los Angeles';", "generated_sql": "SELECT COUNT(*) \nFROM cases \nJOIN attorneys ON cases.attorney_id = attorneys.attorney_id \nJOIN offices ON attorneys.office_id = offices.office_id \nWHERE offices.office_name = 'Los Angeles';", "raw_model_output": "\n\nTo determine how many cases were handled by attorneys in the 'Los Angeles' office, we need to:\n\n1. **Identify the relevant office**: The `offices` table contains the `office_name` column, and we are interested in the office named 'Los Angeles'.\n2. **Link attorneys to their office**: The `attorneys` table contains an `office_id` that corresponds to the `office_id` in the `offices` table.\n3. **Link cases to attorneys**: The `cases` table contains an `attorney_id` that corresponds to the `attorney_id` in the `attorneys` table.\n4. **Count the cases**: Once we have the correct join conditions, we can count the number of cases associated with attorneys in the 'Los Angeles' office.\n\n---\n\n### \u2705 Final SQL Query\n\n```sql\nSELECT COUNT(*) \nFROM cases \nJOIN attorneys ON cases.attorney_id = attorneys.attorney_id \nJOIN offices ON attorneys.office_id = offices.office_id \nWHERE offices.office_name = 'Los Angeles';\n```\n\n---\n\n### \ud83d\udccc Explanation\n\n- `JOIN attorneys ON cases.attorney_id = attorneys.attorney_id`: Links each case to its corresponding attorney.\n- `JOIN offices ON attorneys.office_id = offices.office_id`: Links each attorney to their office.\n- `WHERE offices.office_name = 'Los Angeles'`: Filters the results to only include attorneys in the 'Los Angeles' office.\n- `COUNT(*)`: Counts the total number of cases handled by those attorneys.\n\nThis query will return the correct number of cases handled by attorneys located in the 'Los Angeles' office.", "latency_sec": 5.2764270305633545, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 895, "prompt_eval_sec": null, "tokens_completion": 822, "completion_eval_sec": null, "tokens_total": 1717, "tokens_per_sec": 325.40959820999916, "retrieval_latency_sec": 0.10243606567382812, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters by 'offices.city = 'Los Angeles'', while the Generated SQL filters by 'offices.office_name = 'Los Angeles''. Although in the provided sample data the office_name and city values coincide for the Los Angeles office, the queries are not semantically equivalent because they check different columns. The 'city' and 'office_name' columns could contain different values in other scenarios, leading to different results."}
{"example_id": 5148, "sql_complexity": "window functions", "prompt": "List the unique types of smart city technologies that have been implemented in the top 3 most populous countries in the world.", "context": "CREATE TABLE smart_city_tech (tech_type VARCHAR(255), country VARCHAR(255)); CREATE TABLE country_populations (country VARCHAR(255), population INT);", "reference_sql": "SELECT DISTINCT tech_type FROM smart_city_tech SCT WHERE country IN (SELECT country FROM (SELECT country, ROW_NUMBER() OVER (ORDER BY population DESC) as rank FROM country_populations) CP WHERE rank <= 3);", "generated_sql": "SELECT DISTINCT tech_type  \nFROM smart_city_tech  \nWHERE country IN (  \n    SELECT country  \n    FROM country_populations  \n    ORDER BY population DESC  \n    LIMIT 3  \n);", "raw_model_output": "\n\nSELECT DISTINCT tech_type  \nFROM smart_city_tech  \nWHERE country IN (  \n    SELECT country  \n    FROM country_populations  \n    ORDER BY population DESC  \n    LIMIT 3  \n);", "latency_sec": 3.56494402885437, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 741, "prompt_eval_sec": null, "tokens_completion": 551, "completion_eval_sec": null, "tokens_total": 1292, "tokens_per_sec": 362.4180322447298, "retrieval_latency_sec": 0.10621309280395508, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve distinct tech_types from smart_city_tech where the country is among the top 3 most populous countries. The reference query uses ROW_NUMBER() to explicitly rank countries by population and filter the top 3, while the generated query uses ORDER BY ... LIMIT 3 to achieve the same result. Since both approaches ultimately select the same set of countries (assuming deterministic ordering), the queries are semantically equivalent."}
{"example_id": 5547, "sql_complexity": "multiple_joins", "prompt": "Which species have a population growth rate higher than the average for protected areas?", "context": "CREATE TABLE species (id INT, name VARCHAR(50), population DECIMAL(5,2), protected_area_id INT, growth_rate DECIMAL(5,2)); INSERT INTO species (id, name, population, protected_area_id, growth_rate) VALUES (1, 'Species 1', 500.00, 1, 0.05), (2, 'Species 2', 800.00, 1, 0.03), (3, 'Species 3', 1200.00, 2, 0.07), (4, 'Species 4', 700.00, 2, 0.02); CREATE TABLE protected_areas (id INT, name VARCHAR(50)); INSERT INTO protected_areas (id, name) VALUES (1, 'Area 1'), (2, 'Area 2');", "reference_sql": "SELECT s.name, s.growth_rate FROM species s INNER JOIN protected_areas pa ON s.protected_area_id = pa.id GROUP BY s.name, s.growth_rate HAVING s.growth_rate > (SELECT AVG(s.growth_rate) FROM species s INNER JOIN protected_areas pa ON s.protected_area_id = pa.id);", "generated_sql": "SELECT s.name\nFROM species s\nINNER JOIN (\n    SELECT protected_area_id, AVG(growth_rate) AS avg_growth\n    FROM species\n    GROUP BY protected_area_id\n) pa_avg ON s.protected_area_id = pa_avg.protected_area_id\nWHERE s.growth_rate > pa_avg.avg_growth;", "raw_model_output": "\n\nTo determine which species have a population growth rate higher than the average for their respective protected areas, we need to:\n\n1. **Calculate the average growth rate** of species within each protected area.\n2. **Compare each species' growth rate** to the average of its corresponding protected area.\n3. **Return the names of species** whose growth rate exceeds the average for their protected area.\n\nThis approach ensures that we are comparing each species to the average growth rate of other species within the same protected area, which aligns with the phrasing of the question.\n\n---\n\n### \u2705 Final SQL Query\n\n```sql\nSELECT s.name\nFROM species s\nINNER JOIN (\n    SELECT protected_area_id, AVG(growth_rate) AS avg_growth\n    FROM species\n    GROUP BY protected_area_id\n) pa_avg ON s.protected_area_id = pa_avg.protected_area_id\nWHERE s.growth_rate > pa_avg.avg_growth;\n```\n\n---\n\n### \ud83d\udccc Explanation\n\n- **Subquery (`pa_avg`)**: Computes the average growth rate for each `protected_area_id`.\n- **Join**: Links each species to the average growth rate of its protected area.\n- **Filter (`WHERE`)**: Selects only those species whose growth rate is greater than the average for their protected area.\n\nThis query is efficient, uses standard ANSI SQL, and adheres strictly to the schema provided.", "latency_sec": 18.62017798423767, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1179, "prompt_eval_sec": null, "tokens_completion": 2898, "completion_eval_sec": null, "tokens_total": 4077, "tokens_per_sec": 218.95601661011278, "retrieval_latency_sec": 0.10545682907104492, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the overall average growth rate across all species and filters those above that global average. The Generated SQL calculates a per-protected_area average growth rate and filters species based on their specific area's average. The HAVING clause in Reference uses a scalar subquery for the global average, while the Generated SQL uses a per-group average from a derived table. This results in different filtering criteria and thus non-equivalent results."}
{"example_id": 5498, "sql_complexity": "aggregation", "prompt": "Identify the destinations with the highest number of repeat visitors from the US.", "context": "CREATE TABLE RepeatTravelers (Visitor VARCHAR(20), Destination VARCHAR(20), VisitCount INT); INSERT INTO RepeatTravelers (Visitor, Destination, VisitCount) VALUES ('David', 'Paris', 3), ('Ella', 'London', 4), ('Fiona', 'Paris', 2);", "reference_sql": "SELECT Destination, AVG(VisitCount) AS AvgVisitCount FROM RepeatTravelers WHERE Visitor LIKE '%USA%' GROUP BY Destination ORDER BY AvgVisitCount DESC;", "generated_sql": "SELECT Destination, VisitCount \nFROM RepeatTravelers \nORDER BY VisitCount DESC;", "raw_model_output": "\n\nThe provided schema does not include any information about the visitors' countries or regions. Therefore, it is not possible to determine which destinations have the highest number of repeat visitors \"from the US\" based on the given data. The `RepeatTravelers` table only contains `Visitor`, `Destination`, and `VisitCount` columns, but no field to identify the visitor's nationality or country.\n\nIf the question assumes all visitors in the table are from the US (which is not stated in the schema), the SQL to find destinations with the highest repeat visits would be:\n\n```sql\nSELECT Destination, VisitCount \nFROM RepeatTravelers \nORDER BY VisitCount DESC;\n```\n\nHowever, this ignores the \"from the US\" condition, which cannot be enforced with the current schema.", "latency_sec": 8.75827407836914, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 856, "prompt_eval_sec": null, "tokens_completion": 1375, "completion_eval_sec": null, "tokens_total": 2231, "tokens_per_sec": 254.73055307894975, "retrieval_latency_sec": 0.10499811172485352, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query filters rows where Visitor contains 'USA' and calculates the average VisitCount per Destination, while the generated query selects all rows without filtering and returns raw VisitCount values. Additionally, the reference query groups by Destination and orders by the average, whereas the generated query orders by raw VisitCount. The sample data contains no 'USA' visitors, making the reference query return no results, while the generated query returns all three rows."}
{"example_id": 3546, "sql_complexity": "window functions", "prompt": "What are the cryptocurrency exchanges with their corresponding blockchain companies, ranked by exchange ID in ascending order, for the Bitcoin platform?", "context": "CREATE TABLE cryptocurrency_exchanges (exchange_id INT, exchange_name VARCHAR(50), company_id INT); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (1, 'Binance', 1); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (2, 'Coinbase', 2); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (3, 'Kraken', 3); CREATE TABLE blockchain_companies (company_id INT, company_name VARCHAR(50), platform VARCHAR(50)); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (1, 'Binance', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (2, 'Blockstream', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (3, 'Blockchair', 'Bitcoin');", "reference_sql": "SELECT ce.exchange_name, bc.company_name, ce.exchange_id, ROW_NUMBER() OVER (PARTITION BY bc.platform ORDER BY ce.exchange_id ASC) as rank FROM cryptocurrency_exchanges ce JOIN blockchain_companies bc ON ce.company_id = bc.company_id WHERE bc.platform = 'Bitcoin';", "generated_sql": "SELECT ce.exchange_name, bc.company_name, ce.exchange_id, ROW_NUMBER() OVER (ORDER BY ce.exchange_id ASC) AS rank  \nFROM cryptocurrency_exchanges ce  \nJOIN blockchain_companies bc ON ce.company_id = bc.company_id  \nWHERE bc.platform = 'Bitcoin'  \nORDER BY ce.exchange_id ASC;", "raw_model_output": "\n\nSELECT ce.exchange_name, bc.company_name, ce.exchange_id, ROW_NUMBER() OVER (ORDER BY ce.exchange_id ASC) AS rank  \nFROM cryptocurrency_exchanges ce  \nJOIN blockchain_companies bc ON ce.company_id = bc.company_id  \nWHERE bc.platform = 'Bitcoin'  \nORDER BY ce.exchange_id ASC;", "latency_sec": 18.413839101791382, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1034, "prompt_eval_sec": null, "tokens_completion": 2864, "completion_eval_sec": null, "tokens_total": 3898, "tokens_per_sec": 211.6886097707232, "retrieval_latency_sec": 0.11077094078063965, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries produce the same result because the ROW_NUMBER() calculation in the Reference SQL effectively behaves like the Generated SQL's version. The WHERE clause filters bc.platform = 'Bitcoin', making the PARTITION BY bc.platform in the Reference SQL redundant (all rows are in one partition). Both queries order by ce.exchange_id ASC for ranking, and the Generated SQL's additional ORDER BY clause does not affect the rank values. The final result set contains identical rows with matching rank values."}
{"example_id": 486, "sql_complexity": "single join", "prompt": "What is the average price of paintings from African artists in our collection?", "context": "CREATE TABLE Artworks (id INT, title VARCHAR(50), price DECIMAL(10,2), medium VARCHAR(50), artist_nationality VARCHAR(50)); CREATE TABLE Collections (id INT, name VARCHAR(50), continent VARCHAR(50));", "reference_sql": "SELECT AVG(Artworks.price) FROM Artworks INNER JOIN Collections ON Artworks.artist_nationality = Collections.continent WHERE Artworks.medium = 'Painting' AND Collections.continent = 'Africa';", "generated_sql": "SELECT AVG(price) FROM Artworks WHERE medium = 'Painting' AND artist_nationality = 'African';", "raw_model_output": "\n\nSELECT AVG(price) FROM Artworks WHERE medium = 'Painting' AND artist_nationality = 'African';", "latency_sec": 5.611188173294067, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 877, "prompt_eval_sec": null, "tokens_completion": 859, "completion_eval_sec": null, "tokens_total": 1736, "tokens_per_sec": 309.38188960803916, "retrieval_latency_sec": 0.1089639663696289, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Reference SQL uses a JOIN with Collections on Artworks.artist_nationality = Collections.continent and filters Collections.continent = 'Africa', which implies Artworks.artist_nationality = 'Africa'. The Generated SQL incorrectly uses artist_nationality = 'African' (a different string value). Second, the Generated SQL omit the unnecessary JOIN entirely, but the core semantic difference lies in the nationality value comparison. These differences in filtering conditions make the queries non-equivalent."}
{"example_id": 794, "sql_complexity": "multiple_joins", "prompt": "Which suppliers have provided raw materials for the production of chemicals with high environmental impact?", "context": "CREATE TABLE suppliers (id INT, name TEXT); INSERT INTO suppliers (id, name) VALUES (1, 'Supplier1'), (2, 'Supplier2'), (3, 'Supplier3'); CREATE TABLE chemicals (id INT, name TEXT, environmental_impact INT); INSERT INTO chemicals (id, name, environmental_impact) VALUES (1, 'ChemA', 10), (2, 'ChemB', 20), (3, 'ChemC', 15); CREATE TABLE raw_materials (chemical_id INT, supplier_id INT); INSERT INTO raw_materials (chemical_id, supplier_id) VALUES (1, 1), (1, 2), (2, 3), (3, 1);", "reference_sql": "SELECT s.name FROM suppliers s INNER JOIN raw_materials rm ON s.id = rm.supplier_id INNER JOIN chemicals c ON rm.chemical_id = c.id WHERE c.environmental_impact > 10;", "generated_sql": "SELECT DISTINCT s.name\nFROM suppliers s\nJOIN raw_materials rm ON s.id = rm.supplier_id\nJOIN chemicals c ON rm.chemical_id = c.id\nWHERE c.environmental_impact > 15;", "raw_model_output": "\n\nTo determine which suppliers have provided raw materials for chemicals with high environmental impact, we need to:\n\n1. **Identify chemicals with high environmental impact** \u2014 based on the given data, we can define \"high\" as an environmental impact greater than 15 (since the average impact is 15, and 20 is the only value above that).\n2. **Link these chemicals to their suppliers** via the `raw_materials` table.\n3. **Retrieve the supplier names** from the `suppliers` table.\n\n---\n\n### \u2705 SQL Query\n\n```sql\nSELECT DISTINCT s.name\nFROM suppliers s\nJOIN raw_materials rm ON s.id = rm.supplier_id\nJOIN chemicals c ON rm.chemical_id = c.id\nWHERE c.environmental_impact > 15;\n```\n\n---\n\n### \ud83d\udccc Explanation\n\n- **`JOIN raw_materials`** connects suppliers to the chemicals they supply.\n- **`JOIN chemicals`** allows us to access the `environmental_impact` column.\n- **`WHERE c.environmental_impact > 15`** filters for chemicals with high environmental impact.\n- **`SELECT DISTINCT s.name`** ensures we only return unique supplier names.\n\n---\n\n### \ud83e\uddea Result (Based on Sample Data)\n\nGiven the sample data:\n\n- `ChemB` (id=2) has an environmental impact of 20, which is above 15.\n- `ChemB` is supplied by `Supplier3` (id=3).\n\nSo the result will be:\n\n```\nname\n-----\nSupplier3\n```", "latency_sec": 11.488951206207275, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 920, "prompt_eval_sec": null, "tokens_completion": 1797, "completion_eval_sec": null, "tokens_total": 2717, "tokens_per_sec": 236.48807895816054, "retrieval_latency_sec": 0.10703086853027344, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their WHERE conditions (10 vs. 15) and use of DISTINCT. The Reference SQL filters chemicals with environmental_impact > 10 (including 15 and 20), while the Generated SQL filters >15 (only 20). This results in different supplier names being returned. Additionally, the Generated SQL's DISTINCT clause could further alter results if duplicates existed, though the schema structure here may not produce duplicates. The core filter difference makes them non-equivalent."}
{"example_id": 3164, "sql_complexity": "set operations", "prompt": "What is the average age of patients who received therapy in 'clinic_a' and 'clinic_b'?", "context": "CREATE TABLE clinic_a (patient_id INT, age INT, therapy_received BOOLEAN); INSERT INTO clinic_a (patient_id, age, therapy_received) VALUES (1, 35, true), (2, 42, true), (3, 28, false); CREATE TABLE clinic_b (patient_id INT, age INT, therapy_received BOOLEAN); INSERT INTO clinic_b (patient_id, age, therapy_received) VALUES (4, 50, true), (5, 32, false), (6, 45, true);", "reference_sql": "SELECT AVG(age) FROM (SELECT age FROM clinic_a WHERE therapy_received = true UNION ALL SELECT age FROM clinic_b WHERE therapy_received = true) AS combined_clinics;", "generated_sql": "SELECT AVG(age) FROM (\n    SELECT age FROM clinic_a WHERE therapy_received = TRUE\n    UNION ALL\n    SELECT age FROM clinic_b WHERE therapy_received = TRUE\n) AS combined_therapy_patients;", "raw_model_output": "\n\nSELECT AVG(age) FROM (\n    SELECT age FROM clinic_a WHERE therapy_received = TRUE\n    UNION ALL\n    SELECT age FROM clinic_b WHERE therapy_received = TRUE\n) AS combined_therapy_patients;", "latency_sec": 5.367082834243774, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 756, "prompt_eval_sec": null, "tokens_completion": 815, "completion_eval_sec": null, "tokens_total": 1571, "tokens_per_sec": 292.7102205273407, "retrieval_latency_sec": 0.10931015014648438, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average age of patients who received therapy (therapy_received = true) from both clinic_a and clinic_b. The only difference is the alias name of the subquery (combined_clinics vs. combined_therapy_patients), which does not affect the result. The UNION ALL operation and filtering conditions are identical in both queries."}
{"example_id": 3704, "sql_complexity": "aggregation", "prompt": "What is the total sales revenue for each category of garments in the South America region in Q1 2022?", "context": "CREATE TABLE sales_category (sale_id INT, garment_category VARCHAR(50), sale_date DATE, total_sales DECIMAL(10, 2), region VARCHAR(50));", "reference_sql": "SELECT garment_category, SUM(total_sales) FROM sales_category WHERE sale_date BETWEEN '2022-01-01' AND '2022-03-31' AND region = 'South America' GROUP BY garment_category;", "generated_sql": "SELECT garment_category, SUM(total_sales) FROM sales_category WHERE region = 'South America' AND sale_date BETWEEN '2022-01-01' AND '2022-03-31' GROUP BY garment_category;", "raw_model_output": "\n\nSELECT garment_category, SUM(total_sales) FROM sales_category WHERE region = 'South America' AND sale_date BETWEEN '2022-01-01' AND '2022-03-31' GROUP BY garment_category;", "latency_sec": 3.1807150840759277, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 837, "prompt_eval_sec": null, "tokens_completion": 490, "completion_eval_sec": null, "tokens_total": 1327, "tokens_per_sec": 417.2017816507839, "retrieval_latency_sec": 0.10879373550415039, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The two queries are semantically equivalent because the order of conditions in the WHERE clause does not affect the result. Both queries filter for 'South America' region and sales between '2022-01-01' and '2022-03-31', then aggregate by garment_category. The logical AND operator ensures both conditions are applied regardless of order."}
{"example_id": 2851, "sql_complexity": "single join", "prompt": "How many cases were handled by attorneys who joined the firm in 2015 or later?", "context": "CREATE TABLE attorneys (attorney_id INT, join_year INT); CREATE TABLE cases (case_id INT, attorney_id INT, billing_amount INT);", "reference_sql": "SELECT COUNT(DISTINCT cases.case_id) FROM cases INNER JOIN attorneys ON cases.attorney_id = attorneys.attorney_id WHERE attorneys.join_year >= 2015;", "generated_sql": "SELECT COUNT(*) FROM cases INNER JOIN attorneys ON cases.attorney_id = attorneys.attorney_id WHERE attorneys.join_year >= 2015;", "raw_model_output": "\n\nSELECT COUNT(*) FROM cases INNER JOIN attorneys ON cases.attorney_id = attorneys.attorney_id WHERE attorneys.join_year >= 2015;", "latency_sec": 2.8589179515838623, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 909, "prompt_eval_sec": null, "tokens_completion": 426, "completion_eval_sec": null, "tokens_total": 1335, "tokens_per_sec": 466.9598857359302, "retrieval_latency_sec": 0.10721373558044434, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query uses COUNT(DISTINCT cases.case_id) which counts unique case IDs, while the generated query uses COUNT(*) which counts all rows. If there are duplicate case_id entries in the cases table, the two queries would produce different results."}
{"example_id": 3246, "sql_complexity": "single join", "prompt": "What is the average eco-friendliness score of accommodations in Oceania by year?", "context": "CREATE TABLE Accommodations (Accommodation_ID INT, Accommodation_Name VARCHAR(50), City VARCHAR(30), Country VARCHAR(50), Eco_Friendliness_Score INT, Visit_Year INT); INSERT INTO Accommodations (Accommodation_ID, Accommodation_Name, City, Country, Eco_Friendliness_Score, Visit_Year) VALUES (1, 'EcoLodge', 'Sydney', 'Australia', 85, 2019), (2, 'GreenHotel', 'Melbourne', 'Australia', 90, 2019), (3, 'SustainableResort', 'Auckland', 'New Zealand', 80, 2019), (4, 'EcoVilla', 'Wellington', 'New Zealand', 88, 2019); CREATE TABLE Countries (Country VARCHAR(50), Continent VARCHAR(30)); INSERT INTO Countries (Country, Continent) VALUES ('Australia', 'Oceania'), ('New Zealand', 'Oceania');", "reference_sql": "SELECT C.Continent, V.Visit_Year, AVG(A.Eco_Friendliness_Score) AS Avg_Eco_Score  FROM Accommodations A  JOIN Countries C  ON A.Country = C.Country  WHERE C.Continent = 'Oceania'  GROUP BY C.Continent, V.Visit_Year  ORDER BY V.Visit_Year;", "generated_sql": "SELECT a.Visit_Year, AVG(a.Eco_Friendliness_Score) AS Average_Eco_Score\nFROM Accommodations a\nJOIN Countries c ON a.Country = c.Country\nWHERE c.Continent = 'Oceania'\nGROUP BY a.Visit_Year;", "raw_model_output": "\n\nSELECT a.Visit_Year, AVG(a.Eco_Friendliness_Score) AS Average_Eco_Score\nFROM Accommodations a\nJOIN Countries c ON a.Country = c.Country\nWHERE c.Continent = 'Oceania'\nGROUP BY a.Visit_Year;", "latency_sec": 4.009633779525757, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 985, "prompt_eval_sec": null, "tokens_completion": 616, "completion_eval_sec": null, "tokens_total": 1601, "tokens_per_sec": 399.28833605082, "retrieval_latency_sec": 0.10413384437561035, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes 'Continent' in the SELECT and GROUP BY clauses, while the Generated SQL omits it. Although the WHERE clause filters for 'Oceania', the GROUP BY in the Reference query groups by both 'Continent' and 'Visit_Year', whereas the Generated SQL only groups by 'Visit_Year'. This difference in grouping logic could lead to different results if there were multiple continents in the dataset. Additionally, the SELECT list differs in columns, making the result sets structurally unequal."}
{"example_id": 3056, "sql_complexity": "multiple_joins", "prompt": "Identify all suppliers who provide non-GMO ingredients to restaurants with Michelin stars.", "context": "CREATE TABLE Suppliers (id INT, name VARCHAR(50), isNonGMO BOOLEAN); CREATE TABLE Restaurants (id INT, name VARCHAR(50), numStars INT); CREATE TABLE Ingredients (supplierId INT, restaurantId INT, isNonGMO BOOLEAN);", "reference_sql": "SELECT Suppliers.name FROM Suppliers INNER JOIN Ingredients ON Suppliers.id = Ingredients.supplierId INNER JOIN Restaurants ON Ingredients.restaurantId = Restaurants.id WHERE Restaurants.numStars > 2 AND Ingredients.isNonGMO = TRUE;", "generated_sql": "SELECT DISTINCT s.id, s.name  \nFROM Suppliers s  \nJOIN Ingredients i ON s.id = i.supplierId  \nJOIN Restaurants r ON i.restaurantId = r.id  \nWHERE r.numStars > 0 AND i.isNonGMO = TRUE;", "raw_model_output": "\n\nSELECT DISTINCT s.id, s.name  \nFROM Suppliers s  \nJOIN Ingredients i ON s.id = i.supplierId  \nJOIN Restaurants r ON i.restaurantId = r.id  \nWHERE r.numStars > 0 AND i.isNonGMO = TRUE;", "latency_sec": 5.413395166397095, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 793, "prompt_eval_sec": null, "tokens_completion": 817, "completion_eval_sec": null, "tokens_total": 1610, "tokens_per_sec": 297.4103959736495, "retrieval_latency_sec": 0.10640263557434082, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in three key aspects: 1) The Reference query selects only 'Suppliers.name' while the Generated query selects 's.id' and 's.name'. 2) The WHERE clause in the Reference uses 'Restaurants.numStars > 2' whereas the Generated uses 'r.numStars > 0'. 3) The Generated query includes 'DISTINCT' which could eliminate duplicates not present in the Reference query. These differences ensure they do not produce identical results."}
{"example_id": 264, "sql_complexity": "set operations", "prompt": "List the number of community health centers and infectious disease tracking facilities in 'southwest' regions.", "context": "CREATE TABLE centers (id INT, name TEXT, region TEXT); INSERT INTO centers (id, name, region) VALUES (1, 'Center A', 'southwest'); INSERT INTO centers (id, name, region) VALUES (2, 'Center B', 'northeast'); INSERT INTO centers (id, name, region) VALUES (3, 'Center C', 'northwest'); CREATE TABLE diseases (id INT, name TEXT, region TEXT); INSERT INTO diseases (id, name, region) VALUES (1, 'Disease A', 'southwest'); INSERT INTO diseases (id, name, region) VALUES (2, 'Disease B', 'southeast');", "reference_sql": "SELECT COUNT(*) FROM ( (SELECT * FROM centers WHERE region = 'southwest') UNION (SELECT * FROM diseases WHERE region = 'southwest') );", "generated_sql": "SELECT \n    (SELECT COUNT(*) FROM centers WHERE region = 'southwest') AS community_health_centers,\n    (SELECT COUNT(*) FROM diseases WHERE region = 'southwest') AS infectious_disease_facilities;", "raw_model_output": "\n\nSELECT \n    (SELECT COUNT(*) FROM centers WHERE region = 'southwest') AS community_health_centers,\n    (SELECT COUNT(*) FROM diseases WHERE region = 'southwest') AS infectious_disease_facilities;", "latency_sec": 6.282222270965576, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 917, "prompt_eval_sec": null, "tokens_completion": 977, "completion_eval_sec": null, "tokens_total": 1894, "tokens_per_sec": 301.485671520007, "retrieval_latency_sec": 0.11307907104492188, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns a single count of all rows from both tables combined (using UNION), while the Generated SQL returns two separate counts as distinct columns. The Reference SQL's result is a single value (e.g., 2 in this case), whereas the Generated SQL's result has two values (e.g., 1 and 1). The structure and output format differ, making them non-equivalent."}
{"example_id": 2838, "sql_complexity": "basic SQL", "prompt": "What is the minimum safety rating of electric vehicles in the 'green_cars' table?", "context": "CREATE TABLE green_cars (id INT, make VARCHAR(50), model VARCHAR(50), type VARCHAR(50), safety_rating INT);", "reference_sql": "SELECT MIN(safety_rating) FROM green_cars WHERE type = 'Electric';", "generated_sql": "SELECT MIN(safety_rating) FROM green_cars WHERE type = 'electric';", "raw_model_output": "\n\nSELECT MIN(safety_rating) FROM green_cars WHERE type = 'electric';", "latency_sec": 2.687701940536499, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 604, "prompt_eval_sec": null, "tokens_completion": 391, "completion_eval_sec": null, "tokens_total": 995, "tokens_per_sec": 370.20474070922666, "retrieval_latency_sec": 0.09072494506835938, "match_exact": true, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent because SQL string comparisons are typically case-insensitive by default unless explicitly configured otherwise. Both queries select the minimum safety_rating from green_cars where type matches a specific value, differing only in the case of the string literal ('Electric' vs 'electric'). Assuming standard database settings, this difference in casing does not affect the result."}
{"example_id": 1187, "sql_complexity": "multiple_joins", "prompt": "Who are the top 3 authors with the highest number of articles published in The Guardian?", "context": "CREATE TABLE authors (id INT, name VARCHAR(100), publisher VARCHAR(50)); CREATE TABLE articles_authors (article_id INT, author_id INT); INSERT INTO authors (id, name, publisher) VALUES (1, 'Author1', 'The Guardian'), (2, 'Author2', 'The Guardian'), (3, 'Author3', 'The Guardian'); INSERT INTO articles_authors (article_id, author_id) VALUES (1, 1), (2, 2), (3, 1), (3, 2), (3, 3); INSERT INTO articles (id, title, publication_date, publisher) VALUES (1, 'Article1', '2021-01-01', 'The Guardian'), (2, 'Article2', '2021-01-02', 'The Guardian'), (3, 'Article3', '2021-01-03', 'The Guardian');", "reference_sql": "SELECT a.name, COUNT(aa.article_id) AS articles_count FROM authors a JOIN articles_authors aa ON a.id = aa.author_id JOIN articles ar ON aa.article_id = ar.id WHERE ar.publisher = 'The Guardian' GROUP BY a.name ORDER BY articles_count DESC LIMIT 3;", "generated_sql": "SELECT a.name, COUNT(*) AS num_articles  \nFROM articles_authors aa  \nJOIN articles ar ON aa.article_id = ar.id  \nJOIN authors a ON aa.author_id = a.id  \nWHERE ar.publisher = 'The Guardian'  \nGROUP BY a.id, a.name  \nORDER BY num_articles DESC  \nLIMIT 3;", "raw_model_output": "\n\nSELECT a.name, COUNT(*) AS num_articles  \nFROM articles_authors aa  \nJOIN articles ar ON aa.article_id = ar.id  \nJOIN authors a ON aa.author_id = a.id  \nWHERE ar.publisher = 'The Guardian'  \nGROUP BY a.id, a.name  \nORDER BY num_articles DESC  \nLIMIT 3;", "latency_sec": 8.808594942092896, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1081, "prompt_eval_sec": null, "tokens_completion": 1384, "completion_eval_sec": null, "tokens_total": 2465, "tokens_per_sec": 279.84031689557105, "retrieval_latency_sec": 0.11081910133361816, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their GROUP BY clauses. The Reference SQL groups by 'a.name', which may combine authors with identical names (not enforced as unique in the schema). The Generated SQL groups by 'a.id' and 'a.name', ensuring correct aggregation per author. While the sample data has unique names, the schema allows non-unique names, making the queries semantically different."}
{"example_id": 360, "sql_complexity": "window functions", "prompt": "What is the change in crime rate for each category, between this year and last year, for the same time period?", "context": "CREATE TABLE CrimeStatistics (ID INT, CrimeType VARCHAR(50), Date TIMESTAMP, Count INT); INSERT INTO CrimeStatistics (ID, CrimeType, Date, Count) VALUES (1, 'Theft', '2022-01-01 00:00:00', 100), (2, 'Vandalism', '2022-01-01 00:00:00', 50), (3, 'Theft', '2022-01-02 00:00:00', 120), (4, 'Vandalism', '2022-01-02 00:00:00', 60), (5, 'Theft', '2021-01-01 00:00:00', 80), (6, 'Vandalism', '2021-01-01 00:00:00', 40), (7, 'Theft', '2021-01-02 00:00:00', 90), (8, 'Vandalism', '2021-01-02 00:00:00', 45);", "reference_sql": "SELECT CrimeType, (SUM(Count) OVER (PARTITION BY CrimeType ORDER BY EXTRACT(YEAR FROM Date) ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING)) - SUM(Count) OVER (PARTITION BY CrimeType ORDER BY EXTRACT(YEAR FROM Date)) AS CrimeRateChange FROM CrimeStatistics WHERE Date BETWEEN DATE_TRUNC('year', CURRENT_DATE - INTERVAL '1 year') AND CURRENT_DATE;", "generated_sql": "SELECT \n    CrimeType,\n    SUM(CASE WHEN EXTRACT(YEAR FROM Date) = EXTRACT(YEAR FROM CURRENT_DATE) THEN Count ELSE 0 END) \n    - \n    SUM(CASE WHEN EXTRACT(YEAR FROM Date) = EXTRACT(YEAR FROM CURRENT_DATE) - 1 THEN Count ELSE 0 END) AS change\nFROM CrimeStatistics\nGROUP BY CrimeType;", "raw_model_output": "\n\nTo determine the **change in crime rate for each category between this year and last year for the same time period**, we need to:\n\n- **Group the data by `CrimeType`**.\n- **Calculate the total number of crimes for each year** (this year and last year).\n- **Subtract the total for last year from the total for this year** to get the change.\n\nThe key is to use **conditional aggregation** to sum the `Count` values for the current year and the previous year, and then compute the difference.\n\n---\n\n### \u2705 Final SQL Query\n\n```sql\nSELECT \n    CrimeType,\n    SUM(CASE WHEN EXTRACT(YEAR FROM Date) = EXTRACT(YEAR FROM CURRENT_DATE) THEN Count ELSE 0 END) \n    - \n    SUM(CASE WHEN EXTRACT(YEAR FROM Date) = EXTRACT(YEAR FROM CURRENT_DATE) - 1 THEN Count ELSE 0 END) AS change\nFROM CrimeStatistics\nGROUP BY CrimeType;\n```\n\n---\n\n### \ud83d\udd0d Explanation\n\n- `EXTRACT(YEAR FROM Date)` is used to extract the year from the `Date` column.\n- `CURRENT_DATE` gives the current date, and `EXTRACT(YEAR FROM CURRENT_DATE)` gets the current year.\n- The `CASE` statements conditionally sum the `Count` values for the current year and the previous year.\n- The difference between these two sums gives the **change in crime rate** for each `CrimeType`.\n\nThis query is **standard ANSI SQL** and will work across most SQL databases that support the `EXTRACT` and `CURRENT_DATE` functions.", "latency_sec": 32.57139205932617, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 984, "prompt_eval_sec": null, "tokens_completion": 5050, "completion_eval_sec": null, "tokens_total": 6034, "tokens_per_sec": 185.2545936326441, "retrieval_latency_sec": 0.09446191787719727, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in several key aspects.  The Reference SQL uses window functions to calculate a difference between the previous year's sum and the current year's sum, while the Generated SQL calculates the difference between the current year's sum and the previous year's sum (resulting in opposite signs).  Additionally, the Reference SQL includes a WHERE clause that filters data to the last two years, while the Generated SQL does not.  Furthermore, the window function in the Reference SQL may not correctly aggregate data by year due to its use of ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING, which only considers the immediately preceding row, not the entire previous year's data.  These differences mean the queries will not produce the same results."}
{"example_id": 335, "sql_complexity": "single join", "prompt": "List the policy numbers, claim amounts, and claim dates for policies that have more than two claims and the total claim amount exceeds $5000", "context": "CREATE TABLE policies (policy_number INT);CREATE TABLE claims (claim_id INT, policy_number INT, claim_amount DECIMAL(10,2), claim_date DATE);", "reference_sql": "SELECT p.policy_number, c.claim_amount, c.claim_date FROM policies p INNER JOIN claims c ON p.policy_number = c.policy_number GROUP BY p.policy_number, c.claim_amount, c.claim_date HAVING COUNT(c.claim_id) > 2 AND SUM(c.claim_amount) > 5000;", "generated_sql": "SELECT c.policy_number, c.claim_amount, c.claim_date\nFROM claims c\nWHERE c.policy_number IN (\n    SELECT policy_number\n    FROM claims\n    GROUP BY policy_number\n    HAVING COUNT(*) > 2 AND SUM(claim_amount) > 5000\n);", "raw_model_output": "\n\nSELECT c.policy_number, c.claim_amount, c.claim_date\nFROM claims c\nWHERE c.policy_number IN (\n    SELECT policy_number\n    FROM claims\n    GROUP BY policy_number\n    HAVING COUNT(*) > 2 AND SUM(claim_amount) > 5000\n);", "latency_sec": 5.6635730266571045, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1093, "prompt_eval_sec": null, "tokens_completion": 853, "completion_eval_sec": null, "tokens_total": 1946, "tokens_per_sec": 343.59934812187225, "retrieval_latency_sec": 0.10553908348083496, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query groups by policy_number, claim_amount, and claim_date, filtering groups with COUNT(claim_id) > 2 and SUM(claim_amount) > 5000. This returns aggregated rows per (policy, amount, date) combination. The generated query selects all claims for policies meeting the criteria (COUNT(*) > 2 and SUM(claim_amount) > 5000) at the policy level, without grouping. This results in all individual claims for qualifying policies, not aggregated rows. The grouping logic and output structure differ."}
{"example_id": 2866, "sql_complexity": "basic SQL", "prompt": "What is the number of hospitals in 'rural_healthcare' table?", "context": "CREATE TABLE rural_healthcare (name VARCHAR(255), type VARCHAR(255), location VARCHAR(255)); INSERT INTO rural_healthcare (name, type, location) VALUES ('Rural General Hospital', 'Hospital', 'Bushland'), ('Rural Community Hospital', 'Hospital', 'Forest Region');", "reference_sql": "SELECT COUNT(*) FROM rural_healthcare WHERE type = 'Hospital';", "generated_sql": "SELECT COUNT(*) FROM rural_healthcare;", "raw_model_output": "\n\nSELECT COUNT(*) FROM rural_healthcare;", "latency_sec": 1.802398920059204, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 588, "prompt_eval_sec": null, "tokens_completion": 260, "completion_eval_sec": null, "tokens_total": 848, "tokens_per_sec": 470.48408127771484, "retrieval_latency_sec": 0.09524798393249512, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query counts only rows where type = 'Hospital', while the generated query counts all rows without filtering. Although the sample data has only 'Hospital' entries, the generated query would include non-hospital records if present, making them non-equivalent in general."}
{"example_id": 4440, "sql_complexity": "multiple_joins", "prompt": "What is the average session length for each game genre in the last month, sorted by average session length.", "context": "CREATE TABLE game_sessions(id INT, user_id INT, game_name VARCHAR(50), start_time DATETIME, end_time DATETIME); CREATE TABLE games(id INT, name VARCHAR(50), genre VARCHAR(50));", "reference_sql": "SELECT genres.genre, AVG(TIMESTAMPDIFF(SECOND, start_time, end_time)) as avg_session_length FROM game_sessions JOIN games ON game_sessions.game_name = games.name JOIN (SELECT DISTINCT game_name, genre FROM game_sessions JOIN games ON game_sessions.game_name = games.name) genres ON games.name = genres.game_name WHERE start_time >= DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH) GROUP BY genres.genre ORDER BY avg_session_length DESC;", "generated_sql": "SELECT g.genre, AVG(TIMESTAMPDIFF(SECOND, gs.start_time, gs.end_time)) AS avg_session_length\nFROM game_sessions gs\nJOIN games g ON gs.game_name = g.name\nWHERE gs.start_time >= DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH)\nGROUP BY g.genre\nORDER BY avg_session_length DESC;", "raw_model_output": "\n\nSELECT g.genre, AVG(TIMESTAMPDIFF(SECOND, gs.start_time, gs.end_time)) AS avg_session_length\nFROM game_sessions gs\nJOIN games g ON gs.game_name = g.name\nWHERE gs.start_time >= DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH)\nGROUP BY g.genre\nORDER BY avg_session_length DESC;", "latency_sec": 14.774435043334961, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 779, "prompt_eval_sec": null, "tokens_completion": 2324, "completion_eval_sec": null, "tokens_total": 3103, "tokens_per_sec": 210.02495126876778, "retrieval_latency_sec": 0.10853099822998047, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average session length per game genre, filtering sessions from the last month. The Reference SQL uses a redundant subquery to ensure distinct game_name/genre pairs, but since the games table maps each game_name to a single genre, the Generated SQL's direct join achieves the same result. The GROUP BY and aggregation logic are identical, and the WHERE clause filters the same data. The subquery in the Reference SQL does not affect the final output because it only retrieves existing genre information already available via the direct join."}
{"example_id": 451, "sql_complexity": "single join", "prompt": "Which customers have made a transaction over 500 in the \"risk_management\" category?", "context": "CREATE TABLE customers (id INT, name VARCHAR(50), category VARCHAR(50)); INSERT INTO customers (id, name, category) VALUES (1, 'John Doe', 'risk_management'); INSERT INTO customers (id, name, category) VALUES (2, 'Jane Smith', 'compliance'); INSERT INTO customers (id, name, category) VALUES (3, 'Jim Brown', 'risk_management'); CREATE TABLE transactions (id INT, customer_id INT, amount DECIMAL(10, 2)); INSERT INTO transactions (id, customer_id, amount) VALUES (1, 1, 500.00); INSERT INTO transactions (id, customer_id, amount) VALUES (2, 1, 200.00); INSERT INTO transactions (id, customer_id, amount) VALUES (3, 2, 100.00); INSERT INTO transactions (id, customer_id, amount) VALUES (4, 3, 750.00);", "reference_sql": "SELECT c.name FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE c.category = 'risk_management' AND t.amount > 500;", "generated_sql": "SELECT DISTINCT c.name  \nFROM customers c  \nJOIN transactions t ON c.id = t.customer_id  \nWHERE c.category = 'risk_management' AND t.amount > 500;", "raw_model_output": "\n\nSELECT DISTINCT c.name  \nFROM customers c  \nJOIN transactions t ON c.id = t.customer_id  \nWHERE c.category = 'risk_management' AND t.amount > 500;", "latency_sec": 5.1180078983306885, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1294, "prompt_eval_sec": null, "tokens_completion": 772, "completion_eval_sec": null, "tokens_total": 2066, "tokens_per_sec": 403.67268692059963, "retrieval_latency_sec": 0.09785604476928711, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The generated query adds DISTINCT which ensures unique names, while the reference query may return duplicate names if a customer has multiple qualifying transactions. Though in the provided data they return the same result, semantically they differ in handling duplicates."}
{"example_id": 2879, "sql_complexity": "basic SQL", "prompt": "Update the FoodSafetyRecords.OrganicFarms table to include a new record for a certified organic farm in Kenya.", "context": "CREATE TABLE FoodSafetyRecords.OrganicFarms (farmName TEXT, country TEXT, certified BOOLEAN);", "reference_sql": "INSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('Ngong Organic Farm', 'Kenya', TRUE);", "generated_sql": "INSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('Kenya Organic Farm', 'Kenya', TRUE);", "raw_model_output": "\n\nINSERT INTO FoodSafetyRecords.OrganicFarms (farmName, country, certified) VALUES ('Kenya Organic Farm', 'Kenya', TRUE);", "latency_sec": 2.525747060775757, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 578, "prompt_eval_sec": null, "tokens_completion": 387, "completion_eval_sec": null, "tokens_total": 965, "tokens_per_sec": 382.0651778581543, "retrieval_latency_sec": 0.11247992515563965, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The two queries differ in the farmName value inserted. The reference SQL inserts 'Ngong Organic Farm' while the generated SQL inserts 'Kenya Organic Farm'. Since the farmName is a textual field and the values are distinct, the resulting data would not be identical. The country and certified values are the same, but the semantic equivalence requires all inserted values to match, which they do not in this case."}
{"example_id": 5688, "sql_complexity": "single join", "prompt": "What is the total amount donated to a specific cause?", "context": "CREATE TABLE causes (id INT, name TEXT); CREATE TABLE donations (id INT, donor_id INT, cause_id INT, donation_amount DECIMAL(10,2)); INSERT INTO causes (id, name) VALUES (1, 'Cause A'), (2, 'Cause B'); INSERT INTO donations (id, donor_id, cause_id, donation_amount) VALUES (1, 1, 1, 50.00), (2, 2, 1, 100.00);", "reference_sql": "SELECT SUM(donation_amount) FROM donations JOIN causes ON donations.cause_id = causes.id WHERE causes.name = 'Cause A';", "generated_sql": "SELECT c.name, SUM(d.donation_amount) AS total_donation FROM donations d JOIN causes c ON d.cause_id = c.id GROUP BY c.name;", "raw_model_output": "\n\nSELECT c.name, SUM(d.donation_amount) AS total_donation FROM donations d JOIN causes c ON d.cause_id = c.id GROUP BY c.name;", "latency_sec": 4.120272874832153, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 951, "prompt_eval_sec": null, "tokens_completion": 639, "completion_eval_sec": null, "tokens_total": 1590, "tokens_per_sec": 385.89677147651815, "retrieval_latency_sec": 0.10684871673583984, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the total donations for a specific cause ('Cause A') using a WHERE clause, while the Generated SQL groups donations by all causes and returns multiple rows. The Reference query returns a single aggregated value, whereas the Generated query returns a list of cause names with their respective totals. They have different output structures and filtering logic."}
{"example_id": 3273, "sql_complexity": "multiple_joins", "prompt": "List all departments, the number of chemicals they handle, and the number of machines used in their manufacturing processes.", "context": "CREATE TABLE Departments (DepartmentID INT, DepartmentName VARCHAR(20)); INSERT INTO Departments (DepartmentID, DepartmentName) VALUES (1, 'Manufacturing'), (2, 'Engineering'), (3, 'Chemical Safety'), (4, 'Product Development'); CREATE TABLE Chemicals (ChemicalID INT, ChemicalName VARCHAR(20), DepartmentID INT); INSERT INTO Chemicals (ChemicalID, ChemicalName, DepartmentID) VALUES (1, 'Hydrochloric Acid', 1), (2, 'Nitric Acid', 2), (3, 'Sodium Hydroxide', 3), (4, 'New Chemical', 4); CREATE TABLE Machinery (MachineID INT, MachineName VARCHAR(20), DepartmentID INT); INSERT INTO Machinery (MachineID, MachineName, DepartmentID) VALUES (1, 'Mixer 1', 1), (2, 'Cutter 2', 2), (3, 'Dispenser 3', 3), (4, 'Innovator 4', 4);", "reference_sql": "SELECT D.DepartmentName, COUNT(C.ChemicalID) AS ChemicalCount, COUNT(M.MachineID) AS MachineCount FROM Departments D LEFT JOIN Chemicals C ON D.DepartmentID = C.DepartmentID LEFT JOIN Machinery M ON D.DepartmentID = M.DepartmentID GROUP BY D.DepartmentName;", "generated_sql": "SELECT d.DepartmentID, d.DepartmentName, COALESCE(c.ChemicalCount, 0) AS NumberOfChemicals, COALESCE(m.MachineCount, 0) AS NumberOfMachines FROM Departments d LEFT JOIN (SELECT DepartmentID, COUNT(*) AS ChemicalCount FROM Chemicals GROUP BY DepartmentID) c ON d.DepartmentID = c.DepartmentID LEFT JOIN (SELECT DepartmentID, COUNT(*) AS MachineCount FROM Machinery GROUP BY DepartmentID) m ON d.DepartmentID = m.DepartmentID;", "raw_model_output": "\n\nSELECT d.DepartmentID, d.DepartmentName, COALESCE(c.ChemicalCount, 0) AS NumberOfChemicals, COALESCE(m.MachineCount, 0) AS NumberOfMachines FROM Departments d LEFT JOIN (SELECT DepartmentID, COUNT(*) AS ChemicalCount FROM Chemicals GROUP BY DepartmentID) c ON d.DepartmentID = c.DepartmentID LEFT JOIN (SELECT DepartmentID, COUNT(*) AS MachineCount FROM Machinery GROUP BY DepartmentID) m ON d.DepartmentID = m.DepartmentID;", "latency_sec": 9.016743898391724, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1256, "prompt_eval_sec": null, "tokens_completion": 1403, "completion_eval_sec": null, "tokens_total": 2659, "tokens_per_sec": 294.89581050142436, "retrieval_latency_sec": 0.10503196716308594, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL returns DepartmentName with counts, while the Generated SQL includes DepartmentID and uses subqueries with COALESCE. The output columns differ (DepartmentID is present in Generated SQL but not Reference SQL), and the grouping strategy (by DepartmentName vs. DepartmentID) may yield different results if DepartmentNames are not unique. Additionally, the Generated SQL explicitly handles null counts with COALESCE, whereas the Reference SQL relies on LEFT JOIN behavior to produce zeros."}
{"example_id": 1895, "sql_complexity": "window functions", "prompt": "What is the average safety score of chemical production sites in the United States, partitioned by state and ranked in descending order?", "context": "CREATE TABLE production_sites (site_id INT, site_name TEXT, country TEXT, state TEXT, safety_score FLOAT); INSERT INTO production_sites (site_id, site_name, country, state, safety_score) VALUES (1, 'Site A', 'USA', 'NY', 92.5), (2, 'Site B', 'USA', 'CA', 87.4), (3, 'Site C', 'USA', 'TX', 95.3), (4, 'Site D', 'USA', 'FL', 89.2);", "reference_sql": "SELECT state, AVG(safety_score) as avg_safety_score, ROW_NUMBER() OVER (ORDER BY AVG(safety_score) DESC) as rank FROM production_sites WHERE country = 'USA' GROUP BY state ORDER BY rank;", "generated_sql": "SELECT state, AVG(safety_score) AS avg_safety_score \nFROM production_sites \nWHERE country = 'USA' \nGROUP BY state \nORDER BY avg_safety_score DESC;", "raw_model_output": "\n\nSELECT state, AVG(safety_score) AS avg_safety_score \nFROM production_sites \nWHERE country = 'USA' \nGROUP BY state \nORDER BY avg_safety_score DESC;", "latency_sec": 4.503823280334473, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 910, "prompt_eval_sec": null, "tokens_completion": 687, "completion_eval_sec": null, "tokens_total": 1597, "tokens_per_sec": 354.5876249126276, "retrieval_latency_sec": 0.09679484367370605, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a 'rank' column generated by ROW_NUMBER() which the Generated SQL lacks. While both queries group by state and order by average safety score descending, the Reference's ORDER BY uses the derived 'rank' column (which depends on the same AVG(safety_score) as the Generated SQL's ORDER BY), but the additional column makes the result sets structurally different. The Generated SQL omits the rank calculation entirely."}
{"example_id": 4669, "sql_complexity": "set operations", "prompt": "Identify the number of IoT devices in each country and the total number of devices.", "context": "CREATE TABLE device_country (device_id INT, country TEXT); INSERT INTO device_country (device_id, country) VALUES (1, 'USA'), (2, 'Canada'), (3, 'Mexico'), (4, 'Brazil'); CREATE TABLE device_info (device_id INT, device_type TEXT); INSERT INTO device_info (device_id, device_type) VALUES (1, 'Soil Sensor'), (2, 'Temperature Sensor'), (3, 'Humidity Sensor'), (4, 'Precision Sprayer');", "reference_sql": "SELECT country, COUNT(*) AS device_count FROM device_country GROUP BY country UNION SELECT 'Total' AS country, COUNT(*) FROM device_country;", "generated_sql": "SELECT country, COUNT(*) AS num_devices  \nFROM device_country  \nJOIN device_info ON device_country.device_id = device_info.device_id  \nGROUP BY country  \nUNION ALL  \nSELECT 'Total', COUNT(*)  \nFROM device_country  \nJOIN device_info ON device_country.device_id = device_info.device_id;", "raw_model_output": "\n\nSELECT country, COUNT(*) AS num_devices  \nFROM device_country  \nJOIN device_info ON device_country.device_id = device_info.device_id  \nGROUP BY country  \nUNION ALL  \nSELECT 'Total', COUNT(*)  \nFROM device_country  \nJOIN device_info ON device_country.device_id = device_info.device_id;", "latency_sec": 8.168211936950684, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 852, "prompt_eval_sec": null, "tokens_completion": 1281, "completion_eval_sec": null, "tokens_total": 2133, "tokens_per_sec": 261.1342624878415, "retrieval_latency_sec": 0.11299300193786621, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries produce the same result. The Reference SQL counts devices per country from device_country and adds a total. The Generated SQL joins device_country with device_info (which has a 1:1 relationship with device_id) and performs the same counts. Since the join doesn't alter the row count (all device_ids exist in both tables), the grouping and total calculations match. The column names differ (device_count vs num_devices) but the UNION/UNION ALL behavior is equivalent here due to non-overlapping rows. The final output structure and values are identical."}
{"example_id": 5302, "sql_complexity": "multiple_joins", "prompt": "Find the supplier with the lowest average delivery time for orders in the last month.", "context": "CREATE TABLE Suppliers (SupplierID int, SupplierName varchar(50)); CREATE TABLE Products (ProductID int, ProductName varchar(50), SupplierID int); CREATE TABLE Orders (OrderID int, ProductID int, OrderDate date, DeliveryTime int); INSERT INTO Suppliers VALUES (1, 'SupplierA'), (2, 'SupplierB'); INSERT INTO Products VALUES (1, 'Organic Apples', 1), (2, 'Bananas', 2); INSERT INTO Orders VALUES (1, 1, '2022-01-01', 2), (2, 2, '2022-01-03', 3);", "reference_sql": "SELECT SupplierName, AVG(DeliveryTime) as AvgDeliveryTime FROM Orders o JOIN Products p ON o.ProductID = p.ProductID JOIN Suppliers sp ON p.SupplierID = sp.SupplierID WHERE OrderDate >= DATEADD(month, -1, GETDATE()) GROUP BY SupplierName ORDER BY AvgDeliveryTime ASC;", "generated_sql": "SELECT s.SupplierName, AVG(o.DeliveryTime) AS avg_delivery_time  \nFROM Orders o  \nJOIN Products p ON o.ProductID = p.ProductID  \nJOIN Suppliers s ON p.SupplierID = s.SupplierID  \nWHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH)  \nGROUP BY s.SupplierID, s.SupplierName  \nORDER BY avg_delivery_time ASC  \nLIMIT 1;", "raw_model_output": "\n\nSELECT s.SupplierName, AVG(o.DeliveryTime) AS avg_delivery_time  \nFROM Orders o  \nJOIN Products p ON o.ProductID = p.ProductID  \nJOIN Suppliers s ON p.SupplierID = s.SupplierID  \nWHERE o.OrderDate >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH)  \nGROUP BY s.SupplierID, s.SupplierName  \nORDER BY avg_delivery_time ASC  \nLIMIT 1;", "latency_sec": 14.13441777229309, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 903, "prompt_eval_sec": null, "tokens_completion": 2192, "completion_eval_sec": null, "tokens_total": 3095, "tokens_per_sec": 218.96904774294669, "retrieval_latency_sec": 0.10208725929260254, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the Generated SQL includes a LIMIT 1 clause which restricts the result to a single row, while the Reference SQL does not. Second, the Generated SQL groups by both SupplierID and SupplierName (though SupplierName is functionally dependent on SupplierID in this schema), whereas the Reference SQL only groups by SupplierName. Additionally, the date functions (DATEADD vs DATE_SUB) may behave differently across databases, though they aim to achieve similar date calculations. These differences in grouping and result limitation make the queries non-equivalent."}
{"example_id": 267, "sql_complexity": "subqueries", "prompt": "What is the total number of disability support programs offered in urban and rural areas, and the percentage of total programs for each area type?", "context": "CREATE TABLE programs (program_id INT, program_name VARCHAR(255), area_type VARCHAR(255));", "reference_sql": "SELECT area_type, COUNT(*) as total_programs, ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM programs) , 2) as percentage_of_total FROM programs WHERE area_type IN ('urban', 'rural') GROUP BY area_type;", "generated_sql": "SELECT \n    area_type,\n    COUNT(*) AS total_programs,\n    (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM programs)) AS percentage\nFROM programs\nWHERE area_type IN ('Urban', 'Rural')\nGROUP BY area_type;", "raw_model_output": "\n\nSELECT \n    area_type,\n    COUNT(*) AS total_programs,\n    (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM programs)) AS percentage\nFROM programs\nWHERE area_type IN ('Urban', 'Rural')\nGROUP BY area_type;", "latency_sec": 10.021166801452637, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1031, "prompt_eval_sec": null, "tokens_completion": 1575, "completion_eval_sec": null, "tokens_total": 2606, "tokens_per_sec": 260.0495582632396, "retrieval_latency_sec": 0.08498311042785645, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the WHERE clause uses different case ('urban'/'rural' vs 'Urban'/'Rural') which may yield different results in case-sensitive databases. Second, the Reference SQL uses ROUND() to limit decimal precision while the Generated SQL does not, leading to potential differences in the percentage values. These discrepancies make the queries non-equivalent."}
{"example_id": 3028, "sql_complexity": "basic SQL", "prompt": "What is the number of startups founded by non-binary individuals in the technology industry?", "context": "CREATE TABLE company (id INT, name TEXT, founder_gender TEXT, industry TEXT); INSERT INTO company (id, name, founder_gender, industry) VALUES (1, 'CodeForAll', 'Non-binary', 'Technology'); INSERT INTO company (id, name, founder_gender, industry) VALUES (2, 'TechVillage', 'Male', 'Technology');", "reference_sql": "SELECT COUNT(*) FROM company WHERE founder_gender = 'Non-binary' AND industry = 'Technology';", "generated_sql": "SELECT COUNT(*) FROM company WHERE founder_gender = 'Non-binary' AND industry = 'Technology';", "raw_model_output": "\n\nSELECT COUNT(*) FROM company WHERE founder_gender = 'Non-binary' AND industry = 'Technology';", "latency_sec": 2.478266954421997, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 767, "prompt_eval_sec": null, "tokens_completion": 354, "completion_eval_sec": null, "tokens_total": 1121, "tokens_per_sec": 452.33222272515405, "retrieval_latency_sec": 0.09096789360046387, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They both count the number of companies where founder_gender is 'Non-binary' and industry is 'Technology'. The SQL syntax, table name, column names, and conditions are exactly the same in both queries."}
{"example_id": 3282, "sql_complexity": "aggregation", "prompt": "Which marine species have been observed in both the Arctic and Antarctic oceans?", "context": "CREATE TABLE marine_species (id INT, species_name VARCHAR(50), common_name VARCHAR(50), region VARCHAR(20));INSERT INTO marine_species (id, species_name, common_name, region) VALUES (1, 'Orcinus_orca', 'Killer Whale', 'Arctic');INSERT INTO marine_species (id, species_name, common_name, region) VALUES (2, 'Balaenoptera_bonaerensis', 'Antarctic Minke Whale', 'Antarctic');", "reference_sql": "SELECT species_name FROM marine_species WHERE region IN ('Arctic', 'Antarctic') GROUP BY species_name HAVING COUNT(DISTINCT region) = 2;", "generated_sql": "SELECT species_name \nFROM marine_species \nWHERE region IN ('Arctic', 'Antarctic') \nGROUP BY species_name \nHAVING COUNT(DISTINCT region) = 2;", "raw_model_output": "\n\nSELECT species_name \nFROM marine_species \nWHERE region IN ('Arctic', 'Antarctic') \nGROUP BY species_name \nHAVING COUNT(DISTINCT region) = 2;", "latency_sec": 3.1206021308898926, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 979, "prompt_eval_sec": null, "tokens_completion": 476, "completion_eval_sec": null, "tokens_total": 1455, "tokens_per_sec": 466.256170755444, "retrieval_latency_sec": 0.1100311279296875, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure and logic. Both queries select species_name from marine_species where region is 'Arctic' or 'Antarctic', group by species_name, and filter with HAVING COUNT(DISTINCT region) = 2. The formatting differences (line breaks, indentation) do not affect semantic equivalence."}
{"example_id": 3474, "sql_complexity": "subqueries", "prompt": "What is the total transaction volume for the top 3 digital assets by market capitalization in the 'developed_markets' schema?", "context": "CREATE SCHEMA developed_markets; CREATE TABLE developed_markets.digital_assets (asset_name VARCHAR(10), market_cap BIGINT, daily_transaction_volume BIGINT); INSERT INTO developed_markets.digital_assets (asset_name, market_cap, daily_transaction_volume) VALUES ('AssetG', 30000000, 15000000), ('AssetH', 25000000, 12000000), ('AssetI', 20000000, 10000000), ('AssetJ', 15000000, 8000000), ('AssetK', 10000000, 6000000);", "reference_sql": "SELECT SUM(daily_transaction_volume) FROM (SELECT daily_transaction_volume FROM developed_markets.digital_assets ORDER BY market_cap DESC FETCH NEXT 3 ROWS ONLY) t;", "generated_sql": "SELECT SUM(daily_transaction_volume) FROM (SELECT daily_transaction_volume FROM developed_markets.digital_assets ORDER BY market_cap DESC LIMIT 3) AS top_assets;", "raw_model_output": "\n\nSELECT SUM(daily_transaction_volume) FROM (SELECT daily_transaction_volume FROM developed_markets.digital_assets ORDER BY market_cap DESC LIMIT 3) AS top_assets;", "latency_sec": 6.703024864196777, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1134, "prompt_eval_sec": null, "tokens_completion": 1040, "completion_eval_sec": null, "tokens_total": 2174, "tokens_per_sec": 324.33118540438386, "retrieval_latency_sec": 0.11262202262878418, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of daily_transaction_volume for the top 3 assets by market_cap. The Reference SQL uses FETCH NEXT 3 ROWS ONLY while the Generated SQL uses LIMIT 3. These clauses are functionally equivalent in this context for limiting the result set to 3 rows after ordering. The ORDER BY market_cap DESC ensures the same top 3 rows are selected, resulting in identical sums."}
{"example_id": 1626, "sql_complexity": "aggregation", "prompt": "Find the total value of social impact bonds issued by each organization.", "context": "CREATE TABLE social_impact_bonds (id INT, organization_name VARCHAR(255), issue_year INT, value FLOAT); INSERT INTO social_impact_bonds (id, organization_name, issue_year, value) VALUES (1, 'Acme Corp', 2018, 2000000), (2, 'XYZ Foundation', 2019, 3000000), (3, 'Global Giving', 2018, 1500000), (4, 'Acme Corp', 2019, 2500000), (5, 'XYZ Foundation', 2018, 1000000);", "reference_sql": "SELECT organization_name, SUM(value) as total_value FROM social_impact_bonds GROUP BY organization_name;", "generated_sql": "SELECT organization_name, SUM(value) AS total_value FROM social_impact_bonds GROUP BY organization_name;", "raw_model_output": "\n\nSELECT organization_name, SUM(value) AS total_value FROM social_impact_bonds GROUP BY organization_name;", "latency_sec": 2.1648378372192383, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1144, "prompt_eval_sec": null, "tokens_completion": 324, "completion_eval_sec": null, "tokens_total": 1468, "tokens_per_sec": 678.1108380319446, "retrieval_latency_sec": 0.10178112983703613, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. They both select organization_name and sum the value column, grouping by organization_name. The only differences are whitespace and case formatting (e.g., 'as' vs 'AS'), which do not affect SQL semantics."}
{"example_id": 1315, "sql_complexity": "single join", "prompt": "List all the transactions made by clients living in New York with a transaction amount greater than $1000.", "context": "CREATE TABLE transactions (id INT, client_id INT, transaction_amount DECIMAL(10,2), transaction_date DATE); INSERT INTO transactions (id, client_id, transaction_amount, transaction_date) VALUES (1, 3, 1500.00, '2022-01-01'), (2, 4, 800.00, '2022-01-02'), (3, 3, 1200.00, '2022-01-03'); CREATE TABLE clients (id INT, name VARCHAR(255), state VARCHAR(255)); INSERT INTO clients (id, name, state) VALUES (3, 'Mike Johnson', 'New York'), (4, 'Sara Lee', 'California');", "reference_sql": "SELECT transactions.id, transactions.client_id, transactions.transaction_amount, transactions.transaction_date FROM transactions INNER JOIN clients ON transactions.client_id = clients.id WHERE clients.state = 'New York' AND transactions.transaction_amount > 1000.00;", "generated_sql": "SELECT * FROM transactions JOIN clients ON transactions.client_id = clients.id WHERE clients.state = 'New York' AND transactions.transaction_amount > 1000;", "raw_model_output": "\n\nSELECT * FROM transactions JOIN clients ON transactions.client_id = clients.id WHERE clients.state = 'New York' AND transactions.transaction_amount > 1000;", "latency_sec": 2.498220205307007, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 963, "prompt_eval_sec": null, "tokens_completion": 377, "completion_eval_sec": null, "tokens_total": 1340, "tokens_per_sec": 536.3818598350209, "retrieval_latency_sec": 0.0991368293762207, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL explicitly selects specific columns from the transactions table, while the Generated SQL uses SELECT * which includes all columns from both tables. This results in different column sets in the output, even though the filtering conditions and join logic are identical."}
{"example_id": 520, "sql_complexity": "multiple_joins", "prompt": "What is the total number of electric vehicles sold in 'California' in the 'sales' schema?", "context": "CREATE TABLE sales_regions (id INT, name VARCHAR(50));   CREATE TABLE sales (id INT, region_id INT, vehicle_count INT);   CREATE TABLE vehicles (id INT, type VARCHAR(50));   INSERT INTO sales_regions VALUES (1, 'California');   INSERT INTO sales VALUES (1, 1, 5000);   INSERT INTO vehicles VALUES (1, 'electric');", "reference_sql": "SELECT SUM(sales.vehicle_count) FROM sales INNER JOIN sales_regions ON sales.region_id = sales_regions.id INNER JOIN vehicles ON sales.id = vehicles.id WHERE vehicles.type = 'electric' AND sales_regions.name = 'California';", "generated_sql": "SELECT SUM(sales.vehicle_count) FROM sales INNER JOIN sales_regions ON sales.region_id = sales_regions.id INNER JOIN vehicles ON sales.id = vehicles.id WHERE sales_regions.name = 'California' AND vehicles.type = 'electric';", "raw_model_output": "\n\nSELECT SUM(sales.vehicle_count) FROM sales INNER JOIN sales_regions ON sales.region_id = sales_regions.id INNER JOIN vehicles ON sales.id = vehicles.id WHERE sales_regions.name = 'California' AND vehicles.type = 'electric';", "latency_sec": 7.205912828445435, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 760, "prompt_eval_sec": null, "tokens_completion": 1123, "completion_eval_sec": null, "tokens_total": 1883, "tokens_per_sec": 261.3131805545625, "retrieval_latency_sec": 0.10075688362121582, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The two queries are semantically equivalent. The only difference is the order of conditions in the WHERE clause, which does not affect the result since AND is commutative. Both queries filter for 'California' region and 'electric' vehicles through the same table joins."}
{"example_id": 3999, "sql_complexity": "single join", "prompt": "What is the total number of tickets sold for performances with a rating of 5?", "context": "CREATE TABLE performance (id INT PRIMARY KEY, name VARCHAR(255), date DATE, artist_id INT, rating INT); INSERT INTO performance (id, name, date, artist_id, rating) VALUES (1, 'Dance Recital', '2022-03-01', 1, 5);", "reference_sql": "SELECT SUM(t.quantity) as total_tickets_sold FROM performance p INNER JOIN ticket t ON p.id = t.performance_id WHERE p.rating = 5;", "generated_sql": "The provided database schema does not include a column for \"tickets_sold\" in the `performance` table, making it impossible to calculate the total number of tickets sold for performances with a rating of 5. The question requires data that is not present in the given schema. \n\n**Answer:**  \nThe SQL query cannot be executed because the `performance` table lacks a `tickets_sold` column.", "raw_model_output": "\n\nThe provided database schema does not include a column for \"tickets_sold\" in the `performance` table, making it impossible to calculate the total number of tickets sold for performances with a rating of 5. The question requires data that is not present in the given schema. \n\n**Answer:**  \nThe SQL query cannot be executed because the `performance` table lacks a `tickets_sold` column.", "latency_sec": 12.937793970108032, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 737, "prompt_eval_sec": null, "tokens_completion": 2039, "completion_eval_sec": null, "tokens_total": 2776, "tokens_per_sec": 214.56517288911658, "retrieval_latency_sec": 0.10732412338256836, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL attempts to calculate total tickets sold by joining the performance table with a ticket table's quantity column. However, the Generated SQL's explanation incorrectly states that the performance table lacks a 'tickets_sold' column. The actual issue is that the schema provided does not include a ticket table, making both queries invalid. Since the Generated SQL is not a query but an explanation, and the Reference SQL references a non-existent table, they are not semantically equivalent."}
{"example_id": 2261, "sql_complexity": "multiple_joins", "prompt": "What is the total number of animals that have been released into 'protected' habitats, and the average weight of those animals?", "context": "CREATE TABLE habitats (habitat_id INT, habitat_name VARCHAR(50), habitat_status VARCHAR(50)); INSERT INTO habitats (habitat_id, habitat_name, habitat_status) VALUES (1, 'Habitat A', 'protected'), (2, 'Habitat B', 'unprotected'); CREATE TABLE animal_habitats (animal_id INT, habitat_id INT, animal_weight FLOAT); INSERT INTO animal_habitats (animal_id, habitat_id, animal_weight) VALUES (101, 1, 25.5), (102, 2, 15.2); CREATE TABLE animals (animal_id INT, animal_name VARCHAR(50)); INSERT INTO animals (animal_id, animal_name) VALUES (101, 'Dog'), (102, 'Cat');", "reference_sql": "SELECT COUNT(*), AVG(animal_habitats.animal_weight) FROM animal_habitats INNER JOIN animals ON animal_habitats.animal_id = animals.animal_id INNER JOIN habitats ON animal_habitats.habitat_id = habitats.habitat_id WHERE habitats.habitat_status = 'protected';", "generated_sql": "SELECT COUNT(*) AS total_animals, AVG(animal_weight) AS average_weight  \nFROM animal_habitats  \nJOIN habitats ON animal_habitats.habitat_id = habitats.habitat_id  \nWHERE habitats.habitat_status = 'protected';", "raw_model_output": "\n\nSELECT COUNT(*) AS total_animals, AVG(animal_weight) AS average_weight  \nFROM animal_habitats  \nJOIN habitats ON animal_habitats.habitat_id = habitats.habitat_id  \nWHERE habitats.habitat_status = 'protected';", "latency_sec": 15.357032775878906, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1028, "prompt_eval_sec": null, "tokens_completion": 2377, "completion_eval_sec": null, "tokens_total": 3405, "tokens_per_sec": 221.72251955782693, "retrieval_latency_sec": 0.09530186653137207, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the count and average animal weight for records where habitat_status is 'protected'. The Reference SQL includes an unnecessary join with the animals table, but since no columns from animals are used in the SELECT or WHERE clauses, it doesn't affect the result. The Generated SQL omits this redundant join but produces the same output."}
{"example_id": 3439, "sql_complexity": "multiple_joins", "prompt": "How many menu items contain ingredients sourced from local suppliers for each restaurant?", "context": "CREATE TABLE restaurants (id INT, name VARCHAR(50), location VARCHAR(50)); INSERT INTO restaurants VALUES (1, 'Restaurant A', 'City A'); INSERT INTO restaurants VALUES (2, 'Restaurant B', 'City B'); CREATE TABLE menu_items (id INT, name VARCHAR(50), restaurant_id INT, price DECIMAL(5,2)); INSERT INTO menu_items VALUES (1, 'Item A', 1, 10.99); INSERT INTO menu_items VALUES (2, 'Item B', 1, 12.99); INSERT INTO menu_items VALUES (3, 'Item C', 2, 11.99); CREATE TABLE ingredients (id INT, name VARCHAR(50), local_source BOOLEAN, menu_item_id INT); INSERT INTO ingredients VALUES (1, 'Ingredient A', TRUE, 1); INSERT INTO ingredients VALUES (2, 'Ingredient B', FALSE, 1); INSERT INTO ingredients VALUES (3, 'Ingredient C', TRUE, 2); INSERT INTO ingredients VALUES (4, 'Ingredient D', FALSE, 2); INSERT INTO ingredients VALUES (5, 'Ingredient E', TRUE, 3);", "reference_sql": "SELECT r.name, COUNT(DISTINCT mi.id) as num_local_items FROM restaurants r JOIN menu_items mi ON r.id = mi.restaurant_id JOIN ingredients i ON mi.id = i.menu_item_id WHERE i.local_source = TRUE GROUP BY r.name;", "generated_sql": "SELECT r.name, COUNT(DISTINCT mi.id) AS local_menu_count\nFROM restaurants r\nJOIN menu_items mi ON r.id = mi.restaurant_id\nJOIN ingredients i ON mi.id = i.menu_item_id\nWHERE i.local_source = TRUE\nGROUP BY r.id, r.name;", "raw_model_output": "\n\nSELECT r.name, COUNT(DISTINCT mi.id) AS local_menu_count\nFROM restaurants r\nJOIN menu_items mi ON r.id = mi.restaurant_id\nJOIN ingredients i ON mi.id = i.menu_item_id\nWHERE i.local_source = TRUE\nGROUP BY r.id, r.name;", "latency_sec": 14.655346870422363, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 924, "prompt_eval_sec": null, "tokens_completion": 2290, "completion_eval_sec": null, "tokens_total": 3214, "tokens_per_sec": 219.30562465816092, "retrieval_latency_sec": 0.09788632392883301, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their GROUP BY clauses. The Reference SQL groups by 'r.name' alone, while the Generated SQL groups by both 'r.id' and 'r.name'. If restaurant names are not unique, grouping by 'r.name' could combine results from multiple restaurants with the same name, whereas grouping by 'r.id' ensures each restaurant is uniquely identified. This difference in grouping logic may lead to different results in cases where restaurant names are not unique."}
{"example_id": 2265, "sql_complexity": "aggregation", "prompt": "Hourly revenue for a specific movie?", "context": "CREATE TABLE Movie_Revenue (id INT, movie_title VARCHAR(100), revenue_time TIME, revenue DECIMAL(10,2));", "reference_sql": "SELECT revenue_time, SUM(revenue) FROM Movie_Revenue WHERE movie_title = 'Spider-Man: No Way Home' GROUP BY revenue_time;", "generated_sql": "SELECT EXTRACT(HOUR FROM revenue_time) AS Hour, SUM(revenue) AS Total_Revenue \nFROM Movie_Revenue \nWHERE movie_title = 'Specific Movie' \nGROUP BY EXTRACT(HOUR FROM revenue_time);", "raw_model_output": "\n\nSELECT EXTRACT(HOUR FROM revenue_time) AS Hour, SUM(revenue) AS Total_Revenue \nFROM Movie_Revenue \nWHERE movie_title = 'Specific Movie' \nGROUP BY EXTRACT(HOUR FROM revenue_time);", "latency_sec": 4.6778340339660645, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 659, "prompt_eval_sec": null, "tokens_completion": 708, "completion_eval_sec": null, "tokens_total": 1367, "tokens_per_sec": 292.22926467123926, "retrieval_latency_sec": 0.10629606246948242, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent.  The WHERE clauses filter for different movie titles ('Spider-Man: No Way Home' vs. 'Specific Movie').  The GROUP BY clauses group by different fields (revenue_time vs. the hour extracted from revenue_time).  Additionally, the selected columns differ (revenue_time vs. Hour). These differences will result in different output."}
{"example_id": 1763, "sql_complexity": "multiple_joins", "prompt": "What is the total food and beverage revenue last month for hotels in 'Bangkok'?", "context": "CREATE TABLE revenue (hotel_id INT, revenue_source VARCHAR(50), revenue INT, revenue_date DATE); INSERT INTO revenue (hotel_id, revenue_source, revenue, revenue_date) VALUES (5, 'Room revenue', 12000, '2022-03-01'), (5, 'Food and beverage', 4000, '2022-03-02'), (5, 'Other revenue', 1000, '2022-03-03'); CREATE TABLE hotels (hotel_id INT, city VARCHAR(50)); INSERT INTO hotels (hotel_id, city) VALUES (5, 'Bangkok'); CREATE TABLE dates (date DATE); INSERT INTO dates (date) VALUES ('2022-03-01'), ('2022-03-02'), ('2022-03-03');", "reference_sql": "SELECT SUM(revenue) FROM revenue JOIN hotels ON revenue.hotel_id = hotels.hotel_id JOIN dates ON revenue.revenue_date = dates.date WHERE hotels.city = 'Bangkok' AND revenue_source = 'Food and beverage' AND dates.date >= DATEADD(month, -1, GETDATE());", "generated_sql": "SELECT SUM(r.revenue) FROM revenue r JOIN hotels h ON r.hotel_id = h.hotel_id WHERE h.city = 'Bangkok' AND r.revenue_source = 'Food and beverage' AND r.revenue_date >= '2022-03-01' AND r.revenue_date <= '2022-03-31';", "raw_model_output": "\n\nSELECT SUM(r.revenue) FROM revenue r JOIN hotels h ON r.hotel_id = h.hotel_id WHERE h.city = 'Bangkok' AND r.revenue_source = 'Food and beverage' AND r.revenue_date >= '2022-03-01' AND r.revenue_date <= '2022-03-31';", "latency_sec": 10.913360834121704, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1125, "prompt_eval_sec": null, "tokens_completion": 1710, "completion_eval_sec": null, "tokens_total": 2835, "tokens_per_sec": 259.7733221773527, "retrieval_latency_sec": 0.08835697174072266, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses a dynamic date condition (DATEADD(month, -1, GETDATE())) which depends on the current date, while the Generated SQL uses a fixed date range ('2022-03-01' to '2022-03-31'). The Reference SQL also includes an unnecessary join with the dates table that doesn't affect the result in this specific dataset. Since the date conditions are not equivalent (dynamic vs. static), the queries may produce different results depending on when they are executed."}
{"example_id": 5499, "sql_complexity": "set operations", "prompt": "How many legal aid clinics and community mediation centers are there in total, and what is the sum of cases handled by each type of center, for centers located in the state of California?", "context": "CREATE TABLE LegalAidClinics (ClinicName text, State text, NumCases int); INSERT INTO LegalAidClinics VALUES ('Clinic1', 'CA', 30, '2022-01-01'), ('Clinic2', 'CA', 25, '2022-01-01'); CREATE TABLE CommunityMediationCenters (CenterName text, State text, NumCases int); INSERT INTO CommunityMediationCenters VALUES ('CM1', 'CA', 22, '2022-01-01'), ('CM2', 'CA', 28, '2022-01-01');", "reference_sql": "SELECT State, 'Legal Aid Clinics' AS CenterType, COUNT(*) AS NumCenters, SUM(NumCases) AS TotalCases FROM LegalAidClinics WHERE State = 'CA' UNION ALL SELECT State, 'Community Mediation Centers', COUNT(*), SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA';", "generated_sql": "SELECT 'Legal Aid Clinics' AS Type, COUNT(*) AS TotalCount, SUM(NumCases) AS TotalCases FROM LegalAidClinics WHERE State = 'CA' UNION ALL SELECT 'Community Mediation Centers' AS Type, COUNT(*) AS TotalCount, SUM(NumCases) AS TotalCases FROM CommunityMediationCenters WHERE State = 'CA';", "raw_model_output": "\n\nSELECT 'Legal Aid Clinics' AS Type, COUNT(*) AS TotalCount, SUM(NumCases) AS TotalCases FROM LegalAidClinics WHERE State = 'CA' UNION ALL SELECT 'Community Mediation Centers' AS Type, COUNT(*) AS TotalCount, SUM(NumCases) AS TotalCases FROM CommunityMediationCenters WHERE State = 'CA';", "latency_sec": 10.6938157081604, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1181, "prompt_eval_sec": null, "tokens_completion": 1657, "completion_eval_sec": null, "tokens_total": 2838, "tokens_per_sec": 265.38703092052873, "retrieval_latency_sec": 0.10942578315734863, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their output structure. The Reference SQL includes a 'State' column and uses 'CenterType' for classification, while the Generated SQL omits 'State' and uses 'Type' instead. Additionally, the column names 'NumCenters' vs 'TotalCount' differ, making the result sets structurally incompatible despite similar data aggregation."}
{"example_id": 2408, "sql_complexity": "aggregation", "prompt": "What is the average number of victories for players from Japan and South Korea, partitioned by game mode?", "context": "CREATE TABLE PlayerVictories (PlayerID INT, GameMode VARCHAR(255), Victories INT, Country VARCHAR(255)); INSERT INTO PlayerVictories (PlayerID, GameMode, Victories, Country) VALUES (1, 'Battle Royale', 25, 'Japan'), (2, 'Team Deathmatch', 18, 'South Korea');", "reference_sql": "SELECT GameMode, AVG(Victories) as AvgVictories FROM PlayerVictories WHERE Country IN ('Japan', 'South Korea') GROUP BY GameMode, Country WITH ROLLUP;", "generated_sql": "SELECT GameMode, AVG(Victories) AS AverageVictories  \nFROM PlayerVictories  \nWHERE Country IN ('Japan', 'South Korea')  \nGROUP BY GameMode;", "raw_model_output": "\n\nSELECT GameMode, AVG(Victories) AS AverageVictories  \nFROM PlayerVictories  \nWHERE Country IN ('Japan', 'South Korea')  \nGROUP BY GameMode;", "latency_sec": 4.245884895324707, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 874, "prompt_eval_sec": null, "tokens_completion": 637, "completion_eval_sec": null, "tokens_total": 1511, "tokens_per_sec": 355.87399028735217, "retrieval_latency_sec": 0.09491610527038574, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL groups by both GameMode and Country with ROLLUP, producing subtotals for each Country-GameMode combination and overall totals. The Generated SQL only groups by GameMode, aggregating across all countries. This difference in grouping fields leads to different result structures and values."}
{"example_id": 2729, "sql_complexity": "subqueries", "prompt": "Find the total number of trips made by shared autonomous vehicles in Seattle", "context": "CREATE TABLE shared_vehicles (id INT, vehicle_type VARCHAR(20), is_autonomous BOOLEAN, trip_count INT); INSERT INTO shared_vehicles (id, vehicle_type, is_autonomous, trip_count) VALUES (1, 'ebike', false, 1200), (2, 'escooter', false, 800), (3, 'car', true, 1500); CREATE TABLE city_data (city VARCHAR(20), has_autonomous_vehicles BOOLEAN); INSERT INTO city_data (city, has_autonomous_vehicles) VALUES ('Seattle', true), ('Denver', false), ('Portland', true);", "reference_sql": "SELECT SUM(trip_count) FROM shared_vehicles WHERE is_autonomous = true AND vehicle_type != 'ebike' AND vehicle_type != 'escooter' AND city IN (SELECT city FROM city_data WHERE has_autonomous_vehicles = true AND city = 'Seattle');", "generated_sql": "SELECT SUM(trip_count) AS total_trips\nFROM shared_vehicles\nWHERE is_autonomous = true;", "raw_model_output": "\n\nTo determine the total number of trips made by **shared autonomous vehicles in Seattle**, we need to consider the structure of the database and the relationships between the tables.\n\n---\n\n### Key Observations:\n\n- The `shared_vehicles` table contains:\n  - `id`, `vehicle_type`, `is_autonomous`, and `trip_count`.\n  - It includes a column `is_autonomous` that indicates whether a vehicle is autonomous.\n  - However, **it does not contain a `city` column**, which is necessary to filter by location (e.g., Seattle).\n\n- The `city_data` table contains:\n  - `city` and `has_autonomous_vehicles`.\n  - It tells us whether a city has autonomous vehicles, but **it does not link to specific vehicles** or their trip counts.\n\n---\n\n### Problem:\n\nThe question asks for the **total number of trips made by shared autonomous vehicles in Seattle**. However, **there is no way to associate the `shared_vehicles` table with the `city_data` table** due to the **absence of a common column** (like `city`) in `shared_vehicles`.\n\nThis means we **cannot filter the vehicles by city** based on the provided schema.\n\n---\n\n### Conclusion:\n\nGiven the schema, the only way to proceed is to **assume that all autonomous vehicles in the `shared_vehicles` table are located in Seattle**, or that the question is asking for the **total number of trips made by autonomous vehicles**, **regardless of city**.\n\nThus, the correct SQL query is:\n\n```sql\nSELECT SUM(trip_count) AS total_trips\nFROM shared_vehicles\nWHERE is_autonomous = true;\n```\n\nThis query sums the `trip_count` for all autonomous vehicles in the `shared_vehicles` table.", "latency_sec": 12.993273735046387, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 785, "prompt_eval_sec": null, "tokens_completion": 2044, "completion_eval_sec": null, "tokens_total": 2829, "tokens_per_sec": 217.7280381902075, "retrieval_latency_sec": 0.10508990287780762, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL references a 'city' column in the shared_vehicles table, which does not exist according to the schema. The Generated SQL correctly sums trip_count for autonomous vehicles without invalid column references. Additionally, the Reference SQL's subquery logic (filtering by city) is irrelevant due to the schema mismatch, making the queries non-equivalent."}
{"example_id": 2952, "sql_complexity": "aggregation", "prompt": "Show the total budget allocated for each program category in 2023.", "context": "CREATE TABLE Budget (id INT, category TEXT, year INT, allocated_amount INT); INSERT INTO Budget (id, category, year, allocated_amount) VALUES (1, 'Education', 2023, 30000); INSERT INTO Budget (id, category, year, allocated_amount) VALUES (2, 'Healthcare', 2023, 50000);", "reference_sql": "SELECT category, SUM(allocated_amount) FROM Budget WHERE year = 2023 GROUP BY category;", "generated_sql": "SELECT category, SUM(allocated_amount) AS total_budget FROM Budget WHERE year = 2023 GROUP BY category;", "raw_model_output": "\n\nSELECT category, SUM(allocated_amount) AS total_budget FROM Budget WHERE year = 2023 GROUP BY category;", "latency_sec": 1.555267095565796, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 819, "prompt_eval_sec": null, "tokens_completion": 200, "completion_eval_sec": null, "tokens_total": 1019, "tokens_per_sec": 655.1929266074355, "retrieval_latency_sec": 0.08692026138305664, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. The only difference is the alias 'total_budget' assigned to the SUM column in the generated query, which does not affect the result set's data or structure. Both queries group by category, filter for 2023, and calculate the same aggregate value."}
{"example_id": 4328, "sql_complexity": "aggregation", "prompt": "What is the average cargo handling time in hours for each port?", "context": "CREATE TABLE cargo_handling (id INT, port_id INT, time_in_hours DECIMAL(5,2)); INSERT INTO cargo_handling (id, port_id, time_in_hours) VALUES (1, 1, 20.5), (2, 1, 22.3), (3, 2, 18.7);", "reference_sql": "SELECT port_id, AVG(time_in_hours) FROM cargo_handling GROUP BY port_id;", "generated_sql": "SELECT port_id, AVG(time_in_hours) AS average_time FROM cargo_handling GROUP BY port_id;", "raw_model_output": "\n\nSELECT port_id, AVG(time_in_hours) AS average_time FROM cargo_handling GROUP BY port_id;", "latency_sec": 3.8681018352508545, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 762, "prompt_eval_sec": null, "tokens_completion": 599, "completion_eval_sec": null, "tokens_total": 1361, "tokens_per_sec": 351.8521636625258, "retrieval_latency_sec": 0.08475112915039062, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries compute the average time_in_hours per port_id using the same GROUP BY clause. The generated query adds an alias (average_time) for the aggregated column, but this does not affect the semantic result (data values) - only the column name in the output."}
{"example_id": 4915, "sql_complexity": "window functions", "prompt": "Calculate the percentage of total Europium production for each country.", "context": "CREATE TABLE europium_production (country VARCHAR(50), quantity INT);", "reference_sql": "SELECT country, quantity * 100.0 / SUM(quantity) OVER (PARTITION BY NULL) AS percentage FROM europium_production;", "generated_sql": "SELECT country, (quantity * 100.0 / SUM(quantity) OVER ()) AS percentage FROM europium_production;", "raw_model_output": "\n\nSELECT country, (quantity * 100.0 / SUM(quantity) OVER ()) AS percentage FROM europium_production;", "latency_sec": 7.0907628536224365, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 791, "prompt_eval_sec": null, "tokens_completion": 1110, "completion_eval_sec": null, "tokens_total": 1901, "tokens_per_sec": 268.09527257407035, "retrieval_latency_sec": 0.08819890022277832, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the percentage of each country's production relative to the total production. The SUM(quantity) OVER (PARTITION BY NULL) in the reference query and SUM(quantity) OVER () in the generated query both compute the total sum of quantities across the entire table. The semantic meaning of the window functions is identical in this context."}
{"example_id": 5030, "sql_complexity": "subqueries", "prompt": "What is the success rate of diverse-led startups (at least 1 female or underrepresented racial or ethnic group executive) in the past 3 years?", "context": "CREATE TABLE DiverseStartups(id INT, name TEXT, country TEXT, year INT, success BOOLEAN);   INSERT INTO DiverseStartups VALUES (1, 'FemTech', 'USA', 2020, true), (2, 'GreenCity', 'Canada', 2019, false), (3, 'AI-Health', 'UK', 2021, true), (4, 'SolarEnergy', 'USA', 2020, false), (5, 'DataAnalytics', 'Germany', 2019, true), (6, 'SmartGrid', 'USA', 2021, true), (7, 'CloudServices', 'India', 2020, false), (8, 'RenewableEnergy', 'USA', 2019, true);", "reference_sql": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3) AS success_rate FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 3 AND success = true;", "generated_sql": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 2) AS success_rate FROM DiverseStartups WHERE success = true AND year >= YEAR(CURRENT_DATE) - 2;", "raw_model_output": "\n\nSELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM DiverseStartups WHERE year >= YEAR(CURRENT_DATE) - 2) AS success_rate FROM DiverseStartups WHERE success = true AND year >= YEAR(CURRENT_DATE) - 2;", "latency_sec": 11.488176107406616, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1398, "prompt_eval_sec": null, "tokens_completion": 1775, "completion_eval_sec": null, "tokens_total": 3173, "tokens_per_sec": 276.1970194689403, "retrieval_latency_sec": 0.10278725624084473, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the number of years considered. The Reference SQL uses 'YEAR(CURRENT_DATE) - 3' while the Generated SQL uses 'YEAR(CURRENT_DATE) - 2', resulting in different time ranges for calculation. This changes the denominator and numerator counts, leading to different success rates."}
{"example_id": 4626, "sql_complexity": "aggregation", "prompt": "What was the maximum number of training hours for farmers in each country in 2020?", "context": "CREATE TABLE training (id INT, country_id INT, farmer_id INT, hours INT, date DATE);", "reference_sql": "SELECT country_id, MAX(hours) FROM training WHERE YEAR(date) = 2020 GROUP BY country_id;", "generated_sql": "SELECT country_id, MAX(hours) AS max_hours FROM training WHERE EXTRACT(YEAR FROM date) = 2020 GROUP BY country_id;", "raw_model_output": "\n\nSELECT country_id, MAX(hours) AS max_hours FROM training WHERE EXTRACT(YEAR FROM date) = 2020 GROUP BY country_id;", "latency_sec": 6.239260196685791, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 661, "prompt_eval_sec": null, "tokens_completion": 962, "completion_eval_sec": null, "tokens_total": 1623, "tokens_per_sec": 260.1269940404337, "retrieval_latency_sec": 0.1038668155670166, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter records where the date is in the year 2020. The reference query uses YEAR(date) = 2020, while the generated query uses EXTRACT(YEAR FROM date) = 2020. Both functions extract the year from the date column and compare it to 2020, resulting in the same filter. The generated query adds an alias (max_hours) for the MAX(hours) column, but this does not affect the semantic equivalence of the result set."}
{"example_id": 2703, "sql_complexity": "set operations", "prompt": "Identify the species unique to 'MarineResearchAreaA' and 'MarineResearchAreaB'", "context": "CREATE TABLE ResearchAreaSpecies (area VARCHAR(255), species VARCHAR(255)); INSERT INTO ResearchAreaSpecies (area, species) VALUES ('MarineResearchAreaA', 'Coral'), ('MarineResearchAreaA', 'Starfish'), ('MarineResearchAreaB', 'Jellyfish');", "reference_sql": "(SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB') UNION (SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA');", "generated_sql": "SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB') \nUNION \n(SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA');", "raw_model_output": "\n\n(SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB') \nUNION \n(SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaB' EXCEPT SELECT species FROM ResearchAreaSpecies WHERE area = 'MarineResearchAreaA');", "latency_sec": 4.137695074081421, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 696, "prompt_eval_sec": null, "tokens_completion": 634, "completion_eval_sec": null, "tokens_total": 1330, "tokens_per_sec": 321.4349960999152, "retrieval_latency_sec": 0.09631681442260742, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform the same operations: they compute the symmetric difference between species in 'MarineResearchAreaA' and 'MarineResearchAreaB' using EXCEPT and UNION. The structure and logic are identical, with only minor formatting differences (parentheses placement and spacing) that do not affect the result."}
{"example_id": 200, "sql_complexity": "window functions", "prompt": "List the top three categories of workforce development programs with the highest budget increases.", "context": "CREATE TABLE programs (program_id INT, program_name VARCHAR(50), budget DECIMAL(10, 2), category VARCHAR(50), budget_date DATE);", "reference_sql": "SELECT category, SUM(budget - LAG(budget) OVER (PARTITION BY category ORDER BY budget_date)) as total_budget_increase FROM programs GROUP BY category ORDER BY total_budget_increase DESC LIMIT 3;", "generated_sql": "SELECT category, SUM(budget) AS total_budget\nFROM programs\nGROUP BY category\nORDER BY total_budget DESC\nLIMIT 3;", "raw_model_output": "\n\nSELECT category, SUM(budget) AS total_budget\nFROM programs\nGROUP BY category\nORDER BY total_budget DESC\nLIMIT 3;", "latency_sec": 16.048097133636475, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 535, "prompt_eval_sec": null, "tokens_completion": 2522, "completion_eval_sec": null, "tokens_total": 3057, "tokens_per_sec": 190.48987394228766, "retrieval_latency_sec": 0.09779810905456543, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates the total budget increase per category by summing the differences between consecutive budgets (using LAG), while the generated query simply sums all budgets per category. The calculations and resulting metrics are fundamentally different."}
{"example_id": 5131, "sql_complexity": "basic SQL", "prompt": "How many wells were drilled in the Eagle Ford Shale and Bakken Formation?", "context": "CREATE TABLE wells (id INT, region VARCHAR(255), well_type VARCHAR(255), num_drilled INT); INSERT INTO wells (id, region, well_type, num_drilled) VALUES (1, 'Eagle Ford Shale', 'Oil', 2000), (2, 'Eagle Ford Shale', 'Gas', 1500), (3, 'Bakken Formation', 'Oil', 1000), (4, 'Bakken Formation', 'Gas', 1200);", "reference_sql": "SELECT SUM(num_drilled) as total_wells FROM wells WHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "generated_sql": "SELECT SUM(num_drilled) FROM wells WHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "raw_model_output": "\n\nSELECT SUM(num_drilled) FROM wells WHERE region IN ('Eagle Ford Shale', 'Bakken Formation');", "latency_sec": 5.678152084350586, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 822, "prompt_eval_sec": null, "tokens_completion": 886, "completion_eval_sec": null, "tokens_total": 1708, "tokens_per_sec": 300.80208747972364, "retrieval_latency_sec": 0.13048863410949707, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of num_drilled for rows where region is 'Eagle Ford Shale' or 'Bakken Formation'. The only difference is the alias (total_wells) in the reference query, which doesn't affect the result's semantic meaning."}
{"example_id": 1160, "sql_complexity": "subqueries", "prompt": "What is the total revenue generated from ads on Instagram in March 2021, for users in the 'brand' category who have posted more than 10 times?", "context": "CREATE TABLE ads (ad_id INT, user_id INT, platform VARCHAR(255), ad_revenue DECIMAL(10,2), post_count INT); INSERT INTO ads (ad_id, user_id, platform, ad_revenue, post_count) VALUES (1, 1, 'Instagram', 150.50, 12), (2, 2, 'Twitter', 80.00, 15), (3, 3, 'Instagram', 120.75, 8);", "reference_sql": "SELECT SUM(ad_revenue) FROM ads WHERE platform = 'Instagram' AND MONTH(ad_date) = 3 AND YEAR(ad_date) = 2021 AND user_id IN (SELECT user_id FROM users WHERE category = 'brand' AND post_count > 10);", "generated_sql": "SELECT SUM(ad_revenue) FROM ads WHERE platform = 'Instagram' AND post_count > 10;", "raw_model_output": "\n\nThe provided schema does not include a `category` column or a `date` column, which are required to answer the question as stated. However, based on the available data, the query can only filter by `platform` and `post_count`. Assuming the question intended to reference `post_count` instead of a `category`, the SQL would be:\n\n```sql\nSELECT SUM(ad_revenue) FROM ads WHERE platform = 'Instagram' AND post_count > 10;\n``` \n\n**Note:** The original question references a \"brand category\" and a specific date (March 2021), but these conditions cannot be fulfilled with the given schema. The above query addresses the available fields.", "latency_sec": 12.899530172348022, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1082, "prompt_eval_sec": null, "tokens_completion": 2023, "completion_eval_sec": null, "tokens_total": 3105, "tokens_per_sec": 240.70644112729076, "retrieval_latency_sec": 0.1390073299407959, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL includes additional conditions: filtering by ad_date (month/year) and a subquery joining with a non-existent 'users' table (missing from the schema) to filter user_id based on category and post_count. The Generated SQL omits these conditions and incorrectly uses ads.post_count instead of users.post_count. The absence of the 'users' table in the schema also makes the Reference SQL invalid."}
{"example_id": 4708, "sql_complexity": "subqueries", "prompt": "What is the maximum number of high-level threats reported by a single agency in a month?", "context": "CREATE TABLE Threat_Intelligence (Threat_ID INT, Threat_Type VARCHAR(50), Threat_Level VARCHAR(50), Reported_Date DATE, Reporting_Agency VARCHAR(50)); CREATE VIEW High_Level_Threats AS SELECT Threat_Type, Threat_Level, Reported_Date FROM Threat_Intelligence WHERE Threat_Level = 'High';", "reference_sql": "SELECT Reporting_Agency, MAX(Number_of_High_Level_Threats) as Max_High_Level_Threats_in_a_Month FROM (SELECT Reporting_Agency, TO_CHAR(Reported_Date, 'YYYY-MM') as Month, COUNT(*) as Number_of_High_Level_Threats FROM High_Level_Threats GROUP BY Reporting_Agency, Month) GROUP BY Reporting_Agency;", "generated_sql": "SELECT MAX(agency_count) FROM (\n    SELECT COUNT(*) AS agency_count\n    FROM Threat_Intelligence\n    WHERE Threat_Level = 'High'\n    AND Reported_Date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH)\n    GROUP BY Reporting_Agency\n) AS subquery;", "raw_model_output": "\n\nSELECT MAX(agency_count) FROM (\n    SELECT COUNT(*) AS agency_count\n    FROM Threat_Intelligence\n    WHERE Threat_Level = 'High'\n    AND Reported_Date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH)\n    GROUP BY Reporting_Agency\n) AS subquery;", "latency_sec": 7.943041086196899, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 671, "prompt_eval_sec": null, "tokens_completion": 1228, "completion_eval_sec": null, "tokens_total": 1899, "tokens_per_sec": 239.07719718333152, "retrieval_latency_sec": 0.12701916694641113, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates the maximum number of high-level threats per agency across all months, while the Generated SQL only considers threats from the last month and returns the maximum count across agencies for that specific time frame. The Generated SQL also lacks the month-based grouping and aggregation present in the Reference SQL."}
{"example_id": 5608, "sql_complexity": "set operations", "prompt": "List the suppliers that provide materials for both product A and product C.", "context": "CREATE TABLE products (product_id INT, product_name TEXT); CREATE TABLE materials (material_id INT, material_name TEXT, product_id INT, supplier_id INT); INSERT INTO products (product_id, product_name) VALUES (1, 'Product A'), (2, 'Product B'), (3, 'Product C'); INSERT INTO materials (material_id, material_name, product_id, supplier_id) VALUES (1, 'Material 1', 1, 101), (2, 'Material 2', 1, 102), (3, 'Material 3', 2, 103), (4, 'Material 4', 3, 101), (5, 'Material 5', 3, 102);", "reference_sql": "SELECT supplier_id FROM materials WHERE product_id = 1 INTERSECT SELECT supplier_id FROM materials WHERE product_id = 3;", "generated_sql": "SELECT supplier_id\nFROM materials\nWHERE product_id IN (1, 3)\nGROUP BY supplier_id\nHAVING COUNT(DISTINCT product_id) = 2;", "raw_model_output": "\n\nTo find the suppliers that provide materials for **both Product A** and **Product C**, we need to identify those `supplier_id`s that appear in the `materials` table for **both** `product_id = 1` (Product A) and `product_id = 3` (Product C).\n\nWe can achieve this by filtering the `materials` table to only include rows where the `product_id` is either 1 or 3, then grouping by `supplier_id` and ensuring that each group contains **exactly two distinct product IDs** (i.e., both Product A and Product C).\n\n---\n\n### \u2705 SQL Query\n\n```sql\nSELECT supplier_id\nFROM materials\nWHERE product_id IN (1, 3)\nGROUP BY supplier_id\nHAVING COUNT(DISTINCT product_id) = 2;\n```\n\n---\n\n### \ud83d\udd0d Explanation\n\n- `WHERE product_id IN (1, 3)`: Filters the rows to only include materials for Product A (`product_id = 1`) and Product C (`product_id = 3`).\n- `GROUP BY supplier_id`: Groups the results by each supplier.\n- `HAVING COUNT(DISTINCT product_id) = 2`: Ensures that the supplier has materials for **both** Product A and Product C (i.e., two distinct product IDs in the group).\n\nThis query will return the `supplier_id`s that supply materials to **both** Product A and Product C.", "latency_sec": 10.76319408416748, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1315, "prompt_eval_sec": null, "tokens_completion": 1678, "completion_eval_sec": null, "tokens_total": 2993, "tokens_per_sec": 278.0773046174708, "retrieval_latency_sec": 0.13791203498840332, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve supplier_ids that have materials for both product_id 1 and 3. The Reference SQL uses INTERSECT to find common supplier_ids between the two product groups, while the Generated SQL uses GROUP BY and HAVING COUNT(DISTINCT product_id) = 2 to ensure suppliers appear in both product groups. Both approaches effectively identify suppliers present in both product_id 1 and 3."}
{"example_id": 1506, "sql_complexity": "basic SQL", "prompt": "How many habitats are in the 'animal_habitats' table?", "context": "CREATE TABLE animal_habitats (id INT PRIMARY KEY, habitat_name VARCHAR, num_animals INT);", "reference_sql": "SELECT COUNT(*) FROM animal_habitats;", "generated_sql": "SELECT COUNT(*) FROM animal_habitats;", "raw_model_output": "\n\nSELECT COUNT(*) FROM animal_habitats;", "latency_sec": 3.1715118885040283, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 634, "prompt_eval_sec": null, "tokens_completion": 475, "completion_eval_sec": null, "tokens_total": 1109, "tokens_per_sec": 349.67549830724573, "retrieval_latency_sec": 0.1345221996307373, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical: they select the count of all rows from the 'animal_habitats' table using the same syntax. The result will be the same for both."}
{"example_id": 3117, "sql_complexity": "aggregation", "prompt": "What is the percentage of the population that has access to clean water in each continent?", "context": "CREATE TABLE water_data (id INT, country VARCHAR(50), continent CHAR(2), access_to_clean_water BOOLEAN); INSERT INTO water_data VALUES (1, 'Canada', 'NA', true), (2, 'Mexico', 'NA', false), (3, 'Brazil', 'SA', true), (4, 'Russia', 'EU', true);", "reference_sql": "SELECT continent, COUNT(*) FILTER (WHERE access_to_clean_water) * 100.0 / COUNT(*) AS percentage FROM water_data GROUP BY continent;", "generated_sql": "SELECT continent, (COUNT(CASE WHEN access_to_clean_water THEN 1 END) * 100.0 / COUNT(*)) AS percentage FROM water_data GROUP BY continent;", "raw_model_output": "\n\nSELECT continent, (COUNT(CASE WHEN access_to_clean_water THEN 1 END) * 100.0 / COUNT(*)) AS percentage FROM water_data GROUP BY continent;", "latency_sec": 5.0885560512542725, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 798, "prompt_eval_sec": null, "tokens_completion": 789, "completion_eval_sec": null, "tokens_total": 1587, "tokens_per_sec": 311.8762933954166, "retrieval_latency_sec": 0.13155102729797363, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the percentage of countries with access to clean water per continent. The Reference SQL uses COUNT(*) FILTER (WHERE access_to_clean_water) while the Generated SQL uses COUNT(CASE WHEN access_to_clean_water THEN 1 END). Both approaches count the number of true values in access_to_clean_water, resulting in identical calculations. The GROUP BY clauses and division by total count are equivalent in both queries."}
{"example_id": 3542, "sql_complexity": "window functions", "prompt": "What is the average yield of crops for each country, ranked by average yield?", "context": "CREATE TABLE farming (id INT, name TEXT, country TEXT, crop TEXT, yield INT); INSERT INTO farming VALUES (1, 'Smith Farm', 'USA', 'Corn', 120), (2, 'Brown Farm', 'Canada', 'Soybeans', 45), (3, 'Jones Farm', 'Mexico', 'Wheat', 80);", "reference_sql": "SELECT country, AVG(yield) as avg_yield, ROW_NUMBER() OVER (ORDER BY AVG(yield) DESC) as rank FROM farming GROUP BY country;", "generated_sql": "SELECT country, AVG(yield) AS average_yield FROM farming GROUP BY country ORDER BY average_yield DESC;", "raw_model_output": "\n\nSELECT country, AVG(yield) AS average_yield FROM farming GROUP BY country ORDER BY average_yield DESC;", "latency_sec": 2.80014705657959, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 673, "prompt_eval_sec": null, "tokens_completion": 428, "completion_eval_sec": null, "tokens_total": 1101, "tokens_per_sec": 393.19363510318044, "retrieval_latency_sec": 0.12179708480834961, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a ROW_NUMBER() column for ranking, while the Generated SQL only returns country and average_yield without ranking. The presence of the rank column and different result structure make them non-equivalent."}
{"example_id": 2274, "sql_complexity": "subqueries", "prompt": "Add a new crop 'amaranth' to farm 'Nourishing Harvest' with yield 50 in 2023", "context": "CREATE TABLE farms (id INT, name TEXT, location TEXT, size FLOAT); INSERT INTO farms (id, name, location, size) VALUES (1, 'Nourishing Harvest', 'Mexico', 120.0); CREATE TABLE crops (id INT, farm_id INT, crop TEXT, yield INT, year INT);", "reference_sql": "INSERT INTO crops (id, farm_id, crop, yield, year) VALUES (5, (SELECT id FROM farms WHERE name = 'Nourishing Harvest'), 'amaranth', 50, 2023);", "generated_sql": "INSERT INTO crops (farm_id, crop, yield, year) VALUES ((SELECT id FROM farms WHERE name = 'Nourishing Harvest'), 'amaranth', 50, 2023);", "raw_model_output": "\n\nINSERT INTO crops (farm_id, crop, yield, year) VALUES ((SELECT id FROM farms WHERE name = 'Nourishing Harvest'), 'amaranth', 50, 2023);", "latency_sec": 3.161139965057373, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1084, "prompt_eval_sec": null, "tokens_completion": 482, "completion_eval_sec": null, "tokens_total": 1566, "tokens_per_sec": 495.39090875768227, "retrieval_latency_sec": 0.13469219207763672, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL explicitly specifies the 'id' column and provides a value (5), while the Generated SQL omits the 'id' column entirely. Since the 'id' column is part of the crops table schema and not auto-generated, the two queries insert different data structures. The Generated SQL would fail if 'id' is a required column, making them semantically distinct."}
{"example_id": 3705, "sql_complexity": "subqueries", "prompt": "What is the percentage of unions with collective bargaining agreements in the Midwest region?", "context": "CREATE TABLE collective_bargaining (bargaining_id INT, union_name VARCHAR(50), contract_start_date DATE, contract_end_date DATE, region VARCHAR(50));CREATE VIEW union_region AS SELECT DISTINCT union_name, region FROM collective_bargaining;", "reference_sql": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM union_region) as percentage FROM union_region ur WHERE ur.region = 'Midwest' AND EXISTS (SELECT 1 FROM collective_bargaining cb WHERE cb.union_name = ur.union_name);", "generated_sql": "SELECT (COUNT(DISTINCT CASE WHEN region = 'Midwest' THEN union_name END) * 100.0 / COUNT(DISTINCT union_name)) AS percentage FROM union_region;", "raw_model_output": "\n\nSELECT (COUNT(DISTINCT CASE WHEN region = 'Midwest' THEN union_name END) * 100.0 / COUNT(DISTINCT union_name)) AS percentage FROM union_region;", "latency_sec": 18.959444999694824, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1156, "prompt_eval_sec": null, "tokens_completion": 2958, "completion_eval_sec": null, "tokens_total": 4114, "tokens_per_sec": 216.98947411520854, "retrieval_latency_sec": 0.12304377555847168, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL counts the number of (union_name, region) pairs in the Midwest (with a redundant EXISTS check) and divides by total union_region rows. The Generated SQL calculates the ratio of distinct union_names in the Midwest to total distinct union_names. They differ in how they count unions: the first counts row pairs, while the second counts unique unions. For example, if a union appears in multiple regions, the Reference SQL counts all its Midwest entries, but the Generated SQL counts it once. This leads to different results in cases with multiple region entries per union."}
{"example_id": 240, "sql_complexity": "aggregation", "prompt": "What is the average capacity of renewable energy projects for each country?", "context": "CREATE TABLE projects (name TEXT, type TEXT, capacity INTEGER, country TEXT); INSERT INTO projects (name, type, capacity, country) VALUES ('Project 1', 'Wind', 100, 'USA'), ('Project 2', 'Solar', 200, 'Germany'), ('Project 3', 'Wind', 300, 'France');", "reference_sql": "SELECT country, AVG(capacity) FROM projects GROUP BY country", "generated_sql": "SELECT country, AVG(capacity) FROM projects GROUP BY country;", "raw_model_output": "\n\nSELECT country, AVG(capacity) FROM projects GROUP BY country;", "latency_sec": 3.209606885910034, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 724, "prompt_eval_sec": null, "tokens_completion": 472, "completion_eval_sec": null, "tokens_total": 1196, "tokens_per_sec": 372.6313042417632, "retrieval_latency_sec": 0.12314605712890625, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and content. The only difference is the presence of a trailing semicolon in the Generated SQL, which does not affect the semantic meaning or execution of the query."}
{"example_id": 2132, "sql_complexity": "set operations", "prompt": "What is the average caseload per attorney in community legal clinics in California, and how does it compare to the state average?", "context": "CREATE TABLE cali_community_legal_clinics(id INT, attorney_count INT, cases_handled INT, state VARCHAR(255));", "reference_sql": "SELECT state, AVG(cases_handled/attorney_count) AS avg_caseload FROM cali_community_legal_clinics WHERE state = 'California' GROUP BY state UNION ALL SELECT 'California', AVG(cases_handled/attorney_count) FROM cali_community_legal_clinics WHERE state = 'California';", "generated_sql": "SELECT \n    (SELECT SUM(cases_handled) * 1.0 / SUM(attorney_count) FROM cali_community_legal_clinics WHERE state = 'California') AS california_avg,\n    (SELECT SUM(cases_handled) * 1.0 / SUM(attorney_count) FROM cali_community_legal_clinics) AS state_avg;", "raw_model_output": "\n\nSELECT \n    (SELECT SUM(cases_handled) * 1.0 / SUM(attorney_count) FROM cali_community_legal_clinics WHERE state = 'California') AS california_avg,\n    (SELECT SUM(cases_handled) * 1.0 / SUM(attorney_count) FROM cali_community_legal_clinics) AS state_avg;", "latency_sec": 21.146905183792114, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 760, "prompt_eval_sec": null, "tokens_completion": 3307, "completion_eval_sec": null, "tokens_total": 4067, "tokens_per_sec": 192.32128600629096, "retrieval_latency_sec": 0.11793994903564453, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates the average caseload per attorney for California clinics and returns two rows with the same value, while the Generated SQL computes total caseload divided by total attorneys for California and all states in a single row. The aggregation methods differ (average of ratios vs. ratio of sums) and the result structures are incompatible."}
{"example_id": 3276, "sql_complexity": "basic SQL", "prompt": "What is the total energy consumption of the Chemical Plant B in the last quarter?", "context": "CREATE TABLE EnergyConsumption (EnergyID INT, Plant VARCHAR(255), EnergyQuantity DECIMAL(5,2), Timestamp DATETIME);", "reference_sql": "SELECT SUM(EnergyQuantity) FROM EnergyConsumption WHERE Plant = 'Chemical Plant B' AND Timestamp BETWEEN DATE_SUB(CURRENT_DATE(), INTERVAL 3 MONTH) AND CURRENT_DATE();", "generated_sql": "SELECT SUM(EnergyQuantity) FROM EnergyConsumption WHERE Plant = 'Chemical Plant B' AND Timestamp >= CURRENT_DATE - INTERVAL '3' MONTH;", "raw_model_output": "\n\nSELECT SUM(EnergyQuantity) FROM EnergyConsumption WHERE Plant = 'Chemical Plant B' AND Timestamp >= CURRENT_DATE - INTERVAL '3' MONTH;", "latency_sec": 11.708884954452515, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 795, "prompt_eval_sec": null, "tokens_completion": 1843, "completion_eval_sec": null, "tokens_total": 2638, "tokens_per_sec": 225.29899390606386, "retrieval_latency_sec": 0.1081850528717041, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query uses BETWEEN with CURRENT_DATE (which is a DATE type, effectively midnight of the current day) as the upper bound, while the generated query uses >= with CURRENT_DATE - INTERVAL '3' MONTH (no upper bound). This means the reference query excludes records from the current day after midnight, whereas the generated query includes all records from three months ago up to the current moment. The absence of an upper bound in the generated query makes them non-equivalent."}
{"example_id": 3074, "sql_complexity": "multiple_joins", "prompt": "Find the top 5 players with the highest scores in the 'historical_tournaments' view, including their scores and the names of the tournaments they participated in.", "context": "CREATE VIEW historical_tournaments AS SELECT tournaments.tournament_name, players.player_name, players.score FROM tournaments JOIN players_scores ON tournaments.tournament_id = players_scores.tournament_id JOIN players ON players_scores.player_id = players.player_id;  CREATE TABLE tournaments (tournament_id INT, tournament_name TEXT);  CREATE TABLE players_scores (player_id INT, tournament_id INT, score INT);  CREATE TABLE players (player_id INT, player_name TEXT);", "reference_sql": "SELECT players.player_name, MAX(players_scores.score) as high_score, tournaments.tournament_name FROM historical_tournaments JOIN players ON historical_tournaments.player_id = players.player_id JOIN players_scores ON historical_tournaments.player_id = players_scores.player_id JOIN tournaments ON players_scores.tournament_id = tournaments.tournament_id GROUP BY players.player_id, tournaments.tournament_name ORDER BY high_score DESC LIMIT 5;", "generated_sql": "SELECT player_name, score, tournament_name\nFROM historical_tournaments\nWHERE player_name IN (\n    SELECT player_name\n    FROM historical_tournaments\n    GROUP BY player_name\n    ORDER BY MAX(score) DESC\n    LIMIT 5\n)\nORDER BY player_name, score DESC;", "raw_model_output": "\n\nSELECT player_name, score, tournament_name\nFROM historical_tournaments\nWHERE player_name IN (\n    SELECT player_name\n    FROM historical_tournaments\n    GROUP BY player_name\n    ORDER BY MAX(score) DESC\n    LIMIT 5\n)\nORDER BY player_name, score DESC;", "latency_sec": 21.74296498298645, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 995, "prompt_eval_sec": null, "tokens_completion": 3392, "completion_eval_sec": null, "tokens_total": 4387, "tokens_per_sec": 201.76641058074475, "retrieval_latency_sec": 0.10950207710266113, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL groups by player_id and tournament_name to get each player's score per tournament, but the MAX(score) is redundant since each group contains a single row. The Generated SQL selects all tournaments for players in the top 5 by their maximum score, returning multiple rows per player. The Reference SQL's GROUP BY and aggregation logic differ fundamentally from the Generated SQL's subquery filtering and ordering strategy."}
{"example_id": 2219, "sql_complexity": "window functions", "prompt": "What is the average population of cities with a UNESCO World Heritage designation, ordered by designation date?", "context": "CREATE TABLE cities (name VARCHAR(255), population INT, designation_date DATE); INSERT INTO cities (name, population, designation_date) VALUES ('Paris', 2141000, '1991-09-16'); INSERT INTO cities (name, population, designation_date) VALUES ('Rio de Janeiro', 6727000, '2012-07-01');", "reference_sql": "SELECT AVG(population) FROM (SELECT population, ROW_NUMBER() OVER (ORDER BY designation_date) rn FROM cities WHERE name IN (SELECT name FROM heritagesites)) t WHERE rn % 2 = 1;", "generated_sql": "SELECT AVG(population) AS average_population\nFROM cities\nORDER BY designation_date;", "raw_model_output": "\n\nThe provided schema does not include any tables or columns that explicitly track UNESCO World Heritage designations. The `cities` table contains a `designation_date` column, but there is no indication that this field relates to UNESCO designations. Without additional context or tables (e.g., a `world_heritage_sites` table linking cities to UNESCO status), it is impossible to determine which cities qualify for the query. \n\nHowever, if we assume that all cities in the `cities` table inherently have a UNESCO designation (despite the lack of explicit data), the SQL query would be:\n\n```sql\nSELECT AVG(population) AS average_population\nFROM cities\nORDER BY designation_date;\n```\n\n**Note:** This query assumes all cities in the table are UNESCO-designated, which is not supported by the schema. The correct answer requires additional data not present in the provided schema.", "latency_sec": 7.825253009796143, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 981, "prompt_eval_sec": null, "tokens_completion": 1214, "completion_eval_sec": null, "tokens_total": 2195, "tokens_per_sec": 280.5021124878852, "retrieval_latency_sec": 0.10940098762512207, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters cities based on a subquery involving 'heritagesites' (which isn't in the provided schema) and averages every other row (odd row numbers) after ordering by designation_date. The Generated SQL calculates the average population of all cities without filtering or row-number-based selection. The presence of the 'heritagesites' subquery and the row-number filtering in the Reference SQL makes it fundamentally different from the Generated SQL, which lacks these elements."}
{"example_id": 3786, "sql_complexity": "aggregation", "prompt": "Display the names and average co-owner percentages for all properties in the 'property_coownership' table where the co-owner percentage is greater than 60.", "context": "CREATE TABLE property_coownership (property_id INT, owner VARCHAR(255), percentage INT); INSERT INTO property_coownership (property_id, owner, percentage) VALUES (1, 'Mohammed', 70), (1, 'Fatima', 30), (2, 'Jamal', 65), (2, 'Aisha', 35), (3, 'Ali', 75), (3, 'Khadija', 25);", "reference_sql": "SELECT owner, AVG(percentage) FROM property_coownership WHERE percentage > 60 GROUP BY owner;", "generated_sql": "SELECT owner, AVG(percentage) FROM property_coownership WHERE percentage > 60 GROUP BY owner;", "raw_model_output": "\n\nSELECT owner, AVG(percentage) FROM property_coownership WHERE percentage > 60 GROUP BY owner;", "latency_sec": 16.28861975669861, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 905, "prompt_eval_sec": null, "tokens_completion": 2539, "completion_eval_sec": null, "tokens_total": 3444, "tokens_per_sec": 211.43596274224973, "retrieval_latency_sec": 0.1070401668548584, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure, conditions, and clauses. Both queries select 'owner' and the average 'percentage' from the 'property_coownership' table where 'percentage' > 60, grouped by 'owner'. Since they are exactly the same, they will produce identical results."}
{"example_id": 2357, "sql_complexity": "basic SQL", "prompt": "What is the total amount of climate finance invested in renewable energy projects by public and private sectors in Africa?", "context": "CREATE TABLE renewable_energy_projects (project_id INT, sector TEXT, investor_type TEXT, region TEXT, amount FLOAT); INSERT INTO renewable_energy_projects (project_id, sector, investor_type, region, amount) VALUES (1, 'Renewable Energy', 'Public', 'Africa', 5000000); INSERT INTO renewable_energy_projects (project_id, sector, investor_type, region, amount) VALUES (2, 'Renewable Energy', 'Private', 'Africa', 7000000);", "reference_sql": "SELECT SUM(amount) FROM renewable_energy_projects WHERE sector = 'Renewable Energy' AND region = 'Africa';", "generated_sql": "SELECT SUM(amount) FROM renewable_energy_projects WHERE sector = 'Renewable Energy' AND region = 'Africa' AND investor_type IN ('Public', 'Private');", "raw_model_output": "\n\nSELECT SUM(amount) FROM renewable_energy_projects WHERE sector = 'Renewable Energy' AND region = 'Africa' AND investor_type IN ('Public', 'Private');", "latency_sec": 3.5394458770751953, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 813, "prompt_eval_sec": null, "tokens_completion": 546, "completion_eval_sec": null, "tokens_total": 1359, "tokens_per_sec": 383.9584068235572, "retrieval_latency_sec": 0.10335683822631836, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The generated query adds an extra condition (investor_type IN ('Public', 'Private')) that isn't present in the reference query. While the existing data satisfies this condition, the reference query could include rows with other investor_type values (e.g., 'Government') that the generated query would exclude. This makes the queries not semantically equivalent."}
{"example_id": 1009, "sql_complexity": "multiple_joins", "prompt": "Find the number of IoT sensors installed in each farm that use Sprinkler irrigation.", "context": "CREATE TABLE IoT_Sensors (id INT, sensor_type VARCHAR(50), Farm_id INT); INSERT INTO IoT_Sensors (id, sensor_type, Farm_id) VALUES (1, 'Soil Moisture', 1), (2, 'Temperature', 1), (3, 'Humidity', 2); CREATE TABLE Irrigation (id INT, Farm_id INT, irrigation_type VARCHAR(50), duration INT); INSERT INTO Irrigation (id, Farm_id, irrigation_type, duration) VALUES (1, 1, 'Sprinkler', 30), (2, 2, 'Drip', 45);", "reference_sql": "SELECT f.id, COUNT(s.id) FROM Farmers f JOIN Irrigation i ON f.id = i.Farm_id JOIN IoT_Sensors s ON f.id = s.Farm_id WHERE i.irrigation_type = 'Sprinkler' GROUP BY f.id;", "generated_sql": "SELECT i.Farm_id, COUNT(*) AS num_sensors  \nFROM IoT_Sensors i  \nJOIN Irrigation ir ON i.Farm_id = ir.Farm_id  \nWHERE ir.irrigation_type = 'Sprinkler'  \nGROUP BY i.Farm_id;", "raw_model_output": "\n\nSELECT i.Farm_id, COUNT(*) AS num_sensors  \nFROM IoT_Sensors i  \nJOIN Irrigation ir ON i.Farm_id = ir.Farm_id  \nWHERE ir.irrigation_type = 'Sprinkler'  \nGROUP BY i.Farm_id;", "latency_sec": 5.22527813911438, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 864, "prompt_eval_sec": null, "tokens_completion": 814, "completion_eval_sec": null, "tokens_total": 1678, "tokens_per_sec": 321.13123078351583, "retrieval_latency_sec": 0.11169314384460449, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of IoT_Sensors per Farm_id where the irrigation_type is 'Sprinkler'. The Reference SQL uses Farmers table and counts s.id, while the Generated SQL directly joins IoT_Sensors and Irrigation, counting all rows. Since the Farm_id in both tables refers to the same entity and the WHERE condition filters irrigation_type, the grouping and counting logic produce identical results. The COUNT(s.id) in Reference and COUNT(*) in Generated are equivalent in this context because each row in the join represents a valid IoT_Sensor-Irrigation pairing."}
{"example_id": 4217, "sql_complexity": "subqueries", "prompt": "Show consumer preference data for foundations, excluding products from the USA.", "context": "CREATE TABLE cosmetics (product_id INT, product_name VARCHAR(100), product_type VARCHAR(50), is_cruelty_free BOOLEAN, consumer_preference_score INT); INSERT INTO cosmetics (product_id, product_name, product_type, is_cruelty_free, consumer_preference_score) VALUES (1, 'Lipstick A', 'Lipstick', TRUE, 80), (2, 'Foundation B', 'Foundation', FALSE, 90), (3, 'Mascara C', 'Mascara', TRUE, 85), (4, 'Eyeshadow D', 'Eyeshadow', TRUE, 70), (5, 'Blush E', 'Blush', FALSE, 95); CREATE TABLE ingredient_sourcing (ingredient_id INT, ingredient_name VARCHAR(100), sourcing_country VARCHAR(50), is_organic BOOLEAN); INSERT INTO ingredient_sourcing (ingredient_id, ingredient_name, sourcing_country, is_organic) VALUES (1, 'Rosehip Oil', 'Chile', TRUE), (2, 'Shea Butter', 'Ghana', TRUE), (3, 'Jojoba Oil', 'India', TRUE), (4, 'Coconut Oil', 'Philippines', FALSE), (5, 'Aloe Vera', 'USA', TRUE);", "reference_sql": "SELECT * FROM cosmetics WHERE product_type = 'Foundation' AND product_id NOT IN (SELECT cosmetics.product_id FROM cosmetics INNER JOIN ingredient_sourcing ON cosmetics.product_id = ingredient_sourcing.ingredient_id WHERE ingredient_sourcing.sourcing_country = 'USA');", "generated_sql": "-- The question cannot be answered with the current schema.\n-- There is no column in the cosmetics table that indicates the sourcing country.\n-- Therefore, it is not possible to exclude products from the USA.", "raw_model_output": "\n\nTo retrieve the **consumer preference data for foundations, excluding products from the USA**, we need to consider the structure of the provided database schema.\n\n---\n\n### \u2705 Key Observations:\n\n- The **`cosmetics`** table contains:\n  - `product_name`\n  - `product_type`\n  - `consumer_preference_score`\n  - `is_cruelty_free`\n  - `product_id`\n\n- The **`ingredient_sourcing`** table contains:\n  - `ingredient_name`\n  - `sourcing_country`\n  - `is_organic`\n\nHowever, **there is no direct link** between the `cosmetics` and `ingredient_sourcing` tables (e.g., no foreign key or shared column like `ingredient_id` or `product_id`).\n\n---\n\n### \ud83e\udde0 Interpretation:\n\nThe question asks to **exclude products from the USA**, but the `cosmetics` table **does not have a `sourcing_country`** column. Therefore, **we cannot filter by country** based on the current schema.\n\nThis implies that the **question is not answerable** with the given schema, as there is **no way to determine the sourcing country of a product**.\n\n---\n\n### \u2705 Final Answer:\n\n```sql\n-- The question cannot be answered with the current schema.\n-- There is no column in the cosmetics table that indicates the sourcing country.\n-- Therefore, it is not possible to exclude products from the USA.\n```\n\nIf the schema were to include a `sourcing_country` column in the `cosmetics` table, the query would be:\n\n```sql\nSELECT product_name, consumer_preference_score\nFROM cosmetics\nWHERE product_type = 'Foundation' AND sourcing_country != 'USA';\n```\n\nBut with the current schema, this is **not possible**.", "latency_sec": 16.33452796936035, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 972, "prompt_eval_sec": null, "tokens_completion": 2547, "completion_eval_sec": null, "tokens_total": 3519, "tokens_per_sec": 215.43322259454317, "retrieval_latency_sec": 0.134721040725708, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL attempts to exclude products linked to US-sourced ingredients via a join between cosmetics and ingredient_sourcing tables, but the Generated SQL states that the cosmetics table lacks a sourcing country column. While the Reference SQL is syntactically valid, the Generated SQL is not a query but a note about schema limitations. The two cannot be semantically equivalent because one is a query and the other is a descriptive statement about schema constraints."}
{"example_id": 5620, "sql_complexity": "basic SQL", "prompt": "What is the recycling rate of plastic in the residential sector in the state of New York?", "context": "CREATE TABLE recycling_rates_city (sector VARCHAR(20), city VARCHAR(20), material VARCHAR(20), recycling_rate DECIMAL(5,2)); INSERT INTO recycling_rates_city (sector, city, material, recycling_rate) VALUES ('residential', 'New York City', 'plastic', 0.25), ('commercial', 'New York City', 'plastic', 0.30), ('residential', 'New York City', 'paper', 0.45), ('commercial', 'New York City', 'paper', 0.50), ('residential', 'Los Angeles', 'plastic', 0.20), ('commercial', 'Los Angeles', 'plastic', 0.35), ('residential', 'Los Angeles', 'paper', 0.40), ('commercial', 'Los Angeles', 'paper', 0.50);", "reference_sql": "SELECT recycling_rate FROM recycling_rates_city WHERE sector = 'residential' AND material = 'plastic' AND city = 'New York City';", "generated_sql": "SELECT recycling_rate FROM recycling_rates_city WHERE sector = 'residential' AND city = 'New York City' AND material = 'plastic';", "raw_model_output": "\n\nSELECT recycling_rate FROM recycling_rates_city WHERE sector = 'residential' AND city = 'New York City' AND material = 'plastic';", "latency_sec": 3.6479458808898926, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1045, "prompt_eval_sec": null, "tokens_completion": 547, "completion_eval_sec": null, "tokens_total": 1592, "tokens_per_sec": 436.40998303725985, "retrieval_latency_sec": 0.13321971893310547, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The order of conditions in the WHERE clause does not affect the result. Both queries filter for 'residential' sector, 'plastic' material, and 'New York City' city, producing identical results."}
{"example_id": 3151, "sql_complexity": "basic SQL", "prompt": "List all biotech startups that received funding in 2022 and their respective funding amounts.", "context": "CREATE TABLE biotech_startups (name TEXT, funding FLOAT, date DATE); INSERT INTO biotech_startups (name, funding, date) VALUES ('StartupA', 3500000, '2022-02-28'); INSERT INTO biotech_startups (name, funding, date) VALUES ('StartupB', 4500000, '2022-07-12');", "reference_sql": "SELECT name, funding FROM biotech_startups WHERE date BETWEEN '2022-01-01' AND '2022-12-31';", "generated_sql": "SELECT name, funding FROM biotech_startups WHERE date BETWEEN '2022-01-01' AND '2022-12-31';", "raw_model_output": "\n\nSELECT name, funding FROM biotech_startups WHERE date BETWEEN '2022-01-01' AND '2022-12-31';", "latency_sec": 6.674583911895752, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 907, "prompt_eval_sec": null, "tokens_completion": 1038, "completion_eval_sec": null, "tokens_total": 1945, "tokens_per_sec": 291.40393254080317, "retrieval_latency_sec": 0.1394333839416504, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They select the same columns (name, funding) from the same table (biotech_startups) with the same WHERE condition using BETWEEN to filter dates between '2022-01-01' and '2022-12-31'. The sample data shows both entries fall within this range, so both queries would return the same results."}
{"example_id": 2136, "sql_complexity": "window functions", "prompt": "What is the total military equipment sales revenue for each sales representative by fiscal year?", "context": "CREATE TABLE SalesReps (SalesRepID INT, SalesRepName VARCHAR(50), FiscalYear INT, Revenue DECIMAL(10,2)); INSERT INTO SalesReps (SalesRepID, SalesRepName, FiscalYear, Revenue) VALUES (1, 'John Doe', 2020, 150000.00), (2, 'Jane Smith', 2020, 200000.00), (1, 'John Doe', 2021, 180000.00), (2, 'Jane Smith', 2021, 250000.00);", "reference_sql": "SELECT SalesRepName, FiscalYear, SUM(Revenue) OVER (PARTITION BY SalesRepName ORDER BY FiscalYear) AS TotalRevenue FROM SalesReps;", "generated_sql": "SELECT SalesRepName, FiscalYear, SUM(Revenue) AS TotalRevenue\nFROM SalesReps\nGROUP BY SalesRepName, FiscalYear;", "raw_model_output": "\n\nThe question asks for the total military equipment sales revenue by sales representative and fiscal year. However, the provided schema only includes a `SalesReps` table with a `Revenue` column, but no explicit reference to \"military equipment\" or related fields. Assuming the `Revenue` column in the `SalesReps` table represents military equipment sales revenue (as no other table is provided), the SQL query groups by `SalesRepName` and `FiscalYear` to calculate the total revenue.\n\n**SQL Statement:**\n```sql\nSELECT SalesRepName, FiscalYear, SUM(Revenue) AS TotalRevenue\nFROM SalesReps\nGROUP BY SalesRepName, FiscalYear;\n``` \n\n**Explanation:**  \nThis query aggregates the `Revenue` values for each combination of `SalesRepName` and `FiscalYear` using `SUM(Revenue)`, providing the total military equipment sales revenue per sales representative per fiscal year. The assumption is that the `Revenue` column in the `SalesReps` table corresponds to military equipment sales, as no other table or column explicitly references \"military equipment\" in the schema.", "latency_sec": 5.5757529735565186, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 810, "prompt_eval_sec": null, "tokens_completion": 865, "completion_eval_sec": null, "tokens_total": 1675, "tokens_per_sec": 300.4078566507214, "retrieval_latency_sec": 0.1271219253540039, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates a running total (cumulative sum) of Revenue for each SalesRepName ordered by FiscalYear using a window function. The Generated SQL aggregates Revenue by SalesRepName and FiscalYear, returning only the sum for each specific year. The Reference SQL shows cumulative values across years, while the Generated SQL shows per-year totals. For example, John Doe's 2021 row would show 330000 (150000+180000) in Reference SQL but 180000 in Generated SQL."}
{"example_id": 5452, "sql_complexity": "basic SQL", "prompt": "What is the name of the farms with a size greater than 150 acres located in 'Texas'?", "context": "CREATE TABLE farms (id INT PRIMARY KEY, name VARCHAR(50), size INT, location VARCHAR(50)); INSERT INTO farms (id, name, size, location) VALUES (1, 'Smith Farms', 200, 'Texas'), (2, 'Johnson Farms', 100, 'California');", "reference_sql": "SELECT name FROM farms WHERE size > 150 AND location = 'Texas'", "generated_sql": "SELECT name FROM farms WHERE size > 150 AND location = 'Texas';", "raw_model_output": "\n\nSELECT name FROM farms WHERE size > 150 AND location = 'Texas';", "latency_sec": 1.9190599918365479, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1029, "prompt_eval_sec": null, "tokens_completion": 286, "completion_eval_sec": null, "tokens_total": 1315, "tokens_per_sec": 685.231314077649, "retrieval_latency_sec": 0.13175702095031738, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select the 'name' column from the 'farms' table where 'size' is greater than 150 and 'location' is 'Texas'. The whitespace differences (e.g., line breaks) do not affect semantic equivalence."}
{"example_id": 5152, "sql_complexity": "aggregation", "prompt": "How many international tourists visited Portugal in 2020, broken down by continent?", "context": "CREATE TABLE international_tourists(tourist_id INT, country TEXT, arrival_year INT, continent TEXT);INSERT INTO international_tourists (tourist_id, country, arrival_year, continent) VALUES (1, 'Spain', 2020, 'Europe'), (2, 'France', 2020, 'Europe'), (3, 'Brazil', 2020, 'South America'), (4, 'United States', 2020, 'North America'), (5, 'China', 2020, 'Asia');", "reference_sql": "SELECT continent, COUNT(*) FROM international_tourists WHERE arrival_year = 2020 GROUP BY continent;", "generated_sql": "SELECT continent, COUNT(*) AS number_of_tourists \nFROM international_tourists \nWHERE country = 'Portugal' AND arrival_year = 2020 \nGROUP BY continent;", "raw_model_output": "\n\nSELECT continent, COUNT(*) AS number_of_tourists \nFROM international_tourists \nWHERE country = 'Portugal' AND arrival_year = 2020 \nGROUP BY continent;", "latency_sec": 2.6950042247772217, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 926, "prompt_eval_sec": null, "tokens_completion": 410, "completion_eval_sec": null, "tokens_total": 1336, "tokens_per_sec": 495.73206146288635, "retrieval_latency_sec": 0.1454012393951416, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query counts all tourists from 2020 grouped by continent, while the generated query specifically filters for 'Portugal' (which has no entries in the data) and arrives at an empty result. The additional country filter in the generated query makes it non-equivalent."}
{"example_id": 2477, "sql_complexity": "set operations", "prompt": "What is the carbon price in Europe and Australia for the last quarter of 2020?", "context": "CREATE TABLE CarbonPrices (Country TEXT, Year INT, Quarter INT, CarbonPrice NUMBER); INSERT INTO CarbonPrices (Country, Year, Quarter, CarbonPrice) VALUES ('Europe', 2020, 4, 25), ('Australia', 2020, 4, 15); CREATE TABLE CarbonTaxes (Country TEXT, Year INT, Quarter INT, CarbonPrice NUMBER); INSERT INTO CarbonTaxes (Country, Year, Quarter, CarbonPrice) VALUES ('Europe', 2019, 4, 20), ('Australia', 2019, 4, 10);", "reference_sql": "SELECT Context.Country, Context.CarbonPrice FROM ( SELECT * FROM CarbonPrices WHERE CarbonPrices.Country IN ('Europe', 'Australia') AND CarbonPrices.Year = 2020 AND CarbonPrices.Quarter = 4 UNION SELECT * FROM CarbonTaxes WHERE CarbonTaxes.Country IN ('Europe', 'Australia') AND CarbonTaxes.Year = 2020 AND CarbonTaxes.Quarter = 4 ) AS Context;", "generated_sql": "SELECT Country, Year, Quarter, CarbonPrice FROM CarbonPrices WHERE Year = 2020 AND Quarter = 4 AND Country IN ('Europe', 'Australia');", "raw_model_output": "\n\nSELECT Country, Year, Quarter, CarbonPrice FROM CarbonPrices WHERE Year = 2020 AND Quarter = 4 AND Country IN ('Europe', 'Australia');", "latency_sec": 3.741071939468384, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 823, "prompt_eval_sec": null, "tokens_completion": 573, "completion_eval_sec": null, "tokens_total": 1396, "tokens_per_sec": 373.15508030523876, "retrieval_latency_sec": 0.14141106605529785, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL combines data from both CarbonPrices and CarbonTaxes tables using UNION, but the Generated SQL only queries CarbonPrices. While the CarbonTaxes data for 2020 Q4 is empty in the sample data, the Generated SQL selects all columns (Country, Year, Quarter, CarbonPrice) whereas the Reference SQL only selects Country and CarbonPrice. The column differences and exclusion of CarbonTaxes data (even if empty) make them semantically distinct."}
{"example_id": 4573, "sql_complexity": "subqueries", "prompt": "Find the names of all the indigenous communities in the 'Arctic_Communities' table that have a population size greater than the average population size in the 'Antarctic_Communities' table.", "context": "CREATE TABLE Arctic_Communities (name TEXT, population INTEGER); CREATE TABLE Antarctic_Communities (name TEXT, population INTEGER);", "reference_sql": "SELECT name FROM Arctic_Communities WHERE Arctic_Communities.population > (SELECT AVG(population) FROM Antarctic_Communities)", "generated_sql": "SELECT name FROM Arctic_Communities WHERE population > (SELECT AVG(population) FROM Antarctic_Communities);", "raw_model_output": "\n\nSELECT name FROM Arctic_Communities WHERE population > (SELECT AVG(population) FROM Antarctic_Communities);", "latency_sec": 2.574000120162964, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 644, "prompt_eval_sec": null, "tokens_completion": 371, "completion_eval_sec": null, "tokens_total": 1015, "tokens_per_sec": 394.3278759193449, "retrieval_latency_sec": 0.1214909553527832, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries compare the population of Arctic_Communities to the average population of Antarctic_Communities. The generated query omits the table alias in the WHERE clause, but since the column 'population' is unambiguous (only exists in Arctic_Communities), the semantic meaning remains identical."}
{"example_id": 3596, "sql_complexity": "window functions", "prompt": "What is the total revenue for each game in the \"Gaming\" category?", "context": "CREATE TABLE Games (GameID int, GameName varchar(50), Category varchar(50), Revenue decimal(10,2));", "reference_sql": "SELECT Category, SUM(Revenue) OVER(PARTITION BY Category) as TotalRevenue FROM Games;", "generated_sql": "SELECT GameName, Revenue FROM Games WHERE Category = 'Gaming';", "raw_model_output": "\n\nSELECT GameName, Revenue FROM Games WHERE Category = 'Gaming';", "latency_sec": 6.729997873306274, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 815, "prompt_eval_sec": null, "tokens_completion": 1047, "completion_eval_sec": null, "tokens_total": 1862, "tokens_per_sec": 276.67170704249384, "retrieval_latency_sec": 0.1295948028564453, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates a window function to show total revenue per category for all games, while the generated query filters only 'Gaming' category games and returns individual game revenue without aggregation. The output columns, data scope, and purpose differ significantly."}
{"example_id": 5039, "sql_complexity": "subqueries", "prompt": "What is the total number of community policing events in 'City Park' in 2021?", "context": "CREATE TABLE locations (id INT, name VARCHAR(255)); CREATE TABLE community_policing (id INT, location_id INT, year INT, events INT); INSERT INTO locations (id, name) VALUES (1, 'City Park'); INSERT INTO community_policing (id, location_id, year, events) VALUES (1, 1, 2021, 5);", "reference_sql": "SELECT SUM(events) FROM community_policing WHERE location_id = (SELECT id FROM locations WHERE name = 'City Park') AND year = 2021;", "generated_sql": "SELECT SUM(cp.events) FROM community_policing cp JOIN locations l ON cp.location_id = l.id WHERE l.name = 'City Park' AND cp.year = 2021;", "raw_model_output": "\n\nSELECT SUM(cp.events) FROM community_policing cp JOIN locations l ON cp.location_id = l.id WHERE l.name = 'City Park' AND cp.year = 2021;", "latency_sec": 11.229454040527344, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 797, "prompt_eval_sec": null, "tokens_completion": 1755, "completion_eval_sec": null, "tokens_total": 2552, "tokens_per_sec": 227.25949015773844, "retrieval_latency_sec": 0.12424397468566895, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of 'events' from community_policing where the location name is 'City Park' and the year is 2021. The reference query uses a subquery to get the location_id, while the generated query uses a JOIN. Since the location name 'City Park' is unique, both approaches filter the same rows and produce identical results."}
{"example_id": 2724, "sql_complexity": "basic SQL", "prompt": "What is the earliest installation date for solar panels in Italy?", "context": "CREATE TABLE solar_panels_italy (id INT, installation_date DATE); INSERT INTO solar_panels_italy (id, installation_date) VALUES (1, '2018-01-01'), (2, '2019-01-01'), (3, '2020-01-01');", "reference_sql": "SELECT MIN(installation_date) as earliest_date FROM solar_panels_italy;", "generated_sql": "SELECT MIN(installation_date) FROM solar_panels_italy;", "raw_model_output": "\n\nSELECT MIN(installation_date) FROM solar_panels_italy;", "latency_sec": 1.4058399200439453, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 754, "prompt_eval_sec": null, "tokens_completion": 206, "completion_eval_sec": null, "tokens_total": 960, "tokens_per_sec": 682.8657988101456, "retrieval_latency_sec": 0.12136697769165039, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the minimum installation_date from the solar_panels_italy table. The only difference is the presence of an alias ('as earliest_date') in the reference query, which does not affect the semantic result. The generated query omits the alias but returns the same value."}
{"example_id": 2200, "sql_complexity": "single join", "prompt": "Which diversity programs are currently being participated in by employees in the HR department?", "context": "CREATE TABLE Employees (Employee_ID INT, First_Name VARCHAR(20), Last_Name VARCHAR(20), Department VARCHAR(20), Salary DECIMAL(10,2), Date_Hired DATE); CREATE TABLE Diversity_Programs (Program_ID INT, Program_Name VARCHAR(50), Participant_ID INT, Date_Started DATE, Date_Ended DATE);", "reference_sql": "SELECT dp.Program_Name FROM Diversity_Programs dp JOIN Employees e ON dp.Participant_ID = e.Employee_ID WHERE e.Department = 'HR' AND dp.Date_Ended IS NULL;", "generated_sql": "SELECT DISTINCT dp.Program_Name \nFROM Diversity_Programs dp \nJOIN Employees e ON dp.Participant_ID = e.Employee_ID \nWHERE e.Department = 'HR' AND dp.Date_Ended IS NULL;", "raw_model_output": "\n\nSELECT DISTINCT dp.Program_Name \nFROM Diversity_Programs dp \nJOIN Employees e ON dp.Participant_ID = e.Employee_ID \nWHERE e.Department = 'HR' AND dp.Date_Ended IS NULL;", "latency_sec": 3.5908122062683105, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 906, "prompt_eval_sec": null, "tokens_completion": 550, "completion_eval_sec": null, "tokens_total": 1456, "tokens_per_sec": 405.47929447781473, "retrieval_latency_sec": 0.1255800724029541, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The generated query adds DISTINCT which ensures unique Program_Name values, while the reference query may return duplicates. Semantically equivalent only if Program_Name is guaranteed to be unique under the given conditions, but without such a constraint, they are not equivalent."}
{"example_id": 4359, "sql_complexity": "window functions", "prompt": "Which destinations have the least hotel awards?", "context": "CREATE TABLE Destinations (destination_id INT, destination_name TEXT, country TEXT, awards INT); INSERT INTO Destinations (destination_id, destination_name, country, awards) VALUES (1, 'City A', 'Germany', 3), (2, 'City B', 'Switzerland', 5), (3, 'City C', 'Norway', 2);", "reference_sql": "SELECT destination_name, country, awards, RANK() OVER (PARTITION BY country ORDER BY awards ASC) AS rank FROM Destinations;", "generated_sql": "SELECT destination_name, country, awards\nFROM Destinations\nWHERE awards = (SELECT MIN(awards) FROM Destinations);", "raw_model_output": "\n\nTo determine which destinations have the **least hotel awards**, we need to identify the **minimum number of awards** in the `Destinations` table and then retrieve all destinations that have that value.\n\n---\n\n### \u2705 Key Steps:\n1. **Find the minimum number of awards** using a subquery with `MIN(awards)`.\n2. **Select all destinations** that have this minimum value.\n\nThis approach ensures that **all destinations with the least awards are returned**, even if there are multiple entries with the same minimum.\n\n---\n\n### \ud83e\udde0 SQL Query:\n```sql\nSELECT destination_name, country, awards\nFROM Destinations\nWHERE awards = (SELECT MIN(awards) FROM Destinations);\n```\n\n---\n\n### \ud83d\udccc Example Output (based on provided data):\n| destination_name | country  | awards |\n|------------------|----------|--------|\n| City C           | Norway   | 2      |\n\nThis query correctly identifies the destination(s) with the least hotel awards.", "latency_sec": 5.32208776473999, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 816, "prompt_eval_sec": null, "tokens_completion": 824, "completion_eval_sec": null, "tokens_total": 1640, "tokens_per_sec": 308.14974733512724, "retrieval_latency_sec": 0.12819886207580566, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL calculates a rank within each country partition based on awards, while the Generated SQL selects only rows with the absolute minimum awards in the entire table. They produce different results: the first returns ranked rows per country, the second returns all destinations with the global minimum awards."}
{"example_id": 1373, "sql_complexity": "subqueries", "prompt": "What is the total value of military equipment sales to Africa in the last 12 months?", "context": "CREATE TABLE Military_Equipment_Sales(sale_id INT, sale_date DATE, equipment_type VARCHAR(50), country VARCHAR(50), sale_value DECIMAL(10,2));", "reference_sql": "SELECT SUM(sale_value) FROM Military_Equipment_Sales WHERE country IN (SELECT country FROM World_Countries WHERE continent = 'Africa') AND sale_date >= DATE_SUB(CURRENT_DATE, INTERVAL 12 MONTH);", "generated_sql": "SELECT SUM(sale_value) FROM Military_Equipment_Sales WHERE country = 'Africa' AND sale_date >= CURRENT_DATE - INTERVAL '1 year';", "raw_model_output": "\n\nSELECT SUM(sale_value) FROM Military_Equipment_Sales WHERE country = 'Africa' AND sale_date >= CURRENT_DATE - INTERVAL '1 year';", "latency_sec": 2.8678877353668213, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 613, "prompt_eval_sec": null, "tokens_completion": 439, "completion_eval_sec": null, "tokens_total": 1052, "tokens_per_sec": 366.8204954561941, "retrieval_latency_sec": 0.12848377227783203, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their country filtering logic. The Reference SQL uses a subquery to select countries in Africa from World_Countries, while the Generated SQL directly checks for country = 'Africa'. This assumes 'Africa' is a valid country name, which is incorrect (Africa is a continent). Additionally, the date conditions are functionally equivalent (12 months vs 1 year), but the country condition discrepancy makes the queries non-equivalent."}
{"example_id": 904, "sql_complexity": "basic SQL", "prompt": "What is the minimum Shariah-compliant loan amount issued in the last quarter of 2021?", "context": "CREATE TABLE loans (id INT, amount DECIMAL, date DATE, loan_type VARCHAR); INSERT INTO loans (id, amount, date, loan_type) VALUES (1, 5000, '2021-09-05', 'Shariah-compliant'), (2, 7000, '2021-10-07', 'socially responsible'), (3, 9000, '2021-11-03', 'Shariah-compliant'), (4, 11000, '2021-12-31', 'Shariah-compliant');", "reference_sql": "SELECT MIN(amount) FROM loans WHERE EXTRACT(YEAR FROM date) = 2021 AND EXTRACT(QUARTER FROM date) = 4 AND loan_type = 'Shariah-compliant';", "generated_sql": "SELECT MIN(amount) FROM loans WHERE loan_type = 'Shariah-compliant' AND date BETWEEN '2021-10-01' AND '2021-12-31';", "raw_model_output": "\n\nSELECT MIN(amount) FROM loans WHERE loan_type = 'Shariah-compliant' AND date BETWEEN '2021-10-01' AND '2021-12-31';", "latency_sec": 3.814882755279541, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 897, "prompt_eval_sec": null, "tokens_completion": 590, "completion_eval_sec": null, "tokens_total": 1487, "tokens_per_sec": 389.7891745013899, "retrieval_latency_sec": 0.12584280967712402, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter for 'Shariah-compliant' loans in the fourth quarter of 2021. The reference query uses EXTRACT(QUARTER) = 4 and EXTRACT(YEAR) = 2021, which corresponds to October-December 2021. The generated query uses a date range from '2021-10-01' to '2021-12-31', which covers the same period. Since the sample data shows the same minimum amount (9000) for these rows, the results will be identical."}
{"example_id": 3299, "sql_complexity": "set operations", "prompt": "How many schools and hospitals are there in Colombia and which ones need repairs?", "context": "CREATE TABLE schools (id INT, country VARCHAR(20), name VARCHAR(50), needs_repair BOOLEAN); CREATE TABLE hospitals (id INT, country VARCHAR(20), name VARCHAR(50), needs_repair BOOLEAN);", "reference_sql": "SELECT 'Schools' as facility_type, COUNT(*) as total, SUM(needs_repair) as repairs_needed FROM schools WHERE country = 'Colombia' UNION ALL SELECT 'Hospitals' as facility_type, COUNT(*) as total, SUM(needs_repair) as repairs_needed FROM hospitals WHERE country = 'Colombia';", "generated_sql": "SELECT \n    (SELECT COUNT(*) FROM schools WHERE country = 'Colombia') AS total_schools,\n    (SELECT COUNT(*) FROM hospitals WHERE country = 'Colombia') AS total_hospitals,\n    (SELECT COUNT(*) FROM schools WHERE country = 'Colombia' AND needs_repair = TRUE) AS schools_needing_repair,\n    (SELECT COUNT(*) FROM hospitals WHERE country = 'Colombia' AND needs_repair = TRUE) AS hospitals_needing_repair;", "raw_model_output": "\n\nSELECT \n    (SELECT COUNT(*) FROM schools WHERE country = 'Colombia') AS total_schools,\n    (SELECT COUNT(*) FROM hospitals WHERE country = 'Colombia') AS total_hospitals,\n    (SELECT COUNT(*) FROM schools WHERE country = 'Colombia' AND needs_repair = TRUE) AS schools_needing_repair,\n    (SELECT COUNT(*) FROM hospitals WHERE country = 'Colombia' AND needs_repair = TRUE) AS hospitals_needing_repair;", "latency_sec": 16.145328998565674, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1126, "prompt_eval_sec": null, "tokens_completion": 2527, "completion_eval_sec": null, "tokens_total": 3653, "tokens_per_sec": 226.2573900057736, "retrieval_latency_sec": 0.10352802276611328, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL returns two rows (one for Schools, one for Hospitals) with columns facility_type, total, and repairs_needed. The Generated SQL returns a single row with four separate columns for total_schools, total_hospitals, schools_needing_repair, and hospitals_needing_repair. The structure and column organization differ, so the result sets are not equivalent."}
{"example_id": 907, "sql_complexity": "set operations", "prompt": "What is the total quantity of items with type 'E' or type 'F' in warehouse O and warehouse P?", "context": "CREATE TABLE warehouse_o(item_id INT, item_type VARCHAR(10), quantity INT);CREATE TABLE warehouse_p(item_id INT, item_type VARCHAR(10), quantity INT);INSERT INTO warehouse_o(item_id, item_type, quantity) VALUES (1, 'E', 200), (2, 'F', 300), (3, 'E', 50), (4, 'F', 400);INSERT INTO warehouse_p(item_id, item_type, quantity) VALUES (1, 'E', 150), (2, 'F', 250), (3, 'E', 40), (4, 'F', 350);", "reference_sql": "SELECT quantity FROM warehouse_o WHERE item_type IN ('E', 'F') UNION ALL SELECT quantity FROM warehouse_p WHERE item_type IN ('E', 'F');", "generated_sql": "SELECT SUM(quantity) FROM (\n    SELECT quantity FROM warehouse_o WHERE item_type IN ('E', 'F')\n    UNION ALL\n    SELECT quantity FROM warehouse_p WHERE item_type IN ('E', 'F')\n) AS combined;", "raw_model_output": "\n\nSELECT SUM(quantity) FROM (\n    SELECT quantity FROM warehouse_o WHERE item_type IN ('E', 'F')\n    UNION ALL\n    SELECT quantity FROM warehouse_p WHERE item_type IN ('E', 'F')\n) AS combined;", "latency_sec": 14.223889112472534, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1071, "prompt_eval_sec": null, "tokens_completion": 2225, "completion_eval_sec": null, "tokens_total": 3296, "tokens_per_sec": 231.72284133667978, "retrieval_latency_sec": 0.10941696166992188, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns a list of individual quantities from both tables, while the Generated SQL returns the sum of all those quantities. The first produces multiple rows of data, the second produces a single aggregated value. Their result structures and contents differ fundamentally."}
{"example_id": 1400, "sql_complexity": "single join", "prompt": "What is the maximum co-ownership duration for properties in the neighborhood of 'Chinatown' in San Francisco?'", "context": "CREATE TABLE sf_neighborhoods (neighborhood_id INT, name VARCHAR(255), city VARCHAR(255)); INSERT INTO sf_neighborhoods (neighborhood_id, name, city) VALUES (1, 'Chinatown', 'San Francisco'); CREATE TABLE co_ownership (co_ownership_id INT, property_id INT, co_owner_id INT, start_date DATE, end_date DATE); INSERT INTO co_ownership (co_ownership_id, property_id, co_owner_id, start_date, end_date) VALUES (1, 1, 2, '2010-01-01', '2020-01-01'), (2, 2, 3, '2015-01-01', '2022-01-01'); CREATE TABLE properties (property_id INT, city VARCHAR(255)); INSERT INTO properties (property_id, city) VALUES (1, 'San Francisco'), (2, 'San Francisco');", "reference_sql": "SELECT MAX(DATEDIFF(end_date, start_date)) as max_duration FROM co_ownership JOIN properties ON co_ownership.property_id = properties.property_id WHERE properties.city = 'San Francisco' AND name = 'Chinatown';", "generated_sql": "SELECT MAX(DATEDIFF(end_date, start_date)) AS max_co_ownership_duration\nFROM co_ownership\nJOIN properties ON co_ownership.property_id = properties.property_id\nWHERE properties.city = 'San Francisco';", "raw_model_output": "\n\nTo determine the **maximum co-ownership duration** for properties in the **neighborhood of 'Chinatown' in San Francisco**, we need to:\n\n1. **Identify properties located in the 'Chinatown' neighborhood**.\n2. **Link those properties to their co-ownership records**.\n3. **Calculate the duration of each co-ownership** (i.e., `end_date - start_date`).\n4. **Find the maximum duration**.\n\n---\n\n### Assumptions\n\n- The `sf_neighborhoods` table contains the neighborhood name and city.\n- The `properties` table contains the city of the property.\n- The `co_ownership` table contains the `property_id` and the `start_date` and `end_date` of co-ownership.\n\nHowever, **there is no direct link between the `properties` table and the `sf_neighborhoods` table** in the schema provided. This is a **critical missing link**.\n\nGiven this, we can only assume that **properties in San Francisco are in the 'Chinatown' neighborhood**, which is not a valid assumption in a real-world scenario. But since the question explicitly asks for properties in 'Chinatown' in San Francisco, and no other way to link the two tables is provided, we proceed under this assumption.\n\n---\n\n### Final SQL Query\n\n```sql\nSELECT MAX(DATEDIFF(end_date, start_date)) AS max_co_ownership_duration\nFROM co_ownership\nJOIN properties ON co_ownership.property_id = properties.property_id\nWHERE properties.city = 'San Francisco';\n```\n\n---\n\n### Notes\n\n- This query assumes that **all properties in San Francisco are in the 'Chinatown' neighborhood**, which is not a valid assumption in a real-world database.\n- If the schema had a `neighborhood_id` in the `properties` table, the query would include a join with `sf_neighborhoods` and filter by `name = 'Chinatown'`.\n- The `DATEDIFF` function is used to calculate the number of days between `start_date` and `end_date`. If your SQL dialect uses a different function (e.g., `AGE()` in PostgreSQL), adjust accordingly.", "latency_sec": 15.632719993591309, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1005, "prompt_eval_sec": null, "tokens_completion": 2444, "completion_eval_sec": null, "tokens_total": 3449, "tokens_per_sec": 220.62699270593538, "retrieval_latency_sec": 0.09488320350646973, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a WHERE condition filtering on 'name = 'Chinatown'', but the Generated SQL omits this condition. The 'name' column exists in sf_neighborhoods, but the queries join co_ownership with properties (which lacks a 'name' column). This suggests a potential schema inconsistency, but semantically, the queries differ due to the missing 'name' filter in the Generated SQL."}
{"example_id": 5248, "sql_complexity": "window functions", "prompt": "Find the top 5 games by rating", "context": "CREATE TABLE games (game_id INT PRIMARY KEY, name VARCHAR(50), genre VARCHAR(50), rating DECIMAL(3,2));", "reference_sql": "SELECT * FROM (SELECT name, rating, ROW_NUMBER() OVER (ORDER BY rating DESC) as rn FROM games) t WHERE rn <= 5;", "generated_sql": "SELECT name, rating FROM games ORDER BY rating DESC LIMIT 5;", "raw_model_output": "\n\nSELECT name, rating FROM games ORDER BY rating DESC LIMIT 5;", "latency_sec": 5.035249948501587, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 862, "prompt_eval_sec": null, "tokens_completion": 770, "completion_eval_sec": null, "tokens_total": 1632, "tokens_per_sec": 324.1149926401684, "retrieval_latency_sec": 0.10042977333068848, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the top 5 games by rating in descending order. The reference query uses ROW_NUMBER() to assign ranks and filter the top 5, while the generated query uses ORDER BY with LIMIT 5. Since the ordering logic (rating DESC) is identical and both methods select the first 5 rows, the result sets are equivalent."}
{"example_id": 778, "sql_complexity": "single join", "prompt": "What is the maximum property price in wheelchair-accessible neighborhoods in Singapore?", "context": "CREATE TABLE Singapore_Neighborhoods (Neighborhood_Name TEXT, Wheelchair_Accessibility BOOLEAN); INSERT INTO Singapore_Neighborhoods (Neighborhood_Name, Wheelchair_Accessibility) VALUES ('Orchard', true), ('Marina Bay', true), ('Chinatown', false), ('Little India', false), ('Bugis', true); CREATE TABLE Singapore_Properties (Neighborhood_Name TEXT, Property_Price INTEGER); INSERT INTO Singapore_Properties (Neighborhood_Name, Property_Price) VALUES ('Orchard', 2000000), ('Marina Bay', 3000000), ('Chinatown', 1500000), ('Little India', 1200000), ('Bugis', 1800000);", "reference_sql": "SELECT MAX(Singapore_Properties.Property_Price) FROM Singapore_Properties INNER JOIN Singapore_Neighborhoods ON Singapore_Properties.Neighborhood_Name = Singapore_Neighborhoods.Neighborhood_Name WHERE Singapore_Neighborhoods.Wheelchair_Accessibility = true;", "generated_sql": "SELECT MAX(p.Property_Price) FROM Singapore_Properties p JOIN Singapore_Neighborhoods n ON p.Neighborhood_Name = n.Neighborhood_Name WHERE n.Wheelchair_Accessibility = true;", "raw_model_output": "\n\nSELECT MAX(p.Property_Price) FROM Singapore_Properties p JOIN Singapore_Neighborhoods n ON p.Neighborhood_Name = n.Neighborhood_Name WHERE n.Wheelchair_Accessibility = true;", "latency_sec": 3.0290377140045166, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 909, "prompt_eval_sec": null, "tokens_completion": 442, "completion_eval_sec": null, "tokens_total": 1351, "tokens_per_sec": 446.0162360322416, "retrieval_latency_sec": 0.10872721672058105, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between Singapore_Properties and Singapore_Neighborhoods on Neighborhood_Name, filter for wheelchair-accessible neighborhoods, and select the maximum property price. The only difference is the use of table aliases (p/n) in the generated query, which does not affect semantic meaning."}
{"example_id": 3859, "sql_complexity": "aggregation", "prompt": "What is the total number of mental health parity violations by month and year?", "context": "CREATE TABLE mental_health_parity_reports (report_id INT, violation_date DATE); INSERT INTO mental_health_parity_reports (report_id, violation_date) VALUES (1, '2022-01-01'), (2, '2022-02-15'), (3, '2022-03-05'), (4, '2022-04-20'), (5, '2021-06-12'), (6, '2021-07-28');", "reference_sql": "SELECT EXTRACT(MONTH FROM violation_date) AS month, EXTRACT(YEAR FROM violation_date) AS year, COUNT(*) FROM mental_health_parity_reports GROUP BY month, year;", "generated_sql": "SELECT YEAR(violation_date) AS year, MONTH(violation_date) AS month, COUNT(*) AS total_violations \nFROM mental_health_parity_reports \nGROUP BY YEAR(violation_date), MONTH(violation_date) \nORDER BY year, month;", "raw_model_output": "\n\nSELECT YEAR(violation_date) AS year, MONTH(violation_date) AS month, COUNT(*) AS total_violations \nFROM mental_health_parity_reports \nGROUP BY YEAR(violation_date), MONTH(violation_date) \nORDER BY year, month;", "latency_sec": 2.7562601566314697, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 698, "prompt_eval_sec": null, "tokens_completion": 423, "completion_eval_sec": null, "tokens_total": 1121, "tokens_per_sec": 406.71051943442694, "retrieval_latency_sec": 0.1040048599243164, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries group by year and month, count violations, and return the same data. The Reference SQL uses EXTRACT(MONTH/YEAR) while the Generated SQL uses MONTH(violation_date)/YEAR(violation_date), which are functionally equivalent. The column order differs (month/year vs year/month) but this doesn't affect the semantic result. The Generated SQL adds an ORDER BY, but the core data remains identical."}
{"example_id": 3551, "sql_complexity": "multiple_joins", "prompt": "List all artists who have performed in New York and Chicago, along with their highest-earning performance.", "context": "CREATE TABLE artist_events (artist_id INT, event_id INT, earnings DECIMAL(5,2)); CREATE TABLE artists (id INT, name VARCHAR(50)); CREATE TABLE events (id INT, city VARCHAR(20));", "reference_sql": "SELECT artists.name, MAX(artist_events.earnings) FROM artists INNER JOIN artist_events ON artists.id = artist_events.artist_id INNER JOIN events ON artist_events.event_id = events.id WHERE city IN ('New York', 'Chicago') GROUP BY artists.name;", "generated_sql": "SELECT a.name, MAX(ae.earnings) AS highest_earning  \nFROM artists a  \nJOIN artist_events ae ON a.id = ae.artist_id  \nJOIN events e ON ae.event_id = e.id  \nWHERE e.city IN ('New York', 'Chicago')  \nGROUP BY a.id, a.name  \nHAVING COUNT(DISTINCT e.city) = 2;", "raw_model_output": "\n\nSELECT a.name, MAX(ae.earnings) AS highest_earning  \nFROM artists a  \nJOIN artist_events ae ON a.id = ae.artist_id  \nJOIN events e ON ae.event_id = e.id  \nWHERE e.city IN ('New York', 'Chicago')  \nGROUP BY a.id, a.name  \nHAVING COUNT(DISTINCT e.city) = 2;", "latency_sec": 9.998595952987671, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 776, "prompt_eval_sec": null, "tokens_completion": 1551, "completion_eval_sec": null, "tokens_total": 2327, "tokens_per_sec": 232.73267676194789, "retrieval_latency_sec": 0.09200310707092285, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. 1) The Generated SQL includes a HAVING clause that filters for artists with events in *both* New York and Chicago (COUNT(DISTINCT e.city) = 2), while the Reference SQL only filters for events in either city. 2) The Generated SQL groups by both a.id and a.name, whereas the Reference SQL only groups by a.name. This could lead to different results if there are artists with the same name but different IDs. The additional HAVING clause in the Generated SQL significantly changes the result set."}
{"example_id": 5168, "sql_complexity": "aggregation", "prompt": "Get the number of renewable energy projects in Australia for each project type.", "context": "CREATE TABLE renewable_projects (id INT PRIMARY KEY, project_name VARCHAR(255), project_location VARCHAR(255), project_type VARCHAR(255), capacity_mw FLOAT);", "reference_sql": "SELECT project_type, COUNT(*) FROM renewable_projects WHERE project_location = 'Australia' GROUP BY project_type;", "generated_sql": "SELECT project_type, COUNT(*) FROM renewable_projects WHERE project_location = 'Australia' GROUP BY project_type;", "raw_model_output": "\n\nSELECT project_type, COUNT(*) FROM renewable_projects WHERE project_location = 'Australia' GROUP BY project_type;", "latency_sec": 2.0955169200897217, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 581, "prompt_eval_sec": null, "tokens_completion": 318, "completion_eval_sec": null, "tokens_total": 899, "tokens_per_sec": 429.0110909538771, "retrieval_latency_sec": 0.09826087951660156, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure, syntax, and logic. Both queries select project_type and count records from the renewable_projects table where project_location is 'Australia', grouped by project_type. Since they are exactly the same, they will produce identical results."}
{"example_id": 4916, "sql_complexity": "aggregation", "prompt": "What is the maximum revenue generated from selling Yttrium in India in the past 3 years?", "context": "CREATE TABLE Yttrium_Sales (id INT PRIMARY KEY, year INT, country VARCHAR(20), quantity INT, price PER_KG); INSERT INTO Yttrium_Sales (id, year, country, quantity, price) VALUES (1, 2019, 'India', 120, 40), (2, 2020, 'India', 130, 45), (3, 2021, 'India', 140, 50), (4, 2019, 'China', 150, 35), (5, 2020, 'China', 160, 40), (6, 2021, 'China', 170, 45);", "reference_sql": "SELECT MAX(quantity * price) FROM Yttrium_Sales WHERE country = 'India' GROUP BY year ORDER BY year DESC LIMIT 3;", "generated_sql": "SELECT MAX(quantity * price) FROM Yttrium_Sales WHERE country = 'India';", "raw_model_output": "\n\nSELECT MAX(quantity * price) FROM Yttrium_Sales WHERE country = 'India';", "latency_sec": 14.83569622039795, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 886, "prompt_eval_sec": null, "tokens_completion": 2335, "completion_eval_sec": null, "tokens_total": 3221, "tokens_per_sec": 217.1114824777398, "retrieval_latency_sec": 0.10923600196838379, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns the maximum quantity*price per year for India (3 rows) ordered by year descending, while the Generated SQL returns a single maximum value across all India entries. The first query groups by year and limits 3 results, whereas the second query calculates a single global maximum without grouping."}
{"example_id": 812, "sql_complexity": "multiple_joins", "prompt": "What is the average salary of 'engineer' workers in each factory?", "context": "CREATE TABLE factories (factory_id INT, factory_name VARCHAR(20)); INSERT INTO factories VALUES (1, 'Factory X'), (2, 'Factory Y'), (3, 'Factory Z'); CREATE TABLE roles (role_id INT, role_name VARCHAR(20)); INSERT INTO roles VALUES (1, 'engineer'), (2, 'manager'), (3, 'assistant'); CREATE TABLE workers (worker_id INT, factory_id INT, role_id INT, salary DECIMAL(5,2)); INSERT INTO workers VALUES (1, 1, 1, 50000.00), (2, 1, 2, 70000.00), (3, 2, 1, 55000.00), (4, 2, 3, 40000.00), (5, 3, 1, 60000.00);", "reference_sql": "SELECT f.factory_name, AVG(salary) FROM workers w INNER JOIN factories f ON w.factory_id = f.factory_id INNER JOIN roles r ON w.role_id = r.role_id WHERE r.role_name = 'engineer' GROUP BY f.factory_name;", "generated_sql": "SELECT f.factory_name, AVG(w.salary) AS avg_salary  \nFROM workers w  \nJOIN roles r ON w.role_id = r.role_id  \nJOIN factories f ON w.factory_id = f.factory_id  \nWHERE r.role_name = 'engineer'  \nGROUP BY f.factory_name;", "raw_model_output": "\n\nSELECT f.factory_name, AVG(w.salary) AS avg_salary  \nFROM workers w  \nJOIN roles r ON w.role_id = r.role_id  \nJOIN factories f ON w.factory_id = f.factory_id  \nWHERE r.role_name = 'engineer'  \nGROUP BY f.factory_name;", "latency_sec": 9.72361707687378, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 853, "prompt_eval_sec": null, "tokens_completion": 1526, "completion_eval_sec": null, "tokens_total": 2379, "tokens_per_sec": 244.66204100715856, "retrieval_latency_sec": 0.09351968765258789, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the average salary of engineers per factory. They use equivalent JOIN conditions (INNER JOIN vs JOIN), same WHERE clause filtering for 'engineer' roles, and group by factory name. The only differences are join order and explicit table alias in AVG(salary) which don't affect the result."}
{"example_id": 5784, "sql_complexity": "set operations", "prompt": "List the number of users who have completed a workout of a specific type (e.g. Running) and have a membership status of 'Active'.", "context": "CREATE TABLE workouts (id INT, user_id INT, workout_type VARCHAR(20)); CREATE TABLE members (id INT, name VARCHAR(50), membership_status VARCHAR(20), state VARCHAR(20)); INSERT INTO workouts (id, user_id, workout_type) VALUES (1, 1, 'Running'), (2, 1, 'Cycling'), (3, 2, 'Running'), (4, 3, 'Cycling'), (5, 3, 'Swimming'), (6, 4, 'Running'), (7, 4, 'Swimming'); INSERT INTO members (id, name, membership_status, state) VALUES (1, 'John Doe', 'Active', 'Texas'), (2, 'Jane Doe', 'Inactive', 'California'), (3, 'Bob Smith', 'Active', 'Texas'), (4, 'Alice Johnson', 'Active', 'California');", "reference_sql": "SELECT COUNT(*) FROM (SELECT user_id FROM workouts WHERE workout_type = 'Running' INTERSECT SELECT id FROM members WHERE membership_status = 'Active') AS user_set;", "generated_sql": "SELECT COUNT(DISTINCT w.user_id) FROM workouts w JOIN members m ON w.user_id = m.id WHERE w.workout_type = 'Running' AND m.membership_status = 'Active';", "raw_model_output": "\n\nSELECT COUNT(DISTINCT w.user_id) FROM workouts w JOIN members m ON w.user_id = m.id WHERE w.workout_type = 'Running' AND m.membership_status = 'Active';", "latency_sec": 3.431624174118042, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1220, "prompt_eval_sec": null, "tokens_completion": 525, "completion_eval_sec": null, "tokens_total": 1745, "tokens_per_sec": 508.50556805174637, "retrieval_latency_sec": 0.09502911567687988, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count the number of distinct user_ids who have at least one 'Running' workout and are active members. The Reference SQL uses INTERSECT to find common user_ids between 'Running' workouts and active members, while the Generated SQL joins the tables and counts distinct user_ids with the same conditions. Both approaches yield the same result."}
{"example_id": 3038, "sql_complexity": "subqueries", "prompt": "What is the total assets of clients who have invested in mutual funds but not in stocks?", "context": "CREATE TABLE clients (client_id INT, name TEXT, age INT, gender TEXT, total_assets DECIMAL(10,2)); INSERT INTO clients VALUES (1, 'John Doe', 35, 'Male', 250000.00), (2, 'Jane Smith', 45, 'Female', 500000.00); CREATE TABLE investments (client_id INT, investment_type TEXT); INSERT INTO investments VALUES (1, 'Stocks'), (1, 'Bonds'), (2, 'Stocks'), (3, 'Mutual Funds');", "reference_sql": "SELECT c.total_assets FROM clients c INNER JOIN investments i ON c.client_id = i.client_id WHERE i.investment_type = 'Mutual Funds' AND c.client_id NOT IN (SELECT client_id FROM investments WHERE investment_type = 'Stocks');", "generated_sql": "SELECT SUM(c.total_assets) FROM clients c WHERE EXISTS (SELECT 1 FROM investments i WHERE i.client_id = c.client_id AND i.investment_type = 'Mutual Funds') AND NOT EXISTS (SELECT 1 FROM investments i WHERE i.client_id = c.client_id AND i.investment_type = 'Stocks');", "raw_model_output": "\n\nSELECT SUM(c.total_assets) FROM clients c WHERE EXISTS (SELECT 1 FROM investments i WHERE i.client_id = c.client_id AND i.investment_type = 'Mutual Funds') AND NOT EXISTS (SELECT 1 FROM investments i WHERE i.client_id = c.client_id AND i.investment_type = 'Stocks');", "latency_sec": 14.798714876174927, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1117, "prompt_eval_sec": null, "tokens_completion": 2299, "completion_eval_sec": null, "tokens_total": 3416, "tokens_per_sec": 230.83085447504376, "retrieval_latency_sec": 0.09053492546081543, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL selects individual client total_assets values, while the Generated SQL aggregates them using SUM. Additionally, the Reference SQL uses an INNER JOIN and NOT IN, whereas the Generated SQL uses EXISTS/NOT EXISTS. These differences in output structure (scalar vs. set) and implementation logic make them non-equivalent."}
{"example_id": 1078, "sql_complexity": "basic SQL", "prompt": "What is the maximum and minimum temperature difference between any two Arctic research stations?", "context": "CREATE TABLE arctic_stations (id INT, name TEXT, location TEXT, temperature DECIMAL(5,2)); INSERT INTO arctic_stations (id, name, location, temperature) VALUES (1, 'Station A', 'Greenland', 2.3), (2, 'Station B', 'Canada', -5.2);", "reference_sql": "SELECT a.name as station1, b.name as station2, MAX(ABS(a.temperature - b.temperature)) as temp_diff FROM arctic_stations a, arctic_stations b ORDER BY temp_diff DESC LIMIT 1", "generated_sql": "SELECT MAX(temperature) - MIN(temperature) AS temperature_difference\nFROM arctic_stations;", "raw_model_output": "\n\nTo determine the **maximum and minimum temperature difference** between any two Arctic research stations, we need to calculate the **range** of temperatures recorded in the `arctic_stations` table. This is done by subtracting the **minimum temperature** from the **maximum temperature**.\n\n---\n\n### \u2705 Key Points:\n- The relevant table is `arctic_stations`.\n- The relevant column is `temperature`.\n- We are not asked to return the max and min separately, but their **difference**.\n- The SQL function `MAX(temperature)` gives the highest temperature.\n- The SQL function `MIN(temperature)` gives the lowest temperature.\n- The difference is simply `MAX(temperature) - MIN(temperature)`.\n\n---\n\n### \u2705 Final SQL Query:\n\n```sql\nSELECT MAX(temperature) - MIN(temperature) AS temperature_difference\nFROM arctic_stations;\n```\n\nThis query will return a single value representing the temperature difference between the warmest and coldest stations in the dataset.", "latency_sec": 4.649626970291138, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 810, "prompt_eval_sec": null, "tokens_completion": 696, "completion_eval_sec": null, "tokens_total": 1506, "tokens_per_sec": 323.8969512226701, "retrieval_latency_sec": 0.10896420478820801, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the maximum temperature difference between any two stations. The reference query computes the maximum absolute difference between all station pairs, while the generated query calculates the difference between the overall maximum and minimum temperatures. Since the maximum possible temperature difference in a dataset is always equal to (max temperature - min temperature), both approaches yield the same numerical result."}
{"example_id": 5015, "sql_complexity": "basic SQL", "prompt": "Calculate the average recycling rate", "context": "CREATE TABLE recycling_rates (id INT PRIMARY KEY, location VARCHAR(50), rate FLOAT);", "reference_sql": "SELECT AVG(rate) FROM recycling_rates;", "generated_sql": "SELECT AVG(rate) FROM recycling_rates;", "raw_model_output": "\n\nSELECT AVG(rate) FROM recycling_rates;", "latency_sec": 2.177586317062378, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 732, "prompt_eval_sec": null, "tokens_completion": 309, "completion_eval_sec": null, "tokens_total": 1041, "tokens_per_sec": 478.0522323470221, "retrieval_latency_sec": 0.09099817276000977, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and content. Both select the average value of the 'rate' column from the 'recycling_rates' table, resulting in the same output."}
{"example_id": 1533, "sql_complexity": "subqueries", "prompt": "Which programs had the highest volunteer participation rate in the last quarter?", "context": "CREATE TABLE Programs (ProgramID INT, ProgramName TEXT, Budget DECIMAL(10,2), NumVolunteers INT); CREATE TABLE VolunteerEvents (EventID INT, ProgramID INT, EventDate DATE, NumVolunteers INT);", "reference_sql": "SELECT p.ProgramName, COUNT(v.EventID) / (SELECT COUNT(*) FROM VolunteerEvents WHERE EventDate >= DATEADD(quarter, -1, GETDATE())) * 100.0 AS VolunteerParticipationRate FROM Programs p INNER JOIN VolunteerEvents v ON p.ProgramID = v.ProgramID WHERE v.EventDate >= DATEADD(quarter, -1, GETDATE()) GROUP BY p.ProgramName ORDER BY VolunteerParticipationRate DESC;", "generated_sql": "SELECT p.ProgramName, SUM(ve.NumVolunteers) AS TotalVolunteers\nFROM Programs p\nJOIN VolunteerEvents ve ON p.ProgramID = ve.ProgramID\nWHERE ve.EventDate >= CURRENT_DATE - INTERVAL '3 months'\nGROUP BY p.ProgramID, p.ProgramName\nORDER BY TotalVolunteers DESC;", "raw_model_output": "\n\nTo determine which programs had the **highest volunteer participation rate in the last quarter**, we need to interpret \"participation rate\" in the context of the provided schema. Since the schema does not include a `total_participants` column, and the `Programs` table contains a `NumVolunteers` field, we assume that the \"participation rate\" refers to the **total number of volunteers** who participated in events for each program during the last quarter.\n\n---\n\n### Key Assumptions:\n- **\"Last quarter\"** is interpreted as the **last 3 months** from the current date.\n- **\"Volunteer participation rate\"** is interpreted as the **total number of volunteers** across all events for a program in the last quarter.\n- We will use the `VolunteerEvents` table to calculate the total number of volunteers per program.\n\n---\n\n### SQL Query:\n\n```sql\nSELECT p.ProgramName, SUM(ve.NumVolunteers) AS TotalVolunteers\nFROM Programs p\nJOIN VolunteerEvents ve ON p.ProgramID = ve.ProgramID\nWHERE ve.EventDate >= CURRENT_DATE - INTERVAL '3 months'\nGROUP BY p.ProgramID, p.ProgramName\nORDER BY TotalVolunteers DESC;\n```\n\n---\n\n### Explanation:\n- **`JOIN`** connects the `Programs` and `VolunteerEvents` tables using `ProgramID`.\n- **`WHERE ve.EventDate >= CURRENT_DATE - INTERVAL '3 months'`** filters events that occurred in the last 3 months.\n- **`SUM(ve.NumVolunteers)`** aggregates the number of volunteers per program.\n- **`GROUP BY`** ensures the sum is calculated per program.\n- **`ORDER BY TotalVolunteers DESC`** sorts the results in descending order of volunteer participation.\n\nThis query will return the programs with the highest volunteer participation in the last quarter, based on the total number of volunteers across all events.", "latency_sec": 14.966286182403564, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 794, "prompt_eval_sec": null, "tokens_completion": 2352, "completion_eval_sec": null, "tokens_total": 3146, "tokens_per_sec": 210.20578930923242, "retrieval_latency_sec": 0.10831737518310547, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates a participation rate percentage (count of program-specific events divided by total events in the last quarter), while the Generated SQL sums volunteer counts per program. They differ in: 1) Aggregation logic (count vs sum), 2) Calculation method (ratio vs absolute value), 3) Grouping (ProgramName vs ProgramID+ProgramName). The output columns and their meanings are fundamentally different."}
{"example_id": 4021, "sql_complexity": "subqueries", "prompt": "What is the percentage of energy efficiency improvement, per sector, compared to 2015 levels?", "context": "CREATE TABLE energy_efficiency (id INT, sector VARCHAR(50), year INT, efficiency FLOAT); INSERT INTO energy_efficiency (id, sector, year, efficiency) VALUES (1, 'Industry', 2015, 100.0), (2, 'Industry', 2020, 105.0), (3, 'Residential', 2015, 100.0), (4, 'Residential', 2020, 103.0);", "reference_sql": "SELECT sector, (SUM(efficiency) / (SELECT SUM(efficiency) FROM energy_efficiency WHERE year = 2015 AND sector = e.sector) * 100.0) - 100.0 AS improvement FROM energy_efficiency e WHERE year = 2020 GROUP BY sector;", "generated_sql": "SELECT \n    e1.sector,\n    ((e2.efficiency - e1.efficiency) / e1.efficiency) * 100 AS percentage_improvement\nFROM \n    energy_efficiency e1\nJOIN \n    energy_efficiency e2\nON \n    e1.sector = e2.sector\nWHERE \n    e1.year = 2015\n    AND e2.year = 2020;", "raw_model_output": "\n\nSELECT \n    e1.sector,\n    ((e2.efficiency - e1.efficiency) / e1.efficiency) * 100 AS percentage_improvement\nFROM \n    energy_efficiency e1\nJOIN \n    energy_efficiency e2\nON \n    e1.sector = e2.sector\nWHERE \n    e1.year = 2015\n    AND e2.year = 2020;", "latency_sec": 12.739270210266113, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 864, "prompt_eval_sec": null, "tokens_completion": 1992, "completion_eval_sec": null, "tokens_total": 2856, "tokens_per_sec": 224.18866645111694, "retrieval_latency_sec": 0.09060311317443848, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL calculates the percentage improvement for each sector by comparing the sum of efficiencies in 2020 to the sum in 2015, while the Generated SQL computes the percentage improvement for individual records (not aggregated). If there are multiple entries per sector/year, the Generated SQL would produce multiple rows with per-record improvements, whereas the Reference SQL would return one row per sector with aggregated results. Even in the sample data, the Generated SQL's approach is fundamentally different in handling data granularity."}
{"example_id": 1551, "sql_complexity": "single join", "prompt": "How many unique donors made donations in the healthcare industry in Q3 2022?", "context": "CREATE TABLE donations (id INT, donor_id INT, amount FLOAT, donation_date DATE); INSERT INTO donations (id, donor_id, amount, donation_date) VALUES (1, 7, 100, '2022-07-01'); INSERT INTO donations (id, donor_id, amount, donation_date) VALUES (2, 8, 200, '2022-09-15'); INSERT INTO donors (id, name, industry, first_donation_date DATE) VALUES (7, 'Charlie Davis', 'Healthcare', '2022-07-01'); INSERT INTO donors (id, name, industry, first_donation_date DATE) VALUES (8, 'Dana Wilson', 'Healthcare', '2022-09-15');", "reference_sql": "SELECT COUNT(DISTINCT donor_id) FROM donations d JOIN donors don ON d.donor_id = don.id WHERE industry = 'Healthcare' AND donation_date BETWEEN '2022-07-01' AND '2022-09-30';", "generated_sql": "SELECT COUNT(DISTINCT d.donor_id) FROM donations d JOIN donors dr ON d.donor_id = dr.id WHERE dr.industry = 'Healthcare' AND d.donation_date BETWEEN '2022-07-01' AND '2022-09-30';", "raw_model_output": "\n\nSELECT COUNT(DISTINCT d.donor_id) FROM donations d JOIN donors dr ON d.donor_id = dr.id WHERE dr.industry = 'Healthcare' AND d.donation_date BETWEEN '2022-07-01' AND '2022-09-30';", "latency_sec": 4.691892385482788, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1031, "prompt_eval_sec": null, "tokens_completion": 699, "completion_eval_sec": null, "tokens_total": 1730, "tokens_per_sec": 368.721159366912, "retrieval_latency_sec": 0.09816217422485352, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform an inner join between donations and donors tables on donor_id, filter for 'Healthcare' industry and donations in July-September 2022, and count distinct donor_ids. The only differences are table alias names ('don' vs 'dr') which don't affect semantic meaning."}
{"example_id": 2592, "sql_complexity": "window functions", "prompt": "What is the third highest account balance for Shariah-compliant finance customers?", "context": "CREATE TABLE shariah_compliant_finance(customer_id INT, account_balance DECIMAL(10, 2)); INSERT INTO shariah_compliant_finance VALUES (1, 5000), (2, 7000), (3, 6000), (4, 8000), (5, 9000);", "reference_sql": "SELECT account_balance FROM (SELECT account_balance, RANK() OVER (ORDER BY account_balance DESC) as rn FROM shariah_compliant_finance) t WHERE rn = 3;", "generated_sql": "SELECT account_balance\nFROM (\n    SELECT account_balance, ROW_NUMBER() OVER (ORDER BY account_balance DESC) AS rn\n    FROM shariah_compliant_finance\n) t\nWHERE rn = 3;", "raw_model_output": "\n\nTo determine the **third highest account balance** in the `shariah_compliant_finance` table, we need to:\n\n1. **Sort the account balances in descending order**.\n2. **Assign a row number** to each row based on this order.\n3. **Select the row where the row number is 3**, which corresponds to the third highest balance.\n\nThis approach ensures that we correctly identify the third highest value, even if there are duplicate balances (though in this case, all balances are unique).\n\n---\n\n### \u2705 SQL Query\n\n```sql\nSELECT account_balance\nFROM (\n    SELECT account_balance, ROW_NUMBER() OVER (ORDER BY account_balance DESC) AS rn\n    FROM shariah_compliant_finance\n) t\nWHERE rn = 3;\n```\n\n---\n\n### \ud83d\udccc Explanation\n\n- `ROW_NUMBER() OVER (ORDER BY account_balance DESC) AS rn`: This assigns a unique row number to each row, starting from 1 for the highest balance.\n- The outer query filters for `rn = 3`, which gives the third highest balance.\n- The result will be `7000`, as per the sample data provided.", "latency_sec": 8.221118927001953, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 892, "prompt_eval_sec": null, "tokens_completion": 1283, "completion_eval_sec": null, "tokens_total": 2175, "tokens_per_sec": 264.5625272317002, "retrieval_latency_sec": 0.10507702827453613, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the 3rd highest account balance. Since all account balances in the table are unique, RANK() and ROW_NUMBER() produce the same ordering. The third highest value (7000) will be returned by both queries."}
{"example_id": 3795, "sql_complexity": "single join", "prompt": "What is the total quantity of unsold garments for each manufacturer based in 'Italy' or 'Spain'?", "context": "CREATE TABLE manufacturers (id INT PRIMARY KEY, name VARCHAR(255), country VARCHAR(255)); CREATE TABLE garments (id INT PRIMARY KEY, manufacturer_id INT, quantity_manufactured INT, quantity_sold INT);", "reference_sql": "SELECT m.name, SUM(g.quantity_manufactured - g.quantity_sold) as total_unsold_quantity FROM manufacturers m JOIN garments g ON m.id = g.manufacturer_id WHERE m.country IN ('Italy', 'Spain') GROUP BY m.name;", "generated_sql": "SELECT m.name, SUM(g.quantity_manufactured - g.quantity_sold) AS total_unsold FROM manufacturers m JOIN garments g ON m.id = g.manufacturer_id WHERE m.country IN ('Italy', 'Spain') GROUP BY m.id, m.name;", "raw_model_output": "\n\nSELECT m.name, SUM(g.quantity_manufactured - g.quantity_sold) AS total_unsold FROM manufacturers m JOIN garments g ON m.id = g.manufacturer_id WHERE m.country IN ('Italy', 'Spain') GROUP BY m.id, m.name;", "latency_sec": 7.712125062942505, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 937, "prompt_eval_sec": null, "tokens_completion": 1199, "completion_eval_sec": null, "tokens_total": 2136, "tokens_per_sec": 276.9664628837107, "retrieval_latency_sec": 0.11122989654541016, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their GROUP BY clauses. The Reference SQL groups by 'm.name' alone, which could combine multiple manufacturers with the same name. The Generated SQL groups by both 'm.id' and 'm.name', ensuring each manufacturer is treated as a separate group. Since 'm.id' is the primary key, grouping by 'm.id' and 'm.name' is functionally equivalent to grouping by 'm.id' alone, but grouping by 'm.name' may aggregate different manufacturers into the same group if they share the same name. This leads to different results when manufacturers have duplicate names."}
{"example_id": 4138, "sql_complexity": "window functions", "prompt": "How many lifelong learning courses has a student with ID '2' completed, in chronological order?", "context": "CREATE TABLE lifelong_learning (student_id INT, course_id INT, completion_date DATE); INSERT INTO lifelong_learning VALUES (2, 1001, '2015-01-01'), (2, 1002, '2016-01-01');", "reference_sql": "SELECT student_id, course_id, COUNT(course_id) OVER (PARTITION BY student_id ORDER BY completion_date) as completed_courses FROM lifelong_learning WHERE student_id = 2;", "generated_sql": "SELECT student_id, course_id, COUNT(course_id) OVER (PARTITION BY student_id ORDER BY completion_date) AS completed_courses FROM lifelong_learning WHERE student_id = 2;", "raw_model_output": "\n\nSELECT student_id, course_id, COUNT(course_id) OVER (PARTITION BY student_id ORDER BY completion_date) AS completed_courses FROM lifelong_learning WHERE student_id = 2;", "latency_sec": 15.606270790100098, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 978, "prompt_eval_sec": null, "tokens_completion": 2432, "completion_eval_sec": null, "tokens_total": 3410, "tokens_per_sec": 218.50191156257185, "retrieval_latency_sec": 0.08259820938110352, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both select student_id, course_id, and a window function that counts course_id partitioned by student_id and ordered by completion_date, with the same WHERE condition (student_id = 2). The only differences are trivial formatting variations (case of AS keyword and spacing) that do not affect semantic meaning."}
{"example_id": 312, "sql_complexity": "aggregation", "prompt": "List the top 3 most represented ethnicities in movies produced in the USA.", "context": "CREATE TABLE movies (title VARCHAR(255), production_country VARCHAR(64), lead_actor_ethnicity VARCHAR(64));", "reference_sql": "SELECT lead_actor_ethnicity, COUNT(*) AS count FROM movies WHERE production_country = 'USA' GROUP BY lead_actor_ethnicity ORDER BY count DESC LIMIT 3;", "generated_sql": "SELECT lead_actor_ethnicity, COUNT(*) AS count \nFROM movies \nWHERE production_country = 'USA' \nGROUP BY lead_actor_ethnicity \nORDER BY count DESC \nLIMIT 3;", "raw_model_output": "\n\nSELECT lead_actor_ethnicity, COUNT(*) AS count \nFROM movies \nWHERE production_country = 'USA' \nGROUP BY lead_actor_ethnicity \nORDER BY count DESC \nLIMIT 3;", "latency_sec": 1.647209882736206, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 833, "prompt_eval_sec": null, "tokens_completion": 234, "completion_eval_sec": null, "tokens_total": 1067, "tokens_per_sec": 647.7620193897754, "retrieval_latency_sec": 0.09647488594055176, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure, logic, and syntax. Both select the same columns, apply the same filter (production_country = 'USA'), group by the same column (lead_actor_ethnicity), order by the same expression (count DESC), and limit to 3 results. The formatting differences (e.g., line breaks) do not affect semantic equivalence."}
{"example_id": 4298, "sql_complexity": "single join", "prompt": "How many users joined the gym in Q1 2023?", "context": "CREATE TABLE memberships (id INT, user_id INT, join_date DATE); INSERT INTO memberships (id, user_id, join_date) VALUES (1, 5, '2023-01-15'), (2, 6, '2023-02-03'), (3, 7, '2023-03-20'), (4, 8, '2022-12-31');", "reference_sql": "SELECT COUNT(*) FROM memberships WHERE join_date BETWEEN '2023-01-01' AND '2023-03-31';", "generated_sql": "SELECT COUNT(*) FROM memberships WHERE join_date >= '2023-01-01' AND join_date <= '2023-03-31';", "raw_model_output": "\n\nSELECT COUNT(*) FROM memberships WHERE join_date >= '2023-01-01' AND join_date <= '2023-03-31';", "latency_sec": 3.654035806655884, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1263, "prompt_eval_sec": null, "tokens_completion": 553, "completion_eval_sec": null, "tokens_total": 1816, "tokens_per_sec": 496.9847303335472, "retrieval_latency_sec": 0.11016416549682617, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter memberships with join_date between '2023-01-01' and '2023-03-31' inclusive. The BETWEEN operator in the reference query is equivalent to the combination of >= and <= in the generated query for date ranges."}
{"example_id": 5211, "sql_complexity": "multiple_joins", "prompt": "What is the average transaction value in the last week, split by product category and customer demographics?", "context": "CREATE TABLE transactions (transaction_id INT, customer_id INT, product_id INT, category_id INT, transaction_date DATE, amount DECIMAL(10,2)); CREATE TABLE customers (customer_id INT, age INT, gender VARCHAR(10), location VARCHAR(255)); CREATE TABLE products (product_id INT, name VARCHAR(255), category_id INT);", "reference_sql": "SELECT c.age, c.gender, p.category_id, AVG(t.amount) as avg_transaction_value FROM transactions t INNER JOIN customers c ON t.customer_id = c.customer_id INNER JOIN products p ON t.product_id = p.product_id WHERE t.transaction_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 WEEK) GROUP BY c.age, c.gender, p.category_id;", "generated_sql": "SELECT p.category_id AS product_category, c.gender, c.age, c.location, AVG(t.amount) AS average_transaction_value FROM transactions t INNER JOIN products p ON t.product_id = p.product_id INNER JOIN customers c ON t.customer_id = c.customer_id WHERE t.transaction_date >= CURRENT_DATE - INTERVAL '1 WEEK' GROUP BY p.category_id, c.gender, c.age, c.location;", "raw_model_output": "\n\nSELECT p.category_id AS product_category, c.gender, c.age, c.location, AVG(t.amount) AS average_transaction_value FROM transactions t INNER JOIN products p ON t.product_id = p.product_id INNER JOIN customers c ON t.customer_id = c.customer_id WHERE t.transaction_date >= CURRENT_DATE - INTERVAL '1 WEEK' GROUP BY p.category_id, c.gender, c.age, c.location;", "latency_sec": 13.31856107711792, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 875, "prompt_eval_sec": null, "tokens_completion": 2083, "completion_eval_sec": null, "tokens_total": 2958, "tokens_per_sec": 222.0960644976896, "retrieval_latency_sec": 0.1062769889831543, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The generated query includes an additional column (c.location) in both the SELECT and GROUP BY clauses, which changes the result structure and aggregation. The reference query groups by (age, gender, category_id) while the generated query groups by (category_id, gender, age, location), leading to different aggregation results."}
{"example_id": 382, "sql_complexity": "window functions", "prompt": "What is the average annual precipitation in the past 10 years for each weather station?", "context": "CREATE TABLE WeatherStation (ID INT, Name VARCHAR(100), Location VARCHAR(100), Elevation FLOAT, AnnualPrecipitation FLOAT); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (1, 'Station A', 'Arctic Circle', 100, 450); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (2, 'Station B', 'North Pole', 200, 300);", "reference_sql": "SELECT Name, AVG(AnnualPrecipitation) OVER (PARTITION BY Name ORDER BY Name ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS AvgAnnualPrecipitation FROM WeatherStation WHERE YEAR(CurrentDate) - YEAR(DateInstalled) BETWEEN 1 AND 10;", "generated_sql": "SELECT Name, AnnualPrecipitation AS AverageAnnualPrecipitation FROM WeatherStation;", "raw_model_output": "\n\nThe provided schema includes a `WeatherStation` table with an `AnnualPrecipitation` column, which appears to store a single value per station. However, the question references \"average annual precipitation in the past 10 years,\" implying historical data. Since the schema does not include a table with yearly precipitation records (e.g., a `measurement_date` field), it is not possible to calculate a true 10-year average. \n\nAssuming `AnnualPrecipitation` already represents the average over the required period, the SQL query would simply retrieve this value for each station:\n\n```sql\nSELECT Name, AnnualPrecipitation AS AverageAnnualPrecipitation FROM WeatherStation;\n``` \n\nIf the schema were intended to include historical data (e.g., a `climate_data` table with `measurement_date`), the query would require joining and aggregating yearly values. However, based on the given schema, the above query is the only feasible option.", "latency_sec": 7.143754959106445, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1118, "prompt_eval_sec": null, "tokens_completion": 1109, "completion_eval_sec": null, "tokens_total": 2227, "tokens_per_sec": 311.74081596417994, "retrieval_latency_sec": 0.10505986213684082, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL contains a WHERE clause referencing a non-existent 'DateInstalled' column, making it invalid. The Generated SQL selects raw AnnualPrecipitation values instead of calculating an average. Additionally, the window function in Reference SQL would produce aggregated values per Name, while Generated SQL returns individual records without aggregation."}
{"example_id": 2190, "sql_complexity": "single join", "prompt": "What is the total number of humanitarian assistance events by each country in the last 3 years?", "context": "CREATE TABLE Humanitarian_Assistance (id INT, country VARCHAR(50), year INT, events INT); CREATE TABLE Countries (id INT, name VARCHAR(50), region VARCHAR(50));", "reference_sql": "SELECT co.name, SUM(ha.events) FROM Humanitarian_Assistance ha INNER JOIN Countries co ON ha.country = co.name WHERE ha.year BETWEEN (YEAR(CURRENT_DATE) - 3) AND YEAR(CURRENT_DATE) GROUP BY co.name;", "generated_sql": "SELECT c.name, SUM(ha.events) AS total_events  \nFROM Humanitarian_Assistance ha  \nJOIN Countries c ON ha.country = c.name  \nWHERE ha.year >= (SELECT MAX(year) - 2 FROM Humanitarian_Assistance)  \nGROUP BY c.name;", "raw_model_output": "\n\nSELECT c.name, SUM(ha.events) AS total_events  \nFROM Humanitarian_Assistance ha  \nJOIN Countries c ON ha.country = c.name  \nWHERE ha.year >= (SELECT MAX(year) - 2 FROM Humanitarian_Assistance)  \nGROUP BY c.name;", "latency_sec": 27.040507078170776, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1042, "prompt_eval_sec": null, "tokens_completion": 4217, "completion_eval_sec": null, "tokens_total": 5259, "tokens_per_sec": 194.48599779570992, "retrieval_latency_sec": 0.09038782119750977, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses a fixed range based on the current year (YEAR(CURRENT_DATE) - 3 to YEAR(CURRENT_DATE)), while the Generated SQL uses a dynamic range based on the maximum year in the table (MAX(year) - 2). This can lead to different year ranges if the maximum year in the table is not equal to the current year. For example, if the current year is 2023 but the latest year in the table is 2022, the Reference includes 2020-2023 while the Generated includes 2020-2022. Additionally, the Generated SQL's WHERE clause uses >= instead of BETWEEN, which may include more years if the max year is not exactly 2 years behind the current year."}
{"example_id": 1852, "sql_complexity": "set operations", "prompt": "Compare coal production and employment rates in China and India between 2018 and 2020.", "context": "CREATE TABLE china_coal_production (year INT, production FLOAT); INSERT INTO china_coal_production (year, production) VALUES (2018, 3500.0), (2019, 3600.0), (2020, 3700.0); CREATE TABLE china_employment (year INT, employment FLOAT); INSERT INTO china_employment (year, employment) VALUES (2018, 8000000.0), (2019, 8100000.0), (2020, 8200000.0); CREATE TABLE india_coal_production (year INT, production FLOAT); INSERT INTO india_coal_production (year, production) VALUES (2018, 700.0), (2019, 750.0), (2020, 800.0); CREATE TABLE india_employment (year INT, employment FLOAT); INSERT INTO india_employment (year, employment) VALUES (2018, 1000000.0), (2019, 1050000.0), (2020, 1100000.0);", "reference_sql": "SELECT 'China' AS country, china_coal_production.production, china_employment.employment FROM china_coal_production INNER JOIN china_employment ON china_coal_production.year = china_employment.year WHERE china_coal_production.year BETWEEN 2018 AND 2020 UNION ALL SELECT 'India', india_coal_production.production, india_employment.employment FROM india_coal_production INNER JOIN india_employment ON india_coal_production.year = india_employment.year WHERE india_coal_production.year BETWEEN 2018 AND 2020;", "generated_sql": "SELECT \n    c.year,\n    c.production AS china_coal_production,\n    e.employment AS china_employment,\n    i.production AS india_coal_production,\n    e2.employment AS india_employment\nFROM \n    china_coal_production c\nJOIN \n    china_employment e ON c.year = e.year\nJOIN \n    india_coal_production i ON c.year = i.year\nJOIN \n    india_employment e2 ON c.year = e2.year\nWHERE \n    c.year BETWEEN 2018 AND 2020;", "raw_model_output": "\n\nSELECT \n    c.year,\n    c.production AS china_coal_production,\n    e.employment AS china_employment,\n    i.production AS india_coal_production,\n    e2.employment AS india_employment\nFROM \n    china_coal_production c\nJOIN \n    china_employment e ON c.year = e.year\nJOIN \n    india_coal_production i ON c.year = i.year\nJOIN \n    india_employment e2 ON c.year = e2.year\nWHERE \n    c.year BETWEEN 2018 AND 2020;", "latency_sec": 9.412152767181396, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1282, "prompt_eval_sec": null, "tokens_completion": 1437, "completion_eval_sec": null, "tokens_total": 2719, "tokens_per_sec": 288.8818389646945, "retrieval_latency_sec": 0.10639476776123047, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns two rows per year (China and India separately) with columns 'country', 'production', 'employment', while the Generated SQL returns one row per year with all four columns (China and India production/employment). The structure and number of rows differ, making them non-equivalent."}
{"example_id": 2535, "sql_complexity": "subqueries", "prompt": "What is the maximum safety rating for vehicles in the vehiclesafety schema?", "context": "CREATE TABLE VehicleSafety (id INT, vehicle_id INT, safetyrating INT, PRIMARY KEY (id)); CREATE TABLE Vehicles (id INT, make VARCHAR(50), model VARCHAR(50), PRIMARY KEY (id)); CREATE TABLE LuxuryVehicles (id INT, vehicle_id INT, PRIMARY KEY (id), FOREIGN KEY (vehicle_id) REFERENCES Vehicles(id));", "reference_sql": "SELECT MAX(safetyrating) FROM vehicleSafety JOIN Vehicles ON vehicleSafety.vehicle_id = Vehicles.id WHERE EXISTS (SELECT * FROM LuxuryVehicles WHERE Vehicles.id = LuxuryVehicles.vehicle_id);", "generated_sql": "SELECT MAX(safetyrating) FROM VehicleSafety;", "raw_model_output": "\n\nSELECT MAX(safetyrating) FROM VehicleSafety;", "latency_sec": 3.1537363529205322, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 754, "prompt_eval_sec": null, "tokens_completion": 483, "completion_eval_sec": null, "tokens_total": 1237, "tokens_per_sec": 392.23316776447416, "retrieval_latency_sec": 0.09596014022827148, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters vehicles using an EXISTS clause with LuxuryVehicles, while the Generated SQL selects from VehicleSafety without any filters. The Reference query only considers vehicles that are also luxury vehicles (via the join and EXISTS condition), whereas the Generated query includes all entries from VehicleSafety. This difference in filtering means they may return different MAX(safetyrating) values."}
{"example_id": 2140, "sql_complexity": "aggregation", "prompt": "What was the total amount of minerals extracted in the 'north' region for each month in 2020?", "context": "CREATE TABLE extraction(id INT, location TEXT, month INT, year INT, minerals_extracted FLOAT);INSERT INTO extraction(id, location, month, year, minerals_extracted) VALUES (1, 'north', 1, 2020, 1500), (2, 'north', 2, 2020, 1800), (3, 'south', 1, 2020, 1200);", "reference_sql": "SELECT month, SUM(minerals_extracted) FROM extraction WHERE location = 'north' AND year = 2020 GROUP BY month;", "generated_sql": "SELECT month, SUM(minerals_extracted) FROM extraction WHERE location = 'north' AND year = 2020 GROUP BY month;", "raw_model_output": "\n\nSELECT month, SUM(minerals_extracted) FROM extraction WHERE location = 'north' AND year = 2020 GROUP BY month;", "latency_sec": 3.03985595703125, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 958, "prompt_eval_sec": null, "tokens_completion": 464, "completion_eval_sec": null, "tokens_total": 1422, "tokens_per_sec": 467.78532275875915, "retrieval_latency_sec": 0.10763978958129883, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure, conditions, and aggregation logic. Both queries select the same columns, apply the same WHERE filters (location = 'north' and year = 2020), and group by the same column (month). Since the queries are exactly the same, they will produce identical results."}
{"example_id": 4779, "sql_complexity": "window functions", "prompt": "What is the average CO2 emission for the top 3 highest emitting countries since 2015?", "context": "CREATE TABLE emissions (country VARCHAR(50), year INT, co2_emission INT); INSERT INTO emissions (country, year, co2_emission) VALUES ('USA', 2015, 5373978000); INSERT INTO emissions (country, year, co2_emission) VALUES ('China', 2015, 10498600000); INSERT INTO emissions (country, year, co2_emission) VALUES ('India', 2015, 2633830000); INSERT INTO emissions (country, year, co2_emission) VALUES ('USA', 2016, 5518004000); INSERT INTO emissions (country, year, co2_emission) VALUES ('China', 2016, 10813000000); INSERT INTO emissions (country, year, co2_emission) VALUES ('India', 2016, 2799280000);", "reference_sql": "SELECT AVG(co2_emission) as avg_emission FROM (SELECT country, year, co2_emission, ROW_NUMBER() OVER (ORDER BY co2_emission DESC) as rn FROM emissions WHERE year >= 2015) t WHERE rn <= 3 GROUP BY country;", "generated_sql": "SELECT AVG(total_emission) AS average_emission\nFROM (\n    SELECT SUM(co2_emission) AS total_emission\n    FROM emissions\n    WHERE year >= 2015\n    GROUP BY country\n    ORDER BY total_emission DESC\n    FETCH FIRST 3 ROWS ONLY\n) AS top_countries;", "raw_model_output": "\n\nSELECT AVG(total_emission) AS average_emission\nFROM (\n    SELECT SUM(co2_emission) AS total_emission\n    FROM emissions\n    WHERE year >= 2015\n    GROUP BY country\n    ORDER BY total_emission DESC\n    FETCH FIRST 3 ROWS ONLY\n) AS top_countries;", "latency_sec": 18.878310918807983, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1080, "prompt_eval_sec": null, "tokens_completion": 2952, "completion_eval_sec": null, "tokens_total": 4032, "tokens_per_sec": 213.57842962439085, "retrieval_latency_sec": 0.1101689338684082, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL calculates the average of the top 3 co2_emission values (per row) grouped by country, while the Generated SQL first aggregates emissions by country (summing them), then takes the top 3 countries by total emission and averages those totals. The Reference SQL's grouping by country after row numbering leads to different results compared to the Generated SQL's aggregation-first approach."}
{"example_id": 1015, "sql_complexity": "subqueries", "prompt": "List the top 3 most expensive eco-friendly products in Europe and their suppliers.", "context": "CREATE TABLE Suppliers (supplierID INT, supplierName VARCHAR(50), country VARCHAR(50)); CREATE TABLE Products (productID INT, productName VARCHAR(50), price DECIMAL(10,2), ecoFriendly BOOLEAN, supplierID INT);", "reference_sql": "SELECT P.productName, P.price, S.supplierName FROM (SELECT * FROM Products WHERE ecoFriendly = TRUE ORDER BY price DESC LIMIT 3) P JOIN Suppliers S ON P.supplierID = S.supplierID;", "generated_sql": "SELECT p.productName, p.price, s.supplierName  \nFROM Products p  \nJOIN Suppliers s ON p.supplierID = s.supplierID  \nWHERE s.country = 'Europe' AND p.ecoFriendly = TRUE  \nORDER BY p.price DESC  \nFETCH FIRST 3 ROWS ONLY;", "raw_model_output": "\n\nSELECT p.productName, p.price, s.supplierName  \nFROM Products p  \nJOIN Suppliers s ON p.supplierID = s.supplierID  \nWHERE s.country = 'Europe' AND p.ecoFriendly = TRUE  \nORDER BY p.price DESC  \nFETCH FIRST 3 ROWS ONLY;", "latency_sec": 5.724069118499756, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 868, "prompt_eval_sec": null, "tokens_completion": 867, "completion_eval_sec": null, "tokens_total": 1735, "tokens_per_sec": 303.10605341794565, "retrieval_latency_sec": 0.0894620418548584, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in filtering conditions and operation order. The Reference SQL filters eco-friendly products first, limits to 3, then joins with Suppliers. The Generated SQL joins first, then filters for European suppliers and eco-friendly products. The Generated SQL includes an additional WHERE condition (s.country = 'Europe') not present in the Reference SQL, leading to different result sets."}
{"example_id": 3715, "sql_complexity": "aggregation", "prompt": "What is the average age of engines still in service for each engine type?", "context": "CREATE TABLE Engine (id INT, aircraft_id INT, engine_type VARCHAR(255), hours_since_last_service INT, manufacture_year INT); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (1, 1, 'GE90-115B', 500, 2000); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (2, 2, 'CFM56-5B', 1000, 1995); INSERT INTO Engine (id, aircraft_id, engine_type, hours_since_last_service, manufacture_year) VALUES (3, 1, 'GE90-115B', 700, 2002);", "reference_sql": "SELECT engine_type, AVG(YEAR(CURRENT_DATE) - manufacture_year) as avg_age FROM Engine GROUP BY engine_type;", "generated_sql": "SELECT engine_type, AVG(2023 - manufacture_year) AS average_age\nFROM Engine\nGROUP BY engine_type;", "raw_model_output": "\n\nTo determine the **average age of engines still in service for each engine type**, we need to calculate the age of each engine based on its **manufacture year**. Since the question does not provide a specific current year, we will assume the current year is **2023** (a common default in such scenarios).\n\n---\n\n### Key Assumptions:\n- All engines in the `Engine` table are **still in service** (no status field is provided).\n- The **age** of an engine is defined as the difference between the **current year (2023)** and the **manufacture_year**.\n- We group the results by `engine_type` to compute the average age per type.\n\n---\n\n### SQL Query:\n\n```sql\nSELECT engine_type, AVG(2023 - manufacture_year) AS average_age\nFROM Engine\nGROUP BY engine_type;\n```\n\n---\n\n### Explanation:\n- `engine_type`: The type of engine (e.g., 'GE90-115B', 'CFM56-5B').\n- `manufacture_year`: The year the engine was manufactured.\n- `2023 - manufacture_year`: Calculates the age of the engine.\n- `AVG(...)`: Computes the average age for each engine type.\n- `GROUP BY engine_type`: Groups the results by engine type.\n\nThis query will return the average age of engines for each type, assuming all engines in the table are still in service.", "latency_sec": 21.614281177520752, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 698, "prompt_eval_sec": null, "tokens_completion": 3385, "completion_eval_sec": null, "tokens_total": 4083, "tokens_per_sec": 188.90288168576222, "retrieval_latency_sec": 0.1041409969329834, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL uses YEAR(CURRENT_DATE) which depends on the actual current year, while the Generated SQL hardcodes 2023. If the current year is not 2023, the calculated ages would differ. Although the data provided uses 2023 in the Generated SQL, the two queries are not semantically equivalent in general cases."}
{"example_id": 1957, "sql_complexity": "set operations", "prompt": "What is the average temperature recorded for the 'polar_bear' species in the 'Arctic_Animals' table compared to the 'penguin' species in the 'Antarctic_Animals' table?", "context": "CREATE TABLE Arctic_Animals (species TEXT, avg_temp FLOAT); CREATE TABLE Antarctic_Animals (species TEXT, avg_temp FLOAT);", "reference_sql": "SELECT AVG(Arctic_Animals.avg_temp) FROM Arctic_Animals WHERE Arctic_Animals.species = 'polar_bear' INTERSECT SELECT AVG(Antarctic_Animals.avg_temp) FROM Antarctic_Animals WHERE Antarctic_Animals.species = 'penguin'", "generated_sql": "SELECT \n    (SELECT avg_temp FROM Arctic_Animals WHERE species = 'polar_bear') AS polar_bear_avg,\n    (SELECT avg_temp FROM Antarctic_Animals WHERE species = 'penguin') AS penguin_avg;", "raw_model_output": "\n\nSELECT \n    (SELECT avg_temp FROM Arctic_Animals WHERE species = 'polar_bear') AS polar_bear_avg,\n    (SELECT avg_temp FROM Antarctic_Animals WHERE species = 'penguin') AS penguin_avg;", "latency_sec": 9.309566974639893, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 670, "prompt_eval_sec": null, "tokens_completion": 1436, "completion_eval_sec": null, "tokens_total": 2106, "tokens_per_sec": 226.2188999485084, "retrieval_latency_sec": 0.09959816932678223, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL computes the intersection of two average temperature values (polar bear in Arctic vs penguin in Antarctic), returning only when both averages are equal. The Generated SQL retrieves the two average temperatures as separate columns in a single row. The first returns a single value (if matches) while the second returns two values, making them semantically different."}
{"example_id": 1311, "sql_complexity": "basic SQL", "prompt": "What is the total number of veteran job applications in Texas in the last year?", "context": "CREATE TABLE veteran_jobs (id INT, state VARCHAR(50), application_date DATE); INSERT INTO veteran_jobs (id, state, application_date) VALUES (1, 'Texas', '2021-02-15'), (2, 'California', '2021-04-10'), (3, 'Texas', '2022-01-05');", "reference_sql": "SELECT COUNT(*) FROM veteran_jobs WHERE state = 'Texas' AND application_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR);", "generated_sql": "SELECT COUNT(*) FROM veteran_jobs WHERE state = 'Texas' AND EXTRACT(YEAR FROM application_date) = EXTRACT(YEAR FROM CURRENT_DATE) - 1;", "raw_model_output": "\n\nSELECT COUNT(*) FROM veteran_jobs WHERE state = 'Texas' AND EXTRACT(YEAR FROM application_date) = EXTRACT(YEAR FROM CURRENT_DATE) - 1;", "latency_sec": 20.653672218322754, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 809, "prompt_eval_sec": null, "tokens_completion": 3230, "completion_eval_sec": null, "tokens_total": 4039, "tokens_per_sec": 195.55844390794732, "retrieval_latency_sec": 0.10555815696716309, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their date range logic. The reference query uses DATE_SUB to find records within the last year (e.g., 2022-01-01 to 2023-01-01 if current date is 2023-01-01), while the generated query checks for records exactly in the previous calendar year (e.g., 2022). This causes discrepancies when the current date is not at the start of the year. For example, a record with application_date '2022-12-31' would be included in the reference query but excluded from the generated query if the current year is 2023."}
{"example_id": 2997, "sql_complexity": "window functions", "prompt": "What is the earliest capture time for each satellite image in the 'satellite_images' table?", "context": "CREATE TABLE satellite_images (image_id INT, image_url TEXT, capture_time TIMESTAMP); INSERT INTO satellite_images (image_id, image_url, capture_time) VALUES (1, 'image1.jpg', '2022-01-01 10:00:00'), (2, 'image2.jpg', '2021-05-01 10:00:00');", "reference_sql": "SELECT image_id, MIN(capture_time) OVER (PARTITION BY image_id) FROM satellite_images;", "generated_sql": "SELECT MIN(capture_time) FROM satellite_images;", "raw_model_output": "\n\nSELECT MIN(capture_time) FROM satellite_images;", "latency_sec": 4.08022403717041, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 732, "prompt_eval_sec": null, "tokens_completion": 605, "completion_eval_sec": null, "tokens_total": 1337, "tokens_per_sec": 327.67808527670815, "retrieval_latency_sec": 0.09254288673400879, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns each image_id with its own capture_time (since MIN over a partition of one row equals the row's value), producing two rows. The Generated SQL returns a single aggregated minimum capture_time value. The result structures and contents differ."}
{"example_id": 3743, "sql_complexity": "aggregation", "prompt": "What is the maximum budget spent on peacekeeping operations by each department?", "context": "CREATE TABLE DepartmentPeacekeeping (id INT, department VARCHAR(50), budget INT);", "reference_sql": "SELECT department, MAX(budget) FROM DepartmentPeacekeeping GROUP BY department;", "generated_sql": "SELECT department, MAX(budget) FROM DepartmentPeacekeeping GROUP BY department;", "raw_model_output": "\n\nSELECT department, MAX(budget) FROM DepartmentPeacekeeping GROUP BY department;", "latency_sec": 2.0279221534729004, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 567, "prompt_eval_sec": null, "tokens_completion": 298, "completion_eval_sec": null, "tokens_total": 865, "tokens_per_sec": 426.5449729017713, "retrieval_latency_sec": 0.10954475402832031, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure and logic. Both queries select the department and maximum budget from the DepartmentPeacekeeping table, grouping by department. Since the queries are exactly the same, they will produce identical results."}
{"example_id": 4664, "sql_complexity": "multiple_joins", "prompt": "Calculate the total number of volunteer hours contributed by volunteers from 'California' in 'Health' projects in 2021.", "context": "CREATE TABLE volunteers (volunteer_id INT, name VARCHAR(255), state VARCHAR(255));", "reference_sql": "SELECT SUM(vh.hours) as total_hours FROM volunteer_projects vp JOIN volunteer_hours vh ON vp.project_id = vh.project_id JOIN volunteers vol ON vh.volunteer_id = vol.volunteer_id WHERE vp.cause = 'Health' AND vol.state = 'California' AND vh.volunteer_date BETWEEN '2021-01-01' AND '2021-12-31';", "generated_sql": "The provided database schema only includes the `volunteers` table with columns `volunteer_id`, `name`, and `state`. However, the question requires data about **volunteer hours** and **Health projects**, which are not present in the schema. Without tables containing `hours` or `program`/`project` information, it is impossible to calculate the requested metric. \n\n**Answer:**  \nThe schema is incomplete. The necessary tables (e.g., `volunteer_hours` or `projects`) to retrieve volunteer hours or project details are not defined.", "raw_model_output": "\n\nThe provided database schema only includes the `volunteers` table with columns `volunteer_id`, `name`, and `state`. However, the question requires data about **volunteer hours** and **Health projects**, which are not present in the schema. Without tables containing `hours` or `program`/`project` information, it is impossible to calculate the requested metric. \n\n**Answer:**  \nThe schema is incomplete. The necessary tables (e.g., `volunteer_hours` or `projects`) to retrieve volunteer hours or project details are not defined.", "latency_sec": 5.796708822250366, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 946, "prompt_eval_sec": null, "tokens_completion": 906, "completion_eval_sec": null, "tokens_total": 1852, "tokens_per_sec": 319.49163858139536, "retrieval_latency_sec": 0.11046791076660156, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL queries multiple tables (volunteer_projects, volunteer_hours, volunteers) to calculate total hours for California volunteers in Health projects. The Generated 'SQL' is not a valid query but an explanation stating the schema is incomplete. The necessary tables (volunteer_hours, volunteer_projects) are missing from the schema, making the Generated SQL non-functional and semantically different from the Reference."}
{"example_id": 251, "sql_complexity": "set operations", "prompt": "Compare the number of economic diversification projects in two regions, one in Europe and one in Oceania, by showing the project type and the number of projects in each region.", "context": "CREATE TABLE economic_diversification (region VARCHAR(50), project_type VARCHAR(50), project_start_date DATE);", "reference_sql": "SELECT 'Europe' as region, project_type, COUNT(*) as project_count FROM economic_diversification WHERE region = 'Europe' UNION ALL SELECT 'Oceania' as region, project_type, COUNT(*) as project_count FROM economic_diversification WHERE region = 'Oceania';", "generated_sql": "SELECT 'Europe' AS region, project_type, COUNT(*) AS project_count FROM economic_diversification WHERE region = 'Europe' GROUP BY project_type UNION ALL SELECT 'Oceania' AS region, project_type, COUNT(*) AS project_count FROM economic_diversification WHERE region = 'Oceania' GROUP BY project_type;", "raw_model_output": "\n\nSELECT 'Europe' AS region, project_type, COUNT(*) AS project_count FROM economic_diversification WHERE region = 'Europe' GROUP BY project_type UNION ALL SELECT 'Oceania' AS region, project_type, COUNT(*) AS project_count FROM economic_diversification WHERE region = 'Oceania' GROUP BY project_type;", "latency_sec": 4.3663859367370605, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 745, "prompt_eval_sec": null, "tokens_completion": 661, "completion_eval_sec": null, "tokens_total": 1406, "tokens_per_sec": 322.0054343273843, "retrieval_latency_sec": 0.10314202308654785, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference SQL lacks GROUP BY clauses, which would cause it to return incorrect results (invalid SQL syntax in standard SQL). The generated SQL correctly groups by project_type for each region, ensuring accurate counts per project type. Without grouping, the reference query would either fail or produce arbitrary project_type values."}
{"example_id": 610, "sql_complexity": "subqueries", "prompt": "What is the percentage of community development projects completed in 'Caribbean' in 2020?", "context": "CREATE TABLE community_projects (project_id INT, project_name TEXT, location TEXT, completion_year INT); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (1, 'Community Center', 'Southern Region, Caribbean', 2020); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (2, 'Park Renovation', 'Northern Region, Caribbean', 2019); INSERT INTO community_projects (project_id, project_name, location, completion_year) VALUES (3, 'Library Construction', 'Caribbean', 2020);", "reference_sql": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM community_projects WHERE location = 'Caribbean')) FROM community_projects WHERE completion_year = 2020 AND location = 'Caribbean';", "generated_sql": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM community_projects WHERE location = 'Caribbean')) FROM community_projects WHERE completion_year = 2020 AND location = 'Caribbean';", "raw_model_output": "\n\nSELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM community_projects WHERE location = 'Caribbean')) FROM community_projects WHERE completion_year = 2020 AND location = 'Caribbean';", "latency_sec": 14.419916152954102, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1006, "prompt_eval_sec": null, "tokens_completion": 2243, "completion_eval_sec": null, "tokens_total": 3249, "tokens_per_sec": 225.3133766893923, "retrieval_latency_sec": 0.10733222961425781, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure and logic. Both queries calculate the percentage of community projects completed in 2020 within the 'Caribbean' location by dividing the count of matching projects by the total count of Caribbean projects. Since the queries are exactly the same, they will produce identical results."}
{"example_id": 421, "sql_complexity": "set operations", "prompt": "What is the combined landfill capacity for 'City A' and 'City B'?", "context": "CREATE TABLE landfill_capacity (city VARCHAR(255), capacity INT); INSERT INTO landfill_capacity (city, capacity) VALUES ('City A', 500000), ('City B', 600000);", "reference_sql": "SELECT SUM(capacity) FROM (SELECT capacity FROM landfill_capacity WHERE city = 'City A' UNION ALL SELECT capacity FROM landfill_capacity WHERE city = 'City B') AS combined_capacity;", "generated_sql": "SELECT SUM(capacity) FROM landfill_capacity WHERE city IN ('City A', 'City B');", "raw_model_output": "\n\nSELECT SUM(capacity) FROM landfill_capacity WHERE city IN ('City A', 'City B');", "latency_sec": 2.4056999683380127, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 817, "prompt_eval_sec": null, "tokens_completion": 366, "completion_eval_sec": null, "tokens_total": 1183, "tokens_per_sec": 491.7487698257236, "retrieval_latency_sec": 0.09906792640686035, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of capacities for 'City A' and 'City B'. The reference query uses a UNION ALL subquery to combine the two cities' capacities, while the generated query uses a single WHERE clause with IN. Since both approaches retrieve the same set of rows (500000 + 600000) and apply SUM, they produce identical results."}
{"example_id": 880, "sql_complexity": "aggregation", "prompt": "Show veteran employment statistics for each state in the 'veteran_employment' table", "context": "CREATE TABLE veteran_employment (employee_id INT, state VARCHAR(2), job_title VARCHAR(50), employment_date DATE);", "reference_sql": "SELECT state, COUNT(*) as veteran_employees FROM veteran_employment WHERE state IN ('CA', 'NY', 'TX', 'FL', 'PA') GROUP BY state;", "generated_sql": "SELECT state, COUNT(*) AS veteran_employees FROM veteran_employment GROUP BY state;", "raw_model_output": "\n\nSELECT state, COUNT(*) AS veteran_employees FROM veteran_employment GROUP BY state;", "latency_sec": 2.6992969512939453, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 624, "prompt_eval_sec": null, "tokens_completion": 412, "completion_eval_sec": null, "tokens_total": 1036, "tokens_per_sec": 383.8036417235899, "retrieval_latency_sec": 0.10972404479980469, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters results to only include records where the state is in ('CA', 'NY', 'TX', 'FL', 'PA'), while the Generated SQL includes all states present in the table. This means the Generated SQL could return more states than the Reference SQL, making them non-equivalent."}
{"example_id": 454, "sql_complexity": "single join", "prompt": "Which excavation sites have more than 10 artifacts?", "context": "CREATE TABLE ExcavationSite (SiteID INT, SiteName VARCHAR(50)); INSERT INTO ExcavationSite (SiteID, SiteName) VALUES (1, 'Site A'), (2, 'Site B'), (3, 'Site C'); CREATE TABLE Artifact (ArtifactID INT, SiteID INT, ObjectType VARCHAR(50)); INSERT INTO Artifact (ArtifactID, SiteID, ObjectType) VALUES (1, 1, 'Pottery'), (2, 1, 'Tool'), (3, 2, 'Statue'), (4, 2, 'Bead'), (5, 3, 'Bead'), (6, 3, 'Bead'), (7, 3, 'Bead'), (8, 3, 'Bead'), (9, 3, 'Bead'), (10, 3, 'Bead'), (11, 3, 'Bead');", "reference_sql": "SELECT e.SiteName FROM ExcavationSite e JOIN Artifact a ON e.SiteID = a.SiteID GROUP BY e.SiteName HAVING COUNT(a.ArtifactID) > 10;", "generated_sql": "SELECT e.SiteName  \nFROM ExcavationSite e  \nJOIN Artifact a ON e.SiteID = a.SiteID  \nGROUP BY e.SiteID, e.SiteName  \nHAVING COUNT(a.ArtifactID) > 10;", "raw_model_output": "\n\nSELECT e.SiteName  \nFROM ExcavationSite e  \nJOIN Artifact a ON e.SiteID = a.SiteID  \nGROUP BY e.SiteID, e.SiteName  \nHAVING COUNT(a.ArtifactID) > 10;", "latency_sec": 4.935970067977905, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1131, "prompt_eval_sec": null, "tokens_completion": 760, "completion_eval_sec": null, "tokens_total": 1891, "tokens_per_sec": 383.10605087900717, "retrieval_latency_sec": 0.10110282897949219, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their GROUP BY clauses. The Reference SQL groups by only 'SiteName', while the Generated SQL groups by both 'SiteID' and 'SiteName'. Although in the provided sample data (where SiteName is unique) they may produce the same result, semantically they are not equivalent. If multiple sites had the same SiteName (which is allowed by the schema), the Reference SQL would incorrectly aggregate artifacts across sites with the same name, whereas the Generated SQL would correctly separate them by SiteID. The Generated SQL is more robust and adheres to proper grouping practices."}
{"example_id": 1086, "sql_complexity": "aggregation", "prompt": "What is the total CO2 emission for each equipment type, excluding equipment that is older than 8 years?", "context": "CREATE TABLE EmissionData (EquipmentID INT, EquipmentType VARCHAR(50), CO2Emission INT, Age INT); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (1, 'Excavator', 50, 8); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (2, 'Haul Truck', 70, 7); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (3, 'Shovel', 30, 6); INSERT INTO EmissionData (EquipmentID, EquipmentType, CO2Emission, Age) VALUES (4, 'Drilling Rig', 40, 3);", "reference_sql": "SELECT EquipmentType, SUM(CO2Emission) as TotalCO2Emission FROM EmissionData WHERE Age <= 8 GROUP BY EquipmentType;", "generated_sql": "SELECT EquipmentType, SUM(CO2Emission) AS TotalCO2Emission FROM EmissionData WHERE Age <= 8 GROUP BY EquipmentType;", "raw_model_output": "\n\nSELECT EquipmentType, SUM(CO2Emission) AS TotalCO2Emission FROM EmissionData WHERE Age <= 8 GROUP BY EquipmentType;", "latency_sec": 3.426973342895508, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 868, "prompt_eval_sec": null, "tokens_completion": 505, "completion_eval_sec": null, "tokens_total": 1373, "tokens_per_sec": 400.6450773381065, "retrieval_latency_sec": 0.10083603858947754, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure, column aliases, conditions, and grouping. Both select EquipmentType and sum CO2Emission where Age <= 8, grouped by EquipmentType. No semantic differences exist between them."}
{"example_id": 3455, "sql_complexity": "basic SQL", "prompt": "What are the names of all innovation projects in the 'rural_infrastructure' table, excluding those with a budget over 50000?", "context": "CREATE TABLE rural_infrastructure (name VARCHAR(255), budget INT); INSERT INTO rural_infrastructure (name, budget) VALUES ('Dam Construction', 40000), ('Well Digging', 30000), ('Irrigation System', 70000);", "reference_sql": "SELECT name FROM rural_infrastructure WHERE budget <= 50000;", "generated_sql": "SELECT name FROM rural_infrastructure WHERE budget <= 50000;", "raw_model_output": "\n\nSELECT name FROM rural_infrastructure WHERE budget <= 50000;", "latency_sec": 3.0393710136413574, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 957, "prompt_eval_sec": null, "tokens_completion": 464, "completion_eval_sec": null, "tokens_total": 1421, "tokens_per_sec": 467.5309442717731, "retrieval_latency_sec": 0.1057581901550293, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure and logic. Both select the 'name' column from the 'rural_infrastructure' table where the 'budget' is less than or equal to 50000. The queries are syntactically and semantically identical, so they will produce the same result."}
{"example_id": 3936, "sql_complexity": "window functions", "prompt": "What is the total investment per client for each investment type?", "context": "CREATE TABLE clients (client_id INT, name TEXT, investment_type TEXT, investment FLOAT); INSERT INTO clients (client_id, name, investment_type, investment) VALUES (1, 'John Doe', 'Stocks', 3000.00), (1, 'John Doe', 'Bonds', 2000.00), (2, 'Jane Smith', 'Stocks', 5000.00);", "reference_sql": "SELECT client_id, name, investment_type, SUM(investment) OVER (PARTITION BY client_id, investment_type ORDER BY client_id) as total_investment FROM clients;", "generated_sql": "SELECT client_id, investment_type, SUM(investment) AS total_investment FROM clients GROUP BY client_id, investment_type;", "raw_model_output": "\n\nSELECT client_id, investment_type, SUM(investment) AS total_investment FROM clients GROUP BY client_id, investment_type;", "latency_sec": 3.5756800174713135, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 806, "prompt_eval_sec": null, "tokens_completion": 550, "completion_eval_sec": null, "tokens_total": 1356, "tokens_per_sec": 379.2285644616909, "retrieval_latency_sec": 0.10959529876708984, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query includes the 'name' column and uses a window function to calculate a running total, returning one row per original record. The generated query groups by client_id and investment_type, omitting 'name' and aggregating rows into one per group. This results in different column sets, row counts, and values (e.g., the window function's cumulative sum vs. grouped total)."}
{"example_id": 1838, "sql_complexity": "window functions", "prompt": "What are the top 3 species with the most sightings across all arctic research stations?", "context": "CREATE TABLE research_station (id INT, name TEXT); INSERT INTO research_station (id, name) VALUES (1, 'Station A'); INSERT INTO research_station (id, name) VALUES (2, 'Station B'); CREATE TABLE species_observations (station_id INT, species_name TEXT, sightings INT); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (1, 'Species 1', 10); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (1, 'Species 2', 5); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (2, 'Species 1', 8); INSERT INTO species_observations (station_id, species_name, sightings) VALUES (2, 'Species 3', 15);", "reference_sql": "SELECT species_name, SUM(sightings) as total_sightings, RANK() OVER (ORDER BY SUM(sightings) DESC) as rank FROM species_observations GROUP BY species_name HAVING rank <= 3;", "generated_sql": "SELECT species_name, SUM(sightings) AS total_sightings \nFROM species_observations \nGROUP BY species_name \nORDER BY total_sightings DESC \nLIMIT 3;", "raw_model_output": "\n\nSELECT species_name, SUM(sightings) AS total_sightings \nFROM species_observations \nGROUP BY species_name \nORDER BY total_sightings DESC \nLIMIT 3;", "latency_sec": 4.9016029834747314, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1116, "prompt_eval_sec": null, "tokens_completion": 735, "completion_eval_sec": null, "tokens_total": 1851, "tokens_per_sec": 377.63156384563644, "retrieval_latency_sec": 0.09390878677368164, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a RANK() column and uses HAVING rank <= 3, while the Generated SQL only returns species_name and total_sightings without ranking. The Reference query's HAVING clause references an analytic function (RANK()) which is not valid in standard SQL (analytic functions cannot be used in HAVING). Additionally, the result sets differ in columns returned (Reference includes rank, Generated does not)."}
{"example_id": 3091, "sql_complexity": "single join", "prompt": "Find the number of hybrid vehicles sold in the US, Germany, and Japan.", "context": "CREATE TABLE vehicle_sales (sale_id INT, vehicle_id INT, country VARCHAR(20), quantity INT); CREATE TABLE vehicles (vehicle_id INT, model VARCHAR(20), manufacture VARCHAR(20), vehicle_type VARCHAR(20));", "reference_sql": "SELECT SUM(vs.quantity) FROM vehicle_sales vs JOIN vehicles v ON vs.vehicle_id = v.vehicle_id WHERE v.vehicle_type = 'hybrid' AND vs.country IN ('US', 'Germany', 'Japan');", "generated_sql": "SELECT SUM(vs.quantity) \nFROM vehicle_sales vs \nJOIN vehicles v ON vs.vehicle_id = v.vehicle_id \nWHERE v.vehicle_type = 'hybrid' \n  AND vs.country IN ('US', 'Germany', 'Japan');", "raw_model_output": "\n\nSELECT SUM(vs.quantity) \nFROM vehicle_sales vs \nJOIN vehicles v ON vs.vehicle_id = v.vehicle_id \nWHERE v.vehicle_type = 'hybrid' \n  AND vs.country IN ('US', 'Germany', 'Japan');", "latency_sec": 2.9684321880340576, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 824, "prompt_eval_sec": null, "tokens_completion": 445, "completion_eval_sec": null, "tokens_total": 1269, "tokens_per_sec": 427.4983963303663, "retrieval_latency_sec": 0.09793210029602051, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The two queries are identical in structure and logic. Both perform a JOIN between vehicle_sales and vehicles on vehicle_id, filter for hybrid vehicle_type and countries in ('US', 'Germany', 'Japan'), and calculate the sum of quantity. The only difference is formatting (line breaks/indentation), which does not affect semantic equivalence."}
{"example_id": 2399, "sql_complexity": "set operations", "prompt": "What is the average duration of criminal trials for Indigenous defendants compared to non-Indigenous defendants in Canada and New Zealand?", "context": "CREATE TABLE canada_criminal_trials (id INT, defendant_type VARCHAR(255), days_to_completion INT); INSERT INTO canada_criminal_trials (id, defendant_type, days_to_completion) VALUES (1, 'Indigenous', 60), (2, 'Non-Indigenous', 45);CREATE TABLE nz_criminal_trials (id INT, defendant_type VARCHAR(255), days_to_completion INT); INSERT INTO nz_criminal_trials (id, defendant_type, days_to_completion) VALUES (1, 'Indigenous', 70), (2, 'Non-Indigenous', 50);", "reference_sql": "SELECT AVG(days_to_completion) AS avg_duration FROM canada_criminal_trials WHERE defendant_type = 'Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM canada_criminal_trials WHERE defendant_type = 'Non-Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM nz_criminal_trials WHERE defendant_type = 'Indigenous' UNION ALL SELECT AVG(days_to_completion) AS avg_duration FROM nz_criminal_trials WHERE defendant_type = 'Non-Indigenous';", "generated_sql": "SELECT 'Canada' AS country, defendant_type, AVG(days_to_completion) AS avg_duration FROM canada_criminal_trials GROUP BY defendant_type\nUNION ALL\nSELECT 'New Zealand' AS country, defendant_type, AVG(days_to_completion) AS avg_duration FROM nz_criminal_trials GROUP BY defendant_type;", "raw_model_output": "\n\nSELECT 'Canada' AS country, defendant_type, AVG(days_to_completion) AS avg_duration FROM canada_criminal_trials GROUP BY defendant_type\nUNION ALL\nSELECT 'New Zealand' AS country, defendant_type, AVG(days_to_completion) AS avg_duration FROM nz_criminal_trials GROUP BY defendant_type;", "latency_sec": 3.833919048309326, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 940, "prompt_eval_sec": null, "tokens_completion": 578, "completion_eval_sec": null, "tokens_total": 1518, "tokens_per_sec": 395.9395023401458, "retrieval_latency_sec": 0.11606884002685547, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns only the average durations in separate rows without any contextual columns, while the Generated SQL includes additional 'country' and 'defendant_type' columns. Although the numerical averages match, the result sets differ in structure, making them semantically distinct."}
{"example_id": 2972, "sql_complexity": "set operations", "prompt": "How many indigenous communities are in the Arctic Research Station 13 and 14?", "context": "CREATE TABLE Arctic_Research_Station_13 (id INT, community TEXT); CREATE TABLE Arctic_Research_Station_14 (id INT, community TEXT);", "reference_sql": "SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_13; SELECT COUNT(DISTINCT community) FROM Arctic_Research_Station_14; SELECT COUNT(DISTINCT community) FROM (SELECT * FROM Arctic_Research_Station_13 UNION ALL SELECT * FROM Arctic_Research_Station_14) AS Arctic_Communities;", "generated_sql": "SELECT COUNT(DISTINCT community) FROM (SELECT community FROM Arctic_Research_Station_13 UNION ALL SELECT community FROM Arctic_Research_Station_14) AS combined;", "raw_model_output": "\n\nSELECT COUNT(DISTINCT community) FROM (SELECT community FROM Arctic_Research_Station_13 UNION ALL SELECT community FROM Arctic_Research_Station_14) AS combined;", "latency_sec": 2.9887259006500244, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 693, "prompt_eval_sec": null, "tokens_completion": 448, "completion_eval_sec": null, "tokens_total": 1141, "tokens_per_sec": 381.7680302338336, "retrieval_latency_sec": 0.11092090606689453, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries count distinct 'community' values from both tables. The Reference's third query uses SELECT * (including id and community) but counts only 'community', while the Generated SQL explicitly selects only 'community'. Since the COUNT(DISTINCT community) is unaffected by additional columns, the results are equivalent."}
{"example_id": 5576, "sql_complexity": "window functions", "prompt": "Who are the top 5 users with the most followers, and what is their location?", "context": "CREATE TABLE user_data (user_id INT, name VARCHAR(50), followers INT, location VARCHAR(50)); INSERT INTO user_data (user_id, name, followers, location) VALUES (1, 'Alice', 10000, 'New York'), (2, 'Bob', 15000, 'California'), (3, 'Charlie', 12000, 'Texas'), (4, 'David', 8000, 'Florida'), (5, 'Eve', 9000, 'Illinois');", "reference_sql": "SELECT name, location FROM (SELECT name, location, ROW_NUMBER() OVER (ORDER BY followers DESC) AS rank FROM user_data) AS user_ranks WHERE rank <= 5;", "generated_sql": "SELECT name, location FROM user_data ORDER BY followers DESC LIMIT 5;", "raw_model_output": "\n\nSELECT name, location FROM user_data ORDER BY followers DESC LIMIT 5;", "latency_sec": 2.0403530597686768, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 936, "prompt_eval_sec": null, "tokens_completion": 285, "completion_eval_sec": null, "tokens_total": 1221, "tokens_per_sec": 598.4258430932683, "retrieval_latency_sec": 0.10941100120544434, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL uses ROW_NUMBER() to assign ranks and filters by rank <= 5, which ensures exactly 5 rows (even with ties in followers). The Generated SQL uses ORDER BY followers DESC LIMIT 5, which may return fewer than 5 rows if there are ties in followers (depending on database behavior). Additionally, the Reference SQL's subquery introduces an extra layer that could affect execution plans, though the final result set may appear similar in cases with unique followers."}
{"example_id": 1560, "sql_complexity": "basic SQL", "prompt": "What is the average media literacy score for users in the 'Young Adult' age group who have completed at least one disinformation detection course?", "context": "CREATE TABLE users (id INT, age VARCHAR(20), media_literacy_score INT, courses_completed INT);", "reference_sql": "SELECT AVG(media_literacy_score) FROM users WHERE age = 'Young Adult' AND courses_completed > 0;", "generated_sql": "SELECT AVG(media_literacy_score) FROM users WHERE age = 'Young Adult' AND courses_completed > 0;", "raw_model_output": "\n\nSELECT AVG(media_literacy_score) FROM users WHERE age = 'Young Adult' AND courses_completed > 0;", "latency_sec": 2.550818681716919, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 564, "prompt_eval_sec": null, "tokens_completion": 369, "completion_eval_sec": null, "tokens_total": 933, "tokens_per_sec": 365.7649235076212, "retrieval_latency_sec": 0.11468195915222168, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure, conditions, and selected columns. Both queries calculate the average media_literacy_score for users aged 'Young Adult' with courses_completed > 0, ensuring semantically equivalent results."}
{"example_id": 1201, "sql_complexity": "basic SQL", "prompt": "What is the maximum energy efficiency rating of hydroelectric dams in Canada?", "context": "CREATE TABLE hydro_dams (id INT, name TEXT, country TEXT, energy_efficiency_rating FLOAT); INSERT INTO hydro_dams (id, name, country, energy_efficiency_rating) VALUES (1, 'Robert-Bourassa', 'Canada', 0.94), (2, 'Churchill Falls', 'Canada', 0.92);", "reference_sql": "SELECT MAX(energy_efficiency_rating) FROM hydro_dams WHERE country = 'Canada';", "generated_sql": "SELECT MAX(energy_efficiency_rating) FROM hydro_dams WHERE country = 'Canada';", "raw_model_output": "\n\nSELECT MAX(energy_efficiency_rating) FROM hydro_dams WHERE country = 'Canada';", "latency_sec": 1.633317232131958, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 647, "prompt_eval_sec": null, "tokens_completion": 242, "completion_eval_sec": null, "tokens_total": 889, "tokens_per_sec": 544.2910798409898, "retrieval_latency_sec": 0.1341869831085205, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The reference and generated queries are identical in structure and logic. Both select the maximum energy_efficiency_rating from the hydro_dams table where country equals 'Canada', ensuring they will produce the same result."}
{"example_id": 4243, "sql_complexity": "single join", "prompt": "How many orders were placed by new and returning customers in each month of the year 2021?'", "context": "CREATE TABLE customer (id INT, first_order_date DATE, last_order_date DATE);", "reference_sql": "INSERT INTO customer (id, first_order_date, last_order_date) SELECT customer_id, MIN(order_date) AS first_order_date, MAX(order_date) AS last_order_date FROM orders GROUP BY customer_id; SELECT YEAR(order_date) AS year, MONTH(order_date) AS month, CASE WHEN DATEDIFF(last_order_date, first_order_date) > 30 THEN 'returning' ELSE 'new' END AS customer_type, COUNT(DISTINCT id) AS num_orders FROM orders JOIN customer ON orders.customer_id = customer.id WHERE YEAR(order_date) = 2021 GROUP BY year, month, customer_type;", "generated_sql": "SELECT \n    DATE_FORMAT(first_order_date, '%Y-%m') AS month,\n    COUNT(*) AS new_customers,\n    (SELECT COUNT(*) FROM customer WHERE first_order_date < DATE_FORMAT(first_order_date, '%Y-%m')) AS returning_customers\nFROM customer\nWHERE YEAR(first_order_date) = 2021\nGROUP BY month;", "raw_model_output": "\n\nSELECT \n    DATE_FORMAT(first_order_date, '%Y-%m') AS month,\n    COUNT(*) AS new_customers,\n    (SELECT COUNT(*) FROM customer WHERE first_order_date < DATE_FORMAT(first_order_date, '%Y-%m')) AS returning_customers\nFROM customer\nWHERE YEAR(first_order_date) = 2021\nGROUP BY month;", "latency_sec": 20.099332094192505, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 786, "prompt_eval_sec": null, "tokens_completion": 3152, "completion_eval_sec": null, "tokens_total": 3938, "tokens_per_sec": 195.9269084935337, "retrieval_latency_sec": 0.11661911010742188, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The reference query analyzes order data to classify customers as 'new' or 'returning' based on the 30-day gap between their first and last order dates, then aggregates orders by year/month. The generated query focuses on customer first_order_date, groups by formatted month, and uses a flawed subquery to count 'returning_customers' (comparing dates to string-formatted months, which is logically incorrect). The generated query lacks the order-level analysis and correct customer classification logic present in the reference query."}
{"example_id": 2321, "sql_complexity": "subqueries", "prompt": "What are the names and types of vessels used in research expeditions in the regions with the lowest ocean acidification levels?", "context": "CREATE TABLE ocean_acidification (id INT PRIMARY KEY, region VARCHAR(255), year INT, acidification_level INT); INSERT INTO ocean_acidification (id, region, year, acidification_level) VALUES (1, 'Arctic Ocean', 2018, 20), (2, 'Southern Ocean', 2019, 22); CREATE TABLE expedition_vessels (id INT PRIMARY KEY, name VARCHAR(255), type VARCHAR(255), region VARCHAR(255)); INSERT INTO expedition_vessels (id, name, type, region) VALUES (1, 'Sea Researcher', 'Research Vessel', 'Arctic Ocean');", "reference_sql": "SELECT v.name, v.type FROM expedition_vessels v INNER JOIN ocean_acidification oa ON v.region = oa.region WHERE oa.acidification_level = (SELECT MIN(acidification_level) FROM ocean_acidification);", "generated_sql": "SELECT name, type FROM expedition_vessels WHERE region IN (SELECT region FROM ocean_acidification WHERE acidification_level = (SELECT MIN(acidification_level) FROM ocean_acidification));", "raw_model_output": "\n\nSELECT name, type FROM expedition_vessels WHERE region IN (SELECT region FROM ocean_acidification WHERE acidification_level = (SELECT MIN(acidification_level) FROM ocean_acidification));", "latency_sec": 5.865691900253296, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 902, "prompt_eval_sec": null, "tokens_completion": 914, "completion_eval_sec": null, "tokens_total": 1816, "tokens_per_sec": 309.5968951116543, "retrieval_latency_sec": 0.1322331428527832, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL uses an INNER JOIN which may return duplicate rows if multiple entries in ocean_acidification share the same region and minimum acidification_level. The Generated SQL uses a WHERE IN clause, which ensures each region is considered once, leading to potentially fewer rows. This difference in handling duplicates makes them non-equivalent in general cases."}
{"example_id": 4349, "sql_complexity": "multiple_joins", "prompt": "Show the research grants awarded to professors in the Computer Science department.", "context": "CREATE TABLE departments (id INT, name VARCHAR(50)); INSERT INTO departments (id, name) VALUES (1, 'Computer Science'), (2, 'Mathematics'); CREATE TABLE professors (id INT, name VARCHAR(50), department_id INT); INSERT INTO professors (id, name, department_id) VALUES (1, 'John Smith', 1), (2, 'Jane Doe', 2); CREATE TABLE grants (id INT, professor_id INT, year INT, amount FLOAT); INSERT INTO grants (id, professor_id, year, amount) VALUES (1, 1, 2021, 5000.0), (2, 2, 2020, 7000.0);", "reference_sql": "SELECT professors.name, grants.amount FROM professors INNER JOIN grants ON professors.id = grants.professor_id INNER JOIN departments ON professors.department_id = departments.id WHERE departments.name = 'Computer Science';", "generated_sql": "SELECT g.* FROM grants g JOIN professors p ON g.professor_id = p.id JOIN departments d ON p.department_id = d.id WHERE d.name = 'Computer Science';", "raw_model_output": "\n\nSELECT g.* FROM grants g JOIN professors p ON g.professor_id = p.id JOIN departments d ON p.department_id = d.id WHERE d.name = 'Computer Science';", "latency_sec": 3.0076181888580322, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 879, "prompt_eval_sec": null, "tokens_completion": 442, "completion_eval_sec": null, "tokens_total": 1321, "tokens_per_sec": 439.2179848139477, "retrieval_latency_sec": 0.10812711715698242, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL selects specific columns (professors.name and grants.amount), while the Generated SQL selects all columns from the grants table (g.*). This difference in selected columns means the result sets would have different structures, even if the underlying data matches."}
{"example_id": 476, "sql_complexity": "basic SQL", "prompt": "Insert new food safety records for locations \"A123\", \"B456\", and \"C789\"", "context": "CREATE TABLE food_safety_records (id INT, location VARCHAR(255), inspection_date DATE, violation_count INT);", "reference_sql": "INSERT INTO food_safety_records (location, inspection_date, violation_count) VALUES ('A123', '2022-03-01', 0), ('B456', '2022-03-05', 2), ('C789', '2022-03-10', 1);", "generated_sql": "INSERT INTO food_safety_records (location, inspection_date, violation_count) VALUES ('A123', CURRENT_DATE, 0), ('B456', CURRENT_DATE, 0), ('C789', CURRENT_DATE, 0);", "raw_model_output": "\n\nINSERT INTO food_safety_records (location, inspection_date, violation_count) VALUES ('A123', CURRENT_DATE, 0), ('B456', CURRENT_DATE, 0), ('C789', CURRENT_DATE, 0);", "latency_sec": 10.892728090286255, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 641, "prompt_eval_sec": null, "tokens_completion": 1717, "completion_eval_sec": null, "tokens_total": 2358, "tokens_per_sec": 216.4746958204878, "retrieval_latency_sec": 0.0880889892578125, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL inserts specific dates and violation counts, while the Generated SQL uses CURRENT_DATE (which varies) and sets all violation_counts to 0. The data values differ in both inspection dates and violation counts."}
{"example_id": 2908, "sql_complexity": "single join", "prompt": "List all co-owners and the properties they own in New York, NY.", "context": "CREATE TABLE properties (id INT, city VARCHAR(50), price INT); CREATE TABLE co_owners (property_id INT, owner_name VARCHAR(50)); INSERT INTO properties (id, city, price) VALUES (1, 'New York', 800000), (2, 'Los Angeles', 600000); INSERT INTO co_owners (property_id, owner_name) VALUES (1, 'David'), (1, 'Ella'), (2, 'Frank');", "reference_sql": "SELECT properties.city, co_owners.owner_name FROM properties INNER JOIN co_owners ON properties.id = co_owners.property_id WHERE properties.city = 'New York';", "generated_sql": "SELECT co.owner_name, p.id \nFROM co_owners co \nJOIN properties p ON co.property_id = p.id \nWHERE p.city = 'New York';", "raw_model_output": "\n\nSELECT co.owner_name, p.id \nFROM co_owners co \nJOIN properties p ON co.property_id = p.id \nWHERE p.city = 'New York';", "latency_sec": 13.013858079910278, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 758, "prompt_eval_sec": null, "tokens_completion": 2047, "completion_eval_sec": null, "tokens_total": 2805, "tokens_per_sec": 215.53946437529757, "retrieval_latency_sec": 0.1066138744354248, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries select different columns. The Reference SQL returns (city, owner_name) while the Generated SQL returns (owner_name, id). Although both filter properties in 'New York' and join the same tables, the column names and order differ, leading to different result structures."}
{"example_id": 636, "sql_complexity": "set operations", "prompt": "Insert new data into the 'cosmetic_ingredients' table for a vegan eyeshadow product by brand 'Ara' with ingredients 'Mica', 'Iron Oxide', 'Titanium Dioxide' and 'Zinc Oxide'.", "context": "CREATE TABLE cosmetic_ingredients (ingredient_id INT, product_name TEXT, brand_name TEXT, ingredient_type TEXT);", "reference_sql": "INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type) VALUES (NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient'); INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type, ingredient_name) SELECT ingredient_id, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Mica' FROM cosmetic_ingredients WHERE ingredient_name = 'Mica' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Iron Oxide' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Titanium Dioxide' UNION ALL SELECT NULL, 'Vegan Eyeshadow', 'Ara', 'Ingredient', 'Zinc Oxide';", "generated_sql": "INSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type) VALUES \n((SELECT MAX(ingredient_id) FROM cosmetic_ingredients) + 1, 'Vegan Eyeshadow', 'Ara', 'Mica'), \n((SELECT MAX(ingredient_id) FROM cosmetic_ingredients) + 1, 'Vegan Eyeshadow', 'Ara', 'Iron Oxide'), \n((SELECT MAX(ingredient_id) FROM cosmetic_ingredients) + 1, 'Vegan Eyeshadow', 'Ara', 'Titanium Dioxide'), \n((SELECT MAX(ingredient_id) FROM cosmetic_ingredients) + 1, 'Vegan Eyeshadow', 'Ara', 'Zinc Oxide');", "raw_model_output": "\n\nINSERT INTO cosmetic_ingredients (ingredient_id, product_name, brand_name, ingredient_type) VALUES \n((SELECT MAX(ingredient_id) FROM cosmetic_ingredients) + 1, 'Vegan Eyeshadow', 'Ara', 'Mica'), \n((SELECT MAX(ingredient_id) FROM cosmetic_ingredients) + 1, 'Vegan Eyeshadow', 'Ara', 'Iron Oxide'), \n((SELECT MAX(ingredient_id) FROM cosmetic_ingredients) + 1, 'Vegan Eyeshadow', 'Ara', 'Titanium Dioxide'), \n((SELECT MAX(ingredient_id) FROM cosmetic_ingredients) + 1, 'Vegan Eyeshadow', 'Ara', 'Zinc Oxide');", "latency_sec": 16.4842631816864, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 756, "prompt_eval_sec": null, "tokens_completion": 2578, "completion_eval_sec": null, "tokens_total": 3334, "tokens_per_sec": 202.25350464581211, "retrieval_latency_sec": 0.11301708221435547, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL attempts to insert into a non-existent 'ingredient_name' column and includes an initial row with 'Ingredient' as the type, while the Generated SQL inserts four rows with ingredient types as the actual names. Additionally, the Generated SQL's use of (SELECT MAX(ingredient_id) + 1) would assign the same ID to all inserted rows, causing duplicates, whereas the Reference SQL uses existing or NULL IDs. The data structure and output differ significantly."}
{"example_id": 3404, "sql_complexity": "multiple_joins", "prompt": "What are the names of startups that have received funding from investors with over 3 million funds, and are involved in Genetic Research or Bioprocess Engineering?", "context": "CREATE TABLE public.investors ( id SERIAL PRIMARY KEY, name VARCHAR(100), type VARCHAR(50), funds INTEGER ); CREATE TABLE public.investments ( id SERIAL PRIMARY KEY, investor_id INTEGER, startup_id INTEGER ); CREATE TABLE public.startups ( id SERIAL PRIMARY KEY, name VARCHAR(100), industry VARCHAR(50), funding INTEGER );", "reference_sql": "SELECT startups.name FROM public.startups JOIN public.investments ON startups.id = investments.startup_id JOIN public.investors ON investments.investor_id = investors.id WHERE (startups.industry = 'Genetic Research' OR startups.industry = 'Bioprocess Engineering') AND investors.funds > 3000000;", "generated_sql": "SELECT DISTINCT s.name \nFROM public.startups s \nJOIN public.investments i ON s.id = i.startup_id \nJOIN public.investors inv ON i.investor_id = inv.id \nWHERE inv.funds > 3000000 \nAND s.industry IN ('Genetic Research', 'Bioprocess Engineering');", "raw_model_output": "\n\nSELECT DISTINCT s.name \nFROM public.startups s \nJOIN public.investments i ON s.id = i.startup_id \nJOIN public.investors inv ON i.investor_id = inv.id \nWHERE inv.funds > 3000000 \nAND s.industry IN ('Genetic Research', 'Bioprocess Engineering');", "latency_sec": 4.315380096435547, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 931, "prompt_eval_sec": null, "tokens_completion": 656, "completion_eval_sec": null, "tokens_total": 1587, "tokens_per_sec": 367.75439579721916, "retrieval_latency_sec": 0.11249709129333496, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the use of DISTINCT in the Generated SQL, which eliminates duplicate startup names. The Reference SQL does not have DISTINCT, so it might return duplicate names if multiple investments exist from the same investor to the same startup. The industry condition is equivalent via IN vs OR, but the DISTINCT clause makes the result sets potentially different."}
{"example_id": 134, "sql_complexity": "subqueries", "prompt": "Who are the top 3 authors with the most citations in the Mathematics department in the past 5 years?", "context": "CREATE TABLE authors (id INT, name VARCHAR(50), department VARCHAR(50)); INSERT INTO authors (id, name, department) VALUES (1, 'Author Name', 'Mathematics'); CREATE TABLE publications (id INT, title VARCHAR(100), author VARCHAR(50), journal VARCHAR(50), year INT, cites INT); INSERT INTO publications (id, title, author, journal, year, cites) VALUES (1, 'Publication Title', 'Author Name', 'Journal Name', 2021, 10);", "reference_sql": "SELECT author, SUM(cites) as total_cites FROM publications WHERE author IN (SELECT name FROM authors WHERE department = 'Mathematics') AND year BETWEEN YEAR(CURRENT_DATE) - 5 AND YEAR(CURRENT_DATE) GROUP BY author ORDER BY total_cites DESC LIMIT 3;", "generated_sql": "SELECT a.name, SUM(p.cites) AS total_cites \nFROM authors a \nJOIN publications p ON a.name = p.author \nWHERE a.department = 'Mathematics' \n  AND p.year >= EXTRACT(YEAR FROM CURRENT_DATE) - 5 \nGROUP BY a.name \nORDER BY total_cites DESC \nLIMIT 3;", "raw_model_output": "\n\nSELECT a.name, SUM(p.cites) AS total_cites \nFROM authors a \nJOIN publications p ON a.name = p.author \nWHERE a.department = 'Mathematics' \n  AND p.year >= EXTRACT(YEAR FROM CURRENT_DATE) - 5 \nGROUP BY a.name \nORDER BY total_cites DESC \nLIMIT 3;", "latency_sec": 17.27765703201294, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1059, "prompt_eval_sec": null, "tokens_completion": 2713, "completion_eval_sec": null, "tokens_total": 3772, "tokens_per_sec": 218.3166382462068, "retrieval_latency_sec": 0.10412812232971191, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the top 3 authors from the 'Mathematics' department with the highest total citations in the last 5 years. The Reference SQL uses a subquery to filter authors, while the Generated SQL uses a JOIN. The year conditions (BETWEEN vs. >=) are equivalent, and both group by author name. The output columns (author name and total_cites) are identical. Assuming unique author names, the results will match."}
{"example_id": 592, "sql_complexity": "set operations", "prompt": "How many public healthcare facilities and public parks are there in total, in the 'StateData' schema's 'StateHealthcare' and 'StateParks' tables?", "context": "CREATE SCHEMA StateData; CREATE TABLE StateHealthcare (Name varchar(255), Type varchar(255)); INSERT INTO StateHealthcare (Name, Type) VALUES ('FacilityA', 'Public'), ('FacilityB', 'Public'), ('FacilityC', 'Private'); CREATE TABLE StateParks (Name varchar(255), Type varchar(255)); INSERT INTO StateParks (Name, Type) VALUES ('ParkA', 'Public'), ('ParkB', 'Public'), ('ParkC', 'Private');", "reference_sql": "SELECT COUNT(*) FROM StateData.StateHealthcare WHERE Type = 'Public' UNION ALL SELECT COUNT(*) FROM StateData.StateParks WHERE Type = 'Public';", "generated_sql": "SELECT (SELECT COUNT(*) FROM StateData.StateHealthcare WHERE Type = 'Public') + (SELECT COUNT(*) FROM StateData.StateParks WHERE Type = 'Public') AS TotalPublicFacilitiesAndParks;", "raw_model_output": "\n\nSELECT (SELECT COUNT(*) FROM StateData.StateHealthcare WHERE Type = 'Public') + (SELECT COUNT(*) FROM StateData.StateParks WHERE Type = 'Public') AS TotalPublicFacilitiesAndParks;", "latency_sec": 4.840403318405151, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 759, "prompt_eval_sec": null, "tokens_completion": 734, "completion_eval_sec": null, "tokens_total": 1493, "tokens_per_sec": 308.4453715505516, "retrieval_latency_sec": 0.10104918479919434, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query returns two separate counts (one for StateHealthcare and one for StateParks) as two rows, while the generated query returns a single row with the summed total. The output structure differs (two rows vs. one row), making them non-equivalent."}
{"example_id": 1989, "sql_complexity": "single join", "prompt": "What are the names and production dates of garments made from fabrics with a sustainability score over 70, produced after 2021-01-01?", "context": "CREATE TABLE fabrics (id INT, name VARCHAR(50), type VARCHAR(50), sustainability_score INT); INSERT INTO fabrics (id, name, type, sustainability_score) VALUES (1, 'Organic Linen', 'Natural', 80); INSERT INTO fabrics (id, name, type, sustainability_score) VALUES (2, 'Recycled Nylon', 'Synthetic', 72);", "reference_sql": "SELECT garments.name, garments.production_date FROM garments JOIN fabrics ON garments.fabric_id = fabrics.id WHERE fabrics.sustainability_score > 70 AND garments.production_date > '2021-01-01';", "generated_sql": "SELECT garments.name, garments.production_date\nFROM garments\nJOIN fabrics ON garments.fabric_id = fabrics.id\nWHERE fabrics.sustainability_score > 70\n  AND garments.production_date > '2021-01-01';", "raw_model_output": "\n\nThe question references a `garments` table, which is not included in the provided schema. However, based on the examples and logical inference, we assume the existence of a `garments` table with columns `name`, `production_date`, and a foreign key `fabric_id` linking to the `fabrics` table. Here's the SQL query:\n\n```sql\nSELECT garments.name, garments.production_date\nFROM garments\nJOIN fabrics ON garments.fabric_id = fabrics.id\nWHERE fabrics.sustainability_score > 70\n  AND garments.production_date > '2021-01-01';\n``` \n\n**Note**: The schema provided in the context only includes the `fabrics` table. The `garments` table and its structure are inferred based on the question and examples. If the actual schema differs, the query may need adjustment.", "latency_sec": 7.340364933013916, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 710, "prompt_eval_sec": null, "tokens_completion": 1150, "completion_eval_sec": null, "tokens_total": 1860, "tokens_per_sec": 253.39339623763004, "retrieval_latency_sec": 0.10897612571716309, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries select the same columns, perform identical JOIN conditions, and apply the same WHERE clause filters (sustainability_score > 70 and production_date > '2021-01-01'). The syntax is identical, with no differences in logical structure or semantic meaning."}
{"example_id": 1388, "sql_complexity": "aggregation", "prompt": "What was the total donation amount by each organization in the last 30 days?", "context": "CREATE TABLE organization_donations (id INT, organization TEXT, donation_date DATE, donation_amount DECIMAL(10,2)); INSERT INTO organization_donations (id, organization, donation_date, donation_amount) VALUES (1, 'Organization A', '2021-03-15', 100.00), (2, 'Organization B', '2021-03-25', 200.00);", "reference_sql": "SELECT organization, SUM(donation_amount) FROM organization_donations WHERE donation_date >= DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY) GROUP BY organization;", "generated_sql": "SELECT organization, SUM(donation_amount) AS total_donation \nFROM organization_donations \nWHERE donation_date >= CURRENT_DATE - INTERVAL '30 days' \nGROUP BY organization;", "raw_model_output": "\n\nSELECT organization, SUM(donation_amount) AS total_donation \nFROM organization_donations \nWHERE donation_date >= CURRENT_DATE - INTERVAL '30 days' \nGROUP BY organization;", "latency_sec": 4.62500786781311, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 981, "prompt_eval_sec": null, "tokens_completion": 713, "completion_eval_sec": null, "tokens_total": 1694, "tokens_per_sec": 366.26964719110657, "retrieval_latency_sec": 0.10847806930541992, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of donation_amount for each organization where donation_date is within the last 30 days. The date calculation syntax differs (DATE_SUB vs. CURRENT_DATE - INTERVAL), but both expressions evaluate to the same date range. The GROUP BY and aggregation logic are identical."}
{"example_id": 1628, "sql_complexity": "window functions", "prompt": "What is the ranking of national security measures for Russia based on the publication date?", "context": "CREATE TABLE national_security (id INT, title VARCHAR(255), description TEXT, agency VARCHAR(255), date DATE); INSERT INTO national_security (id, title, description, agency, date) VALUES (1, 'National Cyber Strategy', 'Outlines the approach to protecting the American people and the American way of life in the digital age', 'White House', '2018-09-20'); INSERT INTO national_security (id, title, description, agency, date) VALUES (2, 'Cybersecurity and Infrastructure Security Agency Act of 2018', 'Establishes the Cybersecurity and Infrastructure Security Agency within the Department of Homeland Security', 'Congress', '2018-11-16'); INSERT INTO national_security (id, title, description, agency, date) VALUES (3, 'Russian Military Doctrine', 'Outlines the country\u2019s stance on military security', 'Russian Government', '2014-12-26');", "reference_sql": "SELECT title, description, agency, date, ROW_NUMBER() OVER (PARTITION BY agency ORDER BY date DESC) as ranking FROM national_security WHERE agency = 'Russian Government';", "generated_sql": "SELECT title, date, RANK() OVER (ORDER BY date) AS ranking FROM national_security WHERE agency = 'Russian Government';", "raw_model_output": "\n\nSELECT title, date, RANK() OVER (ORDER BY date) AS ranking FROM national_security WHERE agency = 'Russian Government';", "latency_sec": 4.554915189743042, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1304, "prompt_eval_sec": null, "tokens_completion": 700, "completion_eval_sec": null, "tokens_total": 2004, "tokens_per_sec": 439.9642839701374, "retrieval_latency_sec": 0.10997128486633301, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in three key aspects: 1) The Reference SQL uses ROW_NUMBER() with PARTITION BY agency and ORDER BY date DESC, while the Generated SQL uses RANK() without partitioning and orders by date (ascending by default). 2) The Reference SQL includes description and agency columns in the output, whereas the Generated SQL omits them. 3) The ranking logic differs: ROW_NUMBER() assigns unique sequential integers within partitions, while RANK() may leave gaps for ties. These differences ensure distinct results."}
{"example_id": 2300, "sql_complexity": "aggregation", "prompt": "What is the minimum capacity for schools in each location ('community_development')?", "context": "CREATE TABLE community_development.schools (id INT, name VARCHAR(50), capacity INT, location VARCHAR(50));", "reference_sql": "SELECT location, MIN(capacity) FROM community_development.schools GROUP BY location;", "generated_sql": "SELECT location, MIN(capacity) FROM community_development.schools GROUP BY location;", "raw_model_output": "\n\nSELECT location, MIN(capacity) FROM community_development.schools GROUP BY location;", "latency_sec": 2.0129220485687256, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 484, "prompt_eval_sec": null, "tokens_completion": 307, "completion_eval_sec": null, "tokens_total": 791, "tokens_per_sec": 392.9610689904436, "retrieval_latency_sec": 0.10623693466186523, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL are identical in structure and logic. Both queries select the 'location' and minimum 'capacity' from the 'community_development.schools' table, grouping results by 'location'. Since the queries are exactly the same, they will produce identical results."}
{"example_id": 4976, "sql_complexity": "set operations", "prompt": "What is the most common hashtag used in posts made by users from Brazil?", "context": "CREATE TABLE posts (id INT, user_id INT, content TEXT, hashtags TEXT, post_date DATE); INSERT INTO posts (id, user_id, content, hashtags, post_date) VALUES (1, 1, 'Hello World', '#datascience', '2022-06-01'), (2, 1, 'I love data', '#ai', '2022-06-02'), (3, 2, 'Ol\u00e1 Mundo', '#brasil', '2022-06-03'); CREATE TABLE users (id INT, name VARCHAR(100), country VARCHAR(50)); INSERT INTO users (id, name, country) VALUES (1, 'Jo\u00e3o Silva', 'Brazil'), (2, 'Maria Souza', 'Brazil');", "reference_sql": "SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(hashtags, ' ', n.n), ' ', -1) hashtag, COUNT(*) count FROM posts JOIN users ON posts.user_id = users.id CROSS JOIN (SELECT 1 n UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5) n WHERE users.country = 'Brazil' GROUP BY hashtag ORDER BY count DESC LIMIT 1;", "generated_sql": "SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(hashtags, ' ', n.n), ' ', -1) AS hashtag, COUNT(*) AS count  \nFROM posts  \nJOIN users ON posts.user_id = users.id  \nCROSS JOIN (SELECT 1 AS n UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5) AS n  \nWHERE users.country = 'Brazil'  \nGROUP BY hashtag  \nORDER BY count DESC  \nLIMIT 1;", "raw_model_output": "\n\nSELECT SUBSTRING_INDEX(SUBSTRING_INDEX(hashtags, ' ', n.n), ' ', -1) AS hashtag, COUNT(*) AS count  \nFROM posts  \nJOIN users ON posts.user_id = users.id  \nCROSS JOIN (SELECT 1 AS n UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5) AS n  \nWHERE users.country = 'Brazil'  \nGROUP BY hashtag  \nORDER BY count DESC  \nLIMIT 1;", "latency_sec": 13.124013900756836, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1398, "prompt_eval_sec": null, "tokens_completion": 2061, "completion_eval_sec": null, "tokens_total": 3459, "tokens_per_sec": 263.5626589667454, "retrieval_latency_sec": 0.11449599266052246, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries perform the same operations: extracting individual hashtags from the 'hashtags' column using nested SUBSTRING_INDEX functions, joining posts with users where country is 'Brazil', and grouping by the extracted hashtag to count occurrences. The only differences are syntactic (column aliases in the Generated SQL) which do not affect the semantic result. The core logic, table joins, filtering, and aggregation are identical."}
{"example_id": 4637, "sql_complexity": "single join", "prompt": "What is the total value of transactions for each customer in the last 30 days?", "context": "CREATE TABLE transactions (id INT, customer_id INT, value DECIMAL(10, 2), transaction_date DATE); INSERT INTO transactions (id, customer_id, value, transaction_date) VALUES (1, 1, 100, '2022-01-01'), (2, 1, 200, '2022-01-15'), (3, 2, 50, '2022-01-05'), (4, 2, 150, '2022-01-30'), (5, 3, 300, '2022-01-20');", "reference_sql": "SELECT c.id, SUM(t.value) FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE t.transaction_date >= CURDATE() - INTERVAL 30 DAY GROUP BY c.id;", "generated_sql": "SELECT customer_id, SUM(value) FROM transactions WHERE transaction_date >= CURRENT_DATE - INTERVAL '30 days' GROUP BY customer_id;", "raw_model_output": "\n\nSELECT customer_id, SUM(value) FROM transactions WHERE transaction_date >= CURRENT_DATE - INTERVAL '30 days' GROUP BY customer_id;", "latency_sec": 6.8969738483428955, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 1066, "prompt_eval_sec": null, "tokens_completion": 1051, "completion_eval_sec": null, "tokens_total": 2117, "tokens_per_sec": 306.94621243324593, "retrieval_latency_sec": 0.09407520294189453, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of transaction values for each customer within the last 30 days. The Reference SQL uses an INNER JOIN with customers and groups by c.id, while the Generated SQL directly groups by customer_id from transactions. Since the join condition ensures customer_id matches and the date filtering is equivalent (CURDATE() - INTERVAL 30 DAY vs CURRENT_DATE - INTERVAL '30 days'), the results will be identical. The column name difference (c.id vs customer_id) does not affect semantic equivalence as the data values remain the same."}
{"example_id": 4947, "sql_complexity": "aggregation", "prompt": "What is the total revenue for drugs approved between 2017 and 2019?", "context": "CREATE TABLE drug_sales_3 (drug_name TEXT, revenue FLOAT, year INT); INSERT INTO drug_sales_3 (drug_name, revenue, year) VALUES ('DrugG', 20000000, 2019), ('DrugG', 19000000, 2018), ('DrugH', 15000000, 2017), ('DrugH', 16000000, 2018);", "reference_sql": "SELECT drug_name, SUM(revenue) FROM drug_sales_3 WHERE year BETWEEN 2017 AND 2019 GROUP BY drug_name;", "generated_sql": "The question asks for the total revenue of drugs approved between 2017 and 2019. However, the provided schema only includes the `drug_sales_3` table, which contains `drug_name`, `revenue`, and `year` columns. There is **no table or column** in the schema that explicitly stores the **approval year** of the drugs. \n\nWithout access to a table (e.g., `drug_approval`) that links drugs to their approval years, it is **impossible to determine** which drugs were approved during the specified time frame. The `year` column in `drug_sales_3` likely represents the year of sales, not approval, and there is no mechanism to infer approval years from the given data.\n\n### Final Answer:\nThe question cannot be answered with the provided schema, as there is no data about drug approvals.", "raw_model_output": "\n\nThe question asks for the total revenue of drugs approved between 2017 and 2019. However, the provided schema only includes the `drug_sales_3` table, which contains `drug_name`, `revenue`, and `year` columns. There is **no table or column** in the schema that explicitly stores the **approval year** of the drugs. \n\nWithout access to a table (e.g., `drug_approval`) that links drugs to their approval years, it is **impossible to determine** which drugs were approved during the specified time frame. The `year` column in `drug_sales_3` likely represents the year of sales, not approval, and there is no mechanism to infer approval years from the given data.\n\n### Final Answer:\nThe question cannot be answered with the provided schema, as there is no data about drug approvals.", "latency_sec": 8.252807140350342, "total_duration_sec": null, "load_duration_sec": null, "tokens_prompt": 989, "prompt_eval_sec": null, "tokens_completion": 1275, "completion_eval_sec": null, "tokens_total": 2264, "tokens_per_sec": 274.3308987472462, "retrieval_latency_sec": 0.13856196403503418, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL aggregates sales revenue by drug for years 2017-2019, while the Generated SQL attempts to calculate revenue for drugs approved during that period. The schema lacks approval year data, making the Generated SQL's goal unachievable. The WHERE conditions (sales year vs. approval year) and semantic goals differ, so they are not equivalent."}
