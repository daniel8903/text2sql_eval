{"example_id": 904, "sql_complexity": "basic SQL", "prompt": "What is the minimum Shariah-compliant loan amount issued in the last quarter of 2021?", "context": "CREATE TABLE loans (id INT, amount DECIMAL, date DATE, loan_type VARCHAR); INSERT INTO loans (id, amount, date, loan_type) VALUES (1, 5000, '2021-09-05', 'Shariah-compliant'), (2, 7000, '2021-10-07', 'socially responsible'), (3, 9000, '2021-11-03', 'Shariah-compliant'), (4, 11000, '2021-12-31', 'Shariah-compliant');", "reference_sql": "SELECT MIN(amount) FROM loans WHERE EXTRACT(YEAR FROM date) = 2021 AND EXTRACT(QUARTER FROM date) = 4 AND loan_type = 'Shariah-compliant';", "generated_sql": "SELECT MIN(amount) FROM loans WHERE loan_type = 'Shariah-compliant' AND date BETWEEN DATE_SUB(CURRENT_DATE, INTERVAL '3 month') AND CURRENT_DATE;", "raw_model_output": "Explanation:\nThis query calculates the minimum Shariah-compliant loan amount issued in the last quarter of 2021 by filtering loans with a Shariah-compliant type and date within the last quarter of 2021. It then orders these results by the loan amount, returning only the smallest value.\n\nSQL:\nSELECT MIN(amount) FROM loans WHERE loan_type = 'Shariah-compliant' AND date BETWEEN DATE_SUB(CURRENT_DATE, INTERVAL '3 month') AND CURRENT_DATE;", "latency_sec": 5.55492901802063, "total_duration_sec": 5.414772452, "load_duration_sec": 3.761144978, "tokens_prompt": 210, "prompt_eval_sec": 0.098515401, "tokens_completion": 97, "completion_eval_sec": 1.554546995, "tokens_total": 307, "tokens_per_sec": 55.26623274646133, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query filters for loans in 2021's fourth quarter (October-December 2021) with 'Shariah-compliant' type. The generated query uses a relative date range (last 3 months from CURRENT_DATE), which depends on the current date and may not align with 2021's dates. Additionally, the generated query does not explicitly check the year or quarter, leading to different filtering logic."}
{"example_id": 1373, "sql_complexity": "subqueries", "prompt": "What is the total value of military equipment sales to Africa in the last 12 months?", "context": "CREATE TABLE Military_Equipment_Sales(sale_id INT, sale_date DATE, equipment_type VARCHAR(50), country VARCHAR(50), sale_value DECIMAL(10,2));", "reference_sql": "SELECT SUM(sale_value) FROM Military_Equipment_Sales WHERE country IN (SELECT country FROM World_Countries WHERE continent = 'Africa') AND sale_date >= DATE_SUB(CURRENT_DATE, INTERVAL 12 MONTH);", "generated_sql": "SELECT SUM(sale_value) FROM Military_Equipment_Sales WHERE country = 'Africa' AND sale_date >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR);", "raw_model_output": "Explanation:\nThis query calculates the total value of military equipment sales to Africa in the last 12 months by filtering records based on country and date. It then sums up the sale_value column for these filtered records.\n\nSQL:\nSELECT SUM(sale_value) FROM Military_Equipment_Sales WHERE country = 'Africa' AND sale_date >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR);", "latency_sec": 1.3760349750518799, "total_duration_sec": 1.270957014, "load_duration_sec": 0.021824028, "tokens_prompt": 126, "prompt_eval_sec": 0.013644497, "tokens_completion": 78, "completion_eval_sec": 1.235083229, "tokens_total": 204, "tokens_per_sec": 148.2520456955018, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their country filtering logic. The reference query uses a subquery to select countries in Africa from World_Countries, while the generated query incorrectly filters for country = 'Africa' (assuming 'Africa' is a country name). The date functions (CURRENT_DATE vs CURDATE) are equivalent, and INTERVAL 12 MONTH vs 1 YEAR are functionally the same. However, the country condition is not equivalent due to the subquery vs literal comparison."}
{"example_id": 5039, "sql_complexity": "subqueries", "prompt": "What is the total number of community policing events in 'City Park' in 2021?", "context": "CREATE TABLE locations (id INT, name VARCHAR(255)); CREATE TABLE community_policing (id INT, location_id INT, year INT, events INT); INSERT INTO locations (id, name) VALUES (1, 'City Park'); INSERT INTO community_policing (id, location_id, year, events) VALUES (1, 1, 2021, 5);", "reference_sql": "SELECT SUM(events) FROM community_policing WHERE location_id = (SELECT id FROM locations WHERE name = 'City Park') AND year = 2021;", "generated_sql": "SELECT SUM(events) FROM community_policing WHERE name = 'City Park' AND year = 2021;", "raw_model_output": "Explanation:\nThis query calculates the total number of community policing events in 'City Park' for the year 2021. It does this by joining the locations and community_policing tables on their respective location_id columns, filtering for rows where the name column equals 'City Park' and the year column is equal to 2021. The COUNT function then sums up the number of events in these filtered rows.\n\nSQL:\nSELECT SUM(events) FROM community_policing WHERE name = 'City Park' AND year = 2021;", "latency_sec": 1.9355709552764893, "total_duration_sec": 1.740055521, "load_duration_sec": 0.010284542, "tokens_prompt": 169, "prompt_eval_sec": 0.005715617, "tokens_completion": 108, "completion_eval_sec": 1.723674495, "tokens_total": 277, "tokens_per_sec": 143.11022762812203, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Generated SQL references a 'name' column in the community_policing table, which does not exist. The Reference SQL correctly joins with the locations table to filter by location name. The Generated SQL would result in an error, while the Reference SQL returns the correct sum of events."}
{"example_id": 4932, "sql_complexity": "basic SQL", "prompt": "Delete the workout row with the id of 2.", "context": "CREATE TABLE Workouts (id INT, user_id INT, workout_name TEXT, calories INT); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (1, 1, 'Running', 300); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (2, 1, 'Cycling', 400); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (3, 2, 'Yoga', 200);", "reference_sql": "DELETE FROM Workouts WHERE id = 2;", "generated_sql": "DELETE query to remove the specified workout row from the Workouts table. The WHERE clause filters rows based on the id column, ensuring only the desired workout is deleted.\n\nSQL:\nDELETE FROM Workouts WHERE id = 2;", "raw_model_output": "Explanation:\nThe SQL statement uses a DELETE query to remove the specified workout row from the Workouts table. The WHERE clause filters rows based on the id column, ensuring only the desired workout is deleted.\n\nSQL:\nDELETE FROM Workouts WHERE id = 2;", "latency_sec": 1.0421850681304932, "total_duration_sec": 0.874193893, "load_duration_sec": 0.016893398, "tokens_prompt": 188, "prompt_eval_sec": 0.005899432, "tokens_completion": 53, "completion_eval_sec": 0.850973974, "tokens_total": 241, "tokens_per_sec": 231.24491740446248, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries are identical DELETE statements targeting the Workouts table with the same WHERE clause (id = 2). They will produce the same result by removing the row with id 2 from the table."}
{"example_id": 4637, "sql_complexity": "single join", "prompt": "What is the total value of transactions for each customer in the last 30 days?", "context": "CREATE TABLE transactions (id INT, customer_id INT, value DECIMAL(10, 2), transaction_date DATE); INSERT INTO transactions (id, customer_id, value, transaction_date) VALUES (1, 1, 100, '2022-01-01'), (2, 1, 200, '2022-01-15'), (3, 2, 50, '2022-01-05'), (4, 2, 150, '2022-01-30'), (5, 3, 300, '2022-01-20');", "reference_sql": "SELECT c.id, SUM(t.value) FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE t.transaction_date >= CURDATE() - INTERVAL 30 DAY GROUP BY c.id;", "generated_sql": "SELECT customer_id, SUM(value) FROM transactions WHERE transaction_date >= DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY) GROUP BY customer_id;", "raw_model_output": "Explanation:\nThis query calculates the total value of transactions for each customer in the last 30 days by using a subquery to filter transactions based on their transaction date, and then grouping the results by customer_id.\n\nSQL:\nSELECT customer_id, SUM(value) FROM transactions WHERE transaction_date >= DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY) GROUP BY customer_id;", "latency_sec": 1.4934887886047363, "total_duration_sec": 1.212712452, "load_duration_sec": 0.01793826, "tokens_prompt": 213, "prompt_eval_sec": 0.007094739, "tokens_completion": 74, "completion_eval_sec": 1.187207925, "tokens_total": 287, "tokens_per_sec": 192.16749545748135, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of transaction values for customers with transactions in the last 30 days. The Reference SQL joins customers and transactions but ultimately groups by customer_id (same as c.id), while the Generated SQL directly groups by customer_id from transactions. The date conditions (CURDATE() - INTERVAL 30 DAY vs DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY)) are equivalent. Since the INNER JOIN in the Reference SQL ensures only customers with transactions are included, and the Generated SQL directly filters transactions, the result sets are identical."}
{"example_id": 3704, "sql_complexity": "aggregation", "prompt": "What is the total sales revenue for each category of garments in the South America region in Q1 2022?", "context": "CREATE TABLE sales_category (sale_id INT, garment_category VARCHAR(50), sale_date DATE, total_sales DECIMAL(10, 2), region VARCHAR(50));", "reference_sql": "SELECT garment_category, SUM(total_sales) FROM sales_category WHERE sale_date BETWEEN '2022-01-01' AND '2022-03-31' AND region = 'South America' GROUP BY garment_category;", "generated_sql": "selects the sale_id, garment_category, and total_sales from the subquery.\n\nSQL:\nSELECT sale_id, garment_category, total_sales FROM (SELECT sale_id, garment_category, total_sales FROM sales_category WHERE region = 'South America' AND sale_date BETWEEN '2022-01-01' AND '2022-03-31') AS subquery;", "raw_model_output": "Explanation:\nThis query uses a subquery to calculate the total sales revenue for each garment category in the South America region. The outer query then selects the sale_id, garment_category, and total_sales from the subquery.\n\nSQL:\nSELECT sale_id, garment_category, total_sales FROM (SELECT sale_id, garment_category, total_sales FROM sales_category WHERE region = 'South America' AND sale_date BETWEEN '2022-01-01' AND '2022-03-31') AS subquery;", "latency_sec": 1.8645062446594238, "total_duration_sec": 1.658485591, "load_duration_sec": 0.028613394, "tokens_prompt": 129, "prompt_eval_sec": 0.006846013, "tokens_completion": 102, "completion_eval_sec": 1.622135754, "tokens_total": 231, "tokens_per_sec": 123.89339036093985, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query aggregates total_sales by garment_category using SUM and GROUP BY, while the generated query retrieves individual sales records without aggregation. The selected columns and output structure differ fundamentally."}
{"example_id": 382, "sql_complexity": "window functions", "prompt": "What is the average annual precipitation in the past 10 years for each weather station?", "context": "CREATE TABLE WeatherStation (ID INT, Name VARCHAR(100), Location VARCHAR(100), Elevation FLOAT, AnnualPrecipitation FLOAT); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (1, 'Station A', 'Arctic Circle', 100, 450); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (2, 'Station B', 'North Pole', 200, 300);", "reference_sql": "SELECT Name, AVG(AnnualPrecipitation) OVER (PARTITION BY Name ORDER BY Name ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS AvgAnnualPrecipitation FROM WeatherStation WHERE YEAR(CurrentDate) - YEAR(DateInstalled) BETWEEN 1 AND 10;", "generated_sql": "selects the ID and AnnualPrecipitation columns from the WeatherStation table, where the year is within the last 10 years (i.e., between 2013 and 2022). The query then groups the results by the ID column of the WeatherStation table.\n\nSQL:\nSELECT WS.ID, AVG(WP.AnnualPrecipitation) FROM WeatherStation WS JOIN (SELECT ID, AnnualPrecipitation FROM WeatherStation WHERE YEAR = YEAR(CURRENT_DATE) - 10 OR YEAR = YEAR(CURRENT_DATE)) WP ON WS.ID = WP.ID GROUP BY WS.ID;", "raw_model_output": "Explanation:\nThis query calculates the average annual precipitation in the past 10 years for each weather station. It does this by joining the WeatherStation table with a subquery that selects the ID and AnnualPrecipitation columns from the WeatherStation table, where the year is within the last 10 years (i.e., between 2013 and 2022). The query then groups the results by the ID column of the WeatherStation table.\n\nSQL:\nSELECT WS.ID, AVG(WP.AnnualPrecipitation) FROM WeatherStation WS JOIN (SELECT ID, AnnualPrecipitation FROM WeatherStation WHERE YEAR = YEAR(CURRENT_DATE) - 10 OR YEAR = YEAR(CURRENT_DATE)) WP ON WS.ID = WP.ID GROUP BY WS.ID;", "latency_sec": 2.7110509872436523, "total_duration_sec": 2.456798457, "load_duration_sec": 0.014537371, "tokens_prompt": 192, "prompt_eval_sec": 0.006974189, "tokens_completion": 152, "completion_eval_sec": 2.434696319, "tokens_total": 344, "tokens_per_sec": 126.88805987737899, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL references non-existent columns (DateInstalled, CurrentDate) and uses a window function, while the Generated SQL references a non-existent YEAR column and uses a JOIN with GROUP BY. Both queries have invalid column references based on the provided schema, but their structures and intended operations differ significantly."}
{"example_id": 5168, "sql_complexity": "aggregation", "prompt": "Get the number of renewable energy projects in Australia for each project type.", "context": "CREATE TABLE renewable_projects (id INT PRIMARY KEY, project_name VARCHAR(255), project_location VARCHAR(255), project_type VARCHAR(255), capacity_mw FLOAT);", "reference_sql": "SELECT project_type, COUNT(*) FROM renewable_projects WHERE project_location = 'Australia' GROUP BY project_type;", "generated_sql": "SELECT query to retrieve data from the renewable_projects table. The WHERE clause filters records based on the project_location and project_type columns, while the GROUP BY clause groups results by project_type. Finally, the COUNT function counts the number of projects for each group.\n\nSQL:\nSELECT project_type, COUNT(*) FROM renewable_projects WHERE project_location = 'Australia' GROUP BY project_type;", "raw_model_output": "Explanation:\nThis SQL statement uses a SELECT query to retrieve data from the renewable_projects table. The WHERE clause filters records based on the project_location and project_type columns, while the GROUP BY clause groups results by project_type. Finally, the COUNT function counts the number of projects for each group.\n\nSQL:\nSELECT project_type, COUNT(*) FROM renewable_projects WHERE project_location = 'Australia' GROUP BY project_type;", "latency_sec": 1.6357100009918213, "total_duration_sec": 1.328892579, "load_duration_sec": 0.018038544, "tokens_prompt": 119, "prompt_eval_sec": 0.003677304, "tokens_completion": 82, "completion_eval_sec": 1.306565945, "tokens_total": 201, "tokens_per_sec": 122.88241795802594, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They select project_type and count projects from renewable_projects where project_location is 'Australia', grouping results by project_type. The generated SQL matches the reference exactly."}
{"example_id": 4669, "sql_complexity": "set operations", "prompt": "Identify the number of IoT devices in each country and the total number of devices.", "context": "CREATE TABLE device_country (device_id INT, country TEXT); INSERT INTO device_country (device_id, country) VALUES (1, 'USA'), (2, 'Canada'), (3, 'Mexico'), (4, 'Brazil'); CREATE TABLE device_info (device_id INT, device_type TEXT); INSERT INTO device_info (device_id, device_type) VALUES (1, 'Soil Sensor'), (2, 'Temperature Sensor'), (3, 'Humidity Sensor'), (4, 'Precision Sprayer');", "reference_sql": "SELECT country, COUNT(*) AS device_count FROM device_country GROUP BY country UNION SELECT 'Total' AS country, COUNT(*) FROM device_country;", "generated_sql": "SELECT country, COUNT(device_id) as num_devices FROM device_country GROUP BY country;", "raw_model_output": "Explanation:\nThis query uses a combination of GROUP BY and COUNT to identify the number of IoT devices in each country. It also calculates the total number of devices by using the SUM function on the device_id column.\n\nSQL:\nSELECT country, COUNT(device_id) as num_devices FROM device_country GROUP BY country;", "latency_sec": 1.2173991203308105, "total_duration_sec": 1.019898135, "load_duration_sec": 0.014938106, "tokens_prompt": 192, "prompt_eval_sec": 0.007267353, "tokens_completion": 62, "completion_eval_sec": 0.996749054, "tokens_total": 254, "tokens_per_sec": 208.64151760761843, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a 'Total' row in its result set via the UNION, while the Generated SQL only returns grouped country counts without a total. This makes their result sets structurally different."}
{"example_id": 4573, "sql_complexity": "subqueries", "prompt": "Find the names of all the indigenous communities in the 'Arctic_Communities' table that have a population size greater than the average population size in the 'Antarctic_Communities' table.", "context": "CREATE TABLE Arctic_Communities (name TEXT, population INTEGER); CREATE TABLE Antarctic_Communities (name TEXT, population INTEGER);", "reference_sql": "SELECT name FROM Arctic_Communities WHERE Arctic_Communities.population > (SELECT AVG(population) FROM Antarctic_Communities)", "generated_sql": "selects the names of the Arctic communities with a population greater than this average, filtering out non-indigenous communities.\n\nSQL:\nSELECT name FROM Arctic_Communities WHERE population > (SELECT AVG(population) FROM Antarctic_Communities);", "raw_model_output": "Explanation:\nThis query first calculates the average population size for the Antarctic communities. It then selects the names of the Arctic communities with a population greater than this average, filtering out non-indigenous communities.\n\nSQL:\nSELECT name FROM Arctic_Communities WHERE population > (SELECT AVG(population) FROM Antarctic_Communities);", "latency_sec": 1.117380142211914, "total_duration_sec": 1.012009272, "load_duration_sec": 0.015573769, "tokens_prompt": 135, "prompt_eval_sec": 0.005460562, "tokens_completion": 62, "completion_eval_sec": 0.990410804, "tokens_total": 197, "tokens_per_sec": 176.3052631399265, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "The Reference SQL and Generated SQL have identical structure and logic. Both select names from Arctic_Communities where population exceeds the average population of Antarctic_Communities. The descriptive text for Generated SQL mentions 'filtering out non-indigenous communities,' but this is not present in the actual SQL code. Since the SQL statements are identical, they are semantically equivalent."}
{"example_id": 3008, "sql_complexity": "multiple_joins", "prompt": "Who are the users who used electric vehicles and their trip details?", "context": "CREATE TABLE users (id INT, name VARCHAR(50), age INT, gender VARCHAR(10), city VARCHAR(50));CREATE TABLE vehicles (id INT, vehicle_type VARCHAR(20), is_electric BOOLEAN);CREATE TABLE trips (id INT, user_id INT, vehicle_id INT, trip_distance FLOAT, trip_duration INT, departure_time TIMESTAMP, arrival_time TIMESTAMP);INSERT INTO users (id, name, age, gender, city) VALUES (3, 'Alex', 30, 'Female', 'New York');INSERT INTO vehicles (id, vehicle_type, is_electric) VALUES (1, 'Tesla', true), (2, 'Bike', false);INSERT INTO trips (id, user_id, vehicle_id, trip_distance, trip_duration, departure_time, arrival_time) VALUES (3, 3, 1, 15.3, 25, '2022-01-03 12:00:00', '2022-01-03 12:25:00');", "reference_sql": "SELECT u.name, v.vehicle_type, t.trip_distance, t.trip_duration FROM users u JOIN trips t ON u.id = t.user_id JOIN vehicles v ON t.vehicle_id = v.id WHERE v.is_electric = true;", "generated_sql": "SELECT u.id, u.name, t.trip_distance, t.trip_duration, t.departure_time, t.arrival_time FROM users u JOIN trips t ON u.id = t.user_id JOIN vehicles v ON t.vehicle_id = v.id WHERE v.vehicle_type = 'Tesla';", "raw_model_output": "Explanation:\nThis query joins the users table with the trips table on the user_id column, then joins the trips table with the vehicles table on the vehicle_id column. It filters for rows where the vehicle_type is 'Tesla' (electric) and returns the id, name, trip_distance, trip_duration, departure_time, and arrival_time columns.\n\nSQL:\nSELECT u.id, u.name, t.trip_distance, t.trip_duration, t.departure_time, t.arrival_time FROM users u JOIN trips t ON u.id = t.user_id JOIN vehicles v ON t.vehicle_id = v.id WHERE v.vehicle_type = 'Tesla';", "latency_sec": 2.3787169456481934, "total_duration_sec": 2.075664227, "load_duration_sec": 0.014398875, "tokens_prompt": 291, "prompt_eval_sec": 0.007974625, "tokens_completion": 127, "completion_eval_sec": 2.052908903, "tokens_total": 418, "tokens_per_sec": 175.7249851709852, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL filters for electric vehicles (v.is_electric = true), while the Generated SQL filters specifically for Tesla vehicles (v.vehicle_type = 'Tesla'). Additionally, the selected columns differ: the Reference includes vehicle_type, while the Generated includes id, departure_time, and arrival_time. These differences in WHERE conditions and column selection result in distinct outputs."}
{"example_id": 1506, "sql_complexity": "basic SQL", "prompt": "How many habitats are in the 'animal_habitats' table?", "context": "CREATE TABLE animal_habitats (id INT PRIMARY KEY, habitat_name VARCHAR, num_animals INT);", "reference_sql": "SELECT COUNT(*) FROM animal_habitats;", "generated_sql": "SELECT COUNT(*) FROM animal_habitats;", "raw_model_output": "Explanation:\nThe SQL statement uses a COUNT function to count the number of rows in the 'animal_habitats' table.\n\nSQL:\nSELECT COUNT(*) FROM animal_habitats;", "latency_sec": 0.7655839920043945, "total_duration_sec": 0.608142511, "load_duration_sec": 0.01694516, "tokens_prompt": 107, "prompt_eval_sec": 0.003980971, "tokens_completion": 37, "completion_eval_sec": 0.586487115, "tokens_total": 144, "tokens_per_sec": 188.09170712019463, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and purpose. They both count all rows in the 'animal_habitats' table using the same syntax, so they will produce the same result."}
{"example_id": 4138, "sql_complexity": "window functions", "prompt": "How many lifelong learning courses has a student with ID '2' completed, in chronological order?", "context": "CREATE TABLE lifelong_learning (student_id INT, course_id INT, completion_date DATE); INSERT INTO lifelong_learning VALUES (2, 1001, '2015-01-01'), (2, 1002, '2016-01-01');", "reference_sql": "SELECT student_id, course_id, COUNT(course_id) OVER (PARTITION BY student_id ORDER BY completion_date) as completed_courses FROM lifelong_learning WHERE student_id = 2;", "generated_sql": "selects the count of rows from the lifelong_learning table where the student_id is equal to '2', ordered by completion_date.\n\nSQL:\nSELECT COUNT(*) FROM lifelong_learning WHERE student_id = 2 ORDER BY completion_date;", "raw_model_output": "Explanation:\nThis query selects the count of rows from the lifelong_learning table where the student_id is equal to '2', ordered by completion_date.\n\nSQL:\nSELECT COUNT(*) FROM lifelong_learning WHERE student_id = 2 ORDER BY completion_date;", "latency_sec": 1.1283199787139893, "total_duration_sec": 0.803234464, "load_duration_sec": 0.015205, "tokens_prompt": 143, "prompt_eval_sec": 0.005481541, "tokens_completion": 49, "completion_eval_sec": 0.78212199, "tokens_total": 192, "tokens_per_sec": 170.16449555278936, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns multiple rows with a cumulative count per course completion date for student_id=2, while the Generated SQL returns a single row with the total count of rows for student_id=2. The output structure and purpose differ: the first uses a window function to track progression over time, while the second simply counts total records."}
{"example_id": 5499, "sql_complexity": "set operations", "prompt": "How many legal aid clinics and community mediation centers are there in total, and what is the sum of cases handled by each type of center, for centers located in the state of California?", "context": "CREATE TABLE LegalAidClinics (ClinicName text, State text, NumCases int); INSERT INTO LegalAidClinics VALUES ('Clinic1', 'CA', 30, '2022-01-01'), ('Clinic2', 'CA', 25, '2022-01-01'); CREATE TABLE CommunityMediationCenters (CenterName text, State text, NumCases int); INSERT INTO CommunityMediationCenters VALUES ('CM1', 'CA', 22, '2022-01-01'), ('CM2', 'CA', 28, '2022-01-01');", "reference_sql": "SELECT State, 'Legal Aid Clinics' AS CenterType, COUNT(*) AS NumCenters, SUM(NumCases) AS TotalCases FROM LegalAidClinics WHERE State = 'CA' UNION ALL SELECT State, 'Community Mediation Centers', COUNT(*), SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA';", "generated_sql": "SELECT SUM(CASE WHEN CenterType = 'Legal Aid Clinic' THEN NumCases ELSE 0 END) AS LegalAidClinicCases, SUM(CASE WHEN CenterType = 'Community Mediation Center' THEN NumCases ELSE 0 END) AS CommunityMediationCenterCases FROM (SELECT * FROM LegalAidClinics UNION ALL SELECT * FROM CommunityMediationCenters) AS Centers WHERE State = 'CA';", "raw_model_output": "Explanation:\nThis query calculates the total number of legal aid clinics and community mediation centers in California, as well as the sum of cases handled by each type of center. It uses a combination of SUM() and COUNT() functions to achieve this.\n\nSQL:\nSELECT SUM(CASE WHEN CenterType = 'Legal Aid Clinic' THEN NumCases ELSE 0 END) AS LegalAidClinicCases, SUM(CASE WHEN CenterType = 'Community Mediation Center' THEN NumCases ELSE 0 END) AS CommunityMediationCenterCases FROM (SELECT * FROM LegalAidClinics UNION ALL SELECT * FROM CommunityMediationCenters) AS Centers WHERE State = 'CA';", "latency_sec": 2.4172122478485107, "total_duration_sec": 2.215078698, "load_duration_sec": 0.021147647, "tokens_prompt": 238, "prompt_eval_sec": 0.006113397, "tokens_completion": 136, "completion_eval_sec": 2.187082329, "tokens_total": 374, "tokens_per_sec": 154.72369062041878, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL returns two rows (one for each center type) with columns State, CenterType, NumCenters, and TotalCases. The Generated SQL attempts to aggregate cases by CenterType but lacks a CenterType column in its subquery (due to UNION ALL of tables without such a column), making it invalid. Additionally, the Generated SQL returns a single row with summed values, while the Reference SQL returns multiple rows. The structural and logical differences prevent equivalence."}
{"example_id": 2265, "sql_complexity": "aggregation", "prompt": "Hourly revenue for a specific movie?", "context": "CREATE TABLE Movie_Revenue (id INT, movie_title VARCHAR(100), revenue_time TIME, revenue DECIMAL(10,2));", "reference_sql": "SELECT revenue_time, SUM(revenue) FROM Movie_Revenue WHERE movie_title = 'Spider-Man: No Way Home' GROUP BY revenue_time;", "generated_sql": "SELECT AVG(revenue) FROM Movie_Revenue WHERE movie_title = 'Movie Title';", "raw_model_output": "Explanation:\nThe query calculates the hourly revenue for a specific movie by filtering the Movie_Revenue table based on the movie title and then grouping the results by hour. The AVG function is used to calculate the average revenue per hour.\n\nSQL:\nSELECT AVG(revenue) FROM Movie_Revenue WHERE movie_title = 'Movie Title';", "latency_sec": 1.106041669845581, "total_duration_sec": 1.049984593, "load_duration_sec": 0.015526535, "tokens_prompt": 107, "prompt_eval_sec": 0.007275279, "tokens_completion": 65, "completion_eval_sec": 1.026648784, "tokens_total": 172, "tokens_per_sec": 155.50951170222513, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query calculates SUM(revenue) grouped by revenue_time for a specific movie, while the generated query calculates AVG(revenue) for a different movie. Differences include aggregate functions (SUM vs AVG), grouping (revenue_time vs no group), and WHERE conditions (different movie titles)."}
{"example_id": 5792, "sql_complexity": "multiple_joins", "prompt": "How many cases were handled by attorneys in the 'Los Angeles' office?", "context": "CREATE TABLE offices (office_id INT, office_name VARCHAR(20), city VARCHAR(20), state VARCHAR(20)); INSERT INTO offices (office_id, office_name, city, state) VALUES (1, 'Boston', 'Boston', 'MA'), (2, 'New York', 'New York', 'NY'), (3, 'Los Angeles', 'Los Angeles', 'CA'); CREATE TABLE attorneys (attorney_id INT, office_id INT); INSERT INTO attorneys (attorney_id, office_id) VALUES (1, 1), (2, 2), (3, 3); CREATE TABLE cases (case_id INT, attorney_id INT); INSERT INTO cases (case_id, attorney_id) VALUES (1, 1), (2, 2), (3, 3);", "reference_sql": "SELECT COUNT(*) FROM cases JOIN attorneys ON cases.attorney_id = attorneys.attorney_id JOIN offices ON attorneys.office_id = offices.office_id WHERE offices.city = 'Los Angeles';", "generated_sql": "SELECT COUNT(*) FROM offices JOIN attorneys ON offices.office_id = attorneys.office_id WHERE city = 'Los Angeles';", "raw_model_output": "Explanation:\nThis query joins the offices and attorneys tables to find the number of cases handled by attorneys in the Los Angeles office. It then filters for rows where the city is 'Los Angeles', calculates the count of case_id values, and returns this count.\n\nSQL:\nSELECT COUNT(*) FROM offices JOIN attorneys ON offices.office_id = attorneys.office_id WHERE city = 'Los Angeles';", "latency_sec": 1.334986925125122, "total_duration_sec": 1.249473928, "load_duration_sec": 0.01507927, "tokens_prompt": 250, "prompt_eval_sec": 0.006079431, "tokens_completion": 76, "completion_eval_sec": 1.227922398, "tokens_total": 326, "tokens_per_sec": 244.19714820011856, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL counts cases linked to attorneys in Los Angeles offices, while the Generated SQL counts attorneys in Los Angeles offices. Although both may return 1 in the given dataset (due to 1:1 attorney-case relationships), they are not semantically equivalent because they count different entities (cases vs. attorneys) and the Generated SQL omits the cases table entirely."}
{"example_id": 2513, "sql_complexity": "single join", "prompt": "What is the total number of concert ticket sales for artists who released their first album between 2015 and 2017?", "context": "CREATE TABLE ConcertTicketSales (id INT, year INT, artist_id INT); CREATE TABLE ArtistAlbums (id INT, artist_id INT, year INT);", "reference_sql": "SELECT COUNT(DISTINCT cts.artist_id) FROM ConcertTicketSales cts JOIN ArtistAlbums a ON cts.artist_id = a.artist_id WHERE a.year BETWEEN 2015 AND 2017;", "generated_sql": "SELECT COUNT(*) FROM ConcertTicketSales c JOIN ArtistAlbums a ON c.artist_id = a.artist_id WHERE a.year BETWEEN 2015 AND 2017;", "raw_model_output": "Explanation:\nThis query calculates the total number of concert ticket sales for artists who released their first album between 2015 and 2017. It does this by joining the ConcertTicketSales table with the ArtistAlbums table on artist_id, then filtering rows where year is greater than or equal to 2015 and less than or equal to 2017.\n\nSQL:\nSELECT COUNT(*) FROM ConcertTicketSales c JOIN ArtistAlbums a ON c.artist_id = a.artist_id WHERE a.year BETWEEN 2015 AND 2017;", "latency_sec": 1.9860498905181885, "total_duration_sec": 1.751985195, "load_duration_sec": 0.014813023, "tokens_prompt": 129, "prompt_eval_sec": 0.005255038, "tokens_completion": 108, "completion_eval_sec": 1.73121644, "tokens_total": 237, "tokens_per_sec": 119.33234967131835, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query counts distinct artist_ids, while the generated query counts all rows. If multiple ConcertTicketSales entries exist for the same artist_id with matching ArtistAlbums records, the generated query would return a higher count. For example, an artist with 3 sales records would contribute 1 to the reference query but 3 to the generated query."}
{"example_id": 3546, "sql_complexity": "window functions", "prompt": "What are the cryptocurrency exchanges with their corresponding blockchain companies, ranked by exchange ID in ascending order, for the Bitcoin platform?", "context": "CREATE TABLE cryptocurrency_exchanges (exchange_id INT, exchange_name VARCHAR(50), company_id INT); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (1, 'Binance', 1); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (2, 'Coinbase', 2); INSERT INTO cryptocurrency_exchanges (exchange_id, exchange_name, company_id) VALUES (3, 'Kraken', 3); CREATE TABLE blockchain_companies (company_id INT, company_name VARCHAR(50), platform VARCHAR(50)); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (1, 'Binance', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (2, 'Blockstream', 'Bitcoin'); INSERT INTO blockchain_companies (company_id, company_name, platform) VALUES (3, 'Blockchair', 'Bitcoin');", "reference_sql": "SELECT ce.exchange_name, bc.company_name, ce.exchange_id, ROW_NUMBER() OVER (PARTITION BY bc.platform ORDER BY ce.exchange_id ASC) as rank FROM cryptocurrency_exchanges ce JOIN blockchain_companies bc ON ce.company_id = bc.company_id WHERE bc.platform = 'Bitcoin';", "generated_sql": "SELECT c.exchange_name, b.company_name FROM cryptocurrency_exchanges c JOIN blockchain_companies b ON c.company_id = b.company_id WHERE b.platform = 'Bitcoin' ORDER BY c.exchange_id ASC;", "raw_model_output": "Explanation:\nThis query joins the cryptocurrency_exchanges table with the blockchain_companies table on the company_id column. It then filters the results to only include records where the platform is 'Bitcoin'. Finally, it orders the results by exchange_id in ascending order.\n\nSQL:\nSELECT c.exchange_name, b.company_name FROM cryptocurrency_exchanges c JOIN blockchain_companies b ON c.company_id = b.company_id WHERE b.platform = 'Bitcoin' ORDER BY c.exchange_id ASC;", "latency_sec": 1.596031904220581, "total_duration_sec": 1.549126898, "load_duration_sec": 0.015018631, "tokens_prompt": 290, "prompt_eval_sec": 0.008216639, "tokens_completion": 94, "completion_eval_sec": 1.525188442, "tokens_total": 384, "tokens_per_sec": 240.5966942042588, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL includes an additional 'exchange_id' column and a 'rank' column generated by ROW_NUMBER(), while the Generated SQL omits these. Additionally, the Generated SQL explicitly sorts results with ORDER BY, whereas the Reference SQL's ordering is embedded within the window function. The result sets differ in both structure and content."}
{"example_id": 1515, "sql_complexity": "multiple_joins", "prompt": "What is the average age of clients who lost cases in the 'personal injury' category?", "context": "CREATE TABLE Cases (CaseID int, ClientID int, Category varchar(50)); INSERT INTO Cases (CaseID, ClientID, Category) VALUES (701, 7, 'Personal Injury'); CREATE TABLE Clients (ClientID int, Age int, Gender varchar(10)); INSERT INTO Clients (ClientID, Age, Gender) VALUES (7, 45, 'Male'); CREATE TABLE CaseOutcomes (CaseID int, Outcome varchar(50)); INSERT INTO CaseOutcomes (CaseID, Outcome) VALUES (701, 'Lost');", "reference_sql": "SELECT AVG(C.Age) as AvgAge FROM Clients C INNER JOIN Cases CA ON C.ClientID = CA.ClientID INNER JOIN CaseOutcomes CO ON CA.CaseID = CO.CaseID WHERE CA.Category = 'Personal Injury' AND CO.Outcome = 'Lost';", "generated_sql": "SELECT AVG(Clients.Age) FROM Cases JOIN Clients ON Cases.ClientID = Clients.ClientID WHERE Cases.Category = 'Personal Injury' AND CaseOutcomes.Outcome = 'Lost';", "raw_model_output": "Explanation:\nThis query calculates the average age of clients who lost cases in the 'Personal Injury' category. It does this by joining the Cases and Clients tables on ClientID, filtering for rows where CaseOutcome is 'Lost' and Category is 'Personal Injury', and then averaging the Age column.\n\nSQL:\nSELECT AVG(Clients.Age) FROM Cases JOIN Clients ON Cases.ClientID = Clients.ClientID WHERE Cases.Category = 'Personal Injury' AND CaseOutcomes.Outcome = 'Lost';", "latency_sec": 1.7566618919372559, "total_duration_sec": 1.589098359, "load_duration_sec": 0.009420387, "tokens_prompt": 200, "prompt_eval_sec": 0.006423893, "tokens_completion": 98, "completion_eval_sec": 1.572673861, "tokens_total": 298, "tokens_per_sec": 169.63992978259697, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL joins all three tables (Clients, Cases, CaseOutcomes) and filters on both Category and Outcome. The Generated SQL missing the join with CaseOutcomes table, which is required to access the Outcome column. This makes the Generated SQL invalid and semantically different from the Reference SQL."}
{"example_id": 3925, "sql_complexity": "set operations", "prompt": "What is the total number of students and staff with accommodations in the \"disability_services\" schema, excluding the \"accessibility_parking\" type?", "context": "CREATE SCHEMA disability_services; CREATE TABLE staff (id INT, name VARCHAR(50), accommodation VARCHAR(50)); CREATE TABLE students (id INT, name VARCHAR(50), accommodation VARCHAR(50));", "reference_sql": "SELECT COUNT(*) FROM disability_services.staff WHERE accommodation != 'accessibility_parking' UNION SELECT COUNT(*) FROM disability_services.students WHERE accommodation != 'accessibility_parking';", "generated_sql": "SELECT COUNT(*) FROM disability_services.students UNION SELECT COUNT(*) FROM disability_services.staff WHERE accommodation != 'accessibility_parking';", "raw_model_output": "Explanation:\nThis query calculates the total number of students and staff with accommodations in the \"disability_services\" schema. It excludes rows where the accommodation is \"accessibility_parking\". The result is a single row containing the total count.\n\nSQL:\nSELECT COUNT(*) FROM disability_services.students UNION SELECT COUNT(*) FROM disability_services.staff WHERE accommodation != 'accessibility_parking';", "latency_sec": 1.2135040760040283, "total_duration_sec": 1.194582084, "load_duration_sec": 0.016977383, "tokens_prompt": 142, "prompt_eval_sec": 0.005249017, "tokens_completion": 74, "completion_eval_sec": 1.171802149, "tokens_total": 216, "tokens_per_sec": 177.99692994132388, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL applies the 'accommodation != 'accessibility_parking'' filter to both staff and students, while the Generated SQL only applies this filter to staff and counts all students without filtering. This results in different counts for the student portion of the result."}
{"example_id": 335, "sql_complexity": "single join", "prompt": "List the policy numbers, claim amounts, and claim dates for policies that have more than two claims and the total claim amount exceeds $5000", "context": "CREATE TABLE policies (policy_number INT);CREATE TABLE claims (claim_id INT, policy_number INT, claim_amount DECIMAL(10,2), claim_date DATE);", "reference_sql": "SELECT p.policy_number, c.claim_amount, c.claim_date FROM policies p INNER JOIN claims c ON p.policy_number = c.policy_number GROUP BY p.policy_number, c.claim_amount, c.claim_date HAVING COUNT(c.claim_id) > 2 AND SUM(c.claim_amount) > 5000;", "generated_sql": "SELECT p.policy_number, c.claim_amount, c.claim_date FROM policies p JOIN (SELECT policy_number, SUM(claim_amount) as total_claim_amount FROM claims GROUP BY policy_number HAVING COUNT(*) > 2 AND total_claim_amount > 5000) c ON p.policy_number = c.policy_number;", "raw_model_output": "Explanation:\nThis query uses a subquery to find the policy numbers with more than two claims. It then joins this result with the claims table on the policy_number column. The WHERE clause filters out policies with 2 or fewer claims, and the HAVING clause filters out policies with total claim amounts less than $5000.\n\nSQL:\nSELECT p.policy_number, c.claim_amount, c.claim_date FROM policies p JOIN (SELECT policy_number, SUM(claim_amount) as total_claim_amount FROM claims GROUP BY policy_number HAVING COUNT(*) > 2 AND total_claim_amount > 5000) c ON p.policy_number = c.policy_number;", "latency_sec": 2.1399879455566406, "total_duration_sec": 2.122887596, "load_duration_sec": 0.014593102, "tokens_prompt": 134, "prompt_eval_sec": 0.005147393, "tokens_completion": 132, "completion_eval_sec": 2.102594481, "tokens_total": 266, "tokens_per_sec": 124.29976559088033, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The reference query groups by policy_number, claim_amount, and claim_date, requiring each group (same policy, amount, and date) to have >2 claims and sum >5000. The generated query instead groups by policy_number only, checking total claims count and sum for the entire policy, but references non-existent columns (claim_amount, claim_date) from the subquery. Additionally, the generated query's subquery lacks these columns, making it invalid."}
