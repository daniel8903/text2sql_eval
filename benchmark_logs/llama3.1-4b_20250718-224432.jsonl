{"example_id": 904, "sql_complexity": "basic SQL", "prompt": "What is the minimum Shariah-compliant loan amount issued in the last quarter of 2021?", "context": "CREATE TABLE loans (id INT, amount DECIMAL, date DATE, loan_type VARCHAR); INSERT INTO loans (id, amount, date, loan_type) VALUES (1, 5000, '2021-09-05', 'Shariah-compliant'), (2, 7000, '2021-10-07', 'socially responsible'), (3, 9000, '2021-11-03', 'Shariah-compliant'), (4, 11000, '2021-12-31', 'Shariah-compliant');", "reference_sql": "SELECT MIN(amount) FROM loans WHERE EXTRACT(YEAR FROM date) = 2021 AND EXTRACT(QUARTER FROM date) = 4 AND loan_type = 'Shariah-compliant';", "generated_sql": "SELECT MIN(amount) \nFROM loans \nWHERE EXTRACT(MONTH FROM date) = 10 AND loan_type = 'Shariah-compliant';", "raw_model_output": " Query\n```sql\nSELECT MIN(amount) \nFROM loans \nWHERE EXTRACT(MONTH FROM date) = 10 AND loan_type = 'Shariah-compliant';\n```\n\n### Explanation\n\nTo find the minimum Shariah-compliant loan amount issued in the last quarter of 2021, we need to filter the `loans` table for loans with a `date` that falls within the fourth quarter (October, November, or December) and a `loan_type` of 'Shariah-compliant'. We then select the minimum `amount` from these filtered rows.\n\nThe `EXTRACT(MONTH FROM date)` function extracts the month from the `date` column. By setting this to 10, we filter for loans issued in October (the last quarter). The `WHERE` clause also filters by `loan_type = 'Shariah-compliant'`.\n\nFinally, the `MIN(amount)` function returns the minimum amount among these filtered rows.\n\n### Example Use Case\n\nSuppose you are a financial analyst working with a bank that offers Shariah-compliant loans. You want to identify the smallest loan issued in the last quarter of 2021 to inform your marketing strategy and pricing decisions. This SQL query would help you achieve this goal by providing the minimum Shariah-compliant loan amount issued during that period.", "latency_sec": 6.123283863067627, "total_duration_sec": 5.828500291, "load_duration_sec": 1.416387552, "tokens_prompt": 150, "prompt_eval_sec": 0.101322333, "tokens_completion": 270, "completion_eval_sec": 4.308814804, "tokens_total": 420, "tokens_per_sec": 68.59064668440661, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query filters for loans in the 4th quarter (October-December) of 2021, while the generated query only checks for October (month=10). The sample data shows 'Shariah-compliant' loans in November and December (which would be included in the reference query but excluded by the generated query). Thus, the generated query is more restrictive and would return different results."}
{"example_id": 1373, "sql_complexity": "subqueries", "prompt": "What is the total value of military equipment sales to Africa in the last 12 months?", "context": "CREATE TABLE Military_Equipment_Sales(sale_id INT, sale_date DATE, equipment_type VARCHAR(50), country VARCHAR(50), sale_value DECIMAL(10,2));", "reference_sql": "SELECT SUM(sale_value) FROM Military_Equipment_Sales WHERE country IN (SELECT country FROM World_Countries WHERE continent = 'Africa') AND sale_date >= DATE_SUB(CURRENT_DATE, INTERVAL 12 MONTH);", "generated_sql": "SELECT SUM(CASE WHEN T1.country = 'Africa' THEN T1.sale_value END) AS total_value\nFROM Military_Equipment_Sales AS T1\nWHERE EXTRACT(YEAR FROM T1.sale_date) >= (SELECT YEAR FROM ADDDATE(CURRENT_DATE, INTERVAL -12 MONTH));", "raw_model_output": " Query\n\n```sql\nSELECT SUM(CASE WHEN T1.country = 'Africa' THEN T1.sale_value END) AS total_value\nFROM Military_Equipment_Sales AS T1\nWHERE EXTRACT(YEAR FROM T1.sale_date) >= (SELECT YEAR FROM ADDDATE(CURRENT_DATE, INTERVAL -12 MONTH));\n```\n\n### Explanation\n\nThis SQL query calculates the total value of military equipment sales to Africa in the last 12 months. Here's how it works:\n\n- The `SUM` function is used to calculate the total value.\n- A `CASE` statement within the `SUM` function checks if the country is 'Africa'. If true, it adds the sale value to the running total.\n- The subquery `(SELECT YEAR FROM ADDDATE(CURRENT_DATE, INTERVAL -12 MONTH))` calculates the current year minus 12 months. This ensures that we only consider sales from the last 12 months.\n- The `EXTRACT(YEAR FROM T1.sale_date)` function extracts the year from each sale date in the table.\n- The `WHERE` clause filters out any sales outside of the last 12 months by comparing the extracted year with the result from the subquery.\n\n### Example Use Case\n\nSuppose we have a table `Military_Equipment_Sales` containing the following data:\n\n| sale_id | sale_date       | equipment_type | country    | sale_value |\n|---------|-----------------|-----------------|------------|------------|\n| 1       | 2022-01-01      | Tank           | USA         | 100000.00  |\n| 2       | 2022-02-01      | Aircraft        | France      | 50000.00   |\n| 3       | 2022-03-01      | Artillery      | Africa      | 200000.00  |\n| 4       | 2021-12-01      | Submarine       | USA         | 150000.00  |\n\nRunning the SQL query would return:\n\n| total_value |\n|-------------|\n| 220000.00   |\n\nThis is because sales from Africa in the last 12 months (2022) amount to a total value of $220,000.00. The sale from France in January 2021 is excluded since it's outside the 12-month window.", "latency_sec": 7.743555068969727, "total_duration_sec": 7.60884758, "load_duration_sec": 0.023854163, "tokens_prompt": 66, "prompt_eval_sec": 0.016051831, "tokens_completion": 475, "completion_eval_sec": 7.568520344, "tokens_total": 541, "tokens_per_sec": 69.86455125345671, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query sums sales from all African countries (via a subquery on World_Countries) within the last 12 months. The generated query incorrectly checks if country = 'Africa' (literal string) instead of using the subquery, and its date condition uses year comparison (EXTRACT(YEAR)) which may include incomplete periods compared to the DATE_SUB approach. Both differences in country filtering and date logic lead to different results."}
{"example_id": 5039, "sql_complexity": "subqueries", "prompt": "What is the total number of community policing events in 'City Park' in 2021?", "context": "CREATE TABLE locations (id INT, name VARCHAR(255)); CREATE TABLE community_policing (id INT, location_id INT, year INT, events INT); INSERT INTO locations (id, name) VALUES (1, 'City Park'); INSERT INTO community_policing (id, location_id, year, events) VALUES (1, 1, 2021, 5);", "reference_sql": "SELECT SUM(events) FROM community_policing WHERE location_id = (SELECT id FROM locations WHERE name = 'City Park') AND year = 2021;", "generated_sql": "SELECT COUNT(*) \nFROM community_policing \nWHERE location_id = 1 AND year = 2021;", "raw_model_output": " Query\n```sql\nSELECT COUNT(*) \nFROM community_policing \nWHERE location_id = 1 AND year = 2021;\n```\n\n### Explanation\n\nThis query uses a simple `COUNT` function to count the number of rows that match the specified conditions. The `WHERE` clause filters out any rows where the `location_id` is not equal to 1 (i.e., 'City Park') or the `year` is not equal to 2021.\n\n### Example Use Case\n\nSuppose we want to analyze community policing data for different locations and years. We can use this query as a starting point and modify it to filter by additional conditions, such as location name or event type.\n\n```sql\nSELECT COUNT(*) \nFROM community_policing \nWHERE location_id = 1 AND year = 2021 AND events > 3;\n```\n\nThis modified query would only count the number of community policing events in 'City Park' that occurred in 2021 and had more than 3 events.", "latency_sec": 3.6455371379852295, "total_duration_sec": 3.316378093, "load_duration_sec": 0.01449637, "tokens_prompt": 109, "prompt_eval_sec": 0.005864891, "tokens_completion": 207, "completion_eval_sec": 3.295444012, "tokens_total": 316, "tokens_per_sec": 86.68132789195586, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query sums the 'events' column for a specific location and year, while the generated query counts the number of rows matching the same criteria. In the sample data, the reference would return 5 (sum of events) and the generated query would return 1 (count of rows), producing different results."}
{"example_id": 4932, "sql_complexity": "basic SQL", "prompt": "Delete the workout row with the id of 2.", "context": "CREATE TABLE Workouts (id INT, user_id INT, workout_name TEXT, calories INT); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (1, 1, 'Running', 300); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (2, 1, 'Cycling', 400); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (3, 2, 'Yoga', 200);", "reference_sql": "DELETE FROM Workouts WHERE id = 2;", "generated_sql": "DELETE FROM Workouts WHERE id = 2;", "raw_model_output": " Query\n```sql\nDELETE FROM Workouts WHERE id = 2;\n```\n\nThis will delete the row from the `Workouts` table where the `id` is equal to 2. Note that this query does not require a `WHERE` clause because we are specifying the exact value of the column (`id`) that we want to delete.\n\n### Explanation\nThe SQL `DELETE` statement is used to remove data from a database table. The syntax for deleting rows in a table is:\n```sql\nDELETE FROM table_name WHERE condition;\n```\nIn this case, we're using the `Workouts` table and specifying the `id` column as the condition to delete. Since we want to delete only one row with a specific `id`, we don't need to use a `WHERE` clause.\n\n### Example Use Case\nSuppose you have a user who wants to stop participating in cycling workouts, so you would run this query:\n```sql\nDELETE FROM Workouts WHERE id = 2;\n```\nThis will remove the row with `id` equal to 2 from the `Workouts` table. The resulting table would be:\n```markdown\n| id | user_id | workout_name | calories |\n|----|---------|--------------|----------|\n| 1  | 1       | Running      | 300       |\n| 3  | 2       | Yoga         | 200       |\n```\nNote that the row with `id` equal to 2 is no longer present in the table.", "latency_sec": 5.139934778213501, "total_duration_sec": 5.004662711, "load_duration_sec": 0.014328214, "tokens_prompt": 128, "prompt_eval_sec": 0.006834414, "tokens_completion": 311, "completion_eval_sec": 4.982952287, "tokens_total": 439, "tokens_per_sec": 85.4096440796831, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They both delete the record with id = 2 from the Workouts table, resulting in the same database state change."}
{"example_id": 4637, "sql_complexity": "single join", "prompt": "What is the total value of transactions for each customer in the last 30 days?", "context": "CREATE TABLE transactions (id INT, customer_id INT, value DECIMAL(10, 2), transaction_date DATE); INSERT INTO transactions (id, customer_id, value, transaction_date) VALUES (1, 1, 100, '2022-01-01'), (2, 1, 200, '2022-01-15'), (3, 2, 50, '2022-01-05'), (4, 2, 150, '2022-01-30'), (5, 3, 300, '2022-01-20');", "reference_sql": "SELECT c.id, SUM(t.value) FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE t.transaction_date >= CURDATE() - INTERVAL 30 DAY GROUP BY c.id;", "generated_sql": "SELECT \n    customer_id,\n    SUM(value) AS total_value\nFROM \n    transactions\nWHERE \n    transaction_date >= DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY)\nGROUP BY \n    customer_id;", "raw_model_output": " Query\n```sql\nSELECT \n    customer_id,\n    SUM(value) AS total_value\nFROM \n    transactions\nWHERE \n    transaction_date >= DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY)\nGROUP BY \n    customer_id;\n```\n\n### Explanation\n\nThis query calculates the total value of transactions for each customer in the last 30 days. Here's how it works:\n\n1. `DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY)` subtracts 30 days from the current date, giving us a date that is 30 days ago.\n2. The `WHERE` clause filters out any transactions older than 30 days by selecting only those with a transaction date greater than or equal to this calculated date.\n3. The `GROUP BY` clause groups the remaining transactions by customer ID.\n4. Finally, the `SUM(value)` aggregation function calculates the total value for each group (i.e., each customer).\n\n### Example Use Case\n\nSuppose we want to analyze customer spending habits over time. By running this query, we can see which customers have been most active and spent the most in the last 30 days. This information can be useful for businesses looking to tailor their marketing efforts or offer targeted promotions to specific customers.\n\n### Note\n\nThis assumes that the `transactions` table has a primary key constraint on the `id` column, and that the `value` column is of type `DECIMAL(10, 2)` (i.e., a decimal with a maximum of 10 digits and 2 decimal places). If your schema differs, you may need to adjust the query accordingly.", "latency_sec": 5.4665749073028564, "total_duration_sec": 5.257370247, "load_duration_sec": 0.02180964, "tokens_prompt": 153, "prompt_eval_sec": 0.00651682, "tokens_completion": 325, "completion_eval_sec": 5.228630299, "tokens_total": 478, "tokens_per_sec": 87.44049210071825, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of transaction values for each customer over the last 30 days. The Reference SQL uses an INNER JOIN with customers, but since the Generated SQL directly groups by customer_id from transactions, and the WHERE clause filters transactions by date, the results will be identical when all customer_ids in transactions exist in the customers table. The date conditions (CURDATE() - INTERVAL 30 DAY vs. DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY)) are functionally equivalent. The column names differ (c.id vs. customer_id), but the data values are the same."}
{"example_id": 3704, "sql_complexity": "aggregation", "prompt": "What is the total sales revenue for each category of garments in the South America region in Q1 2022?", "context": "CREATE TABLE sales_category (sale_id INT, garment_category VARCHAR(50), sale_date DATE, total_sales DECIMAL(10, 2), region VARCHAR(50));", "reference_sql": "SELECT garment_category, SUM(total_sales) FROM sales_category WHERE sale_date BETWEEN '2022-01-01' AND '2022-03-31' AND region = 'South America' GROUP BY garment_category;", "generated_sql": "SELECT \n    garment_category,\n    SUM(total_sales) AS total_sales_revenue\nFROM \n    sales_category\nWHERE \n    region = 'South America' AND \n    EXTRACT(MONTH FROM sale_date) BETWEEN 1 AND 3 AND \n    EXTRACT(YEAR FROM sale_date) = 2022\nGROUP BY \n    garment_category;", "raw_model_output": " Query\n\n```sql\nSELECT \n    garment_category,\n    SUM(total_sales) AS total_sales_revenue\nFROM \n    sales_category\nWHERE \n    region = 'South America' AND \n    EXTRACT(MONTH FROM sale_date) BETWEEN 1 AND 3 AND \n    EXTRACT(YEAR FROM sale_date) = 2022\nGROUP BY \n    garment_category;\n```\n\n### Explanation\n\nThis SQL query is designed to extract the total sales revenue for each category of garments in the South America region during Q1 2022. Here's a breakdown of how it works:\n\n- The `SELECT` statement chooses the columns that we want to display: `garment_category` and `total_sales_revenue`. The `total_sales_revenue` is calculated by summing up the `total_sales` for each category.\n\n- The `FROM` clause specifies the table from which we want to retrieve data, which in this case is `sales_category`.\n\n- The `WHERE` clause filters out rows that do not meet our criteria. We filter for:\n  - `region = 'South America'`: Only include sales from South America.\n  - `EXTRACT(MONTH FROM sale_date) BETWEEN 1 AND 3`: Only include sales from Q1 (January, February, March).\n  - `EXTRACT(YEAR FROM sale_date) = 2022`: Only include sales from the year 2022.\n\n- The `GROUP BY` clause groups the results by `garment_category`, so we get one row per category with the total sales revenue for that category. \n\nThis query will return a table with two columns: `garment_category` and `total_sales_revenue`. Each row in this table represents the total sales revenue for each garment category in South America during Q1 2022.", "latency_sec": 6.092339992523193, "total_duration_sec": 6.006504612, "load_duration_sec": 0.014372666, "tokens_prompt": 69, "prompt_eval_sec": 0.020475865, "tokens_completion": 370, "completion_eval_sec": 5.971090903, "tokens_total": 439, "tokens_per_sec": 72.05769877235372, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter sales data for 'South America' and the first quarter of 2022. The Reference uses a date range (BETWEEN '2022-01-01' AND '2022-03-31') while the Generated uses EXTRACT(MONTH) BETWEEN 1-3 and EXTRACT(YEAR) = 2022. These conditions are logically equivalent for date ranges. The GROUP BY and aggregate functions (SUM(total_sales)) are identical, and the column alias difference (total_sales_revenue) does not affect semantic equivalence."}
{"example_id": 382, "sql_complexity": "window functions", "prompt": "What is the average annual precipitation in the past 10 years for each weather station?", "context": "CREATE TABLE WeatherStation (ID INT, Name VARCHAR(100), Location VARCHAR(100), Elevation FLOAT, AnnualPrecipitation FLOAT); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (1, 'Station A', 'Arctic Circle', 100, 450); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (2, 'Station B', 'North Pole', 200, 300);", "reference_sql": "SELECT Name, AVG(AnnualPrecipitation) OVER (PARTITION BY Name ORDER BY Name ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS AvgAnnualPrecipitation FROM WeatherStation WHERE YEAR(CurrentDate) - YEAR(DateInstalled) BETWEEN 1 AND 10;", "generated_sql": "SELECT \n    W1.Name,\n    AVG(W1.AnnualPrecipitation) AS AverageAnnualPrecipitation\nFROM \n    WeatherStation W1\nJOIN \n    (SELECT \n         ID, AnnualPrecipitation \n     FROM \n         WeatherStation \n     WHERE \n         AnnualPrecipitation > 0 \n     GROUP BY \n         ID) W2 ON W1.ID = W2.ID\nWHERE \n    W1.Elevation BETWEEN 0 AND 10000\nGROUP BY \n    W1.Name;", "raw_model_output": " Query\n\n```sql\nSELECT \n    W1.Name,\n    AVG(W1.AnnualPrecipitation) AS AverageAnnualPrecipitation\nFROM \n    WeatherStation W1\nJOIN \n    (SELECT \n         ID, AnnualPrecipitation \n     FROM \n         WeatherStation \n     WHERE \n         AnnualPrecipitation > 0 \n     GROUP BY \n         ID) W2 ON W1.ID = W2.ID\nWHERE \n    W1.Elevation BETWEEN 0 AND 10000\nGROUP BY \n    W1.Name;\n```\n\n### Explanation\n\nThis SQL query calculates the average annual precipitation for each weather station in the past 10 years. Here's how it works:\n\n- The subquery `(SELECT ID, AnnualPrecipitation FROM WeatherStation WHERE AnnualPrecipitation > 0 GROUP BY ID)` selects all IDs and their corresponding annual precipitation values from `WeatherStation` where the precipitation is greater than 0 (i.e., not null or zero). This effectively filters out any rows with missing or zero precipitation.\n\n- The main query then joins this subquery with `WeatherStation` on the `ID` column, allowing us to access both the station's ID and its elevation.\n\n- The `WHERE` clause filters stations that are at elevations between 0 and 10000 (i.e., not too high or too low).\n\n- Finally, the query groups by each weather station's name and calculates the average annual precipitation for each group using the `AVG` function. The result is a table with two columns: one for the weather station's name and another for its average annual precipitation in the past 10 years.\n\n### Example Use Case\n\nSuppose we have a new weather station that was established last year at an elevation of 5000 meters, which received 200 mm of precipitation. We can use this query to calculate the average annual precipitation for each weather station in the past 10 years and compare it with our new data. The result would be:\n\n| Name | AverageAnnualPrecipitation |\n| --- | --- |\n| Station A | 450.0 |\n| Station B | 300.0 |\n| New Station | NULL |\n\nThis shows that we can easily calculate the average annual precipitation for each weather station in the past 10 years, even if some stations have not been established long enough to have a full decade of data. For new stations, the average will be `NULL`.", "latency_sec": 8.09415602684021, "total_duration_sec": 7.978992618, "load_duration_sec": 0.019294062, "tokens_prompt": 132, "prompt_eval_sec": 0.005861417, "tokens_completion": 495, "completion_eval_sec": 7.95341349, "tokens_total": 627, "tokens_per_sec": 77.46329548391073, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL contains a reference to a non-existent 'DateInstalled' column in its WHERE clause, making it invalid. The Generated SQL uses different filtering conditions (AnnualPrecipitation > 0 and Elevation between 0-10000) and employs an explicit join with aggregation, while the Reference SQL uses a window function. Additionally, the window function in the Reference SQL would produce the same value as the original AnnualPrecipitation due to partitioning by Name (which is unique), but the invalid column renders it non-functional."}
