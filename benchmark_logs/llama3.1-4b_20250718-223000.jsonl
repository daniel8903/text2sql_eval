{"example_id": 904, "sql_complexity": "basic SQL", "prompt": "What is the minimum Shariah-compliant loan amount issued in the last quarter of 2021?", "context": "CREATE TABLE loans (id INT, amount DECIMAL, date DATE, loan_type VARCHAR); INSERT INTO loans (id, amount, date, loan_type) VALUES (1, 5000, '2021-09-05', 'Shariah-compliant'), (2, 7000, '2021-10-07', 'socially responsible'), (3, 9000, '2021-11-03', 'Shariah-compliant'), (4, 11000, '2021-12-31', 'Shariah-compliant');", "reference_sql": "SELECT MIN(amount) FROM loans WHERE EXTRACT(YEAR FROM date) = 2021 AND EXTRACT(QUARTER FROM date) = 4 AND loan_type = 'Shariah-compliant';", "generated_sql": "SELECT MIN(amount) \nFROM loans \nWHERE EXTRACT(MONTH FROM date) = 10 AND loan_type = 'Shariah-compliant';", "raw_model_output": " Query\n```sql\nSELECT MIN(amount) \nFROM loans \nWHERE EXTRACT(MONTH FROM date) = 10 AND loan_type = 'Shariah-compliant';\n```\n\n### Explanation\n\nTo find the minimum Shariah-compliant loan amount issued in the last quarter of 2021, we need to filter the `loans` table for loans with a `date` in October (month 10), and then select only those that are Shariah-compliant. We use the `EXTRACT(MONTH FROM date)` function to extract the month from the `date` column.\n\nThe `MIN(amount)` function is used to find the minimum amount among these filtered loans.\n\n### Example Use Case\n\nSuppose we want to analyze loan data for a specific quarter and identify the smallest Shariah-compliant loan issued during that period. We can use this SQL query to achieve this. By modifying the date range, we can easily switch between different quarters or years to examine the loan data in various time periods.", "latency_sec": 5.566849946975708, "total_duration_sec": 5.401052072, "load_duration_sec": 2.017517572, "tokens_prompt": 150, "prompt_eval_sec": 0.101529769, "tokens_completion": 206, "completion_eval_sec": 3.280022918, "tokens_total": 356, "tokens_per_sec": 63.94999028012304, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query filters for loans in the 4th quarter (October-December) of 2021, while the generated query only checks for October. The sample data shows 'Shariah-compliant' loans in November and December (which would be included in the reference query but excluded by the generated query). This makes the result sets different."}
{"example_id": 1373, "sql_complexity": "subqueries", "prompt": "What is the total value of military equipment sales to Africa in the last 12 months?", "context": "CREATE TABLE Military_Equipment_Sales(sale_id INT, sale_date DATE, equipment_type VARCHAR(50), country VARCHAR(50), sale_value DECIMAL(10,2));", "reference_sql": "SELECT SUM(sale_value) FROM Military_Equipment_Sales WHERE country IN (SELECT country FROM World_Countries WHERE continent = 'Africa') AND sale_date >= DATE_SUB(CURRENT_DATE, INTERVAL 12 MONTH);", "generated_sql": "SELECT SUM(CASE WHEN country = 'Africa' THEN sale_value END) AS total_value\nFROM Military_Equipment_Sales\nWHERE EXTRACT(YEAR FROM sale_date) >= (EXTRACT(YEAR FROM CURRENT_DATE) - 1);", "raw_model_output": " Query\n\n```sql\nSELECT SUM(CASE WHEN country = 'Africa' THEN sale_value END) AS total_value\nFROM Military_Equipment_Sales\nWHERE EXTRACT(YEAR FROM sale_date) >= (EXTRACT(YEAR FROM CURRENT_DATE) - 1);\n```\n\n### Explanation\n\nThis query calculates the total value of military equipment sales to Africa in the last 12 months. Here's how it works:\n\n- The `SUM` function is used to calculate the total value.\n- The `CASE WHEN` statement checks if the country is 'Africa'. If true, then the sale_value is included in the sum.\n- The `EXTRACT(YEAR FROM CURRENT_DATE)` and `(EXTRACT(YEAR FROM CURRENT_DATE) - 1)` expressions are used to get the current year and subtract one from it. This ensures that we only consider sales from the last 12 months.\n\n### Example Use Case\n\nSuppose you have a database of military equipment sales, and you want to know the total value of sales to Africa in the last 12 months. You can use this query to get the answer. The result will be the total value of all sales to Africa that occurred within the last year. \n\n### Note\nThis assumes that the `sale_date` column is of type DATE, and that you are using a database system that supports the `EXTRACT` function (such as PostgreSQL). If your database system does not support this function, you may need to use an alternative method to extract the year from the date. \n\n### Alternative Solution\n\nIf your database system does not support the `EXTRACT` function, you can use the following query instead:\n\n```sql\nSELECT SUM(CASE WHEN country = 'Africa' THEN sale_value END) AS total_value\nFROM Military_Equipment_Sales\nWHERE sale_date >= DATE_TRUNC('year', CURRENT_DATE) - INTERVAL '1 year';\n```\n\nThis query uses the `DATE_TRUNC` function to truncate the date to the year level, and then subtracts one year from it. This achieves the same result as the original query. \n\n### Note\n\nThe exact syntax for the alternative solution may vary depending on your database system. The above example is for PostgreSQL. You should adjust the syntax according to your specific database system.", "latency_sec": 7.392937898635864, "total_duration_sec": 7.384766484, "load_duration_sec": 0.020210994, "tokens_prompt": 66, "prompt_eval_sec": 0.008937969, "tokens_completion": 460, "completion_eval_sec": 7.355317943, "tokens_total": 526, "tokens_per_sec": 71.14898125913608, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in two key aspects. First, the reference query uses a subquery to find all countries in Africa from World_Countries, while the generated query incorrectly checks for country = 'Africa' (a single country name). Second, the date conditions differ: the reference uses a 12-month interval from current date, while the generated query checks if the sale_date's year is >= (current year - 1), which includes a broader time range (entire previous year + partial current year) compared to the exact 12-month window."}
{"example_id": 5039, "sql_complexity": "subqueries", "prompt": "What is the total number of community policing events in 'City Park' in 2021?", "context": "CREATE TABLE locations (id INT, name VARCHAR(255)); CREATE TABLE community_policing (id INT, location_id INT, year INT, events INT); INSERT INTO locations (id, name) VALUES (1, 'City Park'); INSERT INTO community_policing (id, location_id, year, events) VALUES (1, 1, 2021, 5);", "reference_sql": "SELECT SUM(events) FROM community_policing WHERE location_id = (SELECT id FROM locations WHERE name = 'City Park') AND year = 2021;", "generated_sql": "SELECT COUNT(*) \nFROM community_policing \nWHERE location_id = 1 AND year = 2021;", "raw_model_output": " Query\n```sql\nSELECT COUNT(*) \nFROM community_policing \nWHERE location_id = 1 AND year = 2021;\n```\n\n### Explanation\n\nThis query uses a simple `COUNT` function to count the number of rows that match the specified conditions. The `WHERE` clause filters the results to only include rows where `location_id` is equal to 1 (i.e., 'City Park') and `year` is equal to 2021.\n\n### Example Use Case\n\nSuppose we want to analyze community policing data for different locations over time. We can use this query as a starting point, adding additional conditions or filters as needed to get the desired results. For example:\n\n```sql\nSELECT location_id, year, COUNT(*) \nFROM community_policing \nWHERE events > 0 \nGROUP BY location_id, year;\n```\n\nThis query groups the results by `location_id` and `year`, counting the number of events for each combination. The resulting table can be used to visualize trends in community policing data over time for different locations.", "latency_sec": 3.767703056335449, "total_duration_sec": 3.508857866, "load_duration_sec": 0.026018511, "tokens_prompt": 109, "prompt_eval_sec": 0.006311387, "tokens_completion": 217, "completion_eval_sec": 3.475992729, "tokens_total": 326, "tokens_per_sec": 86.52486544867864, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The reference query sums the 'events' column for a specific location and year, while the generated query counts the number of rows. In the sample data, the reference query would return 5 (sum of events) and the generated query would return 1 (count of rows), producing different results."}
{"example_id": 4932, "sql_complexity": "basic SQL", "prompt": "Delete the workout row with the id of 2.", "context": "CREATE TABLE Workouts (id INT, user_id INT, workout_name TEXT, calories INT); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (1, 1, 'Running', 300); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (2, 1, 'Cycling', 400); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (3, 2, 'Yoga', 200);", "reference_sql": "DELETE FROM Workouts WHERE id = 2;", "generated_sql": "DELETE FROM Workouts WHERE id = 2;", "raw_model_output": " Code\n\n```sql\nDELETE FROM Workouts WHERE id = 2;\n```\n\n### Explanation\nThis SQL code deletes a specific row from the `Workouts` table based on its `id`. The `WHERE` clause specifies that we want to delete rows where the `id` is equal to 2. This will remove the workout with the id of 2 from the database.\n\n### Example Use Case\nSuppose you have a user who has completed a cycling workout and wants to remove it from their workout history. You can use this SQL code to delete the corresponding row from the `Workouts` table, effectively removing the workout from the user's record. \n\n```sql\n-- Insert new workouts for users 1 and 2\nINSERT INTO Workouts (id, user_id, workout_name, calories) \nVALUES (4, 1, 'Swimming', 500);\nINSERT INTO Workouts (id, user_id, workout_name, calories) \nVALUES (5, 2, 'Strength Training', 600);\n\n-- Delete the workout with id 2\nDELETE FROM Workouts WHERE id = 2;\n``` \n\nAfter executing this code, the `Workouts` table will contain only rows for users 1 and 2. The row with id 2 has been successfully deleted.", "latency_sec": 4.310417890548706, "total_duration_sec": 4.280387023, "load_duration_sec": 0.014533398, "tokens_prompt": 128, "prompt_eval_sec": 0.006275225, "tokens_completion": 266, "completion_eval_sec": 4.259032445, "tokens_total": 394, "tokens_per_sec": 91.40645060515112, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They both delete the record from the Workouts table where the id is 2. The semantic meaning and resulting database state after execution are exactly the same."}
{"example_id": 4637, "sql_complexity": "single join", "prompt": "What is the total value of transactions for each customer in the last 30 days?", "context": "CREATE TABLE transactions (id INT, customer_id INT, value DECIMAL(10, 2), transaction_date DATE); INSERT INTO transactions (id, customer_id, value, transaction_date) VALUES (1, 1, 100, '2022-01-01'), (2, 1, 200, '2022-01-15'), (3, 2, 50, '2022-01-05'), (4, 2, 150, '2022-01-30'), (5, 3, 300, '2022-01-20');", "reference_sql": "SELECT c.id, SUM(t.value) FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE t.transaction_date >= CURDATE() - INTERVAL 30 DAY GROUP BY c.id;", "generated_sql": "SELECT \n    c.customer_id,\n    SUM(t.value) AS total_value\nFROM \n    customers c\nJOIN \n    transactions t ON c.id = t.customer_id\nWHERE \n    EXTRACT(YEAR FROM t.transaction_date) = 2022 AND \n    EXTRACT(MONTH FROM t.transaction_date) = 1 AND \n    EXTRACT(DAY FROM t.transaction_date) <= 30\nGROUP BY \n    c.customer_id;", "raw_model_output": " Query\n```sql\nSELECT \n    c.customer_id,\n    SUM(t.value) AS total_value\nFROM \n    customers c\nJOIN \n    transactions t ON c.id = t.customer_id\nWHERE \n    EXTRACT(YEAR FROM t.transaction_date) = 2022 AND \n    EXTRACT(MONTH FROM t.transaction_date) = 1 AND \n    EXTRACT(DAY FROM t.transaction_date) <= 30\nGROUP BY \n    c.customer_id;\n```\n\n### Explanation\n\nThis SQL query calculates the total value of transactions for each customer in the last 30 days. Here's a step-by-step breakdown:\n\n1. **Join customers table with transactions table**: We join the `customers` table with the `transactions` table on the `customer_id` column to link each transaction with its corresponding customer.\n2. **Filter transactions by date range**: We filter transactions based on the year, month, and day of the transaction date using the `EXTRACT` function. This ensures we only consider transactions from January 2022 that are within the last 30 days (i.e., up to January 29, 2022).\n3. **Group by customer_id**: We group the filtered transactions by their corresponding `customer_id`.\n4. **Calculate total value for each customer**: For each group of transactions belonging to a single customer, we calculate the sum of their values using the `SUM` function.\n\nNote that this query assumes the existence of a `customers` table with an `id` column and a `transaction_date` column in the `transactions` table. The actual schema may vary depending on your specific database design.", "latency_sec": 5.6089537143707275, "total_duration_sec": 5.398103422, "load_duration_sec": 0.014476764, "tokens_prompt": 153, "prompt_eval_sec": 0.006418842, "tokens_completion": 334, "completion_eval_sec": 5.376908409, "tokens_total": 487, "tokens_per_sec": 86.82546243023096, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL filters transactions from the last 30 days using CURDATE() - INTERVAL 30 DAY, while the Generated SQL explicitly filters for January 2022 with day <= 30. This makes the Generated SQL fixed to a specific date range (January 2022) rather than a dynamic 30-day window. Additionally, the Generated SQL excludes transactions on January 31st, whereas the Reference SQL would include them if within the 30-day window. The date conditions and dynamic vs. static ranges make them non-equivalent."}
{"example_id": 3704, "sql_complexity": "aggregation", "prompt": "What is the total sales revenue for each category of garments in the South America region in Q1 2022?", "context": "CREATE TABLE sales_category (sale_id INT, garment_category VARCHAR(50), sale_date DATE, total_sales DECIMAL(10, 2), region VARCHAR(50));", "reference_sql": "SELECT garment_category, SUM(total_sales) FROM sales_category WHERE sale_date BETWEEN '2022-01-01' AND '2022-03-31' AND region = 'South America' GROUP BY garment_category;", "generated_sql": "SELECT \n    garment_category,\n    SUM(total_sales) AS total_sales_revenue\nFROM \n    sales_category\nWHERE \n    region = 'South America' AND \n    EXTRACT(MONTH FROM sale_date) BETWEEN 3 AND 5 AND \n    EXTRACT(YEAR FROM sale_date) = 2022\nGROUP BY \n    garment_category;", "raw_model_output": " Query\n\n```sql\nSELECT \n    garment_category,\n    SUM(total_sales) AS total_sales_revenue\nFROM \n    sales_category\nWHERE \n    region = 'South America' AND \n    EXTRACT(MONTH FROM sale_date) BETWEEN 3 AND 5 AND \n    EXTRACT(YEAR FROM sale_date) = 2022\nGROUP BY \n    garment_category;\n```\n\n### Explanation\n\nThis SQL query selects the total sales revenue for each category of garments in the South America region during Q1 2022. Here's a breakdown:\n\n- `SELECT`: We select two columns: `garment_category` and `total_sales`. The `total_sales` column is calculated using the `SUM` function.\n  \n- `FROM`: We specify the table from which we want to retrieve data, which is `sales_category`.\n\n- `WHERE`:\n  - We filter rows where the region is 'South America'.\n  - We further filter rows based on the sale date. The `EXTRACT(MONTH FROM)` and `EXTRACT(YEAR FROM)` functions are used to extract the month and year from the `sale_date`, respectively.\n  \n- `GROUP BY`: We group the results by `garment_category` so that we can calculate the total sales revenue for each category.\n\n### Example Use Case\n\nSuppose you have a database containing sales data for different garment categories in various regions. You want to analyze the sales performance of these categories during Q1 2022 in South America. This SQL query would help you achieve this by providing the total sales revenue for each category, allowing you to compare their performance and make informed business decisions.", "latency_sec": 5.509546995162964, "total_duration_sec": 5.375894276, "load_duration_sec": 0.021098137, "tokens_prompt": 69, "prompt_eval_sec": 0.006033286, "tokens_completion": 336, "completion_eval_sec": 5.347607473, "tokens_total": 405, "tokens_per_sec": 73.5087658487285, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in their date filtering logic. The reference uses a direct date range ('2022-01-01' to '2022-03-31'), while the generated query uses EXTRACT(MONTH FROM sale_date) BETWEEN 3 AND 5 (March-May) combined with EXTRACT(YEAR = 2022). This makes the generated query include March-May 2022, whereas the reference only includes January-March 2022. The overlap is only March, but the full ranges differ."}
{"example_id": 382, "sql_complexity": "window functions", "prompt": "What is the average annual precipitation in the past 10 years for each weather station?", "context": "CREATE TABLE WeatherStation (ID INT, Name VARCHAR(100), Location VARCHAR(100), Elevation FLOAT, AnnualPrecipitation FLOAT); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (1, 'Station A', 'Arctic Circle', 100, 450); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (2, 'Station B', 'North Pole', 200, 300);", "reference_sql": "SELECT Name, AVG(AnnualPrecipitation) OVER (PARTITION BY Name ORDER BY Name ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS AvgAnnualPrecipitation FROM WeatherStation WHERE YEAR(CurrentDate) - YEAR(DateInstalled) BETWEEN 1 AND 10;", "generated_sql": "SELECT \n    W1.Name,\n    AVG(W1.AnnualPrecipitation) AS AverageAnnualPrecipitation\nFROM \n    WeatherStation W1\nJOIN \n    (SELECT \n         ID, AnnualPrecipitation \n     FROM \n         WeatherStation \n     WHERE \n         AnnualPrecipitation > 0) W2 ON W1.ID = W2.ID\nWHERE \n    EXTRACT(YEAR FROM CURRENT_DATE - INTERVAL '10 years') <= EXTRACT(YEAR FROM CURRENT_DATE)\nGROUP BY \n    W1.Name;", "raw_model_output": " Query\n\n```sql\nSELECT \n    W1.Name,\n    AVG(W1.AnnualPrecipitation) AS AverageAnnualPrecipitation\nFROM \n    WeatherStation W1\nJOIN \n    (SELECT \n         ID, AnnualPrecipitation \n     FROM \n         WeatherStation \n     WHERE \n         AnnualPrecipitation > 0) W2 ON W1.ID = W2.ID\nWHERE \n    EXTRACT(YEAR FROM CURRENT_DATE - INTERVAL '10 years') <= EXTRACT(YEAR FROM CURRENT_DATE)\nGROUP BY \n    W1.Name;\n```\n\n### Explanation\n\nThis SQL query calculates the average annual precipitation for each weather station in the past 10 years. Here's a step-by-step breakdown:\n\n1. **Joining tables**: We join the `WeatherStation` table with a subquery that selects only rows where `AnnualPrecipitation > 0`. This ensures we're only considering non-zero values.\n2. **Filtering dates**: We filter out records older than 10 years using the `EXTRACT(YEAR FROM CURRENT_DATE - INTERVAL '10 years') <= EXTRACT(YEAR FROM CURRENT_DATE)` condition.\n3. **Grouping and averaging**: We group the results by station name (`W1.Name`) and calculate the average annual precipitation for each station using the `AVG` function.\n\n### Example Use Case\n\nSuppose we have a weather monitoring system that provides historical data on precipitation at various weather stations around the world. This query would help us identify which stations are experiencing high or low precipitation in the past 10 years, allowing us to make more informed decisions about resource allocation and infrastructure planning.", "latency_sec": 5.679533004760742, "total_duration_sec": 5.353180025, "load_duration_sec": 0.014553636, "tokens_prompt": 132, "prompt_eval_sec": 0.005804827, "tokens_completion": 333, "completion_eval_sec": 5.332297343, "tokens_total": 465, "tokens_per_sec": 81.87292856828617, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL references a non-existent 'DateInstalled' column in its WHERE clause, which would cause an error. The Generated SQL uses a subquery filtering for AnnualPrecipitation > 0 and employs a GROUP BY aggregation, while the Reference SQL uses a window function. Additionally, the Reference SQL's WHERE condition involving YEAR() calculations is invalid due to missing columns. These differences in filtering, aggregation logic, and schema compliance make the queries non-equivalent."}
{"example_id": 5168, "sql_complexity": "aggregation", "prompt": "Get the number of renewable energy projects in Australia for each project type.", "context": "CREATE TABLE renewable_projects (id INT PRIMARY KEY, project_name VARCHAR(255), project_location VARCHAR(255), project_type VARCHAR(255), capacity_mw FLOAT);", "reference_sql": "SELECT project_type, COUNT(*) FROM renewable_projects WHERE project_location = 'Australia' GROUP BY project_type;", "generated_sql": "SELECT \n    project_type,\n    COUNT(*) as num_projects\nFROM \n    renewable_projects\nWHERE \n    project_location = 'Australia'\nGROUP BY \n    project_type;", "raw_model_output": " Query\n```sql\nSELECT \n    project_type,\n    COUNT(*) as num_projects\nFROM \n    renewable_projects\nWHERE \n    project_location = 'Australia'\nGROUP BY \n    project_type;\n```\n\n### Explanation\n\nThis SQL query will return the number of renewable energy projects in Australia for each project type. Here's how it works:\n\n1. `SELECT`: We select the columns we want to display: `project_type` and `COUNT(*) as num_projects`. The `COUNT(*)` function counts the total number of rows in each group.\n2. `FROM`: We specify the table we're querying, which is `renewable_projects`.\n3. `WHERE`: We filter the results to only include projects located in Australia by setting `project_location = 'Australia'`.\n4. `GROUP BY`: We group the remaining rows by `project_type`, so that we can count the number of projects for each type.\n\n### Example Use Case\n\nSuppose you have a database with information about renewable energy projects, and you want to know how many solar panels are being used in Australia versus wind turbines. You could use this query to get the answer! \n\n```sql\n-- Create some sample data\nINSERT INTO renewable_projects (id, project_name, project_location, project_type, capacity_mw)\nVALUES \n(1, 'Solar Panel', 'Australia', 'solar', 10),\n(2, 'Wind Turbine', 'Australia', 'wind', 20),\n(3, 'Hydroelectric Dam', 'New Zealand', 'hydro', 30);\n\n-- Run the query\nSELECT \n    project_type,\n    COUNT(*) as num_projects\nFROM \n    renewable_projects\nWHERE \n    project_location = 'Australia'\nGROUP BY \n    project_type;\n```\n\nThis would return:\n\n| project_type | num_projects |\n| --- | --- |\n| solar | 1 |\n| wind | 1 |\n\nLet me know if you have any questions or need further clarification!", "latency_sec": 6.5284459590911865, "total_duration_sec": 6.43981751, "load_duration_sec": 0.016523968, "tokens_prompt": 59, "prompt_eval_sec": 0.003589461, "tokens_completion": 402, "completion_eval_sec": 6.419338581, "tokens_total": 461, "tokens_per_sec": 70.61404856358419, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries retrieve the same data: counts of projects by type in Australia. The generated query adds an alias 'num_projects' to the COUNT(*) column, but this does not affect the semantic result set's content. The GROUP BY, WHERE, and aggregation logic are identical."}
{"example_id": 4669, "sql_complexity": "set operations", "prompt": "Identify the number of IoT devices in each country and the total number of devices.", "context": "CREATE TABLE device_country (device_id INT, country TEXT); INSERT INTO device_country (device_id, country) VALUES (1, 'USA'), (2, 'Canada'), (3, 'Mexico'), (4, 'Brazil'); CREATE TABLE device_info (device_id INT, device_type TEXT); INSERT INTO device_info (device_id, device_type) VALUES (1, 'Soil Sensor'), (2, 'Temperature Sensor'), (3, 'Humidity Sensor'), (4, 'Precision Sprayer');", "reference_sql": "SELECT country, COUNT(*) AS device_count FROM device_country GROUP BY country UNION SELECT 'Total' AS country, COUNT(*) FROM device_country;", "generated_sql": "SELECT \n  c.country,\n  COUNT(di.device_id) AS num_devices,\n  SUM(COUNT(di.device_id)) OVER () AS total_num_devices\nFROM \n  device_country dc\nJOIN \n  device_info di ON dc.device_id = di.device_id\nGROUP BY \n  c.country;", "raw_model_output": " Query\n\n```sql\nSELECT \n  c.country,\n  COUNT(di.device_id) AS num_devices,\n  SUM(COUNT(di.device_id)) OVER () AS total_num_devices\nFROM \n  device_country dc\nJOIN \n  device_info di ON dc.device_id = di.device_id\nGROUP BY \n  c.country;\n```\n\n### Explanation\n\nThis SQL query identifies the number of IoT devices in each country and the total number of devices. Here's a step-by-step explanation:\n\n1. **Joining tables**: We join `device_country` (dc) with `device_info` (di) on the common column `device_id`.\n2. **Grouping by country**: We group the results by the `country` column from `device_country`.\n3. **Counting devices in each country**: For each country, we count the number of devices using `COUNT(di.device_id) AS num_devices`.\n4. **Calculating total number of devices**: To calculate the total number of devices across all countries, we use a window function (`SUM(COUNT(di.device_id)) OVER ()`) that counts the total number of devices in each row (i.e., for each country). The `OVER()` clause specifies that we want to apply this aggregation over the entire result set.\n5. **Final output**: We select the `country`, `num_devices`, and `total_num_devices` columns to display the results.\n\n### Example Output\n\n| country | num_devices | total_num_devices |\n| --- | --- | --- |\n| USA     | 1          | 4                |\n| Canada  | 1          | 4                |\n| Mexico  | 1          | 4                |\n| Brazil  | 1          | 4                |\n\nNote that the `total_num_devices` column is not actually calculated in this query, as it's a conceptual representation of the total number of devices across all countries. The actual count is done at runtime by the database.", "latency_sec": 6.524784803390503, "total_duration_sec": 6.418128919, "load_duration_sec": 0.014205906, "tokens_prompt": 132, "prompt_eval_sec": 0.005844052, "tokens_completion": 399, "completion_eval_sec": 6.397527299, "tokens_total": 531, "tokens_per_sec": 81.38199434931158, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL returns country-specific device counts with a separate 'Total' row, while the Generated SQL joins device_country with device_info, groups by country, and adds a window function total in each row. The Generated SQL also includes an extra 'total_num_devices' column and omits the explicit 'Total' row. Additionally, the Generated SQL's JOIN operation could introduce discrepancies if there were missing device_info entries, though in this specific dataset it doesn't affect results."}
{"example_id": 4573, "sql_complexity": "subqueries", "prompt": "Find the names of all the indigenous communities in the 'Arctic_Communities' table that have a population size greater than the average population size in the 'Antarctic_Communities' table.", "context": "CREATE TABLE Arctic_Communities (name TEXT, population INTEGER); CREATE TABLE Antarctic_Communities (name TEXT, population INTEGER);", "reference_sql": "SELECT name FROM Arctic_Communities WHERE Arctic_Communities.population > (SELECT AVG(population) FROM Antarctic_Communities)", "generated_sql": "SELECT name \nFROM Arctic_Communities \nWHERE population > (SELECT AVG(population) FROM Antarctic_Communities);", "raw_model_output": " Query\n\n```sql\nSELECT name \nFROM Arctic_Communities \nWHERE population > (SELECT AVG(population) FROM Antarctic_Communities);\n```\n\nThis query works as follows:\n\n- The subquery `(SELECT AVG(population) FROM Antarctic_communities)` calculates the average population size in the 'Antarctic_Communities' table.\n- The outer query `SELECT name FROM Arctic_Communities WHERE population > ...` selects the names of all communities from the 'Arctic_Communities' table where their population is greater than the calculated average. \n\n### Explanation\nThis SQL query uses a subquery to calculate the average population size in the Antarctic communities, and then selects the names of the Arctic communities with populations above this average. The result will be the names of all indigenous Arctic communities that have more people than the average number of people in an Antarctic community. \n\nNote: This assumes there are no null values in the 'population' column. If there could be nulls, you would need to add a `WHERE population IS NOT NULL` clause before your main query.", "latency_sec": 3.513861894607544, "total_duration_sec": 3.462910568, "load_duration_sec": 0.034154391, "tokens_prompt": 75, "prompt_eval_sec": 0.005069367, "tokens_completion": 214, "completion_eval_sec": 3.423270656, "tokens_total": 289, "tokens_per_sec": 82.24569111367362, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select names from Arctic_Communities where population exceeds the average population of Antarctic_Communities. The generated query omits the table name in the WHERE clause (population vs. Arctic_Communities.population), but since the column exists only in the queried table, the semantic meaning remains identical."}
{"example_id": 3008, "sql_complexity": "multiple_joins", "prompt": "Who are the users who used electric vehicles and their trip details?", "context": "CREATE TABLE users (id INT, name VARCHAR(50), age INT, gender VARCHAR(10), city VARCHAR(50));CREATE TABLE vehicles (id INT, vehicle_type VARCHAR(20), is_electric BOOLEAN);CREATE TABLE trips (id INT, user_id INT, vehicle_id INT, trip_distance FLOAT, trip_duration INT, departure_time TIMESTAMP, arrival_time TIMESTAMP);INSERT INTO users (id, name, age, gender, city) VALUES (3, 'Alex', 30, 'Female', 'New York');INSERT INTO vehicles (id, vehicle_type, is_electric) VALUES (1, 'Tesla', true), (2, 'Bike', false);INSERT INTO trips (id, user_id, vehicle_id, trip_distance, trip_duration, departure_time, arrival_time) VALUES (3, 3, 1, 15.3, 25, '2022-01-03 12:00:00', '2022-01-03 12:25:00');", "reference_sql": "SELECT u.name, v.vehicle_type, t.trip_distance, t.trip_duration FROM users u JOIN trips t ON u.id = t.user_id JOIN vehicles v ON t.vehicle_id = v.id WHERE v.is_electric = true;", "generated_sql": "SELECT u.name, t.trip_distance, t.trip_duration, v.vehicle_type \nFROM trips t \nJOIN vehicles v ON t.vehicle_id = v.id \nJOIN users u ON t.user_id = u.id \nWHERE v.is_electric = true;", "raw_model_output": " Query\n```sql\nSELECT u.name, t.trip_distance, t.trip_duration, v.vehicle_type \nFROM trips t \nJOIN vehicles v ON t.vehicle_id = v.id \nJOIN users u ON t.user_id = u.id \nWHERE v.is_electric = true;\n```\n\nThis query first joins the `trips`, `vehicles`, and `users` tables based on their respective IDs. Then, it filters the results to only include rows where the vehicle is electric (`v.is_electric = true`). Finally, it selects the desired columns from each table.\n\n### Explanation\nTo answer this question, we need to join three tables: `trips`, `vehicles`, and `users`. We want to know which users used electric vehicles for their trips. So, we first join the `trips` table with the `vehicles` table on the `vehicle_id` column, and then join the result with the `users` table on the `user_id` column. This allows us to access the user's name, trip details, and vehicle type.\n\nThe filter condition (`WHERE v.is_electric = true`) ensures that we only include rows where the vehicle is electric. The selected columns (`u.name`, `t.trip_distance`, `t.trip_duration`, `v.vehicle_type`) provide the desired information about the users who used electric vehicles for their trips.", "latency_sec": 4.524823188781738, "total_duration_sec": 4.480632929, "load_duration_sec": 0.01450783, "tokens_prompt": 231, "prompt_eval_sec": 0.007895058, "tokens_completion": 276, "completion_eval_sec": 4.457624195, "tokens_total": 507, "tokens_per_sec": 112.04857711501087, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries select the same columns but in a different order. While the data content is identical, the column order in the result set differs, making them not semantically equivalent under strict SQL semantics where column order matters."}
{"example_id": 1506, "sql_complexity": "basic SQL", "prompt": "How many habitats are in the 'animal_habitats' table?", "context": "CREATE TABLE animal_habitats (id INT PRIMARY KEY, habitat_name VARCHAR, num_animals INT);", "reference_sql": "SELECT COUNT(*) FROM animal_habitats;", "generated_sql": "SELECT COUNT(*) FROM animal_habitats;", "raw_model_output": " Query\n```sql\nSELECT COUNT(*) FROM animal_habitats;\n```\n\n### Explanation\nThis query uses the `COUNT` function to count the number of rows in the `animal_habitats` table. The `*` symbol is a wildcard that represents all columns, and the `SELECT` statement retrieves this count.\n\n### Example Use Case\nSuppose we have the following data in the 'animal_habitats' table:\n| id | habitat_name | num_animals |\n|----|--------------|-------------|\n| 1  | Forest       | 10          |\n| 2  | Desert       | 20          |\n| 3  | Mountain     | 30          |\n\nRunning this query would return `3`, indicating that there are three habitats in the 'animal_habitats' table.", "latency_sec": 2.753901958465576, "total_duration_sec": 2.652950872, "load_duration_sec": 0.014515166, "tokens_prompt": 47, "prompt_eval_sec": 0.003563276, "tokens_completion": 166, "completion_eval_sec": 2.634424848, "tokens_total": 213, "tokens_per_sec": 77.34480138090308, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic, selecting the count of all rows from the animal_habitats table. They will produce the same result."}
{"example_id": 4138, "sql_complexity": "window functions", "prompt": "How many lifelong learning courses has a student with ID '2' completed, in chronological order?", "context": "CREATE TABLE lifelong_learning (student_id INT, course_id INT, completion_date DATE); INSERT INTO lifelong_learning VALUES (2, 1001, '2015-01-01'), (2, 1002, '2016-01-01');", "reference_sql": "SELECT student_id, course_id, COUNT(course_id) OVER (PARTITION BY student_id ORDER BY completion_date) as completed_courses FROM lifelong_learning WHERE student_id = 2;", "generated_sql": "SELECT COUNT(*) \nFROM (\n    SELECT course_id \n    FROM lifelong_learning \n    WHERE student_id = 2 \n    ORDER BY completion_date ASC\n) AS subquery;", "raw_model_output": " Query\n```sql\nSELECT COUNT(*) \nFROM (\n    SELECT course_id \n    FROM lifelong_learning \n    WHERE student_id = 2 \n    ORDER BY completion_date ASC\n) AS subquery;\n```\n\n### Explanation\n\nThis query works as follows:\n\n- The outer `SELECT COUNT(*)` statement counts the number of rows in the subquery.\n- The subquery selects only the `course_id`s from the `lifelong_learning` table where the `student_id` is 2, and orders them by their completion date in ascending order (i.e., earliest to latest).\n- Since we are counting the number of courses completed, we don't need to include any additional columns or aggregate functions beyond `COUNT(*)`. \n\n### Example Use Case\nSuppose you want to know how many courses a student has completed over time. You can use this query as a starting point and modify it to suit your needs.\n\n### Advice\n\n- Always consider the specific requirements of your problem when writing SQL queries.\n- Be mindful of data types and potential issues with ordering dates (e.g., leap years, daylight saving time).\n- Use meaningful table aliases to improve readability. In this case, `subquery` is a clear and descriptive alias for the subquery.", "latency_sec": 4.151780128479004, "total_duration_sec": 4.061410643, "load_duration_sec": 0.01464268, "tokens_prompt": 83, "prompt_eval_sec": 0.005087712, "tokens_completion": 254, "completion_eval_sec": 4.041191849, "tokens_total": 337, "tokens_per_sec": 81.17000167912535, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL returns multiple rows with a cumulative count of courses per student, while the Generated SQL returns a single total count. The Reference query produces 2 rows with (student_id, course_id, completed_courses) values, whereas the Generated query returns a single scalar value (2). Their output structures and purposes differ."}
{"example_id": 5499, "sql_complexity": "set operations", "prompt": "How many legal aid clinics and community mediation centers are there in total, and what is the sum of cases handled by each type of center, for centers located in the state of California?", "context": "CREATE TABLE LegalAidClinics (ClinicName text, State text, NumCases int); INSERT INTO LegalAidClinics VALUES ('Clinic1', 'CA', 30, '2022-01-01'), ('Clinic2', 'CA', 25, '2022-01-01'); CREATE TABLE CommunityMediationCenters (CenterName text, State text, NumCases int); INSERT INTO CommunityMediationCenters VALUES ('CM1', 'CA', 22, '2022-01-01'), ('CM2', 'CA', 28, '2022-01-01');", "reference_sql": "SELECT State, 'Legal Aid Clinics' AS CenterType, COUNT(*) AS NumCenters, SUM(NumCases) AS TotalCases FROM LegalAidClinics WHERE State = 'CA' UNION ALL SELECT State, 'Community Mediation Centers', COUNT(*), SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA';", "generated_sql": "SELECT \n    COUNT(ClinicName) AS TotalCenters,\n    SUM(NumCases) AS TotalCases,\n    SUM(CASE WHEN CenterName = 'CM1' THEN NumCases ELSE 0 END) AS CM1Cases,\n    SUM(CASE WHEN CenterName = 'CM2' THEN NumCases ELSE 0 END) AS CM2Cases\nFROM \n    LegalAidClinics\nUNION ALL\nSELECT \n    COUNT(CenterName) AS TotalCenters,\n    SUM(NumCases) AS TotalCases,\n    SUM(CASE WHEN CenterName = 'CM1' THEN NumCases ELSE 0 END) AS CM1Cases,\n    SUM(CASE WHEN CenterName = 'CM2' THEN NumCases ELSE 0 END) AS CM2Cases\nFROM \n    CommunityMediationCenters;", "raw_model_output": " Code\n\n```sql\nSELECT \n    COUNT(ClinicName) AS TotalCenters,\n    SUM(NumCases) AS TotalCases,\n    SUM(CASE WHEN CenterName = 'CM1' THEN NumCases ELSE 0 END) AS CM1Cases,\n    SUM(CASE WHEN CenterName = 'CM2' THEN NumCases ELSE 0 END) AS CM2Cases\nFROM \n    LegalAidClinics\nUNION ALL\nSELECT \n    COUNT(CenterName) AS TotalCenters,\n    SUM(NumCases) AS TotalCases,\n    SUM(CASE WHEN CenterName = 'CM1' THEN NumCases ELSE 0 END) AS CM1Cases,\n    SUM(CASE WHEN CenterName = 'CM2' THEN NumCases ELSE 0 END) AS CM2Cases\nFROM \n    CommunityMediationCenters;\n```\n\n### Explanation\n\nThis SQL code uses the `UNION ALL` operator to combine two separate queries: one for legal aid clinics and one for community mediation centers. Each query counts the total number of centers, sums up the cases handled by each center, and filters cases for specific centers (CM1 and CM2).\n\nThe first part of the query selects data from the `LegalAidClinics` table:\n\n```sql\nSELECT \n    COUNT(ClinicName) AS TotalCenters,\n    SUM(NumCases) AS TotalCases,\n    SUM(CASE WHEN CenterName = 'CM1' THEN NumCases ELSE 0 END) AS CM1Cases,\n    SUM(CASE WHEN CenterName = 'CM2' THEN NumCases ELSE 0 END) AS CM2Cases\nFROM \n    LegalAidClinics;\n```\n\nThe second part of the query selects data from the `CommunityMediationCenters` table:\n\n```sql\nSELECT \n    COUNT(CenterName) AS TotalCenters,\n    SUM(NumCases) AS TotalCases,\n    SUM(CASE WHEN CenterName = 'CM1' THEN NumCases ELSE 0 END) AS CM1Cases,\n    SUM(CASE WHEN CenterName = 'CM2' THEN NumCases ELSE 0 END) AS CM2Cases\nFROM \n    CommunityMediationCenters;\n```\n\nBoth queries use the `UNION ALL` operator to combine their results into a single result set. The resulting table contains four columns: `TotalCenters`, `TotalCases`, `CM1Cases`, and `CM2Cases`. \n\nNote that this query assumes there are no cases where both `CenterName` is 'CM1' or 'CM2'. If such cases exist, you would need to use a different approach. \n\nAlso note that the `UNION ALL` operator does not remove duplicate rows, so if there are multiple centers with the same name (e.g., two clinics named 'Clinic1'), they will be counted separately in the total count of centers. If you want to eliminate duplicates, consider using `UNION` instead of `UNION ALL`. \n\nFinally, this query does not account for cases where a center has no data (i.e., `NumCases` is NULL). Depending on your database schema and requirements, you might need to add additional logic to handle such cases.", "latency_sec": 10.813015937805176, "total_duration_sec": 10.577836096, "load_duration_sec": 0.014820666, "tokens_prompt": 178, "prompt_eval_sec": 0.006752774, "tokens_completion": 658, "completion_eval_sec": 10.555636361, "tokens_total": 836, "tokens_per_sec": 77.31422988817782, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not semantically equivalent. The Reference SQL combines LegalAidClinics and CommunityMediationCenters into a single result with State, CenterType, NumCenters, and TotalCases. The Generated SQL incorrectly references 'CenterName' in LegalAidClinics (which doesn't exist) and adds CM1Cases/CM2Cases columns that don't exist in the Reference. The structure and logic differ significantly, including incorrect column usage and aggregation targets."}
