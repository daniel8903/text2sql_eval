{"example_id": 904, "sql_complexity": "basic SQL", "prompt": "What is the minimum Shariah-compliant loan amount issued in the last quarter of 2021?", "context": "CREATE TABLE loans (id INT, amount DECIMAL, date DATE, loan_type VARCHAR); INSERT INTO loans (id, amount, date, loan_type) VALUES (1, 5000, '2021-09-05', 'Shariah-compliant'), (2, 7000, '2021-10-07', 'socially responsible'), (3, 9000, '2021-11-03', 'Shariah-compliant'), (4, 11000, '2021-12-31', 'Shariah-compliant');", "reference_sql": "SELECT MIN(amount) FROM loans WHERE EXTRACT(YEAR FROM date) = 2021 AND EXTRACT(QUARTER FROM date) = 4 AND loan_type = 'Shariah-compliant';", "generated_sql": "SELECT MIN(amount) AS min_loan_amount \nFROM loans \nWHERE date BETWEEN '2021-10-01' AND '2021-12-31' AND loan_type = 'Shariah-compliant';", "raw_model_output": "```sql\nSELECT MIN(amount) AS min_loan_amount \nFROM loans \nWHERE date BETWEEN '2021-10-01' AND '2021-12-31' AND loan_type = 'Shariah-compliant';\n```", "latency_sec": 18.57796597480774, "total_duration_sec": 18.29227479, "load_duration_sec": 2.688283682, "tokens_prompt": 436, "prompt_eval_sec": 11.376391963, "tokens_completion": 56, "completion_eval_sec": 4.218931522, "tokens_total": 492, "tokens_per_sec": 26.482985309972378, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries filter loans with 'Shariah-compliant' type and dates in Q4 of 2021. The reference uses EXTRACT(QUARTER) = 4, which corresponds to October-December, while the generated query uses BETWEEN '2021-10-01' AND '2021-12-31'. These date ranges are equivalent for Q4. The MIN(amount) calculation will yield the same result (9000) as both filter the same rows."}
{"example_id": 1373, "sql_complexity": "subqueries", "prompt": "What is the total value of military equipment sales to Africa in the last 12 months?", "context": "CREATE TABLE Military_Equipment_Sales(sale_id INT, sale_date DATE, equipment_type VARCHAR(50), country VARCHAR(50), sale_value DECIMAL(10,2));", "reference_sql": "SELECT SUM(sale_value) FROM Military_Equipment_Sales WHERE country IN (SELECT country FROM World_Countries WHERE continent = 'Africa') AND sale_date >= DATE_SUB(CURRENT_DATE, INTERVAL 12 MONTH);", "generated_sql": "SELECT SUM(sale_value) AS total_value \nFROM Military_Equipment_Sales \nWHERE country LIKE 'Africa%' \nAND sale_date >= DATEADD(month, -12, GETDATE());", "raw_model_output": "```sql\nSELECT SUM(sale_value) AS total_value \nFROM Military_Equipment_Sales \nWHERE country LIKE 'Africa%' \nAND sale_date >= DATEADD(month, -12, GETDATE());\n```", "latency_sec": 8.140172958374023, "total_duration_sec": 7.823373244, "load_duration_sec": 0.024517613, "tokens_prompt": 239, "prompt_eval_sec": 4.678102991, "tokens_completion": 44, "completion_eval_sec": 3.118559233, "tokens_total": 283, "tokens_per_sec": 34.765846063365274, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in how they filter countries. The Reference SQL uses a subquery to select countries from World_Countries where continent = 'Africa', while the Generated SQL uses a LIKE 'Africa%' pattern match. This would include countries starting with 'Africa' (e.g., 'Africa', 'African Republic') but exclude exact matches not starting with 'Africa' or include unintended entries. Additionally, date functions differ (DATE_SUB vs DATEADD) but achieve similar 12-month window logic. The country condition discrepancy makes them non-equivalent."}
{"example_id": 5039, "sql_complexity": "subqueries", "prompt": "What is the total number of community policing events in 'City Park' in 2021?", "context": "CREATE TABLE locations (id INT, name VARCHAR(255)); CREATE TABLE community_policing (id INT, location_id INT, year INT, events INT); INSERT INTO locations (id, name) VALUES (1, 'City Park'); INSERT INTO community_policing (id, location_id, year, events) VALUES (1, 1, 2021, 5);", "reference_sql": "SELECT SUM(events) FROM community_policing WHERE location_id = (SELECT id FROM locations WHERE name = 'City Park') AND year = 2021;", "generated_sql": "SELECT SUM(events) \nFROM community_policing cp \nJOIN locations l ON cp.location_id = l.id \nWHERE l.name = 'City Park' AND cp.year = 2021;", "raw_model_output": "```sql\nSELECT SUM(events) \nFROM community_policing cp \nJOIN locations l ON cp.location_id = l.id \nWHERE l.name = 'City Park' AND cp.year = 2021;\n```", "latency_sec": 11.072149991989136, "total_duration_sec": 10.958737574, "load_duration_sec": 0.025727615, "tokens_prompt": 351, "prompt_eval_sec": 7.538754647, "tokens_completion": 46, "completion_eval_sec": 3.389034272, "tokens_total": 397, "tokens_per_sec": 35.855728136562036, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries calculate the sum of events for 'City Park' in 2021. The reference query uses a subquery to get the location ID, while the generated query uses a JOIN to combine the tables. Both enforce the same filtering conditions (location name and year) and aggregate the same column. The semantic result is identical."}
{"example_id": 4932, "sql_complexity": "basic SQL", "prompt": "Delete the workout row with the id of 2.", "context": "CREATE TABLE Workouts (id INT, user_id INT, workout_name TEXT, calories INT); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (1, 1, 'Running', 300); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (2, 1, 'Cycling', 400); INSERT INTO Workouts (id, user_id, workout_name, calories) VALUES (3, 2, 'Yoga', 200);", "reference_sql": "DELETE FROM Workouts WHERE id = 2;", "generated_sql": "DELETE FROM Workouts WHERE id = 2;", "raw_model_output": "DELETE FROM Workouts WHERE id = 2;", "latency_sec": 6.693708181381226, "total_duration_sec": 6.570237343, "load_duration_sec": 0.022523857, "tokens_prompt": 282, "prompt_eval_sec": 5.793708567, "tokens_completion": 11, "completion_eval_sec": 0.751390736, "tokens_total": 293, "tokens_per_sec": 43.77244900143531, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic. They both delete the record with id = 2 from the Workouts table, resulting in the same database state change."}
{"example_id": 4637, "sql_complexity": "single join", "prompt": "What is the total value of transactions for each customer in the last 30 days?", "context": "CREATE TABLE transactions (id INT, customer_id INT, value DECIMAL(10, 2), transaction_date DATE); INSERT INTO transactions (id, customer_id, value, transaction_date) VALUES (1, 1, 100, '2022-01-01'), (2, 1, 200, '2022-01-15'), (3, 2, 50, '2022-01-05'), (4, 2, 150, '2022-01-30'), (5, 3, 300, '2022-01-20');", "reference_sql": "SELECT c.id, SUM(t.value) FROM customers c INNER JOIN transactions t ON c.id = t.customer_id WHERE t.transaction_date >= CURDATE() - INTERVAL 30 DAY GROUP BY c.id;", "generated_sql": "SELECT c.customer_id, SUM(t.value) AS total_value\nFROM customers c\nINNER JOIN transactions t ON c.customer_id = t.customer_id\nWHERE t.transaction_date >= DATEADD(day, -30, GETDATE())\nGROUP BY c.customer_id;", "raw_model_output": "```sql\nSELECT c.customer_id, SUM(t.value) AS total_value\nFROM customers c\nINNER JOIN transactions t ON c.customer_id = t.customer_id\nWHERE t.transaction_date >= DATEADD(day, -30, GETDATE())\nGROUP BY c.customer_id;\n```", "latency_sec": 14.117914199829102, "total_duration_sec": 13.961260405, "load_duration_sec": 0.022588074, "tokens_prompt": 427, "prompt_eval_sec": 9.694886503, "tokens_completion": 57, "completion_eval_sec": 4.241219079, "tokens_total": 484, "tokens_per_sec": 34.28268461964862, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in the selected columns (c.id vs c.customer_id) and date functions (CURDATE() - INTERVAL 30 DAY vs DATEADD(day, -30, GETDATE())). While the date logic may be semantically similar, the column name discrepancy means the result sets would differ. Additionally, the generated SQL uses SQL Server syntax (DATEADD/GETDATE) while the reference uses MySQL syntax (CURDATE)."}
{"example_id": 3704, "sql_complexity": "aggregation", "prompt": "What is the total sales revenue for each category of garments in the South America region in Q1 2022?", "context": "CREATE TABLE sales_category (sale_id INT, garment_category VARCHAR(50), sale_date DATE, total_sales DECIMAL(10, 2), region VARCHAR(50));", "reference_sql": "SELECT garment_category, SUM(total_sales) FROM sales_category WHERE sale_date BETWEEN '2022-01-01' AND '2022-03-31' AND region = 'South America' GROUP BY garment_category;", "generated_sql": "SELECT garment_category, SUM(total_sales) AS total_revenue \nFROM sales_category \nWHERE sale_date BETWEEN '2022-01-01' AND '2022-03-31' \nAND region = 'South America' \nGROUP BY garment_category;", "raw_model_output": "```sql\nSELECT garment_category, SUM(total_sales) AS total_revenue \nFROM sales_category \nWHERE sale_date BETWEEN '2022-01-01' AND '2022-03-31' \nAND region = 'South America' \nGROUP BY garment_category;\n```", "latency_sec": 13.806477069854736, "total_duration_sec": 13.559385468, "load_duration_sec": 0.023077577, "tokens_prompt": 394, "prompt_eval_sec": 8.691737098, "tokens_completion": 65, "completion_eval_sec": 4.841731755, "tokens_total": 459, "tokens_per_sec": 33.24526580369929, "match_exact": false, "match_ast": true, "llm_equivalent": true, "llm_explanation": "The queries are semantically equivalent. The generated query adds an alias 'total_revenue' to the SUM(total_sales) column, but this does not affect the actual data returned. Both queries filter on the same date range and region, group by the same column, and calculate the same aggregate value."}
{"example_id": 382, "sql_complexity": "window functions", "prompt": "What is the average annual precipitation in the past 10 years for each weather station?", "context": "CREATE TABLE WeatherStation (ID INT, Name VARCHAR(100), Location VARCHAR(100), Elevation FLOAT, AnnualPrecipitation FLOAT); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (1, 'Station A', 'Arctic Circle', 100, 450); INSERT INTO WeatherStation (ID, Name, Location, Elevation, AnnualPrecipitation) VALUES (2, 'Station B', 'North Pole', 200, 300);", "reference_sql": "SELECT Name, AVG(AnnualPrecipitation) OVER (PARTITION BY Name ORDER BY Name ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS AvgAnnualPrecipitation FROM WeatherStation WHERE YEAR(CurrentDate) - YEAR(DateInstalled) BETWEEN 1 AND 10;", "generated_sql": "SELECT Location, AVG(AnnualPrecipitation) AS avg_annual_precipitation\nFROM WeatherStation\nWHERE ID IN (SELECT ID FROM WeatherStation WHERE AnnualPrecipitation IS NOT NULL)\nGROUP BY Location;", "raw_model_output": "```sql\nSELECT Location, AVG(AnnualPrecipitation) AS avg_annual_precipitation\nFROM WeatherStation\nWHERE ID IN (SELECT ID FROM WeatherStation WHERE AnnualPrecipitation IS NOT NULL)\nGROUP BY Location;\n```\n\nThis SQL statement calculates the average annual precipitation for each weather station over the past 10 years. However, since the schema does not include a `date` column or any other temporal data to filter by time, we assume that the `AnnualPrecipitation` field already contains the relevant historical data. If you need to consider only records from the past 10 years, additional columns would be required in the schema.", "latency_sec": 19.267528295516968, "total_duration_sec": 19.235990412, "load_duration_sec": 0.027492564, "tokens_prompt": 401, "prompt_eval_sec": 8.932482212, "tokens_completion": 135, "completion_eval_sec": 10.273149438, "tokens_total": 536, "tokens_per_sec": 27.81882511233746, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The Reference SQL contains a WHERE clause referencing a non-existent 'DateInstalled' column, making it invalid. The Generated SQL filters using 'AnnualPrecipitation IS NOT NULL' and groups by 'Location', while the Reference SQL attempts to use a window function with 'Name' partitioning. The selected columns (Name vs Location) and aggregation methods (window function vs GROUP BY) differ significantly, leading to different results."}
{"example_id": 5168, "sql_complexity": "aggregation", "prompt": "Get the number of renewable energy projects in Australia for each project type.", "context": "CREATE TABLE renewable_projects (id INT PRIMARY KEY, project_name VARCHAR(255), project_location VARCHAR(255), project_type VARCHAR(255), capacity_mw FLOAT);", "reference_sql": "SELECT project_type, COUNT(*) FROM renewable_projects WHERE project_location = 'Australia' GROUP BY project_type;", "generated_sql": "SELECT project_type, COUNT(*) \nFROM renewable_projects \nWHERE country = 'Australia' \nGROUP BY project_type;", "raw_model_output": "```sql\nSELECT project_type, COUNT(*) \nFROM renewable_projects \nWHERE country = 'Australia' \nGROUP BY project_type;\n```", "latency_sec": 6.332050323486328, "total_duration_sec": 6.297369906, "load_duration_sec": 0.027197152, "tokens_prompt": 225, "prompt_eval_sec": 4.233209233, "tokens_completion": 28, "completion_eval_sec": 2.034490331, "tokens_total": 253, "tokens_per_sec": 39.95546261873392, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query filters using 'project_location = 'Australia'', while the generated query uses 'country = 'Australia''. The 'country' column does not exist in the renewable_projects table (only 'project_location' exists), making the generated query invalid and semantically different."}
{"example_id": 4669, "sql_complexity": "set operations", "prompt": "Identify the number of IoT devices in each country and the total number of devices.", "context": "CREATE TABLE device_country (device_id INT, country TEXT); INSERT INTO device_country (device_id, country) VALUES (1, 'USA'), (2, 'Canada'), (3, 'Mexico'), (4, 'Brazil'); CREATE TABLE device_info (device_id INT, device_type TEXT); INSERT INTO device_info (device_id, device_type) VALUES (1, 'Soil Sensor'), (2, 'Temperature Sensor'), (3, 'Humidity Sensor'), (4, 'Precision Sprayer');", "reference_sql": "SELECT country, COUNT(*) AS device_count FROM device_country GROUP BY country UNION SELECT 'Total' AS country, COUNT(*) FROM device_country;", "generated_sql": "SELECT \n    dc.country,\n    COUNT(di.device_id) AS num_devices\nFROM \n    device_country dc\nLEFT JOIN \n    device_info di ON dc.device_id = di.device_id\nGROUP BY \n    dc.country;", "raw_model_output": "```sql\nSELECT \n    dc.country,\n    COUNT(di.device_id) AS num_devices\nFROM \n    device_country dc\nLEFT JOIN \n    device_info di ON dc.device_id = di.device_id\nGROUP BY \n    dc.country;\n```", "latency_sec": 11.303128004074097, "total_duration_sec": 11.160125454, "load_duration_sec": 0.021747259, "tokens_prompt": 349, "prompt_eval_sec": 7.383982079, "tokens_completion": 51, "completion_eval_sec": 3.75205464, "tokens_total": 400, "tokens_per_sec": 35.38843405611474, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes a 'Total' row in its output via UNION, while the Generated SQL only returns country-specific counts without a total. Although both queries count devices per country correctly (due to 1:1 relationships in the data), the absence of the 'Total' row in the Generated SQL makes them semantically different."}
{"example_id": 4573, "sql_complexity": "subqueries", "prompt": "Find the names of all the indigenous communities in the 'Arctic_Communities' table that have a population size greater than the average population size in the 'Antarctic_Communities' table.", "context": "CREATE TABLE Arctic_Communities (name TEXT, population INTEGER); CREATE TABLE Antarctic_Communities (name TEXT, population INTEGER);", "reference_sql": "SELECT name FROM Arctic_Communities WHERE Arctic_Communities.population > (SELECT AVG(population) FROM Antarctic_Communities)", "generated_sql": "SELECT name FROM Arctic_Communities WHERE population > (SELECT AVG(population) FROM Antarctic_Communities);", "raw_model_output": "```sql\nSELECT name FROM Arctic_Communities WHERE population > (SELECT AVG(population) FROM Antarctic_Communities);\n```", "latency_sec": 8.50728988647461, "total_duration_sec": 8.223557833, "load_duration_sec": 0.025327621, "tokens_prompt": 305, "prompt_eval_sec": 6.386020002, "tokens_completion": 25, "completion_eval_sec": 1.809922902, "tokens_total": 330, "tokens_per_sec": 38.790261576092924, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries select names from Arctic_Communities where population exceeds the average population of Antarctic_Communities. The generated query omits the table alias in the WHERE clause, but since the column 'population' is unambiguous (only exists in Arctic_Communities), the semantic meaning remains identical."}
{"example_id": 3008, "sql_complexity": "multiple_joins", "prompt": "Who are the users who used electric vehicles and their trip details?", "context": "CREATE TABLE users (id INT, name VARCHAR(50), age INT, gender VARCHAR(10), city VARCHAR(50));CREATE TABLE vehicles (id INT, vehicle_type VARCHAR(20), is_electric BOOLEAN);CREATE TABLE trips (id INT, user_id INT, vehicle_id INT, trip_distance FLOAT, trip_duration INT, departure_time TIMESTAMP, arrival_time TIMESTAMP);INSERT INTO users (id, name, age, gender, city) VALUES (3, 'Alex', 30, 'Female', 'New York');INSERT INTO vehicles (id, vehicle_type, is_electric) VALUES (1, 'Tesla', true), (2, 'Bike', false);INSERT INTO trips (id, user_id, vehicle_id, trip_distance, trip_duration, departure_time, arrival_time) VALUES (3, 3, 1, 15.3, 25, '2022-01-03 12:00:00', '2022-01-03 12:25:00');", "reference_sql": "SELECT u.name, v.vehicle_type, t.trip_distance, t.trip_duration FROM users u JOIN trips t ON u.id = t.user_id JOIN vehicles v ON t.vehicle_id = v.id WHERE v.is_electric = true;", "generated_sql": "SELECT U.name, V.vehicle_type, T.trip_distance, T.trip_duration, T.departure_time, T.arrival_time \nFROM users U\nJOIN trips T ON U.id = T.user_id\nJOIN vehicles V ON T.vehicle_id = V.id\nWHERE V.is_electric = TRUE;", "raw_model_output": "```sql\nSELECT U.name, V.vehicle_type, T.trip_distance, T.trip_duration, T.departure_time, T.arrival_time \nFROM users U\nJOIN trips T ON U.id = T.user_id\nJOIN vehicles V ON T.vehicle_id = V.id\nWHERE V.is_electric = TRUE;\n```", "latency_sec": 15.676424026489258, "total_duration_sec": 15.6317651, "load_duration_sec": 0.030205096, "tokens_prompt": 468, "prompt_eval_sec": 10.730582238, "tokens_completion": 65, "completion_eval_sec": 4.868178861, "tokens_total": 533, "tokens_per_sec": 34.00010098600054, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The generated query includes additional columns (departure_time, arrival_time) in the SELECT clause that are not present in the reference query. While both queries join the same tables with identical conditions and filter on the same electric vehicle constraint, the extra columns make the result sets different."}
{"example_id": 1506, "sql_complexity": "basic SQL", "prompt": "How many habitats are in the 'animal_habitats' table?", "context": "CREATE TABLE animal_habitats (id INT PRIMARY KEY, habitat_name VARCHAR, num_animals INT);", "reference_sql": "SELECT COUNT(*) FROM animal_habitats;", "generated_sql": "SELECT COUNT(*) FROM animal_habitats;", "raw_model_output": "```sql\nSELECT COUNT(*) FROM animal_habitats;\n```", "latency_sec": 4.730154991149902, "total_duration_sec": 4.544002844, "load_duration_sec": 0.012967763, "tokens_prompt": 194, "prompt_eval_sec": 3.558745698, "tokens_completion": 14, "completion_eval_sec": 0.970125569, "tokens_total": 208, "tokens_per_sec": 43.973189121533444, "match_exact": true, "match_ast": true, "llm_equivalent": true, "llm_explanation": "Both queries are identical in structure and logic, selecting the count of all rows from the animal_habitats table. They will produce the same result."}
{"example_id": 4138, "sql_complexity": "window functions", "prompt": "How many lifelong learning courses has a student with ID '2' completed, in chronological order?", "context": "CREATE TABLE lifelong_learning (student_id INT, course_id INT, completion_date DATE); INSERT INTO lifelong_learning VALUES (2, 1001, '2015-01-01'), (2, 1002, '2016-01-01');", "reference_sql": "SELECT student_id, course_id, COUNT(course_id) OVER (PARTITION BY student_id ORDER BY completion_date) as completed_courses FROM lifelong_learning WHERE student_id = 2;", "generated_sql": "SELECT COUNT(course_id) OVER (ORDER BY completion_date) as completed_courses \nFROM lifelong_learning \nWHERE student_id = 2;", "raw_model_output": "```sql\nSELECT COUNT(course_id) OVER (ORDER BY completion_date) as completed_courses \nFROM lifelong_learning \nWHERE student_id = 2;\n```", "latency_sec": 9.92088508605957, "total_duration_sec": 9.758572977, "load_duration_sec": 0.028731327, "tokens_prompt": 344, "prompt_eval_sec": 7.36883677, "tokens_completion": 32, "completion_eval_sec": 2.358682952, "tokens_total": 376, "tokens_per_sec": 37.89984429195134, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries are not equivalent. The reference query returns student_id, course_id, and a cumulative count per student, while the generated query only returns the cumulative count without student_id/course_id. The window function in the generated query lacks a PARTITION BY clause, but since the WHERE clause filters student_id=2, the count value would match. However, the output columns differ, making the result sets structurally unequal."}
{"example_id": 5499, "sql_complexity": "set operations", "prompt": "How many legal aid clinics and community mediation centers are there in total, and what is the sum of cases handled by each type of center, for centers located in the state of California?", "context": "CREATE TABLE LegalAidClinics (ClinicName text, State text, NumCases int); INSERT INTO LegalAidClinics VALUES ('Clinic1', 'CA', 30, '2022-01-01'), ('Clinic2', 'CA', 25, '2022-01-01'); CREATE TABLE CommunityMediationCenters (CenterName text, State text, NumCases int); INSERT INTO CommunityMediationCenters VALUES ('CM1', 'CA', 22, '2022-01-01'), ('CM2', 'CA', 28, '2022-01-01');", "reference_sql": "SELECT State, 'Legal Aid Clinics' AS CenterType, COUNT(*) AS NumCenters, SUM(NumCases) AS TotalCases FROM LegalAidClinics WHERE State = 'CA' UNION ALL SELECT State, 'Community Mediation Centers', COUNT(*), SUM(NumCases) FROM CommunityMediationCenters WHERE State = 'CA';", "generated_sql": "SELECT \n    'Legal Aid Clinics' AS CenterType,\n    COUNT(ClinicName) AS NumberOfCenters,\n    SUM(NumCases) AS TotalCases\nFROM \n    LegalAidClinics\nWHERE \n    State = 'CA'\nUNION ALL\nSELECT \n    'Community Mediation Centers' AS CenterType,\n    COUNT(CenterName) AS NumberOfCenters,\n    SUM(NumCases) AS TotalCases\nFROM \n    CommunityMediationCenters\nWHERE \n    State = 'CA';", "raw_model_output": "```sql\nSELECT \n    'Legal Aid Clinics' AS CenterType,\n    COUNT(ClinicName) AS NumberOfCenters,\n    SUM(NumCases) AS TotalCases\nFROM \n    LegalAidClinics\nWHERE \n    State = 'CA'\nUNION ALL\nSELECT \n    'Community Mediation Centers' AS CenterType,\n    COUNT(CenterName) AS NumberOfCenters,\n    SUM(NumCases) AS TotalCases\nFROM \n    CommunityMediationCenters\nWHERE \n    State = 'CA';\n```", "latency_sec": 19.633633136749268, "total_duration_sec": 19.611970037, "load_duration_sec": 0.020999413, "tokens_prompt": 484, "prompt_eval_sec": 11.203698976, "tokens_completion": 112, "completion_eval_sec": 8.38469381, "tokens_total": 596, "tokens_per_sec": 30.35607296157717, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The Reference SQL includes the 'State' column in its output, while the Generated SQL omits it. Although both queries aggregate data for 'CA' states, the result sets differ in structure (4 columns vs. 3 columns). This structural difference makes them non-equivalent."}
{"example_id": 2265, "sql_complexity": "aggregation", "prompt": "Hourly revenue for a specific movie?", "context": "CREATE TABLE Movie_Revenue (id INT, movie_title VARCHAR(100), revenue_time TIME, revenue DECIMAL(10,2));", "reference_sql": "SELECT revenue_time, SUM(revenue) FROM Movie_Revenue WHERE movie_title = 'Spider-Man: No Way Home' GROUP BY revenue_time;", "generated_sql": "SELECT DATEPART(hh, revenue_time) as Hour_of_Day, SUM(revenue) as Total_Revenue \nFROM Movie_Revenue \nWHERE movie_title = 'Specific Movie' \nGROUP BY DATEPART(hh, revenue_time);", "raw_model_output": "```sql\nSELECT DATEPART(hh, revenue_time) as Hour_of_Day, SUM(revenue) as Total_Revenue \nFROM Movie_Revenue \nWHERE movie_title = 'Specific Movie' \nGROUP BY DATEPART(hh, revenue_time);\n```", "latency_sec": 9.129447937011719, "total_duration_sec": 8.850286968, "load_duration_sec": 0.023164293, "tokens_prompt": 248, "prompt_eval_sec": 4.948747495, "tokens_completion": 53, "completion_eval_sec": 3.876134792, "tokens_total": 301, "tokens_per_sec": 32.97023019099711, "match_exact": false, "match_ast": false, "llm_equivalent": false, "llm_explanation": "The queries differ in three key aspects: 1) The WHERE clause filters different movie titles ('Spider-Man: No Way Home' vs 'Specific Movie'), 2) The Reference groups by full revenue_time (TIME type) while the Generated groups by hour part (DATEPART(hh, ...)), and 3) The column names/select lists differ (revenue_time vs Hour_of_Day). These differences ensure distinct output structures and aggregation behaviors."}
{"example_id": 5792, "sql_complexity": "multiple_joins", "prompt": "How many cases were handled by attorneys in the 'Los Angeles' office?", "context": "CREATE TABLE offices (office_id INT, office_name VARCHAR(20), city VARCHAR(20), state VARCHAR(20)); INSERT INTO offices (office_id, office_name, city, state) VALUES (1, 'Boston', 'Boston', 'MA'), (2, 'New York', 'New York', 'NY'), (3, 'Los Angeles', 'Los Angeles', 'CA'); CREATE TABLE attorneys (attorney_id INT, office_id INT); INSERT INTO attorneys (attorney_id, office_id) VALUES (1, 1), (2, 2), (3, 3); CREATE TABLE cases (case_id INT, attorney_id INT); INSERT INTO cases (case_id, attorney_id) VALUES (1, 1), (2, 2), (3, 3);", "reference_sql": "SELECT COUNT(*) FROM cases JOIN attorneys ON cases.attorney_id = attorneys.attorney_id JOIN offices ON attorneys.office_id = offices.office_id WHERE offices.city = 'Los Angeles';", "generated_sql": "SELECT COUNT(*) AS cases_handled \nFROM cases \nINNER JOIN attorneys ON cases.attorney_id = attorneys.attorney_id \nINNER JOIN offices ON attorneys.office_id = offices.office_id \nWHERE offices.city = 'Los Angeles';", "raw_model_output": "```sql\nSELECT COUNT(*) AS cases_handled \nFROM cases \nINNER JOIN attorneys ON cases.attorney_id = attorneys.attorney_id \nINNER JOIN offices ON attorneys.office_id = offices.office_id \nWHERE offices.city = 'Los Angeles';\n```", "latency_sec": 12.299296140670776, "total_duration_sec": 12.171146213, "load_duration_sec": 0.015421914, "tokens_prompt": 385, "prompt_eval_sec": 8.463339197, "tokens_completion": 50, "completion_eval_sec": 3.689486942, "tokens_total": 435, "tokens_per_sec": 35.367877561835506, "match_exact": false, "match_ast": false, "llm_equivalent": true, "llm_explanation": "Both queries perform the same three-table join (cases \u2192 attorneys \u2192 offices) with identical join conditions and WHERE clause filtering on offices.city = 'Los Angeles'. The only difference is the aliasing of the COUNT(*) result in the Generated SQL, which does not affect the semantic output."}
